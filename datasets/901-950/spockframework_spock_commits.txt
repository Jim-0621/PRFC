File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -905,7 +905,7 @@ private void createFilterMethod() {
 
     MethodNode filterMethod = new MethodNode(
       InternalIdentifiers.getFilterName(filterBlock.getParent().getAst().getName()),
-      Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,
+      Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,
       ClassHelper.VOID_TYPE,
       dataProcessorVars
         .stream()

File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -675,7 +675,7 @@ private void turnIntoSimpleParameterization(List<Expression> column) throws Inva
 
         // otherwise generate the extractors and closure
         List<Statement> statements = new ArrayList<>();
-        List<String> referencedPreviousVariables = previousVariableAccesses.stream().map(VariableExpression::getName).collect(toList());
+        Set<String> referencedPreviousVariables = previousVariableAccesses.stream().map(VariableExpression::getName).collect(toSet());
         generatePreviousColumnExtractorStatements(referencedPreviousVariables, row, statements);
         ReturnStatement providerStatement = new ReturnStatement(providerExpression);
         providerStatement.setSourcePosition(providerExpression);
@@ -702,7 +702,7 @@ private void turnIntoSimpleParameterization(List<Expression> column) throws Inva
     rewriteSimpleParameterization(binExpr, varExpr, true);
   }
 
-  private void generatePreviousColumnExtractorStatements(List<String> referencedPreviousVariables, int row,
+  private void generatePreviousColumnExtractorStatements(Set<String> referencedPreviousVariables, int row,
                                                          List<Statement> statements) {
     for (String referencedPreviousVariable : referencedPreviousVariables) {
       statements.add(new ExpressionStatement(

File: spock-core/src/main/java/org/spockframework/runtime/ExtensionClassesLoader.java
Patch:
@@ -56,7 +56,7 @@ public <T> List<Class<? extends T>> loadClasses(String descriptorPath, Class<T>
 
   private Collection<URL> locateDescriptors(String descriptorPath) {
     try {
-      return ReflectionUtil.getResourcesFromClassLoaders(descriptorPath);
+      return ReflectionUtil.getResourcesFromClassLoader(descriptorPath);
     } catch (Exception e) {
       throw new ExtensionException("Failed to locate extension descriptors", e);
     }

File: spock-core/src/main/java/org/spockframework/compiler/AstUtil.java
Patch:
@@ -41,7 +41,6 @@
  */
 public abstract class AstUtil {
   private static final Pattern DATA_TABLE_SEPARATOR = Pattern.compile("_{2,}+");
-  private static final String GET_METHOD_NAME = "get";
   private static final String GET_AT_METHOD_NAME = new IntegerArrayGetAtMetaMethod().getName();
 
   /**

File: spock-core/src/main/java/org/spockframework/lang/SpecInternals.java
Patch:
@@ -324,8 +324,8 @@ private <T> T createMockImpl(String inferredName, Class<?> inferredType, T insta
       MockImplementation implementation, Map<String, Object> options, Class<?> specifiedType, Closure<?> closure) {
     Type effectiveType = specifiedType != null ? specifiedType : options.containsKey("type") ? (Type) options.get("type") : inferredType;
     if (effectiveType == null) {
-      throw new InvalidSpecException("Mock object type cannot be inferred automatically. " +
-          "Please specify a type explicitly (e.g. 'Mock(Person)').");
+      throw new InvalidSpecException(nature + " object type cannot be inferred automatically. " +
+          "Please specify a type explicitly (e.g. '" + nature + "(Person)').");
     }
     return createMock(inferredName, instance, effectiveType, nature, implementation, options, closure);
   }

File: spock-core/src/main/java/org/spockframework/mock/runtime/mockito/MockitoMockMakerImpl.java
Patch:
@@ -29,6 +29,7 @@
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.plugins.MockMaker;
 import org.mockito.plugins.MockitoPlugins;
+import org.spockframework.compiler.SpockNames;
 import org.spockframework.mock.*;
 import org.spockframework.mock.runtime.IMockMaker;
 import org.spockframework.mock.runtime.IProxyBasedMockInterceptor;
@@ -53,7 +54,7 @@ class MockitoMockMakerImpl {
 
   MockitoMockMakerImpl() {
     inlineMockMaker = resolveInlineMockMaker();
-    spockMockMethod = ReflectionUtil.getMethodByName(ISpockMockObject.class, "$spock_get");
+    spockMockMethod = ReflectionUtil.getMethodByName(ISpockMockObject.class, SpockNames.SPOCK_GET);
   }
 
   /**

File: spock-core/src/main/java/org/spockframework/runtime/IRunListener.java
Patch:
@@ -22,6 +22,7 @@
  * They do so by invoking <tt>SpecInfo.addListener()<tt>. See
  * {@link StepwiseExtension} for an example of how to use a listener.
  *
+ * @see org.spockframework.runtime.extension.IBlockListener
  * @author Peter Niederwieser
  */
 public interface IRunListener {

File: spock-core/src/main/java/org/spockframework/runtime/MasterRunSupervisor.java
Patch:
@@ -45,7 +45,7 @@ public void error(ErrorInfoCollector errorInfoCollector, ErrorInfo error) {
 
     exception = transform(exception);
 
-    ErrorInfo transformedError = new ErrorInfo(error.getMethod(), exception);
+    ErrorInfo transformedError = new ErrorInfo(error.getMethod(), exception, error.getErrorContext());
     if (exception instanceof TestAbortedException || exception instanceof TestSkippedException) {
       // Spock has no concept of "aborted tests", so we don't notify Spock listeners
     } else {
@@ -58,7 +58,7 @@ public void error(ErrorInfoCollector errorInfoCollector, ErrorInfo error) {
   private void handleMultipleFailures(ErrorInfoCollector errorInfoCollector,  ErrorInfo error) {
     MultipleFailuresError multiFailure = (MultipleFailuresError) error.getException();
     for (Throwable failure : multiFailure.getFailures())
-      error(errorInfoCollector, new ErrorInfo(error.getMethod(), failure));
+      error(errorInfoCollector, new ErrorInfo(error.getMethod(), failure, error.getErrorContext()));
   }
 
 

File: spock-spring/src/main/java/org/spockframework/spring/mock/SpockSpringProxyCreator.java
Patch:
@@ -22,16 +22,16 @@
 
 import java.util.List;
 
+import static java.util.Collections.emptyList;
 import static java.util.Collections.singletonList;
 
 abstract class SpockSpringProxyCreator {
 
   static Object create(FieldInfo fieldInfo) {
-    List<Class<?>> additionalInterfaces = singletonList(SpockSpringProxy.class);
     DelegatingInterceptor delegatingInterceptor = new DelegatingInterceptor(fieldInfo);
     MockCreationSettings settings = MockCreationSettings.settings(
       fieldInfo.getType(),
-      additionalInterfaces,
+      emptyList(),
       delegatingInterceptor,
       SpockSpringProxyCreator.class.getClassLoader(),
       true);

File: spock-core/src/main/java/org/spockframework/util/ReflectionUtil.java
Patch:
@@ -256,7 +256,7 @@ public static boolean isAssignable(Class<?> type, @Nullable Object arg) {
   }
 
   @SuppressWarnings("ConstantConditions")
-  private static Class<?> getWrapperType(Class<?> type) {
+  public static Class<?> getWrapperType(Class<?> type) {
     return type.isPrimitive() ? getDefaultValue(type).getClass()
                               : type;
   }

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -44,6 +44,8 @@ public class AstNodeCache {
   public final ClassNode SpecInternals = ClassHelper.makeWithoutCaching(SpecInternals.class);
   public final ClassNode MockController = ClassHelper.makeWithoutCaching(MockController.class);
   public final ClassNode SpecificationContext = ClassHelper.makeWithoutCaching(SpecificationContext.class);
+  public final ClassNode DataVariableMultiplication = ClassHelper.makeWithoutCaching(DataVariableMultiplication.class);
+  public final ClassNode DataVariableMultiplicationFactor = ClassHelper.makeWithoutCaching(DataVariableMultiplicationFactor.class);
 
   public final MethodNode SpecInternals_GetSpecificationContext =
       SpecInternals.getDeclaredMethods(Identifiers.GET_SPECIFICATION_CONTEXT).get(0);

File: spock-core/src/main/java/org/spockframework/runtime/extension/IIterationRunner.java
Patch:
@@ -5,6 +5,8 @@
 
 import java.util.concurrent.CompletableFuture;
 
+import static org.spockframework.runtime.DataIteratorFactory.UNKNOWN_ITERATIONS;
+
 /**
  * Interface for running an iteration of a test.
  *
@@ -26,7 +28,7 @@ public interface IIterationRunner {
    */
   @Deprecated
   default CompletableFuture<ExecutionResult> runIteration(Object[] args) {
-    return runIteration(args, -1);
+    return runIteration(args, UNKNOWN_ITERATIONS);
   }
 
   /**

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodKind.java
Patch:
@@ -30,6 +30,7 @@ public enum MethodKind {
   FEATURE,
   DATA_PROVIDER,
   DATA_PROCESSOR,
+  DATA_VARIABLE_MULTIPLICATIONS,
   SPEC_EXECUTION,
   FEATURE_EXECUTION,
   ITERATION_EXECUTION;

File: spock-core/src/main/java/org/spockframework/util/Identifiers.java
Patch:
@@ -54,9 +54,11 @@ public abstract class Identifiers {
    */
   public static final String WHERE = "where";
 
+  public static final String COMBINED = "combined";
+
   public static final String AND = "and";
 
-  public static final List<String> BLOCK_LABELS = asList(SETUP, GIVEN, EXPECT, WHEN, THEN, CLEANUP, WHERE, AND);
+  public static final List<String> BLOCK_LABELS = asList(SETUP, GIVEN, EXPECT, WHEN, THEN, CLEANUP, WHERE, COMBINED, AND);
 
   public static final String SETUP_METHOD = "setup";
 

File: spock-core/src/main/java/org/spockframework/util/Nullable.java
Patch:
@@ -20,6 +20,6 @@
  * Indicates that the annotated field, parameter, or return value of the
  * annotated method is allowed to be null.
  */
-@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
+@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD, ElementType.TYPE_USE})
 @Retention(RetentionPolicy.SOURCE)
 public @interface Nullable {}

File: spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java
Patch:
@@ -133,7 +133,7 @@ public static void verifyMethodCondition(ErrorCollector errorCollector, @Nullabl
 
   public static final String MATCH_COLLECTIONS_AS_SET = "matchCollectionsAsSet";
 
-  public static boolean matchCollectionsAsSet(Object left, Object right) {
+  public static Object matchCollectionsAsSet(Object left, Object right) {
     if (isIterableOrArray(left) && isIterableOrArray(right)) {
       Set<?> actual = GroovyRuntimeUtil.coerce(left, LinkedHashSet.class);
       Set<?> expected = GroovyRuntimeUtil.coerce(right, LinkedHashSet.class);
@@ -142,8 +142,7 @@ public static boolean matchCollectionsAsSet(Object left, Object right) {
       return (left == null) && (right == null);
     } else {
       Pattern pattern = Pattern.compile(String.valueOf(right));
-      java.util.regex.Matcher matcher = pattern.matcher(String.valueOf(left));
-      return matcher.find();
+      return pattern.matcher(String.valueOf(left));
     }
   }
 

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -15,6 +15,7 @@
 package org.spockframework.mock;
 
 import org.spockframework.util.ReflectionUtil;
+import org.spockframework.util.ThreadSafe;
 import spock.lang.Specification;
 
 import java.lang.reflect.*;
@@ -31,6 +32,7 @@
  * A response strategy that returns zero, an "empty" object, or a "dummy" object,
  * depending on the method's declared return type.
  */
+@ThreadSafe
 public class EmptyOrDummyResponse implements IDefaultResponse {
   public static final EmptyOrDummyResponse INSTANCE = new EmptyOrDummyResponse();
 
@@ -40,7 +42,7 @@ private EmptyOrDummyResponse() {}
   @SuppressWarnings("rawtypes")
   public Object respond(IMockInvocation invocation) {
     IMockInteraction interaction = DefaultJavaLangObjectInteractions.INSTANCE.match(invocation);
-    if (interaction != null) return interaction.accept(invocation);
+    if (interaction != null) return interaction.accept(invocation).get();
 
     Class<?> returnType = invocation.getMethod().getReturnType();
 

File: spock-core/src/main/java/org/spockframework/mock/IMockInteraction.java
Patch:
@@ -19,6 +19,7 @@
 import org.spockframework.util.Nullable;
 
 import java.util.List;
+import java.util.function.Supplier;
 
 /**
  * An anticipated interaction between the SUT and one or more mock objects.
@@ -34,8 +35,7 @@ public interface IMockInteraction {
 
   boolean matches(IMockInvocation invocation);
 
-  @Nullable
-  Object accept(IMockInvocation invocation);
+  Supplier<Object> accept(IMockInvocation invocation);
 
   List<IMockInvocation> getAcceptedInvocations();
 

File: spock-core/src/main/java/org/spockframework/mock/ZeroOrNullResponse.java
Patch:
@@ -20,6 +20,7 @@
  * A response strategy that returns zero, false, or null, depending on the method's return type.
  */
 @Beta
+@ThreadSafe
 public class ZeroOrNullResponse implements IDefaultResponse {
   public static final ZeroOrNullResponse INSTANCE = new ZeroOrNullResponse();
 
@@ -28,7 +29,7 @@ private ZeroOrNullResponse() {}
   @Override
   public Object respond(IMockInvocation invocation) {
     IMockInteraction interaction = DefaultJavaLangObjectInteractions.INSTANCE.match(invocation);
-    if (interaction != null) return interaction.accept(invocation);
+    if (interaction != null) return interaction.accept(invocation).get();
 
     Class<?> returnType = invocation.getMethod().getReturnType();
     return ReflectionUtil.getDefaultValue(returnType);

File: spock-core/src/main/java/org/spockframework/mock/response/ConstantResponseGenerator.java
Patch:
@@ -18,11 +18,13 @@
 
 import org.spockframework.mock.IMockInvocation;
 import org.spockframework.runtime.GroovyRuntimeUtil;
+import org.spockframework.util.ThreadSafe;
 
 /**
  *
  * @author Peter Niederwieser
  */
+@ThreadSafe
 public class ConstantResponseGenerator extends SingleResponseGenerator {
   private final Object constant;
 

File: spock-core/src/main/java/org/spockframework/mock/response/WildcardResponseGenerator.java
Patch:
@@ -17,6 +17,7 @@
 package org.spockframework.mock.response;
 
 import org.spockframework.mock.*;
+import org.spockframework.util.ThreadSafe;
 
 /**
  * Returns a value using {@code Stub} semantics (see  {@link EmptyOrDummyResponse}).
@@ -27,6 +28,7 @@
  * @author Peter Niederwieser
  * @author Leonard Brünings
  */
+@ThreadSafe
 public class WildcardResponseGenerator extends SingleResponseGenerator {
   @Override
   public Object doRespond(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/runtime/ByteBuddyMethodInvoker.java
Patch:
@@ -2,7 +2,9 @@
 
 import org.spockframework.mock.*;
 import org.spockframework.util.ExceptionUtil;
+import org.spockframework.util.ThreadSafe;
 
+@ThreadSafe
 public class ByteBuddyMethodInvoker implements IResponseGenerator {
 
   private final ByteBuddyInvoker superCall;

File: spock-core/src/main/java/org/spockframework/mock/runtime/CglibRealMethodInvoker.java
Patch:
@@ -18,7 +18,9 @@
 import org.spockframework.util.ExceptionUtil;
 
 import net.sf.cglib.proxy.MethodProxy;
+import org.spockframework.util.ThreadSafe;
 
+@ThreadSafe
 public class CglibRealMethodInvoker implements IResponseGenerator {
   private final MethodProxy methodProxy;
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/DefaultMethodInvoker.java
Patch:
@@ -20,13 +20,15 @@
 import org.spockframework.util.ExceptionUtil;
 import org.spockframework.util.Nullable;
 import org.spockframework.util.ReflectionUtil;
+import org.spockframework.util.ThreadSafe;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 
+@ThreadSafe
 public class DefaultMethodInvoker implements IResponseGenerator {
   @Nullable // Available since Java 17
   private static final Method INVOKE_DEFAULT = ReflectionUtil.getDeclaredMethodByName(InvocationHandler.class, "invokeDefault");

File: spock-core/src/main/java/org/spockframework/mock/runtime/FailingRealMethodInvoker.java
Patch:
@@ -15,7 +15,9 @@
 package org.spockframework.mock.runtime;
 
 import org.spockframework.mock.*;
+import org.spockframework.util.ThreadSafe;
 
+@ThreadSafe
 public class FailingRealMethodInvoker implements IResponseGenerator {
   private final String message;
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyRealMethodInvoker.java
Patch:
@@ -17,7 +17,9 @@
 import org.spockframework.mock.*;
 
 import groovy.lang.MetaClass;
+import org.spockframework.util.ThreadSafe;
 
+@ThreadSafe
 public class GroovyRealMethodInvoker implements IResponseGenerator {
   private final MetaClass metaClass;
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockInteractionDecorator.java
Patch:
@@ -17,6 +17,7 @@
 import org.spockframework.mock.*;
 
 import java.util.List;
+import java.util.function.Supplier;
 
 public abstract class MockInteractionDecorator implements IMockInteraction {
   protected final IMockInteraction decorated;
@@ -46,7 +47,7 @@ public boolean matches(IMockInvocation invocation) {
   }
 
   @Override
-  public Object accept(IMockInvocation invocation) {
+  public Supplier<Object> accept(IMockInvocation invocation) {
     return decorated.accept(invocation);
   }
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockInvocation.java
Patch:
@@ -58,17 +58,17 @@ public List<Object> getArguments() {
 
   @Override
   public Object callRealMethod() {
-    return realMethodInvoker.respond(this);
+    return realMethodInvoker.getResponseSupplier(this).get();
   }
 
   @Override
   public Object callRealMethodWithArgs(final Object... arguments) {
-      return realMethodInvoker.respond(new DelegatingMockInvocation(this) {
+      return realMethodInvoker.getResponseSupplier(new DelegatingMockInvocation(this) {
         @Override
         public List<Object> getArguments() {
           return asList(arguments);
         }
-      });
+      }).get();
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/mock/runtime/ObjectMethodInvoker.java
Patch:
@@ -1,7 +1,9 @@
 package org.spockframework.mock.runtime;
 
 import org.spockframework.mock.*;
+import org.spockframework.util.ThreadSafe;
 
+@ThreadSafe
 public class ObjectMethodInvoker implements IResponseGenerator {
 
   public static final ObjectMethodInvoker INSTANCE = new ObjectMethodInvoker();
@@ -13,7 +15,7 @@ private ObjectMethodInvoker() {
   public Object respond(IMockInvocation invocation) {
     IMockInteraction interaction = DefaultJavaLangObjectInteractions.INSTANCE.match(invocation);
     if (interaction != null) {
-      return interaction.accept(invocation);
+      return interaction.accept(invocation).get();
     }
 
     return null;

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UseExtension.java
Patch:
@@ -41,7 +41,6 @@ public void visitSpecAnnotations(List<Use> annotations, SpecInfo spec) {
   @Override
   public void visitFeatureAnnotations(List<Use> annotations, FeatureInfo feature) {
     addInterceptor(annotations, feature.getFeatureMethod());
-    feature.setExecutionMode(ExecutionMode.SAME_THREAD);
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/mock/IMockConfiguration.java
Patch:
@@ -1,6 +1,7 @@
 package org.spockframework.mock;
 
 import org.spockframework.mock.runtime.IMockMaker;
+import spock.mock.IMockMakerSettings;
 import org.spockframework.util.*;
 import spock.mock.MockingApi;
 
@@ -95,7 +96,7 @@ public interface IMockConfiguration {
    * @return the custom settings to use for the creation of the mock, or {@code null}
    */
   @Nullable
-  IMockMaker.IMockMakerSettings getMockMaker();
+  IMockMakerSettings getMockMaker();
 
   /**
    * Tells whether a mock object stands in for all objects of the mocked type, or just for itself.
@@ -106,7 +107,7 @@ public interface IMockConfiguration {
   boolean isGlobal();
 
   /**
-   * Tells whether invocations on the mock object should be verified. If (@code false}, invocations
+   * Tells whether invocations on the mock object should be verified. If {@code false}, invocations
    * on the mock object will not be matched against interactions that have a cardinality.
    *
    * @return whether invocations on the mock object should be verified

File: spock-core/src/main/java/org/spockframework/mock/runtime/ByteBuddyMockMaker.java
Patch:
@@ -20,6 +20,7 @@
 import org.spockframework.util.Nullable;
 import org.spockframework.util.ReflectionUtil;
 import org.spockframework.util.ThreadSafe;
+import spock.mock.MockMakerId;
 
 import java.util.Collections;
 import java.util.EnumSet;

File: spock-core/src/main/java/org/spockframework/mock/runtime/CglibMockMaker.java
Patch:
@@ -19,6 +19,7 @@
 import org.spockframework.mock.CannotCreateMockException;
 import org.spockframework.util.ReflectionUtil;
 import org.spockframework.util.ThreadSafe;
+import spock.mock.MockMakerId;
 import spock.util.environment.Jvm;
 
 import java.util.Collections;

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaProxyMockMaker.java
Patch:
@@ -19,6 +19,7 @@
 import org.spockframework.mock.CannotCreateMockException;
 import org.spockframework.mock.ISpockMockObject;
 import org.spockframework.util.ThreadSafe;
+import spock.mock.MockMakerId;
 
 import java.lang.reflect.Proxy;
 import java.util.ArrayList;

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockMakerConfiguration.java
Patch:
@@ -19,6 +19,7 @@
 import org.spockframework.util.Beta;
 import org.spockframework.util.Nullable;
 import spock.config.ConfigurationObject;
+import spock.mock.IMockMakerSettings;
 import spock.mock.MockMakers;
 
 /**
@@ -43,5 +44,5 @@ public class MockMakerConfiguration {
    * You can find the built-in mock makers in {@link MockMakers}.
    */
   @Nullable
-  public IMockMaker.IMockMakerSettings preferredMockMaker = null;
+  public IMockMakerSettings preferredMockMaker = null;
 }

File: spock-core/src/main/java/org/spockframework/mock/runtime/mockito/MockitoMockMaker.java
Patch:
@@ -21,6 +21,7 @@
 import org.spockframework.mock.runtime.IMockMaker;
 import org.spockframework.util.ReflectionUtil;
 import org.spockframework.util.ThreadSafe;
+import spock.mock.MockMakerId;
 
 import java.lang.reflect.Modifier;
 import java.util.Collections;

File: spock-core/src/main/java/org/spockframework/mock/runtime/mockito/MockitoMockMakerSettings.java
Patch:
@@ -18,15 +18,15 @@
 
 import groovy.lang.Closure;
 import org.mockito.MockSettings;
-import org.spockframework.mock.runtime.IMockMaker;
+import spock.mock.IMockMakerSettings;
+import spock.mock.MockMakerId;
 import org.spockframework.runtime.GroovyRuntimeUtil;
 import spock.mock.MockMakers;
 
 import static java.util.Objects.requireNonNull;
-import static org.spockframework.mock.runtime.IMockMaker.MockMakerId;
 import static org.spockframework.util.ObjectUtil.uncheckedCast;
 
-public final class MockitoMockMakerSettings implements IMockMaker.IMockMakerSettings {
+public final class MockitoMockMakerSettings implements IMockMakerSettings {
   private final Closure<?> mockitoCode;
 
   public static MockitoMockMakerSettings createSettings(Closure<?> mockitoCode) {

File: spock-core/src/main/java/org/spockframework/util/IThrowableFunction.java
Patch:
@@ -21,6 +21,7 @@
  *
  * @author Peter Niederwieser
  */
+@FunctionalInterface
 public interface IThrowableFunction<D, C, T extends Throwable> {
   C apply(D value) throws T;
 }

File: spock-core/src/main/java/org/spockframework/compiler/AstUtil.java
Patch:
@@ -222,7 +222,7 @@ private static List<Expression> asArgumentList(Expression arguments) {
       // return same result as for NamedArgumentListExpression wrapped in TupleExpression
       return singletonList(arguments);
 
-    return ((TupleExpression) arguments).getExpressions();
+    return (arguments == null) ? null : ((TupleExpression) arguments).getExpressions();
   }
 
   /**

File: spock-core/src/main/java/org/spockframework/runtime/PlatformSpecRunner.java
Patch:
@@ -184,8 +184,7 @@ public void runFeature(SpockExecutionContext context, Runnable feature) {
     if (currentFeature.isExcluded()) return;
 
     if (currentFeature.isSkipped()) {
-      supervisor.featureSkipped(currentFeature); // todo notify in node isSkipped
-      return;
+      throw new InternalSpockError("Invalid state, feature is executed although it should have been skipped");
     }
 
     supervisor.beforeFeature(currentFeature);

File: spock-core/src/main/java/org/spockframework/runtime/PlatformParameterizedSpecRunner.java
Patch:
@@ -44,7 +44,7 @@ void runParameterizedFeature(SpockExecutionContext context, ParameterizedFeature
     try (IDataIterator dataIterator = new DataIteratorFactory(supervisor).createFeatureDataIterator(context)) {
       IIterationRunner iterationRunner = createIterationRunner(context, childExecutor);
       IDataDriver dataDriver = feature.getDataDriver();
-      dataDriver.runIterations(dataIterator, iterationRunner, feature.getFeatureMethod().getParameters());
+      dataDriver.runIterations(dataIterator, iterationRunner, feature.getFeatureMethod().getParameters().subList(0, feature.getDataVariables().size()));
       childExecutor.awaitFinished();
     } catch (InterruptedException ie) {
       throw ie;
@@ -58,9 +58,9 @@ private IIterationRunner createIterationRunner(SpockExecutionContext context, Pa
       private final AtomicInteger iterationIndex = new AtomicInteger(0);
 
       @Override
-      public CompletableFuture<ExecutionResult> runIteration(Object[] args, int estimatedNumIterations) {
+      public CompletableFuture<ExecutionResult> runIteration(Object[] dataValues, int estimatedNumIterations) {
         int currIterationIndex = iterationIndex.getAndIncrement();
-        IterationInfo iterationInfo = createIterationInfo(context, currIterationIndex, args, estimatedNumIterations);
+        IterationInfo iterationInfo = createIterationInfo(context, currIterationIndex, dataValues, estimatedNumIterations);
         IterationNode iterationNode = new IterationNode(
           context.getParentId().append("iteration", String.valueOf(currIterationIndex)),
           context.getRunContext().getConfiguration(RunnerConfiguration.class), iterationInfo);

File: spock-core/src/main/java/org/spockframework/runtime/extension/IDataDriver.java
Patch:
@@ -50,14 +50,14 @@ public interface IDataDriver {
    *
    * @param dataIterator the data iterator giving access to the data from the data providers. The data iterator is not to be closed by this method.
    * @param iterationRunner the iteration runner that will be used to run the test method for each iteration.
-   * @param parameters the parameters of the test method
+   * @param parameters the parameters of the test method representing data variables
    */
   void runIterations(IDataIterator dataIterator, IIterationRunner iterationRunner, List<ParameterInfo> parameters);
 
   /**
-   * Prepares the arguments for invocation of the test method.
+   * Prepares the arguments for the data variables for invocation of the test method.
    * <p>
-   * It is possible to have fewer arguments produced by the data driver than the number of parameters.
+   * It is possible to have fewer arguments produced by the data driver than the number of data variables.
    * In this case, the missing arguments are filled with {@link MethodInfo#MISSING_ARGUMENT}.
    * <p>
    * Custom implementations of IDataDriver should use this method to prepare the argument array.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RepeatUntilFailureExtension.java
Patch:
@@ -36,9 +36,9 @@ public void runIterations(IDataIterator dataIterator, IIterationRunner iteration
       List<Object[]> data = new ArrayList<>(estimatedNumIterations);
       dataIterator.forEachRemaining(data::add);
       for (int attempt = 0; attempt < maxAttempts; attempt++) {
-        for (Object[] args : data) {
+        for (Object[] dataValues : data) {
           try {
-            ExecutionResult executionResult = iterationRunner.runIteration(args, maxIterations).get();
+            ExecutionResult executionResult = iterationRunner.runIteration(dataValues, maxIterations).get();
             if (executionResult == ExecutionResult.FAILED) {
               return;
             }

File: spock-core/src/main/java/org/spockframework/mock/runtime/CglibMockMaker.java
Patch:
@@ -47,7 +47,7 @@ public Set<MockMakerCapability> getCapabilities() {
 
   @Override
   public int getPriority() {
-    return 300;
+    return 400;
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaProxyMockInterceptorAdapter.java
Patch:
@@ -19,10 +19,10 @@
 
 import java.lang.reflect.*;
 
-public class DynamicProxyMockInterceptorAdapter implements InvocationHandler {
+public class JavaProxyMockInterceptorAdapter implements InvocationHandler {
   private final IProxyBasedMockInterceptor interceptor;
 
-  public DynamicProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {
+  public JavaProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {
     this.interceptor = interceptor;
   }
 

File: spock-core/src/main/java/org/spockframework/builder/CollectionSlot.java
Patch:
@@ -14,7 +14,6 @@
 
 package org.spockframework.builder;
 
-import org.spockframework.gentyref.GenericTypeReflector;
 import org.spockframework.util.*;
 
 import java.lang.reflect.*;
@@ -45,10 +44,10 @@ public Type getType() {
 
   private Type getCollectionType() {
      Method getter = MopUtil.getterFor(property);
-    if (getter != null) return GenericTypeReflector.getExactReturnType(getter, ownerType);
+    if (getter != null) return GenericTypeReflectorUtil.getReturnType(getter, ownerType);
 
     Field field = MopUtil.fieldFor(property);
-    if (field != null) return GenericTypeReflector.getExactFieldType(field, ownerType);
+    if (field != null) return GenericTypeReflectorUtil.getExactFieldType(field, ownerType);
 
     throw new UnreachableCodeError();
   }

File: spock-core/src/main/java/org/spockframework/builder/PojoGestalt.java
Patch:
@@ -17,7 +17,7 @@
 import java.lang.reflect.Type;
 import java.util.List;
 
-import org.spockframework.gentyref.GenericTypeReflector;
+import org.spockframework.util.GenericTypeReflectorUtil;
 import org.spockframework.runtime.GroovyRuntimeUtil;
 import org.spockframework.util.CollectionUtil;
 
@@ -92,7 +92,7 @@ private PojoGestalt createGestalt(Type newType, Object[] args) {
       args = CollectionUtil.copyArray(args, 0, args.length - 1);
     }
 
-    Class<?> newClazz = GenericTypeReflector.erase(newType); // TODO: check that this succeeds (Type could be a TypeVariable etc.)
+    Class<?> newClazz = GenericTypeReflectorUtil.erase(newType); // TODO: check that this succeeds (Type could be a TypeVariable etc.)
     Object newPojo = BuilderHelper.createInstance(newClazz, args);
     ClosureBlueprint newBlueprint = closure == null ? null : new ClosureBlueprint(closure, newPojo);
     return new PojoGestalt(newPojo, newType, newBlueprint, slotFactories);

File: spock-core/src/main/java/org/spockframework/builder/PropertySlot.java
Patch:
@@ -14,7 +14,6 @@
 
 package org.spockframework.builder;
 
-import org.spockframework.gentyref.GenericTypeReflector;
 import org.spockframework.util.*;
 
 import java.lang.reflect.*;
@@ -37,10 +36,10 @@ public Type getType() {
     // could possibly add fast path here, but be careful (inner classes etc.)
 
     Method setter = MopUtil.setterFor(property);
-    if (setter != null) return GenericTypeReflector.getExactParameterTypes(setter, ownerType)[0];
+    if (setter != null) return GenericTypeReflectorUtil.getParameterTypes(setter, ownerType)[0];
 
     Field field = MopUtil.fieldFor(property);
-    if (field != null) return GenericTypeReflector.getExactFieldType(field, ownerType);
+    if (field != null) return GenericTypeReflectorUtil.getExactFieldType(field, ownerType);
 
     throw new UnreachableCodeError();
   }

File: spock-core/src/main/java/org/spockframework/builder/SetterLikeSlot.java
Patch:
@@ -14,7 +14,7 @@
 
 package org.spockframework.builder;
 
-import org.spockframework.gentyref.GenericTypeReflector;
+import org.spockframework.util.GenericTypeReflectorUtil;
 import org.spockframework.runtime.GroovyRuntimeUtil;
 import org.spockframework.util.MopUtil;
 
@@ -36,7 +36,7 @@ public SetterLikeSlot(Object owner, Type ownerType, MetaMethod setterLikeMethod)
   @Override
   public Type getType() {
     Method m = MopUtil.methodFor(setterLikeMethod);
-    return m != null ? GenericTypeReflector.getExactParameterTypes(m, ownerType)[0] :
+    return m != null ? GenericTypeReflectorUtil.getParameterTypes(m, ownerType)[0] :
         setterLikeMethod.getNativeParameterTypes()[0];
   }
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicMockMethod.java
Patch:
@@ -14,7 +14,7 @@
 
 package org.spockframework.mock.runtime;
 
-import org.spockframework.gentyref.GenericTypeReflector;
+import org.spockframework.util.GenericTypeReflectorUtil;
 import org.spockframework.mock.IMockMethod;
 import org.spockframework.util.ReflectionUtil;
 
@@ -55,7 +55,7 @@ public List<Type> getExactParameterTypes() {
 
   @Override
   public Class<?> getReturnType() {
-    return GenericTypeReflector.erase(returnType);
+    return GenericTypeReflectorUtil.erase(returnType);
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockConfiguration.java
Patch:
@@ -14,7 +14,6 @@
 
 package org.spockframework.mock.runtime;
 
-import org.spockframework.gentyref.GenericTypeReflector;
 import org.spockframework.mock.*;
 import org.spockframework.util.*;
 
@@ -67,7 +66,7 @@ public String getName() {
 
   @Override
   public Class<?> getType() {
-    return GenericTypeReflector.erase(type);
+    return GenericTypeReflectorUtil.erase(type);
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockObject.java
Patch:
@@ -14,7 +14,7 @@
 
 package org.spockframework.mock.runtime;
 
-import org.spockframework.gentyref.GenericTypeReflector;
+import org.spockframework.util.GenericTypeReflectorUtil;
 import org.spockframework.lang.Wildcard;
 import org.spockframework.mock.*;
 import org.spockframework.runtime.InvalidSpecException;
@@ -54,7 +54,7 @@ public String getName() {
 
   @Override
   public Class<?> getType() {
-    return GenericTypeReflector.erase(type);
+    return GenericTypeReflectorUtil.erase(type);
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/util/ReflectionUtil.java
Patch:
@@ -16,8 +16,6 @@
 
 import static java.util.Arrays.asList;
 
-import org.spockframework.gentyref.GenericTypeReflector;
-
 import java.io.File;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.*;
@@ -241,7 +239,7 @@ private static Class<?> getWrapperType(Class<?> type) {
   public static List<Class<?>> eraseTypes(List<Type> types) {
     List<Class<?>> result = new ArrayList<>();
     for (Type type : types) {
-      result.add(GenericTypeReflector.erase(type));
+      result.add(GenericTypeReflectorUtil.erase(type));
     }
     return result;
   }

File: spock-core/src/main/java/spock/util/concurrent/PollingConditions.java
Patch:
@@ -41,7 +41,7 @@
  * }
  * </pre>
  *
- * Warning! Avoiding assert keyword in the clojure is only possible if the conditions object type is known
+ * Warning! Avoiding assert keyword in the closure is only possible if the conditions object type is known
  * during compilation (no "def" on the left side):
  * <pre>
  *   PollingConditions conditions = new PollingConditions(timeout: 10, initialDelay: 1.5, factor: 1.25)

File: spock-core/src/main/java/org/spockframework/mock/CannotCreateMockException.java
Patch:
@@ -32,6 +32,6 @@ public CannotCreateMockException(Class<?> mockType, Throwable cause) {
   }
 
   public CannotCreateMockException(Class<?> mockType, String message, Throwable cause) {
-    super(String.format("Cannot create mock for %s %s", mockType, message), cause);
+    super(String.format("Cannot create mock for %s%s", mockType, message), cause);
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/PlatformParameterizedSpecRunner.java
Patch:
@@ -58,9 +58,9 @@ private IIterationRunner createIterationRunner(SpockExecutionContext context, Pa
       private final AtomicInteger iterationIndex = new AtomicInteger(0);
 
       @Override
-      public CompletableFuture<ExecutionResult> runIteration(Object[] args) {
+      public CompletableFuture<ExecutionResult> runIteration(Object[] args, int estimatedNumIterations) {
         int currIterationIndex = iterationIndex.getAndIncrement();
-        IterationInfo iterationInfo = createIterationInfo(context, currIterationIndex, args, -1);
+        IterationInfo iterationInfo = createIterationInfo(context, currIterationIndex, args, estimatedNumIterations);
         IterationNode iterationNode = new IterationNode(
           context.getParentId().append("iteration", String.valueOf(currIterationIndex)),
           context.getRunContext().getConfiguration(RunnerConfiguration.class), iterationInfo);

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodInfo.java
Patch:
@@ -143,7 +143,7 @@ public Object invoke(Object target, Object... arguments) throws Throwable {
       if (arguments[i] == MISSING_ARGUMENT) {
         Function<Integer, String> nameProvider = getNameProvider();
 
-        StringJoiner missingArguments = new StringJoiner("', '", "No argument was provided for parameters: '", "'");
+        StringJoiner missingArguments = new StringJoiner("', '", "No argument was provided for parameters: '", "' in method: '" + getReflection().getDeclaringClass().getName()+ "." + getName() + "'");
         missingArguments.add(nameProvider.apply(i));
         for (int j = i + 1; j < argCount; j++) {
           if (arguments[j] == MISSING_ARGUMENT) {

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicProxyMockInterceptorAdapter.java
Patch:
@@ -28,8 +28,10 @@ public DynamicProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor
 
   @Override
   public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {
-    IResponseGenerator realMethodInvoker = (method.isDefault() || ReflectionUtil.isObjectMethod(method))
+    IResponseGenerator realMethodInvoker = method.isDefault()
       ? new DefaultMethodInvoker(target, method, arguments)
+      : ReflectionUtil.isObjectMethod(method)
+      ? ObjectMethodInvoker.INSTANCE
       : new FailingRealMethodInvoker("Cannot invoke real method '" + method.getName() + "' on interface based mock object");
     return interceptor.intercept(target, method, arguments, realMethodInvoker);
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TempDirExtension.java
Patch:
@@ -41,10 +41,10 @@ public void visitFieldAnnotation(TempDir annotation, FieldInfo field) {
   }
 
   private IThrowableFunction<Path, ?, Exception> createPathToFieldTypeMapper(Class<?> fieldType) {
-    if (Path.class.isAssignableFrom(fieldType) || Object.class.equals(fieldType)) {
+    if (fieldType.isAssignableFrom(Path.class) || Object.class.equals(fieldType)) {
       return p -> p;
     }
-    if (File.class.isAssignableFrom(fieldType)) {
+    if (fieldType.isAssignableFrom(File.class)) {
       return Path::toFile;
     }
 

File: spock-core/src/main/groovy/spock/util/Exceptions.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/AddSlotFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/BuilderHelper.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,7 +30,7 @@ public static Object createInstance(Class clazz, Object... args) {
     }
 
     // IDEA: could support creation of collection types here
-    
+
     if ((clazz.getModifiers() & Modifier.ABSTRACT) != 0) {
       String kind = clazz.isPrimitive() ? "primitive" : clazz.isInterface() ? "interface" : "abstract";
       throw new RuntimeException(String.format( "Cannot instantiate %s type %s", kind, clazz.getName()));

File: spock-core/src/main/java/org/spockframework/builder/ClosureBlueprint.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/CollectionSlot.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/CollectionSlotFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/DelegatingScript.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ public Object getProperty(String property) {
     try {
       return GroovyRuntimeUtil.getProperty($delegate, property);
     } catch (MissingPropertyException e) {
-      return super.getProperty(property);   
+      return super.getProperty(property);
     }
   }
 

File: spock-core/src/main/java/org/spockframework/builder/DelegatingScriptBlueprint.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/GestaltBuilder.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/IBlueprint.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,6 +21,6 @@ public interface IBlueprint {
   Object getThisObject();
 
   void setDelegate(Object delegate);
-  
+
   void evaluate();
-}
\ No newline at end of file
+}

File: spock-core/src/main/java/org/spockframework/builder/IGestalt.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/ISlot.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,4 +19,4 @@
 public interface ISlot {
   Type getType();
   void write(Object value);
-}
\ No newline at end of file
+}

File: spock-core/src/main/java/org/spockframework/builder/ISlotFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,4 +20,4 @@
 
 public interface ISlotFactory {
   @Nullable ISlot create(Object owner, Type ownerType, String name);
-}
\ No newline at end of file
+}

File: spock-core/src/main/java/org/spockframework/builder/PojoBuilder.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/PojoGestalt.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/PropertySlot.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/Sculpturer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/SetterLikeSlot.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/SetterSlotFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/builder/SpockConfigurationGestalt.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/buildsupport/AsmClassReader.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/buildsupport/EmptyAnnotationVisitor.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/buildsupport/SpecClassFileFinder.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/buildsupport/SpecClassFileVisitor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compat/groovy2/GroovyCodeVisitorCompat.java
Patch:
@@ -7,7 +7,7 @@
  *  "License"); you may not use this file except in compliance
  *  with the License.  You may obtain a copy of the License at
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ *    https://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing,
  *  software distributed under the License is distributed on an

File: spock-core/src/main/java/org/spockframework/compiler/AbstractDeepBlockRewriter.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/compiler/AbstractSpecVisitor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/AstUtil.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -320,7 +320,6 @@ public static boolean isJointCompiled(ClassNode clazz) {
 
   public static MethodCallExpression createMethodCall(Expression target, String methodName, Expression arguments) {
     MethodCallExpression result = new MethodCallExpression(target, methodName, arguments);
-    // see http://groovy.329449.n5.nabble.com/Problem-with-latest-2-0-beta-3-snapshot-and-Spock-td5496353.html
     // and https://github.com/spockframework/spock/issues/1200
     // and https://issues.apache.org/jira/browse/GROOVY-9651
     result.setImplicitThis(false);

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -419,7 +419,7 @@ public void visitSpreadExpression(SpreadExpression expr) {
   @Override
   public void visitSpreadMapExpression(SpreadMapExpression expr) {
     // to not record the underlying MapExpression twice, we do nothing here
-    // see http://jira.codehaus.org/browse/GROOVY-3421
+    // see https://jira.codehaus.org/browse/GROOVY-3421
     result = recordNa(expr);
   }
 

File: spock-core/src/main/java/org/spockframework/compiler/DeepBlockRewriter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/ErrorReporter.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/compiler/ErrorRethrowerUsageDetector.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/ExpressionReplacingVisitorSupport.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/FieldInitializationExpression.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -27,11 +27,11 @@
  * initializer expression. The purpose of this class is to make field
  * initializations distinguishable from other assignments while traversing
  * the AST.
- * 
+ *
  * @author Peter Niederwieser
  */
 public class FieldInitializationExpression extends BinaryExpression {
   public FieldInitializationExpression(FieldNode field) {
     super(new FieldExpression(field), Token.newSymbol(Types.ASSIGN, -1, -1), field.getInitialValueExpression());
   }
-}
\ No newline at end of file
+}

File: spock-core/src/main/java/org/spockframework/compiler/IRewriteResources.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/ISpecialMethodCall.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/compiler/InstanceFieldAccessChecker.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/InteractionRewriter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/InvalidSpecCompileException.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -28,7 +28,7 @@
  *
  * Most of the time it is not necessary to use this class directly (see
  * documentation of class ErrorReporter).
- * 
+ *
  * @author Peter Niederwieser
  */
 public class InvalidSpecCompileException extends SyntaxException {

File: spock-core/src/main/java/org/spockframework/compiler/NoSpecialMethodCall.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/compiler/OldValueExpression.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,7 +23,7 @@
  * Used to represent the argument to Specification.old() once it has been processed
  * by IRewriteResources.captureOldValue(). The original expression is
  * kept in case ConditionRewriter still needs it.
- * 
+ *
  * @author Peter Niederwieser
  */
 public class OldValueExpression extends VariableExpression {

File: spock-core/src/main/java/org/spockframework/compiler/SourceLookup.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/SpecAnnotator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/SpecParser.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -187,7 +187,7 @@ private void createSharedFieldSetter(Field field) {
   }
 
   // we try to use the visibility of the original field, but change
-  // private to protected to solve http://issues.spockframework.org/detail?id=151
+  // private to protected to solve https://github.com/spockframework/spock/issues/273
   private int determineVisibilityForSharedFieldAccessor(Field field) {
     if (field.getOwner() == null) { // true field
       int visibility = AstUtil.getVisibility(field.getAst());

File: spock-core/src/main/java/org/spockframework/compiler/SpecialMethodCall.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/compiler/SpockTransform.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/StatementReplacingVisitorSupport.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -66,7 +66,7 @@ protected void replaceVisitedStatementWith(Statement other) {
     replacement = other;
   }
 
-  @SuppressWarnings("unchecked")  
+  @SuppressWarnings("unchecked")
   @Override
   public void visitBlockStatement(BlockStatement stat) {
     replaceAll(stat.getStatements());

File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/AnonymousBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/Block.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/BlockParseInfo.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/CleanupBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/ExpectBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/FeatureMethod.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/Field.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/FixtureMethod.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/HelperMethod.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/ISpecVisitor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/Method.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/Node.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/SetupBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/Spec.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/ThenBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/WhenBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/compiler/model/WhereBlock.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/gentyref/GenericTypeReflector.java
Patch:
@@ -299,7 +299,7 @@ private static Type[] getExactDirectSuperTypes(Type type) {
 	}
 
 	private static Type[] getArrayExactDirectSuperTypes(Type arrayType) {
-		// see http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10.3
+		// see https://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10.3
 		Type typeComponent = getArrayComponentType(arrayType);
 
 		Type[] result;

File: spock-core/src/main/java/org/spockframework/lang/ConditionBlock.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/lang/ISpecificationContext.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/lang/SpecInternals.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/lang/SpreadWildcard.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/lang/Wildcard.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/CallRealMethodResponse.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/CannotCreateMockException.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/CannotInvokeRealMethodException.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/DefaultEqualsInteraction.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/DefaultFinalizeInteraction.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/DefaultHashCodeInteraction.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/DefaultInteraction.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/DefaultJavaLangObjectInteractions.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/DefaultToStringInteraction.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/IArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IChainableResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IDefaultResponse.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IInteractionAware.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IInteractionScope.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IInvocationConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IMockController.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IMockFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/IMockInteraction.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IMockInvocation.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/IMockMethod.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/IMockObject.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/IResponseGenerator.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/ISpockMockObject.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/InteractionNotSatisfiedError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/MockImplementation.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/MockNature.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/MockUtil.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/TooFewInvocationsError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/TooManyInvocationsError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/WrongInvocationOrderError.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/ZeroOrNullResponse.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/constraint/CodeArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/EqualArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/EqualMethodNameConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/EqualPropertyNameConstraint.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/constraint/NamedArgumentListConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/NegatingArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/PositionalArgumentListConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/RegexMethodNameConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/RegexPropertyNameConstraint.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/constraint/SpreadWildcardArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/TargetConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/TypeArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/WildcardArgumentConstraint.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/constraint/WildcardMethodNameConstraint.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/package-info.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -17,4 +17,4 @@
 /**
  * Spock's built-in mocking framework.
  */
-package org.spockframework.mock;
\ No newline at end of file
+package org.spockframework.mock;

File: spock-core/src/main/java/org/spockframework/mock/response/CodeResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/response/ConstantResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/response/DefaultResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/response/IterableResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/response/ResponseGeneratorChain.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/response/SingleResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/response/WildcardResponseGenerator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/CglibMockInterceptorAdapter.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/CglibRealMethodInvoker.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/CompositeMockFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/DefaultMethodInvoker.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/DelegatingMockInvocation.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicMockMethod.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicProxyMockInterceptorAdapter.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/FailingRealMethodInvoker.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockInterceptor.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockMetaClass.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyRealMethodInvoker.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/IProxyBasedMockInterceptor.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/InteractionBuilder.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/InteractionScope.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaMockFactory.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaMockInterceptor.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockConfiguration.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockController.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockInstantiator.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockInteraction.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockInteractionDecorator.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockInvocation.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockObject.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/mock/runtime/ProxyBasedMockFactory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@
 /**
  * Some implementation details of this class and the classes it references are inspired from Spring, EasyMock
  * Class Extensions, JMock, Mockito, and this thread:
- * http://www.nabble.com/Callbacks%2C-classes-and-instances-to4092596.html
+ * https://www.nabble.com/Callbacks%2C-classes-and-instances-to4092596.html
  *
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/org/spockframework/mock/runtime/StaticMockMethod.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/report/log/ReportLogConfiguration.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/AbstractRunListener.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/AsyncRunListener.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/AsyncStandardStreamsListener.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/Condition.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/ConditionNotSatisfiedError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/ConfigurationBuilder.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/ConfigurationScriptLoader.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/DataVariablesIterationNameProvider.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/DummyStackTraceFilter.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoBuilder.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoConverter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoRenderer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoValueRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/ExtensionClassesLoader.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/ExtensionRunner.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/GlobalExtensionRegistry.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/GroovyRuntimeUtil.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -108,7 +108,7 @@ public static String propertyToMethodName(String prefix, String propertyName) {
    * This method differs from Groovy 1.6.8 in that the latter
    * doesn't support the "is" prefix for static boolean properties;
    * however, that seems more like a bug.
-   * See http://jira.codehaus.org/browse/GROOVY-4206
+   * See https://jira.codehaus.org/browse/GROOVY-4206
    */
   @Nullable
   public static String getterMethodToPropertyName(String methodName, List<Class<?>> parameterTypes, Class<?> returnType) {
@@ -268,7 +268,7 @@ public static boolean isVoidMethod(@Nullable Object target, String method, Objec
     // from java.lang.Object, and since we operate on a best effort basis, that's OK
     // also we will choose a static method like Foo.getName() over the equally
     // named method on java.lang.Class, but this is consistent with current Groovy semantics
-    // (see http://jira.codehaus.org/browse/GROOVY-3548)
+    // (see https://jira.codehaus.org/browse/GROOVY-3548)
     // in the end it's probably best to rely on NullAwareInvokeMethodSpec to tell us if
     // everything is OK
     MetaClass metaClass = target instanceof Class ?

File: spock-core/src/main/java/org/spockframework/runtime/HamcrestFacade.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/IConfigurationRegistry.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/IExtensionRegistry.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/IFeatureFilter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/IFeatureSortOrder.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/IMethodNameMapper.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/IRunListener.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -71,7 +71,7 @@ public interface IRunListener {
   // IDEA: might be able to remove remaining two methods and
   // call before/after instead, since skip flag should be set on
   // SpecInfo/FeatureInfo anyway
-  
+
   /**
    * Called if a spec is skipped, for example because it is marked
    * with @Ignore.

File: spock-core/src/main/java/org/spockframework/runtime/IRunSupervisor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/IStackTraceFilter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/IStandardStreamsListener.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -19,4 +19,4 @@
 public interface IStandardStreamsListener {
   void standardOut(String message);
   void standardErr(String message);
-}
\ No newline at end of file
+}

File: spock-core/src/main/java/org/spockframework/runtime/InvalidSpecException.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/MasterRunListener.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/PlatformParameterizedSpecRunner.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/PlatformSpecRunner.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/RunContext.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/RunStatus.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/SafeIterationNameProvider.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/SpecInfoBuilder.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/SpecRunHistory.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/SpecUtil.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/SpockAssertionError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/SpockComparisonFailure.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/SpockExecutionException.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/SpockTimeoutError.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/StackTraceFilter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/StandardStreamsCapturer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/ValueRecorder.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/WrongExceptionThrownError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedArrayRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedClassRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedCollectionRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedMapRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedObjectAsBeanRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedObjectAsStringRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedSetRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/EditDistance.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +20,7 @@
 
 /**
  * Calculates Levenshtein distance and corresponding edit path between two character sequences.
- * Inspired from: http://etorreborre.blogspot.com/2008/06/edit-distance-in-scala_245.html
+ * Inspired from: https://etorreborre.blogspot.com/2008/06/edit-distance-in-scala_245.html
  *
  * Ideas for improvements:
  * - Favor fewer EditOperationS when calculating distance and/or path

File: spock-core/src/main/java/org/spockframework/runtime/condition/EditOperation.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/EditPathRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -59,7 +59,7 @@ public String render(CharSequence seq1, CharSequence seq2, List<EditOperation> o
             String part2 = TextUtil.escape(seq2.charAt(index2++));
             line1.append(part1);
             line2.append(part2);
-            if (part1.length() < part2.length()) line1.append('~'); 
+            if (part1.length() < part2.length()) line1.append('~');
             else if (part2.length() < part1.length()) line2.append('~');
           }
           break;

File: spock-core/src/main/java/org/spockframework/runtime/condition/IObjectRenderer.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/IObjectRendererService.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/LineBuilder.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/condition/ObjectRendererService.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/AbstractAnnotationDrivenExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/AbstractGlobalExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/AbstractMethodInterceptor.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/ExtensionAnnotation.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/ExtensionException.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/ExtensionUtil.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/IAnnotationDrivenExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/IGlobalExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/IMethodInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/IMethodInvocation.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/MethodInvocation.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/RepeatedExtensionAnnotations.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/AutoCleanupExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/AutoCleanupInterceptor.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ConditionalExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ConfineMetaClassChangesExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ConfineMetaClassChangesInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/FailsWithExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/FailsWithInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IgnoreExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IgnoreIfExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IgnoreRestExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IncludeExcludeExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IssueExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/NarrativeExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/OptimizeRunOrderExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/PreconditionContext.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RequiresExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RestoreSystemPropertiesExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RestoreSystemPropertiesInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryBaseInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryFeatureInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryIterationInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RevertMetaClassRunListener.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/StepwiseExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TimeoutExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TimeoutInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TitleExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UnrollConfiguration.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UnrollExtension.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UnrollIterationNameProvider.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UseExtension.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UseInterceptor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/Attachment.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/BlockInfo.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/BlockKind.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,7 +18,7 @@
 
 /**
  * The different kind of blocks that a <tt>BlockInfo</tt> instance can represent.
- * 
+ *
  * @author Peter Niederwieser
  */
 public enum BlockKind {

File: spock-core/src/main/java/org/spockframework/runtime/model/BlockMetadata.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/ErrorInfo.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/model/ExpressionInfo.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/FeatureMetadata.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/FieldInfo.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/FieldMetadata.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/IAttachmentContainer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/IExcludable.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/model/IInterceptable.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/model/ISkippable.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/model/ITaggable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/IterationInfo.java
Patch:
@@ -4,7 +4,7 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodInfo.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodKind.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *     https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -38,7 +38,7 @@ public enum MethodKind {
   public boolean isFixtureMethod() {
     return isSetupMethod() || isCleanupMethod();
   }
-  
+
   public boolean isSetupMethod() {
     return this == SETUP || this == SETUP_SPEC;
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ConditionalExtension.java
Patch:
@@ -71,6 +71,9 @@ public void visitSpecAnnotation(T annotation, SpecInfo spec) {
 
   @Override
   public void visitFeatureAnnotation(T annotation, FeatureInfo feature) {
+    if (feature.getSpec().isSkipped())
+      return;
+
     Closure condition = createCondition(annotation);
 
     try {

File: spock-spring/src/main/java/org/spockframework/spring/mock/SpockMockPostprocessor.java
Patch:
@@ -43,7 +43,7 @@
  * @since 1.2
  */
 
-public class SpockMockPostprocessor extends InstantiationAwareBeanPostProcessorAdapter
+public class SpockMockPostprocessor extends BackwardsCompatibleInstantiationAwareBeanPostProcessorAdapter
   implements BeanFactoryPostProcessor, Ordered {
 
   private static final String FACTORY_BEAN_OBJECT_TYPE = "factoryBeanObjectType";
@@ -327,7 +327,7 @@ public void injectSpies(Object testInstance) {
    * {@link BeanPostProcessor} to handle {@link SpringSpy} definitions. Registered as a
    * separate processor so that it can be ordered above AOP post processors.
    */
-  static class SpyPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
+  static class SpyPostProcessor extends BackwardsCompatibleInstantiationAwareBeanPostProcessorAdapter
     implements PriorityOrdered {
 
     private static final String BEAN_NAME = SpyPostProcessor.class.getName();

File: spock-core/src/main/java/org/spockframework/builder/CollectionSlotFactory.java
Patch:
@@ -18,7 +18,7 @@
 import org.spockframework.util.MopUtil;
 
 import java.lang.reflect.Type;
-import java.util.Collection;
+import java.util.*;
 import java.util.regex.Pattern;
 
 import groovy.lang.MetaProperty;
@@ -35,7 +35,7 @@ public ISlot create(Object owner, Type ownerType, String name) {
   }
 
   private String toPluralForm(String word) {
-    if (word.toLowerCase().endsWith("s")) return word + "es";
+    if (word.toLowerCase(Locale.ROOT).endsWith("s")) return word + "es";
     boolean matchesIESRule = pluralIESPattern.matcher(word).matches();
     return matchesIESRule ? word.substring(0, word.length() - 1) + "ies" : word + "s";
   }

File: spock-core/src/main/java/org/spockframework/compiler/model/BlockParseInfo.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.spockframework.compiler.model;
 
-import java.util.EnumSet;
+import java.util.*;
 
 /**
  *
@@ -137,7 +137,7 @@ public String toString() {
   };
 
   public String toString() {
-    return super.toString().toLowerCase();
+    return super.toString().toLowerCase(Locale.ROOT);
   }
 
   public abstract Block addNewBlock(Method method);

File: spock-core/src/main/java/org/spockframework/util/TextUtil.java
Patch:
@@ -154,10 +154,10 @@ public static String camelCaseToConstantCase(String value) {
       String uppers = matcher.group(2);
 
       if (uppers.length() == 0) {
-        result.append(lowers.toUpperCase());
+        result.append(lowers.toUpperCase(Locale.ROOT));
       } else {
         if (lowers.length() > 0) {
-          result.append(lowers.toUpperCase());
+          result.append(lowers.toUpperCase(Locale.ROOT));
           result.append('_');
         }
         if (uppers.length() > 1 && !matcher.hitEnd()) {

File: spock-core/src/main/java/spock/util/environment/OperatingSystem.java
Patch:
@@ -16,6 +16,8 @@
 
 package spock.util.environment;
 
+import java.util.Locale;
+
 /**
  * Provides information on the current operating system, such as its name, version, and family.
  */
@@ -140,7 +142,7 @@ public boolean isOther() {
   public static OperatingSystem getCurrent() {
     String name = System.getProperty("os.name");
     String version = System.getProperty("os.version");
-    String lowerName = name.toLowerCase();
+    String lowerName = name.toLowerCase(Locale.ROOT);
     if (lowerName.contains("linux")) return new OperatingSystem(name, version, Family.LINUX);
     if (lowerName.contains("mac os") || lowerName.contains("darwin")) return new OperatingSystem(name, version, Family.MAC_OS);
     if (lowerName.contains("windows")) return new OperatingSystem(name, version, Family.WINDOWS);

File: spock-spring/src/main/java/org/spockframework/spring/xml/SpockMockFactoryBean.java
Patch:
@@ -19,7 +19,7 @@
 import org.spockframework.mock.MockNature;
 import spock.mock.DetachedMockFactory;
 
-import java.util.Collections;
+import java.util.*;
 
 import org.springframework.beans.factory.FactoryBean;
 
@@ -47,7 +47,7 @@ public SpockMockFactoryBean (Class<T> targetClass) {
   @SuppressWarnings("unchecked")
   public T getObject() throws Exception {
     if (instance == null) {
-      MockNature nature = MockNature.valueOf(mockNature.toUpperCase());
+      MockNature nature = MockNature.valueOf(mockNature.toUpperCase(Locale.ROOT));
       instance =  new DetachedMockFactory().createMock(name, targetClass, nature,
         Collections.<String, Object>emptyMap());
     }

File: spock-core/src/main/java/org/spockframework/compiler/AstUtil.java
Patch:
@@ -83,7 +83,7 @@ public static List<Statement> getStatements(MethodNode method) {
   public static List<Statement> getStatements(ClosureExpression closure) {
     BlockStatement blockStat = (BlockStatement)closure.getCode();
     return blockStat == null ?
-        Collections.<Statement> emptyList() : // it's not possible to add any statements to such a ClosureExpression, so immutable list is OK
+        Collections.emptyList() : // it's not possible to add any statements to such a ClosureExpression, so immutable list is OK
         blockStat.getStatements();
   }
 

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -765,7 +765,7 @@ private TryCatchStatement surroundSpecialTryCatch(Expression executeAndVerify) {
           createDirectMethodCall(
             new ClassExpression(resources.getAstNodeCache().SpockRuntime),
             resources.getAstNodeCache().SpockRuntime_GroupConditionFailedWithException,
-            new ArgumentListExpression(Arrays.<Expression>asList(
+            new ArgumentListExpression(Arrays.asList(
               new VariableExpression(errorCollectorName),
               new VariableExpression(THROWABLE)                                     // throwable
             ))

File: spock-core/src/main/java/org/spockframework/compiler/InteractionRewriter.java
Patch:
@@ -164,7 +164,7 @@ private void createBuilder() {
     builderExpr = new ConstructorCallExpression(
         resources.getAstNodeCache().InteractionBuilder,
         new ArgumentListExpression(
-            Arrays.<Expression> asList(
+            Arrays.asList(
                 new ConstantExpression(expr.getLineNumber()),
                 new ConstantExpression(expr.getColumnNumber()),
                 new ConstantExpression(resources.getSourceText(expr)))));

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -129,6 +129,6 @@ private Object createDummy(IMockInvocation invocation) {
     Type genericType = invocation.getMethod().getExactReturnType();
     Specification spec = invocation.getMockObject().getSpecification();
     return spec.createMock("dummy", genericType, MockNature.STUB, GroovyObject.class.isAssignableFrom(type) ?
-        MockImplementation.GROOVY : MockImplementation.JAVA, Collections.<String, Object>emptyMap(), null);
+        MockImplementation.GROOVY : MockImplementation.JAVA, Collections.emptyMap(), null);
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/constraint/EqualMethodNameConstraint.java
Patch:
@@ -38,7 +38,7 @@ public boolean isSatisfiedBy(IMockInvocation invocation) {
 
   @Override
   public String describeMismatch(IMockInvocation invocation) {
-    Condition condition = new Condition(CollectionUtil.<Object>listOf(invocation.getMethod().getName(), methodName, false),
+    Condition condition = new Condition(CollectionUtil.listOf(invocation.getMethod().getName(), methodName, false),
       String.format("methodName == \"%s\"", methodName), null, null,
       null, null);
     return condition.getRendering();

File: spock-core/src/main/java/org/spockframework/mock/constraint/EqualPropertyNameConstraint.java
Patch:
@@ -36,7 +36,7 @@ public boolean isSatisfiedBy(IMockInvocation invocation) {
 
   @Override
   public String describeMismatch(IMockInvocation invocation) {
-    Condition condition = new Condition(CollectionUtil.<Object>listOf(getPropertyName(invocation), propertyName, false),
+    Condition condition = new Condition(CollectionUtil.listOf(getPropertyName(invocation), propertyName, false),
       String.format("propertyName == \"%s\"", propertyName), null, null,
       null, null);
     return condition.getRendering();

File: spock-core/src/main/java/org/spockframework/mock/constraint/RegexMethodNameConstraint.java
Patch:
@@ -40,7 +40,7 @@ public boolean isSatisfiedBy(IMockInvocation invocation) {
 
   @Override
   public String describeMismatch(IMockInvocation invocation) {
-    Condition condition = new Condition(CollectionUtil.<Object>listOf(invocation.getMethod().getName(), pattern.pattern(), false),
+    Condition condition = new Condition(CollectionUtil.listOf(invocation.getMethod().getName(), pattern.pattern(), false),
       String.format("methodName ==~ /%s/", pattern.pattern()), null, null,
       null, null);
     return condition.getRendering();

File: spock-core/src/main/java/org/spockframework/mock/constraint/RegexPropertyNameConstraint.java
Patch:
@@ -39,7 +39,7 @@ public boolean isSatisfiedBy(IMockInvocation invocation) {
 
   @Override
   public String describeMismatch(IMockInvocation invocation) {
-    Condition condition = new Condition(CollectionUtil.<Object>listOf(getPropertyName(invocation), pattern.pattern(), false),
+    Condition condition = new Condition(CollectionUtil.listOf(getPropertyName(invocation), pattern.pattern(), false),
       String.format("propertyName ==~ /%s/", pattern.pattern()), null, null,
       null, null);
     return condition.getRendering();

File: spock-core/src/main/java/org/spockframework/mock/constraint/TargetConstraint.java
Patch:
@@ -41,7 +41,7 @@ public boolean isSatisfiedBy(IMockInvocation invocation) {
   @Override
   public String describeMismatch(IMockInvocation invocation) {
     // need to explicitly call .toString() otherwise the render service will attempt to output the contents of collections and such
-    Condition condition = new Condition(CollectionUtil.<Object>listOf(  invocation.getMockObject().getInstance().toString(), target.toString(), false),
+    Condition condition = new Condition(CollectionUtil.listOf(  invocation.getMockObject().getInstance().toString(), target.toString(), false),
       "instance == target", null, null,
       null, null);
     return condition.getRendering();

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicMockMethod.java
Patch:
@@ -28,7 +28,7 @@ public class DynamicMockMethod implements IMockMethod {
   private final boolean isStatic;
 
   public DynamicMockMethod(String methodName, int argumentCount, boolean isStatic) {
-    this(methodName, Collections.<Type>nCopies(argumentCount , Object.class), Object.class, isStatic);
+    this(methodName, Collections.nCopies(argumentCount , Object.class), Object.class, isStatic);
   }
 
   public DynamicMockMethod(String methodName, List<Type> parameterTypes, Type returnType, boolean isStatic) {

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockMetaClass.java
Patch:
@@ -119,7 +119,7 @@ private IMockInvocation createMockInvocation(MetaMethod metaMethod, Object targe
         configuration.isVerified(), configuration.isGlobal(), configuration.getDefaultResponse(), specification, this);
     IMockMethod mockMethod;
     if (metaMethod != null) {
-      List<Type> parameterTypes = Arrays.<Type>asList(metaMethod.getNativeParameterTypes());
+      List<Type> parameterTypes = Arrays.asList(metaMethod.getNativeParameterTypes());
       mockMethod = new DynamicMockMethod(methodName, parameterTypes, metaMethod.getReturnType(), isStatic);
     } else {
       mockMethod = new DynamicMockMethod(methodName, arguments.length, isStatic);

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoConverter.java
Patch:
@@ -95,7 +95,7 @@ public void visitPropertyExpression(PropertyExpression expr) {
         TextPosition.startOf(expr.getProperty()),
         expr.getPropertyAsString(),
         expr.isImplicitThis() ?
-            Collections.<ExpressionInfo>emptyList() :
+            Collections.emptyList() :
             Collections.singletonList(convert(expr.getObjectExpression())));
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/condition/ObjectRendererService.java
Patch:
@@ -32,7 +32,7 @@ public String render(Object object) {
     if (object == null) return "null\n";
 
     // explicit parameterization required although IDEA thinks it's redundant
-    Set<Class<?>> types = Collections.<Class<?>>singleton(object.getClass());
+    Set<Class<?>> types = Collections.singleton(object.getClass());
 
     while (!types.isEmpty()) {
       for (Class<?> type : types) {

File: spock-core/src/main/java/org/spockframework/util/inspector/AstInspector.java
Patch:
@@ -385,7 +385,7 @@ private <T> T getNode(Map<String, T> nodes, String key) {
   @SuppressWarnings("unchecked")
   private static List<Statement> getStatements(BlockStatement blockStat) {
     return blockStat == null ?
-      Collections.<Statement> emptyList() :
+      Collections.emptyList() :
       blockStat.getStatements();
   }
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicProxyMockInterceptorAdapter.java
Patch:
@@ -28,7 +28,7 @@ public DynamicProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor
 
   @Override
   public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {
-    IResponseGenerator realMethodInvoker = (ReflectionUtil.isDefault(method) || ReflectionUtil.isObjectMethod(method))
+    IResponseGenerator realMethodInvoker = (method.isDefault() || ReflectionUtil.isObjectMethod(method))
       ? new DefaultMethodInvoker(target, method, arguments)
       : new FailingRealMethodInvoker("Cannot invoke real method '" + method.getName() + "' on interface based mock object");
     return interceptor.intercept(target, method, arguments, realMethodInvoker);

File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -301,7 +301,7 @@ private AnnotationNode createDataProviderAnnotation(Expression dataProviderExpr,
   }
 
   private Parameter createDataProcessorParameter() {
-    Parameter p = new Parameter(ClassHelper.DYNAMIC_TYPE, "$spock_p" + dataProcessorParams.size());
+    Parameter p = new Parameter(ClassHelper.OBJECT_TYPE, "$spock_p" + dataProcessorParams.size());
     dataProcessorParams.add(p);
     return p;
   }
@@ -635,7 +635,7 @@ private void handleFeatureParameters() {
       String name = dataProcessorVar.getName();
       Parameter declaredDataVariableParameter = declaredDataVariableParameters.get(name);
       newParameters.add(declaredDataVariableParameter == null
-        ? new Parameter(ClassHelper.DYNAMIC_TYPE, name)
+        ? new Parameter(ClassHelper.OBJECT_TYPE, name)
         : declaredDataVariableParameter);
     }
     // then all auxiliary parameters in declaration order

File: spock-core/src/main/java/org/spockframework/runtime/StackTraceFilter.java
Patch:
@@ -35,6 +35,7 @@ public class StackTraceFilter implements IStackTraceFilter {
       "\\Qorg.codehaus.groovy.runtime.\\E.*" +
       "|\\Qorg.codehaus.groovy.reflection.\\E.*" +
       "|\\Qorg.codehaus.groovy.\\E.*MetaClass.*" +
+      "|\\Qorg.codehaus.groovy.vmplugin.v8.\\E.*" +
       "|groovy\\..*MetaClass.*" +
       "|groovy\\.lang\\.MetaMethod" +
       "|\\Qjava.lang.reflect.\\E.*" +

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IgnoreExtension.java
Patch:
@@ -31,7 +31,7 @@ public class IgnoreExtension implements IAnnotationDrivenExtension<Ignore> {
 
   @Override
   public void visitSpecAnnotation(Ignore ignore, SpecInfo spec) {
-    if (spec.getIsBottomSpec()) spec.skip(ignore.value().isEmpty() ? DEFAULT_REASON : ignore.value());
+    if (spec.getIsBottomSpec() || ignore.inherited()) spec.getBottomSpec().skip(ignore.value().isEmpty() ? DEFAULT_REASON : ignore.value());
   }
 
   @Override

File: spock-core/src/main/java/spock/lang/PendingFeatureIf.java
Patch:
@@ -53,7 +53,7 @@
   /**
    * The reason why this feature is pending
    *
-   * @return reason why this feature is pending
+   * @return the string to use for the skip message
    */
   String reason() default "";
 

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TempDirExtension.java
Patch:
@@ -33,7 +33,7 @@ public void visitFieldAnnotation(TempDir annotation, FieldInfo field) {
     // attach interceptor
     SpecInfo specInfo = field.getParent();
     if (field.isShared()) {
-      specInfo.addInterceptor(interceptor);
+      specInfo.getBottomSpec().addInterceptor(interceptor);
     } else {
       for (FeatureInfo featureInfo : specInfo.getBottomSpec().getAllFeatures()) {
         featureInfo.addIterationInterceptor(interceptor);

File: spock-core/src/main/java/org/spockframework/runtime/PlatformSpecRunner.java
Patch:
@@ -119,7 +119,6 @@ public void doRunSharedInitializer(SpockExecutionContext context, SpecInfo spec)
   }
 
   void runSetupSpec(SpockExecutionContext context) {
-    supervisor.beforeSpec(context.getSpec());
     runSetupSpec(context, context.getSpec());
   }
 
@@ -151,7 +150,6 @@ public void doRunSetupSpec(SpockExecutionContext context, SpecInfo spec) {
 
   void runCleanupSpec(SpockExecutionContext context) {
     runCleanupSpec(context.withCurrentInstance(context.getSharedInstance()), context.getSpec());
-    supervisor.afterSpec(context.getSpec());
   }
 
   private void runCleanupSpec(SpockExecutionContext context, SpecInfo spec) {

File: spock-core/src/main/java/org/spockframework/compiler/IRewriteResources.java
Patch:
@@ -38,6 +38,7 @@ public interface IRewriteResources {
   Block getCurrentBlock();
 
   void defineValueRecorder(List<Statement> stats, String variableNameSuffix);
+  void defineErrorRethrower(List<Statement> stats);
   void defineErrorCollector(List<Statement> stats, String variableNameSuffix);
   VariableExpression captureOldValue(Expression oldValue);
   MethodCallExpression getMockInvocationMatcher();

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryExtension.java
Patch:
@@ -50,7 +50,7 @@ private boolean noRetryAnnotation(NodeInfo node) {
   @Override
   public void visitFeatureAnnotation(Retry annotation, FeatureInfo feature) {
     if (annotation.mode() == Retry.Mode.SETUP_FEATURE_CLEANUP) {
-      feature.addIterationInterceptor(new RetryIterationInterceptor(annotation));
+      feature.addIterationInterceptor(new RetryIterationInterceptor(annotation, feature.getFeatureMethod()));
     } else {
       feature.getFeatureMethod().addInterceptor(new RetryFeatureInterceptor(annotation));
     }

File: spock-spring/src/main/java/org/spockframework/spring/SpringInterceptor.java
Patch:
@@ -34,6 +34,9 @@ public SpringInterceptor(SpringTestContextManager manager) {
   @Override
   public void interceptSetupSpecMethod(IMethodInvocation invocation) throws Throwable {
     manager.beforeTestClass();
+    if (invocation.getSpec().isAnnotationPresent(EnableSharedInjection.class)) {
+      manager.prepareTestInstance(invocation.getInstance());
+    }
     invocation.proceed();
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ExecutionExtension.java
Patch:
@@ -10,7 +10,7 @@
 public class ExecutionExtension implements IAnnotationDrivenExtension<Execution> {
   @Override
   public void visitSpecAnnotation(Execution annotation, SpecInfo spec) {
-    spec.setExecutionMode(annotation.value());
+    spec.getBottomSpec().setExecutionMode(annotation.value());
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IsolatedExtension.java
Patch:
@@ -14,6 +14,6 @@ public class IsolatedExtension implements IAnnotationDrivenExtension<Isolated> {
 
   @Override
   public void visitSpecAnnotations(List<Isolated> annotations, SpecInfo spec) {
-    spec.addExclusiveResource(GLOBAL_LOCK);
+    spec.getBottomSpec().addExclusiveResource(GLOBAL_LOCK);
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ResourceLockChildrenExtension.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.List;
 
 import org.spockframework.runtime.extension.IAnnotationDrivenExtension;
+import org.spockframework.runtime.model.FeatureInfo;
 import org.spockframework.runtime.model.SpecInfo;
 import org.spockframework.runtime.model.parallel.ExclusiveResource;
 
@@ -12,10 +13,11 @@ public class ResourceLockChildrenExtension implements IAnnotationDrivenExtension
 
   @Override
   public void visitSpecAnnotations(List<ResourceLockChildren> annotations, SpecInfo spec) {
+    List<FeatureInfo> allFeatures = spec.getBottomSpec().getAllFeatures();
     annotations.stream()
       .map(this::toExclusiveResource)
       .forEach(lockResource ->
-        spec.getFeatures().forEach(feature -> feature.addExclusiveResource(lockResource)));
+        allFeatures.forEach(feature -> feature.addExclusiveResource(lockResource)));
   }
 
   private ExclusiveResource toExclusiveResource(ResourceLockChildren lockResource) {

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ResourceLockExtension.java
Patch:
@@ -19,7 +19,7 @@ public void visitFeatureAnnotations(List<ResourceLock> annotations, FeatureInfo
 
   @Override
   public void visitSpecAnnotations(List<ResourceLock> annotations, SpecInfo spec) {
-    annotations.forEach( lockResource -> spec.addExclusiveResource(
+    annotations.forEach( lockResource -> spec.getBottomSpec().addExclusiveResource(
       toExclusiveResource(lockResource)));
   }
 

File: spock-core/src/main/java/org/spockframework/util/InternalIdentifiers.java
Patch:
@@ -52,6 +52,9 @@ public static boolean isFeatureMethodName(String name) {
   public static String getSharedFieldName(String baseName) {
     return "$spock_sharedField_" + baseName;
   }
+  public static String getFinalFieldName(String baseName) {
+    return "$spock_finalField_" + baseName;
+  }
 
   public static boolean isInternalName(String name) {
     return name.startsWith("$spock_");

File: spock-core/src/main/java/org/spockframework/runtime/IterationNode.java
Patch:
@@ -12,7 +12,7 @@ public class IterationNode extends SpockNode<FeatureInfo> {
   private final IterationInfo iterationInfo;
 
   protected IterationNode(UniqueId uniqueId, RunnerConfiguration configuration, IterationInfo iterationInfo) {
-    super(uniqueId, iterationInfo.getName(), featureToMethodSource(iterationInfo.getFeature()), configuration,
+    super(uniqueId, iterationInfo.getDisplayName(), featureToMethodSource(iterationInfo.getFeature()), configuration,
       iterationInfo.getFeature());
     this.iterationInfo = iterationInfo;
   }

File: spock-core/src/main/java/org/spockframework/runtime/ParameterizedFeatureNode.java
Patch:
@@ -16,7 +16,7 @@
 public class ParameterizedFeatureNode extends FeatureNode {
 
   protected ParameterizedFeatureNode(UniqueId uniqueId, RunnerConfiguration configuration, FeatureInfo featureInfo) {
-    super(uniqueId, featureInfo.getName(),featureToMethodSource(featureInfo), configuration, featureInfo);
+    super(uniqueId, featureInfo.getDisplayName(), featureToMethodSource(featureInfo), configuration, featureInfo);
   }
 
 

File: spock-core/src/main/java/org/spockframework/runtime/PlatformSpecRunner.java
Patch:
@@ -227,8 +227,9 @@ void runIteration(SpockExecutionContext context, IterationInfo iterationInfo, Ru
   IterationInfo createIterationInfo(SpockExecutionContext context, int iterationIndex, Object[] dataValues, int estimatedNumIterations) {
     FeatureInfo currentFeature = context.getCurrentFeature();
     IterationInfo result = new IterationInfo(currentFeature, iterationIndex, dataValues, estimatedNumIterations);
+    result.setName(currentFeature.getName());
     String iterationName = currentFeature.getIterationNameProvider().getName(result);
-    result.setName(iterationName);
+    result.setDisplayName(iterationName);
     return result;
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/SimpleFeatureNode.java
Patch:
@@ -18,7 +18,7 @@ public class SimpleFeatureNode extends FeatureNode {
 
   public SimpleFeatureNode(UniqueId uniqueId, RunnerConfiguration configuration,
                            FeatureInfo featureInfo, IterationNode delegate) {
-    super(uniqueId, featureInfo.getName(), featureToMethodSource(featureInfo), configuration, featureInfo);
+    super(uniqueId, featureInfo.getDisplayName(), featureToMethodSource(featureInfo), configuration, featureInfo);
     this.delegate = delegate;
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/SpecNode.java
Patch:
@@ -11,7 +11,7 @@
 public class SpecNode extends SpockNode<SpecInfo> {
 
   protected SpecNode(UniqueId uniqueId, RunnerConfiguration configuration, SpecInfo specInfo) {
-    super(uniqueId, specInfo.getName(), ClassSource.from(specInfo.getReflection()), configuration, specInfo);
+    super(uniqueId, specInfo.getDisplayName(), ClassSource.from(specInfo.getReflection()), configuration, specInfo);
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TempDirInterceptor.java
Patch:
@@ -45,8 +45,8 @@ private String dirPrefix(IMethodInvocation invocation) {
     // for shared field, no iteration is set, so use the spec name
     // otherwise use the iteration name
     prefix.append(((invocation.getIteration() == null)
-      ? invocation.getSpec().getName()
-      : invocation.getIteration().getName())
+      ? invocation.getSpec().getDisplayName()
+      : invocation.getIteration().getDisplayName())
       .replaceAll("[^a-zA-Z0-9_.-]++", "_"));
     if (prefix.length() > 25) {
       prefix.setLength(25);

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TitleExtension.java
Patch:
@@ -22,6 +22,6 @@
 public class TitleExtension implements IAnnotationDrivenExtension<Title> {
   @Override
   public void visitSpecAnnotation(Title title, SpecInfo spec) {
-    spec.setName(title.value().trim());
+    spec.setDisplayName(title.value().trim());
   }
 }

File: spock-junit4/src/main/java/org/spockframework/junit4/JUnitDescriptionGenerator.java
Patch:
@@ -55,7 +55,7 @@ public static Description describeFeature(FeatureInfo feature, SpecInfo spec) {
   public static Description describeIteration(IterationInfo iteration, SpecInfo spec) {
     return Description.createTestDescription(
       spec.getReflection(),
-      iteration.getName(),
+      iteration.getDisplayName(),
       iteration.getFeature().getFeatureMethod().getAnnotations());
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/ErrorSpecNode.java
Patch:
@@ -25,7 +25,7 @@ public void prune() {
   }
 
   @Override
-  public SpockExecutionContext execute(SpockExecutionContext context, DynamicTestExecutor dynamicTestExecutor) throws Exception {
+  public SpockExecutionContext prepare(SpockExecutionContext context) throws Exception {
     return ExceptionUtil.sneakyThrow(error);
   }
 }

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -199,7 +199,7 @@ public void visitMethodReferenceExpression(MethodReferenceExpression expr) {
   @Override
   public void visitVariableExpression(VariableExpression expr) {
     if (expr instanceof OldValueExpression) {
-      Expression originalExpr = ((OldValueExpression)expr).getOrginalExpression();
+      Expression originalExpr = ((OldValueExpression)expr).getOriginalExpression();
       originalExpr.visit(this); // just to count up recordCount and produce the correct number of N/A values at runtime
       result = expr;
       return;

File: spock-core/src/main/java/org/spockframework/compiler/OldValueExpression.java
Patch:
@@ -34,7 +34,7 @@ public OldValueExpression(Expression originalExpression, String substitutedVaria
     this.originalExpression = originalExpression;
   }
 
-  public Expression getOrginalExpression() {
+  public Expression getOriginalExpression() {
     return originalExpression;
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionComparisonRenderer.java
Patch:
@@ -5,7 +5,7 @@
 
 public interface ExpressionComparisonRenderer {
   /**
-   * Renders a comparision expression.
+   * Renders a comparison expression.
    *
    * @param expr the expression to be rendered
    * @return the rendering or {@code null} if it can't be rendered by this renderer

File: spock-core/src/main/java/org/spockframework/util/inspector/AstInspector.java
Patch:
@@ -294,7 +294,7 @@ public List<Expression> getExpressions(MethodNode node) {
    * Returns the top-level statements in the specified closure definition.
    * If no such statements are found, an empty list is returned.
    *
-   * @param expr a ClosureExpression representing a closure defintion
+   * @param expr a ClosureExpression representing a closure definition
    * @return the top-level statements in the specified closure definition
    */
   public List<Statement> getStatements(ClosureExpression expr) {

File: spock-spring/src/main/java/org/spockframework/spring/SpringSpy.java
Patch:
@@ -21,7 +21,7 @@
 import java.lang.annotation.*;
 
 /**
- * Wraps an exisiting bean in a Spock spy.
+ * Wraps an existing bean in a Spock spy.
  * <p>
  * Inspired by Springs {@code @SpyBean}, but adapted to Spock semantics.
  * <p>

File: spock-spring/src/main/java/org/spockframework/spring/StubBeans.java
Patch:
@@ -48,7 +48,7 @@
   Class<?>[] value();
 
   /**
-   * Controlls if parent StubBean declarations should be inherited.
+   * Controls if parent StubBean declarations should be inherited.
    *
    * @return true if inherit false if only this one
    */

File: spock-core/src/main/java/org/spockframework/compiler/IRewriteResources.java
Patch:
@@ -37,7 +37,8 @@ public interface IRewriteResources {
   Method getCurrentMethod();
   Block getCurrentBlock();
 
-  void defineRecorders(List<Statement> stats, boolean enableErrorCollector, String recorderSuffix);
+  void defineValueRecorder(List<Statement> stats, String variableNameSuffix);
+  void defineErrorCollector(List<Statement> stats, String variableNameSuffix);
   VariableExpression captureOldValue(Expression oldValue);
   MethodCallExpression getMockInvocationMatcher();
 

File: spock-core/src/main/java/org/spockframework/compiler/IRewriteResources.java
Patch:
@@ -37,7 +37,7 @@ public interface IRewriteResources {
   Method getCurrentMethod();
   Block getCurrentBlock();
 
-  void defineRecorders(List<Statement> stats, boolean enableErrorCollector);
+  void defineRecorders(List<Statement> stats, boolean enableErrorCollector, String recorderSuffix);
   VariableExpression captureOldValue(Expression oldValue);
   MethodCallExpression getMockInvocationMatcher();
 

File: spock-core/src/main/java/org/spockframework/util/MopUtil.java
Patch:
@@ -25,8 +25,7 @@
 
 public abstract class MopUtil {
   private static final Field ReflectionMetaMethod_method  = getDeclaredField(ReflectionMetaMethod.class, "method");
-  private static final Field CachedField_field = GroovyRuntimeUtil.isGroovy2() ? getDeclaredField(CachedField.class, "field") :
-    getDeclaredField(CachedField.class, "cachedField");
+  private static final Field CachedField_field = getDeclaredField(CachedField.class, "field");
 
   private static Field getDeclaredField(Class clazz, String name) {
     try {

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaMockInterceptor.java
Patch:
@@ -73,7 +73,8 @@ public Object intercept(Object target, Method method, Object[] arguments, IRespo
           //Groovy 3 started to call go.getProperty("x") method instead of go.getX() directly for go.x
           Throwable throwable = new Throwable();
           StackTraceElement mockCaller = throwable.getStackTrace()[3];
-          if (!("groovy.lang.GroovyObject$getProperty".equals(mockCaller.getClassName()) && "call".equals(mockCaller.getMethodName()))) {
+          // In some strange cases the caller classname is `groovy.lang.GroovyObject$getProperty$0` so we must use starts with here
+          if (!(mockCaller.getClassName().startsWith("groovy.lang.GroovyObject$getProperty") && "call".equals(mockCaller.getMethodName()))) {
             //HACK: Only explicit getter executions (go.foo and go.getFoo()) should be deeper processed.
             //go.getProperty("foo") is treated as is (to allow for its stubbing)
             String methodName = GroovyRuntimeUtil.propertyToMethodName("get", (String) args[0]);

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockMetaClass.java
Patch:
@@ -80,8 +80,10 @@ private Object doInvokeMethod(Object target, String methodName, Object[] argumen
 
     if (method != null && method.getDeclaringClass().isAssignableFrom(configuration.getType())) {
       if (!isStatic && !ReflectionUtil.isFinalMethod(method) && !configuration.isGlobal()) {
+        // perform coercion of arguments, e.g. GString to String
+        Object[] coercedArgs = metaMethod.coerceArgumentsToClasses(unwrappedArgs);
         // use standard proxy dispatch
-        return metaMethod.invoke(target, unwrappedArgs);
+        return metaMethod.invoke(target, coercedArgs);
       }
     }
 

File: spock-core/src/main/java/org/spockframework/compiler/SpockTransform.java
Patch:
@@ -57,9 +57,7 @@ void visit(ASTNode[] nodes, SourceUnit sourceUnit) {
       SourceLookup sourceLookup = new SourceLookup(sourceUnit);
 
       try {
-        ModuleNode module = (ModuleNode) nodes[0];
-        @SuppressWarnings("unchecked")
-        List<ClassNode> classes = module.getClasses();
+        List<ClassNode> classes = sourceUnit.getAST().getClasses();
 
         for (ClassNode clazz : classes)
           if (isSpec(clazz)) processSpec(sourceUnit, clazz, errorReporter, sourceLookup);

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -388,7 +388,7 @@ public void visitArrayExpression(ArrayExpression expr) {
         new ArrayExpression(
             expr.getElementType(),
             convertAll(expr.getExpressions()),
-            convertAll(expr.getSizeExpression()));
+            expr.getSizeExpression() == null ? null : convertAll(expr.getSizeExpression()));
 
     conversion.setSourcePosition(expr);
     result = record(conversion);

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoConverter.java
Patch:
@@ -361,10 +361,11 @@ public void visitClosureListExpression(ClosureListExpression expr) {
   }
 
   @Override
-  @SuppressWarnings("unchecked")
   public void visitArrayExpression(ArrayExpression expr) {
     List<ExpressionInfo> children = convertAll(expr.getExpressions());
-    children.addAll(convertAll(expr.getSizeExpression()));
+    if (expr.getSizeExpression() != null) {
+      children.addAll(convertAll(expr.getSizeExpression()));
+    }
 
     result = new ExpressionInfo(
         TextRegion.of(expr),

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.codehaus.groovy.runtime.wrappers.PojoWrapper;
 import org.spockframework.runtime.*;
+import org.spockframework.runtime.extension.RepeatedExtensionAnnotations;
 import org.spockframework.runtime.model.*;
 import org.spockframework.util.Identifiers;
 import spock.lang.Specification;
@@ -68,6 +69,7 @@ public class AstNodeCache {
       ErrorCollector.getDeclaredMethods(org.spockframework.runtime.ErrorCollector.VALIDATE_COLLECTED_ERRORS).get(0);
 
   // annotations and annotation elements
+  public final ClassNode RepeatedExtensionAnnotations = ClassHelper.makeWithoutCaching(RepeatedExtensionAnnotations.class);
   public final ClassNode SpecMetadata = ClassHelper.makeWithoutCaching(SpecMetadata.class);
   public final ClassNode FieldMetadata = ClassHelper.makeWithoutCaching(FieldMetadata.class);
   public final ClassNode FeatureMetadata = ClassHelper.makeWithoutCaching(FeatureMetadata.class);

File: spock-core/src/main/java/org/spockframework/compiler/SpecialMethodCall.java
Patch:
@@ -14,7 +14,6 @@
 
 package org.spockframework.compiler;
 
-import org.jetbrains.annotations.NotNull;
 import org.spockframework.lang.ConditionBlock;
 import org.spockframework.util.*;
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/ByteBuddyMockFactory.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.lang.reflect.Method;
 import java.util.List;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ThreadLocalRandom;
 
 import static net.bytebuddy.matcher.ElementMatchers.any;

File: spock-core/src/main/java/org/spockframework/runtime/PlatformSpecRunner.java
Patch:
@@ -21,7 +21,6 @@
 import org.spockframework.util.*;
 import spock.lang.Specification;
 
-import org.junit.platform.engine.support.hierarchical.Node;
 
 import java.util.Arrays;
 
@@ -249,7 +248,7 @@ private MethodInfo createMethodInfoForDoRunIteration(SpockExecutionContext conte
     return result;
   }
 
-  void runParameterizedFeature(SpockExecutionContext context, Node.DynamicTestExecutor dynamicTestExecutor) throws InterruptedException  {
+  void runParameterizedFeature(SpockExecutionContext context, ParameterizedFeatureChildExecutor childExecutor) throws InterruptedException  {
     throw new UnsupportedOperationException("This runner cannot run parameterized features");
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/model/FeatureInfo.java
Patch:
@@ -23,7 +23,7 @@ public class FeatureInfo extends SpecElementInfo<SpecInfo, AnnotatedElement> {
   private NameProvider<IterationInfo> iterationNameProvider;
   private final List<DataProviderInfo> dataProviders = new ArrayList<>();
 
-  private boolean reportIterations = false;
+  private boolean reportIterations = true;
 
   public SpecInfo getSpec() {
     return getParent();

File: spock-core/src/main/java/org/spockframework/runtime/model/IterationInfo.java
Patch:
@@ -19,8 +19,6 @@
 import java.lang.reflect.AnnotatedElement;
 import java.util.*;
 
-import static java.util.Collections.unmodifiableMap;
-
 /**
  * Runtime information about an iteration of a feature method.
  */

File: spock-testkit/src/test/groovy/spock/platform/SpockHelloWorldTest.java
Patch:
@@ -47,15 +47,15 @@ void verifySimpleExample() {
   @Test
   void packageSelectorsAreResolved() {
     assertEquals(7, execute(selectPackage(ExampleTestCase.class.getPackage().getName()))
-      .containers()
+      .containerEvents()
       .filter(event -> event.getType() == EventType.STARTED)
       .filter(event -> "spec".equals(event.getTestDescriptor().getUniqueId().getLastSegment().getType()))
       .count());
   }
 
   @Test
   void verifyUnrollExample() {
-    execute(selectClass(UnrollTestCase.class), stats -> stats.started(12).succeeded(12));
+    execute(selectClass(UnrollTestCase.class), stats -> stats.started(13).succeeded(13));
   }
 
   @Test

File: spock-core/src/main/java/org/spockframework/runtime/extension/IMethodInvocation.java
Patch:
@@ -100,7 +100,10 @@ public interface IMethodInvocation {
 
   /**
    * Sets the arguments for this method invocation.
+   *
+   * @deprecated set the fields in the return value of {@link #getArguments()} instead
    */
+  @Deprecated
   void setArguments(Object[] arguments);
 
   /**

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -72,6 +72,7 @@ public class AstNodeCache {
   public final ClassNode FieldMetadata = ClassHelper.makeWithoutCaching(FieldMetadata.class);
   public final ClassNode FeatureMetadata = ClassHelper.makeWithoutCaching(FeatureMetadata.class);
   public final ClassNode DataProviderMetadata = ClassHelper.makeWithoutCaching(DataProviderMetadata.class);
+  public final ClassNode DataProcessorMetadata = ClassHelper.makeWithoutCaching(DataProcessorMetadata.class);
   public final ClassNode BlockMetadata = ClassHelper.makeWithoutCaching(BlockMetadata.class);
   public final ClassNode BlockKind = ClassHelper.makeWithoutCaching(BlockKind.class);
 

File: spock-core/src/main/java/org/spockframework/runtime/model/FeatureMetadata.java
Patch:
@@ -29,12 +29,14 @@
   String NAME = "name";
   String ORDINAL = "ordinal";
   String LINE = "line";
+  String DATA_VARIABLE_NAMES = "dataVariableNames";
   String PARAMETER_NAMES = "parameterNames";
   String BLOCKS = "blocks";
 
   int ordinal();
   String name();
   int line();
+  String[] dataVariableNames();
   String[] parameterNames();
   BlockMetadata[] blocks();
 }

File: spock-core/src/main/java/org/spockframework/runtime/SpecInfoBuilder.java
Patch:
@@ -178,6 +178,7 @@ private DataProviderInfo createDataProvider(FeatureInfo feature, MethodInfo meth
     provider.setParent(feature);
     provider.setLine(metadata.line());
     provider.setDataVariables(Arrays.asList(metadata.dataVariables()));
+    provider.setPreviousDataTableVariables(Arrays.asList(metadata.previousDataTableVariables()));
     provider.setDataProviderMethod(method);
     return provider;
   }

File: spock-core/src/main/java/org/spockframework/runtime/model/DataProviderMetadata.java
Patch:
@@ -10,7 +10,9 @@
 public @interface DataProviderMetadata {
   String LINE = "line";
   String DATA_VARIABLES = "dataVariables";
-  
+  String PREVIOUS_DATA_TABLE_VARIABLES = "previousDataTableVariables";
+
   int line();
   String[] dataVariables();
+  String[] previousDataTableVariables() default { };
 }

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.spockframework.compiler;
 
+import org.codehaus.groovy.runtime.wrappers.PojoWrapper;
 import org.spockframework.runtime.*;
 import org.spockframework.runtime.model.*;
 import org.spockframework.util.Identifiers;
@@ -79,4 +80,5 @@ public class AstNodeCache {
 
   // external types
   public final ClassNode Throwable = ClassHelper.makeWithoutCaching(Throwable.class);
+  public final ClassNode PojoWrapper = ClassHelper.makeWithoutCaching(PojoWrapper.class);
 }

File: spock-core/src/main/java/org/spockframework/compiler/DeepBlockRewriter.java
Patch:
@@ -44,7 +44,7 @@ public class DeepBlockRewriter extends AbstractDeepBlockRewriter {
   private boolean insideInteraction = false;
 
   public DeepBlockRewriter(IRewriteResources resources) {
-    super(resources.getCurrentBlock());
+    super(resources.getCurrentBlock(), resources.getAstNodeCache());
     this.resources = resources;
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/PlatformParameterizedSpecRunner.java
Patch:
@@ -160,7 +160,7 @@ private void runIterations(SpockExecutionContext context, Node.DynamicTestExecut
 
     int iterationIndex = 0;
     while (haveNext(context, iterators)) {
-      IterationInfo iterationInfo = createIterationInfo(context, nextArgs(context, iterators), estimatedNumIterations);
+      IterationInfo iterationInfo = createIterationInfo(context, iterationIndex, nextArgs(context, iterators), estimatedNumIterations);
       IterationNode iterationNode = new IterationNode(context.getParentId().append("iteration",String.valueOf(iterationIndex++)), iterationInfo);
 
       if (context.getErrorInfoCollector().hasErrors()) {

File: spock-core/src/main/java/org/spockframework/runtime/PlatformSpecRunner.java
Patch:
@@ -221,9 +221,9 @@ void runIteration(SpockExecutionContext context, IterationInfo iterationInfo, Ru
     getSpecificationContext(context).setCurrentIteration(null); // TODO check if we really need to null here
   }
 
-  IterationInfo createIterationInfo(SpockExecutionContext context, Object[] dataValues, int estimatedNumIterations) {
+  IterationInfo createIterationInfo(SpockExecutionContext context, int iterationIndex, Object[] dataValues, int estimatedNumIterations) {
     FeatureInfo currentFeature = context.getCurrentFeature();
-    IterationInfo result = new IterationInfo(currentFeature, dataValues, estimatedNumIterations);
+    IterationInfo result = new IterationInfo(currentFeature, iterationIndex, dataValues, estimatedNumIterations);
     String iterationName = currentFeature.getIterationNameProvider().getName(result);
     result.setName(iterationName);
     Description description = Description.createTestDescription(context.getSpec().getReflection(),

File: spock-core/src/main/java/org/spockframework/runtime/SpockEngineDiscoveryPostProcessor.java
Patch:
@@ -30,7 +30,7 @@ private FeatureNode describeParameterizedFeature(UniqueId parentId, FeatureInfo
   }
 
   private SpockNode describeSimpleFeature(UniqueId parentId, FeatureInfo feature) {
-    IterationInfo iterationInfo = new IterationInfo(feature, EMPTY_ARGS, 1);
+    IterationInfo iterationInfo = new IterationInfo(feature, 0, EMPTY_ARGS, 1);
     iterationInfo.setName(feature.getName());
     UniqueId uniqueId = toUniqueId(parentId, feature);
     IterationNode iterationNode = new IterationNode(toUniqueId(uniqueId, feature), iterationInfo);

File: spock-testkit/src/test/groovy/spock/platform/SpockHelloWorldTest.java
Patch:
@@ -67,7 +67,7 @@ void verifySingleExample(Class<?> testClass) {
 
   private void execute(DiscoverySelector selector, Consumer<EventStatistics> statisticsConsumer) {
     execute(selector)
-      .tests()
+      .testEvents()
       .debug()
       .assertStatistics(statisticsConsumer);
   }

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -50,7 +50,7 @@ public Object respond(IMockInvocation invocation) {
       return ReflectionUtil.getDefaultValue(returnType);
     }
 
-    if (returnType.isAssignableFrom(invocation.getMockObject().getType())) {
+    if (returnType != Object.class && returnType.isAssignableFrom(invocation.getMockObject().getType())) {
       return invocation.getMockObject().getInstance();
     }
 

File: spock-core/src/main/java/spock/util/concurrent/AsyncConditions.java
Patch:
@@ -38,7 +38,7 @@
  * def conds = new AsyncConditions()
  *
  * // register async callback
- * machine.workDone << { result ->
+ * machine.workDone >> { result ->
  *   conds.evaluate {
  *     assert result == WorkResult.OK
  *     // could add more explicit conditions here

File: spock-core/src/main/java/spock/util/concurrent/BlockingVariable.java
Patch:
@@ -35,7 +35,7 @@
  * def result = new BlockingVariable&lt;WorkResult&gt;
  *
  * // register async callback
- * machine.workDone << { r ->
+ * machine.workDone >> { r ->
  *  result.set(r)
  * }
  *
@@ -124,4 +124,4 @@ public void set(T value) {
     this.value = value;
     valueReady.countDown();
   }
-}
\ No newline at end of file
+}

File: spock-core/src/main/java/org/spockframework/runtime/RunContext.java
Patch:
@@ -129,7 +129,7 @@ public static <T, U extends Throwable> T withNewContext(String name, File spockU
     if (inheritParentExtensions) allExtensionClasses.addAll(getCurrentExtensions());
 
     RunContext context = new RunContext(name, spockUserHome, configurationScript, allExtensionClasses);
-    LinkedList<RunContext> contextStack = contextStacks.get();
+    Deque<RunContext> contextStack = contextStacks.get();
     contextStack.addFirst(context);
     try {
       context.start();

File: spock-core/src/main/java/org/spockframework/runtime/SpockEngine.java
Patch:
@@ -15,7 +15,7 @@ public String getId() {
 
   @Override
   public TestDescriptor discover(EngineDiscoveryRequest discoveryRequest, UniqueId uniqueId) {
-    RunContext runContext = RunContext.get(); // TODO cleanup
+    RunContext runContext = RunContext.get();
     SpockEngineDescriptor engineDescriptor = new SpockEngineDescriptor(uniqueId, runContext);
     EngineDiscoveryRequestResolver.builder()
       .addClassContainerSelectorResolver(SpecUtil::isRunnableSpec)

File: spock-core/src/main/java/org/spockframework/runtime/ParameterizedFeatureNode.java
Patch:
@@ -28,7 +28,7 @@ public SpockExecutionContext execute(SpockExecutionContext context, DynamicTestE
     context.getRunner().runParameterizedFeature(context, testExecutor);
     errorInfoCollector.assertEmpty();
     if (testExecutor.getExecutionCount() < 1) {
-      // TODO assert at least one iteration here?
+     throw new SpockExecutionException("Data provider has no data");
     }
     return context;
   }

File: spock-core/src/main/java/org/spockframework/runtime/IRunSupervisor.java
Patch:
@@ -37,7 +37,7 @@ public interface IRunSupervisor {
   void afterFeature(FeatureInfo feature);
   void afterSpec(SpecInfo spec);
 
-  int error(ErrorInfo error);
+  void error(ErrorInfoCollector errorInfoCollector,ErrorInfo error);
 
   void specSkipped(SpecInfo spec);
   void featureSkipped(FeatureInfo feature);

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodInfo.java
Patch:
@@ -54,7 +54,6 @@ public MethodInfo(MethodInfo other) {
     this.setParent(other.getParent());
     this.setReflection(other.getReflection());
     this.setMetadata(other.getMetadata());
-    this.setDescription(other.getDescription());
     this.interceptors.addAll(other.interceptors);
     this.invoker = other.invoker;
   }

File: spock-junit4/src/main/java/org/spockframework/junit4/ClassRuleExtension.java
Patch:
@@ -42,7 +42,7 @@ public void visitSpec(SpecInfo spec) {
 
   private static class ClassRuleInterceptorInstaller {
     static void install(SpecInfo spec, List<FieldInfo> ruleFields) {
-      spec.addInterceptor(new ClassRuleInterceptor(ruleFields));
+      spec.addInterceptor(new ClassRuleInterceptor(ruleFields, spec));
     }
   }
 }

File: spock-junit4/src/main/java/org/spockframework/junit4/RuleExtension.java
Patch:
@@ -57,7 +57,7 @@ static void install(SpecInfo spec, List<FieldInfo> ruleFields) {
 
   private static class TestRuleInterceptorInstaller {
     static void install(SpecInfo spec, List<FieldInfo> ruleFields) {
-      TestRuleInterceptor interceptor = new TestRuleInterceptor(ruleFields);
+      TestRuleInterceptor interceptor = new TestRuleInterceptor(ruleFields, spec);
       for (FeatureInfo feature : spec.getAllFeatures()) {
         feature.addIterationInterceptor(interceptor);
       }

File: spock-core/src/main/java/org/spockframework/runtime/IterationNode.java
Patch:
@@ -3,14 +3,12 @@
 import org.spockframework.runtime.model.IterationInfo;
 
 import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.support.descriptor.MethodSource;
 
 public class IterationNode extends SpockNode {
   private final IterationInfo iterationInfo;
 
   protected IterationNode(UniqueId uniqueId, IterationInfo iterationInfo) {
-    super(uniqueId, iterationInfo.getName(),
-      MethodSource.from(iterationInfo.getFeature().getFeatureMethod().getReflection()));
+    super(uniqueId, iterationInfo.getName(), featureToMethodSource(iterationInfo.getFeature()));
     this.iterationInfo = iterationInfo;
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/ParameterizedFeatureNode.java
Patch:
@@ -3,12 +3,11 @@
 import org.spockframework.runtime.model.FeatureInfo;
 
 import org.junit.platform.engine.*;
-import org.junit.platform.engine.support.descriptor.MethodSource;
 
 public class ParameterizedFeatureNode extends FeatureNode {
 
   protected ParameterizedFeatureNode(UniqueId uniqueId, FeatureInfo featureInfo) {
-    super(uniqueId, featureInfo.getName(), MethodSource.from(featureInfo.getFeatureMethod().getReflection()), featureInfo);
+    super(uniqueId, featureInfo.getName(),featureToMethodSource(featureInfo), featureInfo);
   }
 
 

File: spock-core/src/main/java/org/spockframework/runtime/SimpleFeatureNode.java
Patch:
@@ -3,7 +3,6 @@
 import org.spockframework.runtime.model.FeatureInfo;
 
 import org.junit.platform.engine.*;
-import org.junit.platform.engine.support.descriptor.MethodSource;
 
 /**
  * A non-parametric feature (test) that only has a single "iteration".
@@ -17,7 +16,7 @@ public class SimpleFeatureNode extends FeatureNode {
   private final IterationNode delegate;
 
   public SimpleFeatureNode(UniqueId uniqueId, FeatureInfo featureInfo, IterationNode delegate) {
-    super(uniqueId, featureInfo.getName(), MethodSource.from(featureInfo.getFeatureMethod().getReflection()), featureInfo);
+    super(uniqueId, featureInfo.getName(), featureToMethodSource(featureInfo), featureInfo);
     this.delegate = delegate;
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/ParameterizedFeatureNode.java
Patch:
@@ -22,6 +22,7 @@ public SpockExecutionContext prepare(SpockExecutionContext context) throws Excep
   public SpockExecutionContext execute(SpockExecutionContext context, DynamicTestExecutor dynamicTestExecutor) throws Exception {
     verifyNotSkipped(featureInfo);
     context.getRunner().runParameterizedFeature(context, new ChildExecutor(dynamicTestExecutor));
+    // todo assert at least one test execution
     return context;
   }
 
@@ -38,6 +39,7 @@ class ChildExecutor implements DynamicTestExecutor {
 
     @Override
     public void execute(TestDescriptor testDescriptor) {
+      // TODO count test
       addChild(testDescriptor);
       delegate.execute(testDescriptor);
 

File: spock-core/src/main/java/org/spockframework/runtime/IterationNode.java
Patch:
@@ -30,6 +30,7 @@ public SpockExecutionContext before(SpockExecutionContext context) throws Except
 
   @Override
   public SpockExecutionContext execute(SpockExecutionContext context, DynamicTestExecutor dynamicTestExecutor) throws Exception {
+    verifyNotSkipped(iterationInfo.getFeature());
     context.getRunner().runFeatureMethod(context);
     return context;
   }
@@ -51,6 +52,6 @@ public Type getType() {
 
   @Override
   public SkipResult shouldBeSkipped(SpockExecutionContext context) throws Exception {
-    return iterationInfo.getFeature().isSkipped() ? SkipResult.skip("because I said so") : SkipResult.doNotSkip();
+    return shouldBeSkipped(iterationInfo.getFeature());
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/SpockComparisonFailure.java
Patch:
@@ -29,7 +29,7 @@ public class SpockComparisonFailure extends AssertionFailedError {
 
   private final Condition condition;
 
-  public SpockComparisonFailure(Condition condition, ValueWrapper expected, ValueWrapper actual) {
+  public SpockComparisonFailure(Condition condition, Object expected, Object actual) {
     super(null, expected, actual);
     this.condition = condition;
   }

File: spock-core/src/main/java/org/spockframework/runtime/ErrorCollector.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
-import org.junit.runners.model.MultipleFailureException;
+import org.opentest4j.MultipleFailuresError;
 
 public class ErrorCollector {
   private final boolean errorCollectionEnabled;
@@ -25,10 +25,10 @@ public <T extends Throwable> void collectOrThrow(T error) throws T {
 
   public static final String VALIDATE_COLLECTED_ERRORS = "validateCollectedErrors";
 
-  public void validateCollectedErrors() throws MultipleFailureException {
+  public void validateCollectedErrors() {
     if (errorCollectionEnabled){
       if (!throwables.isEmpty()){
-        throw new MultipleFailureException(throwables);
+        throw new MultipleFailuresError("",throwables);
       }
     }
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/AutoCleanupInterceptor.java
Patch:
@@ -61,6 +61,6 @@ public void intercept(IMethodInvocation invocation) throws Throwable {
       }
     }
 
-    ExtensionUtil.throwAll(exceptions);
+    ExtensionUtil.throwAll("Exceptions during cleanup", exceptions);
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/PendingFeatureBaseInterceptor.java
Patch:
@@ -1,6 +1,6 @@
 package org.spockframework.runtime.extension.builtin;
 
-import org.junit.AssumptionViolatedException;
+import org.opentest4j.TestAbortedException;
 
 /**
  * @author Leonard Brünings
@@ -26,8 +26,8 @@ protected AssertionError featurePassedUnexpectedly() {
     return new AssertionError("Feature is marked with @PendingFeature but passes unexpectedly");
   }
 
-  protected AssumptionViolatedException assumptionViolation() {
-    return new AssumptionViolatedException("Feature not yet implemented correctly."
+  protected TestAbortedException assumptionViolation() {
+    return new TestAbortedException("Feature not yet implemented correctly."
       + ("".equals(reason) ? "" : " Reason: " + reason));
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/SpecNode.java
Patch:
@@ -32,7 +32,6 @@ public SpockExecutionContext prepare(SpockExecutionContext context) throws Excep
 
   @Override
   public SkipResult shouldBeSkipped(SpockExecutionContext context) throws Exception {
-    System.out.println("Skipping spec=" + specInfo.isSkipped());
     return specInfo.isSkipped() ? SkipResult.skip("because I said so") : SkipResult.doNotSkip();
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/Condition.java
Patch:
@@ -33,7 +33,7 @@ public class Condition implements Serializable {
   private static final long serialVersionUID = 1L;
 
   private static final Pattern pattern =
-    Pattern.compile("(?<backslashesToEscape>(:?\\\\\\\\)+)|(?<stripBackslash>\\\\\n)|(?<whitespacesToCollapse>\\s*\n\\s*)");
+    Pattern.compile("(?<backslashesToEscape>(?:\\\\\\\\)+)|(?<stripBackslash>\\\\\n)|(?<whitespacesToCollapse>\\s*\n\\s*)");
 
   private final transient List<Object> values;
   private final String text;

File: spock-core/src/main/java/org/spockframework/mock/IArgumentConstraint.java
Patch:
@@ -23,4 +23,5 @@
  */
 public interface IArgumentConstraint {
   boolean isSatisfiedBy(Object arg);
+  String describeMismatch(Object arg);
 }

File: spock-core/src/main/java/org/spockframework/mock/IInvocationConstraint.java
Patch:
@@ -22,4 +22,5 @@
  */
 public interface IInvocationConstraint {
   boolean isSatisfiedBy(IMockInvocation invocation);
+  String describeMismatch(IMockInvocation invocation);
 }

File: spock-spring/src/main/java/org/spockframework/spring/mock/DelegatingInterceptor.java
Patch:
@@ -51,8 +51,10 @@ public Object intercept(Object target, Method method, Object[] arguments, IRespo
 
     try {
       return method.invoke(delegate, arguments);
-    } catch (IllegalAccessException | InvocationTargetException e) {
+    } catch (IllegalAccessException e) {
       ExceptionUtil.sneakyThrow(e);
+    } catch (InvocationTargetException e) {
+      ExceptionUtil.sneakyThrow(e.getTargetException());
     }
     return null;
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryIterationInterceptor.java
Patch:
@@ -42,6 +42,7 @@ public void intercept(IMethodInvocation invocation) throws Throwable {
       invocation.getFeature().getFeatureMethod().addInterceptor(new InnerRetryInterceptor(retry, condition, throwables));
       invocation.proceed();
       if (throwables.isEmpty()) {
+        throwableList.clear();
         break;
       } else {
         throwableList.addAll(throwables);

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RetryExtension.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension;
 import org.spockframework.runtime.model.FeatureInfo;
-
 import spock.lang.Retry;
 
 /**
@@ -30,6 +29,8 @@ public class RetryExtension extends AbstractAnnotationDrivenExtension<Retry> {
   public void visitFeatureAnnotation(Retry annotation, FeatureInfo feature) {
     if (feature.isParameterized() && (annotation.mode() == Retry.Mode.FEATURE)) {
       feature.addInterceptor(new RetryIterationInterceptor(annotation));
+    } else if (annotation.mode() == Retry.Mode.SETUP_FEATURE_CLEANUP) {
+      feature.addIterationInterceptor(new RetryIterationInterceptor(annotation));
     } else {
       feature.getFeatureMethod().addInterceptor(new RetryFeatureInterceptor(annotation));
     }

File: spock-core/src/main/java/org/spockframework/compiler/DeepBlockRewriter.java
Patch:
@@ -17,6 +17,7 @@
 package org.spockframework.compiler;
 
 import org.spockframework.compiler.model.*;
+import org.spockframework.util.Identifiers;
 import org.spockframework.util.Nullable;
 
 import java.util.*;
@@ -152,7 +153,8 @@ private boolean handleImplicitCondition(ExpressionStatement stat) {
     groupConditionFound = currSpecialMethodCall.isGroupConditionBlock();
 
     if ((currSpecialMethodCall.isWithCall() || currSpecialMethodCall.isGroupConditionBlock())
-      && AstUtil.isInvocationWithImplicitThis(stat.getExpression())) {
+      && AstUtil.isInvocationWithImplicitThis(stat.getExpression())
+      && !Identifiers.WITH.equals(AstUtil.getMethodName(stat.getExpression()))) {
       replaceObjectExpressionWithCurrentClosure(stat);
     }
 

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoValueRenderer.java
Patch:
@@ -130,11 +130,11 @@ private String tryReduceStringSizes(String str1, String str2) {
     end1++;
     end2++;
 
-    if ((end1-commonStart) * (end2-commonStart) > MAX_EDIT_DISTANCE_MEMORY) {
+    if (((long) end1-commonStart) * (end2-commonStart) > MAX_EDIT_DISTANCE_MEMORY) {
       return "false\nStrings too large to calculate edit distance.";
     } else {
       // Check if we can add some context
-      if ((end1 - commonStart + 20) * (end2 - commonStart + 20) < MAX_EDIT_DISTANCE_MEMORY){
+      if (((long) end1 - commonStart + 20) * (end2 - commonStart + 20) < MAX_EDIT_DISTANCE_MEMORY){
         commonStart = Math.max(0, commonStart - 10);
         end1 = Math.min(str1.length(), end1 + 10);
         end2 = Math.min(str2.length(), end2 + 10);

File: spock-spring/src/main/java/org/spockframework/spring/SpringMockTestExecutionListener.java
Patch:
@@ -72,7 +72,7 @@ public void beforeTestMethod(SpringTestContext testContext) throws Exception {
 
     for (String beanName : mockBeanNames) {
       BeanDefinition beanDefinition = ((BeanDefinitionRegistry)applicationContext).getBeanDefinition(beanName);
-      if (beanDefinition.isAbstract()) {
+      if (beanDefinition.isAbstract() || beanDefinition.isLazyInit()) {
         continue;
       }
       if (beanDefinition.isSingleton() || scanScopedBean(scanScopedBeans, scopes, beanDefinition)) {

File: spock-core/src/main/java/org/spockframework/runtime/model/FieldMetadata.java
Patch:
@@ -34,5 +34,6 @@
   String name();
   int ordinal();
   int line();
-  boolean initializer();
+  // This should not have a default, but to make it backwards compatible it has to have one.
+  boolean initializer() default false;
 }

File: spock-core/src/main/java/org/spockframework/mock/runtime/ProxyBasedMockFactory.java
Patch:
@@ -26,6 +26,7 @@
 import net.bytebuddy.*;
 import net.bytebuddy.description.modifier.*;
 import net.bytebuddy.dynamic.Transformer;
+import net.bytebuddy.dynamic.scaffold.TypeValidation;
 import net.bytebuddy.implementation.*;
 import net.bytebuddy.implementation.bind.annotation.Morph;
 import net.sf.cglib.proxy.*;
@@ -103,6 +104,7 @@ static Object createMock(final Class<?> type,
           public Class<?> call() throws Exception {
             return new ByteBuddy()
               .with(new NamingStrategy.SuffixingRandom("SpockMock"))
+              .with(TypeValidation.DISABLED) // https://github.com/spockframework/spock/issues/776
               .ignore(none())
               .subclass(type)
               .implement(additionalInterfaces)

File: spock-spring/src/main/java/org/spockframework/spring/SpringInterceptor.java
Patch:
@@ -39,6 +39,7 @@ public void interceptSetupSpecMethod(IMethodInvocation invocation) throws Throwa
 
   @Override
   public void interceptInitializerMethod(IMethodInvocation invocation) throws Throwable {
+    invocation.proceed(); // needs to run before so that mocks are already initialized
     manager.prepareTestInstance(invocation.getInstance());
   }
 

File: spock-spring/src/main/java/org/spockframework/spring/SpringExtension.java
Patch:
@@ -80,10 +80,10 @@ public void error(ErrorInfo error) {
   private boolean isSpringSpec(SpecInfo spec) {
     if (isSpringSpecUsingFindAnnotationDescriptorForTypes(spec)) return true;
 
-    if (ReflectionUtil.isAnnotationPresentRecursive(spec.getClass(), ContextConfiguration.class)) return true;
+    if (ReflectionUtil.isAnnotationPresentRecursive(spec.getReflection(), ContextConfiguration.class)) return true;
 
     return  (contextHierarchyClass != null
-      && ReflectionUtil.isAnnotationPresentRecursive(spec.getClass(), contextHierarchyClass));
+      && ReflectionUtil.isAnnotationPresentRecursive(spec.getReflection(), contextHierarchyClass));
   }
 
   private boolean isSpringSpecUsingFindAnnotationDescriptorForTypes(SpecInfo spec) {

File: spock-core/src/main/java/org/spockframework/runtime/ConditionNotSatisfiedError.java
Patch:
@@ -20,6 +20,8 @@
  * @author Peter Niederwieser
  */
 public class ConditionNotSatisfiedError extends SpockAssertionError {
+  private static final long serialVersionUID = 1L;
+
   private final Condition condition;
 
   public ConditionNotSatisfiedError(Condition condition) {

File: spock-core/src/main/java/org/spockframework/runtime/SpockAssertionError.java
Patch:
@@ -21,6 +21,8 @@
  * @author Peter Niederwieser
  */
 public class SpockAssertionError extends AssertionError {
+  private static final long serialVersionUID = 1L;
+
   public SpockAssertionError() {}
 
   public SpockAssertionError(String message) {

File: spock-core/src/main/java/org/spockframework/runtime/SpockComparisonFailure.java
Patch:
@@ -25,6 +25,8 @@
  * @author Peter Niederwieser
  */
 public class SpockComparisonFailure extends ComparisonFailure {
+  private static final long serialVersionUID = 1L;
+
   private final Condition condition;
 
   public SpockComparisonFailure(Condition condition, String expected, String actual) {

File: spock-core/src/main/java/org/spockframework/mock/IMockFactory.java
Patch:
@@ -17,7 +17,7 @@
 import spock.lang.Specification;
 
 public interface IMockFactory {
-  public boolean canCreate(IMockConfiguration configuration);
-  public Object create(IMockConfiguration configuration, Specification specification);
-  public Object createDetached(IMockConfiguration configuration, ClassLoader classLoader);
+  boolean canCreate(IMockConfiguration configuration);
+  Object create(IMockConfiguration configuration, Specification specification);
+  Object createDetached(IMockConfiguration configuration, ClassLoader classLoader);
 }

File: spock-core/src/main/java/org/spockframework/util/IMultiset.java
Patch:
@@ -31,7 +31,7 @@
  */
 @NotThreadSafe
 public interface IMultiset<E> extends Collection<E> {
-  public int count(E element);
+  int count(E element);
 
-  public Set<Map.Entry<E, Integer>> entrySet();
+  Set<Map.Entry<E, Integer>> entrySet();
 }

File: spock-specs/src/test.java1.8/java/org/spockframework/smoke/mock/IDeposit.java
Patch:
@@ -20,7 +20,7 @@
  * A bank deposit with <a href="https://en.wikipedia.org/wiki/Compound_interest">compound interest</a>.
  */
 public interface IDeposit {
-  public static class DepositException extends Exception {
+  class DepositException extends Exception {
     public DepositException(String message) {
       super(message);
     }

File: spock-tapestry/src/test/java/org/spockframework/tapestry/IService1.java
Patch:
@@ -17,5 +17,5 @@
 package org.spockframework.tapestry;
 
 public interface IService1 {
-  public String generateString();
+  String generateString();
 }

File: spock-tapestry/src/test/java/org/spockframework/tapestry/IService2.java
Patch:
@@ -17,5 +17,5 @@
 package org.spockframework.tapestry;
 
 public interface IService2 {
-  public String generateQuickBrownFox();
+  String generateQuickBrownFox();
 }

File: spock-tapestry/src/test/java/org/spockframework/tapestry/IService3.java
Patch:
@@ -17,5 +17,5 @@
 package org.spockframework.tapestry;
 
 public interface IService3 {
-  public String generateString();
+  String generateString();
 }

File: spock-core/src/main/java/org/spockframework/mock/runtime/ProxyBasedMockFactory.java
Patch:
@@ -128,7 +128,7 @@ public Class<?> call() throws Exception {
               .load(classLoader)
               .getLoaded();
           }
-        }, type);
+        }, CACHE);
 
       Object proxy = MockInstantiator.instantiate(type, enhancedType, constructorArgs, useObjenesis);
       ((ByteBuddyInterceptorAdapter.InterceptorAccess) proxy).$spock_set(interceptor);

File: spock-core/src/main/java/org/spockframework/mock/runtime/ProxyBasedMockFactory.java
Patch:
@@ -128,7 +128,7 @@ public Class<?> call() throws Exception {
               .load(classLoader)
               .getLoaded();
           }
-        }, type);
+        }, CACHE);
 
       Object proxy = MockInstantiator.instantiate(type, enhancedType, constructorArgs, useObjenesis);
       ((ByteBuddyInterceptorAdapter.InterceptorAccess) proxy).$spock_set(interceptor);

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/MethodRuleInterceptor.java
Patch:
@@ -41,7 +41,7 @@ public void intercept(final IMethodInvocation invocation) throws Throwable {
   }
 
   private FrameworkMethod createFrameworkMethod(final IMethodInvocation invocation) {
-    return new FrameworkMethod(invocation.getMethod().getReflection()) {
+    return new FrameworkMethod(invocation.getIteration().getParent().getFeatureMethod().getReflection()) {
       @Override
       public String getName() {
         return invocation.getIteration().getDescription().getMethodName();

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RuleExtension.java
Patch:
@@ -52,7 +52,7 @@ private static class MethodRuleInterceptorInstaller {
     static void install(SpecInfo spec, List<FieldInfo> ruleFields) {
       MethodRuleInterceptor interceptor = new MethodRuleInterceptor(ruleFields);
       for (FeatureInfo feature : spec.getAllFeatures()) {
-        feature.getFeatureMethod().addInterceptor(interceptor);
+        feature.addIterationInterceptor(interceptor);
       }
     }
   }

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -18,14 +18,15 @@
 
 import java.util.*;
 
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.*;
 import org.codehaus.groovy.classgen.BytecodeExpression;
 import org.codehaus.groovy.syntax.Types;
-
+import org.spockframework.runtime.ErrorCollector;
 import org.spockframework.runtime.ValueRecorder;
 import org.spockframework.util.*;
 
@@ -641,7 +642,7 @@ private Expression rewriteToSpockRuntimeCall(MethodNode method, Expression condi
         new ClassExpression(resources.getAstNodeCache().SpockRuntime), method,
         new ArgumentListExpression(args));
 
-    args.add(new VariableExpression("$spock_errorCollector"));
+    args.add(new VariableExpression("$spock_errorCollector", ClassHelper.make(ErrorCollector.class)));
     args.add(message == null ?
         AstUtil.createDirectMethodCall(
             new VariableExpression("$spock_valueRecorder"),

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -18,14 +18,15 @@
 
 import java.util.*;
 
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.*;
 import org.codehaus.groovy.classgen.BytecodeExpression;
 import org.codehaus.groovy.syntax.Types;
-
+import org.spockframework.runtime.ErrorCollector;
 import org.spockframework.runtime.ValueRecorder;
 import org.spockframework.util.*;
 
@@ -641,7 +642,7 @@ private Expression rewriteToSpockRuntimeCall(MethodNode method, Expression condi
         new ClassExpression(resources.getAstNodeCache().SpockRuntime), method,
         new ArgumentListExpression(args));
 
-    args.add(new VariableExpression("$spock_errorCollector"));
+    args.add(new VariableExpression("$spock_errorCollector", ClassHelper.make(ErrorCollector.class)));
     args.add(message == null ?
         AstUtil.createDirectMethodCall(
             new VariableExpression("$spock_valueRecorder"),

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/MethodRuleInterceptor.java
Patch:
@@ -41,7 +41,7 @@ public void intercept(final IMethodInvocation invocation) throws Throwable {
   }
 
   private FrameworkMethod createFrameworkMethod(final IMethodInvocation invocation) {
-    return new FrameworkMethod(invocation.getMethod().getReflection()) {
+    return new FrameworkMethod(invocation.getIteration().getParent().getFeatureMethod().getReflection()) {
       @Override
       public String getName() {
         return invocation.getIteration().getDescription().getMethodName();

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RuleExtension.java
Patch:
@@ -52,7 +52,7 @@ private static class MethodRuleInterceptorInstaller {
     static void install(SpecInfo spec, List<FieldInfo> ruleFields) {
       MethodRuleInterceptor interceptor = new MethodRuleInterceptor(ruleFields);
       for (FeatureInfo feature : spec.getAllFeatures()) {
-        feature.getFeatureMethod().addInterceptor(interceptor);
+        feature.addIterationInterceptor(interceptor);
       }
     }
   }

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicProxyMockInterceptorAdapter.java
Patch:
@@ -30,7 +30,7 @@ public DynamicProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor
   public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {
     IResponseGenerator realMethodInvoker = (ReflectionUtil.isDefault(method) || ReflectionUtil.isObjectMethod(method))
       ? new DefaultMethodInvoker(target, method, arguments)
-      : new FailingRealMethodInvoker("Cannot invoke real method on interface based mock object");
+      : new FailingRealMethodInvoker("Cannot invoke real method '" + method.getName() + "' on interface based mock object");
     return interceptor.intercept(target, method, arguments, realMethodInvoker);
   }
 }

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -103,7 +103,7 @@ private void createSharedFieldGetter(Field field) {
 
     BlockStatement getterBlock = new BlockStatement();
     getter = new MethodNode(getterName, determineVisibilityForSharedFieldAccessor(field) | Opcodes.ACC_SYNTHETIC,
-        ClassHelper.DYNAMIC_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
+        field.getAst().getType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
 
     getterBlock.addStatement(
         new ReturnStatement(

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -103,7 +103,7 @@ private void createSharedFieldGetter(Field field) {
 
     BlockStatement getterBlock = new BlockStatement();
     getter = new MethodNode(getterName, determineVisibilityForSharedFieldAccessor(field) | Opcodes.ACC_SYNTHETIC,
-        ClassHelper.DYNAMIC_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
+        field.getAst().getType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
 
     getterBlock.addStatement(
         new ReturnStatement(

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IgnoreIfExtension.java
Patch:
@@ -42,7 +42,9 @@ public void visitFeatureAnnotation(IgnoreIf annotation, FeatureInfo feature) {
   private void doVisit(IgnoreIf annotation, ISkippable skippable) {
     Closure condition = createCondition(annotation.value());
     Object result = evaluateCondition(condition);
-    skippable.setSkipped(GroovyRuntimeUtil.isTruthy(result));
+    if (GroovyRuntimeUtil.isTruthy(result)) {
+      skippable.setSkipped(true);
+    }
   }
 
   private Closure createCondition(Class<? extends Closure> clazz) {

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RequiresExtension.java
Patch:
@@ -44,7 +44,9 @@ public void visitFeatureAnnotation(Requires annotation, FeatureInfo feature) {
   private void doVisit(Requires annotation, ISkippable skippable) {
     Closure condition = createCondition(annotation.value());
     Object result = evaluateCondition(condition);
-    skippable.setSkipped(!GroovyRuntimeUtil.isTruthy(result));
+    if (!GroovyRuntimeUtil.isTruthy(result)) {
+      skippable.setSkipped(true);
+    }
   }
 
   private Closure createCondition(Class<? extends Closure> clazz) {

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/PendingFeatureExtension.java
Patch:
@@ -11,9 +11,9 @@ public class PendingFeatureExtension extends AbstractAnnotationDrivenExtension<P
   @Override
   public void visitFeatureAnnotation(PendingFeature annotation, FeatureInfo feature) {
     if (feature.isParameterized()) {
-      feature.addInterceptor(new PendingFeatureIterationInterceptor());
+      feature.addInterceptor(new PendingFeatureIterationInterceptor(annotation.exceptions()));
     } else {
-      feature.getFeatureMethod().addInterceptor(new PendingFeatureInterceptor());
+      feature.getFeatureMethod().addInterceptor(new PendingFeatureInterceptor(annotation.exceptions()));
     }
   }
 }

File: spock-core/src/main/java/org/spockframework/report/log/ReportLogConfiguration.java
Patch:
@@ -27,7 +27,7 @@
 
 @ConfigurationObject("report")
 public class ReportLogConfiguration {
-  public boolean enabled = Boolean.getBoolean(System.getProperty("spock.logEnabled", "false"));
+  public boolean enabled = Boolean.getBoolean("spock.logEnabled");
 
   public String logFileDir = System.getProperty("spock.logFileDir");
   public String logFileName = System.getProperty("spock.logFileName");

File: spock-core/src/main/java/org/spockframework/report/log/ReportLogConfiguration.java
Patch:
@@ -27,7 +27,7 @@
 
 @ConfigurationObject("report")
 public class ReportLogConfiguration {
-  public boolean enabled = Boolean.getBoolean(System.getProperty("spock.logEnabled", "false"));
+  public boolean enabled = Boolean.getBoolean("spock.logEnabled");
 
   public String logFileDir = System.getProperty("spock.logFileDir");
   public String logFileName = System.getProperty("spock.logFileName");

File: spock-core/src/main/java/org/spockframework/runtime/BaseSpecRunner.java
Patch:
@@ -396,6 +396,7 @@ public void doRunSetup(SpecInfo spec) {
     runSetup(spec.getSuperSpec());
     for (MethodInfo method : spec.getSetupMethods()) {
       if (runStatus != OK) return;
+      method.setFeature(currentFeature);
       invoke(currentInstance, method);
     }
   }

File: spock-maven/src/main/java/org/spockframework/buildsupport/maven/FindSpecsMojo.java
Patch:
@@ -29,7 +29,6 @@
 import org.apache.maven.project.MavenProject;
 import org.codehaus.plexus.util.xml.Xpp3Dom;
 import org.spockframework.buildsupport.SpecClassFileFinder;
-import org.spockframework.runtime.OptimizeRunOrderSuite;
 import org.spockframework.util.IoUtil;
 import org.spockframework.util.TextUtil;
 

File: spock-maven/src/main/java/org/spockframework/buildsupport/maven/OptimizeRunOrderSuite.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package org.spockframework.runtime;
+package org.spockframework.buildsupport.maven;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -21,6 +21,7 @@
 import org.junit.runners.Suite;
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.RunnerBuilder;
+import org.spockframework.runtime.SpecUtil;
 
 @RunWith(OptimizeRunOrderSuite.class)
 public class OptimizeRunOrderSuite extends Suite {

File: spock-core/src/main/java/org/spockframework/util/VersionChecker.java
Patch:
@@ -21,8 +21,8 @@ public class VersionChecker {
   public static void checkGroovyVersion(String whoIsChecking) {
     if (!compatibleGroovyVersion) throw new IncompatibleGroovyVersionException(String.format(
 "The Spock %s cannot execute because Spock %s is not compatible with Groovy %s. For more information, see http://versioninfo.spockframework.org\n" +
-"Spock location: %s\n" +
-"Groovy location: %s",
+"Spock artifact: %s\n" +
+"Groovy artifact: %s",
         whoIsChecking, SpockReleaseInfo.getVersion(), GroovyReleaseInfo.getVersion(),
         SpockReleaseInfo.getArtifactPath(), GroovyReleaseInfo.getArtifactPath()));
   }

File: spock-core/src/main/java/spock/lang/AutoCleanup.java
Patch:
@@ -35,10 +35,10 @@
  *
  * <pre>
  * &#64;AutoCleanup("dispose") // invoke the object's "dispose" method
- * </pre
+ * </pre>
  *
  * <h3>Cleaning up multiple objects</h3>
- * If multiple fields or properties are annotated with </tt>&#64;AutoCleanup</tt>,
+ * If multiple fields or properties are annotated with <tt>&#64;AutoCleanup</tt>,
  * their objects are cleaned up sequentially in reverse field/property declaration
  * order, starting from the most derived class and walking up the inheritance chain.
  *
@@ -51,7 +51,7 @@
  *
  * <pre>
  * &#64;AutoCleanup(quiet = true) // don't report exceptions
- * </pre
+ * </pre>
  *
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/spock/lang/MockingApi.java
Patch:
@@ -75,8 +75,8 @@ public class MockingApi extends SpecInternals {
    * recognized as belonging to an interaction definition:
    * <ul>
    * <li><tt>num * target.method(args)</tt></li>
-   * <li><tt>target.method(args) >>(>) result(s)</tt></li>
-   * <li><tt>num * target.method(args) >>(>) result(s)</li>
+   * <li><tt>target.method(args) &gt;&gt;(&gt;) result(s)</tt></li>
+   * <li><tt>num * target.method(args) &gt;&gt;(&gt;) result(s)</tt></li>
    * </ul>
    *
    * <p>Regular interaction definition:

File: spock-core/src/main/java/spock/lang/AutoCleanup.java
Patch:
@@ -35,10 +35,10 @@
  *
  * <pre>
  * &#64;AutoCleanup("dispose") // invoke the object's "dispose" method
- * </pre
+ * </pre>
  *
  * <h3>Cleaning up multiple objects</h3>
- * If multiple fields or properties are annotated with </tt>&#64;AutoCleanup</tt>,
+ * If multiple fields or properties are annotated with <tt>&#64;AutoCleanup</tt>,
  * their objects are cleaned up sequentially in reverse field/property declaration
  * order, starting from the most derived class and walking up the inheritance chain.
  *
@@ -51,7 +51,7 @@
  *
  * <pre>
  * &#64;AutoCleanup(quiet = true) // don't report exceptions
- * </pre
+ * </pre>
  *
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/spock/lang/MockingApi.java
Patch:
@@ -75,8 +75,8 @@ public class MockingApi extends SpecInternals {
    * recognized as belonging to an interaction definition:
    * <ul>
    * <li><tt>num * target.method(args)</tt></li>
-   * <li><tt>target.method(args) >>(>) result(s)</tt></li>
-   * <li><tt>num * target.method(args) >>(>) result(s)</li>
+   * <li><tt>target.method(args) &gt;&gt;(&gt;) result(s)</tt></li>
+   * <li><tt>num * target.method(args) &gt;&gt;(&gt;) result(s)</tt></li>
    * </ul>
    *
    * <p>Regular interaction definition:

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -40,7 +40,7 @@ public class EmptyOrDummyResponse implements IDefaultResponse {
   private EmptyOrDummyResponse() {}
 
   public Object respond(IMockInvocation invocation) {
-    IMockInteraction interaction = DefaultEqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
+    IMockInteraction interaction = DefaultJavaLangObjectInteractions.INSTANCE.match(invocation);
     if (interaction != null) return interaction.accept(invocation);
 
     Class<?> returnType = invocation.getMethod().getReturnType();

File: spock-core/src/main/java/org/spockframework/mock/ZeroOrNullResponse.java
Patch:
@@ -27,7 +27,7 @@ public class ZeroOrNullResponse implements IDefaultResponse {
   private ZeroOrNullResponse() {}
 
   public Object respond(IMockInvocation invocation) {
-    IMockInteraction interaction = DefaultEqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
+    IMockInteraction interaction = DefaultJavaLangObjectInteractions.INSTANCE.match(invocation);
     if (interaction != null) return interaction.accept(invocation);
 
     Class<?> returnType = invocation.getMethod().getReturnType();

File: spock-core/src/main/java/org/spockframework/mock/constraint/WildcardMethodNameConstraint.java
Patch:
@@ -25,6 +25,6 @@ public class WildcardMethodNameConstraint implements IInvocationConstraint {
   private WildcardMethodNameConstraint() {}
   
   public boolean isSatisfiedBy(IMockInvocation invocation) {
-    return DefaultEqualsHashCodeToStringInteractions.INSTANCE.match(invocation) == null;
+    return DefaultJavaLangObjectInteractions.INSTANCE.match(invocation) == null;
   }
 }
\ No newline at end of file

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -279,7 +279,7 @@ private MethodNode copyMethod(MethodNode method, String newName) {
 
   // where block must be rewritten before all other blocks
   // s.t. missing method parameters are added; these parameters
-  // will then be used by DeepStatementRewriter.fixupVariableScope()
+  // will then be used by DeepBlockRewriter
   private void handleWhereBlock(Method method) {
     Block block = method.getLastBlock();
     if (!(block instanceof WhereBlock)) return;

File: spock-core/src/main/java/org/spockframework/gentyref/VarMap.java
Patch:
@@ -44,8 +44,8 @@ Type map(Type type) {
 		if (type instanceof Class) {
 			return type;
 		} else if (type instanceof TypeVariable) {
-			assert map.containsKey(type);
-			return map.get(type);
+      Type result = map.get(type);
+      return result == null ? Object.class : result;
 		} else if (type instanceof ParameterizedType) {
 			ParameterizedType pType = (ParameterizedType) type;
 			return new ParameterizedTypeImpl((Class<?>)pType.getRawType(), map(pType.getActualTypeArguments()), pType.getOwnerType() == null ? pType.getOwnerType() : map(pType.getOwnerType()));

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -118,7 +118,7 @@ private Object createEmptyObject(Class<?> type) {
 
   private Object createDummy(IMockInvocation invocation) {
     Class<?> type = invocation.getMethod().getReturnType();
-    Type genericType = invocation.getMethod().getGenericReturnType();
+    Type genericType = invocation.getMethod().getExactReturnType();
     Specification spec = invocation.getMockObject().getSpecification();
     return spec.createMock("dummy", genericType, MockNature.STUB, GroovyObject.class.isAssignableFrom(type) ?
         MockImplementation.GROOVY : MockImplementation.JAVA, Collections.<String, Object>emptyMap(), null);

File: spock-core/src/main/java/org/spockframework/mock/runtime/DynamicMockMethod.java
Patch:
@@ -44,18 +44,18 @@ public String getName() {
   }
 
   public List<Class<?>> getParameterTypes() {
-    return ReflectionUtil.eraseTypes(getGenericParameterTypes());
+    return ReflectionUtil.eraseTypes(getExactParameterTypes());
   }
 
-  public List<Type> getGenericParameterTypes() {
+  public List<Type> getExactParameterTypes() {
     return parameterTypes;
   }
 
   public Class<?> getReturnType() {
     return GenericTypeReflector.erase(returnType);
   }
 
-  public Type getGenericReturnType() {
+  public Type getExactReturnType() {
     return returnType;
   }
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockInterceptor.java
Patch:
@@ -39,7 +39,7 @@ public GroovyMockInterceptor(IMockConfiguration mockConfiguration, Specification
   }
 
   public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {
-    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getGenericType(), target,
+    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getExactType(), target,
         mockConfiguration.isVerified(), mockConfiguration.isGlobal(), mockConfiguration.getDefaultResponse(), specification);
 
     if (method.getDeclaringClass() == ISpockMockObject.class) {
@@ -73,7 +73,7 @@ public Object intercept(Object target, Method method, Object[] arguments, IRespo
       throw new MissingPropertyException((String) normalizedArgs[0], mockConfiguration.getType());
     }
 
-    IMockMethod mockMethod = new StaticMockMethod(method, mockConfiguration.getGenericType());
+    IMockMethod mockMethod = new StaticMockMethod(method, mockConfiguration.getExactType());
     IMockInvocation invocation = new MockInvocation(mockObject, mockMethod, Arrays.asList(normalizedArgs), realMethodInvoker);
     IMockController controller = specification.getSpecificationContext().getMockController();
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockMetaClass.java
Patch:
@@ -115,7 +115,7 @@ private boolean isGetMetaClassCallOnGroovyObject(Object target, String method, O
 
   private IMockInvocation createMockInvocation(MetaMethod metaMethod, Object target,
       String methodName, Object[] arguments, boolean isStatic) {
-    IMockObject mockObject = new MockObject(configuration.getName(), configuration.getGenericType(), target,
+    IMockObject mockObject = new MockObject(configuration.getName(), configuration.getExactType(), target,
         configuration.isVerified(), configuration.isGlobal(), configuration.getDefaultResponse(), specification);
     IMockMethod mockMethod;
     if (metaMethod != null) {

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaMockInterceptor.java
Patch:
@@ -38,7 +38,7 @@ public JavaMockInterceptor(IMockConfiguration mockConfiguration, Specification s
   }
 
   public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {
-    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getGenericType(),
+    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getExactType(),
         target, mockConfiguration.isVerified(), false, mockConfiguration.getDefaultResponse(), specification);
 
     if (method.getDeclaringClass() == ISpockMockObject.class) {
@@ -65,7 +65,7 @@ public Object intercept(Object target, Method method, Object[] arguments, IRespo
       }
     }
 
-    IMockMethod mockMethod = new StaticMockMethod(method, mockConfiguration.getGenericType());
+    IMockMethod mockMethod = new StaticMockMethod(method, mockConfiguration.getExactType());
     IMockInvocation invocation = new MockInvocation(mockObject, mockMethod, Arrays.asList(normalizedArgs), realMethodInvoker);
     IMockController mockController = specification.getSpecificationContext().getMockController();
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockConfiguration.java
Patch:
@@ -61,7 +61,7 @@ public Class<?> getType() {
     return GenericTypeReflector.erase(type);
   }
 
-  public Type getGenericType() {
+  public Type getExactType() {
     return type;
   }
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/MockObject.java
Patch:
@@ -55,7 +55,7 @@ public Class<?> getType() {
     return GenericTypeReflector.erase(type);
   }
 
-  public Type getGenericType() {
+  public Type getExactType() {
     return type;
   }
 

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -16,6 +16,7 @@
 
 import java.lang.reflect.Array;
 import java.lang.reflect.Method;
+import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.*;
@@ -117,8 +118,9 @@ private Object createEmptyObject(Class<?> type) {
 
   private Object createDummy(IMockInvocation invocation) {
     Class<?> type = invocation.getMethod().getReturnType();
+    Type genericType = invocation.getMethod().getGenericReturnType();
     Specification spec = invocation.getMockObject().getSpecification();
-    return spec.createMock("dummy", type, MockNature.STUB, GroovyObject.class.isAssignableFrom(type) ?
+    return spec.createMock("dummy", genericType, MockNature.STUB, GroovyObject.class.isAssignableFrom(type) ?
         MockImplementation.GROOVY : MockImplementation.JAVA, Collections.<String, Object>emptyMap(), null);
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockInterceptor.java
Patch:
@@ -39,7 +39,7 @@ public GroovyMockInterceptor(IMockConfiguration mockConfiguration, Specification
   }
 
   public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {
-    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getType(), target,
+    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getGenericType(), target,
         mockConfiguration.isVerified(), mockConfiguration.isGlobal(), mockConfiguration.getDefaultResponse(), specification);
 
     if (method.getDeclaringClass() == ISpockMockObject.class) {
@@ -73,7 +73,7 @@ public Object intercept(Object target, Method method, Object[] arguments, IRespo
       throw new MissingPropertyException((String) normalizedArgs[0], mockConfiguration.getType());
     }
 
-    IMockMethod mockMethod = new StaticMockMethod(method);
+    IMockMethod mockMethod = new StaticMockMethod(method, mockConfiguration.getGenericType());
     IMockInvocation invocation = new MockInvocation(mockObject, mockMethod, Arrays.asList(normalizedArgs), realMethodInvoker);
     IMockController controller = specification.getSpecificationContext().getMockController();
 

File: spock-core/src/main/java/org/spockframework/mock/runtime/GroovyMockMetaClass.java
Patch:
@@ -15,6 +15,7 @@
 package org.spockframework.mock.runtime;
 
 import java.lang.reflect.Method;
+import java.lang.reflect.Type;
 import java.util.Arrays;
 import java.util.List;
 
@@ -114,11 +115,11 @@ private boolean isGetMetaClassCallOnGroovyObject(Object target, String method, O
 
   private IMockInvocation createMockInvocation(MetaMethod metaMethod, Object target,
       String methodName, Object[] arguments, boolean isStatic) {
-    IMockObject mockObject = new MockObject(configuration.getName(), configuration.getType(), target,
+    IMockObject mockObject = new MockObject(configuration.getName(), configuration.getGenericType(), target,
         configuration.isVerified(), configuration.isGlobal(), configuration.getDefaultResponse(), specification);
     IMockMethod mockMethod;
     if (metaMethod != null) {
-      List<Class<?>> parameterTypes = Arrays.<Class<?>>asList(metaMethod.getNativeParameterTypes());
+      List<Type> parameterTypes = Arrays.<Type>asList(metaMethod.getNativeParameterTypes());
       mockMethod = new DynamicMockMethod(methodName, parameterTypes, metaMethod.getReturnType(), isStatic);
     } else {
       mockMethod = new DynamicMockMethod(methodName, arguments.length, isStatic);

File: spock-core/src/main/java/org/spockframework/mock/runtime/JavaMockInterceptor.java
Patch:
@@ -38,7 +38,7 @@ public JavaMockInterceptor(IMockConfiguration mockConfiguration, Specification s
   }
 
   public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {
-    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getType(),
+    IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getGenericType(),
         target, mockConfiguration.isVerified(), false, mockConfiguration.getDefaultResponse(), specification);
 
     if (method.getDeclaringClass() == ISpockMockObject.class) {
@@ -65,7 +65,7 @@ public Object intercept(Object target, Method method, Object[] arguments, IRespo
       }
     }
 
-    IMockMethod mockMethod = new StaticMockMethod(method);
+    IMockMethod mockMethod = new StaticMockMethod(method, mockConfiguration.getGenericType());
     IMockInvocation invocation = new MockInvocation(mockObject, mockMethod, Arrays.asList(normalizedArgs), realMethodInvoker);
     IMockController mockController = specification.getSpecificationContext().getMockController();
 

File: spock-core/src/main/java/org/spockframework/report/log/ReportLogClient.java
Patch:
@@ -39,8 +39,8 @@ public void start() {
     try {
       socket = new Socket(reportServerAddress, reportServerPort);
     } catch (IOException e) {
-      throw new ExtensionException("Error opening connection to report server. " +
-          "Server address: $reportServerAddress Server port: $reportServerPort", e);
+      throw new ExtensionException(String.format("Error opening connection to report server. " +
+          "Server address: %s Server port: %d", reportServerAddress, reportServerPort), e);
     }
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/WrongExceptionThrownError.java
Patch:
@@ -39,8 +39,8 @@ public Throwable getActual() {
   @Override
   public String getMessage() {
     if (actual == null) {
-      return String.format("Expected exception %s, but no exception was thrown", expected.getName());
+      return String.format("Expected exception of type '%s', but no exception was thrown", expected.getName());
     }
-    return String.format("Expected exception %s, but got %s", expected.getName(), actual.getClass().getName());
+    return String.format("Expected exception of type '%s', but got '%s'", expected.getName(), actual.getClass().getName());
   }
 }

File: spock-core/src/main/java/spock/util/concurrent/PollingConditions.java
Patch:
@@ -161,7 +161,7 @@ public void within(double seconds, Closure<?> conditions) throws InterruptedExce
         long elapsedTime = lastAttempt - start;
         if (elapsedTime >= timeoutMillis) {
           String msg = String.format("Condition not satisfied after %1.2f seconds and %d attempts", elapsedTime / 1000d, attempts);
-          throw new SpockTimeoutError(seconds, msg);
+          throw new SpockTimeoutError(seconds, msg, e);
         }
         Thread.sleep(Math.min(currDelay, start + timeoutMillis - System.currentTimeMillis()));
         currDelay *= factor;

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/AutoCleanupExtension.java
Patch:
@@ -17,7 +17,6 @@
 import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension;
 import org.spockframework.runtime.model.FieldInfo;
 import org.spockframework.runtime.model.SpecInfo;
-import org.spockframework.util.CollectionUtil;
 
 import spock.lang.AutoCleanup;
 
@@ -36,7 +35,7 @@ public void visitFieldAnnotation(AutoCleanup annotation, FieldInfo field) {
 
   @Override
   public void visitSpec(SpecInfo spec) {
-    sharedFieldInterceptor.install(CollectionUtil.getLastElement(spec.getTopSpec().getCleanupSpecMethods()));
-    instanceFieldInterceptor.install(CollectionUtil.getLastElement(spec.getTopSpec().getCleanupMethods()));
+    sharedFieldInterceptor.install(spec.getCleanupSpecInterceptors());
+    instanceFieldInterceptor.install(spec.getCleanupInterceptors());
   }
 }

File: spock-guice/src/main/java/org/spockframework/guice/GuiceExtension.java
Patch:
@@ -38,8 +38,7 @@ public void visitSpec(SpecInfo spec) {
     if (moduleClasses.isEmpty()) return;
     
     GuiceInterceptor interceptor = new GuiceInterceptor(spec, moduleClasses);
-    SpecInfo topSpec = spec.getTopSpec();
-    topSpec.getSharedInitializerMethod().addInterceptor(interceptor);
-    topSpec.getInitializerMethod().addInterceptor(interceptor);
+    spec.addSharedInitializerInterceptor(interceptor);
+    spec.addInitializerInterceptor(interceptor);
   }
 }

File: spock-guice/src/main/java/org/spockframework/guice/GuiceInterceptor.java
Patch:
@@ -49,13 +49,13 @@ public GuiceInterceptor(SpecInfo spec, Set<Class<? extends Module>> moduleClasse
   @Override
   public void interceptSharedInitializerMethod(IMethodInvocation invocation) throws Throwable {
     createInjector();
-    injectValues(invocation.getTarget(), true);
+    injectValues(invocation.getSharedInstance(), true);
     invocation.proceed();
   }
 
   @Override
   public void interceptInitializerMethod(IMethodInvocation invocation) throws Throwable {
-    injectValues(invocation.getTarget(), false);
+    injectValues(invocation.getInstance(), false);
     invocation.proceed();
   }
 

File: spock-tapestry/src/main/java/org/spockframework/tapestry/TapestryExtension.java
Patch:
@@ -91,9 +91,8 @@ public void visitSpec(SpecInfo spec) {
     if (modules == null) return;
 
     IMethodInterceptor interceptor = new TapestryInterceptor(spec, modules);
-    SpecInfo topSpec = spec.getTopSpec();
-    topSpec.getSharedInitializerMethod().addInterceptor(interceptor);
-    topSpec.getInitializerMethod().addInterceptor(interceptor);
+    spec.addSharedInitializerInterceptor(interceptor);
+    spec.addInitializerInterceptor(interceptor);
     spec.addCleanupSpecInterceptor(interceptor);
   }
 

File: spock-spring/src/main/java/org/spockframework/spring/SpringInterceptor.java
Patch:
@@ -39,10 +39,10 @@ public void interceptSetupSpecMethod(IMethodInvocation invocation) throws Throwa
 
   @Override
   public void interceptSetupMethod(IMethodInvocation invocation) throws Throwable {
-    manager.prepareTestInstance(invocation.getTarget());
+    manager.prepareTestInstance(invocation.getInstance());
     exception = null;
     beforeTestMethodInvoked = true;
-    manager.beforeTestMethod(invocation.getTarget(),
+    manager.beforeTestMethod(invocation.getInstance(),
         invocation.getFeature().getFeatureMethod().getReflection());
     invocation.proceed();
   }
@@ -65,7 +65,7 @@ public void interceptCleanupMethod(IMethodInvocation invocation) throws Throwabl
 
     Throwable afterTestMethodEx = null;
     try {
-      manager.afterTestMethod(invocation.getTarget(),
+      manager.afterTestMethod(invocation.getInstance(),
           invocation.getFeature().getFeatureMethod().getReflection(), exception);
     } catch (Throwable t) {
       afterTestMethodEx = t;

File: spock-tapestry/src/main/java/org/spockframework/tapestry/TapestryExtension.java
Patch:
@@ -94,7 +94,7 @@ public void visitSpec(SpecInfo spec) {
     SpecInfo topSpec = spec.getTopSpec();
     topSpec.getSharedInitializerMethod().addInterceptor(interceptor);
     topSpec.getInitializerMethod().addInterceptor(interceptor);
-    CollectionUtil.getLastElement(topSpec.getCleanupSpecMethods()).addInterceptor(interceptor);
+    spec.addCleanupSpecInterceptor(interceptor);
   }
 
   // Returns null if no SubModule annotation was found.

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/AutoCleanupExtension.java
Patch:
@@ -17,6 +17,7 @@
 import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension;
 import org.spockframework.runtime.model.FieldInfo;
 import org.spockframework.runtime.model.SpecInfo;
+import org.spockframework.util.CollectionUtil;
 
 import spock.lang.AutoCleanup;
 
@@ -35,7 +36,7 @@ public void visitFieldAnnotation(AutoCleanup annotation, FieldInfo field) {
 
   @Override
   public void visitSpec(SpecInfo spec) {
-    sharedFieldInterceptor.install(spec.getTopSpec().getCleanupSpecMethod());
-    instanceFieldInterceptor.install(spec.getTopSpec().getCleanupMethod());
+    sharedFieldInterceptor.install(CollectionUtil.getLastElement(spec.getTopSpec().getCleanupSpecMethods()));
+    instanceFieldInterceptor.install(CollectionUtil.getLastElement(spec.getTopSpec().getCleanupMethods()));
   }
 }

File: spock-tapestry/src/main/java/org/spockframework/tapestry/TapestryExtension.java
Patch:
@@ -23,6 +23,7 @@
 import org.spockframework.runtime.extension.IGlobalExtension;
 import org.spockframework.runtime.extension.IMethodInterceptor;
 import org.spockframework.runtime.model.SpecInfo;
+import org.spockframework.util.CollectionUtil;
 
 /**
  * Facilitates the creation of integration-level specifications for applications based
@@ -93,8 +94,7 @@ public void visitSpec(SpecInfo spec) {
     SpecInfo topSpec = spec.getTopSpec();
     topSpec.getSharedInitializerMethod().addInterceptor(interceptor);
     topSpec.getInitializerMethod().addInterceptor(interceptor);
-    topSpec.getCleanupMethod().addInterceptor(interceptor);
-    topSpec.getCleanupSpecMethod().addInterceptor(interceptor);
+    CollectionUtil.getLastElement(topSpec.getCleanupSpecMethods()).addInterceptor(interceptor);
   }
 
   // Returns null if no SubModule annotation was found.

File: spock-core/src/main/java/org/spockframework/mock/MockImplementation.java
Patch:
@@ -17,9 +17,8 @@
 import org.spockframework.util.Beta;
 
 /**
- * The <em>implementation</em> of a mock object determines how method calls are processed
- * and matched against interactions. It is chosen at mock creation time, typically by choosing the
- * appropriate {@link spock.lang.MockingApi} factory method.
+ * Determines how method calls are processed and matched against interactions. A mock implementation
+ * is chosen at mock creation time, typically by selecting the appropriate {@link spock.lang.MockingApi} factory method.
  */
 @Beta
 public enum MockImplementation {

File: spock-core/src/main/java/org/spockframework/mock/MockNature.java
Patch:
@@ -17,7 +17,7 @@
 import org.spockframework.util.Beta;
 
 /**
- * A mock <em>nature</em> is a named set of defaults for a mock's configuration options. It is chosen at
+ * A named set of defaults for a mock's configuration options. A mock nature is chosen at
  * mock creation time, typically by selecting the appropriate {@link spock.lang.MockingApi} factory method.
  */
 @Beta

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/StepwiseExtension.java
Patch:
@@ -47,7 +47,7 @@ private void includeFeaturesBeforeLastIncludedFeature(SpecInfo spec) {
   private void skipFeaturesAfterFirstFailingFeature(final SpecInfo spec) {
     spec.getBottomSpec().addListener(new AbstractRunListener() {
       public void error(ErrorInfo error) {
-        // @Dependent only affects class that carries the annotation,
+        // @Stepwise only affects class that carries the annotation,
         // but not sub- and super classes
         if (!error.getMethod().getParent().equals(spec)) return;
 

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UnrollNameProvider.java
Patch:
@@ -28,7 +28,7 @@
  * @author Peter Niederwieser
  */
 public class UnrollNameProvider implements NameProvider<IterationInfo> {
-  private static final Pattern EXPRESSION_PATTERN = Pattern.compile("#([a-zA-Z_\\$][\\w\\$\\.\\(\\)]*)");
+  private static final Pattern EXPRESSION_PATTERN = Pattern.compile("#([a-zA-Z_\\$]([\\w\\$\\.]|\\(\\))*)");
 
   private final FeatureInfo feature;
   private final Matcher expressionMatcher;

File: spock-core/src/main/java/spock/lang/Timeout.java
Patch:
@@ -49,7 +49,7 @@
 @ExtensionAnnotation(TimeoutExtension.class)
 public @interface Timeout {
   /**
-   * The duration after which the execution of the annotated feature or fixture
+   * Returns the duration after which the execution of the annotated feature or fixture
    * method times out.
    *
    * @return the duration after which the execution of the annotated feature or
@@ -58,7 +58,7 @@
   int value();
 
   /**
-   * The duration's time unit
+   * Returns the duration's time unit.
    *
    * @return the duration's time unit
    */

File: spock-core/src/main/java/spock/util/concurrent/PollingConditions.java
Patch:
@@ -47,7 +47,7 @@
 public class PollingConditions {
   private long timeout = 5000;
   private long initialDelay = 0;
-  private long delay = 1000;
+  private long delay = 500;
   private double factor = 1.0;
 
   /**

File: spock-core/src/main/java/org/spockframework/mock/DefaultEqualsInteraction.java
Patch:
@@ -13,10 +13,10 @@
  */
 package org.spockframework.mock;
 
-public class ObjectEqualsInteraction extends DefaultInteraction {
-  public static final ObjectEqualsInteraction INSTANCE = new ObjectEqualsInteraction();
+public class DefaultEqualsInteraction extends DefaultInteraction {
+  public static final DefaultEqualsInteraction INSTANCE = new DefaultEqualsInteraction();
 
-  private ObjectEqualsInteraction() {}
+  private DefaultEqualsInteraction() {}
   
   public String getText() {
     return "Object.equals() interaction";

File: spock-core/src/main/java/org/spockframework/mock/DefaultHashCodeInteraction.java
Patch:
@@ -13,10 +13,10 @@
  */
 package org.spockframework.mock;
 
-public class ObjectHashCodeInteraction extends DefaultInteraction {
-  public static final ObjectHashCodeInteraction INSTANCE = new ObjectHashCodeInteraction();
+public class DefaultHashCodeInteraction extends DefaultInteraction {
+  public static final DefaultHashCodeInteraction INSTANCE = new DefaultHashCodeInteraction();
 
-  private ObjectHashCodeInteraction() {}
+  private DefaultHashCodeInteraction() {}
 
   public String getText() {
     return "Object.hashCode() interaction";

File: spock-core/src/main/java/org/spockframework/mock/DefaultToStringInteraction.java
Patch:
@@ -14,10 +14,10 @@
 
 package org.spockframework.mock;
 
-public class ObjectToStringInteraction extends DefaultInteraction {
-  public static final ObjectToStringInteraction INSTANCE = new ObjectToStringInteraction();
+public class DefaultToStringInteraction extends DefaultInteraction {
+  public static final DefaultToStringInteraction INSTANCE = new DefaultToStringInteraction();
   
-  private ObjectToStringInteraction() {}
+  private DefaultToStringInteraction() {}
 
   public String getText() {
     return "Object.toString() interaction";

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -38,7 +38,7 @@ public class EmptyOrDummyResponse implements IDefaultResponse {
   private EmptyOrDummyResponse() {}
 
   public Object respond(IMockInvocation invocation) {
-    IMockInteraction interaction = EqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
+    IMockInteraction interaction = DefaultEqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
     if (interaction != null) return interaction.accept(invocation);
 
     Class<?> returnType = invocation.getMethod().getReturnType();

File: spock-core/src/main/java/org/spockframework/mock/WildcardMethodNameConstraint.java
Patch:
@@ -23,9 +23,9 @@ public class WildcardMethodNameConstraint implements IInvocationConstraint {
   private WildcardMethodNameConstraint() {}
   
   public boolean isSatisfiedBy(IMockInvocation invocation) {
-    if (ObjectEqualsInteraction.INSTANCE.matches(invocation)) return false;
-    if (ObjectHashCodeInteraction.INSTANCE.matches(invocation)) return false;
-    if (ObjectToStringInteraction.INSTANCE.matches(invocation)) return false;
+    if (DefaultEqualsInteraction.INSTANCE.matches(invocation)) return false;
+    if (DefaultHashCodeInteraction.INSTANCE.matches(invocation)) return false;
+    if (DefaultToStringInteraction.INSTANCE.matches(invocation)) return false;
     return true; 
   }
 }
\ No newline at end of file

File: spock-core/src/main/java/org/spockframework/mock/ZeroOrNullResponse.java
Patch:
@@ -24,7 +24,7 @@ public class ZeroOrNullResponse implements IDefaultResponse {
   private ZeroOrNullResponse() {}
 
   public Object respond(IMockInvocation invocation) {
-    IMockInteraction interaction = EqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
+    IMockInteraction interaction = DefaultEqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
     if (interaction != null) return interaction.accept(invocation);
 
     Class<?> returnType = invocation.getMethod().getReturnType();

File: spock-core/src/main/java/org/spockframework/mock/CallRealMethodResponse.java
Patch:
@@ -17,12 +17,12 @@
 import org.spockframework.util.Beta;
 
 @Beta
-public class CallRealMethodResponse implements IMockResponse {
+public class CallRealMethodResponse implements IDefaultResponse {
   public static final CallRealMethodResponse INSTANCE = new CallRealMethodResponse();
 
   private CallRealMethodResponse() {}
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     return invocation.callRealMethod();
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/CglibRealMethodInvoker.java
Patch:
@@ -17,14 +17,14 @@
 import net.sf.cglib.proxy.MethodProxy;
 import org.spockframework.util.ExceptionUtil;
 
-public class CglibRealMethodInvoker implements IMockResponse {
+public class CglibRealMethodInvoker implements IResponseGenerator {
   private final MethodProxy methodProxy;
 
   public CglibRealMethodInvoker(MethodProxy methodProxy) {
     this.methodProxy = methodProxy;
   }
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     try {
       return methodProxy.invokeSuper(invocation.getMockObject().getInstance(), invocation.getArguments().toArray());
     } catch (Throwable t) {

File: spock-core/src/main/java/org/spockframework/mock/ConstantResponseGenerator.java
Patch:
@@ -22,14 +22,14 @@
  *
  * @author Peter Niederwieser
  */
-public class ConstantResultGenerator extends SingleResultGenerator {
+public class ConstantResponseGenerator extends SingleResponseGenerator {
   private final Object constant;
 
-  public ConstantResultGenerator(Object constant) {
+  public ConstantResponseGenerator(Object constant) {
     this.constant = constant;
   }
 
-  public Object generateSingle(IMockInvocation invocation) {
+  public Object doRespond(IMockInvocation invocation) {
     return GroovyRuntimeUtil.coerce(constant, invocation.getMethod().getReturnType());
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/DynamicProxyMockInterceptorAdapter.java
Patch:
@@ -26,6 +26,6 @@ public DynamicProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor
 
   public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {
     return interceptor.intercept(target, method, arguments,
-        new UnsupportedRealMethodInvoker("Cannot invoke real method on interface based mock object"));
+        new FailingRealMethodInvoker("Cannot invoke real method on interface based mock object"));
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/EmptyOrDummyResponse.java
Patch:
@@ -32,12 +32,12 @@
  * Returns zero, an "empty" object, or a "dummy" object, depending on the method's declared return type.
  */
 @Beta
-public class EmptyOrDummyResponse implements IMockResponse {
+public class EmptyOrDummyResponse implements IDefaultResponse {
   public static final EmptyOrDummyResponse INSTANCE = new EmptyOrDummyResponse();
 
   private EmptyOrDummyResponse() {}
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     IMockInteraction interaction = EqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
     if (interaction != null) return interaction.accept(invocation);
 

File: spock-core/src/main/java/org/spockframework/mock/FailingRealMethodInvoker.java
Patch:
@@ -14,14 +14,14 @@
 
 package org.spockframework.mock;
 
-public class UnsupportedRealMethodInvoker implements IMockResponse {
+public class FailingRealMethodInvoker implements IResponseGenerator {
   private final String message;
 
-  public UnsupportedRealMethodInvoker(String message) {
+  public FailingRealMethodInvoker(String message) {
     this.message = message;
   }
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     throw new CannotInvokeRealMethodException(message);
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/GroovyMockInterceptor.java
Patch:
@@ -36,11 +36,11 @@ public GroovyMockInterceptor(MockConfiguration mockConfiguration, Specification
     this.mockMetaClass = mockMetaClass;
   }
 
-  public Object intercept(Object target, Method method, Object[] arguments, IMockResponse realMethodInvoker) {
+  public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {
     IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getType(), target,
         mockConfiguration.isVerified(), mockConfiguration.isGlobal(), mockConfiguration.getDefaultResponse(), specification);
 
-    if (method.getDeclaringClass() == IMockObjectProvider.class) {
+    if (method.getDeclaringClass() == ISpockMockObject.class) {
       return mockObject;
     }
 

File: spock-core/src/main/java/org/spockframework/mock/GroovyRealMethodInvoker.java
Patch:
@@ -16,14 +16,14 @@
 
 import groovy.lang.MetaClass;
 
-public class GroovyRealMethodInvoker implements IMockResponse {
+public class GroovyRealMethodInvoker implements IResponseGenerator {
   private final MetaClass metaClass;
 
   public GroovyRealMethodInvoker(MetaClass metaClass) {
     this.metaClass = metaClass;
   }
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     Object instance = invocation.getMockObject().getInstance();
     Object[] arguments = invocation.getArguments().toArray();
     if (invocation.getMethod().isStatic()) {

File: spock-core/src/main/java/org/spockframework/mock/IChainableResponseGenerator.java
Patch:
@@ -21,8 +21,6 @@
  *
  * @author Peter Niederwieser
  */
-// TODO: could extend IMockInvocationResponder
-public interface IResultGenerator {
+public interface IChainableResponseGenerator extends IResponseGenerator {
   boolean isAtEndOfCycle();
-  Object generate(IMockInvocation invocation);
 }

File: spock-core/src/main/java/org/spockframework/mock/IDefaultResponse.java
Patch:
@@ -0,0 +1,3 @@
+package org.spockframework.mock;
+
+public interface IDefaultResponse extends IResponseGenerator {}

File: spock-core/src/main/java/org/spockframework/mock/IMockInteraction.java
Patch:
@@ -45,7 +45,5 @@ public interface IMockInteraction {
 
   boolean isExhausted();
 
-  boolean hasResults();
-
   boolean isRequired();
 }

File: spock-core/src/main/java/org/spockframework/mock/IMockObject.java
Patch:
@@ -48,11 +48,11 @@ public interface IMockObject {
   boolean isVerified();
 
   /**
-   * Returns the default responder for this mock object.
+   * Returns the default response strategy for this mock object.
    *
-   * @return the default responder for this mock object
+   * @return the default response strategy for this mock object
    */
-  IMockResponse getResponder();
+  IDefaultResponse getDefaultResponse();
 
   /**
    * Returns the specification that this mock object is attached to.

File: spock-core/src/main/java/org/spockframework/mock/IProxyBasedMockInterceptor.java
Patch:
@@ -17,5 +17,5 @@
 import java.lang.reflect.Method;
 
 public interface IProxyBasedMockInterceptor {
-  Object intercept(Object target, Method method, Object[] arguments, IMockResponse realMethodInvoker);
+  Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker);
 }

File: spock-core/src/main/java/org/spockframework/mock/ISpockMockObject.java
Patch:
@@ -14,6 +14,6 @@
 
 package org.spockframework.mock;
 
-public interface IMockObjectProvider {
+public interface ISpockMockObject {
   IMockObject $spock_get();
 }

File: spock-core/src/main/java/org/spockframework/mock/IterableResponseGenerator.java
Patch:
@@ -26,19 +26,19 @@
  *
  * @author Peter Niederwieser
  */
-public class IterableResultGenerator implements IResultGenerator {
+public class IterableResponseGenerator implements IChainableResponseGenerator {
   private final Iterator<?> iterator;
   private Object nextValue;
 
-  public IterableResultGenerator(Object iterable) {
+  public IterableResponseGenerator(Object iterable) {
     iterator = GroovyRuntimeUtil.asIterator(iterable);
   }
 
   public boolean isAtEndOfCycle() {
     return !iterator.hasNext();
   }
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     if (iterator.hasNext()) nextValue = iterator.next();
     return GroovyRuntimeUtil.coerce(nextValue, invocation.getMethod().getReturnType());
   }

File: spock-core/src/main/java/org/spockframework/mock/JavaMockInterceptor.java
Patch:
@@ -34,11 +34,11 @@ public JavaMockInterceptor(MockConfiguration mockConfiguration, Specification sp
     this.mockMetaClass = mockMetaClass;
   }
 
-  public Object intercept(Object target, Method method, Object[] arguments, IMockResponse realMethodInvoker) {
+  public Object intercept(Object target, Method method, Object[] arguments, IResponseGenerator realMethodInvoker) {
     IMockObject mockObject = new MockObject(mockConfiguration.getName(), mockConfiguration.getType(),
         target, mockConfiguration.isVerified(), false, mockConfiguration.getDefaultResponse(), specification);
 
-    if (method.getDeclaringClass() == IMockObjectProvider.class) {
+    if (method.getDeclaringClass() == ISpockMockObject.class) {
       return mockObject;
     }
 

File: spock-core/src/main/java/org/spockframework/mock/MockDetector.java
Patch:
@@ -19,15 +19,15 @@
 @Beta
 public class MockDetector {
   public static boolean isMock(Object object) {
-    return object instanceof IMockObjectProvider;
+    return object instanceof ISpockMockObject;
   }
 
   public static IMockObject asMock(Object object) {
     if (!isMock(object)) {
       throw new IllegalArgumentException("Not a mock object: " + object.toString());
     }
 
-    IMockObjectProvider provider = (IMockObjectProvider) object;
-    return provider.$spock_get();
+    ISpockMockObject handle = (ISpockMockObject) object;
+    return handle.$spock_get();
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/ProxyBasedMockFactory.java
Patch:
@@ -63,7 +63,7 @@ private Object createDynamicProxyMock(Class<?> mockType, List<Class<?>> addition
     List<Class<?>> interfaces = new ArrayList<Class<?>>();
     interfaces.add(mockType);
     interfaces.addAll(additionalInterfaces);
-    interfaces.add(IMockObjectProvider.class);
+    interfaces.add(ISpockMockObject.class);
     return Proxy.newProxyInstance(
         classLoader,
         interfaces.toArray(new Class<?>[interfaces.size()]),
@@ -80,7 +80,7 @@ static Object createMock(Class<?> type, List<Class<?>> additionalInterfaces, @Nu
       enhancer.setSuperclass(type);
       List<Class<?>> interfaces = new ArrayList<Class<?>>();
       interfaces.addAll(additionalInterfaces);
-      interfaces.add(IMockObjectProvider.class);
+      interfaces.add(ISpockMockObject.class);
       enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));
       enhancer.setCallbackFilter(BridgeMethodAwareCallbackFilter.INSTANCE);
       MethodInterceptor cglibInterceptor = new CglibMockInterceptorAdapter(interceptor);

File: spock-core/src/main/java/org/spockframework/mock/WildcardResponseGenerator.java
Patch:
@@ -21,8 +21,8 @@
  * 
  * @author Peter Niederwieser
  */
-public class WildcardResultGenerator extends SingleResultGenerator {
-  public Object generateSingle(IMockInvocation invocation) {
-    return invocation.getMockObject().getResponder().generate(invocation);
+public class WildcardResponseGenerator extends SingleResponseGenerator {
+  public Object doRespond(IMockInvocation invocation) {
+    return invocation.getMockObject().getDefaultResponse().respond(invocation);
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/ZeroOrNullResponse.java
Patch:
@@ -18,12 +18,12 @@
 import org.spockframework.util.Beta;
 
 @Beta
-public class ZeroOrNullResponse implements IMockResponse {
+public class ZeroOrNullResponse implements IDefaultResponse {
   public static final ZeroOrNullResponse INSTANCE = new ZeroOrNullResponse();
 
   private ZeroOrNullResponse() {}
 
-  public Object generate(IMockInvocation invocation) {
+  public Object respond(IMockInvocation invocation) {
     IMockInteraction interaction = EqualsHashCodeToStringInteractions.INSTANCE.match(invocation);
     if (interaction != null) return interaction.accept(invocation);
 

File: spock-core/src/main/java/org/spockframework/mock/ProxyBasedMockFactory.java
Patch:
@@ -48,8 +48,7 @@ public Object create(Class<?> mockType, List<Class<?>> additionalInterfaces, @Nu
           constructorArgs, mockInterceptor, classLoader, useObjenesis);
     } else {
       throw new CannotCreateMockException(mockType,
-          ". Mocking of non-interface types requires CGLIB. "
-              + "To solve this problem, put cglib-nodep-2.2 or higher on the class path."
+          ". Mocking of non-interface types requires the CGLIB library. Please put cglib-nodep-2.2 or higher on the class path."
       );
     }
 

File: spock-core/src/main/java/org/spockframework/mock/IInteractionScope.java
Patch:
@@ -27,6 +27,8 @@ public interface IInteractionScope {
 
   void addOrderingBarrier();
 
+  void addUnmatchedInvocation(IMockInvocation invocation);
+
   IMockInteraction match(IMockInvocation invocation);
 
   void verifyInteractions();

File: spock-core/src/main/java/org/spockframework/mock/IMockInteraction.java
Patch:
@@ -35,6 +35,8 @@ public interface IMockInteraction {
   @Nullable
   Object accept(IMockInvocation invocation);
 
+  int computeSimilarityScore(IMockInvocation invocation);
+
   boolean isSatisfied();
 
   boolean isExhausted();

File: spock-core/src/main/java/org/spockframework/mock/IMockObject.java
Patch:
@@ -41,6 +41,8 @@ public interface IMockObject {
    */
   Object getInstance();
 
+  boolean isVerified();
+
   IMockInvocationResponder getDefaultResponse();
 
   boolean matches(Object target, IMockInteraction interaction);

File: spock-core/src/main/java/org/spockframework/mock/MockController.java
Patch:
@@ -43,6 +43,9 @@ public synchronized Object handle(IMockInvocation invocation) {
         }
       }
     }
+    for (IInteractionScope scope : scopes) {
+      scope.addUnmatchedInvocation(invocation);
+    }
     return invocation.getMockObject().getDefaultResponse().respond(invocation);
   }
 

File: spock-core/src/main/java/org/spockframework/mock/JavaMockFactory.java
Patch:
@@ -38,7 +38,8 @@ public Object create(MockConfiguration configuration, Specification specificatio
     MetaClass mockMetaClass = GroovyRuntimeUtil.getMetaClass(configuration.getType());
     IProxyBasedMockInterceptor interceptor = new JavaMockInterceptor(configuration, specification, mockMetaClass);
     return ProxyBasedMockFactory.INSTANCE.create(configuration.getType(), Collections.<Class<?>>emptyList(),
-        configuration.getConstructorArgs(), interceptor, specification.getClass().getClassLoader());
+        configuration.getConstructorArgs(), interceptor, specification.getClass().getClassLoader(),
+        configuration.isUseObjenesis());
   }
 }
 

File: spock-core/src/main/java/org/spockframework/mock/MockInstantiator.java
Patch:
@@ -19,15 +19,14 @@
 import org.spockframework.util.Nullable;
 import org.spockframework.util.ReflectionUtil;
 
-import java.lang.reflect.Constructor;
 import java.util.List;
 
 public class MockInstantiator {
   private static final boolean objenesisAvailable = ReflectionUtil.isClassAvailable("org.objenesis.Objenesis");
 
-  public static Object instantiate(Class<?> declaredType, Class<?> actualType, @Nullable List<Object> constructorArgs) {
+  public static Object instantiate(Class<?> declaredType, Class<?> actualType, @Nullable List<Object> constructorArgs, boolean useObjenesis) {
     try {
-      if (constructorArgs == null && objenesisAvailable) {
+      if (constructorArgs == null && useObjenesis && objenesisAvailable) {
         return ObjenesisInstantiator.instantiate(actualType);
       }
       Object[] ctorArgs = constructorArgs == null ? null : constructorArgs.toArray();

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -441,7 +441,7 @@ public MethodCallExpression getSpecificationContext() {
 
   public MethodCallExpression getMockInvocationMatcher() {
     return new MethodCallExpression(getSpecificationContext(),
-        SpecificationContext.GET_MOCK_INVOCATION_MATCHER, ArgumentListExpression.EMPTY_ARGUMENTS);
+        SpecificationContext.GET_MOCK_CONTROLLER, ArgumentListExpression.EMPTY_ARGUMENTS);
   }
 
   public MethodCallExpression setThrownException(Expression value) {

File: spock-core/src/main/java/org/spockframework/mock/CglibMockInterceptorAdapter.java
Patch:
@@ -26,7 +26,7 @@ public CglibMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor) {
     this.interceptor = interceptor;
   }
 
-  public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
-    return interceptor.intercept(obj, method, args);
+  public Object intercept(Object target, Method method, Object[] arguments, MethodProxy methodProxy) throws Throwable {
+    return interceptor.intercept(target, method, arguments, new CglibRealMethodInvoker(methodProxy));
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/DynamicProxyMockInterceptorAdapter.java
Patch:
@@ -24,7 +24,8 @@ public DynamicProxyMockInterceptorAdapter(IProxyBasedMockInterceptor interceptor
     this.interceptor = interceptor;
   }
 
-  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-    return interceptor.intercept(proxy, method, args);
+  public Object invoke(Object target, Method method, Object[] arguments) throws Throwable {
+    return interceptor.intercept(target, method, arguments,
+        new UnsupportedRealMethodInvoker("Cannot invoke real method on interface based mock object"));
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/IMockController.java
Patch:
@@ -19,6 +19,6 @@
 /**
  * @author Peter Niederwieser
  */
-public interface IMockInvocationMatcher {
-  InvocationMatchResult match(IMockInvocation invocation);
+public interface IMockController {
+  Object handle(IMockInvocation invocation);
 }

File: spock-core/src/main/java/org/spockframework/mock/IMockInvocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009 the original author or authors.
+ * Copyright 2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package org.spockframework.mock;
 
-import java.lang.reflect.Method;
 import java.util.List;
 
 /**

File: spock-core/src/main/java/org/spockframework/mock/IProxyBasedMockInterceptor.java
Patch:
@@ -14,8 +14,10 @@
 
 package org.spockframework.mock;
 
+import spock.mock.IMockInvocationResponder;
+
 import java.lang.reflect.Method;
 
 public interface IProxyBasedMockInterceptor {
-  Object intercept(Object target, Method method, Object[] args);
+  Object intercept(Object target, Method method, Object[] arguments, IMockInvocationResponder realMethodInvoker);
 }

File: spock-core/src/main/java/org/spockframework/mock/IResultGenerator.java
Patch:
@@ -21,6 +21,7 @@
  *
  * @author Peter Niederwieser
  */
+// TODO: could extend IMockInvocationResponder
 public interface IResultGenerator {
   boolean isAtEndOfCycle();
   Object generate(IMockInvocation invocation);

File: spock-core/src/main/java/org/spockframework/mock/InteractionBuilder.java
Patch:
@@ -153,7 +153,7 @@ public InteractionBuilder negateLastArg() {
   public static final String ADD_CONSTANT_RESULT = "setConstantResult";
   public InteractionBuilder setConstantResult(Object constant) {
     resultGenerators.addFirst(constant instanceof Wildcard ?
-        new ReturnTypeBasedResultGenerator() : new ConstantResultGenerator(constant));
+        new WildcardResultGenerator() : new ConstantResultGenerator(constant));
     return this;
   }
 

File: spock-core/src/main/java/org/spockframework/mock/JavaMockFactory.java
Patch:
@@ -22,7 +22,6 @@
 import groovy.lang.*;
 
 import org.spockframework.runtime.GroovyRuntimeUtil;
-import org.spockframework.util.*;
 
 import spock.lang.Specification;
 import spock.mock.MockConfiguration;
@@ -38,7 +37,8 @@ public Object create(MockConfiguration configuration, Specification specificatio
 
     MetaClass mockMetaClass = GroovyRuntimeUtil.getMetaClass(configuration.getType());
     IProxyBasedMockInterceptor interceptor = new JavaMockInterceptor(configuration, specification, mockMetaClass);
-    return ProxyBasedMockFactory.INSTANCE.create(configuration.getType(), Collections.<Class<?>>emptyList(), interceptor, specification);
+    return ProxyBasedMockFactory.INSTANCE.create(configuration.getType(), Collections.<Class<?>>emptyList(),
+        configuration.getConstructorArgs(), interceptor, specification.getClass().getClassLoader());
   }
 }
 

File: spock-core/src/main/java/org/spockframework/mock/ObjectEqualsInteraction.java
Patch:
@@ -19,7 +19,7 @@ public class ObjectEqualsInteraction extends DefaultInteraction {
   private ObjectEqualsInteraction() {}
   
   public String getText() {
-    return "default equals() interaction";
+    return "Object.equals() interaction";
   }
 
   public boolean matches(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/ObjectHashCodeInteraction.java
Patch:
@@ -19,7 +19,7 @@ public class ObjectHashCodeInteraction extends DefaultInteraction {
   private ObjectHashCodeInteraction() {}
 
   public String getText() {
-    return "default hashCode() interaction";
+    return "Object.hashCode() interaction";
   }
 
   public boolean matches(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/ObjectToStringInteraction.java
Patch:
@@ -20,7 +20,7 @@ public class ObjectToStringInteraction extends DefaultInteraction {
   private ObjectToStringInteraction() {}
 
   public String getText() {
-    return "default toString() interaction";
+    return "Object.toString() interaction";
   }
 
   public boolean matches(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/WildcardResultGenerator.java
Patch:
@@ -23,8 +23,8 @@
  * 
  * @author Peter Niederwieser
  */
-public class ReturnTypeBasedResultGenerator extends SingleResultGenerator {
+public class WildcardResultGenerator extends SingleResultGenerator {
   public Object generateSingle(IMockInvocation invocation) {
-    return ReflectionUtil.getDefaultValue(invocation.getMethod().getReturnType());
+    return invocation.getMockObject().getDefaultResponse().respond(invocation);
   }
 }

File: spock-core/src/main/java/spock/lang/ISpecificationContext.java
Patch:
@@ -1,6 +1,6 @@
 package spock.lang;
 
-import org.spockframework.mock.IMockInvocationMatcher;
+import org.spockframework.mock.IMockController;
 import org.spockframework.runtime.model.IterationInfo;
 
 @Beta
@@ -9,5 +9,5 @@ public interface ISpecificationContext {
 
   Throwable getThrownException();
 
-  IMockInvocationMatcher getMockInvocationMatcher();
+  IMockController getMockController();
 }

File: spock-core/src/main/java/org/spockframework/builder/DelegatingScript.java
Patch:
@@ -45,7 +45,7 @@ public void setProperty(String property, Object newValue) {
   @Override
   public Object invokeMethod(String name, Object args) {
     try {
-      return GroovyRuntimeUtil.invokeMethod($delegate, name, GroovyRuntimeUtil.asArray(args));
+      return GroovyRuntimeUtil.invokeMethod($delegate, name, GroovyRuntimeUtil.asArgumentArray(args));
     } catch (MissingMethodException e) {
       return super.invokeMethod(name, args);
     }

File: spock-core/src/main/java/org/spockframework/builder/Sculpturer.java
Patch:
@@ -57,9 +57,9 @@ public Object invokeMethod(String name, Object args) {
     Object thisObject = $gestalt.getBlueprint().getThisObject();
     if (thisObject != null) {
       try {
-        return GroovyRuntimeUtil.invokeMethod(thisObject, name, GroovyRuntimeUtil.asArray(args));
+        return GroovyRuntimeUtil.invokeMethod(thisObject, name, GroovyRuntimeUtil.asArgumentArray(args));
       } catch (MissingMethodException ignored) {}
     }
-    return $gestalt.invokeMethod(name, GroovyRuntimeUtil.asArray(args));
+    return $gestalt.invokeMethod(name, GroovyRuntimeUtil.asArgumentArray(args));
   }
 }

File: spock-core/src/main/java/org/spockframework/builder/SetterLikeSlot.java
Patch:
@@ -41,6 +41,6 @@ public Type getType() {
   }
 
   public void write(Object value) {
-    setterLikeMethod.doMethodInvoke(owner, GroovyRuntimeUtil.asArray(value));
+    setterLikeMethod.doMethodInvoke(owner, GroovyRuntimeUtil.asArgumentArray(value));
   }
 }

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -62,15 +62,15 @@ public class AstNodeCache {
   // mocking API
   public final ClassNode MockController = ClassHelper.makeWithoutCaching(MockController.class);
   public final ClassNode InteractionBuilder = ClassHelper.makeWithoutCaching(InteractionBuilder.class);
-  public final FieldNode DefaultMockFactory_INSTANCE;
+  public final FieldNode CompositeMockFactory_INSTANCE;
 
   // external types
   public final ClassNode Throwable = ClassHelper.makeWithoutCaching(Throwable.class);
 
   public AstNodeCache() {
-    ClassNode factory = ClassHelper.makeWithoutCaching(DefaultMockFactory.class);
+    ClassNode factory = ClassHelper.makeWithoutCaching(CompositeMockFactory.class);
     // since ClassNode.getField(String) does not trigger class node initialization, we call getFields() first
     factory.getFields();
-    DefaultMockFactory_INSTANCE = factory.getField(DefaultMockFactory.INSTANCE_FIELD);
+    CompositeMockFactory_INSTANCE = factory.getField(CompositeMockFactory.INSTANCE_FIELD);
   }
 }

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -562,13 +562,13 @@ private Expression rewriteToSpockRuntimeCall(MethodNode method, Expression condi
             new VariableExpression("$spock_valueRecorder"),
             resources.getAstNodeCache().ValueRecorder_Reset,
             ArgumentListExpression.EMPTY_ARGUMENTS) :
-        new ConstantExpression(null));
+        ConstantExpression.NULL);
     args.add(new ConstantExpression(resources.getSourceText(condition)));
     args.add(new ConstantExpression(condition.getLineNumber()));
     args.add(new ConstantExpression(condition.getColumnNumber()));
     // the following means that "assert x, exprEvaluatingToNull" will be
     // treated the same as "assert x"; but probably it doesn't matter too much
-    args.add(message == null ? new ConstantExpression(null) : message);
+    args.add(message == null ? ConstantExpression.NULL : message);
     args.addAll(additionalArgs);
 
     result.setSourcePosition(condition);

File: spock-core/src/main/java/org/spockframework/compiler/InteractionRewriter.java
Patch:
@@ -30,6 +30,7 @@
 import org.spockframework.mock.MockController;
 import org.spockframework.util.Assert;
 import org.spockframework.util.Nullable;
+import org.spockframework.util.ObjectUtil;
 
 /**
  * Creates the AST representation of an InteractionBuilder build sequence.
@@ -95,7 +96,7 @@ private Expression parseResults(Expression expr) {
   }
   
   private Expression parseCount(Expression expr) {
-    BinaryExpression binExpr = AstUtil.asInstance(expr, BinaryExpression.class);
+    BinaryExpression binExpr = ObjectUtil.asInstance(expr, BinaryExpression.class);
     if (binExpr == null || binExpr.getOperation().getType() != Types.MULTIPLY) return expr;
     count = binExpr.getLeftExpression();
     return binExpr.getRightExpression();

File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -233,7 +233,7 @@ List<List<Expression>> transposeTable(List<List<Expression>> rows) {
   }
 
   private void turnIntoSimpleParameterization(List<Expression> column) throws InvalidSpecCompileException {
-    VariableExpression varExpr = AstUtil.asInstance(column.get(0), VariableExpression.class);
+    VariableExpression varExpr = ObjectUtil.asInstance(column.get(0), VariableExpression.class);
     if (varExpr == null)
       throw new InvalidSpecCompileException(column.get(0),
           "Header of data table may only contain variable names");
@@ -264,7 +264,7 @@ private BinaryExpression getOrExpression(Statement stat) {
   }
   
   private BinaryExpression getOrExpression(Expression expr) {
-    BinaryExpression binExpr = AstUtil.asInstance(expr, BinaryExpression.class);  
+    BinaryExpression binExpr = ObjectUtil.asInstance(expr, BinaryExpression.class);
     if (binExpr == null) return null;
     
     int binExprType = binExpr.getOperation().getType();

File: spock-core/src/main/java/org/spockframework/mock/DefaultEqualsInteraction.java
Patch:
@@ -13,8 +13,6 @@
  */
 package org.spockframework.mock;
 
-import java.lang.reflect.Method;
-
 public class DefaultEqualsInteraction extends DefaultInteraction {
   public static final DefaultEqualsInteraction INSTANCE = new DefaultEqualsInteraction();
 

File: spock-core/src/main/java/org/spockframework/mock/IInvocationDispatcher.java
Patch:
@@ -17,7 +17,6 @@
 package org.spockframework.mock;
 
 /**
- *
  * @author Peter Niederwieser
  */
 public interface IInvocationDispatcher {

File: spock-core/src/main/java/org/spockframework/mock/IMockMethod.java
Patch:
@@ -32,6 +32,8 @@ public interface IMockMethod {
    */
   Class<?> getReturnType();
 
+  boolean isStatic();
+
   /**
    * Returns the physical method corresponding to the mocked method. Returns {@code null} if a dynamic
    * method is mocked, or if the target method isn't known because the invocation is intercepted before

File: spock-core/src/main/java/org/spockframework/mock/MockController.java
Patch:
@@ -18,6 +18,7 @@
 
 import java.util.*;
 
+import org.spockframework.lang.GroovyMockOptions;
 import org.spockframework.util.InternalSpockError;
 
 /**
@@ -76,8 +77,8 @@ public synchronized void leaveScope() {
     scope.verifyInteractions();
   }
 
-  public synchronized Object create(String mockName, Class<?> mockType) {
-    return factory.create(mockName, mockType, this);
+  public synchronized Object create(MockSpec spec) {
+    return factory.create(spec, this);
   }
 
   private void throwAnyPreviousError() {

File: spock-core/src/main/java/org/spockframework/mock/MockObject.java
Patch:
@@ -14,6 +14,8 @@
 
 package org.spockframework.mock;
 
+import org.spockframework.util.Nullable;
+
 public class MockObject implements IMockObject {
   private final String name;
   private final Class<?> type;
@@ -29,6 +31,7 @@ public String getName() {
     return name;
   }
 
+  @Nullable
   public Class<?> getType() {
     return type;
   }

File: spock-core/src/main/java/org/spockframework/util/ReflectionUtil.java
Patch:
@@ -14,7 +14,6 @@
 
 package org.spockframework.util;
 
-import java.beans.Introspector;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;

File: spock-core/src/main/java/org/spockframework/mock/DefaultEqualsInteraction.java
Patch:
@@ -25,11 +25,11 @@ public String getText() {
   }
 
   public boolean matches(IMockInvocation invocation) {
-    Method method = invocation.getMethod();
+    IMockMethod method = invocation.getMethod();
 
     return method.getName().equals("equals")
-        && method.getParameterTypes().length == 1
-        && method.getParameterTypes()[0] == Object.class;
+        && method.getParameterTypes().size() == 1
+        && method.getParameterTypes().get(0) == Object.class;
   }
 
   public Object accept(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/DefaultHashCodeInteraction.java
Patch:
@@ -24,7 +24,7 @@ public String getText() {
 
   public boolean matches(IMockInvocation invocation) {
     return invocation.getMethod().getName().equals("hashCode")
-        && invocation.getMethod().getParameterTypes().length == 0;
+        && invocation.getMethod().getParameterTypes().isEmpty();
   }
 
   public Object accept(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/DefaultToStringInteraction.java
Patch:
@@ -25,7 +25,7 @@ public String getText() {
 
   public boolean matches(IMockInvocation invocation) {
     return invocation.getMethod().getName().equals("toString")
-        && invocation.getMethod().getParameterTypes().length == 0;
+        && invocation.getMethod().getParameterTypes().isEmpty();
   }
 
   public Object accept(IMockInvocation invocation) {

File: spock-core/src/main/java/org/spockframework/mock/IMockInvocation.java
Patch:
@@ -35,9 +35,7 @@ public interface IMockInvocation {
   /**
    * The invoked method.
    */
-  // IDEA: replace with our own Method abstraction so that we can also
-  // represent dynamic Groovy calls
-  Method getMethod();
+  IMockMethod getMethod();
 
   /**
    * The arguments for the invocation.

File: spock-core/src/main/java/org/spockframework/runtime/SpecInfoBuilder.java
Patch:
@@ -43,7 +43,7 @@ public SpecInfo build() {
     int order = 0;
     for (SpecInfo curr : spec.getSpecsTopToBottom())
       for (FeatureInfo feature : curr.getFeatures()) {
-        feature.setDeclarationOrder(order); // lift declaration order to spec hierarchy
+        feature.setDeclarationOrder(order); // turn into "global" order that considers whole inheritance chain
         feature.setExecutionOrder(order);
         order++;
       }
@@ -128,7 +128,7 @@ private void buildFeatures() {
       spec.addFeature(createFeature(method, metadata));
     }
 
-    spec.sortFeatures(new IFeatureSortOrder() {
+    Collections.sort(spec.getFeatures(), new IFeatureSortOrder() {
       public int compare(FeatureInfo m1, FeatureInfo m2) {
         return m1.getDeclarationOrder() - m2.getDeclarationOrder();
       }

File: spock-core/src/main/java/org/spockframework/util/GroovyRuntimeUtil.java
Patch:
@@ -161,7 +161,9 @@ public static Object[] despreadList(Object[] args, Object[] spreads, int[] posit
   // first find the MetaMethod and then invoke it, but the problem is that calling
   // MetaMethod.invoke doesn't have the exact same semantics as calling
   // InvokerHelper.invokeMethod, even if the same method is chosen (see Spec GroovyMopExploration)
-  public static boolean isVoidMethod(Object target, String method, Object... args) {
+  public static boolean isVoidMethod(@Nullable Object target, String method, Object... args) {
+    if (target == null) return false; // no way to tell
+
     Class[] argTypes = ReflectionUtil.getTypes(args);
 
     // the way we choose metaClass, we won't find methods on java.lang.Class

File: spock-core/src/main/java/org/spockframework/compiler/SourceLookup.java
Patch:
@@ -22,11 +22,10 @@
 
 public class SourceLookup {
   private final SourceUnit sourceUnit;
-  private final Janitor janitor;
+  private final Janitor janitor = new Janitor();
 
-  public SourceLookup(SourceUnit sourceUnit, Janitor janitor) {
+  public SourceLookup(SourceUnit sourceUnit) {
     this.sourceUnit = sourceUnit;
-    this.janitor = janitor;
   }
 
   public String lookup(ASTNode node) {

File: spock-core/src/main/java/org/spockframework/util/IncompatibleGroovyVersionException.java
Patch:
@@ -14,8 +14,8 @@
 
 package org.spockframework.util;
 
-public class IncompatibleVersionsError extends Error {
-  public IncompatibleVersionsError(String message) {
+public class IncompatibleGroovyVersionException extends RuntimeException {
+  public IncompatibleGroovyVersionException(String message) {
     super(message);
   }
 }

File: spock-core/src/main/java/org/spockframework/util/SpockReleaseInfo.java
Patch:
@@ -29,7 +29,7 @@ public static String getArtifactPath() {
     return SpockReleaseInfo.class.getProtectionDomain().getCodeSource().getLocation().toString();
   }
 
-  public static boolean isCompatibleWithGroovyVersion(VersionNumber groovyVersion) {
+  public static boolean isCompatibleGroovyVersion(VersionNumber groovyVersion) {
     if (groovyVersion == VersionNumber.UNKNOWN) return true;
 
     return minGroovyVersion.compareTo(groovyVersion) <= 0

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TimeoutInterceptor.java
Patch:
@@ -53,11 +53,11 @@ public void run() {
     if (thread.isAlive()) {
       StackTraceElement[] stack = thread.getStackTrace();
 
-      // IDEA: Isn't thread.stop() more likey to succeed (considering it throws
+      // IDEA: Isn't thread.stop() more likely to succeed (considering it throws
       // an Error instead of an Exception)? Are its risks tolerable here?
       thread.interrupt();
-      SpockTimeoutError error = new SpockTimeoutError("method timed out after %s %s",
-          timeout.value(), timeout.unit().toString().toLowerCase());
+      SpockTimeoutError error = new SpockTimeoutError(timeout.value(), timeout.unit(),
+          "method timed out after %d %s", timeout.value(), timeout.unit().toString().toLowerCase());
       error.setStackTrace(stack);
       throw error;
     }

File: spock-core/src/main/java/spock/util/concurrent/AsyncConditions.java
Patch:
@@ -136,7 +136,7 @@ public void await(int timeout, TimeUnit unit) throws InterruptedException, Throw
     
     long pendingEvalBlocks = latch.getCount();
     if (pendingEvalBlocks > 0)
-      throw new SpockTimeoutError(
+      throw new SpockTimeoutError(timeout, unit,
           "Async conditions timed out after %d %s; %d out of %d evaluate blocks did not complete in time",
           timeout, unit.toString().toLowerCase(), pendingEvalBlocks, numEvalBlocks);
   }

File: spock-core/src/main/java/spock/util/concurrent/BlockingVariable.java
Patch:
@@ -99,7 +99,7 @@ public BlockingVariable(int timeout, TimeUnit unit) {
    */
   public T get() throws InterruptedException {
     if (!valueReady.await(timeout, unit))
-      throw new SpockTimeoutError("BlockingVariable.get() timed out after %d %s",
+      throw new SpockTimeoutError(timeout, unit, "BlockingVariable.get() timed out after %d %s",
           timeout, unit.toString().toLowerCase());
     return value;
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/JUnitFixtureMethodsExtension.java
Patch:
@@ -27,6 +27,7 @@
 
 import org.spockframework.runtime.extension.*;
 import org.spockframework.runtime.model.*;
+import org.spockframework.util.ReflectionUtil;
 import org.spockframework.util.UnreachableCodeError;
 
 /**
@@ -139,9 +140,8 @@ public FixtureMethodInterceptor(Collection<Method> methods) {
       public void intercept(IMethodInvocation invocation) throws Throwable {
         if (!executeBeforeSpecMethod) invocation.proceed();
 
-        // TODO - handle invocation errors in a more user friendly way?
         for (Method method : methods) {
-          method.invoke(invocation.getTarget());
+          ReflectionUtil.invokeMethod(invocation.getTarget(), method);
         }
 
         if (executeBeforeSpecMethod) invocation.proceed();

File: spock-core/src/main/java/org/spockframework/mock/CodeResultGenerator.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @author Peter Niederwieser
  */
-public class CodeResultGenerator implements IResultGenerator {
+public class CodeResultGenerator extends SingleResultGenerator {
   private final Closure code;
   private final boolean provideExtendedInfo;
 
@@ -34,7 +34,7 @@ public CodeResultGenerator(Closure code) {
     provideExtendedInfo = paramTypes.length == 1 && paramTypes[0] == IMockInvocation.class;
   }
 
-  public Object generate(IMockInvocation invocation) {
+  public Object generateSingle(IMockInvocation invocation) {
     Object result = GroovyRuntimeUtil.invokeClosure(code, provideExtendedInfo ? invocation : invocation.getArguments());
     Class<?> returnType = invocation.getMethod().getReturnType();
     

File: spock-core/src/main/java/org/spockframework/mock/ConstantResultGenerator.java
Patch:
@@ -22,14 +22,14 @@
  *
  * @author Peter Niederwieser
  */
-public class ConstantResultGenerator implements IResultGenerator {
+public class ConstantResultGenerator extends SingleResultGenerator {
   private final Object constant;
 
   public ConstantResultGenerator(Object constant) {
     this.constant = constant;
   }
 
-  public Object generate(IMockInvocation invocation) {
+  public Object generateSingle(IMockInvocation invocation) {
     return GroovyRuntimeUtil.coerce(constant, invocation.getMethod().getReturnType());
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/IResultGenerator.java
Patch:
@@ -22,5 +22,6 @@
  * @author Peter Niederwieser
  */
 public interface IResultGenerator {
+  boolean isExhausted();
   Object generate(IMockInvocation invocation);
 }

File: spock-core/src/main/java/org/spockframework/runtime/BaseSpecRunner.java
Patch:
@@ -192,6 +192,7 @@ private MethodInfo createMethodInfoForDoRunFeature() {
    */
   @SuppressWarnings("unused")
   public void doRunFeature() {
+    currentFeature.setIterationNameProvider(new SafeIterationNameProvider(currentFeature.getIterationNameProvider()));
     if (currentFeature.isParameterized())
       runParameterizedFeature();
     else runSimpleFeature();
@@ -225,8 +226,7 @@ private void runIteration(Object[] dataValues, int estimatedNumIterations) {
 
   private IterationInfo createIterationInfo(Object[] dataValues, int estimatedNumIterations) {
     currentIteration = new IterationInfo(currentFeature, dataValues, estimatedNumIterations);
-    SafeIterationNameProvider nameProvider = new SafeIterationNameProvider(currentFeature.getIterationNameProvider());
-    String iterationName = nameProvider.getName(currentIteration);
+    String iterationName = currentFeature.getIterationNameProvider().getName(currentIteration);
     currentIteration.setName(iterationName);
     Description description = Description.createTestDescription(spec.getReflection(),
         iterationName, currentFeature.getFeatureMethod().getReflection().getAnnotations());

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/ClosureBasedUnrollNameProvider.java
Patch:
@@ -25,7 +25,7 @@
 public class ClosureBasedUnrollNameProvider implements NameProvider<IterationInfo> {
   private final FeatureInfo feature;
   private final Class<? extends Closure> closureClass;
-  private int iterationCount;
+  private int iterationCount = -1;
 
   public ClosureBasedUnrollNameProvider(FeatureInfo feature, Class<? extends Closure> nameGeneratorType) {
     this.feature = feature;

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UnrollExtension.java
Patch:
@@ -49,6 +49,6 @@ private NameProvider<IterationInfo> chooseNameProvider(Unroll unroll, FeatureInf
     if (feature.getName().contains("#")) {
       return new UnrollNameProvider(feature, feature.getName());
     }
-    return new UnrollNameProvider(feature, "#featureName[#iterationCount]");
+    return null;
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/BaseSpecRunner.java
Patch:
@@ -192,6 +192,7 @@ private MethodInfo createMethodInfoForDoRunFeature() {
    */
   @SuppressWarnings("unused")
   public void doRunFeature() {
+    currentFeature.setIterationNameProvider(new SafeIterationNameProvider(currentFeature.getIterationNameProvider()));
     if (currentFeature.isParameterized())
       runParameterizedFeature();
     else runSimpleFeature();
@@ -225,8 +226,7 @@ private void runIteration(Object[] dataValues, int estimatedNumIterations) {
 
   private IterationInfo createIterationInfo(Object[] dataValues, int estimatedNumIterations) {
     currentIteration = new IterationInfo(currentFeature, dataValues, estimatedNumIterations);
-    SafeIterationNameProvider nameProvider = new SafeIterationNameProvider(currentFeature.getIterationNameProvider());
-    String iterationName = nameProvider.getName(currentIteration);
+    String iterationName = currentFeature.getIterationNameProvider().getName(currentIteration);
     currentIteration.setName(iterationName);
     currentIteration.setDescription(Description.createTestDescription(spec.getReflection(),
         iterationName, currentFeature.getFeatureMethod().getReflection().getAnnotations()));

File: spock-core/src/main/java/org/spockframework/runtime/BaseSpecRunner.java
Patch:
@@ -228,7 +228,7 @@ private IterationInfo createIterationInfo(Object[] dataValues, int estimatedNumI
     NameProvider<IterationInfo> nameProvider = SafeNameProvider.create(currentFeature.getIterationNameProvider(), currentFeature.getName());
     String iterationName = nameProvider.getName(currentIteration);
     currentIteration.setName(iterationName);
-    currentIteration.setDescription(Description.createTestDescription(spec.getClass(),
+    currentIteration.setDescription(Description.createTestDescription(spec.getReflection(),
         iterationName, currentFeature.getFeatureMethod().getReflection().getAnnotations()));
     return currentIteration;
   }

File: spock-core/src/main/java/org/spockframework/runtime/JUnitDescriptionGenerator.java
Patch:
@@ -54,7 +54,7 @@ public Description aggregate() {
 
     for (FeatureInfo feature : spec.getAllFeaturesInExecutionOrder()) {
       if (feature.isExcluded()) continue;
-      if (feature.isUnrolled()) continue; // don't report up-front because IDEs don't handle this well
+      if (feature.isReportIterations()) continue; // don't report up-front because IDEs don't handle this well
       desc.addChild(feature.getFeatureMethod().getDescription());
     }
 

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/MethodRuleInterceptor.java
Patch:
@@ -57,7 +57,7 @@ private FrameworkMethod createFrameworkMethod(final IMethodInvocation invocation
     return new FrameworkMethod(invocation.getMethod().getReflection()) {
       @Override
       public String getName() {
-        return invocation.getMethod().getName();
+        return invocation.getIteration().getDescription().getMethodName();
       }
     };
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TestRuleInterceptor.java
Patch:
@@ -42,8 +42,8 @@ public void intercept(final IMethodInvocation invocation) throws Throwable {
       Object rule = field.readValue(target);
       if (!(rule instanceof TestRule)) continue;
 
-      Description description = field.isStatic() || field.isShared() ?
-          invocation.getSpec().getDescription() : invocation.getFeature().getDescription();
+      Description description = invocation.getIteration() != null ?
+          invocation.getIteration().getDescription() : invocation.getSpec().getDescription();
       stat = ((TestRule) rule).apply(stat, description);
     }
 

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoBuilder.java
Patch:
@@ -53,7 +53,7 @@ public ExpressionInfo build() {
 
     BlockStatement blockStat = unit.getAST().getStatementBlock();
     Assert.that(blockStat != null && blockStat.getStatements().size() == 1);
-    Statement stat = (Statement)blockStat.getStatements().get(0);
+    Statement stat = blockStat.getStatements().get(0);
     Assert.that(stat instanceof ExpressionStatement);
     Expression expr = ((ExpressionStatement)stat).getExpression();
 

File: spock-core/src/main/java/org/spockframework/runtime/SpockComparisonFailure.java
Patch:
@@ -38,7 +38,7 @@ public Condition getCondition() {
 
   @Override
   public String getMessage() {
-    return "Condition not satisfied:\n\n" + condition.render();
+    return "Condition not satisfied:\n\n" + condition.getRendering();
   }
 
   @Override

File: spock-core/src/main/java/spock/lang/Unroll.java
Patch:
@@ -24,7 +24,7 @@
  * @author Peter Niederwieser
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
+@Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Unroll {
   String value() default "";
 }

File: spock-core/src/main/java/spock/lang/Unroll.java
Patch:
@@ -26,7 +26,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.METHOD)
 public @interface Unroll {
-  // to ensure best possible tool support, we use the same default naming
-  // scheme as JUnit's @Parameterized
-  String value() default "#featureName[#iterationCount]";
+  String value() default "";
 }

File: spock-core/src/main/java/spock/lang/Timeout.java
Patch:
@@ -39,6 +39,9 @@
    * The duration after which the execution of the annotated feature or fixture
    * method times out.
    *
+   * The stack trace of the failure exception will be the execution stack of the test when the
+   * timeout is reached.
+   *
    * @return the duration after which the execution of the annotated feature or
    * fixture method times out
    */

File: spock-core/src/main/java/org/spockframework/runtime/StackTraceFilter.java
Patch:
@@ -113,6 +113,6 @@ private StackTraceElement prettyPrintClosureInvocation(StackTraceElement elem, M
   }
 
   private boolean isGeneratedMethod(StackTraceElement elem) {
-    return elem.getClassName().contains("$") || elem.getMethodName().contains("$");
+    return elem.getLineNumber() < 0;
   }
 }
\ No newline at end of file

File: spock-core/src/main/java/org/spockframework/mock/PositionalArgumentListConstraint.java
Patch:
@@ -59,7 +59,7 @@ private List<Object> expandVarArgs(List<Object> args) {
   }
 
   private boolean areConstraintsSatisfiedBy(List<Object> args) {
-    if (argConstraints.isEmpty() && args.isEmpty()) return true;
+    if (argConstraints.isEmpty()) return args.isEmpty();
     if (argConstraints.size() - args.size() > 1) return false;
     
     for (int i = 0; i < argConstraints.size() - 1; i++) {

File: spock-core/src/main/java/org/spockframework/compiler/AstUtil.java
Patch:
@@ -24,6 +24,7 @@
 import org.codehaus.groovy.syntax.Types;
 import org.objectweb.asm.Opcodes;
 
+import org.spockframework.lang.Wildcard;
 import org.spockframework.runtime.SpockRuntime;
 import org.spockframework.util.InternalSpockError;
 import org.spockframework.util.Nullable;
@@ -102,7 +103,7 @@ public static Expression getInvocationTarget(Expression expr) {
 
   public static boolean isWildcardRef(Expression expr) {
     VariableExpression varExpr = AstUtil.asInstance(expr, VariableExpression.class);
-    if (varExpr == null || !varExpr.getName().equals(Specification._.toString())) return false;
+    if (varExpr == null || !varExpr.getName().equals(Wildcard.INSTANCE.toString())) return false;
 
     Variable accessedVar = varExpr.getAccessedVariable();
     if (accessedVar instanceof FieldNode) // Groovy 1.7.6 and higher

File: spock-core/src/main/java/org/spockframework/util/CollectionUtil.java
Patch:
@@ -57,7 +57,7 @@ public static <T> void addLastElement(List<T> list, T element) {
   public static <T> Iterable<T> reverse(final List<T> list) {
     return new Iterable<T>() {
       public Iterator<T> iterator() {
-        final ListIterator<T> listIterator = list.listIterator();
+        final ListIterator<T> listIterator = list.listIterator(list.size());
 
         return new Iterator<T>() {
           public boolean hasNext() {

File: spock-core/src/main/java/org/spockframework/runtime/model/FeatureInfo.java
Patch:
@@ -109,11 +109,11 @@ public boolean isParameterized() {
   }
 
   public boolean isUnrolled() {
-    return isParameterized() && getReflection().isAnnotationPresent(Unroll.class);
+    return isParameterized() && getFeatureMethod().getReflection().isAnnotationPresent(Unroll.class);
   }
 
   public Unroll getUnroll() {
-    return getReflection().getAnnotation(Unroll.class);
+    return getFeatureMethod().getReflection().getAnnotation(Unroll.class);
   }
 
   public boolean isExcluded() {

File: spock-core/src/main/java/org/spockframework/runtime/JUnitSupervisor.java
Patch:
@@ -144,11 +144,11 @@ private String renderValue(Object value) {
   private int statusFor(ErrorInfo error) {
     switch (error.getMethod().getKind()) {
       case DATA_PROCESSOR:
-        return END_ITERATION;
+      case ITERATION_EXECUTION:
       case SETUP:
       case CLEANUP:
       case FEATURE:
-        return feature.isParameterized() ? END_ITERATION : END_FEATURE;
+        return END_ITERATION;
       case FEATURE_EXECUTION:
       case DATA_PROVIDER:
         return END_FEATURE;

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodInfo.java
Patch:
@@ -41,7 +41,8 @@ public void setKind(MethodKind kind) {
     this.kind = kind;
   }
 
-  public @Nullable FeatureInfo getFeature() {
+  @Nullable
+  public FeatureInfo getFeature() {
     return feature;
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/model/MethodKind.java
Patch:
@@ -30,7 +30,8 @@ public enum MethodKind {
   DATA_PROVIDER,
   DATA_PROCESSOR,
   SPEC_EXECUTION,
-  FEATURE_EXECUTION;
+  FEATURE_EXECUTION,
+  ITERATION_EXECUTION;
 
   public boolean isFixtureMethod() {
     return isSetupMethod() || isCleanupMethod();

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/UseInterceptor.java
Patch:
@@ -37,8 +37,8 @@ public UseInterceptor(List<Class> categories) {
 
   public void intercept(final IMethodInvocation invocation) throws Throwable {
     DefaultGroovyMethods.use(null, categories,
-        new Closure(invocation.getTarget(), invocation.getTarget()) {
-          public Object doCall(Object[] args) throws Throwable {
+        new Closure<Void>(invocation.getTarget(), invocation.getTarget()) {
+          public Void doCall(Object[] args) throws Throwable {
             invocation.proceed();
             return null;
           }

File: spock-core/src/main/java/org/spockframework/builder/ClosureBlueprint.java
Patch:
@@ -16,6 +16,8 @@
 
 import groovy.lang.Closure;
 
+import org.spockframework.util.GroovyRuntimeUtil;
+
 public class ClosureBlueprint implements IBlueprint {
   private final Closure closure;
   private final Object subject;
@@ -35,6 +37,6 @@ public void setDelegate(Object delegate) {
   }
 
   public void evaluate() {
-    closure.call(subject);
+    GroovyRuntimeUtil.callClosure(closure, subject);
   }
 }
\ No newline at end of file

File: spock-core/src/main/java/org/spockframework/experimental/ClosureBasedUnrolledFeatureNameGenerator.java
Patch:
@@ -22,6 +22,7 @@
 import groovy.lang.*;
 
 import org.spockframework.runtime.model.FeatureInfo;
+import org.spockframework.util.GroovyRuntimeUtil;
 
 import spock.lang.Unroll;
 
@@ -49,7 +50,7 @@ public ClosureBasedUnrolledFeatureNameGenerator(GroovyShell shell, FeatureInfo f
   public String nameFor(Object[] args) {
     consecutiveNumber++;
     nameGenerator.setDelegate(new NameGeneratorValues(args));
-    return nameGenerator.call().toString();
+    return GroovyRuntimeUtil.callClosure(nameGenerator).toString();
   }
 
   private String convertToGString(String template) {

File: spock-core/src/main/java/org/spockframework/mock/CodeArgumentConstraint.java
Patch:
@@ -33,6 +33,6 @@ public CodeArgumentConstraint(Closure code) {
   }
 
   public boolean isSatisfiedBy(Object argument) {
-    return GroovyRuntimeUtil.isTruthy(code.call(argument));
+    return GroovyRuntimeUtil.isTruthy(GroovyRuntimeUtil.callClosure(code, argument));
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/CodeResultGenerator.java
Patch:
@@ -35,7 +35,7 @@ public CodeResultGenerator(Closure code) {
   }
 
   public Object generate(IMockInvocation invocation) {
-    Object result = code.call(provideExtendedInfo ? invocation : invocation.getArguments());
+    Object result = GroovyRuntimeUtil.callClosure(code, provideExtendedInfo ? invocation : invocation.getArguments());
     Class<?> returnType = invocation.getMethod().getReturnType();
     
     // don't attempt cast for void methods (closure could be an action that accidentally returns a value)

File: spock-core/src/main/java/org/spockframework/runtime/ConfigurationScriptLoader.java
Patch:
@@ -23,6 +23,7 @@
 import org.codehaus.groovy.control.CompilerConfiguration;
 
 import org.spockframework.builder.DelegatingScript;
+import org.spockframework.util.GroovyRuntimeUtil;
 import org.spockframework.util.Nullable;
 
 import spock.config.ConfigurationException;
@@ -71,7 +72,7 @@ public DelegatingScript loadClosureBasedScript(final Closure closure) {
     return new DelegatingScript() {
       @Override
       public Object run() {
-        closure.call();
+        GroovyRuntimeUtil.callClosure(closure);
         return null;
       }
 

File: spock-core/src/main/java/org/spockframework/runtime/HamcrestFacade.java
Patch:
@@ -73,7 +73,7 @@ static String getFailureDescription(Object matcher, Object value, @Nullable Stri
             .appendValue(value);
       } else { // 1.2
         description.appendText("\n     but: ");
-        ReflectionUtil.invokeMethod(matcher, describeMismatchMethod, void.class, value, description);
+        ReflectionUtil.invokeMethod(matcher, describeMismatchMethod, value, description);
       }
 
       return description.toString();

File: spock-core/src/main/java/org/spockframework/runtime/extension/ExtensionUtil.java
Patch:
@@ -20,7 +20,6 @@
 import org.junit.internal.runners.model.MultipleFailureException;
 
 public class ExtensionUtil {
-  // TODO: throw our own multi-exception type
   public static void throwAll(List<? extends Throwable> exceptions) throws Throwable {
     if (exceptions.isEmpty()) return;
     if (exceptions.size() == 1) throw exceptions.get(0);

File: spock-core/src/main/java/spock/lang/Specification.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.spockframework.mock.MockController;
 import org.spockframework.runtime.*;
+import org.spockframework.util.GroovyRuntimeUtil;
 
 import groovy.lang.Closure;
 
@@ -200,7 +201,7 @@ public <T> T Mock(Class<T> type) {
    * @param block a block of code containing one or more interaction definitions
    */
   public void interaction(Closure block) {
-    block.call();
+    GroovyRuntimeUtil.callClosure(block);
   }
 
   /**

File: spock-spring/src/main/java/org/spockframework/spring/SpringTestContextManager.java
Patch:
@@ -37,12 +37,12 @@ public SpringTestContextManager(Class<?> testClass) {
 
   public void beforeTestClass() throws Exception {
     if (beforeTestClassMethod != null)
-      ReflectionUtil.invokeMethodThatThrowsException(delegate, beforeTestClassMethod);
+      ReflectionUtil.invokeMethod(delegate, beforeTestClassMethod);
   }
 
   public void afterTestClass() throws Exception {
     if (afterTestClassMethod != null)
-      ReflectionUtil.invokeMethodThatThrowsException(delegate, afterTestClassMethod);
+      ReflectionUtil.invokeMethod(delegate, afterTestClassMethod);
   }
 
   public void prepareTestInstance(Object testInstance) throws Exception {

File: spock-core/src/main/java/org/spockframework/runtime/RunContext.java
Patch:
@@ -107,8 +107,9 @@ private IObjectRenderer<Object> createDiffedObjectRenderer() {
     return service;
   }
 
-  public static <T> T withNewContext(@Nullable DelegatingScript configurationScript,
-      List<Class<?>> extensionClasses, boolean inheritParentExtensions, IFunction<RunContext, T> command) {
+  public static <T, U extends Throwable> T withNewContext(@Nullable DelegatingScript configurationScript,
+      List<Class<?>> extensionClasses, boolean inheritParentExtensions,
+      IThrowableFunction<RunContext, T, U> command) throws U {
     List<Class<?>> allExtensionClasses = new ArrayList<Class<?>>(extensionClasses);
     if (inheritParentExtensions) allExtensionClasses.addAll(getCurrentExtensions());
     

File: spock-core/src/main/java/org/spockframework/util/IFunction.java
Patch:
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.spockframework.util;
 
 /**
- * A mathematical function from domain D to co-domain C.
+ * A function from domain D to co-domain C.
  * 
  * @author Peter Niederwieser
  */
-public interface IFunction<D,C> {
+public interface IFunction<D, C> extends IThrowableFunction<D, C, Throwable> {
   C apply(D value);
 }

File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -127,7 +127,7 @@ private AnnotationNode createDataProviderAnnotation(Expression dataProviderExpr,
   }
 
   private Parameter createDataProcessorParameter() {
-    Parameter p = new Parameter(ClassHelper.DYNAMIC_TYPE, "p" + dataProcessorParams.size());
+    Parameter p = new Parameter(ClassHelper.DYNAMIC_TYPE, "$spock_p" + dataProcessorParams.size());
     dataProcessorParams.add(p);
     return p;
   }

File: spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java
Patch:
@@ -55,7 +55,9 @@ public static void verifyMethodCondition(@Nullable ValueRecorder recorder, @Null
     Object result = safe ? InvokerHelper.invokeMethodSafe(target, method, args)
         : InvokerHelper.invokeMethod(target, method, args);
 
-    recorder.replaceLastValue(result);
+    if (recorder != null) {
+      recorder.replaceLastValue(result);
+    }
     
     if (!explicit && result == null && GroovyRuntimeUtil.isVoidMethod(target, method, args)) return;
 

File: spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java
Patch:
@@ -55,7 +55,9 @@ public static void verifyMethodCondition(@Nullable ValueRecorder recorder, @Null
     Object result = safe ? InvokerHelper.invokeMethodSafe(target, method, args)
         : InvokerHelper.invokeMethod(target, method, args);
 
-    recorder.replaceLastValue(result);
+    if (recorder != null) {
+      recorder.replaceLastValue(result);
+    }
     
     if (!explicit && result == null && GroovyRuntimeUtil.isVoidMethod(target, method, args)) return;
 

File: spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java
Patch:
@@ -55,7 +55,9 @@ public static void verifyMethodCondition(@Nullable ValueRecorder recorder, @Null
     Object result = safe ? InvokerHelper.invokeMethodSafe(target, method, args)
         : InvokerHelper.invokeMethod(target, method, args);
 
-    recorder.replaceLastValue(result);
+    if (recorder != null) {
+      recorder.replaceLastValue(result);
+    }
     
     if (!explicit && result == null && GroovyRuntimeUtil.isVoidMethod(target, method, args)) return;
 

File: spock-core/src/main/java/org/spockframework/compiler/IRewriteResourceProvider.java
Patch:
@@ -25,12 +25,14 @@
 
 import org.spockframework.compiler.model.Block;
 import org.spockframework.compiler.model.Method;
+import org.spockframework.compiler.model.Spec;
 
 /**
  *
  * @author Peter Niederwieser
  */
 public interface IRewriteResourceProvider {
+  Spec getCurrentSpec();
   Method getCurrentMethod();
   Block getCurrentBlock();
   void defineValueRecorder(List<Statement> stats);

File: spock-core/src/main/java/org/spockframework/compiler/SpecParser.java
Patch:
@@ -21,7 +21,6 @@
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.stmt.Statement;
-import org.objectweb.asm.Opcodes;
 
 import static org.spockframework.util.Identifiers.*;
 import org.spockframework.compiler.model.*;
@@ -61,7 +60,7 @@ public void visitClass(ClassNode clazz) {
   // although it IS related to a user-provided definition
   public void visitField(FieldNode gField) {
     PropertyNode owner = spec.getAst().getProperty(gField.getName());
-    if (gField.isStatic() || (gField.getModifiers() & Opcodes.ACC_STATIC) != 0) return;
+    if (gField.isStatic()) return;
 
     Field field = new Field(spec, gField, fieldCount++);
     field.setShared(AstUtil.hasAnnotation(gField, Shared.class));

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedObjectAsBeanRenderer.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.spockframework.util.GroovyRuntimeUtil;
 
-public class DiffedObjectRenderer implements IObjectRenderer<Object> {
+public class DiffedObjectAsBeanRenderer implements IObjectRenderer<Object> {
   public String render(Object object) {
     LineBuilder builder = new LineBuilder();
 

File: spock-core/src/main/java/org/spockframework/runtime/condition/DiffedObjectAsBeanRenderer.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.spockframework.util.GroovyRuntimeUtil;
 
-public class DiffedObjectRenderer implements IObjectRenderer<Object> {
+public class DiffedObjectAsBeanRenderer implements IObjectRenderer<Object> {
   public String render(Object object) {
     LineBuilder builder = new LineBuilder();
 

File: spock-core/src/main/java/org/spockframework/runtime/condition/ObjectRendererService.java
Patch:
@@ -27,7 +27,7 @@ public <T> void addRenderer(Class<T> type, IObjectRenderer<? super T> renderer)
 
   @SuppressWarnings("unchecked")
   public String render(Object object) {
-    // cast required although IDEA thinks it's superfluous
+    // cast required although IDEA thinks it's unnecessary
     Set<Class<?>> types = Collections.<Class<?>>singleton(object.getClass());
 
     while (!types.isEmpty()) {

File: spock-core/src/main/java/org/spockframework/compiler/AstUtil.java
Patch:
@@ -190,7 +190,7 @@ public static List<Expression> getArguments(StaticMethodCallExpression expr) {
   public static Expression toArgumentArray(List<Expression> argList, IRewriteResourceProvider resourceProvider) {
     List<Expression> normalArgs = new ArrayList<Expression>();
     List<Expression> spreadArgs = new ArrayList<Expression>();
-    List<ConstantExpression> spreadPositions = new ArrayList<ConstantExpression>();
+    List<Expression> spreadPositions = new ArrayList<Expression>();
 
     for (int i = 0; i < argList.size(); i++) {
       Expression arg = argList.get(i);

File: spock-core/src/main/java/org/spockframework/runtime/ParameterizedSpecRunner.java
Patch:
@@ -119,6 +119,7 @@ private void runIterations(Iterator[] iterators, int estimatedNumIterations) {
 
     while (haveNext(iterators)) {
       IterationInfo iteration = new IterationInfo(nextArgs(iterators), estimatedNumIterations);
+      iteration.setParent(currentFeature);
       runIteration(iteration);
 
       if (resetStatus(ITERATION) != OK) break;

File: spock-core/src/main/java/org/spockframework/runtime/JUnitSupervisor.java
Patch:
@@ -58,7 +58,7 @@ public void beforeFeature(FeatureInfo feature) {
     Unroll unroll = feature.getFeatureMethod().getReflection().getAnnotation(Unroll.class);
     unrollFeature = unroll != null;
     if (unrollFeature)
-      unrolledNameGenerator = new UnrolledFeatureNameGenerator(feature, unroll);
+      unrolledNameGenerator = new UnrolledFeatureNameGenerator(feature, unroll.value());
     else
       notifier.fireTestStarted(getDescription(feature.getFeatureMethod()));
 
@@ -97,7 +97,7 @@ public int error(ErrorInfo error) {
       case DATA_PROCESSOR:
         return END_ITERATION;
       case SETUP:
-      case CLEANUP:     
+      case CLEANUP:
       case FEATURE:
         return feature.isParameterized() ? END_ITERATION : END_FEATURE;
       case FEATURE_EXECUTION:
@@ -151,7 +151,7 @@ public void featureSkipped(FeatureInfo feature) {
   }
 
   private Description getDescription(NodeInfo node) {
-    return (Description)node.getMetadata();
+    return (Description) node.getMetadata();
   }
 
   private Description getCurrentDescription() {

File: spock-core/src/main/java/org/spockframework/util/GroovyRuntimeUtil.java
Patch:
@@ -30,8 +30,8 @@ public static boolean isTruthy(Object obj) {
     return DefaultTypeTransformation.castToBoolean(obj);
   }
 
-  public static <T> T coerce(Object obj, Class<T> type) {
-    return type.cast(DefaultTypeTransformation.castToType(obj, type));
+  public static Object coerce(Object obj, Class<?> type) {
+    return DefaultTypeTransformation.castToType(obj, type);
   }
 
   public static boolean equals(Object obj, Object other) {

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -351,6 +351,7 @@ private void deactivateMethod(MethodNode method) {
     method.setCode(block);
     method.setReturnType(ClassHelper.VOID_TYPE);
     method.setVariableScope(new VariableScope());
+    method.getAnnotations().clear(); // important to avoid problem with annotation closures
   }
 
   // where block must be rewritten before all other blocks

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/RuleExtension.java
Patch:
@@ -25,7 +25,7 @@
 public class RuleExtension implements IGlobalExtension {
   public void visitSpec(SpecInfo spec) {
     List<FieldInfo> ruleFields = new ArrayList<FieldInfo>();
-    for (FieldInfo field : spec.getFields())
+    for (FieldInfo field : spec.getAllFields())
       if (field.getReflection().isAnnotationPresent(Rule.class))
         ruleFields.add(field);
 

File: spock-core/src/main/java/org/spockframework/mock/TooFewInvocationsError.java
Patch:
@@ -36,7 +36,7 @@ public TooFewInvocationsError(List<IMockInteraction> interactions) {
   }
 
   @Override
-  public String toString() {
+  public String getMessage() {
     StringBuilder builder = new StringBuilder();
     builder.append("Too few invocations for:\n\n");
 

File: spock-core/src/main/java/org/spockframework/mock/TooManyInvocationsError.java
Patch:
@@ -39,7 +39,7 @@ public IMockInvocation getLastInvocation() {
   }
 
   @Override
-  public String toString() {
+  public String getMessage() {
     StringBuilder builder = new StringBuilder();
     builder.append("Too many invocations for:\n\n");
     builder.append(interaction);

File: spock-core/src/main/java/org/spockframework/mock/WrongInvocationOrderError.java
Patch:
@@ -32,7 +32,7 @@ public IMockInvocation getLastInvocation() {
   }
 
   @Override
-  public String toString() {
+  public String getMessage() {
     StringBuilder builder = new StringBuilder();
     builder.append("Wrong invocation order for:\n\n");
     builder.append(interaction);

File: spock-core/src/main/java/org/spockframework/runtime/ConditionNotSatisfiedError.java
Patch:
@@ -31,7 +31,7 @@ public Condition getCondition() {
   }
 
   @Override
-  public String toString() {
+  public String getMessage() {
     return "Condition not satisfied:\n\n" + condition.render();
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/SpockTimeoutError.java
Patch:
@@ -15,7 +15,7 @@
 package org.spockframework.runtime;
 
 public class SpockTimeoutError extends SpockAssertionError {
-  public SpockTimeoutError(String msg) {
-    super(msg);
+  public SpockTimeoutError(String formatString, Object... args) {
+    super(String.format(formatString, args));
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/WrongExceptionThrownError.java
Patch:
@@ -35,7 +35,7 @@ public Throwable getActual() {
   }
 
   @Override
-  public String toString() {
+  public String getMessage() {
     return String.format("Expected exception %s, but %s", expected.getName(),
         actual == null ? "no exception was thrown" : ("got " + actual.getClass().getName()));
   }

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TimeoutInterceptor.java
Patch:
@@ -54,8 +54,8 @@ public void run() {
       // IDEA: Isn't thread.stop() more likey to succeed (considering it throws
       // an Error instead of an Exception)? Are its risks tolerable here?
       thread.interrupt();
-      throw new SpockTimeoutError("method timed out after %s %s")
-          .withArgs(timeout.value(), timeout.unit().toString().toLowerCase());
+      throw new SpockTimeoutError("method timed out after %s %s",
+          timeout.value(), timeout.unit().toString().toLowerCase());
     }
 
     if (exception[0] != null)

File: spock-core/src/main/java/spock/util/concurrent/AsyncConditions.java
Patch:
@@ -136,7 +136,8 @@ public void await(int timeout, TimeUnit unit) throws InterruptedException, Throw
     
     long pendingEvalBlocks = latch.getCount();
     if (pendingEvalBlocks > 0)
-      throw new SpockTimeoutError("Async conditions timed out after %d %s; %d out of %d evaluate blocks did not complete in time")
-        .withArgs(timeout, unit.toString().toLowerCase(), pendingEvalBlocks, numEvalBlocks);
+      throw new SpockTimeoutError(
+          "Async conditions timed out after %d %s; %d out of %d evaluate blocks did not complete in time",
+          timeout, unit.toString().toLowerCase(), pendingEvalBlocks, numEvalBlocks);
   }
 }

File: spock-core/src/main/java/spock/util/concurrent/BlockingVariable.java
Patch:
@@ -90,8 +90,8 @@ public BlockingVariable(int timeout, TimeUnit unit) {
    */
   public T get() throws InterruptedException {
     if (!valueReady.await(timeout, unit))
-      throw new SpockTimeoutError("BlockingVariable.get() timed out after %d %s")
-          .withArgs(timeout, unit.toString().toLowerCase());
+      throw new SpockTimeoutError("BlockingVariable.get() timed out after %d %s",
+          timeout, unit.toString().toLowerCase());
     return value;
   }
 

File: spock-core/src/main/java/org/spockframework/util/SpockReleaseInfo.java
Patch:
@@ -17,7 +17,7 @@
 package org.spockframework.util;
 
 public class SpockReleaseInfo {
-  private static final VersionNumber spockVersion = VersionNumber.parse("0.4-groovy-1.6");
+  private static final VersionNumber spockVersion = VersionNumber.parse("0.5-groovy-1.6-SNAPSHOT");
   private static final VersionNumber minGroovyVersion = VersionNumber.parse("1.6.1");
   private static final VersionNumber maxGroovyVersion = VersionNumber.parse("1.6.99");
 

File: spock-core/src/main/java/org/spockframework/util/SpockReleaseInfo.java
Patch:
@@ -17,7 +17,7 @@
 package org.spockframework.util;
 
 public class SpockReleaseInfo {
-  private static final VersionNumber spockVersion = VersionNumber.parse("0.4-groovy-1.7");
+  private static final VersionNumber spockVersion = VersionNumber.parse("0.5-groovy-1.7-SNAPSHOT");
   private static final VersionNumber minGroovyVersion = VersionNumber.parse("1.7.0");
   private static final VersionNumber maxGroovyVersion = VersionNumber.parse("1.7.99");
 

File: spock-core/src/main/java/org/spockframework/mock/ConstantResultGenerator.java
Patch:
@@ -16,6 +16,8 @@
 
 package org.spockframework.mock;
 
+import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
+
 /**
  *
  * @author Peter Niederwieser
@@ -28,6 +30,6 @@ public ConstantResultGenerator(Object constant) {
   }
 
   public Object generate(IMockInvocation invocation) {
-    return constant;
+    return DefaultTypeTransformation.castToType(constant, invocation.getMethod().getReturnType());
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/IterableResultGenerator.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Iterator;
 
 import org.codehaus.groovy.runtime.InvokerHelper;
+import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 /**
  * Generates result values from an iterable object. If the iterator has no more
@@ -35,8 +36,7 @@ public IterableResultGenerator(Object iterable) {
   }
 
   public Object generate(IMockInvocation invocation) {
-    if (iterator.hasNext())
-      nextValue = iterator.next();
-    return nextValue;
+    if (iterator.hasNext()) nextValue = iterator.next();
+    return DefaultTypeTransformation.castToType(nextValue, invocation.getMethod().getReturnType());
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/RunContext.java
Patch:
@@ -52,8 +52,8 @@ private RunContext(@Nullable DelegatingScript configurationScript, List<Class<?>
     }
   }
 
-  public SpecInfoBuilder createSpecInfoBuilder(Class<?> clazz) {
-    return new SpecInfoBuilder(clazz, extensionRegistry.getExtensions());
+  public ExtensionRunner createExtensionRunner(SpecInfo spec) {
+    return new ExtensionRunner(spec, extensionRegistry.getExtensions());
   }
 
   public ParameterizedSpecRunner createSpecRunner(SpecInfo spec, RunNotifier notifier) {

File: spock-core/src/main/java/org/spockframework/runtime/Sputnik.java
Patch:
@@ -45,7 +45,7 @@ public Sputnik(Class<?> clazz) {
     VersionChecker.checkSpockAndGroovyVersionsAreCompatible("spec runner");
 
     runContext = RunContext.get();
-    builder = runContext.createSpecInfoBuilder(clazz);
+    builder = new SpecInfoBuilder(clazz);
     spec = builder.build();
     new JUnitDescriptionGenerator(spec).attach();
   }
@@ -74,7 +74,7 @@ public void sort(Sorter sorter) {
 
   private void runExtensionsIfNecessary() {
     if (extensionsRun) return;
-    builder.runExtensions();
+    runContext.createExtensionRunner(spec).run();
     extensionsRun = true;
   }
 

File: spock-core/src/main/java/org/spockframework/util/MopUtil.java
Patch:
@@ -60,7 +60,6 @@ public static Method methodFor(MetaMethod method) {
     return null;
   }
 
-  // TODO: check/asks if MetaBeanProperty's field has anything to say
   public static Member memberFor(MetaProperty property) {
     if (property instanceof CachedField)
       try {

File: spock-core/src/main/java/org/spockframework/runtime/ExtensionClassesLoader.java
Patch:
@@ -63,7 +63,7 @@ private List<String> readDescriptor(URL url) {
       }
       return lines;
     } catch (IOException e) {
-      throw new ExtensionException("Failed to read extension descriptor '%s'", e).format(url);
+      throw new ExtensionException("Failed to read extension descriptor '%s'", e).withArgs(url);
     } finally {
       IoUtil.closeQuietly(reader);
     }
@@ -73,7 +73,7 @@ private Class<?> loadExtensionClass(String className) {
     try {
       return RunContext.class.getClassLoader().loadClass(className);
     } catch (Exception e) {
-      throw new ExtensionException("Failed to load extension class '%s'", e).format(className);
+      throw new ExtensionException("Failed to load extension class '%s'", e).withArgs(className);
     }
   }
 }

File: spock-core/src/main/java/org/spockframework/runtime/InvalidSpecException.java
Patch:
@@ -34,7 +34,7 @@ public InvalidSpecException(String msg, Throwable throwable) {
     this.msg = msg;
   }
 
-  public InvalidSpecException format(Object... args) {
+  public InvalidSpecException withArgs(Object... args) {
     msg = String.format(msg, args);
     return this;
   }

File: spock-core/src/main/java/org/spockframework/runtime/SpecInfoBuilder.java
Patch:
@@ -279,9 +279,9 @@ private IAnnotationDrivenExtension getOrCreateExtension(Class<? extends IAnnotat
       try {
         result = clazz.newInstance();
       } catch (InstantiationException e) {
-        throw new ExtensionException("Failed to instantiate extension '%s'", e).format(clazz);
+        throw new ExtensionException("Failed to instantiate extension '%s'", e).withArgs(clazz);
       } catch (IllegalAccessException e) {
-        throw new ExtensionException("No-arg constructor of extension '%s' is not public", e).format(clazz);
+        throw new ExtensionException("No-arg constructor of extension '%s' is not public", e).withArgs(clazz);
       }
       localExtensions.put(clazz, result);
     }

File: spock-core/src/main/java/org/spockframework/runtime/SpecUtil.java
Patch:
@@ -50,11 +50,11 @@ public static void checkIsSpec(Class<?> clazz) {
     if (Specification.class.isAssignableFrom(clazz))
       throw new InvalidSpecException(
 "Specification '%s' was not compiled properly (Spock AST transform was not run); try to do a clean build"
-      ).format(clazz.getName());
+      ).withArgs(clazz.getName());
 
     throw new InvalidSpecException(
 "Class '%s' is not a Spock specification (does not extend spock.lang.Specification or a subclass thereof)"
-    ).format(clazz.getName());
+    ).withArgs(clazz.getName());
   }
 
   public static boolean isRunnableSpec(Class<?> clazz) {
@@ -66,7 +66,7 @@ public static void checkIsRunnableSpec(Class<?> clazz) {
 
     if (Modifier.isAbstract(clazz.getModifiers()))
       throw new InvalidSpecException("Specification '%s' is not runnable because it is declared abstract")
-          .format(clazz.getName());
+          .withArgs(clazz.getName());
   }
 
   /**

File: spock-core/src/main/java/org/spockframework/runtime/Sputnik.java
Patch:
@@ -33,8 +33,6 @@
  *
  * @author Peter Niederwieser
  */
-// TODO:
-// - check if we should make use of JUnit's InitializationException
 // - check if StoppedByUserException thrown in Notifier.fireTestStarted() is handled correctly on our side
 public class Sputnik extends Runner implements Filterable, Sortable {
   private final RunContext runContext;

File: spock-core/src/main/java/org/spockframework/runtime/extension/ExtensionException.java
Patch:
@@ -28,7 +28,7 @@ public ExtensionException(String message, Throwable cause) {
     this.message = message;
   }
 
-  public ExtensionException format(Object... args) {
+  public ExtensionException withArgs(Object... args) {
     message = String.format(message, args);
     return this;
   }

File: spock-core/src/main/java/org/spockframework/util/VersionChecker.java
Patch:
@@ -20,7 +20,7 @@ public class VersionChecker {
 
   public static void checkSpockAndGroovyVersionsAreCompatible(String whoIsChecking) {
     if (!compatibleWithGroovy) throw new IncompatibleVersionsError(String.format(
-"The Spock %s refused to run because Spock %s is not compatible with Groovy %s. For more information, see http://versioncheck.spockframework.org\n" +
+"The Spock %s could not run because Spock %s is not compatible with Groovy %s. For more information, see http://versioninfo.spockframework.org\n" +
 "Spock location: %s\n" +
 "Groovy location: %s",
         whoIsChecking, SpockReleaseInfo.getVersion(), GroovyReleaseInfo.getVersion(),

File: spock-guice/src/main/java/org/spockframework/guice/GuiceInterceptor.java
Patch:
@@ -68,9 +68,9 @@ private List<Module> createModules() {
       try {
         modules.add(clazz.newInstance());
       } catch (InstantiationException e) {
-        throw new GuiceExtensionException("Failed to instantiate module '%s'", e).format(clazz.getSimpleName());
+        throw new GuiceExtensionException("Failed to instantiate module '%s'", e).withArgs(clazz.getSimpleName());
       } catch (IllegalAccessException e) {
-        throw new GuiceExtensionException("Failed to instantiate module '%s'", e).format(clazz.getSimpleName());
+        throw new GuiceExtensionException("Failed to instantiate module '%s'", e).withArgs(clazz.getSimpleName());
       }
     }
     return modules;

File: spock-spring/src/main/java/org/spockframework/spring/SpringExtension.java
Patch:
@@ -27,7 +27,6 @@
 
 import spock.lang.Shared;
 
-// TODO: spec for behavior in presence of inheritance
 @NotThreadSafe
 public class SpringExtension implements IGlobalExtension {
   public void visitSpec(SpecInfo spec) {
@@ -60,7 +59,7 @@ private void checkNoSharedFieldsInjected(SpecInfo spec) {
           // avoid compile-time dependency on JDK 1.6 only class
           || ReflectionUtil.isAnnotationPresent(field.getReflection(), "javax.annotation.Resource")))
         throw new SpringExtensionException(
-            "@Shared field '%s' cannot be injected; use an instance field instead").format(field.getName());
+            "@Shared field '%s' cannot be injected; use an instance field instead").withArgs(field.getName());
     }
   }
 

File: spock-core/src/main/java/org/spockframework/compiler/SpecRewriter.java
Patch:
@@ -458,7 +458,7 @@ private Statement rewriteImplicitCondition(Statement stat) {
 
   private boolean isExceptionCondition(Statement stat) {
     Expression expr = AstUtil.getExpression(stat, Expression.class);
-    return expr != null && AstUtil.isBuiltinMemberDeclOrCall(expr, Identifiers.THROWN, 0, 1);
+    return expr != null && AstUtil.isBuiltinMemberAssignmentOrCall(expr, Identifiers.THROWN, 0, 1);
   }
 
   private void rewriteExceptionCondition(Statement stat) {
@@ -470,7 +470,7 @@ private void rewriteExceptionCondition(Statement stat) {
     Expression expr = AstUtil.getExpression(stat, Expression.class);
     assert expr != null;
     try {
-      AstUtil.expandBuiltinMemberDeclOrCall(expr, thrownExceptionRef);
+      AstUtil.expandBuiltinMemberAssignmentOrCall(expr, thrownExceptionRef);
     } catch (InvalidSpecCompileException e) {
       errorReporter.error(e);
     }

File: spock-core/src/main/java/org/spockframework/mock/DefaultEqualsInteraction.java
Patch:
@@ -33,6 +33,6 @@ public boolean matches(IMockInvocation invocation) {
   }
 
   public Object accept(IMockInvocation invocation) {
-    return invocation.getMockObject() == invocation.getArguments().get(0);
+    return invocation.getMockObject().getInstance() == invocation.getArguments().get(0);
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/DefaultHashCodeInteraction.java
Patch:
@@ -28,6 +28,6 @@ public boolean matches(IMockInvocation invocation) {
   }
 
   public Object accept(IMockInvocation invocation) {
-    return System.identityHashCode(invocation.getMockObject());
+    return System.identityHashCode(invocation.getMockObject().getInstance());
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/IdenticalTargetConstraint.java
Patch:
@@ -29,6 +29,6 @@ public IdenticalTargetConstraint(Object target) {
   }
 
   public boolean isSatisfiedBy(IMockInvocation invocation) {
-    return invocation.getMockObject() == target;
+    return invocation.getMockObject().getInstance() == target;
   }
 }

File: spock-core/src/main/java/org/spockframework/mock/IMockInteraction.java
Patch:
@@ -35,6 +35,4 @@ public interface IMockInteraction {
   boolean isSatisfied();
 
   boolean isExhausted();
-  
-  int getAcceptedCount();
 }

File: spock-core/src/main/java/org/spockframework/mock/InteractionBuilder.java
Patch:
@@ -77,7 +77,7 @@ public InteractionBuilder addEqualTarget(Object target) {
   public static final String ADD_EQUAL_METHOD_NAME = "addEqualMethodName";
   public InteractionBuilder addEqualMethodName(String name) {
     if (name.equals(Specification._.toString()))
-      invConstraints.add(new WildcardMethodNameConstraint());
+      invConstraints.add(WildcardMethodNameConstraint.INSTANCE);
     else
       invConstraints.add(new EqualMethodNameConstraint(name));
     return this;
@@ -116,7 +116,7 @@ public InteractionBuilder addCodeArg(Closure closure) {
   public static final String ADD_EQUAL_ARG = "addEqualArg";
   public InteractionBuilder addEqualArg(Object arg) {
     argConstraints.add(arg == Specification._ ?
-        AnyArgumentConstraint.INSTANCE : new EqualArgumentConstraint(arg));
+        WildcardArgumentConstraint.INSTANCE : new EqualArgumentConstraint(arg));
     return this;
   }
 

File: spock-core/src/main/java/org/spockframework/mock/MockController.java
Patch:
@@ -28,7 +28,7 @@ public class MockController implements IInvocationMatcher {
 
   public MockController(IMockFactory factory) {
     this.factory = factory;
-    scopes.addFirst(new DefaultInteractionScope());
+    scopes.addFirst(DefaultInteractionScope.INSTANCE);
     scopes.addFirst(new InteractionScope());
   }
 

File: spock-core/src/main/java/org/spockframework/mock/TooFewInvocationsError.java
Patch:
@@ -45,9 +45,8 @@ public String toString() {
     builder.append("Too few invocations for:\n\n");
 
     for (IMockInteraction interaction : interactions) {
-      int numAccepted = interaction.getAcceptedCount();
-      builder.append(String.format("%s   (%d %s)\n",
-          interaction, numAccepted, numAccepted == 1 ? "invocation" : "invocations"));
+      builder.append(interaction);
+      builder.append("\n");
     }
     
     return builder.toString();

File: spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java
Patch:
@@ -162,7 +162,7 @@ private void rewriteMultiParameterization(BinaryExpression binExpr, Statement en
     List<Expression> listElems = list.getExpressions();
     for (int i = 0; i < listElems.size(); i++) {
       Expression listElem = listElems.get(i);
-      if (AstUtil.isPlaceholderVariableRef(listElem)) continue;
+      if (AstUtil.isWildcardRef(listElem)) continue;
       VariableExpression dataVar = createDataProcessorVariable(listElem, enclosingStat);
       ExpressionStatement exprStat =
           new ExpressionStatement(
@@ -232,7 +232,7 @@ List<List<Expression>> transposeTable(List<List<Expression>> rows) {
 
   // TODO: source positions of generated exprs
   private void turnIntoSimpleParameterization(List<Expression> column) throws InvalidSpecCompileException {
-    VariableExpression varExpr = AstUtil.asExpression(column.get(0), VariableExpression.class);
+    VariableExpression varExpr = AstUtil.asInstance(column.get(0), VariableExpression.class);
     if (varExpr == null)
       throw new InvalidSpecCompileException(column.get(0),
           "Header of data table may only contain variable names");
@@ -243,7 +243,7 @@ private void turnIntoSimpleParameterization(List<Expression> column) throws Inva
   }
 
   private void splitRow(Expression row, List<Expression> parts) {
-    BinaryExpression binExpr = AstUtil.asExpression(row, BinaryExpression.class);
+    BinaryExpression binExpr = AstUtil.asInstance(row, BinaryExpression.class);
     if (binExpr == null || binExpr.getOperation().getType() != Types.BITWISE_OR)
       parts.add(row);
     else {

File: spock-core/src/main/java/org/spockframework/compiler/InteractionRewriter.java
Patch:
@@ -251,7 +251,7 @@ private Statement register() {
         new ExpressionStatement(
             new MethodCallExpression(
                 resourceProvider.getMockControllerRef(),
-                MockController.ADD,
+                MockController.ADD_INTERACTION,
                 new ArgumentListExpression(builderExpr)));
 
     result.setSourcePosition(stat);

File: spock-core/src/main/java/org/spockframework/compiler/ConditionRewriter.java
Patch:
@@ -235,7 +235,7 @@ public void visitClassExpression(ClassExpression expr) {
     // therefore we have to provide one N/A value for every part of the class name
     String text = resourceProvider.getSourceText(expr);
     // NOTE: remove guessing (text == null) once underlying Groovy problem has been fixed
-    recordCount += text == null ? 1 : Util.countOccurrences(text, '.') + 1;
+    recordCount += text == null ? 1 : TextUtil.countOccurrences(text, '.') + 1;
   }
 
   public void visitUnaryMinusExpression(UnaryMinusExpression expr) {

File: spock-core/src/main/java/org/spockframework/util/MopUtil.java
Patch:
@@ -22,7 +22,7 @@
 
 import groovy.lang.*;
 
-public class MopUtil {
+public abstract class MopUtil {
   private static final Field ReflectionMetaMethod_method  = getDeclaredField(ReflectionMetaMethod.class, "method");
   private static final Field CachedField_field = getDeclaredField(CachedField.class, "field");
 

File: spock-core/src/main/java/org/spockframework/util/ReflectionUtil.java
Patch:
@@ -18,7 +18,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.*;
 
-public class ReflectionUtil {
+public abstract class ReflectionUtil {
   public static boolean isClassAvailable(String className) {
     try {
       Util.class.getClassLoader().loadClass(className);

File: spock-core/src/main/java/org/spockframework/util/TextUtil.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @author Peter Niederwieser
  */
-public class TextUtil {
+public abstract class TextUtil {
   public static String repeatChar(char ch, int times) {
     char[] chars = new char[times];
     Arrays.fill(chars, ch);

File: spock-core/src/main/java/org/spockframework/runtime/RunContext.java
Patch:
@@ -19,8 +19,7 @@
 import org.junit.runner.notification.RunNotifier;
 
 import org.spockframework.runtime.model.SpecInfo;
-import org.spockframework.util.IFunction;
-import org.spockframework.util.Nullable;
+import org.spockframework.util.*;
 
 import spock.builder.DelegatingScript;
 import spock.config.RunnerConfiguration;

File: spock-core/src/main/java/org/spockframework/runtime/Sputnik.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.spockframework.runtime.model.FeatureInfo;
 import org.spockframework.runtime.model.SpecInfo;
+import org.spockframework.util.VersionChecker;
 
 /**
  * A JUnit runner for Spock specifications. There is no need to put
@@ -43,6 +44,8 @@ public class Sputnik extends Runner implements Filterable, Sortable {
   private boolean descriptionAggregated = false;
 
   public Sputnik(Class<?> clazz) {
+    VersionChecker.checkSpockAndGroovyVersionsAreCompatible("spec runner");
+
     runContext = RunContext.get();
     builder = runContext.createSpecInfoBuilder(clazz);
     spec = builder.build();

File: spock-core/src/main/java/org/spockframework/mock/DefaultInteraction.java
Patch:
@@ -29,7 +29,7 @@ public boolean isSatisfied() {
   }
 
   public boolean isExhausted() {
-    return true;
+    return false;
   }
 
   public int getAcceptedCount() {

File: spock-core/src/main/java/org/spockframework/mock/InteractionScope.java
Patch:
@@ -32,10 +32,9 @@ public void addInteraction(IMockInteraction interaction) {
   }
 
   public IMockInteraction match(IMockInvocation invocation) {
-    for (IMockInteraction interaction : interactions) {
+    for (IMockInteraction interaction : interactions)
       if (interaction.matches(invocation))
         return interaction;
-    }
 
     return null;
   }

File: spock-core/src/main/java/org/spockframework/mock/MockController.java
Patch:
@@ -28,6 +28,7 @@ public class MockController implements IInvocationMatcher {
 
   public MockController(IMockFactory factory) {
     this.factory = factory;
+    scopes.addFirst(new DefaultInteractionScope());
     scopes.addFirst(new InteractionScope());
   }
 

File: spock-core/src/main/java/org/spockframework/mock/PositionalArgumentListConstraint.java
Patch:
@@ -61,8 +61,6 @@ public boolean isSatisfiedBy(IMockInvocation invocation) {
   /**
    * Tells if the given method can be called with vararg syntax from Groovy(!).
    * If yes, we also support vararg syntax in the interaction definition.
-   * @param method
-   * @return
    */
   private boolean canBeCalledWithVarArgSyntax(Method method) {
     Class<?>[] paramTypes = method.getParameterTypes();

File: spock-core/src/main/java/spock/lang/Specification.java
Patch:
@@ -235,8 +235,6 @@ <T> T Mock(Class<T> type, String name, MockController controller) {
       return null; // unreachable; just exists to avoid compiler warning
     }
 
-    if (name == null) name = type.getSimpleName();
-
     return type.cast(controller.create(name, type));
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/JUnitDescriptionGenerator.java
Patch:
@@ -41,6 +41,8 @@ public void generate() {
     Description desc = Description.createSuiteDescription(spec.getReflection());
     spec.setMetadata(desc);
 
+    if (spec == initialRequestor && spec.isSkipped()) return; // JUnit does it this way
+    
     SpecInfo superSpec = spec.getSuperSpec();
     if (superSpec != null) {
       new JUnitDescriptionGenerator(superSpec, initialRequestor).generate();

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/IgnoreExtension.java
Patch:
@@ -29,7 +29,7 @@
 // setup() and setupSpec() perform initialization of user-defined and internal fields
 public class IgnoreExtension extends AbstractAnnotationDrivenExtension<Ignore> {
   public void visitSpecAnnotation(Ignore ignore, SpecInfo spec) {
-    spec.setSkipped(true);
+    if (spec.isBottomSpec()) spec.setSkipped(true);
   }
 
   public void visitFeatureAnnotation(Ignore ignore, FeatureInfo feature) {

File: spock-core/src/main/java/org/spockframework/runtime/BaseSpecRunner.java
Patch:
@@ -139,7 +139,8 @@ private void invokeCleanupSpec() {
   private void runFeature() {
     if (runStatus != OK) return;
 
-    Assert.that(!currentFeature.isExcluded(), "tried to run excluded feature");
+    if (currentFeature.isExcluded()) return;
+
     if (currentFeature.isSkipped()) {
       supervisor.featureSkipped(currentFeature);
       return;

File: spock-core/src/main/java/org/spockframework/runtime/IMethodNameMapper.java
Patch:
@@ -22,5 +22,6 @@
  * @author Peter Niederwieser
  */
 public interface IMethodNameMapper {
-  String map(String bytecodName);
+  boolean isFixtureMethod(String className, String methodName);
+  String toFeatureName(String methodName);
 }

File: spock-core/src/main/java/org/spockframework/runtime/BaseSpecRunner.java
Patch:
@@ -220,7 +220,7 @@ protected void invoke(Object target, MethodInfo method, Object... arguments) {
     try {
       invocation.proceed();
     } catch (Throwable t) {
-      ErrorInfo error = new ErrorInfo(method, t, runStatus);
+      ErrorInfo error = new ErrorInfo(method, t);
       runStatus = supervisor.error(error);
     }
   }
@@ -231,12 +231,12 @@ protected Object invokeRaw(Object target, MethodInfo method, Object[] arguments)
     try {
       return method.getReflection().invoke(target, arguments);
     } catch (InvocationTargetException e) {
-      runStatus = supervisor.error(new ErrorInfo(method, e.getTargetException(), runStatus));
+      runStatus = supervisor.error(new ErrorInfo(method, e.getTargetException()));
       return null;
     } catch (Throwable t) {
       Error internalError =
           new InternalSpockError("Failed to invoke method '%s'", t).withArgs(method.getReflection().getName());
-      runStatus = supervisor.error(new ErrorInfo(method, internalError, runStatus));
+      runStatus = supervisor.error(new ErrorInfo(method, internalError));
       return null;
     }
   }

File: spock-core/src/main/java/org/spockframework/runtime/MasterRunListener.java
Patch:
@@ -37,13 +37,13 @@ public void beforeFeature(FeatureInfo feature) {
 
   public void beforeIteration(IterationInfo iteration) {
     for (IRunListener listener : spec.getListeners()) {
-      listener.beforeIteration(null);
+      listener.beforeIteration(iteration);
     }
   }
 
   public void afterIteration(IterationInfo iteration) {
     for (IRunListener listener : spec.getListeners()) {
-      listener.afterIteration(null);
+      listener.afterIteration(iteration);
     }
   }
 

File: spock-core/src/main/java/org/spockframework/buildsupport/SpecClassFileFinder.java
Patch:
@@ -53,7 +53,7 @@ public boolean isRunnableSpec(File file) throws IOException {
     try {
       ClassReader reader = new ClassReader(stream);
       SpecClassFileVisitor visitor = new SpecClassFileVisitor();
-      reader.accept(visitor, true);
+      reader.accept(visitor, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
       return visitor.isRunnableSpec();
     } finally {
       stream.close();

File: spock-core/src/main/java/org/spockframework/buildsupport/ant/SpecClassFileSelector.java
Patch:
@@ -33,7 +33,7 @@ public class SpecClassFileSelector extends BaseExtendSelector {
   @Override
   public boolean isSelected(File baseDir, String filename, File file) {
     try {
-      return finder.isSpec(file);
+      return finder.isRunnableSpec(file);
     } catch (IOException e) {
       String msg = e.getMessage();
       log("Error reading class file '" + filename + (msg == null ? "'" : "': " + msg), Project.MSG_WARN);

File: spock-core/src/main/java/org/spockframework/mock/DefaultMockFactory.java
Patch:
@@ -57,7 +57,7 @@ public Object create(String mockName, Class<?> mockType, IInvocationMatcher disp
     if (cglibAvailable)
       return CglibMockFactory.create(mockName, mockType, dispatcher);
     throw new CannotCreateMockException(mockType, "by default, only mocking of interfaces is supported; " +
-      "to allow mocking of classes, put cglib-nodep-2.1_3 or higher on the classpath.");
+      "to allow mocking of classes, put cglib-nodep-2.2 or higher on the classpath.");
   }
 
   private Object createDynamicProxyMock(final String mockName, Class<?> mockType, final IInvocationMatcher dispatcher) {
@@ -114,7 +114,7 @@ public Object intercept(Object mock, Method method, Object[] args, MethodProxy p
         return enhancer.create(); // throws what if no parameterless superclass constructor available?
       } catch (Exception e) {
         throw new CannotCreateMockException(mockType, "the latter has no parameterless constructor; " +
-          "to allow mocking of classes w/o parameterless constructor, put objenesis-1.1 or higher on the classpath.");
+          "to allow mocking of classes w/o parameterless constructor, put objenesis-1.2 or higher on the classpath.");
       }
     }
 

File: spock-core/src/main/java/org/spockframework/runtime/extension/builtin/TimeoutInterceptor.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.spockframework.runtime.extension.builtin;
 
-import org.spockframework.runtime.SpockAssertionError;
+import org.spockframework.runtime.SpockTimeoutError;
 import org.spockframework.runtime.extension.IMethodInterceptor;
 import org.spockframework.runtime.extension.IMethodInvocation;
 
@@ -54,8 +54,8 @@ public void run() {
       // IDEA: Isn't thread.stop() more likey to succeed (considering it throws
       // an Error instead of an Exception)? Are its risks tolerable here?
       thread.interrupt();
-      throw new SpockAssertionError("method timed out after %s %s", timeout.value(),
-        timeout.unit().toString().toLowerCase());
+      throw new SpockTimeoutError("method timed out after %s %s")
+          .withArgs(timeout.value(), timeout.unit().toString().toLowerCase());
     }
 
     if (exception[0] != null)

File: spock-tapestry/src/main/java/org/spockframework/tapestry/TapestryInterceptor.java
Patch:
@@ -71,7 +71,7 @@ private void runbeforeRegistryCreatedMethod(Specification spec) {
     Object methodReturnValue;
 
     try {
-      methodReturnValue = beforeRegistryCreatedMethod.invoke(spec, null);
+      methodReturnValue = beforeRegistryCreatedMethod.invoke(spec, (Object[]) null);
     } catch (IllegalAccessException e) {
       throw new InternalSpockError(e);
     } catch (InvocationTargetException e) {
@@ -127,7 +127,7 @@ private Class[] getSubModules(SpecInfo spec) {
   }
 
   private void injectServices(Object target, boolean sharedFields) throws IllegalAccessException {
-    for (final FieldInfo field : spec.getFields())
+    for (final FieldInfo field : spec.getAllFields())
       if (field.getReflection().isAnnotationPresent(Inject.class)
           && field.getReflection().isAnnotationPresent(Shared.class) == sharedFields) {
         Field rawField = field.getReflection();

File: spock-core/src/main/java/org/spockframework/compiler/IRewriteResourceProvider.java
Patch:
@@ -38,4 +38,5 @@ public interface IRewriteResourceProvider {
   VariableExpression getMockControllerRef();
   AstNodeCache getAstNodeCache();
   String getSourceText(ASTNode node);
+  ErrorReporter getErrorReporter();
 }

File: spock-core/src/main/java/org/spockframework/compiler/model/Method.java
Patch:
@@ -37,8 +37,6 @@ public Method(Spec parent, MethodNode code) {
     setName(code.getName());
   }
 
-  // Class members
-
   public Block getFirstBlock() {
     return firstBlock;
   }

File: spock-core/src/main/java/org/spockframework/runtime/SpecInfoBuilder.java
Patch:
@@ -89,7 +89,7 @@ private void buildSpec() {
   private SpecMetadata getSpecMetadata() {
     SpecMetadata metadata = clazz.getAnnotation(SpecMetadata.class);
     if (metadata == null)
-      throw new InvalidSpecError(
+      throw new InvalidSpecException(
           "Class '%s' is not a Spock specification").format(clazz.getName());
 
     return metadata;

File: spock-core/src/main/java/org/spockframework/runtime/SpockRuntime.java
Patch:
@@ -55,7 +55,7 @@ public static void verifyConditionWithMessage(Object message, Object condition,
   public static final String FEATURE_METHOD_CALLED = "featureMethodCalled";
   
   public static void featureMethodCalled() {
-    throw new InvalidSpecError("Feature methods cannot be called from user code");
+    throw new InvalidSpecException("Feature methods cannot be called from user code");
   }
 
   public static final String NULL_AWARE_INVOKE_METHOD = "nullAwareInvokeMethod";

File: spock-core/src/main/java/org/spockframework/runtime/JUnitSupervisor.java
Patch:
@@ -54,6 +54,8 @@ public void beforeFeature(FeatureInfo feature) {
     this.feature = feature;
 
     // make sure we don't call fireTestStarted/fireTestFinished for ignored features
+    // a bit of a hack; for example, what will happen if exception is thrown before
+    // IgnoreInterceptor gets to throw its SkipSpecOrFeatureException?
     ignoredFeature = feature.getFeatureMethod().getReflection().getAnnotation(Ignore.class) != null;
     if (ignoredFeature) return;
 

File: spock-core/src/main/java/spock/lang/Sputnik.java
Patch:
@@ -37,7 +37,7 @@ public class Sputnik extends Runner implements Filterable, Sortable {
   // TODO: we probably shouldn't just throw these exceptions as-is
   public Sputnik(Class<?> clazz) throws IllegalAccessException, InstantiationException, NoSuchFieldException {
     spec = new SpecInfoBuilder(clazz).build();
-    new JUnitMetadataGenerator(spec).generate();
+    new JUnitDescriptionGenerator(spec).generate();
   }
 
   public Description getDescription() {

File: spock-core/src/main/java/org/spockframework/compiler/SpecParser.java
Patch:
@@ -67,7 +67,7 @@ public void visitConstructor(ConstructorNode constructor) {
     if (AstUtil.isSynthetic(constructor)) return;
 
     throw new SyntaxException(constructor,
-"Constructors are not allowed; instead, define a 'setup()' or 'setupSpeck()' method");
+"Constructors are not allowed; instead, define a 'setup()' or 'setupSpec()' method");
    }
 
   public void visitMethod(MethodNode method) {
@@ -114,7 +114,8 @@ private void buildFixtureMethod(MethodNode method) {
     String name = method.getName();
     if (name.equals(SETUP)) spec.setSetup(fixtureMethod);
     else if (name.equals(CLEANUP)) spec.setCleanup(fixtureMethod);
-    else if (name.equals(SETUP_SPEC_METHOD)) spec.setSetupSpec(fixtureMethod);
+    else if (name.equals(SETUP_SPEC_METHOD) || name.equals(DEPRECATED_SETUP_SPEC_METHOD))
+      spec.setSetupSpec(fixtureMethod);
     else spec.setCleanupSpec(fixtureMethod);
   }
 

File: spock-core/src/main/java/org/spockframework/compiler/model/FixtureMethod.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * AST node representing a fixture method. In source code, a fixture method
  * corresponds to an instance method named one of "setup", "cleanup",
- * "setupSpeck", "cleanupSpeck".
+ * "setupSpec", "cleanupSpec".
  * 
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/spock/lang/Shared.java
Patch:
@@ -22,7 +22,7 @@
  * Indicates that a field is shared among all feature methods in a
  * specification. Initializing a shared field at the point of declaration
  * is encouraged; semantically, this is equivalent to initializing the field at
- * the very beginning of the <tt>setupSpeck()</tt> method.
+ * the very beginning of the <tt>setupSpec()</tt> method.
  * 
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/spock/lang/Speck.java
Patch:
@@ -21,9 +21,12 @@
 /**
  * Marks a class as a Spock specification.
  *
+ * @deprecated Extend from spock.lang.Specification instead. This class will
+ * be removed in Spock 0.4.
  * @author Peter Niederwieser
  */
 
+@Deprecated
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 public @interface Speck {

File: spock-tapestry/src/main/java/org/spockframework/tapestry/TapestryExtension.java
Patch:
@@ -47,7 +47,7 @@
  *
  * <p>For every specification annotated with <tt>&#64;SubModule</tt>, the Tapestry
  * registry will be started up (and subsequently shut down) once. Because fields are injected
- * <em>before</em> field initializers and the <tt>setup()</tt>/<tt>setupSpeck()</tt>
+ * <em>before</em> field initializers and the <tt>setup()</tt>/<tt>setupSpec()</tt>
  * methods are run, they can be safely accessed from these places.
  *
  * <p>Fields marked as <tt>&#64;Shared</tt> are injected once per specification; regular 

File: spock-core/src/main/java/org/spockframework/runtime/model/FieldMetadata.java
Patch:
@@ -24,7 +24,7 @@
  * @author Peter Niederwieser
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
+@Target(ElementType.FIELD)
 public @interface FieldMetadata {
   String NAME = "name";
   String ORDINAL = "ordinal";

File: spock-core/src/main/java/spock/lang/Issue.java
Patch:
@@ -25,7 +25,7 @@
  * @author Peter Niederwieser
  */
 @Retention(RetentionPolicy.SOURCE)
-@Target(ElementType.FIELD)
+@Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Issue {
   /**
    * The IDs of the issues that the annotated element relates to.

File: spock-guice/src/main/java/spock/guice/UseModules.java
Patch:
@@ -24,7 +24,7 @@
 import org.spockframework.guice.GuiceProcessor;
 
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.FIELD)
+@Target(ElementType.TYPE)
 @Directive(GuiceProcessor.class)
 public @interface UseModules {
   Class<? extends Module>[] value();

File: spock-core/src/main/java/org/spockframework/mock/InteractionNotSatisfiedError.java
Patch:
@@ -24,4 +24,4 @@
  *
  * @author Peter Niederwieser
  */
-abstract public class InteractionNotSatisfiedError extends SpeckAssertionError {}
+public abstract class InteractionNotSatisfiedError extends SpeckAssertionError {}

File: spock-core/src/main/java/org/spockframework/mock/TooFewInvocationsError.java
Patch:
@@ -42,11 +42,14 @@ public List<IMockInteraction> getUnsatisfiedInteractions() {
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder();
+    builder.append("Too few invocations for:\n\n");
+
     for (IMockInteraction interaction : interactions) {
       int numAccepted = interaction.getAcceptedCount();
       builder.append(String.format("%s   (%d %s)\n",
           interaction, numAccepted, numAccepted == 1 ? "invocation" : "invocations"));
     }
+    
     return builder.toString();
   }
 

File: spock-core/src/main/java/org/spockframework/mock/TooManyInvocationsError.java
Patch:
@@ -41,6 +41,7 @@ public IMockInvocation getInvocation() {
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder();
+    builder.append("Too many invocations for:\n\n");
     int numInvoked = interaction.getAcceptedCount() + 1;
     builder.append(String.format("%s   (%d %s)\n",
         interaction, numInvoked, numInvoked == 1 ? "invocation" : "invocations"));

File: spock-core/src/main/java/org/spockframework/runtime/Condition.java
Patch:
@@ -59,10 +59,10 @@ public String getMessage() {
 
   public String render() {
     if (text == null)
-      return "Condition not satisfied (no detail information available)\n";
+      return "(No detail information available)\n";
     
     if (message != null)
-      return String.format("%s\n\nMessage: %s\n", flatten(text), message);
+      return String.format("%s\n\nYour message: %s\n", flatten(text), message);
     
     ExpressionInfo exprInfo = new ExpressionInfoBuilder(flatten(text), TextPosition.create(1, 1), values).build();
     return ExpressionInfoRenderer.render(exprInfo);

File: spock-core/src/main/java/org/spockframework/runtime/ConditionNotSatisfiedError.java
Patch:
@@ -32,6 +32,6 @@ public Condition getCondition() {
 
   @Override
   public String toString() {
-    return condition.render();
+    return "Condition not satisfied:\n\n" + condition.render();
   }
 }

File: spock-core/src/main/java/spock/lang/Specification.java
Patch:
@@ -28,7 +28,7 @@
  * @author Peter Niederwieser
  */
 @RunWith(Sputnik.class)
-public class Specification extends Predef {
+public abstract class Specification extends Predef {
   public Object setup() { return null; }
 
   public Object cleanup() { return null; }

File: spock-core/src/main/java/org/spockframework/mock/TooFewInvocationsError.java
Patch:
@@ -42,7 +42,6 @@ public List<IMockInteraction> getUnsatisfiedInteractions() {
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder();
-    builder.append("Too few invocations for:\n\n");
     for (IMockInteraction interaction : interactions) {
       int numAccepted = interaction.getAcceptedCount();
       builder.append(String.format("%s   (%d %s)\n",

File: spock-core/src/main/java/org/spockframework/mock/TooManyInvocationsError.java
Patch:
@@ -41,7 +41,6 @@ public IMockInvocation getInvocation() {
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder();
-    builder.append("Too many invocations for:\n\n");
     int numInvoked = interaction.getAcceptedCount() + 1;
     builder.append(String.format("%s   (%d %s)\n",
         interaction, numInvoked, numInvoked == 1 ? "invocation" : "invocations"));

File: spock-core/src/main/java/org/spockframework/runtime/Condition.java
Patch:
@@ -58,6 +58,9 @@ public String getMessage() {
   }
 
   public String render() {
+    if (text == null)
+      return "Condition not satisfied (no detail information available)\n";
+    
     if (message != null)
       return String.format("%s\n\nMessage: %s\n", flatten(text), message);
     

File: spock-core/src/main/java/org/spockframework/runtime/StackTraceFilter.java
Patch:
@@ -65,6 +65,8 @@ public void filter(Throwable throwable) {
     }
 
     throwable.setStackTrace(filteredTrace.toArray(new StackTraceElement[filteredTrace.size()]));
+
+    if (throwable.getCause() != null) filter(throwable.getCause());
   }
 
   private static boolean isFilteredClass(StackTraceElement elem) {
@@ -97,7 +99,7 @@ private StackTraceElement prettyPrintClosureInvocation(StackTraceElement elem, M
     String consecutiveNumberOfClosureDef = matcher.group(3);
 
     String prettyClassName = classContaingClosureDef;
-    String prettyMethodName = mapper.map(methodContainingClosureDef) + "@closure" + consecutiveNumberOfClosureDef;
+    String prettyMethodName = mapper.map(methodContainingClosureDef) + "_closure" + consecutiveNumberOfClosureDef;
 
     return new StackTraceElement(prettyClassName, prettyMethodName, elem.getFileName(), elem.getLineNumber());
   }

File: spock-core/src/main/java/org/spockframework/compiler/SpeckRewriter.java
Patch:
@@ -429,7 +429,7 @@ public AstNodeCache getAstNodeCache() {
   private FixtureMethod getSetup() {
     if (speck.getSetup() == null) {
       MethodNode gMethod = new MethodNode(Constants.SETUP, Opcodes.ACC_PUBLIC,
-          ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, new BlockStatement());
+          ClassHelper.DYNAMIC_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, new BlockStatement());
       speck.getAst().addMethod(gMethod);
       FixtureMethod setup = new FixtureMethod(speck, gMethod);
       setup.addBlock(new AnonymousBlock(setup));
@@ -442,7 +442,7 @@ private FixtureMethod getSetup() {
   private FixtureMethod getSetupSpeck() {
     if (speck.getSetupSpeck() == null) {
       MethodNode gMethod = new MethodNode(Constants.SETUP_SPECK_METHOD, Opcodes.ACC_PUBLIC,
-          ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, new BlockStatement());
+          ClassHelper.DYNAMIC_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, new BlockStatement());
       speck.getAst().addMethod(gMethod);
       FixtureMethod setupSpeck = new FixtureMethod(speck, gMethod);
       setupSpeck.addBlock(new AnonymousBlock(setupSpeck));

File: spock-core/src/main/java/org/spockframework/compiler/AbstractSpeckVisitor.java
Patch:
@@ -21,6 +21,7 @@
 // IDEA: store context (SpeckInfo, method, etc.); e.g. by overriding new visitNode method and making it final
 public class AbstractSpeckVisitor implements ISpeckVisitor {
   public void visitSpeck(Speck speck) throws Exception {}
+  public void visitSpeckAgain(Speck speck) throws Exception {}
   public void visitMethod(Method method) throws Exception {}
   public void visitMethodAgain(Method method) throws Exception {}
   public void visitAnyBlock(Block block) throws Exception {}

File: spock-core/src/main/java/org/spockframework/compiler/model/ISpeckVisitor.java
Patch:
@@ -21,6 +21,7 @@
  */
 public interface ISpeckVisitor {
   void visitSpeck(Speck speck) throws Exception;
+  void visitSpeckAgain(Speck speck) throws Exception;
   void visitMethod(Method method) throws Exception;
   void visitMethodAgain(Method method) throws Exception;
   void visitAnyBlock(Block block) throws Exception;

File: spock-core/src/main/java/spock/lang/IgnoreRest.java
Patch:
@@ -22,8 +22,8 @@
 import org.spockframework.runtime.intercept.IgnoreRestProcessor;
 
 /**
- * Indicates that all feature methods except the ones to which this annotation
- * is applied should be ignored.
+ * Indicates that all feature methods except the ones carrying this annotation
+ * should be ignored.
  *
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/org/spockframework/compiler/SpeckParser.java
Patch:
@@ -33,7 +33,6 @@
  *
  * @author Peter Niederwieser
  */
-// TODO: disallow static methods (e.g. conditions in static helper methods won't work)
 public class SpeckParser implements GroovyClassVisitor {
   private Speck speck;
 

File: spock-core/src/main/java/org/spockframework/compiler/model/Method.java
Patch:
@@ -27,6 +27,7 @@
 
 /**
  * AST node representing a Speck method (one of fixture method, feature method, helper method).
+ * 
  * @author Peter Niederwieser
  */
 public abstract class Method extends Node<Speck, MethodNode> {

File: spock-core/src/main/java/org/spockframework/runtime/SpeckInfoParameterizedRunner.java
Patch:
@@ -142,6 +142,7 @@ private void runIteration(FeatureInfo feature, Object[] args) {
     invokeFeatureMethod(feature.getFeatureMethod(), args);
     invokeCleanup();
     supervisor.afterIteration();
+
     resetStatus(ITERATION);
   }
 

File: spock-core/src/main/java/org/spockframework/util/UnreachableCodeError.java
Patch:
@@ -20,8 +20,8 @@
  *
  * @author Peter Niederwieser
  */
-public class UnreachableError extends InternalSpockError {
-  public UnreachableError() {
+public class UnreachableCodeError extends InternalSpockError {
+  public UnreachableCodeError() {
     super("You shouldn't be here...fascinating");
   }
 }

File: spock-core/src/main/java/spock/lang/Sputnik.java
Patch:
@@ -49,6 +49,8 @@ public void run(RunNotifier notifier) {
 
   public void filter(Filter filter) throws NoTestsRemainException {
     speck.filterFeatures(new JUnitFilterAdapter(filter));
+    if (speck.getFeatures().size() == 0)
+      throw new NoTestsRemainException();
   }
 
   public void sort(Sorter sorter) {

File: spock-core/src/main/java/org/spockframework/compiler/AstNodeCache.java
Patch:
@@ -43,6 +43,7 @@ public class AstNodeCache {
   // annotations and annotation elements
   public final ClassNode SpeckMetadata = ClassHelper.makeWithoutCaching(SpeckMetadata.class);
   public final ClassNode FeatureMetadata = ClassHelper.makeWithoutCaching(FeatureMetadata.class);
+  public final ClassNode DataProviderMetadata = ClassHelper.makeWithoutCaching(DataProviderMetadata.class);
   public final ClassNode BlockMetadata = ClassHelper.makeWithoutCaching(BlockMetadata.class);
   public final ClassNode BlockKind = ClassHelper.makeWithoutCaching(BlockKind.class);
 

File: spock-core/src/main/java/org/spockframework/compiler/SpeckRewriter.java
Patch:
@@ -188,7 +188,7 @@ private void rewriteWhereBlock(Method method) {
     if (!(block instanceof WhereBlock)) return;
 
     new DeepStatementRewriter(this).visitBlock(block);
-    WhereBlockRewriter.rewrite((WhereBlock)block);
+    WhereBlockRewriter.rewrite((WhereBlock)block, nodeCache);
   }
 
   public void visitMethodAgain(Method method) {

File: spock-core/src/main/java/org/spockframework/runtime/UnrolledFeatureNameGenerator.java
Patch:
@@ -27,7 +27,7 @@
  * @author Peter Niederwieser
  */
 public class UnrolledFeatureNameGenerator {
-  private static final Pattern VARIABLE_PATTERN = Pattern.compile("%([a-zA-Z_\\$][\\w\\$]*)");
+  private static final Pattern VARIABLE_PATTERN = Pattern.compile("#([a-zA-Z_\\$][\\w\\$]*)");
 
   private final FeatureInfo feature;
   private final Matcher variableMatcher;
@@ -47,17 +47,17 @@ public UnrolledFeatureNameGenerator(FeatureInfo feature, Unroll unroll) {
 
   public String nameFor(Object[] args) {
     StringBuffer result = new StringBuffer();
-    iterationCount++;
     variableMatcher.reset();
 
     while (variableMatcher.find()) {
       String variableName = variableMatcher.group(1);
       String value = getValue(variableName, args);
-      if (value == null) value = "%" + variableName; // don't replace
+      if (value == null) value = "#" + variableName; // don't replace
       variableMatcher.appendReplacement(result, value);
     }
 
     variableMatcher.appendTail(result);
+    iterationCount++;
     return result.toString();
   }
 

File: spock-core/src/main/java/org/spockframework/runtime/model/FeatureMetadata.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.annotation.*;
 
 /**
- * Internal method metadata generated by the compiler for consumption by the runtime.
+ * Internal metadata about a feature from which the runtime model is built.
  *
  * @author Peter Niederwieser
  */

File: spock-core/src/main/java/org/spockframework/compiler/DeepStatementRewriter.java
Patch:
@@ -62,7 +62,7 @@ public void visitAssertStatement(AssertStatement stat) {
     super.visitAssertStatement(stat);
     conditionFound = true;
     replaceVisitedStatementWith(
-        ConditionRewriter.rewriteExplicitCondition(stat, resourceProvider, this));
+        ConditionRewriter.rewriteExplicitCondition(stat, resourceProvider));
   }
 
   @Override

File: spock-core/src/main/java/org/spockframework/runtime/JUnitMetadataGenerator.java
Patch:
@@ -34,8 +34,9 @@ public JUnitMetadataGenerator(SpeckInfo speck) {
   }
 
   public void generate() {
-    Description desc = Description.createSuiteDescription(speck.getName());
+    Description desc = Description.createSuiteDescription(speck.getReflection());
     speck.setMetadata(desc);
+    
     for (FeatureInfo feature : speck.getFeatures())
       desc.addChild(describeFeature(feature));
 

File: spock-core/src/main/java/org/spockframework/runtime/JUnitSupervisor.java
Patch:
@@ -61,7 +61,7 @@ public int error(MethodInfo method, Throwable throwable, int runStatus) {
     filter.filter(throwable);
 
     Description description = getFailureDescription(featureMethod, method);
-    if (throwable instanceof FeatureSkippedException) {
+    if (throwable instanceof SkipSpeckOrFeatureException) {
       notifier.fireTestIgnored(description);
       return END_FEATURE;
     }

File: spock-core/src/main/java/org/spockframework/compiler/Constants.java
Patch:
@@ -73,4 +73,6 @@ public abstract class Constants {
   public static final String THROWN = "thrown";
 
   public static final String INTERACTION = "interaction";
+
+  public static final String OLD = "old";
 }

File: spock-core/src/main/java/org/spockframework/runtime/StackTraceFilter.java
Patch:
@@ -26,8 +26,6 @@
  *
  * @author Peter Niederwieser
  */
-// not yet filtered:
-// groovy.lang.MetaClassImpl, groovy.lang.MetaMethod
 public class StackTraceFilter {
   private static final List<String> FILTERED_PACKAGES = Arrays.asList(
       "org.spockframework.runtime",

File: spock-core/src/main/java/org/spockframework/mock/MockController.java
Patch:
@@ -29,7 +29,7 @@ public class MockController implements IInvocationMatcher {
 
   public MockController(IMockFactory factory) {
     this.factory = factory;
-    scopes.addFirst(new GlobalInteractionScope());
+    scopes.addFirst(new InteractionScope());
   }
 
   public static final String ADD = "add";
@@ -50,7 +50,7 @@ public IMockInteraction match(IMockInvocation invocation) {
   public static final String ENTER_SCOPE = "enterScope";
 
   public void enterScope() {
-    scopes.addFirst(new ThenBlockInteractionScope());
+    scopes.addFirst(new InteractionScope());
   }
 
   public static final String LEAVE_SCOPE = "leaveScope";

File: spock-core/src/main/java/org/spockframework/buildsupport/JUnit4ClassVisitor.java
Patch:
@@ -3,8 +3,6 @@
 import org.objectweb.asm.*;
 import org.objectweb.asm.commons.EmptyVisitor;
 
-import java.io.*;
-
 class JUnit4ClassVisitor extends EmptyVisitor {
   boolean isTestCase = false;
 

File: spock-core/src/main/java/org/spockframework/compiler/model/Block.java
Patch:
@@ -33,7 +33,6 @@ public abstract class Block extends Node<Method, List<Statement>> {
   private Block prev;
   private Block next;
 
-  @SuppressWarnings("unchecked")
   public Block(Method parent) {
     super(parent, new ArrayList<Statement>());
   }

File: spock-core/src/main/java/org/spockframework/runtime/ExpressionInfoConverter.java
Patch:
@@ -68,7 +68,6 @@ public void visitStaticMethodCallExpression(StaticMethodCallExpression expr) {
     unsupported(); // still a MethodCallExpression in phase conversion
   }
 
-  @SuppressWarnings("unchecked")
   public void visitConstructorCallExpression(ConstructorCallExpression expr) {
     result = new ExpressionInfo(
         TextRegion.of(expr),

File: spock-core/src/main/java/org/spockframework/runtime/IMethodInfoSortOrder.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.spockframework.runtime;
 
 import java.util.Comparator;

File: spock-core/src/main/java/org/spockframework/compiler/DeepStatementRewriter.java
Patch:
@@ -39,8 +39,6 @@
  */
 // TODO: "assert false" and "expect: false" are missing line number in stack trace,
 // but "assert true && false" does have line number ?!
-// IDEA: explicit syntax for specifying that no exception is thrown, e.g.:
-// NoException thrown
 // TODO: use of SourceLookup in both DeepStatementRewriter and SpeckRewriter might
 // slow down lookup considerably; check whether this is a problem
 // IDEA: disallow return statement in feature methods (might cause harm?)

File: spock-core/src/main/java/org/spockframework/runtime/ValueRecorder.java
Patch:
@@ -31,12 +31,14 @@ public class ValueRecorder implements Iterable<Object> {
   private final ArrayList<Object> values = new ArrayList<Object>();
 
   public static final String RESET = "reset";
+
   public ValueRecorder reset() {
     values.clear();
     return this;
   }
 
   public static final String RECORD = "record";
+  
   /**
    * Records and returns the specified value. Hence an expression can be replaced
    * with record(expression) without impacting evaluation of the expression.

File: spock-core/src/main/java/org/spockframework/util/InternalSpockError.java
Patch:
@@ -20,7 +20,6 @@
  *
  * @author Peter Niederwieser
  */
-// TODO: error or runtime exception?
 public class InternalSpockError extends Error {
   private Object[] msgArgs;
 

File: spock-core/src/main/java/org/spockframework/runtime/ConditionNotSatisfiedError.java
Patch:
@@ -33,6 +33,9 @@ public Condition getCondition() {
 
   @Override
   public String toString() {
+    if (condition.getText() == null)
+      return getMessage() + " (no detailed information available)";
+    
     return getMessage() + ":\n\n" + condition.render();
   }
 }

File: spock-core/src/main/java/spock/lang/Issue.java
Patch:
@@ -32,5 +32,5 @@
    *
    * @return the IDs of the issues that the annotated element relates to
    */
-  String[] values();
+  String[] value();
 }

File: spock-core/src/main/java/org/spockframework/mock/InteractionNotSatisfiedError.java
Patch:
@@ -44,7 +44,7 @@ public List<IMockInteraction> getUnsatisfiedInteractions() {
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder();
-    builder.append("Unsatisfied interactions:\n");
+    builder.append("Interaction not satisfied:\n\n");
     for (IMockInteraction interaction : interactions) {
       int numAccepted = interaction.getAcceptedCount();
       builder.append(String.format("%s   (%d %s)\n",

File: spock-core/src/main/java/spock/lang/Sputnik.java
Patch:
@@ -25,8 +25,9 @@
 import org.spockframework.runtime.model.SpeckInfo;
 
 /**
- * Allows a Speck annotated with @RunWith(Sputnik) to be run by JUnit. In case
- * you wondered, the name is a combination of the words "Spock" and "JUnit".
+ * A JUnit runner for Spock specifications. To run a specification with JUnit,
+ * annotate it with <tt>@org.junit.RunWith(Sputnik)</tt>. In case you wondered,
+ * Sputnik is a combination of the words "Spock" and "JUnit".
  *
  * @author Peter Niederwieser
  */

File: spock-maven/src/main/java/org/spockframework/buildsupport/maven/FindSpecksMojo.java
Patch:
@@ -89,6 +89,6 @@ private Plugin getSurefirePlugin() throws MojoExecutionException {
           && plugin.getArtifactId().equals("maven-surefire-plugin"))
         return plugin;
 
-    throw new MojoExecutionException("Surefire plugin not found");
+    throw new MojoExecutionException("Surefire plugin not found; make sure it is bound to a lifecycle phase");
   }
 }

File: spock-maven/src/main/java/org/spockframework/buildsupport/maven/FindSpecksMojo.java
Patch:
@@ -52,7 +52,8 @@ public void execute() throws MojoExecutionException {
     try {
       tests = new JUnit4TestClassFinder().findTestClasses(testOutputDirectory);
     } catch (IOException e) {
-      throw new MojoExecutionException("IO error while searching for test classes", e);
+      // chaining the exception would result in a cluttered error message
+      throw new MojoExecutionException(e.toString());
     }
 
     getLog().info(String.format("Found %d test classes", tests.size()));

