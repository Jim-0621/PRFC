File: src/core/TsdbQuery.java
Patch:
@@ -1614,7 +1614,8 @@ long getScanStartTimeSeconds() {
   }
 
   /** Returns the UNIX timestamp at which we must stop scanning.  */
-  long getScanEndTimeSeconds() {
+  @VisibleForTesting
+  protected long getScanEndTimeSeconds() {
     // Begin with the raw query end time.
     long end = getEndTime();
 

File: test/core/TestSaltScannerHistogram.java
Patch:
@@ -301,6 +301,7 @@ public void scanWithFiltersOnSameTagOneFail() throws Exception {
     final SaltScanner scanner = new SaltScanner(tsdb, METRIC_BYTES, scanners, 
         null, filters, false, null, query_stats, 0, spans, 0, 0);
 
+    assertTrue(Maps.difference(spans, scanner.scan().joinUninterruptibly()).areEqual());
     assertTrue(Maps.difference(spans, scanner.scanHistogram().joinUninterruptibly()).areEqual());
     assertEquals(0, spans.size());
   }

File: src/core/SaltScanner.java
Patch:
@@ -942,6 +942,7 @@ private void validateAndTriggerCallback(
       histMap.put(scannersRunning, histograms);
     }
 
+    int scannersRunning = countdown.decrementAndGet();
     if (scannersRunning <= 0) {
       try {
         mergeAndReturnResults();

File: src/core/Query.java
Patch:
@@ -197,7 +197,7 @@ public Deferred<Object> configureFromQuery(final TSQuery query,
    * way we get this one data point is by aggregating all the data points of
    * that interval together using an {@link Aggregator}.  This enables you
    * to compute things like the 5-minute average or 10 minute 99th percentile.
-   * @param interval Number of seconds wanted between each data point.
+   * @param interval Number of milliseconds wanted between each data point.
    * @param downsampler Aggregation function to use to group data points
    * within an interval.
    */

File: src/core/SplitRollupQuery.java
Patch:
@@ -1,5 +1,5 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2021  The OpenTSDB Authors.
+// Copyright (C) 2010-2021  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by

File: src/core/SplitRollupSpanGroup.java
Patch:
@@ -1,5 +1,5 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2021  The OpenTSDB Authors.
+// Copyright (C) 2012-2021  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -119,7 +119,6 @@ public Map<String, String> call(ArrayList<Map<String, String>> resolvedTags) thr
      */
     @Override
     public Bytes.ByteMap<byte[]> getTagUids() {
-        Bytes.ByteMap<byte[]> tagUids = new Bytes.ByteMap<byte[]>();
 
         for (SpanGroup group : spanGroups) {
             tagUids.putAll(group.getTagUids());

File: test/core/TestSplitRollupQuery.java
Patch:
@@ -1,5 +1,5 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2021  The OpenTSDB Authors.
+// Copyright (C) 2012-2021  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by

File: src/tsd/HttpRpc.java
Patch:
@@ -26,6 +26,6 @@ interface HttpRpc {
    * @param tsdb The TSDB to use.
    * @param query The HTTP query to execute.
    */
-  void execute(TSDB tsdb, HttpQuery query) throws IOException;
+  void execute(TSDB tsdb, HttpQuery query) throws BadRequestException, IOException;
 
 }

File: src/tsd/HttpJsonSerializer.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Set;
 import java.util.LinkedHashSet;
 import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBufferOutputStream;
@@ -673,7 +674,7 @@ class DPsResolver implements Callback<Deferred<Object>, Object> {
       /** Has to be final to be shared with the nested classes */
       final StringBuilder metric = new StringBuilder(256);
       /** Resolved tags */
-      final Map<String, String> tags = new HashMap<String, String>();
+      final Map<String, String> tags = new ConcurrentHashMap<String, String>();
       /** Resolved aggregated tags */
       final List<String> agg_tags = new ArrayList<String>();
       /** A list storing the metric and tag resolve calls */

File: test/tsd/TestQueryRpc.java
Patch:
@@ -518,7 +518,7 @@ public void postQueryNoMetricBadRequest() throws Exception {
     assertEquals(HttpResponseStatus.BAD_REQUEST, query.response().getStatus());
     final String json =
         query.response().getContent().toString(Charset.forName("UTF-8"));
-    assertTrue(json.contains("No such name for 'foo': 'metrics'"));
+    assertTrue(json.contains("No such name for &#39;foo&#39;: &#39;metrics&#39;"));
   }
 
   @Test
@@ -579,7 +579,7 @@ public void executeNSU() throws Exception {
     assertEquals(HttpResponseStatus.BAD_REQUEST, query.response().getStatus());
     final String json =
         query.response().getContent().toString(Charset.forName("UTF-8"));
-    assertTrue(json.contains("No such name for 'foo': 'metrics'"));
+    assertTrue(json.contains("No such name for &#39;foo&#39;: &#39;metrics&#39;"));
   }
 
   @Test

File: src/tsd/HttpJsonSerializer.java
Patch:
@@ -1,5 +1,5 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2023  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -859,7 +859,7 @@ public Object call(final ArrayList<Object> deferreds) throws Exception {
                 final double value = dp.doubleValue();
                 if (Double.isNaN(value) && 
                     orig_query.fillPolicy() == FillPolicy.NULL) {
-                  json.writeNumberField(Long.toString(timestamp), null);
+                  json.writeNullField(Long.toString(timestamp));
                 } else {
                   json.writeNumberField(Long.toString(timestamp), dp.doubleValue());
                 }

File: test/core/LongHistogramDataPointForTest.java
Patch:
@@ -1,5 +1,5 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2016-2017  The OpenTSDB Authors.
+// Copyright (C) 2016-2023  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -18,7 +18,9 @@
 import java.util.Map;
 
 import org.hbase.async.Bytes;
+import org.junit.Ignore;
 
+@Ignore
 public class LongHistogramDataPointForTest implements Histogram {
   private final int id;
   private long data;

File: src/tsd/GraphHandler.java
Patch:
@@ -70,8 +70,9 @@ final class GraphHandler implements HttpRpc {
   private static final boolean IS_WINDOWS =
     System.getProperty("os.name", "").contains("Windows");
 
+  private static final String RANGE_COMPONENT = "\\\"?-?\\d*\\.?(\\d+)?([eE]-?\\d+)?\\\"?";
   private static Pattern RANGE_VALIDATOR = Pattern.compile(
-      "\\[\\\"?-?\\d+\\.?(\\d+)?([eE]-?\\d+)?\\\"?:\\\"?-?(\\d+\\.?\\d+?)?([eE]-?\\d+)?\\\"?\\]");
+      "\\["+RANGE_COMPONENT+":"+RANGE_COMPONENT+"]");
   private static Pattern LABEL_VALIDATOR = Pattern.compile("[a-zA-z0-9 \\-_]");
   private static Pattern KEY_VALIDATOR = Pattern.compile(
       "(out|left|top|center|right|horiz|box|bottom)?\\s?");

File: src/utils/Config.java
Patch:
@@ -556,6 +556,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.storage_exception_handler.enable", "false");
     default_map.put("tsd.core.uid.random_metrics", "false");
     default_map.put("tsd.core.bulk.allow_out_of_order_timestamps", "false");
+    default_map.put("tsd.gnuplot.options.allowlist", ";axis x1y2");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.query.skip_unresolved_tagvs", "false");
     default_map.put("tsd.query.allow_simultaneous_duplicates", "true");

File: src/core/SaltScanner.java
Patch:
@@ -646,8 +646,7 @@ public Object call(final ArrayList<ArrayList<KeyValue>> rows)
           // TODO - more efficient resolution
           // TODO - byte set instead of a string for the uid may be faster
           if (filters != null && !filters.isEmpty()) {
-            lookups.clear();
-            final String tsuid = 
+            final String tsuid =
                 UniqueId.uidToString(UniqueId.getTSUIDFromKey(key, 
                 TSDB.metrics_width(), Const.TIMESTAMP_BYTES));
             if (skips.contains(tsuid)) {

File: src/stats/QueryStats.java
Patch:
@@ -249,7 +249,7 @@ public QueryStats(final String remote_address, final TSQuery query,
     executed = 1;
     query_start_ns = DateTime.nanoTime();
     query_start_ms = DateTime.currentTimeMillis();
-    overall_stats = new HashMap<QueryStat, Long>();
+    overall_stats = new ConcurrentHashMap<QueryStat, Long>();
     query_stats = new ConcurrentHashMap<Integer, Map<QueryStat, Long>>(1);
     scanner_stats = new ConcurrentHashMap<Integer, 
         Map<Integer, Map<QueryStat, Long>>>(1);

File: src/graph/Plot.java
Patch:
@@ -1,5 +1,5 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2010-2012  The OpenTSDB Authors.
+// Copyright (C) 2010-2021  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -15,7 +15,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.net.URLDecoder;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -139,7 +138,7 @@ public void setParams(final Map<String, String> params) {
     String[] y_format_keys = {"format y", "format y2"};
     for(String k : y_format_keys){
       if(params.containsKey(k)){
-        params.put(k, URLDecoder.decode(params.get(k)));
+        params.put(k, params.get(k));
       }
     }
     this.params = params;

File: test/core/TestTsdbQuery.java
Patch:
@@ -372,7 +372,7 @@ public void configureFromQueryWithForceRaw() throws Exception {
     query.configureFromQuery(ts_query, 0, true).joinUninterruptibly();
 
     assertFalse(query.isRollupQuery());
-    verify(query, never()).transformDownSamplerToRollupQuery(any(), any());
+    verify(query, never()).transformDownSamplerToRollupQuery(any(Aggregator.class), anyString());
 
     assertArrayEquals(METRIC_BYTES, ForTesting.getMetric(query));
     assertEquals(1, ForTesting.getFilters(query).size());

File: src/utils/Config.java
Patch:
@@ -577,6 +577,7 @@ protected void setDefaults() {
     default_map.put("tsd.rollups.agg_tag_key", "_aggregate");
     default_map.put("tsd.rollups.raw_agg_tag_value", "RAW");
     default_map.put("tsd.rollups.block_derived", "true");
+    default_map.put("tsd.rollups.split_query.enable", "false");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: test/core/TestTSDBAddAggregatePoint.java
Patch:
@@ -84,6 +84,7 @@ public void beforeLocal() throws Exception {
     Whitebox.setInternalState(tsdb, "default_interval", 
         rollup_config.getRollupInterval("1m"));
     Whitebox.setInternalState(tsdb, "rollups_block_derived", true);
+    Whitebox.setInternalState(tsdb, "rollups_split_queries", false);
     Whitebox.setInternalState(tsdb, "agg_tag_key", 
         config.getString("tsd.rollups.agg_tag_key"));
     Whitebox.setInternalState(tsdb, "raw_agg_tag_value", 

File: test/core/TestTSDBAddAggregatePointSalted.java
Patch:
@@ -85,6 +85,7 @@ public void beforeLocal() throws Exception {
     Whitebox.setInternalState(tsdb, "default_interval", 
         rollup_config.getRollupInterval("1m"));
     Whitebox.setInternalState(tsdb, "rollups_block_derived", true);
+    Whitebox.setInternalState(tsdb, "rollups_split_queries", false);
     Whitebox.setInternalState(tsdb, "agg_tag_key", 
         config.getString("tsd.rollups.agg_tag_key"));
     Whitebox.setInternalState(tsdb, "raw_agg_tag_value", 

File: test/tsd/TestRollupRpc.java
Patch:
@@ -100,7 +100,8 @@ public void beforeLocal() throws Exception {
     storage.addTable("tsdb-rollup-agg-1h".getBytes(), families);
     storage.addTable("tsdb-agg".getBytes(), families);
     Whitebox.setInternalState(tsdb, "rollups_block_derived", true);
-    Whitebox.setInternalState(tsdb, "agg_tag_key", 
+    Whitebox.setInternalState(tsdb, "rollups_split_queries", false);
+    Whitebox.setInternalState(tsdb, "agg_tag_key",
         config.getString("tsd.rollups.agg_tag_key"));
     Whitebox.setInternalState(tsdb, "raw_agg_tag_value", 
         config.getString("tsd.rollups.raw_agg_tag_value"));
@@ -850,5 +851,4 @@ public void httpUnknownInterval() throws Exception {
     validateCounters(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0);
     validateSEH(false);
   }
-
-}
\ No newline at end of file
+}

File: src/core/TsdbQuery.java
Patch:
@@ -1678,9 +1678,6 @@ public void transformDownSamplerToRollupQuery(final Aggregator group_by,
           rollup_query = new RollupQuery(best_match_rollups.remove(0), 
                   downsampler.getFunction(), downsampler.getInterval(),
                   group_by);
-          if (group_by == Aggregators.COUNT) {
-            aggregator = Aggregators.SUM;
-          }
         }
         catch (NoSuchRollupForIntervalException nre) {
           LOG.error("There is no such rollup for the downsample interval "

File: src/tsd/PutDataPointRpc.java
Patch:
@@ -539,7 +539,7 @@ public Boolean call(final Object obj) {
         if (show_details) {
           details.add(getHttpDetails("Unexpected exception", dp));
         }
-        LOG.warn("Unexpected exception: " + dp);
+        LOG.warn("Unexpected exception: " + dp, e);
         unknown_errors.incrementAndGet();
       }
     }

File: test/core/TestTsdbQueryQueries.java
Patch:
@@ -30,6 +30,7 @@
 import java.util.List;
 import java.util.Map;
 
+import net.opentsdb.query.filter.TagVFilter;
 import net.opentsdb.query.filter.TagVLiteralOrFilter;
 import net.opentsdb.rollup.RollupConfig;
 import net.opentsdb.rollup.RollupInterval;
@@ -1606,7 +1607,7 @@ public void runRollupFiltering() throws Exception {
     sub.setMetric(METRIC_STRING);
     sub.setAggregator("sum");
     sub.setDownsample("1h-sum");
-    sub.setFilters(Lists.newArrayList(new TagVLiteralOrFilter("host", TAGV_STRING)));
+    sub.setFilters(Lists.<TagVFilter>newArrayList(new TagVLiteralOrFilter("host", TAGV_STRING)));
 
     ts_query.setQueries(Arrays.asList(sub));
     ts_query.validateAndSetQuery();

File: src/core/AggregationIterator.java
Patch:
@@ -783,7 +783,7 @@ public double nextDoubleValue() {
         r = Double.MAX_VALUE;
         break;
       case MIN:
-        r = Double.MIN_VALUE;
+        r = -Double.MAX_VALUE;
         break;
       case PREV:
         r = y0;

File: src/core/SaltScanner.java
Patch:
@@ -926,8 +926,9 @@ private void validateAndTriggerCallback(
       final Map<byte[], List<Annotation>> annotations,
       final List<SimpleEntry<byte[], List<HistogramDataPoint>>> histograms) {
 
+    int scannersRunning = countdown.decrementAndGet();
     if (kvs.size() > 0) {
-      kv_map.put(index, kvs);
+      kv_map.put(scannersRunning, kvs);
     }
     
     for (final byte[] key : annotations.keySet()) {
@@ -939,10 +940,9 @@ private void validateAndTriggerCallback(
     }
     
     if (histograms.size() > 0) {
-      histMap.put(index, histograms);
+      histMap.put(scannersRunning, histograms);
     }
 
-    int scannersRunning = countdown.decrementAndGet();
     if (scannersRunning <= 0) {
       try {
         mergeAndReturnResults();

File: test/query/TestQueryUtil.java
Patch:
@@ -139,7 +139,7 @@ public void setDataTableScanFilterEnableBoth() throws Exception {
         true,
         true,
         0);
-    verify(scanner, times(2)).getCurrentKey();
+    verify(scanner, times(3)).getCurrentKey();
     // TODO - validate the regex and fuzzy filter
     verify(scanner, times(1)).setFilter(any(FilterList.class));
     verify(scanner, times(1)).setStartKey(any(byte[].class));

File: src/core/SaltScanner.java
Patch:
@@ -464,7 +464,7 @@ final class ScannerCB implements Callback<Object,
     ArrayList<ArrayList<KeyValue>>> {
     private final Scanner scanner;
     private final int index;
-    private final List<KeyValue> kvs = new ArrayList<KeyValue>();
+    private final List<KeyValue> kvs = Collections.synchronizedList(new ArrayList<KeyValue>());
     private final ByteMap<List<Annotation>> annotations = 
             new ByteMap<List<Annotation>>();
     private final Set<String> skips = Collections.newSetFromMap(

File: src/tools/FsckOptions.java
Patch:
@@ -96,6 +96,7 @@ public static void addDataOptions(final ArgP argp) {
         "Delete compacted columns that cannot be parsed.");
     argp.addOption("--threads", "NUMBER",
         "Number of threads to use when executing a full table scan.");
+    argp.addOption("--sync", "Wait for each fix operation to finish to continue.");
   }
   
   /** @return Whether or not to fix errors while processing. Does not affect 

File: src/tools/Fsck.java
Patch:
@@ -618,7 +618,7 @@ private void fsckDataPoints(final Map<Long, ArrayList<DP>> datapoints)
       boolean has_milliseconds = false;
       boolean has_duplicates = false;
       boolean has_uncorrected_value_error = false;
-      long timestamp = Long.MIN_VALUE;
+      long timestamp = Long.MAX_VALUE;
 
       for (final Map.Entry<Long, ArrayList<DP>> time_map : datapoints.entrySet()) {
         if (key == null) {
@@ -676,7 +676,7 @@ private void fsckDataPoints(final Map<Long, ArrayList<DP>> datapoints)
         }
 
         unique_columns.put(dp_to_keep.kv.qualifier(), dp_to_keep.kv.value());
-        timestamp = Math.max(timestamp, dp_to_keep.kv.timestamp());
+        timestamp = Math.min(timestamp, dp_to_keep.kv.timestamp());
         valid_datapoints.getAndIncrement();
         has_uncorrected_value_error |= Internal.isFloat(dp_to_keep.qualifier()) ?
             fsckFloat(dp_to_keep) : fsckInteger(dp_to_keep);

File: src/core/TSDB.java
Patch:
@@ -946,7 +946,7 @@ public Deferred<Object> addPoint(final String metric,
                             tags, flags);
   }
 
-  private Deferred<Object> addPointInternal(final String metric,
+  Deferred<Object> addPointInternal(final String metric,
                                             final long timestamp,
                                             final byte[] value,
                                             final Map<String, String> tags,

File: src/utils/Config.java
Patch:
@@ -502,6 +502,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.preload_uid_cache.max_entries", "300000");
     default_map.put("tsd.core.storage_exception_handler.enable", "false");
     default_map.put("tsd.core.uid.random_metrics", "false");
+    default_map.put("tsd.core.bulk.allow_out_of_order_timestamps", "false");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.query.skip_unresolved_tagvs", "false");
     default_map.put("tsd.query.allow_simultaneous_duplicates", "true");

File: src/core/BatchedDataPoints.java
Patch:
@@ -137,6 +137,8 @@ public Deferred<Object> persist() {
     final byte[] q = Arrays.copyOfRange(batched_qualifier, 0, qualifier_index);
     final byte[] v = Arrays.copyOfRange(batched_value, 0, value_index);
     final byte[] r = Arrays.copyOfRange(row_key, 0, row_key.length);
+    final long base_time = this.base_time; // shadow fixes issue #1436
+    System.out.println(Arrays.toString(q) + "  " + Arrays.toString(v) + "  " + Arrays.toString(r));
     reset();
     return tsdb.put(r, q, v, base_time);
   }

File: src/tsd/client/QueryUi.java
Patch:
@@ -18,6 +18,7 @@
  * virtually no exposure to the technology except through the tutorial. --tsuna
  */
 
+import java.net.URLEncoder;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -723,12 +724,12 @@ private void addLabels(final StringBuilder url) {
   private void addFormats(final StringBuilder url) {
     final String yformat = this.yformat.getText();
     if (!yformat.isEmpty()) {
-      url.append("&yformat=").append(yformat);
+      url.append("&yformat=").append(URL.encode(yformat));
     }
     if (y2format.isEnabled()) {
       final String y2format = this.y2format.getText();
       if (!y2format.isEmpty()) {
-        url.append("&y2format=").append(y2format);
+        url.append("&y2format=").append(URL.encode(y2format));
       }
     }
   }

File: src/tools/UidManager.java
Patch:
@@ -330,6 +330,9 @@ private static int grep(final HBaseClient client,
   private static boolean printResult(final ArrayList<KeyValue> row,
                                      final byte[] family,
                                      final boolean formard) {
+    if (null == row || row.isEmpty()) {
+      return false;
+    }
     final byte[] key = row.get(0).key();
     String name = formard ? CliUtils.fromBytes(key) : null;
     String id = formard ? null : Arrays.toString(key);

File: src/tools/UidManager.java
Patch:
@@ -330,6 +330,9 @@ private static int grep(final HBaseClient client,
   private static boolean printResult(final ArrayList<KeyValue> row,
                                      final byte[] family,
                                      final boolean formard) {
+    if (null == row || row.isEmpty()) {
+      return false;
+    }
     final byte[] key = row.get(0).key();
     String name = formard ? CliUtils.fromBytes(key) : null;
     String id = formard ? null : Arrays.toString(key);

File: src/core/TSDB.java
Patch:
@@ -729,19 +729,19 @@ public Deferred<ArrayList<Object>> checkNecessaryTablesExist() {
   }
 
   /** Number of cache hits during lookups involving UIDs. */
-  public int uidCacheHits() {
+  public long uidCacheHits() {
     return (metrics.cacheHits() + tag_names.cacheHits()
             + tag_values.cacheHits());
   }
 
   /** Number of cache misses during lookups involving UIDs. */
-  public int uidCacheMisses() {
+  public long uidCacheMisses() {
     return (metrics.cacheMisses() + tag_names.cacheMisses()
             + tag_values.cacheMisses());
   }
 
   /** Number of cache entries currently in RAM for lookups involving UIDs. */
-  public int uidCacheSize() {
+  public long uidCacheSize() {
     return (metrics.cacheSize() + tag_names.cacheSize()
             + tag_values.cacheSize());
   }

File: src/core/TSDB.java
Patch:
@@ -594,19 +594,19 @@ public Deferred<ArrayList<Object>> checkNecessaryTablesExist() {
   }
   
   /** Number of cache hits during lookups involving UIDs. */
-  public int uidCacheHits() {
+  public long uidCacheHits() {
     return (metrics.cacheHits() + tag_names.cacheHits()
             + tag_values.cacheHits());
   }
 
   /** Number of cache misses during lookups involving UIDs. */
-  public int uidCacheMisses() {
+  public long uidCacheMisses() {
     return (metrics.cacheMisses() + tag_names.cacheMisses()
             + tag_values.cacheMisses());
   }
 
   /** Number of cache entries currently in RAM for lookups involving UIDs. */
-  public int uidCacheSize() {
+  public long uidCacheSize() {
     return (metrics.cacheSize() + tag_names.cacheSize()
             + tag_values.cacheSize());
   }

File: src/auth/AuthenticationChannelHandler.java
Patch:
@@ -98,6 +98,7 @@ public void messageReceived(final ChannelHandlerContext ctx,
         String auth_response = TELNET_AUTH_FAILURE;
         final AuthState state = authentication.authenticateTelnet(
             authEvent.getChannel(), (String[]) authCommand);
+
         if (state.getStatus() == AuthStatus.SUCCESS) {
           auth_response = TELNET_AUTH_SUCCESS;
           ctx.getPipeline().remove(this);

File: src/utils/Config.java
Patch:
@@ -605,7 +605,7 @@ protected void setDefaults() {
       + "Content-Type, Accept, Origin, User-Agent, DNT, Cache-Control, "
       + "X-Mx-ReqToken, Keep-Alive, X-Requested-With, If-Modified-Since");
     default_map.put("tsd.query.timeout", "0");
-    default_map.put("tsd.storage.use_otsdb_timestamp", "true");
+    default_map.put("tsd.storage.use_otsdb_timestamp", "false");
     default_map.put("tsd.storage.use_max_value", "true");
     default_map.put("tsd.storage.get_date_tiered_compaction_start", "0");
 

File: src/stats/QueryStats.java
Patch:
@@ -411,7 +411,7 @@ public static Map<String, Object> getRunningAndCompleteStats() {
         obj.put("remote", stats.remote_address);
         obj.put("user", stats.user);
         obj.put("headers", stats.headers);;
-        obj.put("queryStart", DateTime.msFromNano(stats.query_start_ns));
+        obj.put("queryStart", stats.query_start_ms);
         obj.put("elapsed", DateTime.msFromNanoDiff(DateTime.nanoTime(), 
             stats.query_start_ns));
         running.add(obj);

File: src/stats/QueryStats.java
Patch:
@@ -411,7 +411,7 @@ public static Map<String, Object> getRunningAndCompleteStats() {
         obj.put("remote", stats.remote_address);
         obj.put("user", stats.user);
         obj.put("headers", stats.headers);;
-        obj.put("queryStart", DateTime.msFromNano(stats.query_start_ns));
+        obj.put("queryStart", stats.query_start_ms);
         obj.put("elapsed", DateTime.msFromNanoDiff(DateTime.nanoTime(), 
             stats.query_start_ns));
         running.add(obj);

File: src/core/FillingDownsampler.java
Patch:
@@ -194,9 +194,9 @@ public DataPoint next() {
         // The calculated interval timestamp matches what we expect, so we can
         // do normal processing.
         if (rollup_query != null && 
-            (rollup_query.getGroupBy() == Aggregators.AVG || 
-            rollup_query.getGroupBy() == Aggregators.DEV)) {
-          if (rollup_query.getGroupBy() == Aggregators.AVG) {
+            (rollup_query.getRollupAgg() == Aggregators.AVG || 
+            rollup_query.getRollupAgg() == Aggregators.DEV)) {
+          if (rollup_query.getRollupAgg() == Aggregators.AVG) {
             if (specification.getFunction() == Aggregators.AVG) {
               double sum = 0;
               long count = 0;

File: src/core/SaltScanner.java
Patch:
@@ -775,8 +775,8 @@ void processRow(final byte[] key, final ArrayList<KeyValue> row) {
                 LOG.error("Failed to decode histogram data point", t);
               }
             } else {
-              if (rollup_query.getGroupBy() == Aggregators.AVG || 
-                  rollup_query.getGroupBy() == Aggregators.DEV) {
+              if (rollup_query.getRollupAgg() == Aggregators.AVG || 
+                  rollup_query.getRollupAgg() == Aggregators.DEV) {
                 if (qual[0] == (byte) rollup_agg_id ||
                     qual[0] == (byte) rollup_count_id ||
                     Bytes.memcmp(RollupQuery.SUM, qual, 0, RollupQuery.SUM.length) == 0 ||

File: src/tsd/RpcHandler.java
Patch:
@@ -91,9 +91,8 @@ public RpcHandler(final TSDB tsdb, final RpcManager manager) {
     this.rpc_manager = manager;
 
     final String cors = tsdb.getConfig().getString("tsd.http.request.cors_domains");
-    final String mode = tsdb.getConfig().getString("tsd.mode");
 
-    LOG.info("TSD is in " + mode + " mode");
+    LOG.info("TSD is in " + tsdb.getMode() + " mode");
 
     if (cors == null || cors.isEmpty()) {
       cors_domains = null;

File: src/tsd/HttpQuery.java
Patch:
@@ -957,7 +957,7 @@ protected Logger logger() {
   // -------------------------------------------- //
 
   private static final String PAGE_HEADER_START =
-    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">"
+    "<!DOCTYPE html>"
     + "<html><head>"
     + "<meta http-equiv=content-type content=\"text/html;charset=utf-8\">"
     + "<title>";

File: src/core/AggregationIterator.java
Patch:
@@ -166,7 +166,7 @@ public class AggregationIterator implements SeekableView, DataPoint,
    * <li>No: for {@code iterators[i]} the timestamp of the current data
    *     point is {@code timestamps[i]} and the timestamp of the next data
    *     point is {@code timestamps[iterators.length + i]}.</li>
-   * </li></ul>
+   * </ul>
    * <p>
    * Each timestamp can have the {@code FLAG_FLOAT} applied so it's important
    * to use the {@code TIME_MASK} when getting the actual timestamp value

File: src/core/Aggregators.java
Patch:
@@ -87,12 +87,12 @@ public enum Interpolation {
   public static final Aggregator ZIMSUM = new Sum(
       Interpolation.ZIM, "zimsum");
 
-  /** Returns the minimum data point, causing SpanGroup to set <type>.MaxValue
+  /** Returns the minimum data point, causing SpanGroup to set &lt;type&gt;.MaxValue
    * if timestamps don't line up instead of interpolating. */
   public static final Aggregator MIMMIN = new Min(
       Interpolation.MAX, "mimmin");
   
-  /** Returns the maximum data point, causing SpanGroup to set <type>.MinValue
+  /** Returns the maximum data point, causing SpanGroup to set &lt;type&gt;.MinValue
    * if timestamps don't line up instead of interpolating. */
   public static final Aggregator MIMMAX = new Max(
       Interpolation.MIN, "mimmax");

File: src/core/HistogramCodecManager.java
Patch:
@@ -195,7 +195,6 @@ public byte[] encode(final int id,
    * @param id The ID of the histogram type to search for.
    * @param raw_data The non-null and non-empty byte array to parse. Should NOT
    * include the first byte of the ID in the data.
-   * @param timestamp The timestamp associated with the data point.
    * @param includes_id Whether or not the data includes the ID prefix.
    * @return A non-null data point if decoding was successful.
    */

File: src/core/HistogramDataPointCodec.java
Patch:
@@ -46,7 +46,6 @@ public void setId(final int id) {
    * Creates {@code HistogramDataPoint} from raw data and timestamp. Note that 
    * the data point identifier is separate.
    * @param raw_data The encoded byte array of the histogram data
-   * @param timestamp The timestamp of this data point
    * @param includes_id Whether or not to include the id prefix.
    * @return The decoded histogram data point instance
    */

File: src/core/RateOptions.java
Patch:
@@ -19,7 +19,7 @@
  * options are useful when working with metrics that are raw counter values, 
  * where a counter is defined by a value that always increases until it hits
  * a maximum value and then it "rolls over" to start back at 0.
- * <p/>
+ * <p>
  * These options will only be utilized if the query is for a rate calculation
  * and if the "counter" options is set to true.
  * @since 2.0

File: src/core/RowKey.java
Patch:
@@ -15,6 +15,8 @@
 import java.util.Arrays;
 import java.util.Comparator;
 
+import net.opentsdb.uid.NoSuchUniqueId;
+
 import org.hbase.async.Bytes;
 
 import com.stumbleupon.async.Deferred;
@@ -128,7 +130,7 @@ public static byte[] getSaltBytes(final int bucket) {
    * tag UIDs and returning a modulo based on the number of salt buckets.
    * The result will always be a positive integer from 0 to salt buckets.
    * 
-   * NOTE: The row key passed in MUST have allocated the {@link width} number of
+   * NOTE: The row key passed in MUST have allocated the {@code width} number of
    * bytes at the front of the row key or this call will overwrite data.
    * 
    * WARNING: If the width is set to a positive value, then the bucket must be

File: src/core/Span.java
Patch:
@@ -21,6 +21,7 @@
 
 import net.opentsdb.meta.Annotation;
 import net.opentsdb.rollup.RollupQuery;
+import net.opentsdb.uid.NoSuchUniqueId;
 import net.opentsdb.uid.UniqueId;
 
 import org.hbase.async.Bytes;

File: src/core/TSDB.java
Patch:
@@ -42,6 +42,7 @@
 import org.hbase.async.HBaseException;
 import org.hbase.async.KeyValue;
 import org.hbase.async.PutRequest;
+import org.hbase.async.TableNotFoundException;
 import org.jboss.netty.util.HashedWheelTimer;
 import org.jboss.netty.util.Timeout;
 import org.jboss.netty.util.Timer;

File: src/core/TSSubQuery.java
Patch:
@@ -457,7 +457,7 @@ public void setFilters(List<TagVFilter> filters) {
     this.filters = filters;
   }
   
-  /** @param whether or not to match series with ONLY the given tags 
+  /** @param explicit_tags whether or not to match series with ONLY the given tags 
    * @since 2.3 */
   public void setExplicitTags(final boolean explicit_tags) {
     this.explicit_tags = explicit_tags;

File: src/core/WriteableDataPointFilterPlugin.java
Patch:
@@ -42,7 +42,7 @@ public abstract class WriteableDataPointFilterPlugin {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
 

File: src/meta/MetaDataCache.java
Patch:
@@ -38,7 +38,7 @@ public abstract class MetaDataCache {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
 

File: src/meta/TSMeta.java
Patch:
@@ -22,6 +22,8 @@
 import java.util.Map;
 
 import net.opentsdb.core.TSDB;
+import net.opentsdb.uid.NoSuchUniqueId;
+import net.opentsdb.uid.NoSuchUniqueName;
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.uid.UniqueId.UniqueIdType;
 import net.opentsdb.utils.JSON;

File: src/meta/TSUIDQuery.java
Patch:
@@ -25,6 +25,7 @@
 import net.opentsdb.core.RowKey;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.core.Tags;
+import net.opentsdb.uid.NoSuchUniqueId;
 import net.opentsdb.uid.NoSuchUniqueName;
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.uid.UniqueId.UniqueIdType;
@@ -523,7 +524,7 @@ public String toString() {
 
   /**
    * Attempts to retrieve the last data point for the given TSUID. 
-   * This operates by checking the meta table for the {@link #COUNTER_QUALIFIER}
+   * This operates by checking the meta table for the {@code COUNTER_QUALIFIER}
    * and if found, parses the HBase timestamp for the counter (i.e. the time when
    * the counter was written) and tries to load the row in the data table for
    * the hour where that timestamp would have landed. If the counter does not

File: src/meta/UIDMeta.java
Patch:
@@ -36,6 +36,7 @@
 import com.stumbleupon.async.Deferred;
 
 import net.opentsdb.core.TSDB;
+import net.opentsdb.uid.NoSuchUniqueId;
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.uid.UniqueId.UniqueIdType;
 import net.opentsdb.utils.JSON;

File: src/query/QueryUtil.java
Patch:
@@ -183,7 +183,7 @@ public static String getRowKeyUIDRegex(
    * be null.
    * @param row_key_literals An optional list of key value pairs to filter on.
    * May be null.
-   * @param explicit_tag sWhether or not explicit tags are enabled so that the
+   * @param explicit_tags Whether or not explicit tags are enabled so that the
    * regex only picks out series with the specified tags
    * @param enable_fuzzy_filter Whether or not a fuzzy filter should be used
    * in combination with the explicit tags param. If explicit tags is disabled

File: src/query/expression/ExpressionReader.java
Patch:
@@ -61,7 +61,7 @@ public char next() {
     return chars[mark++];
   }
 
-  /** @param the number of characters to skip */
+  /** @param num the number of characters to skip */
   public void skip(final int num) {
     if (num < 0) {
       throw new UnsupportedOperationException("Skipping backwards is not allowed");

File: src/query/expression/Expressions.java
Patch:
@@ -70,7 +70,7 @@ public static ExpressionTree parse(final String expression,
 
   /**
    * Parses a list of string expressions into the proper trees, adding the
-   * metrics to the {@link metric_queries} list.
+   * metrics to the {@code metric_queries} list.
    * @param expressions A list of zero or more expressions (if empty, you get an
    * empty tree list back)
    * @param ts_query The original query with timestamps

File: src/query/expression/ITimeSyncedIterator.java
Patch:
@@ -65,7 +65,7 @@ public interface ITimeSyncedIterator {
   /** @return the index in the ExpressionIterator */
   public int getIndex();
   
-  /** @param the index in the ExpressionIterator */
+  /** @param index the index in the ExpressionIterator */
   public void setIndex(final int index);
   
   /** @return the ID of this set given by the user */
@@ -75,7 +75,7 @@ public interface ITimeSyncedIterator {
    * were defined then the set may be empty.  */
   public ByteSet getQueryTagKs();
 
-  /** @param A fill policy for the iterator. Iterators should implement a default */
+  /** @param policy A fill policy for the iterator. Iterators should implement a default */
   public void setFillPolicy(final NumericFillPolicy policy);
   
   /** @return the fill policy for the iterator */

File: src/query/expression/IntersectionIterator.java
Patch:
@@ -43,8 +43,8 @@
  * <p>
  * The {@link #current_values} map will map the expression "variables" to the
  * proper iterator for each serie's array. E.g.
- *   <"A", [1, 2, 3, 4]>
- *   <"B", [1, 2, 3, 4]>
+ *   &lt;"A", [1, 2, 3, 4]&gt;
+ *   &lt;"B", [1, 2, 3, 4]&gt;
  * <p>
  * So to use it's you simply fetch the result map, call {@link #hasNext()} and
  * {@link #next()} to iterate and in a for loop, iterate {@link #getSeriesSize()}

File: src/query/expression/NumericFillPolicy.java
Patch:
@@ -60,7 +60,7 @@ public String toString() {
     return "policy=" + policy + ", value=" + value;
   }
   
-  /** @returns a NumericFillPolicy builder */
+  /** @return a NumericFillPolicy builder */
   public static Builder Builder() {
     return new Builder();
   }

File: src/query/expression/VariableIterator.java
Patch:
@@ -82,15 +82,15 @@ public static SetOperator fromString(final String name) {
   public void next();
 
   /** 
-   * Determines whether the individual series in the {@link values} array has 
+   * Determines whether the individual series in the {@code values} array has 
    * another value. This may be used for non-synchronous iteration.
    * @param index The index of the series in the values array to check for
    * @return True if the series has another value, false if not
    */
   public boolean hasNext(final int index);
   
   /**
-   * Fetches the next value for an individual series in the {@link values} array.
+   * Fetches the next value for an individual series in the {@code values} array.
    * @param index The index of the series in the values array to advance
    */
   public void next(final int index);  

File: src/query/filter/TagVRegexFilter.java
Patch:
@@ -14,6 +14,7 @@
 
 import java.util.Map;
 import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 import com.google.common.base.Objects;
 import com.stumbleupon.async.Deferred;

File: src/rollup/RollUpDataPoint.java
Patch:
@@ -86,8 +86,8 @@ public final String getGroupByAggregator() {
     return groupby_aggregator;
   }
 
-  /** @param an optional aggregation function if the data point was 
-   * pre-aggregated */
+  /** @param groupby_aggregator an optional aggregation function if the data 
+   * point was pre-aggregated */
   public final void setGroupByAggregator(final String groupby_aggregator) {
     this.groupby_aggregator = groupby_aggregator;
   }

File: src/search/SearchPlugin.java
Patch:
@@ -60,7 +60,7 @@ public abstract class SearchPlugin {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
   

File: src/stats/QueryStats.java
Patch:
@@ -45,7 +45,7 @@
  * stats can be observed via /api/query/stats.
  * 
  * When a query is executed, it should instantiate an object of this class. 
- * Once the query is completed, make sure to call {@link markComplete}.
+ * Once the query is completed, make sure to call {@link #markSent()}.
  * 
  * The cache will store each query based on the combination of the client, query
  * and the result code. If the same query was executed multiple times then it
@@ -890,7 +890,7 @@ public double getTimeStat(final QueryStat stat) {
     return DateTime.msFromNano(overall_stats.get(stat));
   }
   
-  /** @param whether or not to allow duplicate queries to run */
+  /** @param enable_dupes whether or not to allow duplicate queries to run */
   public static void setEnableDuplicates(final boolean enable_dupes) {
     ENABLE_DUPLICATES = enable_dupes;
   }

File: src/tools/StartupPlugin.java
Patch:
@@ -23,8 +23,9 @@
  * as soon as it is completely parsed, just before OpenTSDB begins to use it.
  * <p>
  * <b>Note:</b> Implementations must have a parameterless constructor. The
- * {@link #initialize(TSDB)} method will be called immediately after the plugin is
+ * {@link #initialize(Config)} method will be called immediately after the plugin is
  * instantiated and before any other methods are called.
+ * 
  * @since 2.3
  */
 public abstract class StartupPlugin {
@@ -36,7 +37,7 @@ public abstract class StartupPlugin {
    * <b>Note:</b> Implementations should throw exceptions if they can't start
    * up properly. The TSD will then shutdown so the operator can fix the
    * problem. Please use IllegalArgumentException for configuration issues.
-   * @param tsdb The parent TSDB object
+   * @param config The OpenTSDDB config object.
    * @return A reference to the same configuration object passed in the parameters
    * on success.
    * @throws IllegalArgumentException if required configuration parameters are

File: src/tree/Leaf.java
Patch:
@@ -33,6 +33,7 @@
 import com.stumbleupon.async.Deferred;
 
 import net.opentsdb.core.TSDB;
+import net.opentsdb.uid.NoSuchUniqueId;
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.uid.UniqueId.UniqueIdType;
 import net.opentsdb.utils.JSON;

File: src/tree/Tree.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
+import java.util.regex.PatternSyntaxException;
 
 import net.opentsdb.core.TSDB;
 import net.opentsdb.uid.UniqueId;

File: src/tree/TreeRule.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 import org.hbase.async.Bytes;
 import org.hbase.async.DeleteRequest;

File: src/tsd/AbstractHttpQuery.java
Patch:
@@ -115,7 +115,7 @@ public Channel channel() {
     return chan;
   }
 
-  /** @return The remote address and port in the format <ip>:<port> */
+  /** @return The remote address and port in the format &lt;ip&gt;:&lt;port&gt; */
   public String getRemoteAddress() {
     return chan.getRemoteAddress().toString();
   }

File: src/tsd/PipelineFactory.java
Patch:
@@ -68,7 +68,7 @@ public final class PipelineFactory implements ChannelPipelineFactory {
    * plugins. This constructor creates its own {@link RpcManager}.
    * @param tsdb The TSDB to use.
    * @throws RuntimeException if there is an issue loading plugins
-   * @throws Exception if the HttpQuery handler is unable to load 
+   * @throws RuntimeException if the HttpQuery handler is unable to load 
    * serializers
    */
   public PipelineFactory(final TSDB tsdb) {
@@ -82,7 +82,7 @@ public PipelineFactory(final TSDB tsdb) {
    * @param tsdb The TSDB to use.
    * @param manager instance of a ready-to-use {@link RpcManager}.
    * @throws RuntimeException if there is an issue loading plugins
-   * @throws Exception if the HttpQuery handler is unable to load serializers
+   * throws Exception if the HttpQuery handler is unable to load serializers
    */
   public PipelineFactory(final TSDB tsdb, final RpcManager manager) {
     this(tsdb, RpcManager.instance(tsdb), 
@@ -97,7 +97,7 @@ public PipelineFactory(final TSDB tsdb, final RpcManager manager) {
    * @param connections_limit The maximum number of concurrent connections 
    * supported by the TSD.
    * @throws RuntimeException if there is an issue loading plugins
-   * @throws Exception if the HttpQuery handler is unable to load serializers
+   * throws Exception if the HttpQuery handler is unable to load serializers
    * @since 2.3
    */
   public PipelineFactory(final TSDB tsdb, final RpcManager manager, 

File: src/tsd/RTPublisher.java
Patch:
@@ -48,7 +48,7 @@ public abstract class RTPublisher {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
   

File: src/tsd/RpcPlugin.java
Patch:
@@ -45,7 +45,7 @@ public abstract class RpcPlugin {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
   

File: src/tsd/StorageExceptionHandler.java
Patch:
@@ -40,7 +40,7 @@ public abstract class StorageExceptionHandler {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
   

File: src/uid/RandomUniqueId.java
Patch:
@@ -40,7 +40,7 @@ public class RandomUniqueId {
    * and 2^31-1.
    * NOTE: The caller is responsible for assuring that the UID hasn't been
    * assigned yet.
-   * @return a random UID up to {@link TSDB.metrics_width} wide
+   * @return a random UID up to {@link TSDB#metrics_width()} wide
    */
   public static long getRandomUID() {
     return getRandomUID(TSDB.metrics_width());
@@ -52,7 +52,7 @@ public static long getRandomUID() {
    * @param width Number of bytes to randomize, it can not be larger 
    * than {@link MAX_WIDTH} bytes wide
    * @return a randomly UID
-   * @throws throws IllegalArgumentException if the width is larger than 
+   * @throws IllegalArgumentException if the width is larger than 
    * {@link MAX_WIDTH} bytes
    */
   public static long getRandomUID(final int width) {

File: src/uid/UniqueIdFilterPlugin.java
Patch:
@@ -43,7 +43,7 @@ public abstract class UniqueIdFilterPlugin {
    * @param tsdb The parent TSDB object
    * @throws IllegalArgumentException if required configuration parameters are 
    * missing
-   * @throws Exception if something else goes wrong
+   * @throws RuntimeException if something else goes wrong
    */
   public abstract void initialize(final TSDB tsdb);
 

File: src/utils/Config.java
Patch:
@@ -38,7 +38,7 @@
  * Wherever you need to access the config value, use the proper helper to fetch
  * the value, accounting for exceptions that may be thrown if necessary.
  *
- * The get<type> number helpers will return NumberFormatExceptions if the
+ * The get&lt;type&gt; number helpers will return NumberFormatExceptions if the
  * requested property is null or unparseable. The {@link #getString(String)}
  * helper will return a NullPointerException if the property isn't found.
  * <p>

File: src/utils/DateTime.java
Patch:
@@ -342,7 +342,7 @@ public static void setDefaultTimezone(final String tzname) {
   }
 
   /**
-   * Pass through to {@link System.currentTimeMillis} for use in classes to
+   * Pass through to {@link System#currentTimeMillis()} for use in classes to
    * make unit testing easier. Mocking System.class is a bad idea in general
    * so placing this here and mocking DateTime.class is MUCH cleaner.
    * @return The current epoch time in milliseconds
@@ -353,7 +353,7 @@ public static long currentTimeMillis() {
   }
 
   /**
-   * Pass through to {@link System.nanoTime} for use in classes to
+   * Pass through to {@link System#nanoTime()} for use in classes to
    * make unit testing easier. Mocking System.class is a bad idea in general
    * so placing this here and mocking DateTime.class is MUCH cleaner.
    * @return The current epoch time in milliseconds
@@ -608,7 +608,7 @@ public static Calendar previousInterval(final long ts, final int interval,
   /**
    * Return the proper Calendar time unit as an integer given the string
    * @param units The unit to parse
-   * @return An integer matching a Calendar.<UNIT> enum
+   * @return An integer matching a Calendar.&lt;UNIT&gt; enum
    * @throws IllegalArgumentException if the unit is null, empty or doesn't 
    * match one of the configured units.
    * @since 2.3

File: src/utils/PluginLoader.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.ServiceConfigurationError;
 import java.util.ServiceLoader;
 
 import org.slf4j.Logger;
@@ -88,7 +89,7 @@ public final class PluginLoader {
    * @return An instantiated object of the given type if found, null if the
    * class could not be found
    * @throws ServiceConfigurationError if the plugin cannot be instantiated
-   * @throws IllegalArgumentName if the plugin name is null or empty
+   * @throws IllegalArgumentException if the plugin name is null or empty
    */
   public static <T> T loadSpecificPlugin(final String name, 
       final Class<T> type) {

File: test/tsd/TestHttpRpcPluginQuery.java
Patch:
@@ -43,7 +43,7 @@ public void before() {
   
   @Test
   public void getQueryBaseRoute() {
-    assertEquals("test/this/path", makeQuery("/plugin/test/this/path").getQueryBaseRoute());
+    assertEquals("test", makeQuery("/plugin/test/this/path").getQueryBaseRoute());
     assertEquals("test", makeQuery("/plugin/test/").getQueryBaseRoute());
     assertEquals("test", makeQuery("/plugin/test?some=else&this=that").getQueryBaseRoute());
   }

File: src/tools/UidManager.java
Patch:
@@ -35,7 +35,6 @@
 import org.hbase.async.PutRequest;
 import org.hbase.async.Scanner;
 
-import net.opentsdb.core.Const;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.meta.TSMeta;
 import net.opentsdb.uid.NoSuchUniqueId;
@@ -301,7 +300,7 @@ private static int grep(final HBaseClient client,
     if (ignorecase) {
       regexp = "(?i)" + regexp;
     }
-    scanner.setKeyRegexp(regexp, Const.ASCII_CHARSET);
+    scanner.setKeyRegexp(regexp, CliUtils.CHARSET);
     boolean found = false;
     try {
       ArrayList<ArrayList<KeyValue>> rows;

File: src/tools/UidManager.java
Patch:
@@ -35,7 +35,6 @@
 import org.hbase.async.PutRequest;
 import org.hbase.async.Scanner;
 
-import net.opentsdb.core.Const;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.meta.TSMeta;
 import net.opentsdb.uid.NoSuchUniqueId;
@@ -301,7 +300,7 @@ private static int grep(final HBaseClient client,
     if (ignorecase) {
       regexp = "(?i)" + regexp;
     }
-    scanner.setKeyRegexp(regexp, Const.ASCII_CHARSET);
+    scanner.setKeyRegexp(regexp, CliUtils.CHARSET);
     boolean found = false;
     try {
       ArrayList<ArrayList<KeyValue>> rows;

File: src/tools/UidManager.java
Patch:
@@ -35,6 +35,7 @@
 import org.hbase.async.PutRequest;
 import org.hbase.async.Scanner;
 
+import net.opentsdb.core.Const;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.meta.TSMeta;
 import net.opentsdb.uid.NoSuchUniqueId;
@@ -300,7 +301,7 @@ private static int grep(final HBaseClient client,
     if (ignorecase) {
       regexp = "(?i)" + regexp;
     }
-    scanner.setKeyRegexp(regexp, CliUtils.CHARSET);
+    scanner.setKeyRegexp(regexp, Const.ASCII_CHARSET);
     boolean found = false;
     try {
       ArrayList<ArrayList<KeyValue>> rows;

File: src/tools/UidManager.java
Patch:
@@ -35,6 +35,7 @@
 import org.hbase.async.PutRequest;
 import org.hbase.async.Scanner;
 
+import net.opentsdb.core.Const;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.meta.TSMeta;
 import net.opentsdb.uid.NoSuchUniqueId;
@@ -300,7 +301,7 @@ private static int grep(final HBaseClient client,
     if (ignorecase) {
       regexp = "(?i)" + regexp;
     }
-    scanner.setKeyRegexp(regexp, CliUtils.CHARSET);
+    scanner.setKeyRegexp(regexp, Const.ASCII_CHARSET);
     boolean found = false;
     try {
       ArrayList<ArrayList<KeyValue>> rows;

File: src/core/Span.java
Patch:
@@ -227,7 +227,8 @@ protected void addRow(final KeyValue row) {
    */
   static long lastTimestampInRow(final short metric_width,
                                  final KeyValue row) {
-    final long base_time = Bytes.getUnsignedInt(row.key(), metric_width);
+    final long base_time = Bytes.getUnsignedInt(row.key(), metric_width + 
+        Const.SALT_WIDTH());
     final byte[] qual = row.qualifier();
     if (qual.length >= 4 && Internal.inMilliseconds(qual[qual.length - 4])) {
       return (base_time * 1000) + ((Bytes.getUnsignedInt(qual, qual.length - 4) & 

File: src/rollup/RollupConfig.java
Patch:
@@ -282,7 +282,7 @@ public int getIdForAggregator(final String aggregator) {
     }
     Integer id = aggregations_to_ids.get(aggregator.toLowerCase());
     if (id == null) {
-      throw new IllegalArgumentException("No ID found mapping to aggregator " 
+      throw new IllegalArgumentException("No ID found mapping to aggregator: " 
           + aggregator);
     }
     return id;

File: test/storage/MockBase.java
Patch:
@@ -1707,7 +1707,7 @@ public Deferred<ArrayList<ArrayList<KeyValue>>> answer(
             }
 
 
-            // handle qualifier filters. Just regexp for now
+            // handle qualifier filters. 
             if (filter != null) {
               List<QualifierFilter> qfs = Lists.newArrayList();
               if (filter instanceof FilterList) {

File: src/utils/Config.java
Patch:
@@ -535,6 +535,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.connections.limit", "0");
     default_map.put("tsd.core.enable_api", "true");
     default_map.put("tsd.core.enable_ui", "true");
+    default_map.put("tsd.core.hist_decoder", "net.opentsdb.core.SimpleHistogramDecoder");
     default_map.put("tsd.core.meta.enable_realtime_ts", "false");
     default_map.put("tsd.core.meta.enable_realtime_uid", "false");
     default_map.put("tsd.core.meta.enable_tsuid_incrementing", "false");

File: src/core/AppendDataPoints.java
Patch:
@@ -227,8 +227,8 @@ public final Collection<Cell> parseKeyValue(final TSDB tsdb, final KeyValue kv)
       
     if (repair && needs_repair) {
       LOG.debug("Repairing appended data column " + kv);
-      final PutRequest put = new PutRequest(tsdb.table, kv.key(),  
-          TSDB.FAMILY(), kv.qualifier(), healed_cell);
+      final PutRequest put = RequestBuilder.buildPutRequest(tsdb.getConfig(), tsdb.table, kv.key(),
+          TSDB.FAMILY(), kv.qualifier(), healed_cell, kv.timestamp());
       repaired_deferred = tsdb.getClient().put(put);
     }
     

File: src/core/BatchedDataPoints.java
Patch:
@@ -138,7 +138,7 @@ public Deferred<Object> persist() {
     final byte[] v = Arrays.copyOfRange(batched_value, 0, value_index);
     final byte[] r = Arrays.copyOfRange(row_key, 0, row_key.length);
     reset();
-    return tsdb.put(r, q, v);
+    return tsdb.put(r, q, v, base_time);
   }
 
   @Override

File: src/core/IncomingDataPoints.java
Patch:
@@ -351,12 +351,12 @@ public Deferred<Object> call(final Boolean allowed) throws Exception {
         if (tsdb.getConfig().enable_appends()) {
           final AppendDataPoints kv = new AppendDataPoints(qualifier, value);
           final AppendRequest point = new AppendRequest(tsdb.table, row, TSDB.FAMILY, 
-              AppendDataPoints.APPEND_COLUMN_QUALIFIER, kv.getBytes());
+                  AppendDataPoints.APPEND_COLUMN_QUALIFIER, kv.getBytes());
           point.setDurable(!batch_import);
           return tsdb.client.append(point);/* .addBoth(cb) */
         } else {
-          final PutRequest point = new PutRequest(tsdb.table, row, TSDB.FAMILY, 
-              qualifier, value);
+          final PutRequest point = RequestBuilder.buildPutRequest(tsdb.getConfig(), tsdb.table, row, TSDB.FAMILY,
+              qualifier, value, timestamp);
           point.setDurable(!batch_import);
           return tsdb.client.put(point)/* .addBoth(cb) */;
         }

File: src/meta/Annotation.java
Patch:
@@ -33,6 +33,7 @@
 
 import net.opentsdb.core.Const;
 import net.opentsdb.core.Internal;
+import net.opentsdb.core.RequestBuilder;
 import net.opentsdb.core.RowKey;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.uid.UniqueId;
@@ -184,10 +185,10 @@ public Deferred<Boolean> call(final Annotation stored_note)
         
         final byte[] tsuid_byte = tsuid != null && !tsuid.isEmpty() ? 
             UniqueId.stringToUid(tsuid) : null;
-        final PutRequest put = new PutRequest(tsdb.dataTable(), 
+        final PutRequest put = RequestBuilder.buildPutRequest(tsdb.getConfig(), tsdb.dataTable(),
             getRowKey(start_time, tsuid_byte), FAMILY, 
             getQualifier(start_time), 
-            Annotation.this.getStorageJSON());
+            Annotation.this.getStorageJSON(), start_time);
         return tsdb.getClient().compareAndSet(put, original_note);
       }
       
@@ -275,7 +276,6 @@ public Deferred<Annotation> call(final ArrayList<KeyValue> row)
         if (row == null || row.isEmpty()) {
           return Deferred.fromResult(null);
         }
-        
         Annotation note = JSON.parseToObject(row.get(0).value(),
             Annotation.class);
         return Deferred.fromResult(note);

File: src/core/SaltMultiGetter.java
Patch:
@@ -398,7 +398,7 @@ private void processRollupQuery(final byte[] key, final ArrayList<KeyValue> row,
             final Annotation note = JSON.parseToObject(kv.value(), Annotation.class);
             notes.add(note);
           } else {
-            if (rollup_query.getRollupAgg() == Aggregators.AVG || rollup_query.getRollupAgg() == Aggregators.DEV) {
+            if (rollup_query.getGroupBy() == Aggregators.AVG || rollup_query.getGroupBy() == Aggregators.DEV) {
               if (Bytes.memcmp(RollupQuery.SUM, qual, 0, RollupQuery.SUM.length) == 0
                   || Bytes.memcmp(RollupQuery.COUNT, qual, 0, RollupQuery.COUNT.length) == 0) {
                 keyValues.add(kv);

File: src/core/SaltScanner.java
Patch:
@@ -567,8 +567,8 @@ void processRow(final byte[] key, final ArrayList<KeyValue> row) {
                 map_notes.add(note);
               }
             } else {
-              if (rollup_query.getRollupAgg() == Aggregators.AVG || 
-                  rollup_query.getRollupAgg() == Aggregators.DEV) {
+              if (rollup_query.getGroupBy() == Aggregators.AVG || 
+                  rollup_query.getGroupBy() == Aggregators.DEV) {
                 if (Bytes.memcmp(RollupQuery.SUM, qual, 0, RollupQuery.SUM.length) == 0 ||
                     Bytes.memcmp(RollupQuery.COUNT, qual, 0, RollupQuery.COUNT.length) == 0) {
                   kvs.add(kv);

File: test/core/TestRollupSpan.java
Patch:
@@ -61,7 +61,7 @@ public final class TestRollupSpan {
   
   private static final RollupQuery rollup_query = 
     new RollupQuery(new RollupInterval("tsdb", "tsdb-agg", "1s", "1h"), 
-    aggr_sum, 1000);
+    aggr_sum, 1000, aggr_sum);
   
   @Before
   public void before() throws Exception {

File: src/utils/Config.java
Patch:
@@ -484,6 +484,8 @@ protected void setDefaults() {
     default_map.put("tsd.network.tcp_no_delay", "true");
     default_map.put("tsd.network.keep_alive", "true");
     default_map.put("tsd.network.reuse_address", "true");
+    default_map.put("tsd.core.authentication.enable", "false");
+    default_map.put("tsd.core.authentication.plugin", "");
     default_map.put("tsd.core.auto_create_metrics", "false");
     default_map.put("tsd.core.auto_create_tagks", "true");
     default_map.put("tsd.core.auto_create_tagvs", "true");

File: src/utils/Config.java
Patch:
@@ -491,7 +491,6 @@ protected void setDefaults() {
     default_map.put("tsd.network.tcp_no_delay", "true");
     default_map.put("tsd.network.keep_alive", "true");
     default_map.put("tsd.network.reuse_address", "true");
-    default_map.put("tsd.core.agg_tag", "_aggregate");
     default_map.put("tsd.core.auto_create_metrics", "false");
     default_map.put("tsd.core.auto_create_tagks", "true");
     default_map.put("tsd.core.auto_create_tagvs", "true");

File: src/core/TSQuery.java
Patch:
@@ -71,7 +71,7 @@ public final class TSQuery {
   private boolean show_tsuids;
   
   /** A list of parsed sub queries, must have one or more to fetch data */
-  private ArrayList<TSSubQuery> queries;
+  private List<TSSubQuery> queries;
 
   /** The parsed start time value 
    * <b>Do not set directly</b> */
@@ -445,7 +445,7 @@ public void setShowTSUIDs(boolean show_tsuids) {
   }
   
   /** @param queries a list of {@link TSSubQuery} objects to store*/
-  public void setQueries(ArrayList<TSSubQuery> queries) {
+  public void setQueries(final List<TSSubQuery> queries) {
     this.queries = queries;
   }
 

File: src/rollup/RollupSeq.java
Patch:
@@ -258,7 +258,7 @@ private void append(KeyValue column, boolean is_count) {
             }
           }
         } else {
-          throw new IllegalArgumentException("The offset for " + column 
+          throw new IllegalDataException("The offset for " + column 
               + " of " + offset + " is <= the last offset " + last_offset
               + " for " + this);
         }

File: src/core/Downsampler.java
Patch:
@@ -121,6 +121,7 @@ public class Downsampler implements SeekableView, DataPoint {
     values_in_interval = new ValuesInInterval();
     this.query_start = query_start;
     this.query_end = query_end;
+    this.is_rollup = is_rollup;
     
     final String s = specification.getStringInterval();
     if (s != null && s.toLowerCase().contains("all")) {

File: src/core/TSDB.java
Patch:
@@ -946,7 +946,7 @@ public Deferred<Object> addPoint(final String metric,
                             tags, flags);
   }
 
-  private Deferred<Object> addPointInternal(final String metric,
+  Deferred<Object> addPointInternal(final String metric,
                                             final long timestamp,
                                             final byte[] value,
                                             final Map<String, String> tags,

File: src/utils/Config.java
Patch:
@@ -502,6 +502,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.preload_uid_cache.max_entries", "300000");
     default_map.put("tsd.core.storage_exception_handler.enable", "false");
     default_map.put("tsd.core.uid.random_metrics", "false");
+    default_map.put("tsd.core.bulk.allow_out_of_order_timestamps", "false");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.query.skip_unresolved_tagvs", "false");
     default_map.put("tsd.query.allow_simultaneous_duplicates", "true");

File: src/query/expression/UnionIterator.java
Patch:
@@ -259,7 +259,7 @@ private void setCurrentAndMeta(final ByteMap<ExpressionDataPoint[]>
   static byte[] flattenTags(final boolean use_query_tags, 
       final boolean include_agg_tags, final ExpressionDataPoint dp, 
       final ITimeSyncedIterator sub) {
-    if (dp.tags().isEmpty()) {
+    if (dp.tags() == null || dp.tags().isEmpty()) {
       return HBaseClient.EMPTY_ARRAY;
     }
     final int tagk_width = TSDB.tagk_width();

File: test/query/expression/TestUnionIterator.java
Patch:
@@ -1026,10 +1026,11 @@ public void flattenTagsQueryTagsEmptyWithAgg() throws Exception {
     assertArrayEquals(UID3, flat);
   }
 
-  @Test (expected = NullPointerException.class)
+  @Test
   public void flattenTagsNullTags() throws Exception {
     final ExpressionDataPoint dp = getMockDB(null, agg_tags);
-    UnionIterator.flattenTags(false, false, dp, sub);
+    final byte[] flat = UnionIterator.flattenTags(true, false, dp, sub);
+    assertArrayEquals(HBaseClient.EMPTY_ARRAY, flat);
   }
   
   @Test

File: src/core/RowKey.java
Patch:
@@ -55,7 +55,7 @@ static String metricName(final TSDB tsdb, final byte[] row) {
    */
   public static Deferred<String> metricNameAsync(final TSDB tsdb, 
       final byte[] row) {
-    if (row == null || row.length < 0) {
+    if (row == null || row.length < 1) {
       throw new IllegalArgumentException("Row key cannot be null or empty");
     }
     if (row.length < Const.SALT_WIDTH() + tsdb.metrics.width()) {

File: src/core/RowKey.java
Patch:
@@ -55,7 +55,7 @@ static String metricName(final TSDB tsdb, final byte[] row) {
    */
   public static Deferred<String> metricNameAsync(final TSDB tsdb, 
       final byte[] row) {
-    if (row == null || row.length < 0) {
+    if (row == null || row.length < 1) {
       throw new IllegalArgumentException("Row key cannot be null or empty");
     }
     if (row.length < Const.SALT_WIDTH() + tsdb.metrics.width()) {

File: src/query/QueryUtil.java
Patch:
@@ -231,7 +231,7 @@ public static void setDataTableScanFilter(
           byteRegexToString(regex));
     }
     
-    if (!explicit_tags || !enable_fuzzy_filter) {
+    if (!(explicit_tags && enable_fuzzy_filter)) {
       scanner.setFilter(regex_filter);
       return;
     }

File: src/utils/Config.java
Patch:
@@ -488,6 +488,8 @@ protected void setDefaults() {
     default_map.put("tsd.core.auto_create_tagks", "true");
     default_map.put("tsd.core.auto_create_tagvs", "true");
     default_map.put("tsd.core.connections.limit", "0");
+    default_map.put("tsd.core.enable_api", "true");
+    default_map.put("tsd.core.enable_ui", "true");
     default_map.put("tsd.core.meta.enable_realtime_ts", "false");
     default_map.put("tsd.core.meta.enable_realtime_uid", "false");
     default_map.put("tsd.core.meta.enable_tsuid_incrementing", "false");

File: test/query/pojo/TestQuery.java
Patch:
@@ -70,7 +70,7 @@ public class TestQuery {
       + "  \"expressions\":["
       + "    {"
       + "      \"id\":\"e1\","
-      + "      \"expr\":\"a + b + c\""
+      + "      \"expr\":\"m1 * 1024\""
       + "    }"
       + "  ],"
       + "  \"outputs\":["
@@ -96,7 +96,7 @@ public void setup() {
         .setId("m1").setFilter("f1").setTimeOffset("0")
         .setAggregator("sum").build();
     expression = Expression.Builder().setId("e1")
-        .setExpression("a + b + c").setJoin(
+        .setExpression("m1 * 1024").setJoin(
             Join.Builder().setOperator(SetOperator.UNION).build()).build();
     output = Output.Builder().setId("m1").setAlias("CPU Idle EAST DC")
         .build();

File: src/core/SaltScanner.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -306,8 +305,8 @@ final class ScannerCB implements Callback<Object,
     private final List<KeyValue> kvs = new ArrayList<KeyValue>();
     private final ByteMap<List<Annotation>> annotations = 
             new ByteMap<List<Annotation>>();
-    private final Set<String> skips = new HashSet<String>();
-    private final Set<String> keepers = new HashSet<String>();
+    private final Set<String> skips = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
+    private final Set<String> keepers = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
     
     private long scanner_start = -1;
     /** nanosecond timestamps */

File: src/core/SaltScanner.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -306,8 +305,8 @@ final class ScannerCB implements Callback<Object,
     private final List<KeyValue> kvs = new ArrayList<KeyValue>();
     private final ByteMap<List<Annotation>> annotations = 
             new ByteMap<List<Annotation>>();
-    private final Set<String> skips = new HashSet<String>();
-    private final Set<String> keepers = new HashSet<String>();
+    private final Set<String> skips = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
+    private final Set<String> keepers = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
     
     private long scanner_start = -1;
     /** nanosecond timestamps */

File: src/core/SaltScanner.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -306,8 +305,8 @@ final class ScannerCB implements Callback<Object,
     private final List<KeyValue> kvs = new ArrayList<KeyValue>();
     private final ByteMap<List<Annotation>> annotations = 
             new ByteMap<List<Annotation>>();
-    private final Set<String> skips = new HashSet<String>();
-    private final Set<String> keepers = new HashSet<String>();
+    private final Set<String> skips = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
+    private final Set<String> keepers = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
     
     private long scanner_start = -1;
     /** nanosecond timestamps */

File: src/query/QueryUtil.java
Patch:
@@ -200,7 +200,8 @@ public static void setDataTableScanFilter(
       final int end_time) {
     
     // no-op
-    if (group_bys.isEmpty() && row_key_literals.isEmpty()) {
+    if ((group_bys == null || group_bys.isEmpty()) 
+        && (row_key_literals == null || row_key_literals.isEmpty())) {
       return;
     }
     

File: src/tools/DumpSeries.java
Patch:
@@ -182,7 +182,7 @@ private static void formatKeyValue(final StringBuilder buf,
     final byte[] value = kv.value();
     final int q_len = qualifier.length;
 
-    if (q_len != 3 && q_len % 2 != 0) {
+    if (!AppendDataPoints.isAppendDataPoints(qualifier) && q_len % 2 != 0) {
       if (!importformat) {
         // custom data object, not a data point
         if (kv.qualifier()[0] == Annotation.PREFIX()) {

File: src/tools/TSDMain.java
Patch:
@@ -141,9 +141,9 @@ public static void main(String[] args) throws IOException {
     }
 
     final ServerSocketChannelFactory factory;
-    int connectionsLimit = 0;
+    int connections_limit = 0;
     try {
-      connectionsLimit = config.getInt("tsd.core.connections.limit");
+      connections_limit = config.getInt("tsd.core.connections.limit");
     } catch (NumberFormatException nfe) {
       usage(argp, "Invalid connections limit", 1);
     }
@@ -197,7 +197,7 @@ public static void main(String[] args) throws IOException {
       // here to fail fast.
       final RpcManager manager = RpcManager.instance(tsdb);
 
-      server.setPipelineFactory(new PipelineFactory(tsdb, manager, connectionsLimit));
+      server.setPipelineFactory(new PipelineFactory(tsdb, manager, connections_limit));
       if (config.hasProperty("tsd.network.backlog")) {
         server.setOption("backlog", config.getInt("tsd.network.backlog")); 
       }

File: src/tools/TSDMain.java
Patch:
@@ -180,7 +180,7 @@ public static void main(String[] args) throws IOException {
     try {
       tsdb = new TSDB(config);
       if (startup != null) {
-        tsdb.setStartup(startup);
+        tsdb.setStartupPlugin(startup);
       }
       tsdb.initializePlugins(true);
       if (config.getBoolean("tsd.storage.hbase.prefetch_meta")) {

File: src/tools/CliOptions.java
Patch:
@@ -77,7 +77,7 @@ static String[] parse(final ArgP argp, String[] args) {
       args = argp.parse(args);
     } catch (IllegalArgumentException e) {
       System.err.println("Invalid usage.  " + e.getMessage());
-      return null;
+      System.exit(2);
     }
     honorVerboseFlag(argp);
     return args;

File: src/utils/DateTime.java
Patch:
@@ -75,6 +75,9 @@ public static final long parseDateTimeString(final String datetime,
       final String tz) {
     if (datetime == null || datetime.isEmpty())
       return -1;
+    if (datetime.toLowerCase().equals("now")) {
+      return System.currentTimeMillis();
+    }
     if (datetime.toLowerCase().endsWith("-ago")) {
       long interval = DateTime.parseDuration(
         datetime.substring(0, datetime.length() - 4));

File: src/tools/CliOptions.java
Patch:
@@ -148,6 +148,8 @@ static void overloadConfig(final ArgP argp, final Config config) {
         config.overrideConfig("tsd.network.async_io", entry.getValue());
       } else if (entry.getKey().toLowerCase().equals("--worker-threads")) {
         config.overrideConfig("tsd.network.worker_threads", entry.getValue());
+      } else if (entry.getKey().toLowerCase().equals("--max-connections")) {
+        config.overrideConfig("tsd.core.connections.limit", entry.getValue());
       }
     }
   }

File: src/tools/TSDMain.java
Patch:
@@ -96,6 +96,8 @@ public static void main(String[] args) throws IOException {
     argp.addOption("--backlog", "NUM",
                    "Size of connection attempt queue (default: 3072 or kernel"
                    + " somaxconn.");
+    argp.addOption("--max-connections", "NUM",
+                   "Maximum number of connections to accept");
     argp.addOption("--flush-interval", "MSEC",
                    "Maximum time for which a new data point can be buffered"
                    + " (default: " + DEFAULT_FLUSH_INTERVAL + ").");
@@ -140,7 +142,7 @@ public static void main(String[] args) throws IOException {
     final ServerSocketChannelFactory factory;
     int connectionsLimit = 0;
     try {
-      connectionsLimit = config.getInt("tsd.connections.limit");
+      connectionsLimit = config.getInt("tsd.core.connections.limit");
     } catch (NumberFormatException nfe) {
       usage(argp, "Invalid connections limit", 1);
     }

File: src/tsd/PipelineFactory.java
Patch:
@@ -70,7 +70,7 @@ public final class PipelineFactory implements ChannelPipelineFactory {
    * serializers
    */
   public PipelineFactory(final TSDB tsdb) {
-    this(tsdb, RpcManager.instance(tsdb), 0);
+    this(tsdb, RpcManager.instance(tsdb), tsdb.getConfig().getInt("tsd.core.connections.limit"));
   }
 
   /**

File: src/utils/Config.java
Patch:
@@ -487,6 +487,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.auto_create_metrics", "false");
     default_map.put("tsd.core.auto_create_tagks", "true");
     default_map.put("tsd.core.auto_create_tagvs", "true");
+    default_map.put("tsd.core.connections.limit", "0");
     default_map.put("tsd.core.meta.enable_realtime_ts", "false");
     default_map.put("tsd.core.meta.enable_realtime_uid", "false");
     default_map.put("tsd.core.meta.enable_tsuid_incrementing", "false");
@@ -536,7 +537,6 @@ protected void setDefaults() {
       + "Content-Type, Accept, Origin, User-Agent, DNT, Cache-Control, "
       + "X-Mx-ReqToken, Keep-Alive, X-Requested-With, If-Modified-Since");
     default_map.put("tsd.query.timeout", "0");
-    default_map.put("tsd.connections.limit", "0");
 
     for (Map.Entry<String, String> entry : default_map.entrySet()) {
       if (!properties.containsKey(entry.getKey()))

File: src/utils/Config.java
Patch:
@@ -508,6 +508,8 @@ protected void setDefaults() {
     default_map.put("tsd.search.enable", "false");
     default_map.put("tsd.search.plugin", "");
     default_map.put("tsd.stats.canonical", "false");
+    default_map.put("tsd.startup.enable", "false");
+    default_map.put("tsd.startup.plugin", "");
     default_map.put("tsd.storage.hbase.scanner.maxNumRows", "128");
     default_map.put("tsd.storage.fix_duplicates", "false");
     default_map.put("tsd.storage.flush_interval", "1000");

File: src/utils/PluginLoader.java
Patch:
@@ -104,7 +104,7 @@ public static <T> T loadSpecificPlugin(final String name,
     
     while(it.hasNext()) {
       T plugin = it.next();
-      if (plugin.getClass().getName().equals(name)) {
+      if (plugin.getClass().getName().equals(name) || plugin.getClass().getSuperclass().getName().equals(name)) {
         return plugin;
       }
     }

File: src/utils/Config.java
Patch:
@@ -508,6 +508,8 @@ protected void setDefaults() {
     default_map.put("tsd.search.enable", "false");
     default_map.put("tsd.search.plugin", "");
     default_map.put("tsd.stats.canonical", "false");
+    default_map.put("tsd.startup.enable", "false");
+    default_map.put("tsd.startup.plugin", "");
     default_map.put("tsd.storage.hbase.scanner.maxNumRows", "128");
     default_map.put("tsd.storage.fix_duplicates", "false");
     default_map.put("tsd.storage.flush_interval", "1000");

File: src/utils/PluginLoader.java
Patch:
@@ -104,7 +104,7 @@ public static <T> T loadSpecificPlugin(final String name,
     
     while(it.hasNext()) {
       T plugin = it.next();
-      if (plugin.getClass().getName().equals(name)) {
+      if (plugin.getClass().getName().equals(name) || plugin.getClass().getSuperclass().getName().equals(name)) {
         return plugin;
       }
     }

File: src/query/expression/ExpressionFactory.java
Patch:
@@ -35,6 +35,8 @@ public final class ExpressionFactory {
     available_functions.put("movingAverage", new MovingAverage());
     available_functions.put("highestCurrent", new HighestCurrent());
     available_functions.put("highestMax", new HighestMax());
+    available_functions.put("shift", new TimeShift());
+    available_functions.put("timeShift", new TimeShift());
   }
   
   /** Don't instantiate me! */

File: test/tsd/TestQueryRpc.java
Patch:
@@ -549,6 +549,7 @@ public void gexp() throws Exception {
     
     final HttpQuery query = NettyMocks.getQuery(tsdb, 
         "/api/query/gexp?start=1h-ago&exp=scale(sum:sys.cpu.user,1)");
+    NettyMocks.mockChannelFuture(query);
     rpc.execute(tsdb, query);
     assertEquals(query.response().getStatus(), HttpResponseStatus.OK);
     final String json = 

File: src/core/TSSubQuery.java
Patch:
@@ -288,7 +288,9 @@ public ByteSet getFilterTagKs() {
     }
     final ByteSet tagks = new ByteSet();
     for (final TagVFilter filter : filters) {
-      tagks.add(filter.getTagkBytes());
+      if (filter != null && filter.getTagkBytes() != null) {
+        tagks.add(filter.getTagkBytes());
+      }
     }
     return tagks;
   }

File: src/query/filter/TagVLiteralOrFilter.java
Patch:
@@ -147,7 +147,7 @@ public String getType() {
   /** @return a string describing the filter */
   public static String description() {
     return "Accepts one or more exact values and matches if the series contains "
-        + "any of them. Multiple values can be included and must be seperated "
+        + "any of them. Multiple values can be included and must be separated "
         + "by the | (pipe) character. The filter is case sensitive and will not "
         + "allow characters that TSDB does not allow at write time.";
   }
@@ -196,7 +196,7 @@ public boolean equals(final Object obj) {
     /** @return a string describing the filter */
     public static String description() {
       return "Accepts one or more exact values and matches if the series contains "
-          + "any of them. Multiple values can be included and must be seperated "
+          + "any of them. Multiple values can be included and must be separated "
           + "by the | (pipe) character. The filter is case insensitive and will not "
           + "allow characters that TSDB does not allow at write time.";
     }

File: src/query/filter/TagVNotLiteralOrFilter.java
Patch:
@@ -124,7 +124,7 @@ public int hashCode() {
   public static String description() {
     return "Accepts one or more exact values and matches if the series does NOT "
         + "contain any of them. Multiple values can be included and must be "
-        + "seperated by the | (pipe) character. The filter is case sensitive "
+        + "separated by the | (pipe) character. The filter is case sensitive "
         + "and will not allow characters that TSDB does not allow at write time.";
   }
   
@@ -173,7 +173,7 @@ public boolean equals(final Object obj) {
     public static String description() {
       return "Accepts one or more exact values and matches if the series does NOT "
           + "contain any of them. Multiple values can be included and must be "
-          + "seperated by the | (pipe) character. The filter is case insensitive "
+          + "separated by the | (pipe) character. The filter is case insensitive "
           + "and will not allow characters that TSDB does not allow at write time.";
     }
     

File: src/query/filter/TagVLiteralOrFilter.java
Patch:
@@ -147,7 +147,7 @@ public String getType() {
   /** @return a string describing the filter */
   public static String description() {
     return "Accepts one or more exact values and matches if the series contains "
-        + "any of them. Multiple values can be included and must be seperated "
+        + "any of them. Multiple values can be included and must be separated "
         + "by the | (pipe) character. The filter is case sensitive and will not "
         + "allow characters that TSDB does not allow at write time.";
   }
@@ -196,7 +196,7 @@ public boolean equals(final Object obj) {
     /** @return a string describing the filter */
     public static String description() {
       return "Accepts one or more exact values and matches if the series contains "
-          + "any of them. Multiple values can be included and must be seperated "
+          + "any of them. Multiple values can be included and must be separated "
           + "by the | (pipe) character. The filter is case insensitive and will not "
           + "allow characters that TSDB does not allow at write time.";
     }

File: src/query/filter/TagVNotLiteralOrFilter.java
Patch:
@@ -124,7 +124,7 @@ public int hashCode() {
   public static String description() {
     return "Accepts one or more exact values and matches if the series does NOT "
         + "contain any of them. Multiple values can be included and must be "
-        + "seperated by the | (pipe) character. The filter is case sensitive "
+        + "separated by the | (pipe) character. The filter is case sensitive "
         + "and will not allow characters that TSDB does not allow at write time.";
   }
   
@@ -173,7 +173,7 @@ public boolean equals(final Object obj) {
     public static String description() {
       return "Accepts one or more exact values and matches if the series does NOT "
           + "contain any of them. Multiple values can be included and must be "
-          + "seperated by the | (pipe) character. The filter is case insensitive "
+          + "separated by the | (pipe) character. The filter is case insensitive "
           + "and will not allow characters that TSDB does not allow at write time.";
     }
     

File: src/query/filter/TagVLiteralOrFilter.java
Patch:
@@ -147,7 +147,7 @@ public String getType() {
   /** @return a string describing the filter */
   public static String description() {
     return "Accepts one or more exact values and matches if the series contains "
-        + "any of them. Multiple values can be included and must be seperated "
+        + "any of them. Multiple values can be included and must be separated "
         + "by the | (pipe) character. The filter is case sensitive and will not "
         + "allow characters that TSDB does not allow at write time.";
   }
@@ -196,7 +196,7 @@ public boolean equals(final Object obj) {
     /** @return a string describing the filter */
     public static String description() {
       return "Accepts one or more exact values and matches if the series contains "
-          + "any of them. Multiple values can be included and must be seperated "
+          + "any of them. Multiple values can be included and must be separated "
           + "by the | (pipe) character. The filter is case insensitive and will not "
           + "allow characters that TSDB does not allow at write time.";
     }

File: src/query/filter/TagVNotLiteralOrFilter.java
Patch:
@@ -124,7 +124,7 @@ public int hashCode() {
   public static String description() {
     return "Accepts one or more exact values and matches if the series does NOT "
         + "contain any of them. Multiple values can be included and must be "
-        + "seperated by the | (pipe) character. The filter is case sensitive "
+        + "separated by the | (pipe) character. The filter is case sensitive "
         + "and will not allow characters that TSDB does not allow at write time.";
   }
   
@@ -173,7 +173,7 @@ public boolean equals(final Object obj) {
     public static String description() {
       return "Accepts one or more exact values and matches if the series does NOT "
           + "contain any of them. Multiple values can be included and must be "
-          + "seperated by the | (pipe) character. The filter is case insensitive "
+          + "separated by the | (pipe) character. The filter is case insensitive "
           + "and will not allow characters that TSDB does not allow at write time.";
     }
     

File: test/core/TestInternal.java
Patch:
@@ -822,9 +822,10 @@ public void getMaxUnsignedValueOnBytes() throws Exception {
     assertEquals(1099511627775L, Internal.getMaxUnsignedValueOnBytes(5));
     assertEquals(281474976710655L, Internal.getMaxUnsignedValueOnBytes(6));
     assertEquals(72057594037927935L, Internal.getMaxUnsignedValueOnBytes(7));
+    assertEquals(Long.MAX_VALUE, Internal.getMaxUnsignedValueOnBytes(8));
     
     try {
-      Internal.getMaxUnsignedValueOnBytes(8);
+      Internal.getMaxUnsignedValueOnBytes(9);
       fail("Expected an IllegalArgumentException");
     } catch (IllegalArgumentException e) {
       assertNotNull(e);

File: test/core/TestInternal.java
Patch:
@@ -822,9 +822,10 @@ public void getMaxUnsignedValueOnBytes() throws Exception {
     assertEquals(1099511627775L, Internal.getMaxUnsignedValueOnBytes(5));
     assertEquals(281474976710655L, Internal.getMaxUnsignedValueOnBytes(6));
     assertEquals(72057594037927935L, Internal.getMaxUnsignedValueOnBytes(7));
+    assertEquals(Long.MAX_VALUE, Internal.getMaxUnsignedValueOnBytes(8));
     
     try {
-      Internal.getMaxUnsignedValueOnBytes(8);
+      Internal.getMaxUnsignedValueOnBytes(9);
       fail("Expected an IllegalArgumentException");
     } catch (IllegalArgumentException e) {
       assertNotNull(e);

File: src/utils/Config.java
Patch:
@@ -492,7 +492,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.uid.random_metrics", "false");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.query.skip_unresolved_tagvs", "false");
-    default_map.put("tsd.query.allow_simultaneous_duplicates", "false");
+    default_map.put("tsd.query.allow_simultaneous_duplicates", "true");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: src/utils/Config.java
Patch:
@@ -500,7 +500,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.uid.random_metrics", "false");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.query.skip_unresolved_tagvs", "false");
-    default_map.put("tsd.query.allow_simultaneous_duplicates", "false");
+    default_map.put("tsd.query.allow_simultaneous_duplicates", "true");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: src/core/RowKey.java
Patch:
@@ -98,6 +98,7 @@ public static byte[] rowKeyFromTSUID(final TSDB tsdb, final byte[] tsuid,
     System.arraycopy(tsuid, tsdb.metrics.width(), row, 
         Const.SALT_WIDTH() + tsdb.metrics.width() + Const.TIMESTAMP_BYTES, 
         tsuid.length - tsdb.metrics.width());
+    RowKey.prefixKeyWithSalt(row);
     return row;
   }
 

File: src/core/RowKey.java
Patch:
@@ -98,6 +98,7 @@ public static byte[] rowKeyFromTSUID(final TSDB tsdb, final byte[] tsuid,
     System.arraycopy(tsuid, tsdb.metrics.width(), row, 
         Const.SALT_WIDTH() + tsdb.metrics.width() + Const.TIMESTAMP_BYTES, 
         tsuid.length - tsdb.metrics.width());
+    RowKey.prefixKeyWithSalt(row);
     return row;
   }
 

File: src/tools/UidManager.java
Patch:
@@ -127,6 +127,7 @@ public static void main(String[] args) throws Exception {
       rc = runCommand(tsdb, table, idwidth, ignorecase, args);
     } finally {
       try {
+        LOG.info("Shutting down TSD....");
         tsdb.getClient().shutdown().joinUninterruptibly();
         LOG.info("Gracefully shutdown the TSD");
       } catch (Exception e) {
@@ -1026,7 +1027,7 @@ private static int metaSync(final TSDB tsdb) throws Exception {
       thread.join();
       LOG.info("Thread [" + thread + "] Finished");
     }
-    
+    LOG.info("All metasync threads have completed");
     // make sure buffered data is flushed to storage before exiting
     tsdb.flush().joinUninterruptibly();
     

File: src/tools/UidManager.java
Patch:
@@ -125,6 +125,7 @@ public static void main(String[] args) throws Exception {
       rc = runCommand(tsdb, table, idwidth, ignorecase, args);
     } finally {
       try {
+        LOG.info("Shutting down TSD....");
         tsdb.getClient().shutdown().joinUninterruptibly();
         LOG.info("Gracefully shutdown the TSD");
       } catch (Exception e) {
@@ -990,7 +991,7 @@ private static int metaSync(final TSDB tsdb) throws Exception {
       threads[i].join();
       LOG.info("[" + i + "] Finished");
     }
-    
+    LOG.info("All metasync threads have completed");
     // make sure buffered data is flushed to storage before exiting
     tsdb.flush().joinUninterruptibly();
     

File: src/tools/UidManager.java
Patch:
@@ -127,6 +127,7 @@ public static void main(String[] args) throws Exception {
       rc = runCommand(tsdb, table, idwidth, ignorecase, args);
     } finally {
       try {
+        LOG.info("Shutting down TSD....");
         tsdb.getClient().shutdown().joinUninterruptibly();
         LOG.info("Gracefully shutdown the TSD");
       } catch (Exception e) {
@@ -1026,7 +1027,7 @@ private static int metaSync(final TSDB tsdb) throws Exception {
       thread.join();
       LOG.info("Thread [" + thread + "] Finished");
     }
-    
+    LOG.info("All metasync threads have completed");
     // make sure buffered data is flushed to storage before exiting
     tsdb.flush().joinUninterruptibly();
     

File: src/tsd/GraphHandler.java
Patch:
@@ -851,7 +851,7 @@ private static void printMetricHeader(final PrintWriter writer, final String met
    * @throws IllegalArgumentException if the metric or tags were malformed.
    */
   private static Query[] parseQuery(final TSDB tsdb, final HttpQuery query) {
-    final TSQuery q = QueryRpc.parseQuery(tsdb, query);
+    final TSQuery q = QueryRpc.parseQuery(tsdb, query, null);
     q.validateAndSetQuery();
     return q.buildQueries(tsdb);
   }

File: src/tsd/QueryRpc.java
Patch:
@@ -129,7 +129,7 @@ private void handleQuery(final TSDB tsdb, final HttpQuery query,
       expressions = null;
     } else {
       expressions = new ArrayList<ExpressionTree>();
-      data_query = parseQuery(tsdb, query);
+      data_query = parseQuery(tsdb, query, expressions);
     }
     
     if (query.getAPIMethod() == HttpMethod.DELETE &&
@@ -477,7 +477,7 @@ public String toString() {
    * @return A TSQuery if parsing was successful
    * @throws BadRequestException if parsing was unsuccessful
    */
-  public static TSQuery parseQuery(final TSDB tsdb, final HttpQuery query) {
+  public static TSQuery parseQuery(final TSDB tsdb, final HttpQuery query,
       final List<ExpressionTree> expressions) {
     final TSQuery data_query = new TSQuery();
     

File: src/core/TSSubQuery.java
Patch:
@@ -274,7 +274,8 @@ public List<TagVFilter> getFilters() {
     if (filters == null) {
       filters = new ArrayList<TagVFilter>();
     }
-    return filters;
+    // send a copy so ordering doesn't mess up the hash code
+    return new ArrayList<TagVFilter>(filters);
   }
   
   /** @return the unique set of tagks from the filters. May be null if no filters

File: src/core/TSSubQuery.java
Patch:
@@ -270,7 +270,8 @@ public List<TagVFilter> getFilters() {
     if (filters == null) {
       filters = new ArrayList<TagVFilter>();
     }
-    return filters;
+    // send a copy so ordering doesn't mess up the hash code
+    return new ArrayList<TagVFilter>(filters);
   }
   
   /** @param aggregator the name of an aggregation function */

File: src/tools/Fsck.java
Patch:
@@ -117,11 +117,11 @@ final class Fsck {
   final AtomicLong vle_fixed = new AtomicLong();
   
   /** Length of the metric + timestamp for key validation */
-  private static int key_prefix_length = Const.SALT_WIDTH() + 
+  private int key_prefix_length = Const.SALT_WIDTH() +
       TSDB.metrics_width() + Const.TIMESTAMP_BYTES;
   
   /** Length of a tagk + tagv pair for key validation */
-  private static int key_tags_length = TSDB.tagk_width() + TSDB.tagv_width();
+  private int key_tags_length = TSDB.tagk_width() + TSDB.tagv_width();
   
   /** How often to report progress */
   private static long report_rows = 10000;

File: src/tools/UidManager.java
Patch:
@@ -361,7 +361,7 @@ private static int assign(final TSDB tsdb,
                             final short idwidth,
                             final String[] args) {
     boolean randomize = false;
-    if (UniqueIdType.valueOf(args[1]) == UniqueIdType.METRIC) {
+    if (UniqueId.stringToUniqueIdType(args[1]) == UniqueIdType.METRIC) {
       randomize = tsdb.getConfig().getBoolean("tsd.core.uid.random_metrics");
     }
     final UniqueId uid = new UniqueId(tsdb.getClient(), table, args[1], 

File: src/tools/UidManager.java
Patch:
@@ -361,7 +361,7 @@ private static int assign(final TSDB tsdb,
                             final short idwidth,
                             final String[] args) {
     boolean randomize = false;
-    if (UniqueIdType.valueOf(args[1]) == UniqueIdType.METRIC) {
+    if (UniqueId.stringToUniqueIdType(args[1]) == UniqueIdType.METRIC) {
       randomize = tsdb.getConfig().getBoolean("tsd.core.uid.random_metrics");
     }
     final UniqueId uid = new UniqueId(tsdb.getClient(), table, args[1], 

File: src/meta/TSMeta.java
Patch:
@@ -525,7 +525,7 @@ final class TSMetaCB implements Callback<Deferred<Long>, Long> {
       @Override
       public Deferred<Long> call(final Long incremented_value) 
         throws Exception {
-LOG.info("Value: " + incremented_value);
+        LOG.debug("Value: " + incremented_value);
         if (incremented_value > 1) {
           // TODO - maybe update the search index every X number of increments?
           // Otherwise the search engine would only get last_updated/count 

File: src/tools/Fsck.java
Patch:
@@ -114,11 +114,11 @@ final class Fsck {
   final AtomicLong vle_fixed = new AtomicLong();
   
   /** Length of the metric + timestamp for key validation */
-  private static int key_prefix_length = Const.SALT_WIDTH() + 
+  private int key_prefix_length = Const.SALT_WIDTH() +
       TSDB.metrics_width() + Const.TIMESTAMP_BYTES;
   
   /** Length of a tagk + tagv pair for key validation */
-  private static int key_tags_length = TSDB.tagk_width() + TSDB.tagv_width();
+  private int key_tags_length = TSDB.tagk_width() + TSDB.tagv_width();
   
   /** How often to report progress */
   private static long report_rows = 10000;

File: test/tools/TestDumpSeries.java
Patch:
@@ -31,8 +31,8 @@
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.utils.Config;
 
-import org.apache.zookeeper.proto.DeleteRequest;
 import org.hbase.async.Bytes;
+import org.hbase.async.DeleteRequest;
 import org.hbase.async.GetRequest;
 import org.hbase.async.HBaseClient;
 import org.hbase.async.KeyValue;

File: test/tools/TestTextImporter.java
Patch:
@@ -37,8 +37,8 @@
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.utils.Config;
 
-import org.apache.zookeeper.proto.DeleteRequest;
 import org.hbase.async.Bytes;
+import org.hbase.async.DeleteRequest;
 import org.hbase.async.GetRequest;
 import org.hbase.async.HBaseClient;
 import org.hbase.async.KeyValue;

File: test/tools/TestUID.java
Patch:
@@ -23,8 +23,8 @@
 import net.opentsdb.storage.MockBase;
 import net.opentsdb.utils.Config;
 
-import org.apache.zookeeper.proto.DeleteRequest;
 import org.hbase.async.Bytes;
+import org.hbase.async.DeleteRequest;
 import org.hbase.async.HBaseClient;
 import org.hbase.async.KeyValue;
 import org.hbase.async.Scanner;

File: src/core/Query.java
Patch:
@@ -105,7 +105,7 @@ void setTimeSeries(String metric, Map<String, String> tags,
    * to run asynchronously and use different scanners, we can allow different 
    * TSUIDs.
    * <b>Note:</b> This method will not check to determine if the TSUIDs are 
-   * valid, since that wastes time and we *assume* that the user provides TUSIDs
+   * valid, since that wastes time and we *assume* that the user provides TSUIDs
    * that are up to date.
    * @param tsuids A list of one or more TSUIDs to scan for
    * @param function The aggregation function to use on results
@@ -125,7 +125,7 @@ public void setTimeSeries(final List<String> tsuids,
    * to run asynchronously and use different scanners, we can allow different 
    * TSUIDs.
    * <b>Note:</b> This method will not check to determine if the TSUIDs are 
-   * valid, since that wastes time and we *assume* that the user provides TUSIDs
+   * valid, since that wastes time and we *assume* that the user provides TSUIDs
    * that are up to date.
    * @param tsuids A list of one or more TSUIDs to scan for
    * @param function The aggregation function to use on results

File: src/tsd/client/QueryUi.java
Patch:
@@ -743,7 +743,7 @@ private static QueryString getQueryString(final String qs) {
   }
 
   private void refreshFromQueryString() {
-    final QueryString qs = getQueryString(History.getToken());
+    final QueryString qs = getQueryString(URL.decode(History.getToken()));
 
     maybeSetTextbox(qs, "start", start_datebox.getTextBox());
     maybeSetTextbox(qs, "end", end_datebox.getTextBox());
@@ -909,7 +909,7 @@ public void got(final JSONValue json) {
           if (autoreload.getValue()) {
             history += "&autoreload=" + autoreoload_interval.getText();
           }
-          if (!history.equals(History.getToken())) {
+          if (!history.equals(URL.decode(History.getToken()))) {
             History.newItem(history, false);
           }
 

File: src/core/IncomingDataPoint.java
Patch:
@@ -94,10 +94,10 @@ public String toString() {
     final StringBuilder buf = new StringBuilder();
     buf.append("metric=").append(this.metric);
     buf.append(" ts=").append(this.timestamp);
-    buf.append(" value=").append(this.value).append(" ");
+    buf.append(" value=").append(this.value);
     if (this.tags != null) {
       for (Map.Entry<String, String> entry : this.tags.entrySet()) {
-        buf.append(entry.getKey()).append("=").append(entry.getValue());
+        buf.append(" ").append(entry.getKey()).append("=").append(entry.getValue());
       }
     }
     return buf.toString();

File: src/core/IncomingDataPoint.java
Patch:
@@ -94,10 +94,10 @@ public String toString() {
     final StringBuilder buf = new StringBuilder();
     buf.append("metric=").append(this.metric);
     buf.append(" ts=").append(this.timestamp);
-    buf.append(" value=").append(this.value).append(" ");
+    buf.append(" value=").append(this.value);
     if (this.tags != null) {
       for (Map.Entry<String, String> entry : this.tags.entrySet()) {
-        buf.append(entry.getKey()).append("=").append(entry.getValue());
+        buf.append(" ").append(entry.getKey()).append("=").append(entry.getValue());
       }
     }
     return buf.toString();

File: src/tsd/UniqueIdRpc.java
Patch:
@@ -573,8 +573,9 @@ private String getTSUIDForMetric(final String query_string, TSDB tsdb) {
     try {
     buf.write(tsdb.getUID(UniqueIdType.METRIC, metric));
       for (Entry<String, String> e: sortedTags.entrySet()) {
-        buf.write(tsdb.getUID(UniqueIdType.TAGK, e.getKey()), 0, 3);
-        buf.write(tsdb.getUID(UniqueIdType.TAGV, e.getValue()), 0, 3);
+        // Fix for net.opentsdb.tsd.TestUniqueIdRpc.tsuidPostByM()
+        buf.write(tsdb.getUID(UniqueIdType.TAGK, e.getKey()), 0, TSDB.tagk_width());
+        buf.write(tsdb.getUID(UniqueIdType.TAGV, e.getValue()), 0, TSDB.tagv_width());
       }
     } catch (IOException e) {
       throw new BadRequestException(e);

File: src/tsd/UniqueIdRpc.java
Patch:
@@ -573,8 +573,9 @@ private String getTSUIDForMetric(final String query_string, TSDB tsdb) {
     try {
     buf.write(tsdb.getUID(UniqueIdType.METRIC, metric));
       for (Entry<String, String> e: sortedTags.entrySet()) {
-        buf.write(tsdb.getUID(UniqueIdType.TAGK, e.getKey()), 0, 3);
-        buf.write(tsdb.getUID(UniqueIdType.TAGV, e.getValue()), 0, 3);
+        // Fix for net.opentsdb.tsd.TestUniqueIdRpc.tsuidPostByM()
+        buf.write(tsdb.getUID(UniqueIdType.TAGK, e.getKey()), 0, TSDB.tagk_width());
+        buf.write(tsdb.getUID(UniqueIdType.TAGV, e.getValue()), 0, TSDB.tagv_width());
       }
     } catch (IOException e) {
       throw new BadRequestException(e);

File: src/core/Query.java
Patch:
@@ -119,7 +119,7 @@ void setTimeSeries(String metric, Map<String, String> tags,
    * to run asynchronously and use different scanners, we can allow different 
    * TSUIDs.
    * <b>Note:</b> This method will not check to determine if the TSUIDs are 
-   * valid, since that wastes time and we *assume* that the user provides TUSIDs
+   * valid, since that wastes time and we *assume* that the user provides TSUIDs
    * that are up to date.
    * @param tsuids A list of one or more TSUIDs to scan for
    * @param function The aggregation function to use on results
@@ -139,7 +139,7 @@ public void setTimeSeries(final List<String> tsuids,
    * to run asynchronously and use different scanners, we can allow different 
    * TSUIDs.
    * <b>Note:</b> This method will not check to determine if the TSUIDs are 
-   * valid, since that wastes time and we *assume* that the user provides TUSIDs
+   * valid, since that wastes time and we *assume* that the user provides TSUIDs
    * that are up to date.
    * @param tsuids A list of one or more TSUIDs to scan for
    * @param function The aggregation function to use on results

File: src/core/Query.java
Patch:
@@ -119,7 +119,7 @@ void setTimeSeries(String metric, Map<String, String> tags,
    * to run asynchronously and use different scanners, we can allow different 
    * TSUIDs.
    * <b>Note:</b> This method will not check to determine if the TSUIDs are 
-   * valid, since that wastes time and we *assume* that the user provides TUSIDs
+   * valid, since that wastes time and we *assume* that the user provides TSUIDs
    * that are up to date.
    * @param tsuids A list of one or more TSUIDs to scan for
    * @param function The aggregation function to use on results
@@ -139,7 +139,7 @@ public void setTimeSeries(final List<String> tsuids,
    * to run asynchronously and use different scanners, we can allow different 
    * TSUIDs.
    * <b>Note:</b> This method will not check to determine if the TSUIDs are 
-   * valid, since that wastes time and we *assume* that the user provides TUSIDs
+   * valid, since that wastes time and we *assume* that the user provides TSUIDs
    * that are up to date.
    * @param tsuids A list of one or more TSUIDs to scan for
    * @param function The aggregation function to use on results

File: src/core/BatchedDataPoints.java
Patch:
@@ -304,7 +304,7 @@ public Deferred<String> metricNameAsync() {
     if (row_key == null) {
       throw new IllegalStateException("Instance was not properly constructed!");
     }
-    final byte[] id = Arrays.copyOfRange(row_key, 0, 
+    final byte[] id = Arrays.copyOfRange(row_key, Const.SALT_WIDTH(),
         tsdb.metrics.width() + Const.SALT_WIDTH());
     return tsdb.metrics.getNameAsync(id);
   }

File: src/search/TimeSeriesLookup.java
Patch:
@@ -403,7 +403,7 @@ private Scanner getScanner(final int salt) {
         key = metric_uid;
       } else {
         key = new byte[Const.SALT_WIDTH() + TSDB.metrics_width()];
-        key[0] = (byte)salt;
+        System.arraycopy(RowKey.getSaltBytes(salt), 0, key, 0, Const.SALT_WIDTH());
         System.arraycopy(metric_uid, 0, key, Const.SALT_WIDTH(), metric_uid.length);
       }
       scanner.setStartKey(key);
@@ -416,7 +416,7 @@ private Scanner getScanner(final int salt) {
           key = UniqueId.longToUID(uid, TSDB.metrics_width());
         } else {
           key = new byte[Const.SALT_WIDTH() + TSDB.metrics_width()];
-          key[0] = (byte)salt;
+          System.arraycopy(RowKey.getSaltBytes(salt), 0, key, 0, Const.SALT_WIDTH());
           System.arraycopy(UniqueId.longToUID(uid, TSDB.metrics_width()), 0, 
               key, Const.SALT_WIDTH(), metric_uid.length);
         }

File: src/tools/MetaSync.java
Patch:
@@ -392,7 +392,7 @@ public Object call(ArrayList<ArrayList<KeyValue>> rows)
           
           // now process the UID metric meta data
           final byte[] metric_uid_bytes = 
-            Arrays.copyOfRange(tsuid, 0, Const.SALT_WIDTH() + TSDB.metrics_width()); 
+            Arrays.copyOfRange(tsuid, 0, TSDB.metrics_width());
           final String metric_uid = UniqueId.uidToString(metric_uid_bytes);
           Long last_get = metric_uids.get(metric_uid);
           

File: src/core/BatchedDataPoints.java
Patch:
@@ -304,7 +304,7 @@ public Deferred<String> metricNameAsync() {
     if (row_key == null) {
       throw new IllegalStateException("Instance was not properly constructed!");
     }
-    final byte[] id = Arrays.copyOfRange(row_key, 0, 
+    final byte[] id = Arrays.copyOfRange(row_key, Const.SALT_WIDTH(),
         tsdb.metrics.width() + Const.SALT_WIDTH());
     return tsdb.metrics.getNameAsync(id);
   }

File: src/search/TimeSeriesLookup.java
Patch:
@@ -403,7 +403,7 @@ private Scanner getScanner(final int salt) {
         key = metric_uid;
       } else {
         key = new byte[Const.SALT_WIDTH() + TSDB.metrics_width()];
-        key[0] = (byte)salt;
+        System.arraycopy(RowKey.getSaltBytes(salt), 0, key, 0, Const.SALT_WIDTH());
         System.arraycopy(metric_uid, 0, key, Const.SALT_WIDTH(), metric_uid.length);
       }
       scanner.setStartKey(key);
@@ -416,7 +416,7 @@ private Scanner getScanner(final int salt) {
           key = UniqueId.longToUID(uid, TSDB.metrics_width());
         } else {
           key = new byte[Const.SALT_WIDTH() + TSDB.metrics_width()];
-          key[0] = (byte)salt;
+          System.arraycopy(RowKey.getSaltBytes(salt), 0, key, 0, Const.SALT_WIDTH());
           System.arraycopy(UniqueId.longToUID(uid, TSDB.metrics_width()), 0, 
               key, Const.SALT_WIDTH(), metric_uid.length);
         }

File: src/tools/MetaSync.java
Patch:
@@ -392,7 +392,7 @@ public Object call(ArrayList<ArrayList<KeyValue>> rows)
           
           // now process the UID metric meta data
           final byte[] metric_uid_bytes = 
-            Arrays.copyOfRange(tsuid, 0, Const.SALT_WIDTH() + TSDB.metrics_width()); 
+            Arrays.copyOfRange(tsuid, 0, TSDB.metrics_width());
           final String metric_uid = UniqueId.uidToString(metric_uid_bytes);
           Long last_get = metric_uids.get(metric_uid);
           

File: src/tsd/client/QueryUi.java
Patch:
@@ -780,7 +780,7 @@ private static QueryString getQueryString(final String qs) {
   }
 
   private void refreshFromQueryString() {
-    final QueryString qs = getQueryString(History.getToken());
+    final QueryString qs = getQueryString(URL.decode(History.getToken()));
 
     maybeSetTextbox(qs, "start", start_datebox.getTextBox());
     maybeSetTextbox(qs, "end", end_datebox.getTextBox());
@@ -961,7 +961,7 @@ public void got(final JSONValue json) {
           if (autoreload.getValue()) {
             history += "&autoreload=" + autoreoload_interval.getText();
           }
-          if (!history.equals(History.getToken())) {
+          if (!history.equals(URL.decode(History.getToken()))) {
             History.newItem(history, false);
           }
 

File: src/tsd/client/QueryUi.java
Patch:
@@ -780,7 +780,7 @@ private static QueryString getQueryString(final String qs) {
   }
 
   private void refreshFromQueryString() {
-    final QueryString qs = getQueryString(History.getToken());
+    final QueryString qs = getQueryString(URL.decode(History.getToken()));
 
     maybeSetTextbox(qs, "start", start_datebox.getTextBox());
     maybeSetTextbox(qs, "end", end_datebox.getTextBox());
@@ -961,7 +961,7 @@ public void got(final JSONValue json) {
           if (autoreload.getValue()) {
             history += "&autoreload=" + autoreoload_interval.getText();
           }
-          if (!history.equals(History.getToken())) {
+          if (!history.equals(URL.decode(History.getToken()))) {
             History.newItem(history, false);
           }
 

File: src/meta/TSMeta.java
Patch:
@@ -525,7 +525,6 @@ final class TSMetaCB implements Callback<Deferred<Long>, Long> {
       @Override
       public Deferred<Long> call(final Long incremented_value) 
         throws Exception {
-LOG.info("Value: " + incremented_value);
         if (incremented_value > 1) {
           // TODO - maybe update the search index every X number of increments?
           // Otherwise the search engine would only get last_updated/count 

File: src/meta/TSMeta.java
Patch:
@@ -525,7 +525,6 @@ final class TSMetaCB implements Callback<Deferred<Long>, Long> {
       @Override
       public Deferred<Long> call(final Long incremented_value) 
         throws Exception {
-LOG.info("Value: " + incremented_value);
         if (incremented_value > 1) {
           // TODO - maybe update the search index every X number of increments?
           // Otherwise the search engine would only get last_updated/count 

File: test/tools/TestDumpSeries.java
Patch:
@@ -30,8 +30,8 @@
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.utils.Config;
 
-import org.apache.zookeeper.proto.DeleteRequest;
 import org.hbase.async.Bytes;
+import org.hbase.async.DeleteRequest;
 import org.hbase.async.GetRequest;
 import org.hbase.async.HBaseClient;
 import org.hbase.async.KeyValue;

File: test/tools/TestTextImporter.java
Patch:
@@ -37,8 +37,8 @@
 import net.opentsdb.uid.UniqueId;
 import net.opentsdb.utils.Config;
 
-import org.apache.zookeeper.proto.DeleteRequest;
 import org.hbase.async.Bytes;
+import org.hbase.async.DeleteRequest;
 import org.hbase.async.GetRequest;
 import org.hbase.async.HBaseClient;
 import org.hbase.async.KeyValue;

File: test/tools/TestUID.java
Patch:
@@ -23,8 +23,8 @@
 import net.opentsdb.storage.MockBase;
 import net.opentsdb.utils.Config;
 
-import org.apache.zookeeper.proto.DeleteRequest;
 import org.hbase.async.Bytes;
+import org.hbase.async.DeleteRequest;
 import org.hbase.async.HBaseClient;
 import org.hbase.async.KeyValue;
 import org.hbase.async.Scanner;

File: src/core/IncomingDataPoints.java
Patch:
@@ -100,9 +100,9 @@ static void checkMetricAndTags(final String metric,
     if (tags.size() <= 0) {
       throw new IllegalArgumentException("Need at least one tag (metric="
           + metric + ", tags=" + tags + ')');
-    } else if (tags.size() > Const.MAX_NUM_TAGS) {
+    } else if (tags.size() > Const.MAX_NUM_TAGS()) {
       throw new IllegalArgumentException("Too many tags: " + tags.size()
-          + " maximum allowed: " + Const.MAX_NUM_TAGS + ", tags: " + tags);
+          + " maximum allowed: " + Const.MAX_NUM_TAGS() + ", tags: " + tags);
     }
 
     Tags.validateString("metric name", metric);

File: src/core/TSDB.java
Patch:
@@ -164,6 +164,9 @@ public TSDB(final HBaseClient client, final Config config) {
     if (config.hasProperty("tsd.storage.uid.width.tagv")) {
       TAG_VALUE_WIDTH = config.getShort("tsd.storage.uid.width.tagv");
     }
+    if (config.hasProperty("tsd.storage.max_tags")) {
+      Const.setMaxNumTags(config.getShort("tsd.storage.max_tags"));
+    }
     if (config.hasProperty("tsd.storage.salt.buckets")) {
       Const.setSaltBuckets(config.getInt("tsd.storage.salt.buckets"));
     }

File: test/core/TestIncomingDataPoints.java
Patch:
@@ -37,6 +37,7 @@ public void metricNameAsyncSalted() throws Exception {
     PowerMockito.mockStatic(Const.class);
     PowerMockito.when(Const.SALT_WIDTH()).thenReturn(1);
     PowerMockito.when(Const.SALT_BUCKETS()).thenReturn(2);
+    PowerMockito.when(Const.MAX_NUM_TAGS()).thenReturn((short) 8);
     
     final IncomingDataPoints dps = new IncomingDataPoints(tsdb);
     dps.setSeries(METRIC_STRING, tags);

File: test/core/TestTsdbQueryAggregatorsSalted.java
Patch:
@@ -30,6 +30,7 @@ public void beforeLocal() throws Exception {
     PowerMockito.mockStatic(Const.class);
     PowerMockito.when(Const.SALT_WIDTH()).thenReturn(1);
     PowerMockito.when(Const.SALT_BUCKETS()).thenReturn(2);
+    PowerMockito.when(Const.MAX_NUM_TAGS()).thenReturn((short) 8);
     
     query = new TsdbQuery(tsdb);
   }

File: test/core/TestTsdbQueryDownsampleSalted.java
Patch:
@@ -30,6 +30,7 @@ public void beforeLocal() throws Exception {
     PowerMockito.mockStatic(Const.class);
     PowerMockito.when(Const.SALT_WIDTH()).thenReturn(1);
     PowerMockito.when(Const.SALT_BUCKETS()).thenReturn(2);
+    PowerMockito.when(Const.MAX_NUM_TAGS()).thenReturn((short) 8);
     
     query = new TsdbQuery(tsdb);
   }

File: test/core/TestTsdbQuerySalted.java
Patch:
@@ -29,6 +29,7 @@ public void beforeLocal() throws Exception {
     PowerMockito.mockStatic(Const.class);
     PowerMockito.when(Const.SALT_WIDTH()).thenReturn(1);
     PowerMockito.when(Const.SALT_BUCKETS()).thenReturn(2);
+    PowerMockito.when(Const.MAX_NUM_TAGS()).thenReturn((short) 8);
     
     query = new TsdbQuery(tsdb);
   }

File: test/core/TestTsdbQuerySaltedAppend.java
Patch:
@@ -24,6 +24,7 @@ public void beforeLocal() {
     PowerMockito.mockStatic(Const.class);
     PowerMockito.when(Const.SALT_WIDTH()).thenReturn(1);
     PowerMockito.when(Const.SALT_BUCKETS()).thenReturn(2);
+    PowerMockito.when(Const.MAX_NUM_TAGS()).thenReturn((short) 8);
     query = new TsdbQuery(tsdb);
   }
 }

File: test/tools/TestFsckSalted.java
Patch:
@@ -15,6 +15,7 @@ public void beforeLocal() throws Exception {
     PowerMockito.mockStatic(Const.class);
     PowerMockito.when(Const.SALT_BUCKETS()).thenReturn(2);
     PowerMockito.when(Const.SALT_WIDTH()).thenReturn(1);
+    PowerMockito.when(Const.MAX_NUM_TAGS()).thenReturn((short) 8);
     
     GLOBAL_ROW = new byte[] {0, 0, 0, 0, 0x52, (byte)0xC3, 0x5A, (byte)0x80};
     ROW = MockBase.stringToBytes("0000000150E22700000001000001");

File: src/utils/Config.java
Patch:
@@ -506,6 +506,7 @@ protected void setDefaults() {
     default_map.put("tsd.storage.hbase.meta_table", "tsdb-meta");
     default_map.put("tsd.storage.hbase.zk_quorum", "localhost");
     default_map.put("tsd.storage.hbase.zk_basedir", "/hbase");
+    default_map.put("tsd.storage.hbase.prefetch_meta", "false");
     default_map.put("tsd.storage.enable_appends", "false");
     default_map.put("tsd.storage.repair_appends", "false");
     default_map.put("tsd.storage.enable_compaction", "true");

File: src/utils/Config.java
Patch:
@@ -492,6 +492,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.uid.random_metrics", "false");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.query.skip_unresolved_tagvs", "false");
+    default_map.put("tsd.query.allow_simultaneous_duplicates", "false");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: src/tsd/UniqueIdRpc.java
Patch:
@@ -291,11 +291,10 @@ private void handleTSMeta(final TSDB tsdb, final HttpQuery query) {
         } catch (IllegalArgumentException e) {
           throw new BadRequestException(e);
         }
-        final TSUIDQuery tsuid_query = new TSUIDQuery(tsdb);
+        final TSUIDQuery tsuid_query = new TSUIDQuery(tsdb, metric, tags);
         try {
-          tsuid_query.setQuery(metric, tags);
           final List<TSMeta> tsmetas = tsuid_query.getTSMetas()
-          .joinUninterruptibly();
+              .joinUninterruptibly();
           query.sendReply(query.serializer().formatTSMetaListV1(tsmetas));
         } catch (NoSuchUniqueName e) {
           throw new BadRequestException(HttpResponseStatus.NOT_FOUND, 

File: src/tsd/UniqueIdRpc.java
Patch:
@@ -291,9 +291,8 @@ private void handleTSMeta(final TSDB tsdb, final HttpQuery query) {
         } catch (IllegalArgumentException e) {
           throw new BadRequestException(e);
         }
-        final TSUIDQuery tsuid_query = new TSUIDQuery(tsdb);
+        final TSUIDQuery tsuid_query = new TSUIDQuery(tsdb, metric, tags);
         try {
-          tsuid_query.setQuery(metric, tags);
           final List<TSMeta> tsmetas = tsuid_query.getTSMetas()
           .joinUninterruptibly();
           query.sendReply(query.serializer().formatTSMetaListV1(tsmetas));

File: test/tsd/TestQueryRpc.java
Patch:
@@ -20,16 +20,14 @@
 import org.powermock.api.mockito.PowerMockito;
 import org.mockito.Matchers;
 import java.lang.reflect.Method;
-import java.util.Collection;
-import java.util.Collections;
 import java.util.ArrayList;
 import net.opentsdb.core.DataPoints;
 import net.opentsdb.core.Query;
 import net.opentsdb.core.TSDB;
 import net.opentsdb.core.TSQuery;
 import net.opentsdb.core.TSSubQuery;
 import net.opentsdb.utils.Config;
-import org.hbase.async.HBaseClient;
+
 import org.jboss.netty.handler.codec.http.HttpResponseStatus;
 import org.junit.Before;
 import org.junit.Test;
@@ -38,6 +36,7 @@
 import org.powermock.modules.junit4.PowerMockRunner;
 import net.opentsdb.uid.NoSuchUniqueName;
 import com.stumbleupon.async.Deferred;
+
 /**
  * Unit tests for the Query RPC class that handles parsing user queries for
  * timeseries data and returning that data
@@ -322,4 +321,5 @@ public void postQueryNoMetricBadRequest() throws Exception {
   }
 
   //TODO(cl) add unit tests for the rate options parsing
+
 }
\ No newline at end of file

File: src/utils/Config.java
Patch:
@@ -491,6 +491,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.storage_exception_handler.enable", "false");
     default_map.put("tsd.core.uid.random_metrics", "false");
     default_map.put("tsd.query.filter.expansion_limit", "4096");
+    default_map.put("tsd.query.skip_unresolved_tagvs", "false");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: src/utils/Config.java
Patch:
@@ -490,6 +490,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.preload_uid_cache.max_entries", "300000");
     default_map.put("tsd.core.storage_exception_handler.enable", "false");
     default_map.put("tsd.core.uid.random_metrics", "false");
+    default_map.put("tsd.query.filter.expansion_limit", "4096");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: test/core/TestTSDB.java
Patch:
@@ -256,7 +256,7 @@ public void getUIDTagvNSU() {
     tsdb.getUID(UniqueIdType.TAGV, NSUN_TAGV);
   }
   
-  @Test (expected = NullPointerException.class)
+  @Test (expected = RuntimeException.class)
   public void getUIDNullType() {
     tsdb.getUID(null, METRIC_STRING);
   }

File: test/query/filter/TestTagVFilter.java
Patch:
@@ -72,7 +72,7 @@ public void getFilterGroupBy() throws Exception {
   
   @Test
   public void getFilterLiteral() throws Exception {
-    assertNull(TagVFilter.getFilter(TAGK_STRING, "web01"));
+    assertNull(TagVFilter.getFilter(TAGK_STRING, TAGV_STRING));
   }
   
   @Test
@@ -189,7 +189,7 @@ public void resolveName() throws Exception {
   
   @Test
   public void resolveNameLiteral() throws Exception {
-    final TagVFilter filter = new TagVLiteralOrFilter(TAGK_STRING, "web01");
+    final TagVFilter filter = new TagVLiteralOrFilter(TAGK_STRING, TAGV_STRING);
     filter.resolveTagkName(tsdb).join();
     assertArrayEquals(TAGK_BYTES, filter.getTagkBytes());
     assertEquals(1, filter.getTagVUids().size());    

File: src/core/TSDB.java
Patch:
@@ -132,9 +132,9 @@ public TSDB(final HBaseClient client, final Config config) {
       } else {
         async_config = new org.hbase.async.Config();
       }
-      async_config.overrideConfig("asynchbase.zk.base_path", 
+      async_config.overrideConfig("hbase.zookeeper.znode.parent", 
           config.getString("tsd.storage.hbase.zk_basedir"));
-      async_config.overrideConfig("asynchbase.zk.quorum", 
+      async_config.overrideConfig("hbase.zookeeper.quorum", 
           config.getString("tsd.storage.hbase.zk_quorum"));
       this.client = new HBaseClient(async_config);
     } else {

File: src/tsd/QueryRpc.java
Patch:
@@ -124,7 +124,7 @@ private void handleQuery(final TSDB tsdb, final HttpQuery query) {
     final QueryStats query_stats = 
         new QueryStats(query.getRemoteAddress(), data_query);
     data_query.setQueryStats(query_stats);
-    }
+    
     final int nqueries = data_query.getQueries().size();
     final ArrayList<DataPoints[]> results = new ArrayList<DataPoints[]>(nqueries);
     final List<Annotation> globals = new ArrayList<Annotation>();
@@ -775,4 +775,4 @@ public void setTSUIDs(final List<String> tsuids) {
       this.tsuids = tsuids;
     }
   }
-}
+}
\ No newline at end of file

File: src/core/Internal.java
Patch:
@@ -525,7 +525,7 @@ public static byte[] fixFloatingPointValue(final byte flags,
    * @since 2.0
    */
   public static boolean inMilliseconds(final byte[] qualifier, 
-      final byte offset) {
+      final int offset) {
     return inMilliseconds(qualifier[offset]);
   }
   

File: src/core/Internal.java
Patch:
@@ -541,7 +541,7 @@ public static byte[] fixFloatingPointValue(final byte flags,
    * @since 2.0
    */
   public static boolean inMilliseconds(final byte[] qualifier, 
-      final byte offset) {
+      final int offset) {
     return inMilliseconds(qualifier[offset]);
   }
   

File: test/core/TestSpan.java
Patch:
@@ -357,7 +357,8 @@ public void downsampler() throws Exception {
     assertEquals(6, span.size());
     long interval_ms = 1000000;
     Aggregator downsampler = Aggregators.get("avg");
-    final SeekableView it = span.downsampler(interval_ms, downsampler);
+    final SeekableView it = span.downsampler(1356998000L, 1357007000L, 
+        interval_ms, downsampler, FillPolicy.NONE);
     List<Double> values = Lists.newArrayList();
     List<Long> timestamps_in_millis = Lists.newArrayList();
     while (it.hasNext()) {

File: test/core/TestTsdbQueryQueries.java
Patch:
@@ -539,12 +539,13 @@ public void runEndTime() throws Exception {
     int value = 1;
     long timestamp = 1356998430000L;
     for (DataPoint dp : dps[0]) {
+      System.out.println(timestamp);
       assertEquals(value, dp.longValue());
       assertEquals(timestamp, dp.timestamp());
       value++;
       timestamp += 30000;
     }
-    assertEquals(236, dps[0].size());
+    assertEquals(119, dps[0].size());
   }
   
   @Test

File: test/meta/TestTSMeta.java
Patch:
@@ -332,7 +332,7 @@ public void counterExistsInStorageNot() throws Exception {
   public void incrementAndGetCounter() throws Exception {
     final byte[] tsuid = { 0, 0, 1, 0, 0, 1, 0, 0, 1 };
     TSMeta.incrementAndGetCounter(tsdb, tsuid).joinUninterruptibly();
-    verify(client).bufferAtomicIncrement((AtomicIncrementRequest)any());
+    verify(client).atomicIncrement((AtomicIncrementRequest)any());
   }
   
   @Test (expected = NoSuchUniqueId.class)

File: test/meta/TestTSMeta.java
Patch:
@@ -332,7 +332,7 @@ public void counterExistsInStorageNot() throws Exception {
   public void incrementAndGetCounter() throws Exception {
     final byte[] tsuid = { 0, 0, 1, 0, 0, 1, 0, 0, 1 };
     TSMeta.incrementAndGetCounter(tsdb, tsuid).joinUninterruptibly();
-    verify(client).bufferAtomicIncrement((AtomicIncrementRequest)any());
+    verify(client).atomicIncrement((AtomicIncrementRequest)any());
   }
   
   @Test (expected = NoSuchUniqueId.class)

File: src/meta/TSMeta.java
Patch:
@@ -528,7 +528,7 @@ final class TSMetaCB implements Callback<Deferred<Long>, Long> {
       @Override
       public Deferred<Long> call(final Long incremented_value) 
         throws Exception {
-        
+LOG.info("Value: " + incremented_value);
         if (incremented_value > 1) {
           // TODO - maybe update the search index every X number of increments?
           // Otherwise the search engine would only get last_updated/count 
@@ -611,9 +611,9 @@ public Deferred<Long> call(Boolean success) throws Exception {
     // if the user has disabled real time TSMeta tracking (due to OOM issues)
     // then we only want to increment the data point count.
     if (!tsdb.getConfig().enable_realtime_ts()) {
-      return tsdb.getClient().bufferAtomicIncrement(inc);
+      return tsdb.getClient().atomicIncrement(inc);
     }
-    return tsdb.getClient().bufferAtomicIncrement(inc).addCallbackDeferring(
+    return tsdb.getClient().atomicIncrement(inc).addCallbackDeferring(
         new TSMetaCB());
   }
   

File: src/meta/TSMeta.java
Patch:
@@ -528,7 +528,7 @@ final class TSMetaCB implements Callback<Deferred<Long>, Long> {
       @Override
       public Deferred<Long> call(final Long incremented_value) 
         throws Exception {
-        
+LOG.info("Value: " + incremented_value);
         if (incremented_value > 1) {
           // TODO - maybe update the search index every X number of increments?
           // Otherwise the search engine would only get last_updated/count 
@@ -611,9 +611,9 @@ public Deferred<Long> call(Boolean success) throws Exception {
     // if the user has disabled real time TSMeta tracking (due to OOM issues)
     // then we only want to increment the data point count.
     if (!tsdb.getConfig().enable_realtime_ts()) {
-      return tsdb.getClient().bufferAtomicIncrement(inc);
+      return tsdb.getClient().atomicIncrement(inc);
     }
-    return tsdb.getClient().bufferAtomicIncrement(inc).addCallbackDeferring(
+    return tsdb.getClient().atomicIncrement(inc).addCallbackDeferring(
         new TSMetaCB());
   }
   

File: src/uid/UniqueId.java
Patch:
@@ -161,7 +161,7 @@ public void setTSDB(final TSDB tsdb) {
   
   /** The largest possible ID given the number of bytes the IDs are represented on. */
   public long maxPossibleId() {
-    return (1 << id_width * Byte.SIZE) - 1;
+    return ((long) 1 << id_width * Byte.SIZE) - 1;
   }
   
   /**

File: src/tools/TextImporter.java
Patch:
@@ -66,7 +66,7 @@ public static void main(String[] args) throws Exception {
     Config config = CliOptions.getConfig(argp);
 
     final TSDB tsdb = new TSDB(config);
-    final boolean skip_errors = argp.has("--skip_errors");
+    final boolean skip_errors = argp.has("--skip-errors");
     tsdb.checkNecessaryTablesExist().joinUninterruptibly();
     argp = null;
     try {

File: src/uid/UniqueId.java
Patch:
@@ -192,7 +192,7 @@ public void setTSDB(final TSDB tsdb) {
   
   /** The largest possible ID given the number of bytes the IDs are represented on. */
   public long maxPossibleId() {
-    return (1 << id_width * Byte.SIZE) - 1;
+    return ((long) 1 << id_width * Byte.SIZE) - 1;
   }
   
   /**

File: src/core/IncomingDataPoints.java
Patch:
@@ -96,7 +96,7 @@ final class IncomingDataPoints implements WritableDataPoints {
   static void checkMetricAndTags(final String metric,
       final Map<String, String> tags) {
     if (tags.size() <= 0) {
-      throw new IllegalArgumentException("Need at least one tags (metric="
+      throw new IllegalArgumentException("Need at least one tag (metric="
           + metric + ", tags=" + tags + ')');
     } else if (tags.size() > Const.MAX_NUM_TAGS) {
       throw new IllegalArgumentException("Too many tags: " + tags.size()

File: src/core/IncomingDataPoints.java
Patch:
@@ -93,7 +93,7 @@ final class IncomingDataPoints implements WritableDataPoints {
    */
   static void checkMetricAndTags(final String metric, final Map<String, String> tags) {
     if (tags.size() <= 0) {
-      throw new IllegalArgumentException("Need at least one tags (metric="
+      throw new IllegalArgumentException("Need at least one tag (metric="
           + metric + ", tags=" + tags + ')');
     } else if (tags.size() > Const.MAX_NUM_TAGS) {
       throw new IllegalArgumentException("Too many tags: " + tags.size()

File: src/core/TsdbQuery.java
Patch:
@@ -590,7 +590,7 @@ protected Scanner getScanner(final int salt_bucket) throws HBaseException {
     Bytes.setInt(end_row, (end_time == UNSET
                            ? -1  // Will scan until the end (0xFFF...).
                            : (int) getScanEndTimeSeconds()),
-                 metric_width);
+                           metric_salt_width);
     
     // set the metric UID based on the TSUIDs if given, or the metric UID
     if (tsuids != null && !tsuids.isEmpty()) {

File: src/core/Tags.java
Patch:
@@ -564,6 +564,8 @@ public static HashMap<String, String> resolveIds(final TSDB tsdb,
     throws NoSuchUniqueId {
     try {
       return resolveIdsAsync(tsdb, tags).joinUninterruptibly();
+    } catch (NoSuchUniqueId e) {
+      throw e;
     } catch (Exception e) {
       throw new RuntimeException("Shouldn't be here", e);
     }

File: src/core/TsdbQuery.java
Patch:
@@ -575,7 +575,7 @@ protected Scanner getScanner(final int salt_bucket) throws HBaseException {
     final byte[] end_row = new byte[metric_salt_width + Const.TIMESTAMP_BYTES];
     
     if (Const.SALT_WIDTH() > 0) {
-      final byte[] salt = Internal.getSaltBytes(salt_bucket);
+      final byte[] salt = RowKey.getSaltBytes(salt_bucket);
       System.arraycopy(salt, 0, start_row, 0, Const.SALT_WIDTH());
       System.arraycopy(salt, 0, end_row, 0, Const.SALT_WIDTH());
     }

File: src/core/IncomingDataPoints.java
Patch:
@@ -93,7 +93,7 @@ final class IncomingDataPoints implements WritableDataPoints {
    */
   static void checkMetricAndTags(final String metric, final Map<String, String> tags) {
     if (tags.size() <= 0) {
-      throw new IllegalArgumentException("Need at least one tags (metric="
+      throw new IllegalArgumentException("Need at least one tag (metric="
           + metric + ", tags=" + tags + ')');
     } else if (tags.size() > Const.MAX_NUM_TAGS) {
       throw new IllegalArgumentException("Too many tags: " + tags.size()

File: src/utils/Config.java
Patch:
@@ -453,6 +453,7 @@ protected void setDefaults() {
     default_map.put("tsd.core.tree.enable_processing", "false");
     default_map.put("tsd.core.preload_uid_cache", "false");
     default_map.put("tsd.core.preload_uid_cache.max_entries", "300000");
+    default_map.put("tsd.core.uid.random_metrics", "false");
     default_map.put("tsd.rtpublisher.enable", "false");
     default_map.put("tsd.rtpublisher.plugin", "");
     default_map.put("tsd.search.enable", "false");

File: src/meta/Annotation.java
Patch:
@@ -330,7 +330,7 @@ public ScannerCB() {
         final long normalized_start = (start_time - 
             (start_time % Const.MAX_TIMESPAN));
         final long normalized_end = (end_time - 
-            (end_time % Const.MAX_TIMESPAN));
+            (end_time % Const.MAX_TIMESPAN) + Const.MAX_TIMESPAN);
         
         Bytes.setInt(start, (int) normalized_start, TSDB.metrics_width());
         Bytes.setInt(end, (int) normalized_end, TSDB.metrics_width());
@@ -405,7 +405,7 @@ public static Deferred<Integer> deleteRange(final TSDB tsdb,
     final long start = start_time / 1000;
     final long end = end_time / 1000;
     final long normalized_start = (start - (start % Const.MAX_TIMESPAN));
-    final long normalized_end = (end - (end % Const.MAX_TIMESPAN));
+    final long normalized_end = (end - (end % Const.MAX_TIMESPAN) + Const.MAX_TIMESPAN);
     Bytes.setInt(start_row, (int) normalized_start, TSDB.metrics_width());
     Bytes.setInt(end_row, (int) normalized_end, TSDB.metrics_width());
     

File: src/meta/Annotation.java
Patch:
@@ -330,7 +330,7 @@ public ScannerCB() {
         final long normalized_start = (start_time - 
             (start_time % Const.MAX_TIMESPAN));
         final long normalized_end = (end_time - 
-            (end_time % Const.MAX_TIMESPAN));
+            (end_time % Const.MAX_TIMESPAN) + Const.MAX_TIMESPAN);
         
         Bytes.setInt(start, (int) normalized_start, TSDB.metrics_width());
         Bytes.setInt(end, (int) normalized_end, TSDB.metrics_width());
@@ -405,7 +405,7 @@ public static Deferred<Integer> deleteRange(final TSDB tsdb,
     final long start = start_time / 1000;
     final long end = end_time / 1000;
     final long normalized_start = (start - (start % Const.MAX_TIMESPAN));
-    final long normalized_end = (end - (end % Const.MAX_TIMESPAN));
+    final long normalized_end = (end - (end % Const.MAX_TIMESPAN) + Const.MAX_TIMESPAN);
     Bytes.setInt(start_row, (int) normalized_start, TSDB.metrics_width());
     Bytes.setInt(end_row, (int) normalized_end, TSDB.metrics_width());
     

File: src/utils/Config.java
Patch:
@@ -478,6 +478,7 @@ protected void setDefaults() {
     default_map.put("tsd.http.request.cors_headers", "Authorization, "
       + "Content-Type, Accept, Origin, User-Agent, DNT, Cache-Control, "
       + "X-Mx-ReqToken, Keep-Alive, X-Requested-With, If-Modified-Since");
+    default_map.put("tsd.query.timeout", "0");
 
     for (Map.Entry<String, String> entry : default_map.entrySet()) {
       if (!properties.containsKey(entry.getKey()))

File: src/core/Query.java
Patch:
@@ -22,7 +22,7 @@
 import net.opentsdb.uid.NoSuchUniqueName;
 
 /**
- * A query to retreive data from the TSDB.
+ * A query to retrieve data from the TSDB.
  */
 public interface Query {
 
@@ -69,7 +69,7 @@ public interface Query {
 
   /**
   * Sets the time series to the query.
-  * @param metric The metric to retreive from the TSDB.
+  * @param metric The metric to retrieve from the TSDB.
   * @param tags The set of tags of interest.
   * @param function The aggregation function to use.
   * @param rate If true, the rate of the series will be used instead of the
@@ -86,7 +86,7 @@ void setTimeSeries(String metric, Map<String, String> tags,
     
   /**
    * Sets the time series to the query.
-   * @param metric The metric to retreive from the TSDB.
+   * @param metric The metric to retrieve from the TSDB.
    * @param tags The set of tags of interest.
    * @param function The aggregation function to use.
    * @param rate If true, the rate of the series will be used instead of the

File: src/core/TsdbQuery.java
Patch:
@@ -343,7 +343,7 @@ public Deferred<DataPoints[]> runAsync() throws HBaseException {
    * stored in the map has its timestamp zero'ed out.
    * @throws HBaseException if there was a problem communicating with HBase to
    * perform the search.
-   * @throws IllegalArgumentException if bad data was retreived from HBase.
+   * @throws IllegalArgumentException if bad data was retrieved from HBase.
    */
   private Deferred<TreeMap<byte[], Span>> findSpans() throws HBaseException {
     final short metric_width = tsdb.metrics.width();

File: src/core/Query.java
Patch:
@@ -22,7 +22,7 @@
 import net.opentsdb.uid.NoSuchUniqueName;
 
 /**
- * A query to retreive data from the TSDB.
+ * A query to retrieve data from the TSDB.
  */
 public interface Query {
 
@@ -69,7 +69,7 @@ public interface Query {
 
   /**
   * Sets the time series to the query.
-  * @param metric The metric to retreive from the TSDB.
+  * @param metric The metric to retrieve from the TSDB.
   * @param tags The set of tags of interest.
   * @param function The aggregation function to use.
   * @param rate If true, the rate of the series will be used instead of the
@@ -86,7 +86,7 @@ void setTimeSeries(String metric, Map<String, String> tags,
     
   /**
    * Sets the time series to the query.
-   * @param metric The metric to retreive from the TSDB.
+   * @param metric The metric to retrieve from the TSDB.
    * @param tags The set of tags of interest.
    * @param function The aggregation function to use.
    * @param rate If true, the rate of the series will be used instead of the

File: src/core/TsdbQuery.java
Patch:
@@ -343,7 +343,7 @@ public Deferred<DataPoints[]> runAsync() throws HBaseException {
    * stored in the map has its timestamp zero'ed out.
    * @throws HBaseException if there was a problem communicating with HBase to
    * perform the search.
-   * @throws IllegalArgumentException if bad data was retreived from HBase.
+   * @throws IllegalArgumentException if bad data was retrieved from HBase.
    */
   private Deferred<TreeMap<byte[], Span>> findSpans() throws HBaseException {
     final short metric_width = tsdb.metrics.width();

File: src/core/TSDB.java
Patch:
@@ -659,7 +659,6 @@ private Deferred<Object> addPointInternal(final String metric,
           + " when trying to add value=" + Arrays.toString(value) + '/' + flags
           + " to metric=" + metric + ", tags=" + tags);
     }
-
     IncomingDataPoints.checkMetricAndTags(metric, tags);
     final byte[] row = IncomingDataPoints.rowKeyTemplate(this, metric, tags);
     final long base_time;

File: src/core/Tags.java
Patch:
@@ -401,6 +401,8 @@ public Map<String, String> call(final ArrayList<String> names)
   public static void validateString(final String what, final String s) {
     if (s == null) {
       throw new IllegalArgumentException("Invalid " + what + ": null");
+    } else if ("".equals(s)) {
+      throw new IllegalArgumentException("Invalid " + what + ": empty string");
     }
     final int n = s.length();
     for (int i = 0; i < n; i++) {

File: src/core/TSDB.java
Patch:
@@ -670,7 +670,6 @@ private Deferred<Object> addPointInternal(final String metric,
           + " when trying to add value=" + Arrays.toString(value) + '/' + flags
           + " to metric=" + metric + ", tags=" + tags);
     }
-
     IncomingDataPoints.checkMetricAndTags(metric, tags);
     final byte[] row = IncomingDataPoints.rowKeyTemplate(this, metric, tags);
     final long base_time;

File: src/core/Tags.java
Patch:
@@ -401,6 +401,8 @@ public Map<String, String> call(final ArrayList<String> names)
   public static void validateString(final String what, final String s) {
     if (s == null) {
       throw new IllegalArgumentException("Invalid " + what + ": null");
+    } else if ("".equals(s)) {
+      throw new IllegalArgumentException("Invalid " + what + ": empty string");
     }
     final int n = s.length();
     for (int i = 0; i < n; i++) {

File: src/meta/Annotation.java
Patch:
@@ -273,7 +273,7 @@ public Deferred<Annotation> call(final ArrayList<KeyValue> row)
           return Deferred.fromResult(null);
         }
         
-        Annotation note = JSON.parseToObject(row.get(0).value(), 
+        Annotation note = JSON.parseToObject(row.get(0).value(),
             Annotation.class);
         return Deferred.fromResult(note);
       }
@@ -356,7 +356,7 @@ public Deferred<List<Annotation>> call (
           for (KeyValue column : row) {
             if (column.qualifier().length == 3 && 
                 column.qualifier()[0] == PREFIX()) {
-              Annotation note = JSON.parseToObject(row.get(0).value(), 
+              Annotation note = JSON.parseToObject(column.value(),
                   Annotation.class);
               if (note.start_time < start_time || note.end_time > end_time) {
                 continue;

File: src/tsd/RTPublisher.java
Patch:
@@ -97,7 +97,7 @@ public abstract class RTPublisher {
   public final Deferred<Object> sinkDataPoint(final String metric, 
       final long timestamp, final byte[] value, final Map<String, String> tags, 
       final byte[] tsuid, final short flags) {
-    if ((flags & Const.FLAG_FLOAT) == 0x0) {
+    if ((flags & Const.FLAG_FLOAT) != 0x0) {
       return publishDataPoint(metric, timestamp, 
           Internal.extractFloatingPointValue(value, 0, (byte) flags), 
           tags, tsuid);

File: src/core/TSDB.java
Patch:
@@ -580,7 +580,7 @@ public Deferred<Object> addPoint(final String metric,
                                          + " for metric=" + metric
                                          + " timestamp=" + timestamp);
     }
-    final short flags = Const.FLAG_FLOAT | 0x7;  // A float stored on 4 bytes.
+    final short flags = Const.FLAG_FLOAT | 0x7;  // A float stored on 8 bytes.
     return addPointInternal(metric, timestamp,
                             Bytes.fromLong(Double.doubleToRawLongBits(value)),
                             tags, flags);

File: src/core/TSDB.java
Patch:
@@ -604,7 +604,7 @@ public Deferred<Object> addPoint(final String metric,
                                          + " for metric=" + metric
                                          + " timestamp=" + timestamp);
     }
-    final short flags = Const.FLAG_FLOAT | 0x7;  // A float stored on 4 bytes.
+    final short flags = Const.FLAG_FLOAT | 0x7;  // A float stored on 8 bytes.
     return addPointInternal(metric, timestamp,
                             Bytes.fromLong(Double.doubleToRawLongBits(value)),
                             tags, flags);

File: src/core/TSDB.java
Patch:
@@ -604,7 +604,7 @@ public Deferred<Object> addPoint(final String metric,
                                          + " for metric=" + metric
                                          + " timestamp=" + timestamp);
     }
-    final short flags = Const.FLAG_FLOAT | 0x7;  // A float stored on 4 bytes.
+    final short flags = Const.FLAG_FLOAT | 0x7;  // A float stored on 8 bytes.
     return addPointInternal(metric, timestamp,
                             Bytes.fromLong(Double.doubleToRawLongBits(value)),
                             tags, flags);

File: src/tools/Fsck.java
Patch:
@@ -653,7 +653,7 @@ private void fsckDataPoints(final Map<Long, ArrayList<DP>> datapoints)
             }
           }
           index++;
-          if (index < datapoints.size()) {
+          if (index < time_map.getValue().size()) {
             buf.append("\n");
           }
           last_dp = dp;

File: src/tools/Fsck.java
Patch:
@@ -653,7 +653,7 @@ private void fsckDataPoints(final Map<Long, ArrayList<DP>> datapoints)
             }
           }
           index++;
-          if (index < datapoints.size()) {
+          if (index < time_map.getValue().size()) {
             buf.append("\n");
           }
           last_dp = dp;

File: test/tools/TestFsck.java
Patch:
@@ -16,13 +16,11 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Mockito.when;
 import static org.powermock.api.mockito.PowerMockito.mock;
 
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -3667,4 +3665,5 @@ public void runQuery() throws Exception {
     assertEquals(1, fsck.rows_processed.get());
     assertEquals(0, fsck.totalErrors());
   }
+
 }

File: src/core/Tags.java
Patch:
@@ -455,10 +455,10 @@ static ArrayList<byte[]> resolveAllInternal(final TSDB tsdb,
     throws NoSuchUniqueName {
     final ArrayList<byte[]> tag_ids = new ArrayList<byte[]>(tags.size());
     for (final Map.Entry<String, String> entry : tags.entrySet()) {
-      final byte[] tag_id = (create
+      final byte[] tag_id = (create && tsdb.getConfig().auto_tagk()
                              ? tsdb.tag_names.getOrCreateId(entry.getKey())
                              : tsdb.tag_names.getId(entry.getKey()));
-      final byte[] value_id = (create
+      final byte[] value_id = (create && tsdb.getConfig().auto_tagv()
                                ? tsdb.tag_values.getOrCreateId(entry.getValue())
                                : tsdb.tag_values.getId(entry.getValue()));
       final byte[] thistag = new byte[tag_id.length + value_id.length];

File: src/core/Tags.java
Patch:
@@ -455,10 +455,10 @@ static ArrayList<byte[]> resolveAllInternal(final TSDB tsdb,
     throws NoSuchUniqueName {
     final ArrayList<byte[]> tag_ids = new ArrayList<byte[]>(tags.size());
     for (final Map.Entry<String, String> entry : tags.entrySet()) {
-      final byte[] tag_id = (create
+      final byte[] tag_id = (create && tsdb.getConfig().auto_tagk()
                              ? tsdb.tag_names.getOrCreateId(entry.getKey())
                              : tsdb.tag_names.getId(entry.getKey()));
-      final byte[] value_id = (create
+      final byte[] value_id = (create && tsdb.getConfig().auto_tagv()
                                ? tsdb.tag_values.getOrCreateId(entry.getValue())
                                : tsdb.tag_values.getId(entry.getValue()));
       final byte[] thistag = new byte[tag_id.length + value_id.length];

File: test/core/SeekableViewsForTest.java
Patch:
@@ -145,7 +145,7 @@ private void generateData() {
       if (is_integer) {
         current_data.reset(generateTimestamp(), current);
       } else {
-        current_data.reset(generateTimestamp(), current);
+        current_data.reset(generateTimestamp(), (double)current);
       }
     }
 

File: test/tools/TestDumpSeries.java
Patch:
@@ -186,7 +186,7 @@ public void dumpRaw() throws Exception {
         "[0, 0, 1, 80, -30, 53, 16, 0, 0, 1, 0, 0, 1] sys.cpu.user 1357002000",
         log_lines[8].substring(0, 68));
     assertEquals(
-        "  [1, 0, 0, 0, 0]\t[123, 34, 116, 115, 117, 105, 100, "
+        "  [1, 0, 0]\t[123, 34, 116, 115, 117, 105, 100, "
         + "34, 58, 34, 48, 48, 48, 48, 48, 49, 48, 48, 48, 48, 48, 49, 48, 48, "
         + "48, 48, 48, 49, 34, 44, 34, 115, 116, 97, 114, 116, 84, 105, 109, "
         + "101, 34, 58, 49, 51, 53, 55, 48, 48, 50, 48, 48, 48, 48, 48, 48, "
@@ -199,7 +199,7 @@ public void dumpRaw() throws Exception {
         + "\"000001000001000001\",\"startTime\":1357002000000,\"endTime\":0,"
         + "\"description\":\"Annotation on milliseconds\",\"notes\":\"\","
         + "\"custom\":null}\t1357002016000",
-        log_lines[9].substring(0, 780));
+        log_lines[9].substring(0, 774));
     assertEquals(
         "  [-16, 0, 0, 0]\t[42]\t0\tl\t1357002000000",
         log_lines[10].substring(0, 39));

File: test/tools/TestDumpSeries.java
Patch:
@@ -186,7 +186,7 @@ public void dumpRaw() throws Exception {
         "[0, 0, 1, 80, -30, 53, 16, 0, 0, 1, 0, 0, 1] sys.cpu.user 1357002000",
         log_lines[8].substring(0, 68));
     assertEquals(
-        "  [1, 0, 0, 0, 0]\t[123, 34, 116, 115, 117, 105, 100, "
+        "  [1, 0, 0]\t[123, 34, 116, 115, 117, 105, 100, "
         + "34, 58, 34, 48, 48, 48, 48, 48, 49, 48, 48, 48, 48, 48, 49, 48, 48, "
         + "48, 48, 48, 49, 34, 44, 34, 115, 116, 97, 114, 116, 84, 105, 109, "
         + "101, 34, 58, 49, 51, 53, 55, 48, 48, 50, 48, 48, 48, 48, 48, 48, "
@@ -199,7 +199,7 @@ public void dumpRaw() throws Exception {
         + "\"000001000001000001\",\"startTime\":1357002000000,\"endTime\":0,"
         + "\"description\":\"Annotation on milliseconds\",\"notes\":\"\","
         + "\"custom\":null}\t1357002016000",
-        log_lines[9].substring(0, 780));
+        log_lines[9].substring(0, 774));
     assertEquals(
         "  [-16, 0, 0, 0]\t[42]\t0\tl\t1357002000000",
         log_lines[10].substring(0, 39));

File: src/uid/UniqueId.java
Patch:
@@ -524,7 +524,9 @@ public Object call(final byte[] row) throws Exception {
         tsdb.indexUIDMeta(meta);
       }
       
-      pending_assignments.remove(name);
+      synchronized (pending_assignments) {
+        pending_assignments.remove(name);
+      }
       assignment.callback(row);
       return assignment;
     }

File: src/tools/TSDMain.java
Patch:
@@ -112,10 +112,10 @@ public static void main(String[] args) throws IOException {
 
     // validate the cache and staticroot directories
     try {
-      checkDirectory(config.getString("tsd.http.staticroot"), DONT_CREATE,
-          !MUST_BE_WRITEABLE);
+      checkDirectory(config.getString("tsd.http.staticroot"), 
+          !MUST_BE_WRITEABLE, DONT_CREATE);
       checkDirectory(config.getString("tsd.http.cachedir"),
-          CREATE_IF_NEEDED, MUST_BE_WRITEABLE);
+          MUST_BE_WRITEABLE, CREATE_IF_NEEDED);
     } catch (IllegalArgumentException e) {
       usage(argp, e.getMessage(), 3);
     }

File: src/tools/Fsck.java
Patch:
@@ -205,7 +205,8 @@ final class DP {
               LOG.debug("Found an object from a future version of OpenTSDB\n\t" 
                   + kv);
               continue;
-            } else if (qual.length >= 4 && !Internal.inMilliseconds(qual[0])) {
+            } else if (qual.length == 4 && !Internal.inMilliseconds(qual[0])
+                || qual.length > 4) {
               // compacted row
               if (value[value.length - 1] > Const.MS_MIXED_COMPACT) {
                 errors++;

File: src/tools/Fsck.java
Patch:
@@ -205,7 +205,8 @@ final class DP {
               LOG.debug("Found an object from a future version of OpenTSDB\n\t" 
                   + kv);
               continue;
-            } else if (qual.length >= 4 && !Internal.inMilliseconds(qual[0])) {
+            } else if (qual.length == 4 && !Internal.inMilliseconds(qual[0])
+                || qual.length > 4) {
               // compacted row
               if (value[value.length - 1] > Const.MS_MIXED_COMPACT) {
                 errors++;

File: test/meta/TestTSUIDQuery.java
Patch:
@@ -209,7 +209,7 @@ public void before() throws Exception {
       .thenReturn(Deferred.fromResult("host"));
     when(tag_names.getOrCreateIdAsync("host")).thenReturn(
         Deferred.fromResult(new byte[] { 0, 0, 1 }));
-    when(tag_names.getIdAsync("dc"))
+    when(tag_names.getId("dc"))
       .thenThrow(new NoSuchUniqueName("dc", "metric"));
     when(tag_names.getId("datacenter")).thenReturn(new byte[] { 0, 0, 2 });
     when(tag_names.getIdAsync("datacenter"))
@@ -231,7 +231,7 @@ public void before() throws Exception {
       .thenReturn(Deferred.fromResult("web02"));
     when(tag_values.getOrCreateIdAsync("web02")).thenReturn(
         Deferred.fromResult(new byte[] { 0, 0, 2 }));
-    when(tag_values.getIdAsync("web03"))
+    when(tag_values.getId("web03"))
       .thenThrow(new NoSuchUniqueName("web03", "metric"));
     when(tag_values.getId("dc01")).thenReturn(new byte[] { 0, 0, 3 });
     when(tag_values.getIdAsync("dc01"))

File: src/utils/Config.java
Patch:
@@ -407,6 +407,9 @@ protected void setDefaults() {
     default_map.put("tsd.http.request.enable_chunked", "false");
     default_map.put("tsd.http.request.max_chunk", "4096");
     default_map.put("tsd.http.request.cors_domains", "");
+    default_map.put("tsd.http.request.cors_headers", "Authorization, "
+      + "Content-Type, Accept, Origin, User-Agent, DNT, Cache-Control, "
+      + "X-Mx-ReqToken, Keep-Alive, X-Requested-With, If-Modified-Since");
 
     for (Map.Entry<String, String> entry : default_map.entrySet()) {
       if (!properties.containsKey(entry.getKey()))

File: test/tools/TestFsck.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.util.HashMap;
 
 import net.opentsdb.core.TSDB;
 import net.opentsdb.meta.Annotation;

File: src/tools/CliQuery.java
Patch:
@@ -42,7 +42,7 @@ private static void usage(final ArgP argp, final String errmsg,
     System.err.println("Usage: query"
         + " [Gnuplot opts] START-DATE [END-DATE] <query> [queries...]\n"
         + "A query has the form:\n"
-        + "  FUNC [rate] [counter,max,reset] [downsample FUNC N] SERIES [TAGS]\n"
+        + "  FUNC [rate] [counter,max,reset] [downsample N FUNC] SERIES [TAGS]\n"
         + "For example:\n"
         + " 2010/03/11-20:57 sum my.awsum.metric host=blah"
         + " sum some.other.metric host=blah state=foo\n"

File: src/core/TSQuery.java
Patch:
@@ -148,6 +148,9 @@ public Query[] buildQueries(final TSDB tsdb) {
         } else {
           query.setTimeSeries(sub.getTsuids(), sub.aggregator(), sub.getRate());
         }
+      } else if (sub.getRateOptions() != null) {
+        query.setTimeSeries(sub.getMetric(), sub.getTags(), sub.aggregator(), 
+            sub.getRate(), sub.getRateOptions());
       } else {
         query.setTimeSeries(sub.getMetric(), sub.getTags(), sub.aggregator(), 
             sub.getRate());

File: src/tsd/HttpQuery.java
Patch:
@@ -116,7 +116,7 @@ final class HttpQuery {
 
   /** The response object we'll fill with data */
   private final DefaultHttpResponse response =
-    new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.ACCEPTED);
+    new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
   
   /** The {@code TSDB} instance we belong to */
   private final TSDB tsdb; 

File: src/core/Query.java
Patch:
@@ -153,7 +153,7 @@ public void setTimeSeries(final List<String> tsuids,
    * @param downsampler Aggregation function to use to group data points
    * within an interval.
    */
-  void downsample(int interval, Aggregator downsampler);
+  void downsample(long interval, Aggregator downsampler);
 
   /**
    * Runs this query.

File: src/core/Span.java
Patch:
@@ -424,7 +424,7 @@ public String toString() {
   }
 
   /** Package private iterator method to access it as a DownsamplingIterator. */
-  Span.DownsamplingIterator downsampler(final int interval,
+  Span.DownsamplingIterator downsampler(final long interval,
                                         final Aggregator downsampler) {
     return new Span.DownsamplingIterator(interval, downsampler);
   }
@@ -447,7 +447,7 @@ final class DownsamplingIterator
     private static final long TIME_MASK  = 0x7FFFFFFFFFFFFFFFL;
 
     /** The "sampling" interval, in milliseconds. */
-    private final int interval;
+    private final long interval;
 
     /** Function to use to for downsampling. */
     private final Aggregator downsampler;
@@ -473,7 +473,7 @@ final class DownsamplingIterator
      * @param downsampler The downsampling function to use.
      * @param iterator The iterator to access the underlying data.
      */
-    DownsamplingIterator(final int interval,
+    DownsamplingIterator(final long interval,
                          final Aggregator downsampler) {
       this.interval = interval;
       this.downsampler = downsampler;

File: src/core/SpanGroup.java
Patch:
@@ -92,7 +92,7 @@ final class SpanGroup implements DataPoints {
   private final Aggregator downsampler;
 
   /** Minimum time interval (in seconds) wanted between each data point. */
-  private final int sample_interval;
+  private final long sample_interval;
 
   /**
    * Ctor.
@@ -115,7 +115,7 @@ final class SpanGroup implements DataPoints {
             final Iterable<Span> spans,
             final boolean rate,
             final Aggregator aggregator,
-            final int interval, final Aggregator downsampler) {
+            final long interval, final Aggregator downsampler) {
     this(tsdb, start_time, end_time, spans, rate, new RateOptions(false,
         Long.MAX_VALUE, RateOptions.DEFAULT_RESET_VALUE), aggregator, interval,
         downsampler);
@@ -144,7 +144,7 @@ final class SpanGroup implements DataPoints {
             final Iterable<Span> spans,
             final boolean rate, final RateOptions rate_options,
             final Aggregator aggregator,
-            final int interval, final Aggregator downsampler) {
+            final long interval, final Aggregator downsampler) {
      this.start_time = (start_time & Const.SECOND_MASK) == 0 ? 
          start_time * 1000 : start_time;
      this.end_time = (end_time & Const.SECOND_MASK) == 0 ? 

File: src/core/TSQuery.java
Patch:
@@ -135,7 +135,7 @@ public Query[] buildQueries(final TSDB tsdb) {
       query.setStartTime(start_time);
       query.setEndTime(end_time);
       if (sub.downsampler() != null) {
-        query.downsample((int)sub.downsampleInterval(), sub.downsampler());
+        query.downsample(sub.downsampleInterval(), sub.downsampler());
       } else if (!ms_resolution) {
         // we *may* have multiple millisecond data points in the set so we have
         // to downsample. use the sub query's aggregator

File: src/core/TsdbQuery.java
Patch:
@@ -116,7 +116,7 @@ final class TsdbQuery implements Query {
   private Aggregator downsampler;
 
   /** Minimum time interval (in seconds) wanted between each data point. */
-  private int sample_interval;
+  private long sample_interval;
 
   /** Optional list of TSUIDs to fetch and aggregate instead of a metric */
   private List<String> tsuids;
@@ -246,7 +246,7 @@ public void setTimeSeries(final List<String> tsuids,
    * @throws NullPointerException if the aggregation function is null
    * @throws IllegalArgumentException if the interval is not greater than 0
    */
-  public void downsample(final int interval, final Aggregator downsampler) {
+  public void downsample(final long interval, final Aggregator downsampler) {
     if (downsampler == null) {
       throw new NullPointerException("downsampler");
     } else if (interval <= 0) {

File: src/tools/CliQuery.java
Patch:
@@ -222,7 +222,7 @@ static void parseCommandLineQuery(final String[] args,
       if (downsample) {
         i++;
       }
-      final int interval = downsample ? Integer.parseInt(args[i++]) : 0;
+      final long interval = downsample ? Long.parseLong(args[i++]) : 0;
       final Aggregator sampler = downsample ? Aggregators.get(args[i++]) : null;
       final String metric = args[i++];
       final HashMap<String, String> tags = new HashMap<String, String>();

File: src/tsd/GraphHandler.java
Patch:
@@ -876,7 +876,7 @@ private static Query[] parseQuery(final TSDB tsdb, final HttpQuery query) {
           throw new BadRequestException("No such downsampling function: "
                                         + parts[1].substring(dash + 1));
         }
-        final int interval = (int) DateTime.parseDuration(parts[1].substring(0, dash));
+        final long interval = DateTime.parseDuration(parts[1].substring(0, dash));
         tsdbquery.downsample(interval, downsampler);
       } else {
         tsdbquery.downsample(1000, agg);

File: src/tsd/client/DateTimeBox.java
Patch:
@@ -54,7 +54,7 @@ public Date parse(final DateBox box,
                         final String text,
                         final boolean report_error) {
         if (text.endsWith(" ago") || text.endsWith("-ago")) { // e.g. "1d ago".
-          int interval;
+          long interval;
           final int lastchar = text.length() - 5;
           try {
             interval = Integer.parseInt(text.substring(0, lastchar));

File: src/utils/JSON.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: src/utils/PluginLoader.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: test/plugin/DummyPlugin.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: test/plugin/DummyPluginA.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: test/plugin/DummyPluginB.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: test/utils/TestConfig.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: test/utils/TestJSON.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: test/utils/TestPluginLoader.java
Patch:
@@ -1,9 +1,9 @@
 // This file is part of OpenTSDB.
-// Copyright (C) 2013  The OpenTSDB Authors.
+// Copyright (C) 2013-2014  The OpenTSDB Authors.
 //
 // This program is free software: you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or (at your
+// the Free Software Foundation, either version 2.1 of the License, or (at your
 // option) any later version.  This program is distributed in the hope that it
 // will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 // of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser

File: src/core/IncomingDataPoints.java
Patch:
@@ -252,8 +252,7 @@ private Deferred<Object> addPointInternal(final long timestamp, final byte[] val
     final boolean ms_timestamp = (timestamp & Const.SECOND_MASK) != 0;
     
     // we only accept unix epoch timestamps in seconds or milliseconds
-    if (ms_timestamp && 
-        (timestamp < 1000000000000L || timestamp > 9999999999999L)) {
+    if (timestamp < 0 || (ms_timestamp && timestamp > 9999999999999L)) {
       throw new IllegalArgumentException((timestamp < 0 ? "negative " : "bad")
           + " timestamp=" + timestamp
           + " when trying to add value=" + Arrays.toString(value) + " to " + this);

File: src/core/TSDB.java
Patch:
@@ -627,9 +627,9 @@ private Deferred<Object> addPointInternal(final String metric,
                                             final byte[] value,
                                             final Map<String, String> tags,
                                             final short flags) {
-    // we only accept unix epoch timestamps in seconds or milliseconds
-    if ((timestamp & Const.SECOND_MASK) != 0 && 
-        (timestamp < 1000000000000L || timestamp > 9999999999999L)) {
+    // we only accept positive unix epoch timestamps in seconds or milliseconds
+    if (timestamp < 0 || ((timestamp & Const.SECOND_MASK) != 0 && 
+        timestamp > 9999999999999L)) {
       throw new IllegalArgumentException((timestamp < 0 ? "negative " : "bad")
           + " timestamp=" + timestamp
           + " when trying to add value=" + Arrays.toString(value) + '/' + flags

File: src/meta/Annotation.java
Patch:
@@ -558,7 +558,7 @@ public final String getNotes() {
   }
 
   /** @return the custom key/value map, may be null */
-  public final HashMap<String, String> getCustom() {
+  public final Map<String, String> getCustom() {
     return custom;
   }
 
@@ -597,13 +597,13 @@ public void setNotes(final String notes) {
   }
 
   /** @param custom the custom key/value map */
-  public void setCustom(final HashMap<String, String> custom) {
+  public void setCustom(final Map<String, String> custom) {
     // equivalency of maps is a pain, users have to submit the whole map
     // anyway so we'll just mark it as changed every time we have a non-null
     // value
     if (this.custom != null || custom != null) {
       changed.put("custom", true);
-      this.custom = custom;
+      this.custom = new HashMap<String, String>(custom);
     }
   }
 }

File: src/meta/UIDMeta.java
Patch:
@@ -588,13 +588,13 @@ public void setNotes(final String notes) {
   }
 
   /** @param custom the custom to set */
-  public void setCustom(final HashMap<String, String> custom) {
+  public void setCustom(final Map<String, String> custom) {
     // equivalency of maps is a pain, users have to submit the whole map
     // anyway so we'll just mark it as changed every time we have a non-null
     // value
     if (this.custom != null || custom != null) {
       changed.put("custom", true);
-      this.custom = custom;
+      this.custom = new HashMap<String, String>(custom);
     }
   }
 

File: src/tree/TreeBuilder.java
Patch:
@@ -758,7 +758,7 @@ private void parseMetricRule() {
    * @throws IllegalStateException if the tag UIDMetas have not be set
    */
   private void parseTagkRule() {
-    final ArrayList<UIDMeta> tags = meta.getTags();
+    final List<UIDMeta> tags = meta.getTags();
     if (tags == null || tags.isEmpty()) {
       throw new IllegalStateException(
         "Tags for the timeseries meta were null");

File: src/meta/UIDMeta.java
Patch:
@@ -301,7 +301,7 @@ public Deferred<Object> storeNew(final TSDB tsdb) {
     final PutRequest put = new PutRequest(tsdb.uidTable(), 
         UniqueId.stringToUid(uid), FAMILY, 
         (type.toString().toLowerCase() + "_meta").getBytes(CHARSET), 
-        JSON.serializeToBytes(this));
+        UIDMeta.this.getStorageJSON());
     return tsdb.getClient().put(put);
   }
   

File: test/meta/TestUIDMeta.java
Patch:
@@ -251,12 +251,12 @@ public void syncToStorageNoSuch() throws Exception {
   @Test
   public void storeNew() throws Exception {
     meta = new UIDMeta(UniqueIdType.METRIC, new byte[] { 0, 0, 1 }, "sys.cpu.1");
+    meta.setDisplayName("System CPU");
     meta.storeNew(tsdb).joinUninterruptibly();
     meta = JSON.parseToObject(storage.getColumn(new byte[] { 0, 0, 1 }, 
         NAME_FAMILY,
         "metric_meta".getBytes(MockBase.ASCII())), UIDMeta.class);
-    assertEquals("", meta.getDisplayName());
-    assertEquals("sys.cpu.1", meta.getName());
+    assertEquals("System CPU", meta.getDisplayName());
   }
   
   @Test (expected = IllegalArgumentException.class)

File: src/tools/UidManager.java
Patch:
@@ -116,7 +116,7 @@ static void usage(final ArgP argp, final String errmsg) {
         + "            from storage. Provide an integer Tree ID and optionally\n"
         + "            add \"true\" to delete the tree definition\n\n"
         + "Example values for [kind]:"
-        + " metric, tagk (tag name), tagv (tag value).");
+        + " metrics, tagk (tag name), tagv (tag value).");
     if (argp != null) {
       System.err.print(argp.usage());
     }

File: src/tree/TreeBuilder.java
Patch:
@@ -510,7 +510,7 @@ public List<Tree> call(final List<Tree> loaded_trees)
           local_trees = new ArrayList<Tree>(trees.size());
           local_trees.addAll(trees);
         }
-        
+        trees_lock.unlock();
         return local_trees;
       }
       
@@ -547,6 +547,7 @@ public Object call(final Exception e) throws Exception {
     final List<Tree> local_trees;
     if (trees.isEmpty()) {
       LOG.debug("No trees were found to process the meta through");
+      trees_lock.unlock();
       return Deferred.fromResult(true);
     }
     

File: src/tsd/AnnotationRpc.java
Patch:
@@ -217,7 +217,9 @@ public Deferred<Annotation> call(final Annotation note) throws Exception {
         Deferred<Annotation> deferred = 
             note.syncToStorage(tsdb, method == HttpMethod.PUT)
             .addCallbackDeferring(new SyncCB(note));
-        callbacks.add(deferred.addCallbackDeferring(new IndexCB()));
+        Deferred<Annotation> indexer = 
+            deferred.addCallbackDeferring(new IndexCB());
+        callbacks.add(indexer);
       } catch (IllegalStateException e) {
         LOG.info("No changes for annotation: " + note);
       } catch (IllegalArgumentException e) {

File: src/core/IncomingDataPoints.java
Patch:
@@ -259,7 +259,7 @@ private Deferred<Object> addPointInternal(final long timestamp, final byte[] val
       final long last_ts = base_time + (delta(qualifiers[size - 1]));
       if (timestamp <= last_ts) {
         throw new IllegalArgumentException("New timestamp=" + timestamp
-            + " is less than previous=" + last_ts
+            + " is less than or equal to previous=" + last_ts
             + " when trying to add value=" + Arrays.toString(value)
             + " to " + this);
       } else if (timestamp - base_time >= Const.MAX_TIMESPAN) {

File: src/meta/UIDMeta.java
Patch:
@@ -506,7 +506,7 @@ private byte[] getStorageJSON() {
       if (custom == null) {
         json.writeNullField("custom");
       } else {
-        json.writeStartObject();
+        json.writeObjectFieldStart("custom");
         for (Map.Entry<String, String> entry : custom.entrySet()) {
           json.writeStringField(entry.getKey(), entry.getValue());
         }

File: test/core/TestTSDB.java
Patch:
@@ -764,10 +764,10 @@ private void setupAddPointStorage() throws Exception {
     PowerMockito.mockStatic(IncomingDataPoints.class);   
     final byte[] row = new byte[] { 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1}; 
     PowerMockito.doAnswer(
-        new Answer<Deferred<byte[]>>() {
-          public Deferred<byte[]> answer(final InvocationOnMock unused) 
+        new Answer<byte[]>() {
+          public byte[] answer(final InvocationOnMock unused) 
             throws Exception {
-            return Deferred.fromResult(row);
+            return row;
           }
         }
     ).when(IncomingDataPoints.class, "rowKeyTemplate", (TSDB)any(), anyString(), 

File: src/core/DataPoint.java
Patch:
@@ -20,7 +20,7 @@
 public interface DataPoint {
 
   /**
-   * Returns the timestamp (in seconds) associated with this data point.
+   * Returns the timestamp (in milliseconds) associated with this data point.
    * @return A strictly positive, 32 bit integer.
    */
   long timestamp();

File: src/core/Span.java
Patch:
@@ -514,7 +514,7 @@ public DataPoint next() {
       // average timestamp of all the datapoints in that interval.
       long newtime = 0;
       final short saved_row_index = row_index;
-      final int saved_state = current_row.saveState();
+      final long saved_state = current_row.saveState();
       // Since we know hasNext() returned true, we have at least 1 point.
       moveToNext();
       time = current_row.timestamp() + interval;  // end of interval

File: test/tools/TestFsck.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
-import java.util.HashMap;
 
 import net.opentsdb.core.TSDB;
 import net.opentsdb.meta.Annotation;

File: src/tools/DumpSeries.java
Patch:
@@ -231,7 +231,7 @@ static void appendRawCell(final StringBuilder buf, final Cell cell,
     .append("\t")
     .append(cell.isInteger() ? "l" : "f")
     .append("\t")
-    .append(cell.parseValue())
+    .append(Arrays.toString(cell.value()))
     .append("\t")
     .append(cell.absoluteTimestamp(base_time))
     .append("\t")
@@ -244,7 +244,7 @@ static void appendImportCell(final StringBuilder buf, final Cell cell,
       final long base_time, final String tags) {
     buf.append(cell.absoluteTimestamp(base_time))
     .append(" ")
-    .append(Arrays.toString(cell.value()))
+    .append(cell.parseValue())
     .append(tags);
   }
   

File: src/tsd/GraphHandler.java
Patch:
@@ -61,9 +61,9 @@ final class GraphHandler implements HttpRpc {
   private static final Logger LOG =
     LoggerFactory.getLogger(GraphHandler.class);
 
-  private static final boolean IS_WINDOWS = 
-    System.getProperty("os.name").contains("Windows");
-  
+  private static final boolean IS_WINDOWS =
+    System.getProperty("os.name", "").contains("Windows");
+
   /** Number of times we had to do all the work up to running Gnuplot. */
   private static final AtomicInteger graphs_generated
     = new AtomicInteger();

File: src/tsd/TreeRpc.java
Patch:
@@ -181,7 +181,7 @@ private void handleTree() {
           }
         } else {
           final String delete_all = query.getQueryStringParam("definition");
-          if (delete_all.toLowerCase().equals("true")) {
+          if (delete_all != null && delete_all.toLowerCase().equals("true")) {
             delete_definition = true;
           }
         }

File: test/tsd/TestTreeRpc.java
Patch:
@@ -363,7 +363,7 @@ public void handleTreePOSTDeleteDefault() throws Exception {
   public void handleTreePOSTDeleteDefinition() throws Exception {
     setupStorage();
     HttpQuery query = NettyMocks.deleteQuery(tsdb, 
-      "/api/tree?definition=true", "{\"treeId\":1}");
+      "/api/tree", "{\"treeId\":1,\"definition\":true}");
     // make sure the root is there BEFORE we delete
     assertEquals(4, storage.numColumns(new byte[] { 0, 1 }));
     rpc.execute(tsdb, query);

File: test/core/TestTsdbQuery.java
Patch:
@@ -1341,9 +1341,9 @@ public void runRateCounterDefault() throws Exception {
     HashMap<String, String> tags = new HashMap<String, String>(1);
     tags.put("host", "web01");
     long timestamp = 1356998400;
-    tsdb.addPoint("sys.cpu.user", timestamp += 30, (long)(Long.MAX_VALUE - 55), tags)
+    tsdb.addPoint("sys.cpu.user", timestamp += 30, Long.MAX_VALUE - 55, tags)
       .joinUninterruptibly();
-    tsdb.addPoint("sys.cpu.user", timestamp += 30, (long)(Long.MAX_VALUE - 25), tags)
+    tsdb.addPoint("sys.cpu.user", timestamp += 30, Long.MAX_VALUE - 25, tags)
       .joinUninterruptibly();
     tsdb.addPoint("sys.cpu.user", timestamp += 30, 5, tags).joinUninterruptibly();
     

File: src/uid/UniqueId.java
Patch:
@@ -720,7 +720,7 @@ public Object call(final ArrayList<ArrayList<KeyValue>> rows) {
             + " in cache, but just scanned id=" + Arrays.toString(id));
         }
         suggestions.add(name);
-        if ((short) suggestions.size() > max_results) {  // We have enough.
+        if ((short) suggestions.size() >= max_results) {  // We have enough.
           return suggestions;
         }
         row.clear();  // free()

File: src/utils/DateTime.java
Patch:
@@ -183,9 +183,9 @@ public static final long parseDuration(final String duration) {
         }
         return interval * 1000;                    // seconds
       case 'm': return (interval * 60) * 1000;               // minutes
-      case 'h': return (interval * 3600) * 1000;             // hours
-      case 'd': return (interval * 3600 * 24) * 1000;        // days
-      case 'w': return (interval * 3600 * 24 * 7) * 1000;    // weeks
+      case 'h': return (interval * 3600L) * 1000;             // hours
+      case 'd': return (interval * 3600L * 24) * 1000;        // days
+      case 'w': return (interval * 3600L * 24 * 7) * 1000;    // weeks
       case 'n': return (interval * 3600L * 24 * 30) * 1000;   // month (average)
       case 'y': return (interval * 3600L * 24 * 365) * 1000;  // years (screw leap years)
     }

File: src/meta/TSMeta.java
Patch:
@@ -1035,9 +1035,9 @@ public final void setCreated(final long created) {
   }
   
   /** @param tsuid The TSUID of the timeseries. */
-	public final void setTSUID(final String tsuid) {
-		this.tsuid = tsuid;
-	}
+  public final void setTSUID(final String tsuid) {
+    this.tsuid = tsuid;
+  }
   
   /** @param custom optional key/value map */
   public final void setCustom(final HashMap<String, String> custom) {

File: src/uid/UniqueId.java
Patch:
@@ -720,7 +720,7 @@ public Object call(final ArrayList<ArrayList<KeyValue>> rows) {
             + " in cache, but just scanned id=" + Arrays.toString(id));
         }
         suggestions.add(name);
-        if ((short) suggestions.size() > max_results) {  // We have enough.
+        if ((short) suggestions.size() >= max_results) {  // We have enough.
           return suggestions;
         }
         row.clear();  // free()

File: src/utils/DateTime.java
Patch:
@@ -183,9 +183,9 @@ public static final long parseDuration(final String duration) {
         }
         return interval * 1000;                    // seconds
       case 'm': return (interval * 60) * 1000;               // minutes
-      case 'h': return (interval * 3600) * 1000;             // hours
-      case 'd': return (interval * 3600 * 24) * 1000;        // days
-      case 'w': return (interval * 3600 * 24 * 7) * 1000;    // weeks
+      case 'h': return (interval * 3600L) * 1000;             // hours
+      case 'd': return (interval * 3600L * 24) * 1000;        // days
+      case 'w': return (interval * 3600L * 24 * 7) * 1000;    // weeks
       case 'n': return (interval * 3600L * 24 * 30) * 1000;   // month (average)
       case 'y': return (interval * 3600L * 24 * 365) * 1000;  // years (screw leap years)
     }

File: src/core/IncomingDataPoint.java
Patch:
@@ -15,6 +15,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+
 /**
  * Bridging class that stores a normalized data point parsed from the "put" 
  * RPC methods and gets it ready for storage. Also has some helper methods that
@@ -28,6 +30,7 @@
  * overload with their own fields or parsing methods.
  * @since 2.0
  */
+@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
 public class IncomingDataPoint {
   /** The incoming metric name */
   private String metric;

File: src/core/RowSeq.java
Patch:
@@ -198,7 +198,7 @@ static long extractIntegerValue(final byte[] values,
       case 7: return Bytes.getLong(values, value_idx);
       case 3: return Bytes.getInt(values, value_idx);
       case 1: return Bytes.getShort(values, value_idx);
-      case 0: return values[value_idx] & 0xFF;
+      case 0: return values[value_idx];
     }
     throw new IllegalDataException("Integer value @ " + value_idx
                                    + " not on 8/4/2/1 bytes in "

File: src/core/RowSeq.java
Patch:
@@ -237,7 +237,7 @@ static long extractIntegerValue(final byte[] values,
       case 7: return Bytes.getLong(values, value_idx);
       case 3: return Bytes.getInt(values, value_idx);
       case 1: return Bytes.getShort(values, value_idx);
-      case 0: return values[value_idx] & 0xFF;
+      case 0: return values[value_idx];
     }
     throw new IllegalDataException("Integer value @ " + value_idx
                                    + " not on 8/4/2/1 bytes in "

File: src/tools/TreeSync.java
Patch:
@@ -353,7 +353,7 @@ private Scanner getScanner() throws HBaseException {
 
     LOG.debug("[" + thread_id + "] Start row: " + UniqueId.uidToString(start_row));
     LOG.debug("[" + thread_id + "] End row: " + UniqueId.uidToString(end_row));
-    final Scanner scanner = tsdb.getClient().newScanner(tsdb.uidTable());
+    final Scanner scanner = tsdb.getClient().newScanner(tsdb.metaTable());
     scanner.setStartKey(start_row);
     scanner.setStopKey(end_row);
     scanner.setFamily("name".getBytes(CHARSET));

File: src/tools/MetaSync.java
Patch:
@@ -469,10 +469,10 @@ public Deferred<Boolean> call(Exception e) throws Exception {
          * process the Scanner's limit in rows, wait for all of the storage
          * calls to complete, then continue on to the next set.
          */
-        final class ContinueCB implements Callback<Object, ArrayList<Object>> {
+        final class ContinueCB implements Callback<Object, ArrayList<Boolean>> {
 
           @Override
-          public Object call(ArrayList<Object> puts)
+          public Object call(ArrayList<Boolean> puts)
               throws Exception {
             storage_calls.clear();
             return scan();

File: src/tree/Branch.java
Patch:
@@ -340,7 +340,7 @@ public void prependParentPath(final Map<Integer, String> parent_path) {
    * @throws IllegalArgumentException if the tree ID was missing or data was 
    * missing
    */
-  public Deferred<ArrayList<Object>> storeBranch(final TSDB tsdb, 
+  public Deferred<ArrayList<Boolean>> storeBranch(final TSDB tsdb, 
       final Tree tree, final boolean store_leaves) {  
     if (tree_id < 1 || tree_id > 65535) {
       throw new IllegalArgumentException("Missing or invalid tree ID");

File: src/tsd/GraphHandler.java
Patch:
@@ -848,7 +848,8 @@ private static Query[] parseQuery(final TSDB tsdb, final HttpQuery query) {
       i--;  // Move to the last part (the metric name).
       final HashMap<String, String> parsedtags = new HashMap<String, String>();
       final String metric = Tags.parseWithMetric(parts[i], parsedtags);
-      final boolean rate = "rate".equals(parts[--i]);
+      final boolean rate = parts[--i].startsWith("rate");
+      final RateOptions rate_options = QueryRpc.parseRateOptions(rate, parts[i]); 
       if (rate) {
         i--;  // Move to the next part.
       }
@@ -943,6 +944,7 @@ private static String findGnuplotHelperScript() {
       + "  CLASSPATH=" + System.getProperty("java.class.path"));
   }
 
+
   // ---------------- //
   // Logging helpers. //
   // ---------------- //

File: test/core/TestCompactionQueue.java
Patch:
@@ -226,7 +226,7 @@ public void sortMsAndS() throws Exception {
 
     // We had one row to compact, so one put to do.
     verify(tsdb, times(1)).put(KEY, MockBase.concatByteArrays(qual1, qual3, qual2),
-                               MockBase.concatByteArrays(val1, val3, val2, ZERO));
+         MockBase.concatByteArrays(val1, val3, val2, new byte[] { 1 }));
     // And we had to delete individual cells.
     verify(tsdb, times(1)).delete(KEY, new byte[][] { qual1, qual3, qual2 });
   }
@@ -289,7 +289,7 @@ public void secondAndMs() throws Exception {
 
     // We had one row to compact, so one put to do.
     verify(tsdb, times(1)).put(KEY, MockBase.concatByteArrays(qual1, qual2),
-                               MockBase.concatByteArrays(val1, val2, ZERO));
+         MockBase.concatByteArrays(val1, val2, new byte[] { 1 }));
     // And we had to delete individual cells.
     verify(tsdb, times(1)).delete(KEY, new byte[][] { qual1, qual2 });
   }

File: test/core/TestCompactionQueue.java
Patch:
@@ -249,7 +249,7 @@ public void secondsOutOfOrder() throws Exception {
     compactionq.compact(kvs, annotations);
   }
   
-  @Test// (expected=IllegalDataException.class)
+  @Test (expected=IllegalDataException.class)
   public void msOutOfOrder() throws Exception {
     // all rows with an ms qualifier will go through the complex compaction 
     // process and they'll be sorted

File: src/uid/UniqueId.java
Patch:
@@ -437,7 +437,7 @@ public byte[] getOrCreateId(String name) throws HBaseException {
       addIdToCache(name, row);
       addNameToCache(row, name);
       
-      if (tsdb != null && tsdb.getConfig().enable_meta_tracking()) {
+      if (tsdb != null && tsdb.getConfig().enable_realtime_uid()) {
         final UIDMeta meta = new UIDMeta(type, row, name);
         meta.storeNew(tsdb);
         tsdb.indexUIDMeta(meta);

File: test/uid/TestUniqueId.java
Patch:
@@ -265,7 +265,7 @@ public void getOrCreateIdAssignIdWithSuccess() {
     uid = new UniqueId(client, table, kind, 3);
     final byte[] id = { 0, 0, 5 };
     final Config config = mock(Config.class);
-    when(config.enable_meta_tracking()).thenReturn(false);
+    when(config.enable_realtime_uid()).thenReturn(false);
     final TSDB tsdb = mock(TSDB.class);
     when(tsdb.getConfig()).thenReturn(config);
     uid.setTSDB(tsdb);
@@ -417,7 +417,7 @@ public void getOrCreateIdWithOverflow() {
   public void getOrCreateIdWithICVFailure() {
     uid = new UniqueId(client, table, kind, 3);
     final Config config = mock(Config.class);
-    when(config.enable_meta_tracking()).thenReturn(false);
+    when(config.enable_realtime_uid()).thenReturn(false);
     final TSDB tsdb = mock(TSDB.class);
     when(tsdb.getConfig()).thenReturn(config);
     uid.setTSDB(tsdb);
@@ -448,7 +448,7 @@ public void getOrCreateIdWithICVFailure() {
   public void getOrCreateIdPutsReverseMappingFirst() {
     uid = new UniqueId(client, table, kind, 3);
     final Config config = mock(Config.class);
-    when(config.enable_meta_tracking()).thenReturn(false);
+    when(config.enable_realtime_uid()).thenReturn(false);
     final TSDB tsdb = mock(TSDB.class);
     when(tsdb.getConfig()).thenReturn(config);
     uid.setTSDB(tsdb);

File: src/core/CompactionQueue.java
Patch:
@@ -892,8 +892,9 @@ public void run() {
           // or (2) we have too many rows to recompact already.
           // Note that in the case (2) we might not be able to flush anything
           // if the rows aren't old enough.
-          if (last_flush - now > Const.MAX_TIMESPAN  // (1)
+          if (now - last_flush > Const.MAX_TIMESPAN  // (1)
               || size > maxflushes) {                // (2)
+            last_flush = now;
             flush(now / 1000 - Const.MAX_TIMESPAN - 1, maxflushes);
             if (LOG.isDebugEnabled()) {
               final int newsize = size();

File: src/utils/Config.java
Patch:
@@ -334,6 +334,7 @@ protected void setDefaults() {
     default_map.put("tsd.http.show_stack_trace", "true");
     default_map.put("tsd.http.request.enable_chunked", "false");
     default_map.put("tsd.http.request.max_chunk", "4096");
+    default_map.put("tsd.http.request.cors_domains", "");
 
     for (Map.Entry<String, String> entry : default_map.entrySet()) {
       if (!properties.containsKey(entry.getKey()))

File: src/core/CompactionQueue.java
Patch:
@@ -879,8 +879,9 @@ public void run() {
           // or (2) we have too many rows to recompact already.
           // Note that in the case (2) we might not be able to flush anything
           // if the rows aren't old enough.
-          if (last_flush - now > Const.MAX_TIMESPAN  // (1)
+          if (now - last_flush > Const.MAX_TIMESPAN  // (1)
               || size > maxflushes) {                // (2)
+            last_flush = now;
             flush(now / 1000 - Const.MAX_TIMESPAN - 1, maxflushes);
             if (LOG.isDebugEnabled()) {
               final int newsize = size();

File: src/tsd/ConnectionManager.java
Patch:
@@ -55,7 +55,9 @@ public ConnectionManager() {
    * @param collector The collector to use.
    */
   public static void collectStats(final StatsCollector collector) {
-    collector.record("connectionmgr.connections", connections_established);
+    collector.record("connectionmgr.connections", channels.size(), "type=open");
+    collector.record("connectionmgr.connections", connections_established, 
+        "type=total");
     collector.record("connectionmgr.exceptions", exceptions_caught);
   }
 

File: src/meta/Annotation.java
Patch:
@@ -158,7 +158,6 @@ public Deferred<Boolean> syncToStorage(final TSDB tsdb,
     boolean has_changes = false;
     for (Map.Entry<String, Boolean> entry : changed.entrySet()) {
       if (entry.getValue()) {
-        System.out.println(entry.getKey());
         has_changes = true;
         break;
       }

File: test/tsd/TestTreeRpc.java
Patch:
@@ -393,7 +393,7 @@ public void handleBranchRoot() throws Exception {
     assertTrue(query.response().getContent().toString(MockBase.ASCII())
         .contains("\"displayName\":\"ROOT\""));
     assertTrue(query.response().getContent().toString(MockBase.ASCII())
-        .contains("\"branches\":["));
+        .contains("\"branches\":null"));
   }
   
   @Test

File: src/tsd/StaticFileRpc.java
Patch:
@@ -29,7 +29,7 @@ public void execute(final TSDB tsdb, final HttpQuery query)
     throws IOException {
     final String uri = query.request().getUri();
     if ("/favicon.ico".equals(uri)) {
-      query.sendFile(tsdb.getConfig().getString("tsd.http.staticroot") 
+      query.sendFile(tsdb.getConfig().getString("tsd.http.staticroot")
           + "/favicon.ico", 31536000 /*=1yr*/);
       return;
     }
@@ -43,8 +43,8 @@ public void execute(final TSDB tsdb, final HttpQuery query)
     }
     final int questionmark = uri.indexOf('?', 3);
     final int pathend = questionmark > 0 ? questionmark : uri.length();
-    query.sendFile(tsdb.getConfig().getString("tsd.http.staticroot") 
-                 + uri.substring(3, pathend),
+    query.sendFile(tsdb.getConfig().getString("tsd.http.staticroot")
+                 + uri.substring(2, pathend),  // Drop the "/s"
                    uri.contains("nocache") ? 0 : 31536000 /*=1yr*/);
   }
 }

File: src/tools/CliOptions.java
Patch:
@@ -128,7 +128,7 @@ static void overloadConfig(final ArgP argp, final Config config) {
         config.overrideConfig("tsd.storage.hbase.zk_quorum",
             entry.getValue());
       } else if (entry.getKey().toLowerCase().equals("--zkbasedir")) {
-        config.overrideConfig("tsd.storage.hbase.zk_base_dir",
+        config.overrideConfig("tsd.storage.hbase.zk_basedir",
             entry.getValue());
       } else if (entry.getKey().toLowerCase().equals("--port")) {
         config.overrideConfig("tsd.network.port", entry.getValue());

File: src/tree/Tree.java
Patch:
@@ -568,7 +568,8 @@ public Object call(ArrayList<ArrayList<KeyValue>> rows)
               tree.description = local_tree.description;
               tree.name = local_tree.name;
               tree.notes = local_tree.notes;
-              tree.strict_match = tree.strict_match;
+              tree.strict_match = local_tree.strict_match;
+              tree.enabled = local_tree.enabled;
               
               // WARNING: Since the JSON data in storage doesn't contain the tree
               // ID, we need to parse it from the row key

File: src/tsd/TreeRpc.java
Patch:
@@ -576,7 +576,7 @@ private Tree parseTree() {
       }
     }
     if (query.hasQueryStringParam("enabled")) {
-      final String enabled = query.getQueryStringParam("description");
+      final String enabled = query.getQueryStringParam("enabled");
       if (enabled.toLowerCase().equals("true")) {
         tree.setEnabled(true);
       } else {

File: src/meta/TSMeta.java
Patch:
@@ -774,7 +774,7 @@ private byte[] getStorageJSON() {
       if (custom == null) {
         json.writeNullField("custom");
       } else {
-        json.writeStartObject();
+        json.writeObjectFieldStart("custom");
         for (Map.Entry<String, String> entry : custom.entrySet()) {
           json.writeStringField(entry.getKey(), entry.getValue());
         }

File: src/uid/UniqueId.java
Patch:
@@ -386,7 +386,7 @@ public byte[] getOrCreateId(String name) throws HBaseException {
         addIdToCache(name, row);
         addNameToCache(row, name);
         
-        if (tsdb.getConfig().enable_meta_tracking()) {
+        if (tsdb != null && tsdb.getConfig().enable_meta_tracking()) {
           final UIDMeta meta = new UIDMeta(type, row, name);
           meta.storeNew(tsdb);
           tsdb.indexUIDMeta(meta);

File: src/utils/Config.java
Patch:
@@ -288,6 +288,9 @@ protected void setDefaults() {
     default_map.put("tsd.network.keep_alive", "true");
     default_map.put("tsd.network.reuse_address", "true");
     default_map.put("tsd.core.auto_create_metrics", "false");
+    default_map.put("tsd.core.plugin_path", "");
+    default_map.put("tsd.search.enable", "false");
+    default_map.put("tsd.search.plugin", "");
     default_map.put("tsd.storage.flush_interval", "1000");
     default_map.put("tsd.storage.hbase.data_table", "tsdb");
     default_map.put("tsd.storage.hbase.uid_table", "tsdb-uid");

File: test/core/TestTSQuery.java
Patch:
@@ -70,10 +70,12 @@ public void validateInvalidStart() {
   
   @Test
   public void validateNullEnd() {
+    PowerMockito.mockStatic(System.class);
+    when(System.currentTimeMillis()).thenReturn(1357300800000L);
     TSQuery q = this.getMetricForValidate();
     q.setEnd(null);
     q.validateAndSetQuery();
-    assertEquals(System.currentTimeMillis(), q.endTime());
+    assertEquals(1357300800000L, q.endTime());
   }
   
   @Test

File: test/tsd/TestPutRpc.java
Patch:
@@ -22,7 +22,6 @@
 import net.opentsdb.core.TSDB;
 import net.opentsdb.uid.NoSuchUniqueName;
 import net.opentsdb.utils.Config;
-import net.opentsdb.utils.JSONException;
 
 import org.jboss.netty.handler.codec.http.HttpResponseStatus;
 import org.junit.Before;

File: test/utils/TestPluginLoader.java
Patch:
@@ -80,7 +80,7 @@ public void loadSpecificPlugin() throws Exception {
         "net.opentsdb.plugin.DummyPluginA", 
         DummyPlugin.class);
     assertNotNull(plugin);
-    assertEquals(plugin.myname, "Dummy Plugin A");
+    assertEquals("Dummy Plugin A", plugin.myname);
   }
   
   @Test
@@ -106,7 +106,7 @@ public void loadPlugins() throws Exception {
     List<DummyPlugin> plugins = PluginLoader.loadPlugins(
         DummyPlugin.class);
     assertNotNull(plugins);
-    assertEquals(plugins.size(), 2);
+    assertEquals(2, plugins.size());
   }
   
   @Test

File: src/utils/Config.java
Patch:
@@ -278,6 +278,7 @@ protected void setDefaults() {
     default_map.put("tsd.storage.hbase.zk_quorum", "localhost");
     default_map.put("tsd.storage.hbase.zk_basedir", "/hbase");
     default_map.put("tsd.storage.enable_compaction", "true");
+    default_map.put("tsd.http.show_stack_trace", "true");
 
     for (Map.Entry<String, String> entry : default_map.entrySet()) {
       if (!properties.containsKey(entry.getKey()))

File: src/utils/Config.java
Patch:
@@ -231,7 +231,7 @@ public final boolean getBoolean(final String property) {
    * @return True if the property exists and has a value, not an empty string
    */
   public final boolean hasProperty(final String property) {
-    final String val = this.properties.get(property).toUpperCase();
+    final String val = this.properties.get(property);
     if (val == null)
       return false;
     if (val.isEmpty())

File: src/tsd/RpcHandler.java
Patch:
@@ -110,7 +110,7 @@ public void messageReceived(final ChannelHandlerContext ctx,
       if (message instanceof String[]) {
         handleTelnetRpc(msgevent.getChannel(), (String[]) message);
       } else if (message instanceof HttpRequest) {
-        handleHttpQuery(msgevent.getChannel(), (HttpRequest) message);
+        handleHttpQuery(tsdb, msgevent.getChannel(), (HttpRequest) message);
       } else {
         logError(msgevent.getChannel(), "Unexpected message type "
                  + message.getClass() + ": " + message);
@@ -146,9 +146,9 @@ private void handleTelnetRpc(final Channel chan, final String[] command) {
    * @param chan The channel on which the query was received.
    * @param req The parsed HTTP request.
    */
-  private void handleHttpQuery(final Channel chan, final HttpRequest req) {
+  private void handleHttpQuery(final TSDB tsdb, final Channel chan, final HttpRequest req) {
     http_rpcs_received.incrementAndGet();
-    final HttpQuery query = new HttpQuery(req, chan);
+    final HttpQuery query = new HttpQuery(tsdb, req, chan);
     if (req.isChunked()) {
       logError(query, "Received an unsupported chunked request: "
                + query.request());

File: src/core/TSDB.java
Patch:
@@ -57,7 +57,8 @@ public final class TSDB {
   static final boolean enable_compactions;
   static {
     final String compactions = System.getProperty("tsd.feature.compactions");
-    enable_compactions = compactions != null && !"false".equals(compactions);
+    // If not set, or set to anything but "false", defaults to true.
+    enable_compactions = !"false".equals(compactions);
   }
 
   /** Client for the HBase cluster to use.  */

File: src/tools/TextImporter.java
Patch:
@@ -147,7 +147,7 @@ public String toString() {
         }
         final WritableDataPoints dp = getDataPoints(tsdb, metric, tags);
         Deferred<Object> d;
-        if (value.indexOf('.') < 0) {  // integer value
+        if (Tags.looksLikeInteger(value)) {
           d = dp.addPoint(timestamp, Tags.parseLong(value));
         } else {  // floating point value
           d = dp.addPoint(timestamp, Float.parseFloat(value));

File: src/tsd/PutDataPointRpc.java
Patch:
@@ -115,7 +115,7 @@ private Deferred<Object> importDataPoint(final TSDB tsdb, final String[] words)
         Tags.parse(tags, words[i]);
       }
     }
-    if (value.indexOf('.') < 0) {  // integer value
+    if (Tags.looksLikeInteger(value)) {
       return tsdb.addPoint(metric, timestamp, Tags.parseLong(value), tags);
     } else {  // floating point value
       return tsdb.addPoint(metric, timestamp, Float.parseFloat(value), tags);

File: src/tsd/client/DateTimeBox.java
Patch:
@@ -75,7 +75,7 @@ public Date parse(final DateBox box,
             case 'y': interval *= 3600 * 24 * 365; break;  // years
           }
           final Date d = new Date();
-          d.setTime(d.getTime() - interval * 1000);
+          d.setTime(d.getTime() - interval * 1000L);
           return d;
         } else if (text.length() == 5) {  // "HH:MM"
           try {
@@ -156,7 +156,7 @@ public void onClick(final ClickEvent event) {
             }
             d = new Date();
           }
-          d.setTime(d.getTime() + seconds * 1000);
+          d.setTime(d.getTime() + seconds * 1000L);
           d.setSeconds(0);
           setDate(d);
         }

File: src/core/RowSeq.java
Patch:
@@ -198,7 +198,7 @@ static long extractIntegerValue(final byte[] values,
       case 7: return Bytes.getLong(values, value_idx);
       case 3: return Bytes.getInt(values, value_idx);
       case 1: return Bytes.getShort(values, value_idx);
-      case 0: return values[value_idx];
+      case 0: return values[value_idx] & 0xFF;
     }
     throw new IllegalDataException("Integer value @ " + value_idx
                                    + " not on 8/4/2/1 bytes in "

File: src/tsd/GraphHandler.java
Patch:
@@ -81,7 +81,6 @@ final class GraphHandler implements HttpRpc {
 
   /**
    * Constructor.
-   * @param tsdb The TSDB to use.
    */
   public GraphHandler() {
     // Gnuplot is mostly CPU bound and does only a little bit of IO at the

File: src/tsd/HttpRpc.java
Patch:
@@ -23,7 +23,6 @@ interface HttpRpc {
    * Executes this RPC.
    * @param tsdb The TSDB to use.
    * @param query The HTTP query to execute.
-   * @return A deferred result.
    */
   void execute(TSDB tsdb, HttpQuery query) throws IOException;
 

File: src/uid/UniqueId.java
Patch:
@@ -591,7 +591,7 @@ private byte[] hbaseGet(final byte[] key, final byte[] family,
    * Puts are synchronized.
    *
    * @param put The PutRequest to execute.
-   * @param attemps The maximum number of attempts.
+   * @param attempts The maximum number of attempts.
    * @param wait The initial amount of time in ms to sleep for after a
    * failure.  This amount is doubled after each failed attempt.
    * @throws HBaseException if all the attempts have failed.  This exception

File: src/core/TsdbQuery.java
Patch:
@@ -261,7 +261,7 @@ private TreeMap<byte[], Span> findSpans() throws HBaseException {
             datapoints = new Span(tsdb);
             spans.put(key, datapoints);
           }
-          datapoints.addRow(row);
+          datapoints.addRow(tsdb.compact(row));
           nrows++;
           starttime = System.nanoTime();
         }

File: src/tools/Fsck.java
Patch:
@@ -173,9 +173,10 @@ public String toString() {
                        + "ms (" + (100000 * 1000 / ping_start_time) + " KVs/s)");
               ping_start_time = now;
             }
+            // TODO(tsuna): Add support for compacted cells.
             if (kv.qualifier().length != 2) {
               LOG.warn("Ignoring unsupported KV with a qualifier of "
-                       + kv.qualifier().length + " bytes:" + kv);
+                       + kv.qualifier().length + " bytes: " + kv);
               continue;
             }
             final short qualifier = Bytes.getShort(kv.qualifier());

File: src/graph/Plot.java
Patch:
@@ -215,15 +215,16 @@ private void writeGnuplotScript(final String basepath,
         .append(Short.toString(height)).append("\n"
                 + "set xdata time\n"
                 + "set timefmt \"%s\"\n"
-                + "set format x \"").append(xFormat())
-                                    .append("\"\n"
                 + "set xtic rotate\n"
                 + "set output \"").append(basepath + ".png").append("\"\n"
                 + "set xrange [\"")
         .append(String.valueOf(start_time + utc_offset))
         .append("\":\"")
         .append(String.valueOf(end_time + utc_offset))
         .append("\"]\n");
+      if (!params.containsKey("format x")) {
+        gp.append("set format x \"").append(xFormat()).append("\"\n");
+      }
       final int nseries = datapoints.size();
       if (nseries > 0) {
         gp.write("set grid\n"

File: src/tsd/GraphHandler.java
Patch:
@@ -663,6 +663,9 @@ static void setPlotParams(final HttpQuery query, final Plot plot) {
     if ((value = popParam(querystring, "y2format")) != null) {
       params.put("format y2", stringify(value));
     }
+    if ((value = popParam(querystring, "xformat")) != null) {
+      params.put("format x", stringify(value));
+    }
     if ((value = popParam(querystring, "ylog")) != null) {
       params.put("logscale", "y");
     }

File: src/uid/TestUniqueId.java
Patch:
@@ -327,7 +327,7 @@ public void getOrCreateIdAssignIdWithRaceCondition() {
     when(client.get(anyGet()))
       .thenReturn(d);
 
-    final Answer the_race = new Answer<byte[]>() {
+    final Answer<byte[]> the_race = new Answer<byte[]>() {
       public byte[] answer(final InvocationOnMock unused_invocation) {
         // While answering A's first Get, B doest a full getOrCreateId.
         assertArrayEquals(id, uid_b.getOrCreateId("foo"));

File: src/core/IncomingDataPoints.java
Patch:
@@ -104,7 +104,7 @@ static void checkMetricAndTags(final String metric, final Map<String, String> ta
     Tags.validateString("metric name", metric);
     for (final Map.Entry<String, String> tag : tags.entrySet()) {
       Tags.validateString("tag name", tag.getKey());
-      Tags.validateString("tag name", tag.getValue());
+      Tags.validateString("tag value", tag.getValue());
     }
   }
 

File: src/core/TSDB.java
Patch:
@@ -232,7 +232,8 @@ public Deferred<Object> addPoint(final String metric,
     final short flags = Const.FLAG_FLOAT | 0x3;  // A float stored on 4 bytes.
     return addPointInternal(metric, timestamp,
                             // Note: this is actually on 8 bytes :(
-                            Bytes.fromLong(Float.floatToRawIntBits(value)),
+                            Bytes.fromLong(Float.floatToRawIntBits(value)
+                                           & 0x00000000FFFFFFFFL),
                             tags, flags);
   }
 

File: src/core/TsdbQuery.java
Patch:
@@ -401,7 +401,8 @@ private long getScanStartTime() {
     // but this doesn't really matter.
     // Additionally, in case our sample_interval is large, we need to look
     // even further before/after, so use that too.
-    return getStartTime() - Const.MAX_TIMESPAN * 2 - sample_interval;
+    final long ts = getStartTime() - Const.MAX_TIMESPAN * 2 - sample_interval;
+    return ts > 0 ? ts : 0;
   }
 
   /** Returns the UNIX timestamp at which we must stop scanning.  */

File: src/graph/Plot.java
Patch:
@@ -217,7 +217,7 @@ private void writeGnuplotScript(final String basepath,
     final PrintWriter gp = new PrintWriter(script_path);
     try {
       // XXX don't hardcode all those settings.  At least not like that.
-      gp.append("set terminal png size ")
+      gp.append("set term png small size ")
         // Why the fuck didn't they also add methods for numbers?
         .append(Short.toString(width)).append(",")
         .append(Short.toString(height)).append("\n"

File: src/tools/DumpSeries.java
Patch:
@@ -159,7 +159,7 @@ private static void formatKeyValue(final StringBuilder buf,
     }
     final byte[] qualifier = kv.qualifier();
     final short deltaflags = Bytes.getShort(qualifier);
-    final short delta = (short) (deltaflags >>> 4);
+    final short delta = (short) ((0x0000FFFF & deltaflags) >>> 4);
     final byte[] cell = kv.value();
     final long lvalue = Core.extractLValue(deltaflags, kv);
     if (importformat) {

File: src/core/Tags.java
Patch:
@@ -128,7 +128,7 @@ public static String parseWithMetric(final String metric,
   /**
    * Parses an integer value as a long from the given character sequence.
    * <p>
-   * This is equivalent to {@link Long.parseLong(String)} except it's up to
+   * This is equivalent to {@link Long#parseLong(String)} except it's up to
    * 100% faster on {@link String} and always works in O(1) space even with
    * {@link StringBuilder} buffers (where it's 2x to 5x faster).
    * @param s The character sequence containing the integer value to parse.

File: src/core/Const.java
Patch:
@@ -35,7 +35,7 @@ public final class Const {
   static final short FLAG_FLOAT = 0x8;
 
   /** Max time delta (in seconds) we can store in a column qualifier.  */
-  public static final int MAX_TIMESPAN = 600;
+  public static final short MAX_TIMESPAN = 3600;
 
   /**
    * Array containing the hexadecimal characters (0 to 9, A to F).

File: src/core/Tags.java
Patch:
@@ -104,7 +104,7 @@ public static String parseWithMetric(final String metric,
     final int len = metric.length();
     if (metric.charAt(len - 1) != '}') {  // "foo{"
       throw new IllegalArgumentException("Missing '}' at the end of: " + metric);
-    } else if (curly == len - 1) {  // "foo{}"
+    } else if (curly == len - 2) {  // "foo{}"
       return metric.substring(0, len - 2);
     }
     // substring the tags out of "foo{a=b,...,x=y}" and parse them.

File: src/core/RowSeq.java
Patch:
@@ -68,7 +68,6 @@ final class RowSeq implements DataPoints {
    */
   void setRow(final ArrayList<KeyValue> row) {
     final byte[] key = row.get(0).key();
-    final long base_time = Bytes.getUnsignedInt(key, tsdb.metrics.width());
 
     if (this.key == null) {
       this.key = key;

File: src/tsd/client/DateTimeBox.java
Patch:
@@ -108,7 +108,7 @@ public DateTimeBox() {
   /**
    * A {@link DatePicker} with a customized UI for time support.
    */
-  private final static class DateTimePicker extends DatePicker {
+  private static final class DateTimePicker extends DatePicker {
 
     /** DateTimeBox this picker belongs to.  */
     private DateTimeBox box;

File: src/uid/UniqueId.java
Patch:
@@ -392,7 +392,7 @@ public List<String> suggest(final String search) throws HBaseException {
           final byte[] key = row.get(0).key();
           final String name = fromBytes(key);
           final byte[] id = row.get(0).value();
-          final String cached_name = idCache.get(id);
+          final String cached_name = idCache.get(new String(id));
           if (cached_name == null) {
             addIdToCache(name, id);
             addNameToCache(id, name);

File: src/graph/Plot.java
Patch:
@@ -234,8 +234,7 @@ private void writeGnuplotScript(final String basepath,
       if (nseries > 0) {
         gp.write("set grid\n"
                  + "set key right box\n"
-                 + "set style data linespoints\n"
-                 + "set datafile missing '-'\n");
+                 + "set style data linespoints\n");
       } else {
         gp.write("unset key\n");
         if (params == null || !params.containsKey("label")) {

File: src/tsd/GraphHandler.java
Patch:
@@ -321,6 +321,7 @@ private String getGnuplotBasePath(final HttpQuery query) {
     final HashMap<String, List<String>> qs =
       new HashMap<String, List<String>>(q);
     // But first remove the parameters that don't influence the output.
+    qs.remove("png");
     qs.remove("json");
     qs.remove("ascii");
     return cachedir + Integer.toHexString(qs.hashCode());

File: src/core/TsdbQuery.java
Patch:
@@ -336,7 +336,9 @@ private DataPoints[] groupByAndAggregate(final TreeMap<byte[], Span> spans) {
         i += value_width;
       }
       if (value_id == null) {
-        LOG.info("Dropping span: " + Arrays.toString(row));
+        LOG.error("WTF?  Dropping span for row " + Arrays.toString(row)
+                 + " as it had no matching tag from the requested groups,"
+                 + " which is unexpected.  Query=" + this);
         continue;
       }
       //LOG.info("Span belongs to group " + Arrays.toString(group) + ": " + Arrays.toString(row));

File: src/core/RowSeq.java
Patch:
@@ -139,8 +139,8 @@ void addRow(final ArrayList<KeyValue> row) {
       qualifiers[index] = qualifier;
       values[index] = extractLValue(qualifier, kv);
       if (index > 0 && timestamp(index - 1) >= timestamp(index)) {
-        LOG.error("new timestamp = " + timestamp(index)
-                  + " is < previous=" + timestamp(index -1)
+        LOG.error("new timestamp = " + timestamp(index) + " (index=" + index
+                  + ") is < previous=" + timestamp(index - 1)
                   + " in addRow with kv=" + kv + " in row=" + row);
         // Undo what we've done so far.
         qualifiers = old_qualifiers;
@@ -160,7 +160,7 @@ void addRow(final ArrayList<KeyValue> row) {
    * different {@link RowSeq} instances.
    */
   static boolean canTimeDeltaFit(final long time_delta) {
-    return time_delta <= 1 << (Short.SIZE - Const.FLAG_BITS);
+    return time_delta < 1 << (Short.SIZE - Const.FLAG_BITS);
   }
 
   /**

File: src/core/IncomingDataPoints.java
Patch:
@@ -177,7 +177,7 @@ private Deferred<Object> addPointInternal(final long timestamp, final long value
         throw new IllegalArgumentException("New timestamp=" + timestamp
             + " is less than previous=" + last_ts
             + " when trying to add value=" + value + " to " + this);
-      } else if (timestamp - base_time > Const.MAX_TIMESPAN) {
+      } else if (timestamp - base_time >= Const.MAX_TIMESPAN) {
         // Need to start a new row as we've exceeded Const.MAX_TIMESPAN.
         // We force the starting timestamp to be on a MAX_TIMESPAN boundary
         // so that all TSDs create rows with the same base time.  Otherwise
@@ -236,7 +236,7 @@ private void grow() {
     // We can't have more than 1 value per second, so MAX_TIMESPAN values.
     final int new_size = Math.min(size * 2, Const.MAX_TIMESPAN);
     if (new_size == size) {
-      throw new AssertionError("Can't grow " + this + " larger.");
+      throw new AssertionError("Can't grow " + this + " larger than " + size);
     }
     values = Arrays.copyOf(values, new_size);
     qualifiers = Arrays.copyOf(qualifiers, new_size);

File: src/tsd/GraphHandler.java
Patch:
@@ -584,9 +584,9 @@ static void setPlotParams(final HttpQuery query, final Plot plot) {
    * graph from the file it produces, or if we have been interrupted.
    * @throws GnuplotException if Gnuplot returns non-zero.
    */
-  private static int runGnuplot(final HttpQuery query,
-                                final String basepath,
-                                final Plot plot) throws IOException {
+  static int runGnuplot(final HttpQuery query,
+                        final String basepath,
+                        final Plot plot) throws IOException {
     final int nplotted = plot.dumpToFiles(basepath);
     final long start_time = System.nanoTime();
     final Process gnuplot = new ProcessBuilder(

File: src/tsd/HttpQuery.java
Patch:
@@ -621,6 +621,7 @@ private void logError(final String msg, final Exception e) {
     + "A.l:link{color:#6f6f6f}"
     + "A.u:link{color:green}"
     + ".subg{background-color:#e2f4f7}"
+    + ".fwf{font-family:monospace;white-space:pre-wrap}"
     + "//--></style>";
 
   private static final String PAGE_HEADER_END_BODY_START =

File: src/tools/TSDMain.java
Patch:
@@ -114,7 +114,7 @@ public static void main(String[] args) {
       client.ensureTableExists(table).joinUninterruptibly();
       client.ensureTableExists(uidtable).joinUninterruptibly();
 
-      client.setFlushInterval((short) 100);  // XXX
+      client.setFlushInterval((short) 1000);  // XXX
       final TSDB tsdb = new TSDB(client, table, uidtable);
       final ServerBootstrap server = new ServerBootstrap(factory);
 

