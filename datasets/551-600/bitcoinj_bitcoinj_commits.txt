File: core/src/main/java/org/bitcoinj/crypto/ECKey.java
Patch:
@@ -559,7 +559,7 @@ public int hashCode() {
 
     /**
      * Signs the given hash and returns the R and S components as BigIntegers. In the Bitcoin protocol, they are
-     * usually encoded using ASN.1 format, so you want {@link ECKey.ECDSASignature#toASN1()}
+     * usually encoded using ASN.1 format, so you want {@link ECKey#toASN1()}
      * instead. However sometimes the independent components can be useful, for instance, if you're going to do
      * further EC maths on them.
      * @throws KeyCrypterException if this ECKey doesn't have a private part.

File: core/src/main/java/org/bitcoinj/utils/BtcFormat.java
Patch:
@@ -407,7 +407,7 @@
  * interpret every number as being denominated in the units that were specified when
  * constructing the instance doing the parsing.  This default behavior of {@link
  * BtcFixedFormat} can be overridden by setting a parsing pattern that includes a currency sign
- * using the {@link BtcFormat.Builder#pattern()} method.</p>
+ * using the {@link BtcFormat#pattern()} method.</p>
  *
  * <p>The {@link BtcAutoFormat#parse(String)} method of {@link BtcAutoFormat} (and of
  * {@link BtcAutoFormat} configured with applicable non-default pattern) will recognize a

File: core/src/main/java/org/bitcoinj/base/DefaultAddressParserProvider.java
Patch:
@@ -76,10 +76,11 @@ public AddressParser forNetwork(Network network) {
     }
 
     /**
-     * Dynamically create a new AddressParser using a snapshot of currently configured networks
-     * from Networks.get().
+     * Dynamically create a new {@link AddressParser} using a snapshot of currently configured networks
+     * from {@code Networks.get()}. This is only used by deprecated methods in {@link AddressParser}.
      * @return A backward-compatible parser
      */
+    @Deprecated
     static DefaultAddressParserProvider fromNetworks() {
         List<Network> nets = Networks.get().stream()
                 .map(NetworkParameters::network)

File: core/src/main/java/org/bitcoinj/core/StoredBlock.java
Patch:
@@ -126,9 +126,7 @@ public StoredBlock getPrev(BlockStore store) throws BlockStoreException {
 
     /** Serializes the stored block to a custom packed format. Used by {@link CheckpointManager}. */
     public void serializeCompact(ByteBuffer buffer) {
-        byte[] chainWorkBytes = getChainWork().toByteArray();
-        checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES, () ->
-                "ran out of space to store chain work!");
+        byte[] chainWorkBytes = ByteUtils.bigIntegerToBytes(getChainWork(), CHAIN_WORK_BYTES);
         if (chainWorkBytes.length < CHAIN_WORK_BYTES) {
             // Pad to the right size.
             buffer.put(EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length);

File: examples/src/main/java/org/bitcoinj/examples/Kit.java
Patch:
@@ -55,7 +55,7 @@ public static void main(String[] args) {
         });
 
         kit.wallet().addCoinsReceivedEventListener((wallet, tx, prevBalance, newBalance) -> {
-            System.out.println("-----> coins resceived: " + tx.getTxId());
+            System.out.println("-----> coins received: " + tx.getTxId());
             System.out.println("received: " + tx.getValue(wallet));
         });
 

File: core/src/main/java/org/bitcoinj/wallet/BasicKeyChain.java
Patch:
@@ -361,7 +361,7 @@ public List<Protos.Key> serializeToProtobuf() {
                     .setInitialisationVector(ByteString.copyFrom(data.initialisationVector)));
             // We don't allow mixing of encryption types at the moment.
             checkState(item.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES);
-            proto.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES);
+            proto.setType(Protos.Key.Type.ENCRYPTED);
         } else {
             final byte[] secret = item.getSecretBytes();
             // The secret might be missing in the case of a watching wallet, or a key for which the private key
@@ -401,9 +401,9 @@ private void deserializeFromProtobuf(List<Protos.Key> keys) throws UnreadableWal
             checkState(hashToKeys.isEmpty(), () ->
                     "tried to deserialize into a non-empty chain");
             for (Protos.Key key : keys) {
-                if (key.getType() != Protos.Key.Type.ORIGINAL && key.getType() != Protos.Key.Type.ENCRYPTED_SCRYPT_AES)
+                if (key.getType() != Protos.Key.Type.ORIGINAL && key.getType() != Protos.Key.Type.ENCRYPTED)
                     continue;
-                boolean encrypted = key.getType() == Protos.Key.Type.ENCRYPTED_SCRYPT_AES;
+                boolean encrypted = key.getType() == Protos.Key.Type.ENCRYPTED;
                 byte[] priv = key.hasSecretBytes() ? key.getSecretBytes().toByteArray() : null;
                 if (!key.hasPublicKey())
                     throw new UnreadableWalletException("Public key missing");

File: core/src/main/java/org/bitcoinj/base/internal/Buffers.java
Patch:
@@ -87,7 +87,7 @@ public static String readLengthPrefixedString(ByteBuffer buf) throws BufferUnder
     }
 
     /**
-     * Encode a given string using UTF-8. Then write the lnegth of the encoded bytes as a {@link VarInt}. Then write
+     * Encode a given string using UTF-8. Then write the length of the encoded bytes as a {@link VarInt}. Then write
      * the bytes themselves.
      *
      * @param buf buffer to write to

File: core/src/main/java/org/bitcoinj/base/LegacyAddress.java
Patch:
@@ -161,7 +161,7 @@ public static LegacyAddress fromScriptHash(Network network, byte[] hash160) thro
      * Construct a {@link LegacyAddress} from its base58 form.
      * 
      * @param params
-     *            expected network this address is valid for, or null if if the network should be derived from the
+     *            expected network this address is valid for, or null if the network should be derived from the
      *            base58
      * @param base58
      *            base58-encoded textual form of the address

File: core/src/main/java/org/bitcoinj/core/BitcoinSerializer.java
Patch:
@@ -135,7 +135,7 @@ public int getProtocolVersion() {
     }
 
     /**
-     * Writes message to to the output stream.
+     * Writes message to the output stream.
      */
     @Override
     public void serialize(String name, byte[] message, OutputStream out) throws IOException {
@@ -160,7 +160,7 @@ public void serialize(String name, byte[] message, OutputStream out) throws IOEx
     }
 
     /**
-     * Writes message to to the output stream.
+     * Writes message to the output stream.
      */
     @Override
     public void serialize(Message message, OutputStream out) throws IOException {

File: core/src/main/java/org/bitcoinj/core/MessageSerializer.java
Patch:
@@ -106,7 +106,7 @@ public abstract class MessageSerializer {
     public abstract void seekPastMagicBytes(ByteBuffer in) throws BufferUnderflowException;
 
     /**
-     * Writes message to to the output stream.
+     * Writes message to the output stream.
      * 
      * @throws UnsupportedOperationException if this serializer/deserializer
      * does not support serialization. This can occur either because it's a dummy
@@ -116,7 +116,7 @@ public abstract class MessageSerializer {
     public abstract void serialize(String name, byte[] message, OutputStream out) throws IOException, UnsupportedOperationException;
 
     /**
-     * Writes message to to the output stream.
+     * Writes message to the output stream.
      * 
      * @throws UnsupportedOperationException if this serializer/deserializer
      * does not support serialization. This can occur either because it's a dummy

File: core/src/main/java/org/bitcoinj/core/listeners/TransactionReceivedInBlockListener.java
Patch:
@@ -56,7 +56,7 @@ void receiveFromBlock(Transaction tx, StoredBlock block,
      * compared to the relativity count of another transaction received inside the same block. It is used to establish
      * an ordering of transactions relative to one another.</p>
      *
-     * <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
+     * <p>This method should return false if the given tx hash isn't known about, e.g. because the transaction was
      * a Bloom false positive. If it was known about and stored, it should return true. The caller may need to know
      * this to calculate the effective FP rate.</p>
      *

File: core/src/main/java/org/bitcoinj/crypto/ECKey.java
Patch:
@@ -1224,7 +1224,7 @@ public EncryptedData getEncryptedData() {
     }
 
     /**
-     * Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
+     * Returns the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
      * is not encrypted.
      */
     @Nullable

File: core/src/test/java/org/bitcoinj/crypto/ChildKeyDerivationTest.java
Patch:
@@ -305,7 +305,7 @@ public void reserialization() {
         assertEquals("Parent fingerprint of deserialized parentless private HD key is wrong",
                           key.getParentFingerprint(), 0xbef5a2f9);
 
-        // These encodings are of the the root key of that hierarchy
+        // These encodings are of the root key of that hierarchy
         assertEquals("Parent fingerprint of root node public HD key should be zero",
                           DeterministicKey.deserializeB58("xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB", MAINNET).getParentFingerprint(),
                           0);

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -485,7 +485,7 @@ public final DeterministicKeyChain getActiveKeyChain(ScriptType outputScriptType
 
     /**
      * Returns the key chain that's used for generation of default fresh/current keys. This is always the newest
-     * deterministic chain. If no deterministic chain is present but imported keys instead, a deterministic upgrate is
+     * deterministic chain. If no deterministic chain is present but imported keys instead, a deterministic upgrade is
      * tried.
      */
     public final DeterministicKeyChain getActiveKeyChain() {

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -2552,7 +2552,7 @@ private boolean isNotSpendingTxnsInConfidenceType(Transaction tx, ConfidenceType
 
     /**
      * Creates and returns a new List with the same txns as inputSet
-     * but txns are sorted by depencency (a topological sort).
+     * but txns are sorted by dependency (a topological sort).
      * If tx B spends tx A, then tx A should be before tx B on the returned List.
      * Several invocations to this method with the same inputSet could result in lists with txns in different order,
      * as there is no guarantee on the order of the returned txns besides what was already stated.

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -192,7 +192,7 @@ public void canonicalSignatureLowS() throws Exception {
         // First, a synthetic test.
         TransactionSignature sig = TransactionSignature.dummy();
         Script scriptHighS = ScriptBuilder
-                .createInputScript(new TransactionSignature(sig.r, ECKey.CURVE.getN().subtract(sig.s)));
+                .createInputScript(new TransactionSignature(sig.r, ECKey.ecDomainParameters().getN().subtract(sig.s)));
         assertEquals(RuleViolation.SIGNATURE_CANONICAL_ENCODING, DefaultRiskAnalysis.isInputStandard(
                 new TransactionInput(null, scriptHighS.program(), TransactionOutPoint.UNCONNECTED)));
 

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -628,9 +628,9 @@ else if (header == params.getBip32HeaderP2WPKHpub() || header == params.getBip32
     }
 
     /**
-     * Creates a new, empty wallet with a randomly chosen seed and no transactions. Make sure to provide for sufficient
-     * backup! Any keys will be derived from the seed. If you want to restore a wallet from disk instead, see
-     * {@link #loadFromFile}.
+     * Creates a new, empty wallet with no transactions. If you haven't already done so,
+     * make sure to provide for sufficient backup of the keys in the {@link KeyChainGroup}.
+     * To restore a wallet from disk instead, see {@link #loadFromFile}.
      * @param network network wallet will operate on
      * @param keyChainGroup keychain group to manage keychains
      */

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.Objects;
 
 // TODO: Finish adding Context c'tors to all the different objects so we can start deprecating the versions that take NetworkParameters.
-// TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (eg. Orchid, block stores, wallet, etc).
+// TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (e.g. Orchid, block stores, wallet, etc).
 // TODO: Auto-register the block chain object here, and then use it in the (newly deprecated) TransactionConfidence.getDepthInBlocks() method: the new version should take an AbstractBlockChain specifically.
 //       Also use the block chain object reference from the context in PeerGroup and remove the other constructors, as it's easy to forget to wire things up.
 // TODO: Move Threading.USER_THREAD to here and leave behind just a source code stub. Allow different instantiations of the library to use different user threads.

File: core/src/main/java/org/bitcoinj/crypto/HDKeyDerivation.java
Patch:
@@ -138,7 +138,7 @@ public static Stream<DeterministicKey> generate(DeterministicKey parent, int chi
 
     /**
      * @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
-     * if the resulting derived key is invalid (eg. private key == 0).
+     * if the resulting derived key is invalid (e.g. private key == 0).
      */
     public static DeterministicKey deriveChildKey(DeterministicKey parent, ChildNumber childNumber) throws HDDerivationException {
         if (!parent.hasPrivKey())

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroupStructure.java
Patch:
@@ -115,7 +115,7 @@ static HDPath purpose(ScriptType scriptType) {
 
     /**
      * Return coin type path component for a network id
-     * @param network network id string, eg. {@link BitcoinNetwork#ID_MAINNET}
+     * @param network network id string, e.g. {@link BitcoinNetwork#ID_MAINNET}
      */
     static ChildNumber coinType(Network network) {
         if (!(network instanceof BitcoinNetwork)) {

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -172,8 +172,6 @@ private static List<Transaction> readTransactions(ByteBuffer payload) throws Buf
         List<Transaction> transactions = new ArrayList<>(Math.min(numTransactions, Utils.MAX_INITIAL_ARRAY_LENGTH));
         for (int i = 0; i < numTransactions; i++) {
             Transaction tx = Transaction.read(payload);
-            // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
-            tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);
             transactions.add(tx);
         }
         return transactions;

File: core/src/main/java/org/bitcoinj/testing/FakeTxBuilder.java
Patch:
@@ -292,7 +292,7 @@ public static BlockPair createFakeBlock(BlockStore blockStore, StoredBlock previ
             Block b = previousBlock.createNextBlock(null, version, time, height);
             // Coinbase tx was already added.
             for (Transaction tx : transactions) {
-                tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);
+                tx.getConfidence().maybeSetSourceToNetwork();
                 b.addTransaction(tx);
             }
             b.solve();

File: core/src/test/java/org/bitcoinj/uri/BitcoinURITest.java
Patch:
@@ -455,9 +455,9 @@ public void testNoPaymentProtocolReq() throws Exception {
 
     @Test
     public void testUnescapedPaymentProtocolReq() throws Exception {
-        BitcoinURI uri = BitcoinURI.of("bitcoin:?r=https://merchant.com/pay.php?h%3D2a8628fc2fbe", TESTNET);
-        assertEquals("https://merchant.com/pay.php?h=2a8628fc2fbe", uri.getPaymentRequestUrl());
-        assertEquals(Collections.singletonList("https://merchant.com/pay.php?h=2a8628fc2fbe"), uri.getPaymentRequestUrls());
+        BitcoinURI uri = BitcoinURI.of("bitcoin:?r=https://merchant.example.com/pay?h%3D2a8628fc2fbe", TESTNET);
+        assertEquals("https://merchant.example.com/pay?h=2a8628fc2fbe", uri.getPaymentRequestUrl());
+        assertEquals(Collections.singletonList("https://merchant.example.com/pay?h=2a8628fc2fbe"), uri.getPaymentRequestUrls());
         assertNull(uri.getAddress());
     }
 }

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -143,8 +143,8 @@ public class WalletTool implements Callable<Integer> {
             "                       <key> CHECKSIG as the script.%n" +
             "                       If --payment-request is specified, a transaction will be created using the provided payment request. A payment request can be a local file, a bitcoin uri, or url to download the payment request, e.g.:%n" +
             "                         --payment-request=/path/to/my.bitcoinpaymentrequest%n" +
-            "                         --payment-request=bitcoin:?r=http://merchant.com/pay.php?123%n" +
-            "                         --payment-request=http://merchant.com/pay.php?123%n" +
+            "                         --payment-request=bitcoin:?r=https://merchant.example.com/pay?123%n" +
+            "                         --payment-request=https://merchant.example.com/pay?123%n" +
             "                       Other options include:%n" +
             "                         --fee-per-vkb or --fee-sat-per-vbyte sets the network fee, see below%n" +
             "                         --select-addr or --select-output to select specific outputs%n" +

File: core/src/main/java/org/bitcoinj/crypto/MnemonicCode.java
Patch:
@@ -139,7 +139,7 @@ public static byte[] toSeed(List<String> words, String passphrase) {
         // To create binary seed from mnemonic, we use PBKDF2 function
         // with mnemonic sentence (in UTF-8) used as a password and
         // string "mnemonic" + passphrase (again in UTF-8) used as a
-        // salt. Iteration count is set to 4096 and HMAC-SHA512 is
+        // salt. Iteration count is set to 2048 and HMAC-SHA512 is
         // used as a pseudo-random function. Desired length of the
         // derived key is 512 bits (= 64 bytes).
         //

File: core/src/main/java/org/bitcoinj/net/FilterMerger.java
Patch:
@@ -46,6 +46,7 @@ public class FilterMerger {
     // We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys
     private final int bloomFilterTweak = new Random().nextInt();
 
+    // TODO: Make final after deprecated setBloomFilterFPRate() method is removed
     private volatile double vBloomFilterFPRate;
     private int lastBloomFilterElementCount;
     private BloomFilter lastFilter;
@@ -108,6 +109,7 @@ public Result calculate(List<PeerFilterProvider> providerList) {
         }
     }
 
+    @Deprecated
     public void setBloomFilterFPRate(double bloomFilterFPRate) {
         this.vBloomFilterFPRate = bloomFilterFPRate;
     }

File: integration-test/src/test/java/org/bitcoinj/testing/TestWithPeerGroup.java
Patch:
@@ -113,7 +113,7 @@ protected void initPeerGroup() {
     protected final Semaphore jobBlocks = new Semaphore(0);
 
     private PeerGroup createPeerGroup(final ClientConnectionManager manager) {
-        return new PeerGroup(UNITTEST, blockChain, manager) {
+        return new PeerGroup(UNITTEST, blockChain, manager, PeerGroup.DEFAULT_BLOOM_FILTER_FP_RATE) {
             @Override
             protected ListeningScheduledExecutorService createPrivateExecutor() {
                 return MoreExecutors.listeningDecorator(new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory("PeerGroup test thread")) {

File: core/src/main/java/org/bitcoinj/crypto/PBKDF2SHA512.java
Patch:
@@ -41,7 +41,7 @@ public static byte[] derive(String P, String S, int c, int dkLen) {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 
         try {
-            int hLen = 20;
+            int hLen = 64;          // Length of HMAC result
 
             if (dkLen > ((Math.pow(2, 32)) - 1) * hLen) {
                 throw new IllegalArgumentException("derived key too long");

File: core/src/main/java/org/bitcoinj/wallet/CoinSelector.java
Patch:
@@ -31,6 +31,7 @@
  * may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
  * enough money in the wallet.
  */
+@FunctionalInterface
 public interface CoinSelector {
     /**
      * Creates a CoinSelection that tries to meet the target amount of value. The candidates list is given to

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -101,7 +101,7 @@ public static int compareByDepth(TransactionOutput a, TransactionOutput b) {
      */
     @Deprecated
     static void sortOutputs(ArrayList<TransactionOutput> outputs) {
-        Collections.sort(outputs, DefaultCoinSelector::compareByDepth);
+        outputs.sort(DefaultCoinSelector::compareByDepth);
     }
 
     /** Sub-classes can override this to just customize whether transactions are usable, but keep age sorting. */

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -96,7 +96,7 @@ public void depthOrdering() {
         ArrayList<TransactionOutput> candidates = new ArrayList<>();
         candidates.add(t2.getOutput(0));
         candidates.add(t1.getOutput(0));
-        DefaultCoinSelector.sortOutputs(candidates);
+        candidates.sort(DefaultCoinSelector::compareByDepth);
         assertEquals(t1.getOutput(0), candidates.get(0));
         assertEquals(t2.getOutput(0), candidates.get(1));
     }
@@ -117,7 +117,7 @@ public void coinAgeOrdering() {
         candidates.add(t3.getOutput(0));
         candidates.add(t2.getOutput(0));
         candidates.add(t1.getOutput(0));
-        DefaultCoinSelector.sortOutputs(candidates);
+        candidates.sort(DefaultCoinSelector::compareByDepth);
         assertEquals(t2.getOutput(0), candidates.get(0));
         assertEquals(t1.getOutput(0), candidates.get(1));
         assertEquals(t3.getOutput(0), candidates.get(2));

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/application/WalletApplication.java
Patch:
@@ -193,7 +193,6 @@ protected String suffixFromNetwork(BitcoinNetwork network) {
             case TESTNET -> "test";
             case SIGNET -> "signet";
             case REGTEST -> "regtest";
-            default -> throw new IllegalArgumentException("Unsupported network");
         };
     }
 }

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/controls/BitcoinAddressValidator.java
Patch:
@@ -29,7 +29,7 @@
  */
 public class BitcoinAddressValidator {
     private final AddressParser parser;
-    private Node[] nodes;
+    private final Node[] nodes;
 
 
     public BitcoinAddressValidator(AddressParser parser, TextField field, Node... nodes) {

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/controls/NotificationBarPane.java
Patch:
@@ -48,10 +48,10 @@ public class NotificationBarPane extends BorderPane {
     public static final Duration ANIM_IN_DURATION = GuiUtils.UI_ANIMATION_TIME.multiply(2);
     public static final Duration ANIM_OUT_DURATION = GuiUtils.UI_ANIMATION_TIME;
 
-    private HBox bar;
-    private Label label;
+    private final HBox bar;
+    private final Label label;
     private double barHeight;
-    private ProgressBar progressBar;
+    private final ProgressBar progressBar;
 
     public class Item {
         public final SimpleStringProperty label;

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/utils/easing/EasingInterpolator.java
Patch:
@@ -38,7 +38,7 @@ public abstract class EasingInterpolator extends Interpolator {
     /**
      * The easing mode.
      */
-    private ObjectProperty<EasingMode> easingMode = new SimpleObjectProperty<>(EasingMode.EASE_OUT);
+    private final ObjectProperty<EasingMode> easingMode = new SimpleObjectProperty<>(EasingMode.EASE_OUT);
 
     /**
      * Constructs the interpolator with a specific easing mode.

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/utils/easing/ElasticInterpolator.java
Patch:
@@ -49,12 +49,12 @@ public class ElasticInterpolator extends EasingInterpolator {
     /**
      * The amplitude.
      */
-    private DoubleProperty amplitude = new SimpleDoubleProperty(this, "amplitude", 1);
+    private final DoubleProperty amplitude = new SimpleDoubleProperty(this, "amplitude", 1);
 
     /**
      * The number of oscillations.
      */
-    private DoubleProperty oscillations = new SimpleDoubleProperty(this, "oscillations", 3);
+    private final DoubleProperty oscillations = new SimpleDoubleProperty(this, "oscillations", 3);
 
     /**
      * Default constructor. Initializes the interpolator with ease out mode.

File: wallettemplate/src/main/java/wallettemplate/WalletPasswordController.java
Patch:
@@ -61,7 +61,7 @@ public class WalletPasswordController implements OverlayController<WalletPasswor
     private OverlayableStackPaneController rootController;
     private OverlayableStackPaneController.OverlayUI<? extends OverlayController<WalletPasswordController>> overlayUI;
 
-    private SimpleObjectProperty<AesKey> aesKey = new SimpleObjectProperty<>();
+    private final SimpleObjectProperty<AesKey> aesKey = new SimpleObjectProperty<>();
 
     @Override
     public void initOverlay(OverlayableStackPaneController overlayableStackPaneController, OverlayableStackPaneController.OverlayUI<? extends OverlayController<WalletPasswordController>> ui) {

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/utils/easing/EasingInterpolator.java
Patch:
@@ -104,7 +104,6 @@ protected final double curve(final double v) {
             case EASE_BOTH -> (v <= 0.5)
                                 ? baseCurve(2 * v) / 2
                                 : (2 - baseCurve(2 * (1 - v))) / 2;
-            default -> baseCurve(v);
         };
     }
 }

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/utils/WTUtils.java
Patch:
@@ -66,7 +66,7 @@ public static <T> T ignoredAndLogged(UncheckedRun<T> runnable) {
         }
     }
 
-    public static boolean didThrow(UncheckedRun run) {
+    public static boolean didThrow(UncheckedRun<?> run) {
         try {
             run.run();
             return false;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -1700,11 +1700,11 @@ List<Protos.Key> serializeKeyChainGroupToProtobufInternal() {
      * @throws IOException           if an error occurs while saving
      */
     public void saveToFile(File tempFile, File destFile) throws IOException {
-        File tempParentFile = tempFile.getParentFile();
+        File tempParentFile = tempFile.getAbsoluteFile().getParentFile();
         if (!tempParentFile.exists()) {
             throw new FileNotFoundException(tempParentFile.getPath() + " (wallet directory not found)");
         }
-        File destParentFile = destFile.getParentFile();
+        File destParentFile = destFile.getAbsoluteFile().getParentFile();
         if (!destParentFile.exists()) {
             throw new FileNotFoundException(destParentFile.getPath() + " (wallet directory not found)");
         }

File: core/src/main/java/org/bitcoinj/net/discovery/DnsDiscovery.java
Patch:
@@ -43,7 +43,7 @@
  * However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().
  * </p>
  *
- * <p>DNS seeds do not attempt to enumerate every peer on the network. {@link DnsDiscovery#getPeers(long, long, TimeUnit)}
+ * <p>DNS seeds do not attempt to enumerate every peer on the network. {@link DnsDiscovery#getPeers(long, Duration)}
  * will return up to 30 random peers from the set of those returned within the timeout period. If you want more peers
  * to connect to, you need to discover them via other means (like addr broadcasts).</p>
  */

File: core/src/main/java/org/bitcoinj/utils/BtcFixedFormat.java
Patch:
@@ -36,8 +36,8 @@
  *
  * <p>By default, neither currency codes nor symbols are included in formatted values as
  * output, nor recognized in parsed values as input.  The can be overridden by applying a
- * custom pattern using either the {@link BtcFormat.Builder#localizedPattern} or
- * {@link BtcFormat.Builder#localizedPattern} methods, as described in the documentation for
+ * custom pattern using either the {@link BtcFormat.Builder#localizedPattern(String)} or
+ * {@link BtcFormat.Builder#localizedPattern(String)} methods, as described in the documentation for
  * the {@link BtcFormat.Builder} class.</p>
  *
  * <p>A more detailed explanation, including examples, is in the documentation for the

File: core/src/main/java/org/bitcoinj/store/SPVBlockStore.java
Patch:
@@ -108,7 +108,7 @@ public SPVBlockStore(NetworkParameters params, File file) throws BlockStoreExcep
      * it's missing. This operation will block on disk.
      * @param file file to use for the block store
      * @param capacity custom capacity in number of block headers
-     * @param grow wether or not to migrate an existing block store of different capacity
+     * @param grow whether or not to migrate an existing block store of different capacity
      * @throws BlockStoreException if something goes wrong
      */
     public SPVBlockStore(NetworkParameters params, File file, int capacity, boolean grow) throws BlockStoreException {

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4286,7 +4286,7 @@ public Transaction createSend(Address address, Coin value)
      *
      * @param address The Bitcoin address to send the money to.
      * @param value How much currency to send.
-     * @param allowUnconfirmed Wether to allow spending unconfirmed outputs.
+     * @param allowUnconfirmed Whether to allow spending unconfirmed outputs.
      * @return either the created Transaction or null if there are insufficient coins.
      * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
      * @throws DustySendRequested if the resultant transaction would violate the dust rules.

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -193,7 +193,7 @@ static String getPrefix(BitcoinNetwork network) {
      */
     static CoinSelector forwardingCoinSelector(Sha256Hash parentTxId) {
         return (target, candidates) -> candidates.stream()
-                .filter(output -> output.getParentTransactionHash().equals(parentTxId))
+                .filter(output -> output.getParentTransactionHash() != null && output.getParentTransactionHash().equals(parentTxId))
                 .collect(collectingAndThen(toList(), CoinSelection::new));
     }
 }

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -1447,7 +1447,7 @@ private void blockChainDownloadLocked(Sha256Hash toHash) {
                 throw new RuntimeException(e);
             }
         }
-        // Only add the locator if we didn't already do so. If the chain is < 50 blocks we already reached it.
+        // Only add the genesis hash to the locator if we didn't already do so. If the chain is < 100 blocks we already reached it.
         if (cursor != null)
             blockLocator = blockLocator.add(params.getGenesisBlock().getHash());
 

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -697,7 +697,7 @@ public Address parseAddress(String addressString) throws AddressFormatException
     }
 
     /**
-     * Gets the active keychains via {@link KeyChainGroup#getActiveKeyChains(long)}.
+     * Gets the active keychains via {@link KeyChainGroup#getActiveKeyChains(Instant)}.
      */
     public List<DeterministicKeyChain> getActiveKeyChains() {
         keyChainGroupLock.lock();
@@ -4456,7 +4456,7 @@ public Transaction sendCoins(Peer peer, SendRequest request)
      *     <li>Broadcast (buffer for send) the transaction to a single remote {@link org.bitcoinj.core.Peer}</li>
      *     <li>Mark {@link TransactionBroadcast#awaitSent()} as complete</li>
      *     <li>Wait for a number of remote peers to confirm they have received the broadcast</li>
-     *     <li>Mark {@link TransactionBroadcast#future()} as complete</li>
+     *     <li>Mark {@link TransactionBroadcast#awaitRelayed()} as complete</li>
      * </ol>
      * @param sendRequest transaction to send
      * @return A future for the transaction broadcast

File: core/src/main/java/org/bitcoinj/crypto/ECKey.java
Patch:
@@ -35,7 +35,7 @@
 import org.bitcoinj.base.VarInt;
 import org.bitcoinj.crypto.internal.CryptoUtils;
 import org.bitcoinj.crypto.utils.MessageVerifyUtils;
-import org.bitcoinj.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.bitcoinj.wallet.Wallet;
 import org.bouncycastle.asn1.ASN1InputStream;
 import org.bouncycastle.asn1.ASN1Integer;

File: core/src/main/java/org/bitcoinj/crypto/EncryptableItem.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.crypto;
 
-import org.bitcoinj.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos;
 
 import javax.annotation.Nullable;
 import java.time.Instant;

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypter.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.crypto;
 
-import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
+import org.bitcoinj.protobuf.wallet.Protos.Wallet.EncryptionType;
 
 /**
  * <p>A KeyCrypter can be used to encrypt and decrypt a message. The sequence of events to encrypt and then decrypt

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypterScrypt.java
Patch:
@@ -20,9 +20,9 @@
 import com.google.protobuf.ByteString;
 import org.bitcoinj.base.internal.Stopwatch;
 import org.bitcoinj.base.internal.TimeUtils;
-import org.bitcoinj.wallet.Protos;
-import org.bitcoinj.wallet.Protos.ScryptParameters;
-import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
+import org.bitcoinj.protobuf.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos.ScryptParameters;
+import org.bitcoinj.protobuf.wallet.Protos.Wallet.EncryptionType;
 import org.bouncycastle.crypto.BufferedBlockCipher;
 import org.bouncycastle.crypto.InvalidCipherTextException;
 import org.bouncycastle.crypto.engines.AESEngine;

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocol.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.common.base.MoreObjects;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;
-import org.bitcoin.protocols.payments.Protos;
+import org.bitcoinj.protobuf.payments.Protos;
 import org.bitcoinj.base.Address;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.base.internal.TimeUtils;

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentSession.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.protobuf.InvalidProtocolBufferException;
-import org.bitcoin.protocols.payments.Protos;
+import org.bitcoinj.protobuf.payments.Protos;
 import org.bitcoinj.base.Address;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.base.internal.TimeUtils;

File: core/src/main/java/org/bitcoinj/wallet/BasicKeyChain.java
Patch:
@@ -31,6 +31,7 @@
 import org.bitcoinj.utils.ListenerRegistration;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 
 import javax.annotation.Nullable;
 import java.time.Instant;

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -44,6 +44,7 @@
 import org.bitcoinj.utils.ListenerRegistration;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/wallet/DeterministicSeed.java
Patch:
@@ -37,6 +37,7 @@
 import java.util.Optional;
 
 import org.bitcoinj.base.internal.ByteUtils;
+import org.bitcoinj.protobuf.wallet.Protos;
 
 import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 import static org.bitcoinj.base.internal.Preconditions.checkState;

File: core/src/main/java/org/bitcoinj/wallet/KeyChain.java
Patch:
@@ -19,6 +19,7 @@
 import org.bitcoinj.core.BloomFilter;
 import org.bitcoinj.crypto.ECKey;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 
 import java.time.Instant;
 import java.util.List;

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -39,6 +39,7 @@
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.listeners.CurrentKeyChangeEventListener;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/wallet/SendRequest.java
Patch:
@@ -18,7 +18,7 @@
 package org.bitcoinj.wallet;
 
 import com.google.common.base.MoreObjects;
-import org.bitcoin.protocols.payments.Protos.PaymentDetails;
+import org.bitcoinj.protobuf.payments.Protos.PaymentDetails;
 import org.bitcoinj.base.Address;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.crypto.AesKey;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -89,7 +89,8 @@
 import org.bitcoinj.utils.ListenableCompletableFuture;
 import org.bitcoinj.utils.ListenerRegistration;
 import org.bitcoinj.utils.Threading;
-import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
+import org.bitcoinj.protobuf.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos.Wallet.EncryptionType;
 import org.bitcoinj.wallet.WalletTransaction.Pool;
 import org.bitcoinj.wallet.listeners.CurrentKeyChangeEventListener;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -43,7 +43,8 @@
 import org.bitcoinj.script.ScriptException;
 import org.bitcoinj.utils.ExchangeRate;
 import org.bitcoinj.base.utils.Fiat;
-import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
+import org.bitcoinj.protobuf.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos.Wallet.EncryptionType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -730,7 +731,7 @@ private void readTransaction(Protos.Transaction txProto) throws UnreadableWallet
         txMap.put(txProto.getHash(), tx);
     }
 
-    private WalletTransaction connectTransactionOutputs(final org.bitcoinj.wallet.Protos.Transaction txProto) throws UnreadableWalletException {
+    private WalletTransaction connectTransactionOutputs(final Protos.Transaction txProto) throws UnreadableWalletException {
         Transaction tx = txMap.get(txProto.getHash());
         final WalletTransaction.Pool pool;
         switch (txProto.getPool()) {

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentSessionTest.java
Patch:
@@ -18,7 +18,7 @@
 package org.bitcoinj.protocols.payments;
 
 import com.google.protobuf.ByteString;
-import org.bitcoin.protocols.payments.Protos;
+import org.bitcoinj.protobuf.payments.Protos;
 import org.bitcoinj.base.BitcoinNetwork;
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Address;

File: core/src/test/java/org/bitcoinj/store/WalletProtobufSerializerTest.java
Patch:
@@ -49,7 +49,7 @@
 import org.bitcoinj.wallet.DeterministicKeyChain;
 import org.bitcoinj.wallet.KeyChain;
 import org.bitcoinj.wallet.KeyChainGroup;
-import org.bitcoinj.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.bitcoinj.wallet.UnreadableWalletException;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.WalletExtension;

File: core/src/test/java/org/bitcoinj/wallet/BasicKeyChainTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.bitcoinj.crypto.KeyCrypterScrypt;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.listeners.AbstractKeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.junit.Before;
 import org.junit.Test;
 

File: core/src/test/java/org/bitcoinj/wallet/DeterministicKeyChainTest.java
Patch:
@@ -35,6 +35,7 @@
 import org.bitcoinj.utils.BriefLogFormatter;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.listeners.AbstractKeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.junit.Before;
 import org.junit.Test;
 

File: core/src/test/java/org/bitcoinj/wallet/KeyChainGroupTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.KeyChain.KeyPurpose;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.junit.Before;
 import org.junit.Test;
 

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -70,7 +70,8 @@
 import org.bitcoinj.base.utils.Fiat;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.KeyChain.KeyPurpose;
-import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
+import org.bitcoinj.protobuf.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos.Wallet.EncryptionType;
 import org.bitcoinj.wallet.Wallet.BalanceType;
 import org.bitcoinj.wallet.WalletTransaction.Pool;
 import org.easymock.EasyMock;

File: tools/src/main/java/org/bitcoinj/tools/PaymentProtocolTool.java
Patch:
@@ -23,7 +23,7 @@
 import org.bitcoinj.protocols.payments.PaymentSession;
 import org.bitcoinj.uri.BitcoinURI;
 import org.bitcoinj.uri.BitcoinURIParseException;
-import org.bitcoin.protocols.payments.Protos;
+import org.bitcoinj.protobuf.payments.Protos;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;

File: wallettemplate/src/main/java/wallettemplate/WalletSetPasswordController.java
Patch:
@@ -22,7 +22,7 @@
 import javafx.scene.layout.*;
 import org.bitcoinj.crypto.AesKey;
 import org.bitcoinj.crypto.*;
-import org.bitcoinj.wallet.*;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.bitcoinj.walletfx.application.WalletApplication;
 import org.bitcoinj.walletfx.overlay.OverlayController;
 import org.bitcoinj.walletfx.overlay.OverlayableStackPaneController;

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -65,7 +65,7 @@
 import org.bitcoinj.core.VerificationException;
 import org.bitcoinj.core.listeners.DownloadProgressTracker;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
-import org.bitcoinj.wallet.Protos;
+import org.bitcoinj.protobuf.wallet.Protos;
 import org.bitcoinj.wallet.SendRequest;
 import org.bitcoinj.wallet.UnreadableWalletException;
 import org.bitcoinj.wallet.Wallet;
@@ -243,7 +243,7 @@ public class WalletTool implements Callable<Integer> {
     private static AbstractBlockChain chain;
     private static PeerGroup peerGroup;
     private static Wallet wallet;
-    private static org.bitcoin.protocols.payments.Protos.PaymentRequest paymentRequest;
+    private static org.bitcoinj.protobuf.payments.Protos.PaymentRequest paymentRequest;
 
     public static class Condition {
         public enum Type {
@@ -822,7 +822,7 @@ private void sendPaymentRequest(String location, boolean verifyPki) {
                 System.exit(1);
             }
             try {
-                paymentRequest = org.bitcoin.protocols.payments.Protos.PaymentRequest.newBuilder().mergeFrom(stream).build();
+                paymentRequest = org.bitcoinj.protobuf.payments.Protos.PaymentRequest.newBuilder().mergeFrom(stream).build();
             } catch(IOException e) {
                 System.err.println("Failed to parse payment request from file " + e.getMessage());
                 System.exit(1);

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -234,7 +234,7 @@ public Coin getMinNonDustValue(Coin feePerKb) {
         // 294 satoshis at the default rate of 3000 sat/kB.
         long size = this.serialize().length;
         final Script script = getScriptPubKey();
-        if (ScriptPattern.isP2PKH(script) || ScriptPattern.isP2PK(script) || ScriptPattern.isP2SH(script))
+        if (ScriptPattern.isP2PKH(script) || ScriptPattern.isP2PK(script) || ScriptPattern.isP2SH(script) || ScriptPattern.isSentToMultisig(script))
             size += 32 + 4 + 1 + 107 + 4; // 148
         else if (ScriptPattern.isP2WH(script))
             size += 32 + 4 + 1 + (107 / 4) + 4; // 68

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentSession.java
Patch:
@@ -17,7 +17,6 @@
 package org.bitcoinj.protocols.payments;
 
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.util.concurrent.ListeningExecutorService;
 import com.google.protobuf.InvalidProtocolBufferException;
 import org.bitcoin.protocols.payments.Protos;
 import org.bitcoinj.base.Address;
@@ -50,6 +49,7 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
 
 /**
  * <p>Provides a standard implementation of the Payment Protocol (BIP 0070)</p>
@@ -79,7 +79,7 @@
  * @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki">BIP 0070</a>
  */
 public class PaymentSession {
-    private final static ListeningExecutorService executor = Threading.THREAD_POOL;
+    private final static ExecutorService executor = Threading.THREAD_POOL;
     private NetworkParameters params;
     private Protos.PaymentRequest paymentRequest;
     private Protos.PaymentDetails paymentDetails;

File: core/src/main/java/org/bitcoinj/net/discovery/MultiplexingDiscovery.java
Patch:
@@ -38,6 +38,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
+import static org.bitcoinj.base.BitcoinNetwork.REGTEST;
 import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 /**
@@ -89,7 +90,7 @@ public MultiplexingDiscovery(NetworkParameters params, List<PeerDiscovery> seeds
 
     private MultiplexingDiscovery(NetworkParameters params, List<PeerDiscovery> seeds, boolean parallelQueries,
                                   boolean shufflePeers) {
-        checkArgument(!seeds.isEmpty());
+        checkArgument(!seeds.isEmpty() || params.network() == REGTEST);
         this.netParams = params;
         this.seeds = seeds;
         this.parallelQueries = parallelQueries;

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -86,6 +86,7 @@
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
+import java.time.ZoneId;
 import java.time.format.DateTimeFormatter;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -1213,7 +1214,7 @@ private Optional<Instant> getCreationTime() {
         if (unixtime != null)
             return Optional.of(Instant.ofEpochSecond(unixtime));
         else if (date != null)
-            return Optional.of(Instant.from(date));
+            return Optional.of(date.atStartOfDay(ZoneId.systemDefault()).toInstant());
         else
             return Optional.empty();
     }

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -87,6 +87,7 @@
 import java.nio.charset.StandardCharsets;
 import java.security.SecureRandom;
 import java.text.ParseException;
+import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
 import java.time.format.DateTimeFormatter;
@@ -100,7 +101,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.LogManager;
 import java.util.stream.Collectors;
@@ -1003,7 +1003,7 @@ private void setup() throws BlockStoreException {
             chain = new FullPrunedBlockChain(params, wallet, (FullPrunedBlockStore) store);
         }
         // This will ensure the wallet is saved when it changes.
-        wallet.autosaveToFile(walletFile, 5, TimeUnit.SECONDS, null);
+        wallet.autosaveToFile(walletFile, Duration.ofSeconds(5), null);
         if (peerGroup == null) {
             peerGroup = new PeerGroup(net, chain);
         }
@@ -1069,7 +1069,7 @@ private void createWallet(Network network, File walletFile) throws IOException {
             System.err.println("Wallet creation requested but " + walletFile + " already exists, use --force");
             return;
         }
-        Instant creationTime = getCreationTime().orElse(Instant.ofEpochSecond(MnemonicCode.BIP39_STANDARDISATION_TIME_SECS));
+        Instant creationTime = getCreationTime().orElse(MnemonicCode.BIP39_STANDARDISATION_TIME);
         if (seedStr != null) {
             DeterministicSeed seed;
             // Parse as mnemonic code.

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -232,7 +232,7 @@ public Coin getMinNonDustValue(Coin feePerKb) {
         // so dust is a spendable txout less than
         // 98*dustRelayFee/1000 (in satoshis).
         // 294 satoshis at the default rate of 3000 sat/kB.
-        long size = this.bitcoinSerialize().length;
+        long size = this.serialize().length;
         final Script script = getScriptPubKey();
         if (ScriptPattern.isP2PKH(script) || ScriptPattern.isP2PK(script) || ScriptPattern.isP2SH(script))
             size += 32 + 4 + 1 + 107 + 4; // 148

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -5394,7 +5394,7 @@ private FeeCalculation calculateFee(SendRequest req, Coin value, boolean needAtL
             }
             for (int i = 0; i < req.tx.getOutputs().size(); i++) {
                 TransactionOutput output = TransactionOutput.read(
-                        ByteBuffer.wrap(req.tx.getOutput(i).bitcoinSerialize()), tx);
+                        ByteBuffer.wrap(req.tx.getOutput(i).serialize()), tx);
                 if (req.recipientsPayFees) {
                     // Subtract fee equally from each selected recipient
                     output.setValue(output.getValue().subtract(fee.divide(req.tx.getOutputs().size())));

File: core/src/main/java/org/bitcoinj/core/CheckpointManager.java
Patch:
@@ -145,7 +145,7 @@ private Sha256Hash readBinary(InputStream inputStream) throws IOException {
             for (int i = 0; i < numCheckpoints; i++) {
                 if (dis.read(buffer.array(), 0, size) < size)
                     throw new IOException("Incomplete read whilst loading checkpoints.");
-                StoredBlock block = StoredBlock.deserializeCompact(params.getDefaultSerializer(), buffer);
+                StoredBlock block = StoredBlock.deserializeCompact(buffer);
                 ((Buffer) buffer).position(0);
                 checkpoints.put(block.getHeader().time(), block);
             }
@@ -183,7 +183,7 @@ private Sha256Hash readTextual(InputStream inputStream) throws IOException {
                 ((Buffer) buffer).position(0);
                 buffer.put(bytes);
                 ((Buffer) buffer).position(0);
-                StoredBlock block = StoredBlock.deserializeCompact(params.getDefaultSerializer(), buffer);
+                StoredBlock block = StoredBlock.deserializeCompact(buffer);
                 checkpoints.put(block.getHeader().time(), block);
             }
             HashCode hash = hasher.hash();

File: core/src/main/java/org/bitcoinj/store/SPVBlockStore.java
Patch:
@@ -246,7 +246,7 @@ public StoredBlock get(Sha256Hash hash) throws BlockStoreException {
                 buffer.get(scratch);
                 if (Arrays.equals(scratch, targetHashBytes)) {
                     // Found the target.
-                    StoredBlock storedBlock = StoredBlock.deserializeCompact(params.getDefaultSerializer(), buffer);
+                    StoredBlock storedBlock = StoredBlock.deserializeCompact(buffer);
                     blockCache.put(hash, storedBlock);
                     return storedBlock;
                 }

File: core/src/test/java/org/bitcoinj/core/CheckpointManagerTest.java
Patch:
@@ -56,8 +56,6 @@ public void shouldThrowIllegalStateExceptionWithNoCheckpoints() throws IOExcepti
     @Test
     public void canReadTextualStream() throws IOException {
         expect(params.getId()).andReturn("org/bitcoinj/core/checkpointmanagertest/validTextualFormat");
-        expect(params.getSerializer()).andReturn(
-                new BitcoinSerializer(params, ProtocolVersion.CURRENT.intValue()));
         replay(params);
         new CheckpointManager(params, null);
     }

File: core/src/main/java/org/bitcoinj/core/BaseMessage.java
Patch:
@@ -62,9 +62,7 @@ public byte[] unsafeBitcoinSerialize() {
     /**
      * Serializes this message to the provided stream. If you just want the raw bytes use bitcoinSerialize().
      */
-    protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
-        log.error("Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass());
-    }
+    protected abstract void bitcoinSerializeToStream(OutputStream stream) throws IOException;
 
     /** @deprecated use {@link Transaction#getTxId()}, {@link Block#getHash()}, {@link FilteredBlock#getHash()} or {@link TransactionOutPoint#hash()} */
     @Deprecated

File: core/src/main/java/org/bitcoinj/core/ListMessage.java
Patch:
@@ -40,7 +40,7 @@ public abstract class ListMessage extends Message {
     // For some reason the compiler complains if this is inside InventoryItem
     protected List<InventoryItem> items;
 
-    public static final long MAX_INVENTORY_ITEMS = 50000;
+    public static final int MAX_INVENTORY_ITEMS = 50000;
 
     public ListMessage(ByteBuffer payload) throws ProtocolException {
         super(payload);
@@ -65,12 +65,12 @@ public void removeItem(int index) {
 
     @Override
     protected void parse(ByteBuffer payload) throws BufferUnderflowException, ProtocolException {
-        long arrayLen = VarInt.read(payload).longValue();
+        int arrayLen = VarInt.read(payload).intValue();
         if (arrayLen > MAX_INVENTORY_ITEMS)
             throw new ProtocolException("Too many items in INV message: " + arrayLen);
 
         // An inv is vector<CInv> where CInv is int+hash. The int is either 1 or 2 for tx or block.
-        items = new ArrayList<>((int) arrayLen);
+        items = new ArrayList<>(arrayLen);
         for (int i = 0; i < arrayLen; i++) {
             if (payload.remaining() < InventoryItem.MESSAGE_LENGTH) {
                 throw new ProtocolException("Ran off the end of the INV");

File: core/src/main/java/org/bitcoinj/testing/FakeTxBuilder.java
Patch:
@@ -204,7 +204,7 @@ public static Transaction[] createFakeTx(NetworkParameters params, Coin value,
      * Roundtrip a transaction so that it appears as if it has just come from the wire
      */
     public static Transaction roundTripTransaction(NetworkParameters params, Transaction tx) {
-        return new Transaction(params, tx.bitcoinSerialize());
+        return new Transaction(params, ByteBuffer.wrap(tx.bitcoinSerialize()));
     }
 
     public static class DoubleSpends {

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -294,7 +294,7 @@ protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest) {
     @Nullable
     private volatile Instant vKeyRotationTime = null;
 
-    protected final CoinSelector coinSelector = DefaultCoinSelector.get();
+    protected final CoinSelector coinSelector;
 
     // The wallet version. This is an int that can be used to track breaking changes in the wallet format.
     // You can also use it to detect wallets that come from the future (ie they contain features you
@@ -511,6 +511,7 @@ else if (header == params.getBip32HeaderP2WPKHpub() || header == params.getBip32
      */
     public Wallet(NetworkParameters params, KeyChainGroup keyChainGroup) {
         this.params = Objects.requireNonNull(params);
+        this.coinSelector = DefaultCoinSelector.get(params.network());
         this.keyChainGroup = Objects.requireNonNull(keyChainGroup);
         watchedScripts = new HashSet<>();
         unspent = new HashMap<>();

File: core/src/main/java/org/bitcoinj/wallet/AllowUnconfirmedCoinSelector.java
Patch:
@@ -28,7 +28,7 @@ protected boolean shouldSelect(Transaction tx) {
         return true;
     }
 
-    public static AllowUnconfirmedCoinSelector get() {
+    public static CoinSelector get() {
         return new AllowUnconfirmedCoinSelector();
     }
 }

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -104,7 +104,7 @@ public static boolean isSelectable(Transaction tx) {
                (confidence.numBroadcastPeers() > 0 || tx.getParams().network() == BitcoinNetwork.REGTEST);
     }
 
-    public static DefaultCoinSelector get() {
+    public static CoinSelector get() {
         return new DefaultCoinSelector();
     }
 }

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -88,7 +88,7 @@ public void depthOrdering() {
         Transaction t2 = Objects.requireNonNull(sendMoneyToWallet(AbstractBlockChain.NewBlockType.BEST_CHAIN, COIN));
 
         // Check we selected just the oldest one.
-        DefaultCoinSelector selector = DefaultCoinSelector.get();
+        CoinSelector selector = DefaultCoinSelector.get();
         CoinSelection selection = selector.select(COIN, wallet.calculateAllSpendCandidates());
         assertTrue(selection.outputs().contains(t1.getOutputs().get(0)));
         assertEquals(COIN, selection.totalValue());
@@ -136,7 +136,7 @@ public void identicalInputs() {
         );
         t.getConfidence().setConfidenceType(TransactionConfidence.ConfidenceType.BUILDING);
 
-        DefaultCoinSelector selector = DefaultCoinSelector.get();
+        CoinSelector selector = DefaultCoinSelector.get();
         CoinSelection selection = selector.select(COIN.multiply(2), outputs);
 
         assertTrue(selection.outputs().size() == 4);

File: core/src/main/java/org/bitcoinj/base/internal/TimeUtils.java
Patch:
@@ -72,6 +72,8 @@ public static Instant currentTime() {
 
     /**
      * Returns elapsed time between given start and current time as a Duration.
+     * <p>
+     * Note that this method is affected by the mock clock. If you want to raise real debug data use {@link Stopwatch}.
      */
     public static Duration elapsedTime(Instant start) {
         return Duration.between(start, currentTime());

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypterScrypt.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.crypto;
 
 import com.google.protobuf.ByteString;
+import org.bitcoinj.base.internal.Stopwatch;
 import org.bitcoinj.base.internal.TimeUtils;
 import org.bitcoinj.wallet.Protos;
 import org.bitcoinj.wallet.Protos.ScryptParameters;
@@ -150,9 +151,9 @@ public AesKey deriveKey(CharSequence password) throws KeyCrypterException {
                 log.warn("You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack.");
             }
 
-            Instant start = TimeUtils.currentTime();
+            Stopwatch watch = Stopwatch.start();
             byte[] keyBytes = SCrypt.generate(passwordBytes, salt, (int) scryptParameters.getN(), scryptParameters.getR(), scryptParameters.getP(), KEY_LENGTH);
-            log.info("Deriving key took {} ms for {}.", TimeUtils.elapsedTime(start).toMillis(), scryptParametersString());
+            log.info("Deriving key took {} for {}.", watch, scryptParametersString());
             return new AesKey(keyBytes);
         } catch (Exception e) {
             throw new KeyCrypterException("Could not generate key from password and salt.", e);

File: core/src/main/java/org/bitcoinj/crypto/MnemonicCode.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.base.internal.PlatformUtils;
+import org.bitcoinj.base.internal.Stopwatch;
 import org.bitcoinj.base.internal.TimeUtils;
 import org.bitcoinj.base.internal.StreamUtils;
 import org.bitcoinj.base.internal.InternalUtils;
@@ -145,9 +146,9 @@ public static byte[] toSeed(List<String> words, String passphrase) {
         String pass = InternalUtils.SPACE_JOINER.join(words);
         String salt = "mnemonic" + passphrase;
 
-        Instant start = TimeUtils.currentTime();
+        Stopwatch watch = Stopwatch.start();
         byte[] seed = PBKDF2SHA512.derive(pass, salt, PBKDF2_ROUNDS, 64);
-        log.info("PBKDF2 took {} ms", TimeUtils.elapsedTime(start).toMillis());
+        log.info("PBKDF2 took {}", watch);
         return seed;
     }
 

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.protobuf.ByteString;
 import org.bitcoinj.base.Network;
 import org.bitcoinj.base.ScriptType;
+import org.bitcoinj.base.internal.Stopwatch;
 import org.bitcoinj.base.internal.TimeUtils;
 import org.bitcoinj.crypto.AesKey;
 import org.bitcoinj.base.internal.ByteUtils;
@@ -1272,12 +1273,12 @@ private List<DeterministicKey> maybeLookAhead(DeterministicKey parent, int issue
         log.info("{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children",
                 limit, parent.getPathAsString(), issued, lookaheadSize, lookaheadThreshold, numChildren);
 
-        Instant start = TimeUtils.currentTime();
+        Stopwatch watch = Stopwatch.start();
         List<DeterministicKey> result = HDKeyDerivation.generate(parent, numChildren)
                 .limit(limit)
                 .map(DeterministicKey::dropPrivateBytes)
                 .collect(StreamUtils.toUnmodifiableList());
-        log.info("Took {} ms", TimeUtils.elapsedTime(start).toMillis());
+        log.info("Took {}", watch);
         return result;
     }
 

File: core/src/main/java/org/bitcoinj/wallet/WalletFiles.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.wallet;
 
+import org.bitcoinj.base.internal.Stopwatch;
 import org.bitcoinj.base.internal.TimeUtils;
 import org.bitcoinj.utils.ContextPropagatingThreadFactory;
 import org.slf4j.Logger;
@@ -137,7 +138,7 @@ public void saveNow() throws IOException {
     }
 
     private void saveNowInternal() throws IOException {
-        Instant start = TimeUtils.currentTime();
+        Stopwatch watch = Stopwatch.start();
         File directory = file.getAbsoluteFile().getParentFile();
         if (!directory.exists()) {
             throw new FileNotFoundException(directory.getPath() + " (wallet directory not found)");
@@ -149,7 +150,7 @@ private void saveNowInternal() throws IOException {
         wallet.saveToFile(temp, file);
         if (listener != null)
             listener.onAfterAutoSave(file);
-        log.info("Save completed in {} ms", TimeUtils.elapsedTime(start).toMillis());
+        log.info("Save completed in {}", watch);
     }
 
     /** Queues up a save in the background. Useful for not very important wallet changes. */

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -344,9 +344,10 @@ public String toString() {
             } else if (ScriptPattern.isP2PK(script)) {
                 buf.append(" to pubkey ").append(ByteUtils.formatHex(ScriptPattern.extractKeyFromP2PK(script)));
             } else if (ScriptPattern.isSentToMultisig(script)) {
-                final StringBuilder append = buf.append(" to multisig");
-            } else
+                buf.append(" to multisig");
+            } else {
                 buf.append(" (unknown type)");
+            }
             buf.append(" script:").append(script);
             return buf.toString();
         } catch (ScriptException e) {

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -5358,7 +5358,7 @@ private FeeCalculation calculateFee(SendRequest req, Coin value, boolean needAtL
 
     private void addSuppliedInputs(Transaction tx, List<TransactionInput> originalInputs) {
         for (TransactionInput input : originalInputs)
-            tx.addInput(new TransactionInput(tx, input.bitcoinSerialize()));
+            tx.addInput(new TransactionInput(tx, ByteBuffer.wrap(input.bitcoinSerialize())));
     }
 
     private int estimateVirtualBytesForSigning(CoinSelection selection) {

File: core/src/main/java/org/bitcoinj/core/PartialMerkleTree.java
Patch:
@@ -130,9 +130,7 @@ protected void parse(ByteBuffer payload) throws BufferUnderflowException, Protoc
         hashes = new ArrayList<>(Math.min(nHashes, Utils.MAX_INITIAL_ARRAY_LENGTH));
         for (int i = 0; i < nHashes; i++)
             hashes.add(Sha256Hash.read(payload));
-
-        int nFlagBytes = VarInt.read(payload).intValue();
-        matchedChildBits = Buffers.readBytes(payload, nFlagBytes);
+        matchedChildBits = Buffers.readLengthPrefixedBytes(payload);
     }
 
     // Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -726,9 +726,7 @@ private void parseWitnesses(ByteBuffer payload) throws BufferUnderflowException,
             TransactionWitness witness = new TransactionWitness(pushCount);
             getInput(i).setWitness(witness);
             for (int y = 0; y < pushCount; y++) {
-                VarInt pushSizeVarInt = VarInt.read(payload);
-                int pushSize = pushSizeVarInt.intValue();
-                byte[] push = Buffers.readBytes(payload, pushSize);
+                byte[] push = Buffers.readLengthPrefixedBytes(payload);
                 witness.setPush(y, push);
             }
         }

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -154,8 +154,7 @@ public int getIndex() {
     @Override
     protected void parse(ByteBuffer payload) throws BufferUnderflowException, ProtocolException {
         outpoint = new TransactionOutPoint(payload);
-        int scriptLen = VarInt.read(payload).intValue();
-        scriptBytes = Buffers.readBytes(payload, scriptLen);
+        scriptBytes = Buffers.readLengthPrefixedBytes(payload);
         sequence = ByteUtils.readUint32(payload);
     }
 

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -129,8 +129,7 @@ protected void parse(ByteBuffer payload) throws BufferUnderflowException, Protoc
         // Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
         // SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
         check(value >= 0 || value == -1, () -> new ProtocolException("value out of range: " + value));
-        int scriptLen = VarInt.read(payload).intValue();
-        scriptBytes = Buffers.readBytes(payload, scriptLen);
+        scriptBytes = Buffers.readLengthPrefixedBytes(payload);
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -245,7 +245,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
         this.getAddrFutures = new LinkedList<>();
         this.fastCatchupTime = params.getGenesisBlock().time();
         this.pendingPings = new CopyOnWriteArrayList<>();
-        this.vMinProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG);
+        this.vMinProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.MINIMUM);
         this.wallets = new CopyOnWriteArrayList<>();
         this.context = Context.get();
 

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -555,7 +555,7 @@ public EnumSet<Script.VerifyFlag> getTransactionVerificationFlags(final Block bl
     public static enum ProtocolVersion {
         MINIMUM(70000),
         PONG(60001),
-        BLOOM_FILTER(70000), // BIP37
+        BLOOM_FILTER(70001), // BIP37
         BLOOM_FILTER_BIP111(70011), // BIP111
         WITNESS_VERSION(70012),
         FEEFILTER(70013), // BIP133

File: integration-test/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -732,10 +732,10 @@ public void waitForPeersWithServiceFlags() throws Exception {
         CompletableFuture<List<Peer>> future = peerGroup.waitForPeersWithServiceMask(2, 3);
 
         VersionMessage ver1 = new VersionMessage(UNITTEST, 10);
-        ver1.clientVersion = 70000;
+        ver1.clientVersion = 70001;
         ver1.localServices = Services.of(Services.NODE_NETWORK);
         VersionMessage ver2 = new VersionMessage(UNITTEST, 10);
-        ver2.clientVersion = 70000;
+        ver2.clientVersion = 70001;
         ver2.localServices = Services.of(Services.NODE_NETWORK | 2);
         peerGroup.start();
         assertFalse(future.isDone());

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -150,7 +150,7 @@ public TransactionInput(NetworkParameters params, Transaction parentTransaction,
     }
 
     /**
-     * Gets the index of this input in the parent transaction, or throws if this input is free standing. Iterates
+     * Gets the index of this input in the parent transaction, or throws if this input is freestanding. Iterates
      * over the parents list to discover this.
      */
     public int getIndex() {

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -180,7 +180,7 @@ public void setValue(Coin value) {
     }
 
     /**
-     * Gets the index of this output in the parent transaction, or throws if this output is free standing. Iterates
+     * Gets the index of this output in the parent transaction, or throws if this output is freestanding. Iterates
      * over the parents list to discover this.
      */
     public int getIndex() {

File: core/src/main/java/org/bitcoinj/core/UTXO.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * A UTXO message contains the information necessary to check a spending transaction.
  * It avoids having to store the entire parentTransaction just to get the hash and index.
- * Useful when working with free standing outputs.
+ * Useful when working with freestanding outputs.
  */
 public class UTXO {
     private final Coin value;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4755,7 +4755,7 @@ public void setUTXOProvider(@Nullable UTXOProvider provider) {
 
     // ***************************************************************************************************************
     /**
-     * A custom {@link TransactionOutput} that is free standing. This contains all the information
+     * A custom {@link TransactionOutput} that is freestanding. This contains all the information
      * required for spending without actually having all the linked data (i.e parent tx).
      *
      */
@@ -4764,9 +4764,9 @@ private static class FreeStandingTransactionOutput extends TransactionOutput {
         private final int chainHeight;
 
         /**
-         * Construct a free standing Transaction Output.
+         * Construct a freestanding Transaction Output.
          * @param params The network parameters.
-         * @param output The stored output (free standing).
+         * @param output The stored output (freestanding).
          */
         public FreeStandingTransactionOutput(NetworkParameters params, UTXO output, int chainHeight) {
             super(params, null, output.getValue(), output.getScript().getProgram());

File: core/src/main/java/org/bitcoinj/base/exceptions/AddressFormatException.java
Patch:
@@ -117,7 +117,7 @@ public WrongNetwork(int versionHeader) {
         }
 
         public WrongNetwork(String hrp) {
-            super("Human readable part of address did not match acceptable HRPs for network: " + hrp);
+            super("human-readable part of address did not match acceptable HRPs for network: " + hrp);
         }
     }
 }

File: core/src/main/java/org/bitcoinj/core/AbstractBlockChain.java
Patch:
@@ -1032,7 +1032,7 @@ public boolean isOrphan(Sha256Hash block) {
 
     /**
      * Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
-     * block. This is useful for turning transaction lock times into human readable times. Note that a height in
+     * block. This is useful for turning transaction lock times into human-readable times. Note that a height in
      * the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
      * through the chain to obtain the right answer).
      * @param height block time to estimate

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -793,7 +793,7 @@ public String toString() {
     }
 
     /**
-     * A human readable version of the transaction useful for debugging. The format is not guaranteed to be stable.
+     * A human-readable version of the transaction useful for debugging. The format is not guaranteed to be stable.
      * @param chain If provided, will be used to estimate lock times (if set). Can be null.
      */
     public String toString(@Nullable AbstractBlockChain chain, @Nullable CharSequence nullableIndent) {

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -537,7 +537,7 @@ public int hashCode() {
     }
 
     /**
-     * Returns a human readable debug string.
+     * Returns a human-readable debug string.
      */
     @Override
     public String toString() {

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -339,7 +339,7 @@ else if (ScriptPattern.isP2WPKH(script))
     }
 
     /**
-     * Returns a human readable debug string.
+     * Returns a human-readable debug string.
      */
     @Override
     public String toString() {

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -191,7 +191,7 @@ public HDPath getPath() {
     }
 
     /**
-     * Returns the path of this key as a human readable string starting with M or m to indicate the master key.
+     * Returns the path of this key as a human-readable string starting with M or m to indicate the master key.
      */
     public String getPathAsString() {
         return getPath().toString();

File: core/src/main/java/org/bitcoinj/crypto/ECKey.java
Patch:
@@ -872,7 +872,7 @@ public String signMessage(String message, @Nullable AesKey aesKey, ScriptType sc
      * format generated by signmessage/verifymessage RPCs and GUI menu options. They are intended for humans to verify
      * their communications with each other, hence the base64 format and the fact that the input is text.
      *
-     * @param message Some piece of human readable text.
+     * @param message Some piece of human-readable text.
      * @param signatureBase64 The Bitcoin-format message signature in base64
      * @throws SignatureException If the public key could not be recovered or if there was a signature format error.
      */

File: core/src/main/java/org/bitcoinj/params/Networks.java
Patch:
@@ -31,7 +31,7 @@
  * Utility class that holds all the registered {@link NetworkParameters} types used for address auto discovery.
  * By default only {@link MainNetParams} and {@link TestNet3Params} are used. If you want to use {@link RegTestParams}
  * or {@link UnitTestParams} use {@code register} and then {@code unregister} the {@code TestNet3Params} as they don't
- * have their own Base58 version/type code (although for {@link SegwitAddress} the human readable
+ * have their own Base58 version/type code (although for {@link SegwitAddress} the human-readable
  * parts for RegTest and TestNet are different.)
  */
 public class Networks {

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentSessionTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.bitcoinj.base.Address;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.base.internal.TimeUtils;
+import org.bitcoinj.core.Context;
 import org.bitcoinj.crypto.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Transaction;
@@ -69,6 +70,7 @@ public class PaymentSessionTest {
 
     @Before
     public void setUp() {
+        Context.propagate(new Context());
         serverKey = new ECKey();
         tx = new Transaction(TESTNET);
         outputToMe = new TransactionOutput(TESTNET, tx, amount, serverKey);

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -61,9 +61,9 @@ public static void main(String[] args) {
         BriefLogFormatter.init();
         Context.propagate(new Context());
 
-        if (args.length < 1) {
+        if (args.length < 1 || args.length > 2) {
             System.err.println(USAGE);
-            throw new IllegalArgumentException("Address required");
+            System.exit(1);
         }
 
         // Figure out which network we should connect to. Each network gets its own set of files.

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -44,7 +44,7 @@
  * sends them onwards to an address given on the command line.
  */
 public class ForwardingService implements Closeable {
-    static final String USAGE = "Usage: address-to-send-back-to [mainnet|testnet|signet|regtest]";
+    static final String USAGE = "Usage: address-to-forward-to [mainnet|testnet|signet|regtest]";
     static final int REQUIRED_CONFIRMATIONS = 1;
     static final int MAX_CONNECTIONS = 4;
     private final BitcoinNetwork network;

File: core/src/main/java/org/bitcoinj/core/CheckpointManager.java
Patch:
@@ -240,7 +240,7 @@ public static void checkpoint(NetworkParameters params, InputStream checkpoints,
         checkArgument(!(store instanceof FullPrunedBlockStore), () ->
                 "you cannot use checkpointing with a full store");
 
-        time = time.minus(7, ChronoUnit.WEEKS);
+        time = time.minus(7, ChronoUnit.DAYS);
 
         log.info("Attempting to initialize a new block store with a checkpoint for time {} ({})", time.getEpochSecond(),
                 TimeUtils.dateTimeFormat(time));

File: core/src/main/java/org/bitcoinj/net/discovery/SeedPeers.java
Patch:
@@ -122,7 +122,7 @@ public void shutdown() {
 
     private static InetAddress convertAddress(int seed) throws UnknownHostException {
         byte[] v4addr = new byte[4];
-        ByteUtils.writeUint32LE(seed, v4addr, 0);
+        ByteUtils.writeInt32BE(seed, v4addr, 0);
         return InetAddress.getByAddress(v4addr);
     }
 }

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -229,6 +229,8 @@ public long getSequenceNumber() {
      * examples of how you can use this feature to build contract protocols.
      */
     public void setSequenceNumber(long sequence) {
+        checkArgument(sequence >= 0 && sequence <= ByteUtils.MAX_UNSIGNED_INTEGER, () ->
+                "sequence out of range: " + sequence);
         unCache();
         this.sequence = sequence;
     }

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -1195,7 +1195,7 @@ public boolean add(Rule element) {
         NewBlock b63 = createNextBlock(b60, chainHeadHeight + 19, null, null);
         {
             b63.block.getTransactions().get(0).setLockTime(0xffffffffL);
-            b63.block.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
+            b63.block.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xdeadbeefL);
             checkState(!b63.block.getTransactions().get(0).isFinal(chainHeadHeight + 17, b63.block.getTimeSeconds()));
         }
         b63.solve();

File: core/src/main/java/org/bitcoinj/base/internal/ByteUtils.java
Patch:
@@ -36,6 +36,9 @@
  * from {@code org.bitcoinj.core.Utils}.
  */
 public class ByteUtils {
+    /** Maximum unsigned value that can be expressed by 32 bits. */
+    public static final long MAX_UNSIGNED_INTEGER = Integer.toUnsignedLong(-1);
+
     /**
      * Hex encoding used throughout the framework. Use with ByteUtils.formatHex(byte[]) or ByteUtils.parseHex(CharSequence).
      * @deprecated Use {@link ByteUtils#hexFormat} or {@link ByteUtils#parseHex(String)} or other available

File: core/src/main/java/org/bitcoinj/testing/FakeTxBuilder.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Address;
+import org.bitcoinj.base.internal.ByteUtils;
 import org.bitcoinj.base.internal.TimeUtils;
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Coin;
@@ -73,7 +74,7 @@ public static Transaction createFakeTxWithoutChange(final NetworkParameters para
 
     /** Create a fake coinbase transaction. */
     public static Transaction createFakeCoinbaseTx(final NetworkParameters params) {
-        TransactionOutPoint outpoint = new TransactionOutPoint(params, -1, Sha256Hash.ZERO_HASH);
+        TransactionOutPoint outpoint = new TransactionOutPoint(params, ByteUtils.MAX_UNSIGNED_INTEGER, Sha256Hash.ZERO_HASH);
         TransactionInput input = new TransactionInput(params, null, new byte[0], outpoint);
         Transaction tx = new Transaction(params);
         tx.addInput(input);

File: core/src/test/java/org/bitcoinj/script/ScriptTest.java
Patch:
@@ -338,7 +338,9 @@ private Map<TransactionOutPoint, Script> parseScriptPubKeys(JsonNode inputs) thr
         Map<TransactionOutPoint, Script> scriptPubKeys = new HashMap<>();
         for (JsonNode input : inputs) {
             String hash = input.get(0).asText();
-            int index = input.get(1).asInt();
+            long index = input.get(1).asLong();
+            if (index == -1)
+                index = ByteUtils.MAX_UNSIGNED_INTEGER;
             String script = input.get(2).asText();
             Sha256Hash sha256Hash = Sha256Hash.wrap(ByteUtils.parseHex(hash));
             scriptPubKeys.put(new TransactionOutPoint(TESTNET, index, sha256Hash), parseScriptString(script));
@@ -394,8 +396,6 @@ public void dataDrivenValidTransactions() throws Exception {
 
                 for (int i = 0; i < transaction.getInputs().size(); i++) {
                     TransactionInput input = transaction.getInputs().get(i);
-                    if (input.getOutpoint().getIndex() == 0xffffffffL)
-                        input.getOutpoint().setIndex(-1);
                     assertTrue(scriptPubKeys.containsKey(input.getOutpoint()));
                     input.getScriptSig().correctlySpends(transaction, i, null, null,
                             scriptPubKeys.get(input.getOutpoint()), verifyFlags);

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -693,8 +693,6 @@ private static class HugeDeclaredSizeTransaction extends Transaction {
 
         public HugeDeclaredSizeTransaction(NetworkParameters params, boolean hackInputsSize, boolean hackOutputsSize, boolean hackWitnessPushCountSize) {
             super(params);
-            setSerializer(serializer.withProtocolVersion(
-                    NetworkParameters.ProtocolVersion.WITNESS_VERSION.getBitcoinProtocolVersion()));
             Transaction inputTx = new Transaction(params);
             inputTx.addOutput(Coin.FIFTY_COINS, ECKey.fromPrivate(BigInteger.valueOf(123456)).toAddress(ScriptType.P2PKH, params.network()));
             this.addInput(inputTx.getOutput(0));

File: core/src/main/java/org/bitcoinj/core/AddressMessage.java
Patch:
@@ -49,7 +49,6 @@ public void removeAddress(int index) {
         unCache();
         PeerAddress address = addresses.remove(index);
         address.setParent(null);
-        length = UNKNOWN_LENGTH;
     }
 
     /**

File: core/src/main/java/org/bitcoinj/core/AddressV1Message.java
Patch:
@@ -55,12 +55,10 @@ protected void parse() throws ProtocolException {
             throw new ProtocolException("Address message too large.");
         addresses = new ArrayList<>(numAddresses);
         MessageSerializer serializer = this.serializer.withProtocolVersion(1);
-        length = numAddressesVarInt.getSizeInBytes();
         for (int i = 0; i < numAddresses; i++) {
             PeerAddress addr = new PeerAddress(params, ByteBuffer.wrap(payload, cursor, payload.length - cursor), this, serializer);
             addresses.add(addr);
             cursor += addr.getMessageSize();
-            length += addr.getMessageSize();
         }
     }
 
@@ -72,7 +70,6 @@ public void addAddress(PeerAddress address) {
         unCache();
         address.setParent(this);
         addresses.add(address);
-        length = UNKNOWN_LENGTH;
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/core/AddressV2Message.java
Patch:
@@ -55,12 +55,10 @@ protected void parse() throws ProtocolException {
             throw new ProtocolException("Address message too large.");
         addresses = new ArrayList<>(numAddresses);
         MessageSerializer serializer = this.serializer.withProtocolVersion(2);
-        length = numAddressesVarInt.getSizeInBytes();
         for (int i = 0; i < numAddresses; i++) {
             PeerAddress addr = new PeerAddress(params, ByteBuffer.wrap(payload, cursor, payload.length - cursor), this, serializer);
             addresses.add(addr);
             cursor += addr.getMessageSize();
-            length += addr.getMessageSize();
         }
     }
 
@@ -72,7 +70,6 @@ public void addAddress(PeerAddress address) {
         unCache();
         address.setParent(this);
         addresses.add(address);
-        length = UNKNOWN_LENGTH;
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/core/BloomFilter.java
Patch:
@@ -156,7 +156,6 @@ protected void parse() throws ProtocolException {
             throw new ProtocolException("Bloom filter hash function count out of range");
         nTweak = readUint32();
         nFlags = readBytes(1)[0];
-        length = cursor - offset;
     }
     
     /**

File: core/src/main/java/org/bitcoinj/core/FilteredBlock.java
Patch:
@@ -68,9 +68,7 @@ public void bitcoinSerializeToStream(OutputStream stream) throws IOException {
     protected void parse() throws ProtocolException {
         byte[] headerBytes = readBytes(Block.HEADER_SIZE);
         header = params.getDefaultSerializer().makeBlock(ByteBuffer.wrap(headerBytes));
-        merkleTree = new PartialMerkleTree(params, ByteBuffer.wrap(payload, Block.HEADER_SIZE, length - Block.HEADER_SIZE));
-        
-        length = Block.HEADER_SIZE + merkleTree.getMessageSize();
+        merkleTree = new PartialMerkleTree(params, ByteBuffer.wrap(payload, Block.HEADER_SIZE, payload.length - Block.HEADER_SIZE));
     }
     
     /**

File: core/src/main/java/org/bitcoinj/core/GetBlocksMessage.java
Patch:
@@ -55,7 +55,6 @@ protected void parse() throws ProtocolException {
         int startCount = readVarInt().intValue();
         if (startCount > 500)
             throw new ProtocolException("Number of locators cannot be > 500, received: " + startCount);
-        length = cursor - offset + ((startCount + 1) * 32);
         locator = new BlockLocator();
         for (int i = 0; i < startCount; i++) {
             locator = locator.add(readHash());

File: core/src/main/java/org/bitcoinj/core/PartialMerkleTree.java
Patch:
@@ -131,8 +131,6 @@ protected void parse() throws ProtocolException {
 
         int nFlagBytes = readVarInt().intValue();
         matchedChildBits = readBytes(nFlagBytes);
-
-        length = cursor - offset;
     }
 
     // Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.

File: core/src/main/java/org/bitcoinj/core/Ping.java
Patch:
@@ -65,7 +65,6 @@ protected void parse() throws ProtocolException {
         } catch(ProtocolException e) {
             hasNonce = false;
         }
-        length = hasNonce ? 8 : 0;
     }
     
     public boolean hasNonce() {

File: core/src/main/java/org/bitcoinj/core/Pong.java
Patch:
@@ -44,7 +44,6 @@ public Pong(long nonce) {
     @Override
     protected void parse() throws ProtocolException {
         nonce = readInt64();
-        length = 8;
     }
     
     @Override

File: core/src/main/java/org/bitcoinj/core/RejectMessage.java
Patch:
@@ -100,7 +100,6 @@ protected void parse() throws ProtocolException {
         reason = readStr();
         if (message.equals("block") || message.equals("tx"))
             messageHash = readHash();
-        length = cursor - offset;
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/core/VersionMessage.java
Patch:
@@ -157,7 +157,6 @@ protected void parse() throws ProtocolException {
             bestHeight = 0;
             relayTxesBeforeFilter = true;
         }
-        length = cursor - offset;
     }
 
     @Override

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -1234,11 +1234,11 @@ public boolean add(Rule element) {
             // The following checks are checking to ensure block serialization functions in the way needed for this test
             // If they fail, it is likely not an indication of error, but an indication that this test needs rewritten
             checkState(stream.size() == b64Original.block.getMessageSize() + 8);
-            checkState(stream.size() == b64.getMessageSize());
             // This check fails because it was created for "retain mode" and the likely encoding is not "optimal".
             // We since removed this capability retain the original encoding, but could not rewrite this test data.
+            // checkState(stream.size() == b64.getMessageSize());
             // checkState(Arrays.equals(stream.toByteArray(), b64.bitcoinSerialize()));
-            checkState(b64.getOptimalEncodingMessageSize() == b64Original.block.getMessageSize());
+            // checkState(b64.getOptimalEncodingMessageSize() == b64Original.block.getMessageSize());
         }
         blocks.add(new BlockAndValidity(b64, true, false, b64.getHash(), chainHeadHeight + 19, "b64"));
         spendableOutputs.offer(b64Original.getCoinbaseOutput());

File: core/src/test/java/org/bitcoinj/core/PeerAddressTest.java
Patch:
@@ -45,7 +45,7 @@ public class PeerAddressTest {
     public void equalsContract() {
         EqualsVerifier.forClass(PeerAddress.class)
                 .suppress(Warning.NONFINAL_FIELDS)
-                .withIgnoredFields("time", "parent", "params", "offset", "cursor", "length", "payload", "serializer")
+                .withIgnoredFields("time", "parent", "params", "offset", "cursor", "payload", "serializer")
                 .usingGetClass()
                 .verify();
     }
@@ -57,7 +57,6 @@ public void parse_versionVariant() {
         String hex = "010000000000000000000000000000000000ffff0a000001208d";
         PeerAddress pa = new PeerAddress(MAINNET, ByteBuffer.wrap(ByteUtils.parseHex(hex)), null,
                 serializer);
-        assertEquals(26, pa.length);
         assertEquals(VersionMessage.NODE_NETWORK, pa.getServices().longValue());
         assertEquals("10.0.0.1", pa.getAddr().getHostAddress());
         assertEquals(8333, pa.getPort());
@@ -69,7 +68,6 @@ public void bitcoinSerialize_versionVariant() throws Exception {
         PeerAddress pa = new PeerAddress(MAINNET, InetAddress.getByName(null), 8333, BigInteger.ZERO,
                 serializer);
         assertEquals("000000000000000000000000000000000000ffff7f000001208d", ByteUtils.formatHex(pa.bitcoinSerialize()));
-        assertEquals(26, pa.length);
     }
 
     @Test

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -1586,7 +1586,7 @@ public long getLastPingTime() {
     /**
      * Returns a moving average of the last N ping/pong cycles. If {@link Peer#sendPing()} has never
      * been called or we did not hear back the "pong" message yet, returns empty. The moving average
-     * window is 5 buckets.
+     * window is {@link #PING_MOVING_AVERAGE_WINDOW} buckets.
      * @return moving average, or empty
      */
     public Optional<Duration> pingInterval() {

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -50,9 +50,9 @@
 import java.util.Locale;
 import java.util.Objects;
 
-import static com.google.common.base.Preconditions.checkState;
 import static org.bitcoinj.base.Coin.FIFTY_COINS;
 import static org.bitcoinj.base.Sha256Hash.hashTwice;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * <p>A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.

File: core/src/main/java/org/bitcoinj/core/BlockChain.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 // TODO: Rename this class to SPVBlockChain at some point.
 
@@ -93,7 +93,8 @@ protected void rollbackBlockStore(int height) throws BlockStoreException {
         lock.lock();
         try {
             int currentHeight = getBestChainHeight();
-            checkArgument(height >= 0 && height <= currentHeight, "Bad height: %s", height);
+            checkArgument(height >= 0 && height <= currentHeight, () ->
+                    "bad height: " + height);
             if (height == currentHeight)
                 return; // nothing to do
 

File: core/src/main/java/org/bitcoinj/core/BloomFilter.java
Patch:
@@ -33,12 +33,12 @@
 import java.util.List;
 import java.util.Objects;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static java.lang.Math.E;
 import static java.lang.Math.log;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 import static java.lang.Math.pow;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 /**
  * <p>A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid

File: core/src/main/java/org/bitcoinj/core/FullPrunedBlockChain.java
Patch:
@@ -45,7 +45,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.FutureTask;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * <p>A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the

File: core/src/main/java/org/bitcoinj/core/InventoryMessage.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.core;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 /**
  * <p>Represents the "inv" P2P network message. An inv contains a list of hashes of either blocks or transactions. It's

File: core/src/main/java/org/bitcoinj/core/PeerSocketHandler.java
Patch:
@@ -40,8 +40,8 @@
 import java.util.Objects;
 import java.util.concurrent.locks.Lock;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Handles high-level message (de)serialization for peers, acting as the bridge between the

File: core/src/main/java/org/bitcoinj/core/StoredBlock.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.Locale;
 import java.util.Objects;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient to
@@ -126,7 +126,8 @@ public StoredBlock getPrev(BlockStore store) throws BlockStoreException {
     /** Serializes the stored block to a custom packed format. Used by {@link CheckpointManager}. */
     public void serializeCompact(ByteBuffer buffer) {
         byte[] chainWorkBytes = getChainWork().toByteArray();
-        checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES, "Ran out of space to store chain work!");
+        checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES, () ->
+                "ran out of space to store chain work!");
         if (chainWorkBytes.length < CHAIN_WORK_BYTES) {
             // Pad to the right size.
             buffer.put(EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length);

File: core/src/main/java/org/bitcoinj/core/TransactionBroadcast.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Represents a single transaction broadcast that we are performing. A broadcast occurs after a new transaction is created
@@ -324,7 +324,8 @@ private void invokeProgressCallback(int numSeenPeers, boolean mined) {
         }
         if (callback != null) {
             final double progress = Math.min(1.0, mined ? 1.0 : numSeenPeers / (double) numWaitingFor);
-            checkState(progress >= 0.0 && progress <= 1.0, progress);
+            checkState(progress >= 0.0 && progress <= 1.0, () ->
+                    "" + progress);
             try {
                 if (executor == null)
                     callback.onBroadcastProgress(progress);

File: core/src/main/java/org/bitcoinj/core/TransactionConfidence.java
Patch:
@@ -38,7 +38,7 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 // TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.
 

File: core/src/main/java/org/bitcoinj/core/TransactionOutPoint.java
Patch:
@@ -33,7 +33,7 @@
 import java.io.OutputStream;
 import java.util.Objects;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * <p>This message is a reference or pointer to an output of a different transaction.</p>

File: core/src/main/java/org/bitcoinj/core/TransactionWitness.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 public class TransactionWitness {
     public static final TransactionWitness EMPTY = new TransactionWitness(0);
@@ -38,7 +38,8 @@ public class TransactionWitness {
      * used as a placeholder.
      */
     public static TransactionWitness redeemP2WPKH(@Nullable TransactionSignature signature, ECKey pubKey) {
-        checkArgument(pubKey.isCompressed(), "only compressed keys allowed");
+        checkArgument(pubKey.isCompressed(), () ->
+                "only compressed keys allowed");
         TransactionWitness witness = new TransactionWitness(2);
         witness.setPush(0, signature != null ? signature.encodeToBitcoin() : new byte[0]); // signature
         witness.setPush(1, pubKey.getPubKey()); // pubkey

File: core/src/main/java/org/bitcoinj/crypto/BIP38PrivateKey.java
Patch:
@@ -34,7 +34,7 @@
 import java.text.Normalizer;
 import java.util.Arrays;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Implementation of <a href="https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki">BIP 38</a>

File: core/src/main/java/org/bitcoinj/crypto/DeterministicHierarchy.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Locale;
 import java.util.Map;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 // TODO: This whole API feels a bit object heavy. Do we really need ChildNumber and so many maps, etc?
 // TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?
@@ -102,7 +102,7 @@ public DeterministicKey get(List<ChildNumber> path, boolean relativePath, boolea
             if (!create)
                 throw new IllegalArgumentException(String.format(Locale.US, "No key found for %s path %s.",
                     relativePath ? "relative" : "absolute", inputPath.toString()));
-            checkArgument(absolutePath.size() > 0, "Can't derive the master key: nothing to derive from.");
+            checkArgument(absolutePath.size() > 0, () -> "can't derive the master key: nothing to derive from");
             DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), false, true);
             putKey(HDKeyDerivation.deriveChildKey(parent, absolutePath.get(absolutePath.size() - 1)));
         }

File: core/src/main/java/org/bitcoinj/crypto/DumpedPrivateKey.java
Patch:
@@ -17,7 +17,6 @@
 
 package org.bitcoinj.crypto;
 
-import com.google.common.base.Preconditions;
 import org.bitcoinj.base.Base58;
 import org.bitcoinj.base.Network;
 import org.bitcoinj.base.exceptions.AddressFormatException;
@@ -27,6 +26,8 @@
 import javax.annotation.Nullable;
 import java.util.Arrays;
 
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
+
 /**
  * Parses and generates private keys in the form used by the Bitcoin "dumpprivkey" command. This is the private key
  * bytes with a header byte and 4 checksum bytes at the end. If there are 33 private key bytes instead of 32, then
@@ -104,7 +105,7 @@ public String toBase58() {
     }
 
     private static byte[] encode(byte[] keyBytes, boolean compressed) {
-        Preconditions.checkArgument(keyBytes.length == 32, "Private keys must be 32 bytes");
+        checkArgument(keyBytes.length == 32, () -> "private keys must be 32 bytes");
         if (!compressed) {
             return keyBytes;
         } else {

File: core/src/main/java/org/bitcoinj/crypto/TransactionSignature.java
Patch:
@@ -16,7 +16,6 @@
 
 package org.bitcoinj.crypto;
 
-import com.google.common.base.Preconditions;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.Transaction.SigHash;
 import org.bitcoinj.core.VerificationException;
@@ -25,6 +24,8 @@
 import java.io.IOException;
 import java.math.BigInteger;
 
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
+
 /**
  * A TransactionSignature wraps an {@link ECKey.ECDSASignature} and adds methods for handling
  * the additional SIGHASH mode byte that is used.
@@ -68,7 +69,7 @@ public static TransactionSignature dummy() {
 
     /** Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. */
     public static int calcSigHashValue(Transaction.SigHash mode, boolean anyoneCanPay) {
-        Preconditions.checkArgument(SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode); // enforce compatibility since this code was made before the SigHash enum was updated
+        checkArgument(SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode); // enforce compatibility since this code was made before the SigHash enum was updated
         int sighashFlags = mode.value;
         if (anyoneCanPay)
             sighashFlags |= Transaction.SigHash.ANYONECANPAY.value;

File: core/src/main/java/org/bitcoinj/net/BlockingClient.java
Patch:
@@ -35,7 +35,7 @@
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * <p>Creates a simple connection to a server using a {@link StreamConnection} to process data.</p>

File: core/src/main/java/org/bitcoinj/net/ConnectionHandler.java
Patch:
@@ -38,7 +38,7 @@
 import java.util.Set;
 import java.util.concurrent.locks.ReentrantLock;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 // TODO: The locking in all this class is horrible and not really necessary. We should just run all network stuff on one thread.
 

File: core/src/main/java/org/bitcoinj/net/discovery/MultiplexingDiscovery.java
Patch:
@@ -37,7 +37,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 /**
  * MultiplexingDiscovery queries multiple PeerDiscovery objects, optionally shuffles their responses and then returns the results,

File: core/src/main/java/org/bitcoinj/params/BitcoinNetworkParams.java
Patch:
@@ -42,7 +42,7 @@
 import java.time.temporal.TemporalUnit;
 import java.util.concurrent.TimeUnit;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Parameters for Bitcoin-like networks.
@@ -191,8 +191,8 @@ public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block
             }
             hash = cursor.getHeader().getPrevBlockHash();
         }
-        checkState(cursor != null && isDifficultyTransitionPoint(cursor.getHeight() - 1),
-                "Didn't arrive at a transition point.");
+        checkState(cursor != null && isDifficultyTransitionPoint(cursor.getHeight() - 1), () ->
+                "didn't arrive at a transition point");
         Duration elapsed = TimeUtils.elapsedTime(start);
         if (elapsed.toMillis() > 50)
             log.info("Difficulty transition traversal took {} ms", elapsed.toMillis());

File: core/src/main/java/org/bitcoinj/params/MainNetParams.java
Patch:
@@ -24,7 +24,7 @@
 
 import java.time.Instant;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Parameters for the main production network on which people trade goods and services.
@@ -138,7 +138,7 @@ public Block getGenesisBlock() {
                 genesisBlock.setDifficultyTarget(Block.STANDARD_MAX_DIFFICULTY_TARGET);
                 genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
-                checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
+                checkState(genesisBlock.getHash().equals(GENESIS_HASH), () -> "invalid genesis hash");
             }
         }
         return genesisBlock;

File: core/src/main/java/org/bitcoinj/params/RegTestParams.java
Patch:
@@ -24,7 +24,7 @@
 
 import java.time.Instant;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Network parameters for the regression test mode of bitcoind in which all blocks are trivially solvable.
@@ -86,7 +86,8 @@ public Block getGenesisBlock() {
                 genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
                 genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
-                checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
+                checkState(genesisBlock.getHash().equals(GENESIS_HASH), () ->
+                        "invalid genesis hash");
             }
         }
         return genesisBlock;

File: core/src/main/java/org/bitcoinj/params/SigNetParams.java
Patch:
@@ -23,7 +23,7 @@
 
 import java.time.Instant;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * <p>Parameters for the signet, a separate public instance of Bitcoin that has relaxed rules suitable for development
@@ -83,7 +83,8 @@ public Block getGenesisBlock() {
                 genesisBlock.setDifficultyTarget(GENESIS_DIFFICULTY);
                 genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
-                checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
+                checkState(genesisBlock.getHash().equals(GENESIS_HASH), () ->
+                        "invalid genesis hash");
             }
         }
         return genesisBlock;

File: core/src/main/java/org/bitcoinj/params/TestNet3Params.java
Patch:
@@ -30,7 +30,7 @@
 import java.math.BigInteger;
 import java.time.Instant;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
@@ -92,7 +92,8 @@ public Block getGenesisBlock() {
                 genesisBlock.setDifficultyTarget(Block.STANDARD_MAX_DIFFICULTY_TARGET);
                 genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
-                checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
+                checkState(genesisBlock.getHash().equals(GENESIS_HASH), () ->
+                        "invalid genesis hash");
             }
         }
         return genesisBlock;

File: core/src/main/java/org/bitcoinj/script/ScriptChunk.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.Arrays;
 import java.util.Objects;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 import static org.bitcoinj.script.ScriptOpCodes.OP_0;
 import static org.bitcoinj.script.ScriptOpCodes.OP_1;
 import static org.bitcoinj.script.ScriptOpCodes.OP_16;

File: core/src/main/java/org/bitcoinj/testing/FakeTxBuilder.java
Patch:
@@ -46,9 +46,9 @@
 import java.time.Instant;
 import java.util.Random;
 
-import static com.google.common.base.Preconditions.checkState;
 import static org.bitcoinj.base.Coin.COIN;
 import static org.bitcoinj.base.Coin.valueOf;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Methods for building fake transactions for unit tests. Since these methods are currently used both in the `bitcoinj-core`

File: core/src/main/java/org/bitcoinj/utils/BlockFileLoader.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.Locale;
 import java.util.NoSuchElementException;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 /**
  * <p>This class reads block files stored in the Bitcoin Core format. This is simply a way to concatenate
@@ -55,7 +55,8 @@ public class BlockFileLoader implements Iterable<Block>, Iterator<Block> {
      * Gets the list of files which contain blocks from Bitcoin Core.
      */
     public static List<File> getReferenceClientBlockFileList(File blocksDir) {
-        checkArgument(blocksDir.isDirectory(), "%s is not a directory", blocksDir);
+        checkArgument(blocksDir.isDirectory(), () ->
+                "not a directory: " + blocksDir);
         List<File> list = new LinkedList<>();
         for (int i = 0; true; i++) {
             File file = new File(blocksDir, String.format(Locale.US, "blk%05d.dat", i));

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -35,7 +35,7 @@
 import java.util.List;
 import java.util.Optional;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * <p>The default risk analysis. Currently, it only is concerned with whether a tx/dependency is non-final or not, and

File: core/src/main/java/org/bitcoinj/wallet/RedeemData.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 /**
  * This class aggregates data required to spend transaction output.

File: core/src/test/java/org/bitcoinj/core/BitcoindComparisonTool.java
Patch:
@@ -17,7 +17,6 @@
 
 package org.bitcoinj.core;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.net.NioClient;
@@ -49,6 +48,8 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.bitcoinj.base.internal.Preconditions.checkState;
+
 /**
  * A tool for comparing the blocks which are accepted/rejected by bitcoind/bitcoinj
  * It is designed to run as a testnet-in-a-box network between a single bitcoind node and bitcoinj
@@ -93,7 +94,7 @@ public static void main(String[] args) throws Exception {
         ver.localServices = VersionMessage.NODE_NETWORK;
         final Peer bitcoind = new Peer(PARAMS, ver, new PeerAddress(PARAMS, InetAddress.getLocalHost()),
                 new BlockChain(PARAMS, new MemoryBlockStore(PARAMS)));
-        Preconditions.checkState(bitcoind.getVersionMessage().hasBlockChain());
+        checkState(bitcoind.getVersionMessage().hasBlockChain());
 
         final BlockWrapper currentBlock = new BlockWrapper();
 

File: core/src/test/java/org/bitcoinj/testing/FooWalletExtension.java
Patch:
@@ -21,7 +21,7 @@
 
 import java.util.Arrays;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
 
 public class FooWalletExtension implements WalletExtension {
     private final byte[] data = {1, 2, 3};

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -42,8 +42,8 @@
 import java.util.Collections;
 import java.util.List;
 
-import static com.google.common.base.Preconditions.checkState;
 import static org.bitcoinj.base.Coin.COIN;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 import static org.bitcoinj.script.ScriptOpCodes.OP_PUSHDATA1;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;

File: integration-test/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -60,8 +60,8 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkArgument;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Utility class that makes it easy to work with mock NetworkConnections.

File: tools/src/main/java/org/bitcoinj/tools/BuildCheckpoints.java
Patch:
@@ -49,8 +49,8 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
 
-import static com.google.common.base.Preconditions.checkState;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 
 /**
  * Downloads and verifies a full chain from your local peer, emitting checkpoints at each difficulty transition period

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/utils/GuiUtils.java
Patch:
@@ -32,7 +32,7 @@
 import java.net.URL;
 import java.util.function.BiConsumer;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 import static org.bitcoinj.walletfx.utils.WTUtils.unchecked;
 
 public class GuiUtils {

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -40,7 +40,7 @@
 import org.bitcoinj.walletfx.utils.TextFieldValidator;
 import org.bitcoinj.walletfx.utils.WTUtils;
 
-import static com.google.common.base.Preconditions.checkState;
+import static org.bitcoinj.base.internal.Preconditions.checkState;
 import static org.bitcoinj.walletfx.utils.GuiUtils.*;
 
 import javax.annotation.Nullable;

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -1407,8 +1407,8 @@ private static void executeCheckLockTimeVerify(Transaction txContainingThis, int
         // There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples
         LockTime txContainingThisLockTime = txContainingThis.lockTime();
         if (!(
-            ((txContainingThisLockTime.isBlockHeight()) && (nLockTime.compareTo(LOCKTIME_THRESHOLD_BIG)) < 0) ||
-            ((txContainingThisLockTime.isTimestamp()) && (nLockTime.compareTo(LOCKTIME_THRESHOLD_BIG)) >= 0))
+            ((txContainingThisLockTime instanceof LockTime.HeightLock) && (nLockTime.compareTo(LOCKTIME_THRESHOLD_BIG)) < 0) ||
+            ((txContainingThisLockTime instanceof LockTime.TimeLock) && (nLockTime.compareTo(LOCKTIME_THRESHOLD_BIG)) >= 0))
         )
             throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Lock time requirement type mismatch");
 

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -747,7 +747,7 @@ protected void bitcoinSerializeToStream(OutputStream stream, boolean useSegwit)
                 }
             }
             // lock_time
-            uint32ToByteStreamLE(getLockTime(), stream);
+            uint32ToByteStreamLE(lockTime().rawValue(), stream);
         }
     }
 

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -1407,12 +1407,12 @@ private static void executeCheckLockTimeVerify(Transaction txContainingThis, int
             ((txContainingThis.getLockTime() <  Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) < 0) ||
             ((txContainingThis.getLockTime() >= Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) >= 0))
         )
-            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch");
+            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Lock time requirement type mismatch");
 
         // Now that we know we're comparing apples-to-apples, the
         // comparison is a simple numeric one.
         if (nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime())) > 0)
-            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied");
+            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Lock time requirement not satisfied");
 
         // Finally the nLockTime feature can be disabled and thus
         // CHECKLOCKTIMEVERIFY bypassed if every txin has been

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -204,7 +204,7 @@ public Peer(NetworkParameters params, VersionMessage ver, @Nullable AbstractBloc
      * connection. If you want to create a one-off connection, create a Peer and pass it to
      * {@link NioClientManager#openConnection(SocketAddress, StreamConnection)}
      * or
-     * {@link NioClient#NioClient(SocketAddress, StreamConnection, int)}.</p>
+     * {@link NioClient#NioClient(SocketAddress, StreamConnection, Duration)}.</p>
      *
      * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is
      * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
@@ -223,7 +223,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
      * connection. If you want to create a one-off connection, create a Peer and pass it to
      * {@link NioClientManager#openConnection(SocketAddress, StreamConnection)}
      * or
-     * {@link NioClient#NioClient(SocketAddress, StreamConnection, int)}.</p>
+     * {@link NioClient#NioClient(SocketAddress, StreamConnection, Duration)}.</p>
      *
      * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is
      * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
@@ -257,7 +257,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
      * connection. If you want to create a one-off connection, create a Peer and pass it to
      * {@link NioClientManager#openConnection(SocketAddress, StreamConnection)}
      * or
-     * {@link NioClient#NioClient(SocketAddress, StreamConnection, int)}.</p>
+     * {@link NioClient#NioClient(SocketAddress, StreamConnection, Duration)}.</p>
      *
      * <p>The remoteAddress provided should match the remote address of the peer which is being connected to, and is
      * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>

File: core/src/main/java/org/bitcoinj/net/BlockingClientManager.java
Patch:
@@ -68,7 +68,7 @@ public ListenableCompletableFuture<SocketAddress> openConnection(SocketAddress s
 
     /**
      * Sets the number of milliseconds to wait before giving up on a connect attempt
-     * @param timeout timeout for establishing a connection to the client
+     * @param connectTimeout timeout for establishing a connection to the client
      */
     public void setConnectTimeout(Duration connectTimeout) {
         this.connectTimeout = connectTimeout;

File: core/src/main/java/org/bitcoinj/net/NioClient.java
Patch:
@@ -107,9 +107,9 @@ public int getMaxMessageSize() {
      * The given connection <b>MUST</b> be unique to this object. This does not block while waiting for the connection to
      * open, but will call either the {@link StreamConnection#connectionOpened()} or
      * {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
-     *
-     * @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds). 0 is interpreted as no
-     *                             timeout.
+     * @param serverAddress socket address of the server to connect to
+     * @param parser parses data from the server
+     * @param connectTimeout timeout for establishing a connection to the server, or ZERO for no timeout
      */
     public NioClient(final SocketAddress serverAddress, final StreamConnection parser,
                      final Duration connectTimeout) throws IOException {

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -2689,7 +2689,9 @@ public void witnessTransactionGetFeeTest() throws Exception {
         int vsize = request.tx.getVsize();
         Coin feePerVkb = fee.multiply(1000).divide(vsize);
         assertEquals(Coin.valueOf(14100), fee);
-        assertEquals(Transaction.DEFAULT_TX_FEE, feePerVkb);
+        // due to shorter than expected signature encoding, in rare cases we overpay a little
+        Coin overpaidFee = Transaction.DEFAULT_TX_FEE.add(valueOf(714));
+        assertTrue(feePerVkb.toString(),feePerVkb.equals(Transaction.DEFAULT_TX_FEE) || feePerVkb.equals(overpaidFee));
     }
 
     @Test

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -93,6 +93,9 @@ private Result analyzeIsFinal() {
 
         final int height = wallet.getLastBlockSeenHeight();
         final long time = wallet.getLastBlockSeenTimeSecs();
+        if (time == 0)
+            return null;
+
         // If the transaction has a lock time specified in blocks, we consider that if the tx would become final in the
         // next block it is not risky (as it would confirm normally).
         final int adjustedHeight = height + 1;

File: core/src/test/java/org/bitcoinj/crypto/MnemonicCodeTest.java
Patch:
@@ -58,7 +58,7 @@ public void testGetWordListUnmodifiable() {
         wordList.remove(0);
     }
 
-    @Test(expected = MnemonicException.MnemonicLengthException.class)
+    @Test(expected = RuntimeException.class)
     public void testBadEntropyLength() throws Exception {
         byte[] entropy = ByteUtils.parseHex("7f7f7f7f7f7f7f7f7f7f7f7f7f7f");
         mc.toMnemonic(entropy);
@@ -88,7 +88,7 @@ public void testEmptyMnemonic() throws Exception {
         mc.check(words);
     }
 
-    @Test(expected = MnemonicException.MnemonicLengthException.class)
+    @Test(expected = RuntimeException.class)
     public void testEmptyEntropy() throws Exception {
         byte[] entropy = {};
         mc.toMnemonic(entropy);

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -1678,7 +1678,7 @@ public WalletFiles autosaveToFile(File f, Duration delay, @Nullable WalletFiles.
         }
     }
 
-    /** @deprecated use {@link #autosaveToFile(File, Optional, WalletFiles.Listener)} */
+    /** @deprecated use {@link #autosaveToFile(File, Duration, WalletFiles.Listener)} */
     @Deprecated
     public WalletFiles autosaveToFile(File f, long delayTime, TimeUnit timeUnit, @Nullable WalletFiles.Listener eventListener) {
         return autosaveToFile(f, Duration.ofMillis(timeUnit.toMillis(delayTime)), eventListener);

File: core/src/main/java/org/bitcoinj/script/ScriptBuilder.java
Patch:
@@ -273,9 +273,9 @@ public static Script createOutputScript(Address to) {
         if (to instanceof LegacyAddress) {
             ScriptType scriptType = to.getOutputScriptType();
             if (scriptType == ScriptType.P2PKH)
-                return createP2PKHOutputScript(to.getHash());
+                return createP2PKHOutputScript(((LegacyAddress) to).getHash());
             else if (scriptType == ScriptType.P2SH)
-                return createP2SHOutputScript(to.getHash());
+                return createP2SHOutputScript(((LegacyAddress) to).getHash());
             else
                 throw new IllegalStateException("Cannot handle " + scriptType);
         } else if (to instanceof SegwitAddress) {

File: core/src/main/java/org/bitcoinj/params/MainNetParams.java
Patch:
@@ -22,6 +22,8 @@
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Sha256Hash;
 
+import java.time.Instant;
+
 import static com.google.common.base.Preconditions.checkState;
 
 /**
@@ -134,7 +136,7 @@ public Block getGenesisBlock() {
             if (genesisBlock == null) {
                 genesisBlock = Block.createGenesis(this);
                 genesisBlock.setDifficultyTarget(Block.STANDARD_MAX_DIFFICULTY_TARGET);
-                genesisBlock.setTime(GENESIS_TIME);
+                genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
                 checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
             }

File: core/src/main/java/org/bitcoinj/params/RegTestParams.java
Patch:
@@ -22,6 +22,8 @@
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Sha256Hash;
 
+import java.time.Instant;
+
 import static com.google.common.base.Preconditions.checkState;
 
 /**
@@ -82,7 +84,7 @@ public Block getGenesisBlock() {
             if (genesisBlock == null) {
                 genesisBlock = Block.createGenesis(this);
                 genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
-                genesisBlock.setTime(GENESIS_TIME);
+                genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
                 checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
             }

File: core/src/main/java/org/bitcoinj/params/SigNetParams.java
Patch:
@@ -21,6 +21,8 @@
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Sha256Hash;
 
+import java.time.Instant;
+
 import static com.google.common.base.Preconditions.checkState;
 
 /**
@@ -79,7 +81,7 @@ public Block getGenesisBlock() {
             if (genesisBlock == null) {
                 genesisBlock = Block.createGenesis(this);
                 genesisBlock.setDifficultyTarget(GENESIS_DIFFICULTY);
-                genesisBlock.setTime(GENESIS_TIME);
+                genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
                 checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
             }

File: core/src/main/java/org/bitcoinj/params/TestNet3Params.java
Patch:
@@ -28,6 +28,7 @@
 import org.bitcoinj.store.BlockStoreException;
 
 import java.math.BigInteger;
+import java.time.Instant;
 import java.util.Date;
 
 import static com.google.common.base.Preconditions.checkState;
@@ -90,7 +91,7 @@ public Block getGenesisBlock() {
             if (genesisBlock == null) {
                 genesisBlock = Block.createGenesis(this);
                 genesisBlock.setDifficultyTarget(Block.STANDARD_MAX_DIFFICULTY_TARGET);
-                genesisBlock.setTime(GENESIS_TIME);
+                genesisBlock.setTime(Instant.ofEpochSecond(GENESIS_TIME));
                 genesisBlock.setNonce(GENESIS_NONCE);
                 checkState(genesisBlock.getHash().equals(GENESIS_HASH), "Invalid genesis hash");
             }

File: core/src/main/java/org/bitcoinj/params/UnitTestParams.java
Patch:
@@ -75,7 +75,7 @@ public Block getGenesisBlock() {
             if (genesisBlock == null) {
                 genesisBlock = Block.createGenesis(this);
                 genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
-                genesisBlock.setTime(TimeUtils.currentTimeSeconds());
+                genesisBlock.setTime(TimeUtils.currentTime());
                 genesisBlock.solve();
             }
         }

File: core/src/main/java/org/bitcoinj/testing/FakeTxBuilder.java
Patch:
@@ -43,6 +43,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.time.Instant;
 import java.util.Random;
 
 import static com.google.common.base.Preconditions.checkState;
@@ -270,7 +271,7 @@ public static BlockPair createFakeBlock(BlockStore blockStore, StoredBlock previ
         try {
             Block previousBlock = previousStoredBlock.getHeader();
             Address to = randomAddress(previousBlock.getParams());
-            Block b = previousBlock.createNextBlock(to, version, timeSeconds, height);
+            Block b = previousBlock.createNextBlock(to, version, Instant.ofEpochSecond(timeSeconds), height);
             // Coinbase tx was already added.
             for (Transaction tx : transactions) {
                 tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);

File: core/src/test/java/org/bitcoinj/core/BlockTest.java
Patch:
@@ -40,6 +40,7 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.math.BigInteger;
+import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
@@ -378,7 +379,7 @@ public byte[] bitcoinSerialize() {
     public void testGenesisBlock() {
         Block genesisBlock = Block.createGenesis(MainNetParams.get());
         genesisBlock.setDifficultyTarget(0x1d00ffffL);
-        genesisBlock.setTime(1231006505L);
+        genesisBlock.setTime(Instant.ofEpochSecond(1231006505L));
         genesisBlock.setNonce(2083236893);
         assertEquals(Sha256Hash.wrap("000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"), genesisBlock.getHash());
     }

File: integration-test/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -454,15 +454,15 @@ public void fastCatchup() throws Exception {
         blockChain.add(b1);
         TimeUtils.rollMockClock(60 * 10);  // 10 minutes later.
         Block b2 = makeSolvedTestBlock(b1);
-        b2.setTime(TimeUtils.currentTimeSeconds());
+        b2.setTime(TimeUtils.currentTime());
         b2.solve();
         TimeUtils.rollMockClock(60 * 10);  // 10 minutes later.
         Block b3 = makeSolvedTestBlock(b2);
-        b3.setTime(TimeUtils.currentTimeSeconds());
+        b3.setTime(TimeUtils.currentTime());
         b3.solve();
         TimeUtils.rollMockClock(60 * 10);
         Block b4 = makeSolvedTestBlock(b3);
-        b4.setTime(TimeUtils.currentTimeSeconds());
+        b4.setTime(TimeUtils.currentTime());
         b4.solve();
 
         // Request headers until the last 2 blocks.

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -1672,7 +1672,7 @@ private void setupPinging() {
                 for (Peer peer : getConnectedPeers()) {
                     if (peer.getPeerVersionMessage().clientVersion < params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG))
                         continue;
-                    peer.ping();
+                    peer.sendPing();
                 }
             } catch (Throwable e) {
                 log.error("Exception in ping loop", e);  // The executor swallows exceptions :(
@@ -2231,7 +2231,7 @@ public long getPingIntervalMsec() {
      * times are available via {@link Peer#getLastPingTime()} but it increases load on the
      * remote node. It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
      * Setting the value to be smaller or equals 0 disables pinging entirely, although you can still request one yourself
-     * using {@link Peer#ping()}.
+     * using {@link Peer#sendPing()}.
      */
     public void setPingIntervalMsec(long pingIntervalMsec) {
         lock.lock();

File: core/src/main/java/org/bitcoinj/core/VersionMessage.java
Patch:
@@ -270,7 +270,7 @@ private static void checkSubVerComponent(String component) {
 
     /**
      * Returns true if the clientVersion field is {@link NetworkParameters.ProtocolVersion#PONG} or higher.
-     * If it is then {@link Peer#ping()} is usable.
+     * If it is then {@link Peer#sendPing()} is usable.
      */
     public boolean isPingPongSupported() {
         return clientVersion >= params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG);

File: core/src/test/java/org/bitcoinj/core/BitcoindComparisonTool.java
Patch:
@@ -302,7 +302,7 @@ public static void main(String[] args) throws Exception {
                 locator = new BlockLocator();
                 locator = locator.add(bitcoindChainHead);
                 bitcoind.sendMessage(new GetHeadersMessage(PARAMS, locator, hashTo));
-                bitcoind.ping().get();
+                bitcoind.sendPing().get();
                 if (!chain.getChainHead().getHeader().getHash().equals(bitcoindChainHead)) {
                     rulesSinceFirstFail++;
                     log.error("ERROR: bitcoind and bitcoinj acceptance differs on block \"" + block.ruleName + "\"");
@@ -313,7 +313,7 @@ public static void main(String[] args) throws Exception {
             } else if (rule instanceof MemoryPoolState) {
                 MemoryPoolMessage message = new MemoryPoolMessage();
                 bitcoind.sendMessage(message);
-                bitcoind.ping().get();
+                bitcoind.sendPing().get();
                 if (mostRecentInv == null && !((MemoryPoolState) rule).mempool.isEmpty()) {
                     log.error("ERROR: bitcoind had an empty mempool, but we expected some transactions on rule " + rule.ruleName);
                     rulesSinceFirstFail++;

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -729,7 +729,7 @@ private void send(CoinSelector coinSelector, List<String> outputs, Coin feePerVk
             // Hack for regtest/single peer mode, as we're about to shut down and won't get an ACK from the remote end.
             List<Peer> peerList = peerGroup.getConnectedPeers();
             if (peerList.size() == 1)
-                peerList.get(0).ping().get();
+                peerList.get(0).sendPing().get();
         } catch (BlockStoreException | ExecutionException | InterruptedException | KeyCrypterException e) {
             throw new RuntimeException(e);
         } catch (InsufficientMoneyException e) {

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -512,7 +512,7 @@ public String serializePubB58(NetworkParameters params, ScriptType outputScriptT
     }
 
     /**
-     * Serialize public key to Base58
+     * Serialize private key to Base58
      * <p>
      * outputScriptType should not be used in generating "xprv" format. (and "zprv", "vprv", etc. should not be used)
      * @param params Network parameters indicating which network to serialize key for

File: core/src/main/java/org/bitcoinj/crypto/DumpedPrivateKey.java
Patch:
@@ -78,7 +78,7 @@ public static DumpedPrivateKey fromBase58(@Nullable Network network, String base
     @Deprecated
     public static DumpedPrivateKey fromBase58(@Nullable NetworkParameters params, String base58)
             throws AddressFormatException, AddressFormatException.WrongNetwork {
-        return fromBase58(params.network(), base58);
+        return fromBase58(params == null ? null : params.network(), base58);
     }
 
     private DumpedPrivateKey(Network network, byte[] bytes) {

File: core/src/main/java/org/bitcoinj/base/Address.java
Patch:
@@ -17,7 +17,6 @@
 package org.bitcoinj.base;
 
 import org.bitcoinj.base.exceptions.AddressFormatException;
-import org.bitcoinj.core.DefaultAddressParser;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 

File: core/src/main/java/org/bitcoinj/base/LegacyAddress.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.common.primitives.UnsignedBytes;
 import org.bitcoinj.base.exceptions.AddressFormatException;
 import org.bitcoinj.core.AddressMessage;
-import org.bitcoinj.core.DefaultAddressParser;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.PeerAddress;

File: core/src/main/java/org/bitcoinj/base/SegwitAddress.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.common.primitives.UnsignedBytes;
 import org.bitcoinj.base.exceptions.AddressFormatException;
-import org.bitcoinj.core.DefaultAddressParser;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 

File: core/src/main/java/org/bitcoinj/uri/BitcoinURI.java
Patch:
@@ -21,7 +21,7 @@
 import org.bitcoinj.base.exceptions.AddressFormatException;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.base.Address;
-import org.bitcoinj.core.DefaultAddressParser;
+import org.bitcoinj.base.DefaultAddressParser;
 import org.bitcoinj.core.NetworkParameters;
 
 import javax.annotation.Nonnull;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -36,7 +36,7 @@
 import org.bitcoinj.core.BloomFilter;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
-import org.bitcoinj.core.DefaultAddressParser;
+import org.bitcoinj.base.DefaultAddressParser;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.FilteredBlock;
 import org.bitcoinj.core.InsufficientMoneyException;

File: core/src/test/java/org/bitcoinj/base/LegacyAddressTest.java
Patch:
@@ -21,7 +21,6 @@
 import nl.jqno.equalsverifier.Warning;
 import org.bitcoinj.base.exceptions.AddressFormatException;
 import org.bitcoinj.base.utils.ByteUtils;
-import org.bitcoinj.core.DefaultAddressParser;
 import org.bitcoinj.core.DumpedPrivateKey;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;

File: core/src/test/java/org/bitcoinj/base/SegwitAddressTest.java
Patch:
@@ -21,7 +21,6 @@
 import nl.jqno.equalsverifier.Warning;
 import org.bitcoinj.base.exceptions.AddressFormatException;
 import org.bitcoinj.base.utils.ByteUtils;
-import org.bitcoinj.core.DefaultAddressParser;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptPattern;

File: core/src/test/java/org/bitcoinj/uri/BitcoinURITest.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.bitcoinj.base.BitcoinNetwork;
 import org.bitcoinj.base.Address;
-import org.bitcoinj.core.DefaultAddressParser;
+import org.bitcoinj.base.DefaultAddressParser;
 import org.bitcoinj.base.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.params.Networks;

File: core/src/test/java/org/bitcoinj/utils/MessageVerifyUtilsTest.java
Patch:
@@ -1,7 +1,7 @@
 package org.bitcoinj.utils;
 
 import org.bitcoinj.base.AddressParser;
-import org.bitcoinj.core.DefaultAddressParser;
+import org.bitcoinj.base.DefaultAddressParser;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.TestNet3Params;

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -23,7 +23,7 @@
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.base.AddressParser;
 import org.bitcoinj.core.Context;
-import org.bitcoinj.core.DefaultAddressParser;
+import org.bitcoinj.base.DefaultAddressParser;
 import org.bitcoinj.core.InsufficientMoneyException;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionBroadcast;

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -20,6 +20,7 @@
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.utils.ByteUtils;
+import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Transaction;
@@ -57,6 +58,7 @@ public class DefaultRiskAnalysisTest {
 
     @Before
     public void setup() {
+        Context.propagate(new Context());
         wallet = Wallet.createDeterministic(MAINNET, ScriptType.P2PKH);
         wallet.setLastBlockSeenHeight(1000);
         wallet.setLastBlockSeenTimeSecs(TIMESTAMP);

File: core/src/main/java/org/bitcoinj/core/Address.java
Patch:
@@ -35,7 +35,6 @@
  * form.
  */
 public abstract class Address implements Comparable<Address> {
-    protected static final AddressParser addressParser = new DefaultAddressParser();
     protected final Network network;
     protected final byte[] bytes;
 
@@ -80,6 +79,7 @@ protected Address(Network network, byte[] bytes) {
     @Deprecated
     public static Address fromString(@Nullable NetworkParameters params, String str)
             throws AddressFormatException {
+        AddressParser addressParser = DefaultAddressParser.fromNetworks();
         return (params != null)
                     ? addressParser.parseAddress(str, params.network())
                     : addressParser.parseAddressAnyNetwork(str);

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -481,9 +481,6 @@ protected void processMessage(Message m) throws Exception {
         } else if (m instanceof GetDataMessage) {
             processGetData((GetDataMessage) m);
         } else if (m instanceof AddressMessage) {
-            // We don't care about addresses of the network right now. But in future,
-            // we should save them in the wallet so we don't put too much load on the seed nodes and can
-            // properly explore the network.
             processAddressMessage((AddressMessage) m);
         } else if (m instanceof HeadersMessage) {
             processHeaders((HeadersMessage) m);

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -373,7 +373,7 @@ protected void startUp() throws Exception {
             for (PeerAddress addr : peerAddresses) vPeerGroup.addAddress(addr);
             vPeerGroup.setMaxConnections(peerAddresses.length);
             peerAddresses = null;
-        } else if (!params.getId().equals(BitcoinNetwork.ID_REGTEST)) {
+        } else if (params.network() != BitcoinNetwork.REGTEST) {
             vPeerGroup.addPeerDiscovery(discovery != null ? discovery : new DnsDiscovery(params));
         }
         vChain.addWallet(vWallet);

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -102,7 +102,7 @@ public static boolean isSelectable(Transaction tx) {
                type.equals(TransactionConfidence.ConfidenceType.PENDING) &&
                confidence.getSource().equals(TransactionConfidence.Source.SELF) &&
                // In regtest mode we expect to have only one peer, so we won't see transactions propagate.
-               (confidence.numBroadcastPeers() > 0 || tx.getParams().getId().equals(BitcoinNetwork.ID_REGTEST));
+               (confidence.numBroadcastPeers() > 0 || tx.getParams().network() == BitcoinNetwork.REGTEST);
     }
 
     private static DefaultCoinSelector instance;

File: tools/src/main/java/org/bitcoinj/tools/BuildCheckpoints.java
Patch:
@@ -220,17 +220,17 @@ private static void sanityCheck(File file, int expectedSize) throws IOException
 
         checkState(manager.numCheckpoints() == expectedSize);
 
-        if (params.getId().equals(BitcoinNetwork.ID_MAINNET)) {
+        if (params.network() == BitcoinNetwork.MAINNET) {
             StoredBlock test = manager.getCheckpointBefore(1390500000); // Thu Jan 23 19:00:00 CET 2014
             checkState(test.getHeight() == 280224);
             checkState(test.getHeader().getHashAsString()
                     .equals("00000000000000000b5d59a15f831e1c45cb688a4db6b0a60054d49a9997fa34"));
-        } else if (params.getId().equals(BitcoinNetwork.ID_TESTNET)) {
+        } else if (params.network() == BitcoinNetwork.TESTNET) {
             StoredBlock test = manager.getCheckpointBefore(1390500000); // Thu Jan 23 19:00:00 CET 2014
             checkState(test.getHeight() == 167328);
             checkState(test.getHeader().getHashAsString()
                     .equals("0000000000035ae7d5025c2538067fe7adb1cf5d5d9c31b024137d9090ed13a9"));
-        } else if (params.getId().equals(BitcoinNetwork.ID_SIGNET)) {
+        } else if (params.network() == BitcoinNetwork.SIGNET) {
             StoredBlock test = manager.getCheckpointBefore(1642000000); // 2022-01-12
             checkState(test.getHeight() == 72576);
             checkState(test.getHeader().getHashAsString()

File: core/src/main/java/org/bitcoinj/base/Base58.java
Patch:
@@ -28,7 +28,7 @@
  * <p>
  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
  * <p>
- * You may want to consider working with {@code org.bitcoinj.core.PrefixedChecksummedBytes} instead, which
+ * You may want to consider working with {@code org.bitcoinj.core.EncodedPrivateKey} instead, which
  * adds support for testing the prefix and suffix bytes commonly found in addresses.
  * <p>
  * Satoshi explains: why base-58 instead of standard base-64 encoding?

File: core/src/main/java/org/bitcoinj/core/DumpedPrivateKey.java
Patch:
@@ -30,7 +30,7 @@
  * bytes with a header byte and 4 checksum bytes at the end. If there are 33 private key bytes instead of 32, then
  * the last byte is a discriminator value for the compressed pubkey.
  */
-public class DumpedPrivateKey extends PrefixedChecksummedBytes {
+public class DumpedPrivateKey extends EncodedPrivateKey {
 
     /**
      * Construct a private key from its Base58 representation.

File: core/src/main/java/org/bitcoinj/crypto/BIP38PrivateKey.java
Patch:
@@ -22,8 +22,8 @@
 import org.bitcoinj.base.exceptions.AddressFormatException;
 import org.bitcoinj.base.Base58;
 import org.bitcoinj.core.ECKey;
+import org.bitcoinj.core.EncodedPrivateKey;
 import org.bitcoinj.core.NetworkParameters;
-import org.bitcoinj.core.PrefixedChecksummedBytes;
 import org.bitcoinj.base.Sha256Hash;
 import org.bouncycastle.crypto.generators.SCrypt;
 
@@ -41,7 +41,7 @@
  * Implementation of <a href="https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki">BIP 38</a>
  * passphrase-protected private keys. Currently, only decryption is supported.
  */
-public class BIP38PrivateKey extends PrefixedChecksummedBytes {
+public class BIP38PrivateKey extends EncodedPrivateKey {
     public final boolean ecMultiply;
     public final boolean compressed;
     public final boolean hasLotAndSequence;

File: core/src/main/java/org/bitcoinj/core/AddressParser.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core;
 
 import org.bitcoinj.base.BitcoinNetwork;
+import org.bitcoinj.base.Network;
 import org.bitcoinj.base.exceptions.AddressFormatException;
 
 
@@ -40,7 +41,7 @@ public interface AddressParser {
      * @return A validated address object
      * @throws AddressFormatException invalid address string or not valid for specified network
      */
-    Address parseAddress(String addressString, BitcoinNetwork network) throws AddressFormatException;
+    Address parseAddress(String addressString, Network network) throws AddressFormatException;
 
     @FunctionalInterface
     interface Strict {

File: core/src/main/java/org/bitcoinj/core/DefaultAddressParser.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core;
 
 import org.bitcoinj.base.BitcoinNetwork;
+import org.bitcoinj.base.Network;
 import org.bitcoinj.base.exceptions.AddressFormatException;
 
 /**
@@ -29,7 +30,7 @@ public Address parseAddressAnyNetwork(String addressString) throws AddressFormat
     }
 
     @Override
-    public Address parseAddress(String addressString, BitcoinNetwork network) throws AddressFormatException {
+    public Address parseAddress(String addressString, Network network) throws AddressFormatException {
         NetworkParameters params = (network != null) ? NetworkParameters.of(network) : null;
         try {
             return LegacyAddress.fromBase58(params, addressString);

File: core/src/main/java/org/bitcoinj/core/ECKey.java
Patch:
@@ -25,6 +25,7 @@
 import org.bitcoin.NativeSecp256k1Util;
 import org.bitcoin.Secp256k1Context;
 import org.bitcoinj.base.BitcoinNetwork;
+import org.bitcoinj.base.Network;
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.base.utils.ByteUtils;
@@ -418,7 +419,7 @@ public boolean isCompressed() {
         return pub.isCompressed();
     }
 
-    public Address toAddress(ScriptType scriptType, BitcoinNetwork network) {
+    public Address toAddress(ScriptType scriptType, Network network) {
         NetworkParameters params = NetworkParameters.of(network);
         if (scriptType == ScriptType.P2PKH) {
             return LegacyAddress.fromPubKeyHash(params, this.getPubKeyHash());

File: core/src/main/java/org/bitcoinj/core/LegacyAddress.java
Patch:
@@ -20,7 +20,7 @@
 
 import com.google.common.primitives.UnsignedBytes;
 import org.bitcoinj.base.Base58;
-import org.bitcoinj.base.BitcoinNetwork;
+import org.bitcoinj.base.Network;
 import org.bitcoinj.base.exceptions.AddressFormatException;
 import org.bitcoinj.params.Networks;
 import org.bitcoinj.base.ScriptType;
@@ -53,7 +53,7 @@ public class LegacyAddress extends Address {
     /**
      * Private constructor. Use {@link #fromBase58(NetworkParameters, String)},
      * {@link #fromPubKeyHash(NetworkParameters, byte[])}, {@link #fromScriptHash(NetworkParameters, byte[])} or
-     * {@link ECKey#toAddress(ScriptType, BitcoinNetwork)}.
+     * {@link ECKey#toAddress(ScriptType, Network)}.
      * 
      * @param params
      *            network this address is valid for
@@ -93,7 +93,7 @@ public static LegacyAddress fromPubKeyHash(NetworkParameters params, byte[] hash
      * @param key
      *            only the public part is used
      * @return constructed address
-     * @deprecated Use {@link ECKey#toAddress(ScriptType, BitcoinNetwork)}
+     * @deprecated Use {@link ECKey#toAddress(ScriptType, Network)}
      */
     @Deprecated
     public static LegacyAddress fromKey(NetworkParameters params, ECKey key) {

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -140,8 +140,8 @@ public String getId() {
     /**
      * @return Network enum for this network
      */
-    public BitcoinNetwork network() {
-        return (BitcoinNetwork) network;
+    public Network network() {
+        return network;
     }
 
     /**
@@ -204,7 +204,7 @@ public static NetworkParameters fromPmtProtocolID(String pmtProtocolId) {
     /**
      * Get a NetworkParameters from an Address.
      * Addresses should not be used for storing NetworkParameters. In the future Address will
-     * be an {@code interface} that only makes a {@link BitcoinNetwork} available.
+     * be an {@code interface} that only makes a {@link Network} available.
      * @param address An address
      * @return network parameters
      * @deprecated You should be using {@link Address#network()} instead

File: core/src/main/java/org/bitcoinj/core/SegwitAddress.java
Patch:
@@ -237,7 +237,7 @@ public static SegwitAddress fromProgram(NetworkParameters params, int witnessVer
      * @param key
      *            only the public part is used
      * @return constructed address
-     * @deprecated Use {@link ECKey#toAddress(ScriptType, org.bitcoinj.base.BitcoinNetwork)}
+     * @deprecated Use {@link ECKey#toAddress(ScriptType, org.bitcoinj.base.Network)}
      */
     @Deprecated
     public static SegwitAddress fromKey(NetworkParameters params, ECKey key) {

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -116,7 +116,7 @@ public class WalletAppKit extends AbstractIdleService {
      */
     @Deprecated
     public WalletAppKit(NetworkParameters params, File directory, String filePrefix) {
-        this(params.network(), ScriptType.P2PKH, KeyChainGroupStructure.BIP32, directory, filePrefix);
+        this((BitcoinNetwork) params.network(), ScriptType.P2PKH, KeyChainGroupStructure.BIP32, directory, filePrefix);
     }
 
     /**
@@ -126,7 +126,7 @@ public WalletAppKit(NetworkParameters params, File directory, String filePrefix)
     @Deprecated
     public WalletAppKit(NetworkParameters params, ScriptType preferredOutputScriptType,
             @Nullable KeyChainGroupStructure structure, File directory, String filePrefix) {
-        this(params.network(), preferredOutputScriptType, structure, directory, filePrefix);
+        this((BitcoinNetwork) params.network(), preferredOutputScriptType, structure, directory, filePrefix);
     }
 
     /**

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -508,7 +508,7 @@ public NetworkParameters getNetworkParameters() {
      */
     @Override
     public Address parseAddress(String addressString) throws AddressFormatException {
-        return addressParser.parseAddress(addressString, params.network());
+        return addressParser.parseAddress(addressString, (BitcoinNetwork) params.network());
     }
 
     /**
@@ -3728,7 +3728,7 @@ public Coin getBalance(CoinSelector selector) {
         try {
             checkNotNull(selector);
             List<TransactionOutput> candidates = calculateAllSpendCandidates(true, false);
-            CoinSelection selection = selector.select(params.network().maxMoney(), candidates);
+            CoinSelection selection = selector.select((Coin) params.network().maxMoney(), candidates);
             return selection.totalValue();
         } finally {
             lock.unlock();
@@ -4251,7 +4251,7 @@ public void completeTx(SendRequest req) throws InsufficientMoneyException, BadWa
                 // of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                 checkState(req.tx.getOutputs().size() == 1, "Empty wallet TX must have a single output only.");
                 CoinSelector selector = req.coinSelector == null ? coinSelector : req.coinSelector;
-                bestCoinSelection = selector.select(params.network().maxMoney(), candidates);
+                bestCoinSelection = selector.select((Coin) params.network().maxMoney(), candidates);
                 candidates = null;  // Selector took ownership and might have changed candidates. Don't access again.
                 req.tx.getOutput(0).setValue(bestCoinSelection.totalValue());
                 log.info("  emptying {}", bestCoinSelection.totalValue().toFriendlyString());

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -78,7 +78,7 @@ public static void main(String[] args) {
         } else {
             // Infer network from address
             address = addressParser.parseAddressAnyNetwork(args[0]);
-            network = address.network();
+            network = (BitcoinNetwork) address.network();
         }
 
         forward(new File("."), network, address);

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/application/WalletApplication.java
Patch:
@@ -22,6 +22,7 @@
 import javafx.stage.Stage;
 import org.bitcoinj.base.BitcoinNetwork;
 import org.bitcoinj.base.ScriptType;
+import org.bitcoinj.core.Context;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Utils;
 import org.bitcoinj.kits.WalletAppKit;
@@ -129,6 +130,7 @@ private void startImpl(Stage primaryStage) throws IOException {
     }
 
     protected void startWalletAppKit(Stage primaryStage) throws IOException {
+        Context.propagate(new Context());
         // Tell bitcoinj to run event handlers on the JavaFX UI thread. This keeps things simple and means
         // we cannot forget to switch threads when adding event handlers. Unfortunately, the DownloadListener
         // we give to the app kit is currently an exception and runs on a library thread. It'll get fixed in

File: core/src/main/java/org/bitcoinj/core/LegacyAddress.java
Patch:
@@ -190,8 +190,7 @@ public ScriptType getOutputScriptType() {
      */
     @Deprecated
     public static NetworkParameters getParametersFromAddress(String address) throws AddressFormatException {
-        // TODO: Provide a `Network`-based mechanism for resolving "alt addresses"
-        return NetworkParameters.fromAddress(LegacyAddress.fromBase58(null, address));
+        return NetworkParameters.fromAddress(Address.addressParser.parseAddressAnyNetwork(address));
     }
 
     @Override

File: core/src/test/java/org/bitcoinj/core/AddressComparatorSortTest.java
Patch:
@@ -31,6 +31,8 @@
  * the default comparators.
  */
 public class AddressComparatorSortTest {
+    private static final AddressParser addressParser = new DefaultAddressParser();
+
     /**
      * A manually sorted list of address for verifying sorting with our default comparator.
      * See {@link Address#compareTo}.
@@ -48,7 +50,7 @@ public class AddressComparatorSortTest {
                     // Test net, Segwit
                     "tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7",
                     "tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx"
-            ).map(s -> Address.fromString(null, s))
+            ).map(addressParser::parseAddressAnyNetwork)
             .collect(StreamUtils.toUnmodifiableList());
 
     @Test

File: examples/src/main/java/org/bitcoinj/examples/DoubleSpend.java
Patch:
@@ -46,8 +46,9 @@ public static void main(String[] args) throws Exception {
         System.out.println(kit.wallet());
 
         kit.wallet().getBalanceFuture(COIN, Wallet.BalanceType.AVAILABLE).get();
-        Transaction tx1 = kit.wallet().createSend(Address.fromString(kit.params(), "bcrt1qsmf9envp5dphlu6my2tpwfmce0793jvpvlg5ez"), CENT);
-        Transaction tx2 = kit.wallet().createSend(Address.fromString(kit.params(), "bcrt1qsmf9envp5dphlu6my2tpwfmce0793jvpvlg5ez"), CENT.add(SATOSHI.multiply(10)));
+        Address destinationAddress = kit.wallet().parseAddress("bcrt1qsmf9envp5dphlu6my2tpwfmce0793jvpvlg5ez");
+        Transaction tx1 = kit.wallet().createSend(destinationAddress, CENT);
+        Transaction tx2 = kit.wallet().createSend(destinationAddress, CENT.add(SATOSHI.multiply(10)));
         final Peer peer = kit.peerGroup().getConnectedPeers().get(0);
         peer.addPreMessageReceivedEventListener(Threading.SAME_THREAD,
                 (peer1, m) -> {

File: examples/src/main/java/org/bitcoinj/examples/PrivateKeys.java
Patch:
@@ -60,13 +60,14 @@ public static void main(String[] args) throws Exception {
                 key = ECKey.fromPrivate(privKey);
             }
             System.out.println("Address from private key is: " + SegwitAddress.fromKey(params, key).toString());
-            // And the address ...
-            Address destination = Address.fromString(params, args[1]);
 
             // Import the private key to a fresh wallet.
             Wallet wallet = Wallet.createDeterministic(params, ScriptType.P2PKH);
             wallet.importKey(key);
 
+            // And the address ...
+            Address destination = wallet.parseAddress(args[1]);
+
             // Find the transactions that involve those coins.
             final MemoryBlockStore blockStore = new MemoryBlockStore(params);
             BlockChain chain = new BlockChain(params, wallet, blockStore);

File: examples/src/main/java/org/bitcoinj/examples/SendRequest.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String[] args) throws Exception {
 
         // To which address you want to send the coins?
         // The Address class represents a Bitcoin address.
-        Address to = Address.fromString(kit.params(), "bcrt1qspfueag7fvty7m8htuzare3xs898zvh30fttu2");
+        Address to = kit.wallet().parseAddress("bcrt1qspfueag7fvty7m8htuzare3xs898zvh30fttu2");
         System.out.println("Send money to: " + to.toString());
 
         // There are different ways to create and publish a SendRequest. This is probably the easiest one.

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -69,7 +69,7 @@ public void initialize() {
         app = WalletApplication.instance();
         Coin balance = app.walletAppKit().wallet().getBalance();
         checkState(!balance.isZero());
-        new BitcoinAddressValidator(app.network(), address, sendBtn);
+        new BitcoinAddressValidator(app.walletAppKit().wallet(), address, sendBtn);
         new TextFieldValidator(amountEdit, text ->
                 !WTUtils.didThrow(() -> checkState(Coin.parseCoin(text).compareTo(balance) <= 0)));
         amountEdit.setText(balance.toPlainString());
@@ -84,7 +84,7 @@ public void send(ActionEvent event) {
         // Address exception cannot happen as we validated it beforehand.
         try {
             Coin amount = Coin.parseCoin(amountEdit.getText());
-            Address destination = Address.fromString(NetworkParameters.of(app.network()), address.getText());
+            Address destination = app.walletAppKit().wallet().parseAddress(address.getText());
             SendRequest req;
             if (amount.equals(app.walletAppKit().wallet().getBalance()))
                 req = SendRequest.emptyWallet(destination);

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -446,7 +446,7 @@ public Integer call() throws IOException, BlockStoreException {
                     if (selectAddrStr != null) {
                         Address selectAddr;
                         try {
-                            selectAddr = Address.fromString(params, selectAddrStr);
+                            selectAddr = wallet.parseAddress(selectAddrStr);
                         } catch (AddressFormatException x) {
                             System.err.println("Could not parse given address, or wrong network: " + selectAddrStr);
                             return 1;
@@ -761,7 +761,7 @@ public OutputSpec(String spec) throws IllegalArgumentException {
                 addr = null;
             } else {
                 // Treat as an address.
-                addr = Address.fromString(params, destination);
+                addr = wallet.parseAddress(destination);
                 key = null;
             }
         }
@@ -1228,7 +1228,7 @@ private void deleteKey() {
             key = wallet.findKeyFromPubKey(HEX.decode(pubKeyStr));
         } else {
             try {
-                Address address = Address.fromString(wallet.getParams(), addrStr);
+                Address address = wallet.parseAddress(addrStr);
                 key = wallet.findKeyFromAddress(address);
             } catch (AddressFormatException e) {
                 System.err.println(addrStr + " does not parse as a Bitcoin address of the right network parameters.");

File: core/src/test/java/org/bitcoinj/store/SPVBlockStoreTest.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.common.base.Stopwatch;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Block;
+import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;
@@ -53,6 +54,7 @@ public static void setUpClass() {
 
     @Before
     public void setup() throws Exception {
+        Context.propagate(new Context());
         blockStoreFile = File.createTempFile("spvblockstore", null);
         blockStoreFile.delete();
         blockStoreFile.deleteOnExit();

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -76,6 +76,7 @@ public class TransactionTest {
     @Before
     public void setUp() {
         tx = FakeTxBuilder.createFakeTx(UNITTEST);
+        Context.propagate(new Context());
     }
 
     @Test(expected = VerificationException.EmptyInputsOrOutputs.class)

File: core/src/test/java/org/bitcoinj/core/ParseByteCacheTest.java
Patch:
@@ -90,6 +90,7 @@ private void resetBlockStore() {
     @Before
     public void setUp() throws Exception {
         Utils.setMockClock(); // Use mock clock
+        Context.propagate(new Context());
         Wallet wallet = Wallet.createDeterministic(UNITTEST, ScriptType.P2PKH);
         wallet.freshReceiveKey();
 

File: core/src/test/java/org/bitcoinj/core/BlockTest.java
Patch:
@@ -59,6 +59,7 @@ public class BlockTest {
 
     @Before
     public void setUp() throws Exception {
+        Context.propagate(new Context());
         // One with some of transactions in, so a good test of the merkle tree hashing.
         block700000Bytes = ByteStreams.toByteArray(BlockTest.class.getResourceAsStream("block_testnet700000.dat"));
         block700000 = TESTNET.getDefaultSerializer().makeBlock(block700000Bytes);

File: core/src/main/java/org/bitcoinj/core/TransactionBroadcast.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  * Represents a single transaction broadcast that we are performing. A broadcast occurs after a new transaction is created
- * (typically by a {@link Wallet} and needs to be sent to the network. A broadcast can succeed or fail. A success is
+ * (typically by a {@link Wallet}) and needs to be sent to the network. A broadcast can succeed or fail. A success is
  * defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance. A failure
  * is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from a peer
  * indicating that the transaction was not acceptable.

File: integration-test/src/test/java/org/bitcoinj/kits/WalletAppKitTest.java
Patch:
@@ -20,18 +20,18 @@
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
-import org.junit.Ignore;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 
 import java.io.File;
 
 /**
  * WalletAppKit Functional/Integration test. Uses {@link BitcoinNetwork#TESTNET} so is {@code @Ignore}d.
- * To run this test comment-out the {@code @Ignore} annotation.
+ * To run this test comment-out the {@code @Disabled} annotation.
  */
-@Ignore
+@Disabled
 public class WalletAppKitTest {
     static final BitcoinNetwork network = BitcoinNetwork.TESTNET;
     static final int MAX_CONNECTIONS = 3;

File: core/src/main/java/org/bitcoinj/wallet/CoinSelection.java
Patch:
@@ -39,7 +39,7 @@ public CoinSelection(Collection<TransactionOutput> gathered) {
     }
 
     /**
-     * @deprecated use {@link #CoinSelection(Collection<TransactionOutput>)}
+     * @deprecated use {@link #CoinSelection(Collection)}
      */
     @Deprecated
     public CoinSelection(Coin valueGathered, Collection<TransactionOutput> gathered) {

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.wallet;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.math.LongMath;
 import org.bitcoinj.base.BitcoinNetwork;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Transaction;
@@ -57,7 +58,7 @@ public CoinSelection select(Coin target, List<TransactionOutput> candidates) {
             // Only pick chain-included transactions, or transactions that are ours and pending.
             if (!shouldSelect(output.getParentTransaction())) continue;
             selected.add(output);
-            total += output.getValue().value;
+            total = LongMath.checkedAdd(total, output.getValue().value);
         }
         // Total may be lower than target here, if the given candidates were insufficient to create to requested
         // transaction.

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -21,6 +21,7 @@
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.core.Context;
 import org.bitcoinj.core.InsufficientMoneyException;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;
@@ -49,6 +50,8 @@ public class ForwardingService {
     public static void main(String[] args) throws Exception {
         // This line makes the log output more compact and easily read, especially when using the JDK log adapter.
         BriefLogFormatter.init();
+        Context.propagate(new Context());
+
         if (args.length < 1) {
             System.err.println("Usage: address-to-send-back-to [mainnet|testnet|signet|regtest]");
             return;

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -159,7 +159,7 @@ static String getPrefix(BitcoinNetwork network) {
     static Optional<BitcoinNetwork> parseNetwork(String networkOption) {
         switch (networkOption) {
             case "main":    return Optional.of(BitcoinNetwork.MAIN);
-            case "test":    return Optional.of(BitcoinNetwork.TEST);
+            case "testnet": return Optional.of(BitcoinNetwork.TEST);
             case "regtest": return Optional.of(BitcoinNetwork.REGTEST);
             case "signet":  return Optional.of(BitcoinNetwork.SIGNET);
             default:        return Optional.empty();

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -80,7 +80,6 @@ public Context(NetworkParameters params, int eventHorizon, Coin feePerKb, boolea
         this.ensureMinRequiredFee = ensureMinRequiredFee;
         this.feePerKb = feePerKb;
         lastConstructed = this;
-        slot.set(this);
     }
 
     private static volatile Context lastConstructed;

File: core/src/test/java/org/bitcoinj/core/TxConfidenceTableTest.java
Patch:
@@ -46,6 +46,7 @@ public class TxConfidenceTableTest {
     public void setup() throws Exception {
         BriefLogFormatter.init();
         Context context = new Context(UNITTEST);
+        Context.propagate(context);
         table = context.getConfidenceTable();
 
         Address to = LegacyAddress.fromKey(UNITTEST, new ECKey());

File: integration-test/src/test/java/org/bitcoinj/core/FilteredBlockAndPartialMerkleTreeTest.java
Patch:
@@ -66,7 +66,7 @@ public FilteredBlockAndPartialMerkleTreeTest(ClientType clientType) {
 
     @Before
     public void setUp() throws Exception {
-        new Context(UNITTEST);
+        Context.propagate(new Context(UNITTEST));
         MemoryBlockStore store = new MemoryBlockStore(UNITTEST);
 
         // Cheat and place the previous block (block 100000) at the head of the block store without supporting blocks

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -959,7 +959,7 @@ public void addUnspentTransactionOutput(UTXO out) throws BlockStoreException {
             s.setBytes(5, out.getScript().getProgram());
             s.setString(6, out.getAddress());
             ScriptType scriptType = out.getScript().getScriptType();
-            s.setInt(7, scriptType != null ? scriptType.id : 0);
+            s.setInt(7, scriptType != null ? scriptType.numericId() : 0);
             s.setBoolean(8, out.isCoinbase());
             s.executeUpdate();
             s.close();

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -167,7 +167,6 @@ public int hashCode() {
      * Return network parameters for a network id
      * @param id the network id
      * @return the network parameters for the given string ID or NULL if not recognized
-     * @deprecated Use {@link AbstractBitcoinNetParams#fromID(String)}
      */
     @Deprecated
     @Nullable

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -34,6 +34,7 @@
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.BlockStoreException;
 import org.bitcoinj.store.SPVBlockStore;
+import org.bitcoinj.utils.Network;
 import org.bitcoinj.wallet.DeterministicSeed;
 import org.bitcoinj.wallet.KeyChainGroup;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
@@ -363,7 +364,7 @@ protected void startUp() throws Exception {
                 for (PeerAddress addr : peerAddresses) vPeerGroup.addAddress(addr);
                 vPeerGroup.setMaxConnections(peerAddresses.length);
                 peerAddresses = null;
-            } else if (!params.getId().equals(NetworkParameters.ID_REGTEST)) {
+            } else if (!params.getId().equals(Network.ID_REGTEST)) {
                 vPeerGroup.addPeerDiscovery(discovery != null ? discovery : new DnsDiscovery(params));
             }
             vChain.addWallet(vWallet);

File: core/src/main/java/org/bitcoinj/params/MainNetParams.java
Patch:
@@ -20,6 +20,7 @@
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Sha256Hash;
+import org.bitcoinj.utils.Network;
 
 import static com.google.common.base.Preconditions.checkState;
 
@@ -36,7 +37,8 @@ public class MainNetParams extends AbstractBitcoinNetParams {
 
     public MainNetParams() {
         super();
-        id = ID_MAINNET;
+        network = Network.MAIN;
+        id = Network.ID_MAINNET;
 
         targetTimespan = TARGET_TIMESPAN;
         maxTarget = ByteUtils.decodeCompactBits(Block.STANDARD_MAX_DIFFICULTY_TARGET);

File: core/src/main/java/org/bitcoinj/params/RegTestParams.java
Patch:
@@ -20,6 +20,7 @@
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Sha256Hash;
+import org.bitcoinj.utils.Network;
 
 import static com.google.common.base.Preconditions.checkState;
 
@@ -33,7 +34,8 @@ public class RegTestParams extends AbstractBitcoinNetParams {
 
     public RegTestParams() {
         super();
-        id = ID_REGTEST;
+        network = Network.REGTEST;
+        id = Network.ID_REGTEST;
         
         targetTimespan = TARGET_TIMESPAN;
         maxTarget = ByteUtils.decodeCompactBits(Block.EASIEST_DIFFICULTY_TARGET);

File: core/src/main/java/org/bitcoinj/params/SigNetParams.java
Patch:
@@ -19,6 +19,7 @@
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.Block;
 import org.bitcoinj.base.Sha256Hash;
+import org.bitcoinj.utils.Network;
 
 import static com.google.common.base.Preconditions.checkState;
 
@@ -38,7 +39,8 @@ public class SigNetParams extends AbstractBitcoinNetParams {
 
     public SigNetParams() {
         super();
-        id = ID_SIGNET;
+        network = Network.SIGNET;
+        id = Network.ID_SIGNET;
 
         targetTimespan = TARGET_TIMESPAN;
         maxTarget = ByteUtils.decodeCompactBits(Block.EASIEST_DIFFICULTY_TARGET);

File: core/src/main/java/org/bitcoinj/params/TestNet3Params.java
Patch:
@@ -25,6 +25,7 @@
 import org.bitcoinj.core.VerificationException;
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.BlockStoreException;
+import org.bitcoinj.utils.Network;
 
 import java.math.BigInteger;
 import java.util.Date;
@@ -45,7 +46,8 @@ public class TestNet3Params extends AbstractBitcoinNetParams {
 
     public TestNet3Params() {
         super();
-        id = ID_TESTNET;
+        network = Network.TEST;
+        id = Network.ID_TESTNET;
 
         targetTimespan = TARGET_TIMESPAN;
         maxTarget = ByteUtils.decodeCompactBits(Block.STANDARD_MAX_DIFFICULTY_TARGET);

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -22,6 +22,7 @@
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionConfidence;
 import org.bitcoinj.core.TransactionOutput;
+import org.bitcoinj.utils.Network;
 
 import java.math.BigInteger;
 import java.util.ArrayList;
@@ -101,7 +102,7 @@ public static boolean isSelectable(Transaction tx) {
                type.equals(TransactionConfidence.ConfidenceType.PENDING) &&
                confidence.getSource().equals(TransactionConfidence.Source.SELF) &&
                // In regtest mode we expect to have only one peer, so we won't see transactions propagate.
-               (confidence.numBroadcastPeers() > 0 || tx.getParams().getId().equals(NetworkParameters.ID_REGTEST));
+               (confidence.numBroadcastPeers() > 0 || tx.getParams().getId().equals(Network.ID_REGTEST));
     }
 
     private static DefaultCoinSelector instance;

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -19,14 +19,14 @@
 
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.ECKey.ECDSASignature;
-import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.SignatureDecodeException;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionConfidence;
 import org.bitcoinj.core.TransactionInput;
 import org.bitcoinj.core.TransactionOutput;
 import org.bitcoinj.crypto.TransactionSignature;
 import org.bitcoinj.script.ScriptChunk;
+import org.bitcoinj.utils.Network;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -200,7 +200,7 @@ public static RuleViolation isInputStandard(TransactionInput input) {
     private Result analyzeIsStandard() {
         // The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't want to
         // crush innovation with valueless test coins.
-        if (wallet != null && !wallet.getNetworkParameters().getId().equals(NetworkParameters.ID_MAINNET))
+        if (wallet != null && !wallet.getNetworkParameters().getId().equals(Network.ID_MAINNET))
             return Result.OK;
 
         RuleViolation ruleViolation = isStandard(tx);

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -29,6 +29,7 @@
 import org.bitcoinj.crypto.KeyCrypter;
 import org.bitcoinj.crypto.KeyCrypterScrypt;
 import org.bitcoinj.crypto.LinuxSecureRandom;
+import org.bitcoinj.params.UnitTestParams;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.script.ScriptBuilder;
@@ -270,7 +271,7 @@ private KeyChainGroup(NetworkParameters params, @Nullable BasicKeyChain basicKey
         if (chains != null) {
             if (lookaheadSize > -1)
                 this.lookaheadSize = lookaheadSize;
-            else if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))
+            else if (params.getId().equals(Network.ID_UNITTESTNET))
                 this.lookaheadSize = 5; // Cut down excess computation for unit tests.
             if (lookaheadThreshold > -1)
                 this.lookaheadThreshold = lookaheadThreshold;

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroupStructure.java
Patch:
@@ -63,7 +63,7 @@ default HDPath accountPathFor(ScriptType outputScriptType) {
      * @return The HD Path: purpose / coinType / accountIndex
      */
     default HDPath accountPathFor(ScriptType outputScriptType, NetworkParameters networkParameters) {
-        return accountPathFor(outputScriptType, Network.of(networkParameters));
+        return accountPathFor(outputScriptType, networkParameters.network());
     }
 
 
@@ -112,7 +112,7 @@ static HDPath purpose(ScriptType scriptType) {
 
     /**
      * Return coin type path component for a network id
-     * @param network network id string, eg. {@link NetworkParameters#ID_MAINNET}
+     * @param network network id string, eg. {@link Network#ID_MAINNET}
      */
     static ChildNumber coinType(Network network) {
         switch (network) {

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -81,6 +81,7 @@
 import org.bitcoinj.utils.FutureUtils;
 import org.bitcoinj.utils.ListenableCompletableFuture;
 import org.bitcoinj.utils.ListenerRegistration;
+import org.bitcoinj.utils.Network;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
 import org.bitcoinj.wallet.WalletTransaction.Pool;
@@ -3998,7 +3999,7 @@ public Transaction createSend(Address address, Coin value)
     public Transaction createSend(Address address, Coin value, boolean allowUnconfirmed)
             throws InsufficientMoneyException, BadWalletEncryptionKeyException {
         SendRequest req = SendRequest.to(address, value);
-        if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))
+        if (params.getId().equals(Network.ID_UNITTESTNET))
             req.shuffleOutputs = false;
         if (allowUnconfirmed)
             req.allowUnconfirmed();

File: core/src/test/java/org/bitcoinj/core/LegacyAddressTest.java
Patch:
@@ -28,6 +28,7 @@
 import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptPattern;
+import org.bitcoinj.utils.Network;
 import org.junit.Test;
 
 import java.io.BufferedReader;
@@ -123,6 +124,7 @@ public void getAltNetwork() {
         class AltNetwork extends MainNetParams {
             AltNetwork() {
                 super();
+                network = Network.REGTEST; // TODO: Solution for enums for alt networks??
                 id = "alt.network";
                 addressHeader = 48;
                 p2shHeader = 5;

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -29,6 +29,7 @@
 import org.bitcoinj.script.ScriptError;
 import org.bitcoinj.script.ScriptException;
 import org.bitcoinj.testing.FakeTxBuilder;
+import org.bitcoinj.utils.Network;
 import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
@@ -245,7 +246,7 @@ public void witnessTransaction() {
 
         // Roundtrip without witness
         hex = "0100000003362c10b042d48378b428d60c5c98d8b8aca7a03e1a2ca1048bfd469934bbda95010000008b483045022046c8bc9fb0e063e2fc8c6b1084afe6370461c16cbf67987d97df87827917d42d022100c807fa0ab95945a6e74c59838cc5f9e850714d8850cec4db1e7f3bcf71d5f5ef0141044450af01b4cc0d45207bddfb47911744d01f768d23686e9ac784162a5b3a15bc01e6653310bdd695d8c35d22e9bb457563f8de116ecafea27a0ec831e4a3e9feffffffffc19529a54ae15c67526cc5e20e535973c2d56ef35ff51bace5444388331c4813000000008b48304502201738185959373f04cc73dbbb1d061623d51dc40aac0220df56dabb9b80b72f49022100a7f76bde06369917c214ee2179e583fefb63c95bf876eb54d05dfdf0721ed772014104e6aa2cf108e1c650e12d8dd7ec0a36e478dad5a5d180585d25c30eb7c88c3df0c6f5fd41b3e70b019b777abd02d319bf724de184001b3d014cb740cb83ed21a6ffffffffbaae89b5d2e3ca78fd3f13cf0058784e7c089fb56e1e596d70adcfa486603967010000008b483045022055efbaddb4c67c1f1a46464c8f770aab03d6b513779ad48735d16d4c5b9907c2022100f469d50a5e5556fc2c932645f6927ac416aa65bc83d58b888b82c3220e1f0b73014104194b3f8aa08b96cae19b14bd6c32a92364bea3051cb9f018b03e3f09a57208ff058f4b41ebf96b9911066aef3be22391ac59175257af0984d1432acb8f2aefcaffffffff0340420f00000000001976a914c0fbb13eb10b57daa78b47660a4ffb79c29e2e6b88ac204e0000000000001976a9142cae94ffdc05f8214ccb2b697861c9c07e3948ee88ac1c2e0100000000001976a9146e03561cd4d6033456cc9036d409d2bf82721e9888ac00000000";
-        tx = new Transaction(NetworkParameters.fromID(NetworkParameters.ID_MAINNET), HEX.decode(hex));
+        tx = new Transaction(NetworkParameters.of(Network.MAIN), HEX.decode(hex));
         assertFalse(tx.hasWitnesses());
         assertEquals(3, tx.getInputs().size());
         for (TransactionInput in : tx.getInputs())
@@ -259,7 +260,7 @@ public void witnessTransaction() {
 
         // Roundtrip with witness
         hex = "0100000000010213206299feb17742091c3cb2ab45faa3aa87922d3c030cafb3f798850a2722bf0000000000feffffffa12f2424b9599898a1d30f06e1ce55eba7fabfeee82ae9356f07375806632ff3010000006b483045022100fcc8cf3014248e1a0d6dcddf03e80f7e591605ad0dbace27d2c0d87274f8cd66022053fcfff64f35f22a14deb657ac57f110084fb07bb917c3b42e7d033c54c7717b012102b9e4dcc33c9cc9cb5f42b96dddb3b475b067f3e21125f79e10c853e5ca8fba31feffffff02206f9800000000001976a9144841b9874d913c430048c78a7b18baebdbea440588ac8096980000000000160014e4873ef43eac347471dd94bc899c51b395a509a502483045022100dd8250f8b5c2035d8feefae530b10862a63030590a851183cb61b3672eb4f26e022057fe7bc8593f05416c185d829b574290fb8706423451ebd0a0ae50c276b87b43012102179862f40b85fa43487500f1d6b13c864b5eb0a83999738db0f7a6b91b2ec64f00db080000";
-        tx = new Transaction(NetworkParameters.fromID(NetworkParameters.ID_MAINNET), HEX.decode(hex));
+        tx = new Transaction(NetworkParameters.of(Network.MAIN), HEX.decode(hex));
         assertTrue(tx.hasWitnesses());
         assertEquals(2, tx.getInputs().size());
         assertTrue(tx.getInput(0).hasWitness());

File: integration-test/src/test/java/org/bitcoinj/wallet/WalletAccountPathTest.java
Patch:
@@ -59,7 +59,7 @@ void setupTest() {
     void walletStructurePathTest2(KeyChainGroupStructure structure, HDPath expectedPath, ScriptType scriptType,
                                   Network network) throws IOException, UnreadableWalletException {
         // When we create a wallet with parameterized structure, network, and scriptType
-        Wallet wallet = createWallet(walletFile, network.networkParameters(), structure, scriptType);
+        Wallet wallet = createWallet(walletFile, NetworkParameters.of(network), structure, scriptType);
 
         // Then the account path is as expected
         assertEquals(expectedPath, wallet.getActiveKeyChain().getAccountPath());

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -369,7 +369,7 @@ public Integer call() throws IOException, BlockStoreException {
             java.util.logging.Logger logger = LogManager.getLogManager().getLogger("");
             logger.setLevel(Level.SEVERE);
         }
-        params = net.networkParameters();
+        params = NetworkParameters.of(net);
         String fileName;
         switch (net) {
             case MAIN:

File: core/src/main/java/org/bitcoinj/base/utils/ByteUtils.java
Patch:
@@ -342,7 +342,7 @@ public static long encodeCompactBits(BigInteger value) {
             result >>= 8;
             size++;
         }
-        result |= size << 24;
+        result |= (long) size << 24;
         result |= value.signum() == -1 ? 0x00800000 : 0;
         return result;
     }

File: core/src/main/java/org/bitcoinj/core/PrefixedChecksummedBytes.java
Patch:
@@ -36,7 +36,7 @@
  * </p>
  */
 public abstract class PrefixedChecksummedBytes {
-    protected final transient NetworkParameters params;
+    protected final NetworkParameters params;
     protected final byte[] bytes;
 
     protected PrefixedChecksummedBytes(NetworkParameters params, byte[] bytes) {

File: core/src/main/java/org/bitcoinj/core/ECKey.java
Patch:
@@ -24,6 +24,7 @@
 import org.bitcoin.NativeSecp256k1;
 import org.bitcoin.NativeSecp256k1Util;
 import org.bitcoin.Secp256k1Context;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.crypto.EncryptableItem;
@@ -32,7 +33,6 @@
 import org.bitcoinj.crypto.KeyCrypterException;
 import org.bitcoinj.crypto.LazyECPoint;
 import org.bitcoinj.crypto.LinuxSecureRandom;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.wallet.Protos;
 import org.bitcoinj.wallet.Wallet;
 import org.bouncycastle.asn1.ASN1InputStream;
@@ -1204,7 +1204,7 @@ private String toString(boolean includePrivate, @Nullable KeyParameter aesKey, @
     }
 
     public void formatKeyWithAddress(boolean includePrivateKeys, @Nullable KeyParameter aesKey, StringBuilder builder,
-            NetworkParameters params, Script.ScriptType outputScriptType, @Nullable String comment) {
+                                     NetworkParameters params, ScriptType outputScriptType, @Nullable String comment) {
         builder.append("  addr:");
         if (outputScriptType != null) {
             builder.append(Address.fromKey(params, this, outputScriptType));

File: core/src/main/java/org/bitcoinj/core/LegacyAddress.java
Patch:
@@ -20,7 +20,7 @@
 
 import com.google.common.primitives.UnsignedBytes;
 import org.bitcoinj.params.Networks;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 
 import javax.annotation.Nullable;
 import java.util.Arrays;

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -26,7 +26,7 @@
 import org.bitcoinj.core.TransactionConfidence.ConfidenceType;
 import org.bitcoinj.crypto.TransactionSignature;
 import org.bitcoinj.script.Script;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptError;
 import org.bitcoinj.script.ScriptException;

File: core/src/main/java/org/bitcoinj/core/TransactionBag.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.wallet.Wallet;
@@ -32,10 +33,10 @@ public interface TransactionBag {
     /**
      * Look for a public key which hashes to the given hash and (optionally) is used for a specific script type.
      * @param pubKeyHash hash of the public key to look for
-     * @param scriptType only look for given usage (currently {@link Script.ScriptType#P2PKH} or {@link Script.ScriptType#P2WPKH}) or {@code null} if we don't care
+     * @param scriptType only look for given usage (currently {@link ScriptType#P2PKH} or {@link ScriptType#P2WPKH}) or {@code null} if we don't care
      * @return true if hash was found
      */
-    boolean isPubKeyHashMine(byte[] pubKeyHash, @Nullable Script.ScriptType scriptType);
+    boolean isPubKeyHashMine(byte[] pubKeyHash, @Nullable ScriptType scriptType);
 
     /** Returns true if this wallet is watching transactions for outputs with the script. */
     boolean isWatchedScript(Script script);

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.core;
 
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.script.Script;
@@ -323,10 +324,10 @@ else if (ScriptPattern.isP2SH(script))
                 return transactionBag.isPayToScriptHashMine(ScriptPattern.extractHashFromP2SH(script));
             else if (ScriptPattern.isP2PKH(script))
                 return transactionBag.isPubKeyHashMine(ScriptPattern.extractHashFromP2PKH(script),
-                        Script.ScriptType.P2PKH);
+                        ScriptType.P2PKH);
             else if (ScriptPattern.isP2WPKH(script))
                 return transactionBag.isPubKeyHashMine(ScriptPattern.extractHashFromP2WH(script),
-                        Script.ScriptType.P2WPKH);
+                        ScriptType.P2WPKH);
             else
                 return false;
         } catch (ScriptException e) {

File: core/src/main/java/org/bitcoinj/script/ScriptBuilder.java
Patch:
@@ -26,7 +26,7 @@
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.Utils;
 import org.bitcoinj.crypto.TransactionSignature;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 
 import javax.annotation.Nullable;
 import java.util.ArrayList;

File: core/src/main/java/org/bitcoinj/signers/MissingSigResolutionSigner.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.signers;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.TransactionInput;
 import org.bitcoinj.core.TransactionWitness;
@@ -98,7 +99,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                         throw new ECKey.MissingPrivateKeyException();
                     } else if (missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG) {
                         ECKey key = keyBag.findKeyFromPubKeyHash(
-                                ScriptPattern.extractHashFromP2WH(scriptPubKey), Script.ScriptType.P2WPKH);
+                                ScriptPattern.extractHashFromP2WH(scriptPubKey), ScriptType.P2WPKH);
                         txIn.setWitness(TransactionWitness.redeemP2WPKH(TransactionSignature.dummy(), key));
                     }
                 }

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -35,7 +35,7 @@
 import org.bitcoinj.core.UTXOProviderException;
 import org.bitcoinj.core.VerificationException;
 import org.bitcoinj.script.Script;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/wallet/DecryptingKeyBag.java
Patch:
@@ -16,8 +16,8 @@
 
 package org.bitcoinj.wallet;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.ECKey;
-import org.bitcoinj.script.Script;
 import org.bouncycastle.crypto.params.KeyParameter;
 
 import javax.annotation.Nullable;
@@ -63,7 +63,7 @@ private RedeemData maybeDecrypt(RedeemData redeemData) {
 
     @Nullable
     @Override
-    public ECKey findKeyFromPubKeyHash(byte[] pubKeyHash, @Nullable Script.ScriptType scriptType) {
+    public ECKey findKeyFromPubKeyHash(byte[] pubKeyHash, @Nullable ScriptType scriptType) {
         return maybeDecrypt(target.findKeyFromPubKeyHash(pubKeyHash, scriptType));
     }
 

File: core/src/main/java/org/bitcoinj/wallet/KeyTimeCoinSelector.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.wallet;
 
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionConfidence;
@@ -68,9 +69,9 @@ public CoinSelection select(Coin target, List<TransactionOutput> candidates) {
                 if (ScriptPattern.isP2PK(scriptPubKey)) {
                     controllingKey = wallet.findKeyFromPubKey(ScriptPattern.extractKeyFromP2PK(scriptPubKey));
                 } else if (ScriptPattern.isP2PKH(scriptPubKey)) {
-                    controllingKey = wallet.findKeyFromPubKeyHash(ScriptPattern.extractHashFromP2PKH(scriptPubKey), Script.ScriptType.P2PKH);
+                    controllingKey = wallet.findKeyFromPubKeyHash(ScriptPattern.extractHashFromP2PKH(scriptPubKey), ScriptType.P2PKH);
                 } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {
-                    controllingKey = wallet.findKeyFromPubKeyHash(ScriptPattern.extractHashFromP2WH(scriptPubKey), Script.ScriptType.P2WPKH);
+                    controllingKey = wallet.findKeyFromPubKeyHash(ScriptPattern.extractHashFromP2WH(scriptPubKey), ScriptType.P2WPKH);
                 } else {
                     log.info("Skipping tx output {} because it's not of simple form.", output);
                     continue;

File: core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.Lists;
 import com.google.protobuf.ByteString;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.BloomFilter;
 import org.bitcoinj.core.ECKey;
@@ -125,15 +126,15 @@ public static Builder<?> builder() {
      * This constructor is not stable across releases! If you need a stable API, use {@link #builder()} to use a
      * {@link Builder}.
      */
-    protected MarriedKeyChain(DeterministicKey accountKey, Script.ScriptType outputScriptType) {
+    protected MarriedKeyChain(DeterministicKey accountKey, ScriptType outputScriptType) {
         super(accountKey, false, true, outputScriptType);
     }
 
     /**
      * This constructor is not stable across releases! If you need a stable API, use {@link #builder()} to use a
      * {@link Builder}.
      */
-    protected MarriedKeyChain(DeterministicSeed seed, KeyCrypter crypter, Script.ScriptType outputScriptType, List<ChildNumber> accountPath) {
+    protected MarriedKeyChain(DeterministicSeed seed, KeyCrypter crypter, ScriptType outputScriptType, List<ChildNumber> accountPath) {
         super(seed, crypter, outputScriptType, accountPath);
     }
 

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -19,6 +19,7 @@
 
 import com.google.common.collect.Lists;
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.UnitTestParams;
 import org.bitcoinj.script.Script;
@@ -324,7 +325,7 @@ public void testUTXOProviderWithWallet() throws Exception {
         rollingBlock = rollingBlock.createNextBlock(null);
 
         // Create 1 BTC spend to a key in this wallet (to ourselves).
-        Wallet wallet = Wallet.createDeterministic(PARAMS, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.createDeterministic(PARAMS, ScriptType.P2PKH);
         assertEquals("Available balance is incorrect", Coin.ZERO, wallet.getBalance(Wallet.BalanceType.AVAILABLE));
         assertEquals("Estimated balance is incorrect", Coin.ZERO, wallet.getBalance(Wallet.BalanceType.ESTIMATED));
 

File: core/src/test/java/org/bitcoinj/core/BlockTest.java
Patch:
@@ -19,13 +19,13 @@
 
 import com.google.common.io.ByteStreams;
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.AbstractBlockChain.NewBlockType;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.TestNet3Params;
 import org.bitcoinj.params.UnitTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptOpCodes;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.Wallet.BalanceType;
@@ -227,7 +227,7 @@ public void testReceiveCoinbaseTransaction() throws Exception {
         ECKey miningKey = DumpedPrivateKey.fromBase58(MAINNET, MINING_PRIVATE_KEY).getKey();
         assertNotNull(miningKey);
         Context context = new Context(MAINNET);
-        Wallet wallet = Wallet.createDeterministic(context, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.createDeterministic(context, ScriptType.P2PKH);
         wallet.importKey(miningKey);
 
         // Initial balance should be zero by construction.

File: core/src/test/java/org/bitcoinj/core/ChainSplitTest.java
Patch:
@@ -18,10 +18,10 @@
 package org.bitcoinj.core;
 
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.core.TransactionConfidence.ConfidenceType;
 import org.bitcoinj.params.UnitTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.store.MemoryBlockStore;
 import org.bitcoinj.testing.FakeTxBuilder;
 import org.bitcoinj.utils.BriefLogFormatter;
@@ -67,7 +67,7 @@ public void setUp() throws Exception {
         Utils.setMockClock(); // Use mock clock
         Context.propagate(new Context(UNITTEST, 100, Coin.ZERO, false));
         MemoryBlockStore blockStore = new MemoryBlockStore(UNITTEST);
-        wallet = Wallet.createDeterministic(UNITTEST, Script.ScriptType.P2PKH);
+        wallet = Wallet.createDeterministic(UNITTEST, ScriptType.P2PKH);
         ECKey key1 = wallet.freshReceiveKey();
         ECKey key2 = wallet.freshReceiveKey();
         chain = new BlockChain(UNITTEST, wallet, blockStore);

File: core/src/test/java/org/bitcoinj/core/LegacyAddressTest.java
Patch:
@@ -24,7 +24,7 @@
 import org.bitcoinj.params.Networks;
 import org.bitcoinj.params.TestNet3Params;
 import org.bitcoinj.script.Script;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptPattern;
 import org.junit.Test;

File: core/src/test/java/org/bitcoinj/core/ParseByteCacheTest.java
Patch:
@@ -17,10 +17,10 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.UnitTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.MemoryBlockStore;
 import org.bitcoinj.wallet.Wallet;
@@ -91,7 +91,7 @@ private void resetBlockStore() {
     public void setUp() throws Exception {
         Utils.setMockClock(); // Use mock clock
         Context context = new Context(UNITTEST);
-        Wallet wallet = Wallet.createDeterministic(context, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.createDeterministic(context, ScriptType.P2PKH);
         wallet.freshReceiveKey();
 
         resetBlockStore();

File: core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.TestNet3Params;
 import org.bitcoinj.script.Script;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptPattern;
 import org.junit.Test;

File: core/src/test/java/org/bitcoinj/core/TransactionInputTest.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.common.collect.Lists;
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.params.UnitTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.testing.FakeTxBuilder;
 import org.bitcoinj.wallet.SendRequest;
@@ -37,7 +37,7 @@ public class TransactionInputTest {
 
     @Test
     public void testStandardWalletDisconnect() throws Exception {
-        Wallet w = Wallet.createDeterministic(new Context(UNITTEST), Script.ScriptType.P2PKH);
+        Wallet w = Wallet.createDeterministic(new Context(UNITTEST), ScriptType.P2PKH);
         Address a = w.currentReceiveAddress();
         Transaction tx1 = FakeTxBuilder.createFakeTxWithoutChangeAddress(UNITTEST, Coin.COIN, a);
         w.receivePending(tx1, null);
@@ -60,7 +60,7 @@ public void testStandardWalletDisconnect() throws Exception {
 
     @Test
     public void testUTXOWalletDisconnect() throws Exception {
-        Wallet w = Wallet.createDeterministic(new Context(UNITTEST), Script.ScriptType.P2PKH);
+        Wallet w = Wallet.createDeterministic(new Context(UNITTEST), ScriptType.P2PKH);
         Address a = w.currentReceiveAddress();
         final UTXO utxo = new UTXO(Sha256Hash.of(new byte[] { 1, 2, 3 }), 1, Coin.COIN, 0, false,
                 ScriptBuilder.createOutputScript(a));

File: core/src/test/java/org/bitcoinj/testing/TestWithWallet.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.bitcoinj.testing;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.AbstractBlockChain;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Block;
@@ -29,7 +30,6 @@
 import org.bitcoinj.core.VerificationException;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.UnitTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.MemoryBlockStore;
 import org.bitcoinj.utils.BriefLogFormatter;
@@ -70,9 +70,9 @@ public static void setUpClass() throws Exception {
     public void setUp() throws Exception {
         BriefLogFormatter.init();
         Context.propagate(new Context(UNITTEST, 100, Coin.ZERO, false));
-        wallet = Wallet.createDeterministic(UNITTEST, Script.ScriptType.P2PKH, KeyChainGroupStructure.BIP32);
+        wallet = Wallet.createDeterministic(UNITTEST, ScriptType.P2PKH, KeyChainGroupStructure.BIP32);
         myKey = wallet.freshReceiveKey();
-        myAddress = wallet.freshReceiveAddress(Script.ScriptType.P2PKH);
+        myAddress = wallet.freshReceiveAddress(ScriptType.P2PKH);
         blockStore = new MemoryBlockStore(UNITTEST);
         chain = new BlockChain(UNITTEST, wallet, blockStore);
     }

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.wallet;
 
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
@@ -57,7 +58,7 @@ public class DefaultRiskAnalysisTest {
 
     @Before
     public void setup() {
-        wallet = Wallet.createDeterministic(new Context(MAINNET), Script.ScriptType.P2PKH);
+        wallet = Wallet.createDeterministic(new Context(MAINNET), ScriptType.P2PKH);
         wallet.setLastBlockSeenHeight(1000);
         wallet.setLastBlockSeenTimeSecs(TIMESTAMP);
     }

File: examples/src/main/java/org/bitcoinj/examples/BackupToMnemonicSeed.java
Patch:
@@ -16,10 +16,10 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.internal.InternalUtils;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.wallet.DeterministicSeed;
 import org.bitcoinj.wallet.Wallet;
 
@@ -36,7 +36,7 @@ public class BackupToMnemonicSeed {
     public static void main(String[] args) {
 
         NetworkParameters params = TestNet3Params.get();
-        Wallet wallet = Wallet.createDeterministic(params, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.createDeterministic(params, ScriptType.P2PKH);
 
         DeterministicSeed seed = wallet.getKeyChainSeed();
         System.out.println("seed: " + seed.toString());

File: examples/src/main/java/org/bitcoinj/examples/DoubleSpend.java
Patch:
@@ -16,11 +16,10 @@
 
 package org.bitcoinj.examples;
 
-import org.bitcoinj.core.listeners.PreMessageReceivedEventListener;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.*;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.RegTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
@@ -39,7 +38,7 @@ public class DoubleSpend {
     public static void main(String[] args) throws Exception {
         BriefLogFormatter.init();
         final RegTestParams params = RegTestParams.get();
-        WalletAppKit kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "doublespend");
+        WalletAppKit kit = new WalletAppKit(params, ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "doublespend");
         kit.connectToLocalHost();
         kit.setAutoSave(false);
         kit.startAsync();

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.InsufficientMoneyException;
@@ -29,7 +30,6 @@
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.RegTestParams;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.SendRequest;
@@ -80,7 +80,7 @@ public static void main(String[] args) throws Exception {
         System.out.println("Forwarding address: " + forwardingAddress);
 
         // Start up a basic app using a class that automates some boilerplate.
-        kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), filePrefix);
+        kit = new WalletAppKit(params, ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), filePrefix);
 
         if (params == RegTestParams.get()) {
             // Regression test mode is designed for testing and development only, so there's no public network for it.

File: examples/src/main/java/org/bitcoinj/examples/GenerateLowSTests.java
Patch:
@@ -25,6 +25,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.utils.ByteUtils;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.base.Coin;
@@ -65,7 +66,7 @@ public static void main(final String[] argv)
         final ECKey key = new ECKey(secureRandom);
         final KeyBag bag = new KeyBag() {
             @Override
-            public ECKey findKeyFromPubKeyHash(byte[] pubkeyHash, Script.ScriptType scriptType) {
+            public ECKey findKeyFromPubKeyHash(byte[] pubkeyHash, ScriptType scriptType) {
                 return key;
             }
 

File: examples/src/main/java/org/bitcoinj/examples/Kit.java
Patch:
@@ -16,10 +16,10 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.*;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
@@ -56,7 +56,7 @@ public static void main(String[] args) {
 
         // Now we initialize a new WalletAppKit. The kit handles all the boilerplate for us and is the easiest way to get everything up and running.
         // Have a look at the WalletAppKit documentation and its source to understand what's happening behind the scenes: https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
-        WalletAppKit kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "walletappkit-example");
+        WalletAppKit kit = new WalletAppKit(params, ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "walletappkit-example");
 
         // In case you want to connect with your local bitcoind tell the kit to connect to localhost.
         // You must do that in reg test mode.

File: examples/src/main/java/org/bitcoinj/examples/PrivateKeys.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Base58;
 import org.bitcoinj.core.BlockChain;
@@ -27,7 +28,6 @@
 import org.bitcoinj.core.PeerGroup;
 import org.bitcoinj.core.SegwitAddress;
 import org.bitcoinj.params.MainNetParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.store.MemoryBlockStore;
 import org.bitcoinj.wallet.Wallet;
 
@@ -64,7 +64,7 @@ public static void main(String[] args) throws Exception {
             Address destination = Address.fromString(params, args[1]);
 
             // Import the private key to a fresh wallet.
-            Wallet wallet = Wallet.createDeterministic(params, Script.ScriptType.P2PKH);
+            Wallet wallet = Wallet.createDeterministic(params, ScriptType.P2PKH);
             wallet.importKey(key);
 
             // Find the transactions that involve those coins.

File: examples/src/main/java/org/bitcoinj/examples/RestoreFromSeed.java
Patch:
@@ -16,11 +16,11 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.listeners.DownloadProgressTracker;
 import org.bitcoinj.core.*;
 import org.bitcoinj.net.discovery.DnsDiscovery;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.store.SPVBlockStore;
 import org.bitcoinj.wallet.DeterministicSeed;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
@@ -48,7 +48,7 @@ public static void main(String[] args) throws Exception {
         DeterministicSeed seed = new DeterministicSeed(seedCode, null, passphrase, creationtime);
 
         // The wallet class provides a easy fromSeed() function that loads a new wallet from a given seed.
-        Wallet wallet = Wallet.fromSeed(params, seed, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.fromSeed(params, seed, ScriptType.P2PKH);
 
         // Because we are importing an existing wallet which might already have transactions we must re-download the blockchain to make the wallet picks up these transactions
         // You can find some information about this in the guides: https://bitcoinj.github.io/working-with-the-wallet#setup

File: examples/src/main/java/org/bitcoinj/examples/SendRequest.java
Patch:
@@ -17,10 +17,10 @@
 package org.bitcoinj.examples;
 
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.*;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.Wallet.BalanceType;
@@ -37,7 +37,7 @@ public static void main(String[] args) throws Exception {
 
         // We use the WalletAppKit that handles all the boilerplate for us. Have a look at the Kit.java example for more details.
         NetworkParameters params = TestNet3Params.get();
-        WalletAppKit kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "sendrequest-example");
+        WalletAppKit kit = new WalletAppKit(params, ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "sendrequest-example");
         kit.startAsync();
         kit.awaitRunning();
 

File: integration-test/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -19,11 +19,11 @@
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.Uninterruptibles;
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.base.Sha256Hash;
 import org.bitcoinj.core.listeners.BlocksDownloadedEventListener;
 import org.bitcoinj.core.listeners.PreMessageReceivedEventListener;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.testing.InboundMessageQueuer;
 import org.bitcoinj.testing.TestWithNetworkConnections;
 import org.bitcoinj.utils.Threading;
@@ -682,7 +682,7 @@ public void timeLockedTransactionNew() throws Exception {
         connectWithVersion(70001, VersionMessage.NODE_NETWORK);
         // Test that if we receive a relevant transaction that has a lock time, it doesn't result in a notification
         // until we explicitly opt in to seeing those.
-        Wallet wallet = Wallet.createDeterministic(UNITTEST, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.createDeterministic(UNITTEST, ScriptType.P2PKH);
         ECKey key = wallet.freshReceiveKey();
         peer.addWallet(wallet);
         final Transaction[] vtx = new Transaction[1];
@@ -728,7 +728,7 @@ public void acceptTimeLockedDependency() throws Exception {
     private void checkTimeLockedDependency(boolean shouldAccept) throws Exception {
         // Initial setup.
         connectWithVersion(70001, VersionMessage.NODE_NETWORK);
-        Wallet wallet = Wallet.createDeterministic(UNITTEST, Script.ScriptType.P2PKH);
+        Wallet wallet = Wallet.createDeterministic(UNITTEST, ScriptType.P2PKH);
         ECKey key = wallet.freshReceiveKey();
         wallet.setAcceptRiskyTransactions(shouldAccept);
         peer.addWallet(wallet);

File: integration-test/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.testing;
 
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.BlockChain;
 import org.bitcoinj.base.Coin;
@@ -40,7 +41,6 @@
 import org.bitcoinj.net.StreamConnection;
 import org.bitcoinj.net.StreamConnectionFactory;
 import org.bitcoinj.params.UnitTestParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.MemoryBlockStore;
 import org.bitcoinj.utils.BriefLogFormatter;
@@ -109,7 +109,7 @@ public void setUp(BlockStore blockStore) throws Exception {
         if (wallet == null) {
             // Reduce the number of keys we need to work with to speed up these tests.
             KeyChainGroup kcg = KeyChainGroup.builder(UNITTEST).lookaheadSize(4).lookaheadThreshold(2)
-                    .fromRandom(Script.ScriptType.P2PKH).build();
+                    .fromRandom(ScriptType.P2PKH).build();
             wallet = new Wallet(UNITTEST, kcg);
             key = wallet.freshReceiveKey();
             address = LegacyAddress.fromKey(UNITTEST, key);

File: tools/src/main/java/org/bitcoinj/tools/TestFeeLevel.java
Patch:
@@ -17,12 +17,12 @@
 package org.bitcoinj.tools;
 
 import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.*;
 import org.bitcoinj.core.listeners.PeerConnectedEventListener;
 import org.bitcoinj.core.listeners.PeerDisconnectedEventListener;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.MainNetParams;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
 import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.SendRequest;
@@ -50,7 +50,7 @@ public static void main(String[] args) throws Exception {
         Coin feeRateToTest = Coin.valueOf(Long.parseLong(args[0]));
         System.out.println("Fee rate to test is " + feeRateToTest.toFriendlyString() + "/kB");
 
-        kit = new WalletAppKit(PARAMS, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "testfeelevel");
+        kit = new WalletAppKit(PARAMS, ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "testfeelevel");
         kit.startAsync();
         kit.awaitRunning();
         try {

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -18,9 +18,9 @@
 
 import javafx.application.Application;
 import javafx.stage.Stage;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.params.TestNet3Params;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.walletfx.application.AppDelegate;
 
 /**
@@ -29,7 +29,7 @@
  */
 public class Main extends Application {
     private static final NetworkParameters params = TestNet3Params.get();
-    private static final Script.ScriptType PREFERRED_OUTPUT_SCRIPT_TYPE = Script.ScriptType.P2WPKH;
+    private static final ScriptType PREFERRED_OUTPUT_SCRIPT_TYPE = ScriptType.P2WPKH;
     private static final String APP_NAME = "WalletTemplate";
 
     private final AppDelegate delegate;

File: wallettemplate/src/main/java/wallettemplate/WalletTemplate.java
Patch:
@@ -18,8 +18,8 @@
 
 import javafx.fxml.FXMLLoader;
 import javafx.scene.layout.Pane;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.core.NetworkParameters;
-import org.bitcoinj.script.Script;
 import org.bitcoinj.walletfx.application.WalletApplication;
 
 import java.io.IOException;
@@ -30,7 +30,7 @@
  */
 public class WalletTemplate extends WalletApplication {
 
-    public WalletTemplate(String applicationName, NetworkParameters params, Script.ScriptType preferredOutputScriptType) {
+    public WalletTemplate(String applicationName, NetworkParameters params, ScriptType preferredOutputScriptType) {
         super(applicationName, params, preferredOutputScriptType);
     }
 

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -25,8 +25,7 @@
 import org.bitcoinj.protocols.payments.PaymentProtocol;
 import org.bitcoinj.protocols.payments.PaymentProtocolException;
 import org.bitcoinj.protocols.payments.PaymentSession;
-import org.bitcoinj.script.Script;
-import org.bitcoinj.script.Script.ScriptType;
+import org.bitcoinj.base.ScriptType;
 import org.bitcoinj.script.ScriptException;
 import org.bitcoinj.store.*;
 import org.bitcoinj.uri.BitcoinURI;
@@ -186,7 +185,7 @@ public class WalletTool implements Callable<Integer> {
     @CommandLine.Option(names = "--watchkey", description = "Describes a watching wallet using the specified base58 xpub.")
     private String watchKeyStr = null;
     @CommandLine.Option(names = "--output-script-type", description = "Provide an output script type to any action that requires one. Valid values: P2PKH, P2WPKH. Default: ${DEFAULT-VALUE}")
-    private Script.ScriptType outputScriptType = Script.ScriptType.P2PKH;
+    private ScriptType outputScriptType = ScriptType.P2PKH;
     @CommandLine.Option(names = "--date", description = "Provide a date in form YYYY-MM-DD to any action that requires one.")
     private Date date = null;
     @CommandLine.Option(names = "--unixtime", description = "Provide a date in seconds since epoch.")

File: core/src/main/java/org/bitcoinj/base/Coin.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package org.bitcoinj.core;
+package org.bitcoinj.base;
 
 import com.google.common.math.LongMath;
-import org.bitcoinj.utils.MonetaryFormat;
+import org.bitcoinj.base.utils.MonetaryFormat;
 
 import java.math.BigDecimal;
 

File: core/src/main/java/org/bitcoinj/base/Monetary.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package org.bitcoinj.core;
+package org.bitcoinj.base;
 
 /**
  * Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.

File: core/src/main/java/org/bitcoinj/base/utils/Fiat.java
Patch:
@@ -14,11 +14,11 @@
  * limitations under the License.
  */
 
-package org.bitcoinj.utils;
+package org.bitcoinj.base.utils;
 
 import com.google.common.math.LongMath;
-import org.bitcoinj.core.Coin;
-import org.bitcoinj.core.Monetary;
+import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.Monetary;
 
 import java.math.BigDecimal;
 import java.util.Objects;

File: core/src/main/java/org/bitcoinj/base/utils/MonetaryFormat.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package org.bitcoinj.utils;
+package org.bitcoinj.base.utils;
 
-import org.bitcoinj.core.Coin;
-import org.bitcoinj.core.Monetary;
+import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.Monetary;
 
 import java.math.RoundingMode;
 import java.text.DecimalFormatSymbols;

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -19,6 +19,7 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.internal.InternalUtils;
 import org.bitcoinj.params.AbstractBitcoinNetParams;
 import org.bitcoinj.script.Script;
@@ -41,7 +42,7 @@
 import java.util.Locale;
 
 import static com.google.common.base.Preconditions.checkState;
-import static org.bitcoinj.core.Coin.FIFTY_COINS;
+import static org.bitcoinj.base.Coin.FIFTY_COINS;
 import static org.bitcoinj.core.Sha256Hash.hashTwice;
 
 /**

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.utils.ContextPropagatingThreadFactory;
 import org.bitcoinj.wallet.SendRequest;
 import org.slf4j.Logger;

File: core/src/main/java/org/bitcoinj/core/FeeFilterMessage.java
Patch:
@@ -16,6 +16,8 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
+
 import java.io.IOException;
 import java.io.OutputStream;
 import java.math.BigInteger;

File: core/src/main/java/org/bitcoinj/core/FullPrunedBlockChain.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.params.AbstractBitcoinNetParams;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.Script.VerifyFlag;

File: core/src/main/java/org/bitcoinj/core/InsufficientMoneyException.java
Patch:
@@ -16,6 +16,8 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
+
 import javax.annotation.Nullable;
 
 import static com.google.common.base.Preconditions.checkNotNull;

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.RegTestParams;
 import org.bitcoinj.params.SigNetParams;
@@ -25,7 +26,7 @@
 import org.bitcoinj.script.Script;
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.BlockStoreException;
-import org.bitcoinj.utils.MonetaryFormat;
+import org.bitcoinj.base.utils.MonetaryFormat;
 import org.bitcoinj.utils.VersionTally;
 
 import javax.annotation.Nullable;
@@ -35,7 +36,7 @@
 import java.util.Map;
 import java.util.Objects;
 
-import static org.bitcoinj.core.Coin.COIN;
+import static org.bitcoinj.base.Coin.COIN;
 
 /**
  * <p>NetworkParameters contains the data needed for working with an instantiation of a Bitcoin chain.</p>

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.common.base.Strings;
 import com.google.common.base.Throwables;
 import net.jcip.annotations.GuardedBy;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.listeners.BlocksDownloadedEventListener;
 import org.bitcoinj.core.listeners.ChainDownloadStartedEventListener;
 import org.bitcoinj.core.listeners.GetDataEventListener;

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.google.common.math.IntMath;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.TransactionConfidence.ConfidenceType;
 import org.bitcoinj.crypto.TransactionSignature;
 import org.bitcoinj.script.Script;

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.internal.InternalUtils;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptException;

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptException;

File: core/src/main/java/org/bitcoinj/core/UTXO.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.script.Script;
 
 import java.io.EOFException;

File: core/src/main/java/org/bitcoinj/jni/NativeWalletCoinsReceivedEventListener.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.jni;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener;

File: core/src/main/java/org/bitcoinj/jni/NativeWalletCoinsSentEventListener.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.jni;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener;

File: core/src/main/java/org/bitcoinj/params/AbstractBitcoinNetParams.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.common.base.Stopwatch;
 import org.bitcoinj.core.BitcoinSerializer;
 import org.bitcoinj.core.Block;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Sha256Hash;
 import org.bitcoinj.core.StoredBlock;
@@ -30,7 +30,7 @@
 import org.bitcoinj.core.VerificationException;
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.BlockStoreException;
-import org.bitcoinj.utils.MonetaryFormat;
+import org.bitcoinj.base.utils.MonetaryFormat;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocol.java
Patch:
@@ -22,7 +22,7 @@
 import com.google.protobuf.InvalidProtocolBufferException;
 import org.bitcoin.protocols.payments.Protos;
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.Utils;

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentSession.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.protobuf.InvalidProtocolBufferException;
 import org.bitcoin.protocols.payments.Protos;
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionOutput;

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -20,7 +20,7 @@
 package org.bitcoinj.script;
 
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;

File: core/src/main/java/org/bitcoinj/signers/LocalTransactionSigner.java
Patch:
@@ -17,7 +17,7 @@
 
 package org.bitcoinj.signers;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionInput;

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Block;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;

File: core/src/main/java/org/bitcoinj/testing/FakeTxBuilder.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Block;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.MessageSerializer;
@@ -46,8 +46,8 @@
 import java.util.Random;
 
 import static com.google.common.base.Preconditions.checkState;
-import static org.bitcoinj.core.Coin.COIN;
-import static org.bitcoinj.core.Coin.valueOf;
+import static org.bitcoinj.base.Coin.COIN;
+import static org.bitcoinj.base.Coin.valueOf;
 
 /**
  * Methods for building fake transactions for unit tests. Since these methods are currently used both in the `bitcoinj-core`

File: core/src/main/java/org/bitcoinj/uri/BitcoinURI.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.AddressFormatException;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.params.AbstractBitcoinNetParams;
 

File: core/src/main/java/org/bitcoinj/utils/BtcFixedFormat.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.utils;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 
 import java.math.BigInteger;
 import java.text.DecimalFormat;
@@ -27,7 +27,7 @@
 import java.util.Objects;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static org.bitcoinj.core.Coin.SMALLEST_UNIT_EXPONENT;
+import static org.bitcoinj.base.Coin.SMALLEST_UNIT_EXPONENT;
 
 /**
  * <p>This class, a concrete extension of {@link BtcFormat}, is distinguished in that each

File: core/src/main/java/org/bitcoinj/utils/BtcFormat.java
Patch:
@@ -17,7 +17,7 @@
 package org.bitcoinj.utils;
 
 import com.google.common.base.Strings;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.utils.BtcAutoFormat.Style;
 
 import java.math.BigDecimal;

File: core/src/main/java/org/bitcoinj/utils/ExchangeRate.java
Patch:
@@ -16,7 +16,8 @@
 
 package org.bitcoinj.utils;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.utils.Fiat;
+import org.bitcoinj.base.Coin;
 
 import java.math.BigInteger;
 import java.util.Objects;

File: core/src/main/java/org/bitcoinj/wallet/CoinSelection.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.wallet;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.TransactionOutput;
 
 import java.util.Collection;

File: core/src/main/java/org/bitcoinj/wallet/CoinSelector.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.wallet;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.TransactionOutput;
 
 import java.util.List;

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -17,7 +17,7 @@
 package org.bitcoinj.wallet;
 
 import com.google.common.annotations.VisibleForTesting;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionConfidence;

File: core/src/main/java/org/bitcoinj/wallet/FilteringCoinSelector.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.wallet;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionInput;
 import org.bitcoinj.core.TransactionOutPoint;

File: core/src/main/java/org/bitcoinj/wallet/KeyTimeCoinSelector.java
Patch:
@@ -17,7 +17,7 @@
 
 package org.bitcoinj.wallet;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionConfidence;

File: core/src/main/java/org/bitcoinj/wallet/SendRequest.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.common.base.MoreObjects;
 import org.bitcoin.protocols.payments.Protos.PaymentDetails;
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -29,7 +29,7 @@
 import org.bitcoinj.core.Base58;
 import org.bitcoinj.core.BlockChain;
 import org.bitcoinj.core.BloomFilter;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.FilteredBlock;

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.protobuf.CodedInputStream;
 import com.google.protobuf.CodedOutputStream;
 import com.google.protobuf.WireFormat;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.PeerAddress;
 import org.bitcoinj.core.Sha256Hash;
@@ -37,7 +37,7 @@
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptException;
 import org.bitcoinj.utils.ExchangeRate;
-import org.bitcoinj.utils.Fiat;
+import org.bitcoinj.base.utils.Fiat;
 import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/wallet/listeners/WalletCoinsReceivedEventListener.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.wallet.listeners;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.core.TransactionConfidence;
 import org.bitcoinj.wallet.Wallet;

File: core/src/main/java/org/bitcoinj/wallet/listeners/WalletCoinsSentEventListener.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.wallet.listeners;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Transaction;
 import org.bitcoinj.wallet.Wallet;
 

File: core/src/test/java/org/bitcoinj/base/utils/FiatTest.java
Patch:
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package org.bitcoinj.utils;
+package org.bitcoinj.base.utils;
 
+import org.bitcoinj.base.utils.Fiat;
 import org.junit.Test;
 
-import static org.bitcoinj.utils.Fiat.parseFiat;
+import static org.bitcoinj.base.utils.Fiat.parseFiat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.core;
 
 import com.google.common.collect.Lists;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.UnitTestParams;
 import org.bitcoinj.script.Script;
@@ -40,7 +41,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static org.bitcoinj.core.Coin.FIFTY_COINS;
+import static org.bitcoinj.base.Coin.FIFTY_COINS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;

File: core/src/test/java/org/bitcoinj/core/BlockTest.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.core;
 
 import com.google.common.io.ByteStreams;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.AbstractBlockChain.NewBlockType;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.TestNet3Params;

File: core/src/test/java/org/bitcoinj/core/ParseByteCacheTest.java
Patch:
@@ -29,8 +29,8 @@
 import java.io.ByteArrayOutputStream;
 import java.nio.ByteBuffer;
 
-import static org.bitcoinj.core.Coin.COIN;
-import static org.bitcoinj.core.Coin.valueOf;
+import static org.bitcoinj.base.Coin.COIN;
+import static org.bitcoinj.base.Coin.valueOf;
 import static org.bitcoinj.core.Utils.HEX;
 import static org.bitcoinj.testing.FakeTxBuilder.createFakeBlock;
 import static org.bitcoinj.testing.FakeTxBuilder.createFakeTx;

File: core/src/test/java/org/bitcoinj/core/TransactionInputTest.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core;
 
 import com.google.common.collect.Lists;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.params.UnitTestParams;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptBuilder;

File: core/src/test/java/org/bitcoinj/core/TransactionOutputTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptBuilder;
 import org.bitcoinj.script.ScriptPattern;

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.TransactionConfidence.ConfidenceType;
 import org.bitcoinj.crypto.TransactionSignature;
 import org.bitcoinj.params.TestNet3Params;

File: core/src/test/java/org/bitcoinj/core/TxConfidenceTableTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import java.net.InetAddress;
 
-import static org.bitcoinj.core.Coin.COIN;
+import static org.bitcoinj.base.Coin.COIN;
 import static org.easymock.EasyMock.anyObject;
 import static org.easymock.EasyMock.createMock;
 import static org.easymock.EasyMock.expect;

File: core/src/test/java/org/bitcoinj/core/UTXOTest.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.script.ScriptBuilder;
 import org.junit.Test;
 

File: core/src/test/java/org/bitcoinj/params/AbstractBitcoinNetParamsTest.java
Patch:
@@ -17,7 +17,7 @@
 package org.bitcoinj.params;
 
 import org.bitcoinj.core.Block;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentProtocolTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.bitcoin.protocols.payments.Protos.PaymentACK;
 import org.bitcoin.protocols.payments.Protos.PaymentRequest;
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentSessionTest.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.protobuf.ByteString;
 import org.bitcoin.protocols.payments.Protos;
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
@@ -44,7 +44,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 
-import static org.bitcoinj.core.Coin.COIN;
+import static org.bitcoinj.base.Coin.COIN;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;

File: core/src/test/java/org/bitcoinj/script/ScriptTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.common.collect.Lists;
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.DumpedPrivateKey;
 import org.bitcoinj.core.ECKey;

File: core/src/test/java/org/bitcoinj/store/WalletProtobufSerializerTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.bitcoinj.core.Block;
 import org.bitcoinj.core.BlockChain;
 import org.bitcoinj.core.BlockTest;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;
@@ -71,8 +71,8 @@
 import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static org.bitcoinj.core.Coin.COIN;
-import static org.bitcoinj.core.Coin.FIFTY_COINS;
+import static org.bitcoinj.base.Coin.COIN;
+import static org.bitcoinj.base.Coin.FIFTY_COINS;
 import static org.bitcoinj.testing.FakeTxBuilder.createFakeTx;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;

File: core/src/test/java/org/bitcoinj/testing/TestWithWallet.java
Patch:
@@ -20,7 +20,7 @@
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Block;
 import org.bitcoinj.core.BlockChain;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;

File: core/src/test/java/org/bitcoinj/uri/BitcoinURITest.java
Patch:
@@ -28,8 +28,8 @@
 import java.util.Collections;
 import java.util.Locale;
 
-import static org.bitcoinj.core.Coin.CENT;
-import static org.bitcoinj.core.Coin.parseCoin;
+import static org.bitcoinj.base.Coin.CENT;
+import static org.bitcoinj.base.Coin.parseCoin;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;

File: core/src/test/java/org/bitcoinj/utils/ExchangeRateTest.java
Patch:
@@ -16,7 +16,8 @@
 
 package org.bitcoinj.utils;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.utils.Fiat;
+import org.bitcoinj.base.Coin;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.bitcoinj.core.AbstractBlockChain;
 import org.bitcoinj.core.Block;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.PeerAddress;
 import org.bitcoinj.core.Transaction;
@@ -39,8 +39,8 @@
 import java.util.List;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static org.bitcoinj.core.Coin.CENT;
-import static org.bitcoinj.core.Coin.COIN;
+import static org.bitcoinj.base.Coin.CENT;
+import static org.bitcoinj.base.Coin.COIN;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -17,7 +17,7 @@
 
 package org.bitcoinj.wallet;
 
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
@@ -41,7 +41,7 @@
 import java.util.List;
 
 import static com.google.common.base.Preconditions.checkState;
-import static org.bitcoinj.core.Coin.COIN;
+import static org.bitcoinj.base.Coin.COIN;
 import static org.bitcoinj.script.ScriptOpCodes.OP_PUSHDATA1;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;

File: examples/src/main/java/org/bitcoinj/examples/DoubleSpend.java
Patch:
@@ -28,7 +28,7 @@
 
 import java.io.File;
 
-import static org.bitcoinj.core.Coin.*;
+import static org.bitcoinj.base.Coin.*;
 
 /**
  * This is a little test app that waits for a coin on a local regtest node, then  generates two transactions that double

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -18,7 +18,7 @@
 package org.bitcoinj.examples;
 
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.InsufficientMoneyException;
 import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.NetworkParameters;

File: examples/src/main/java/org/bitcoinj/examples/GenerateLowSTests.java
Patch:
@@ -26,7 +26,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import org.bitcoinj.core.LegacyAddress;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.SignatureDecodeException;

File: examples/src/main/java/org/bitcoinj/examples/PeerMonitor.java
Patch:
@@ -18,7 +18,7 @@
 package org.bitcoinj.examples;
 
 import org.bitcoinj.core.AddressMessage;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.Peer;
 import org.bitcoinj.core.PeerGroup;

File: examples/src/main/java/org/bitcoinj/examples/RefreshWallet.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.*;
 import org.bitcoinj.params.TestNet3Params;
 import org.bitcoinj.store.BlockStore;

File: examples/src/main/java/org/bitcoinj/examples/SendRequest.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.bitcoinj.examples;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.*;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.TestNet3Params;

File: integration-test/src/test/java/org/bitcoinj/core/FilteredBlockAndPartialMerkleTreeTest.java
Patch:
@@ -17,6 +17,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.TransactionConfidence.ConfidenceType;
 import org.bitcoinj.store.MemoryBlockStore;
 import org.bitcoinj.testing.FakeTxBuilder;

File: integration-test/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -19,6 +19,7 @@
 
 import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.listeners.DownloadProgressTracker;
 import org.bitcoinj.core.listeners.PeerConnectedEventListener;
 import org.bitcoinj.core.listeners.PeerDisconnectedEventListener;
@@ -61,8 +62,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.bitcoinj.core.Coin.COIN;
-import static org.bitcoinj.core.Coin.valueOf;
+import static org.bitcoinj.base.Coin.COIN;
+import static org.bitcoinj.base.Coin.valueOf;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;

File: integration-test/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.Uninterruptibles;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.listeners.BlocksDownloadedEventListener;
 import org.bitcoinj.core.listeners.PreMessageReceivedEventListener;
 import org.bitcoinj.params.TestNet3Params;
@@ -51,8 +52,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.bitcoinj.core.Coin.COIN;
-import static org.bitcoinj.core.Coin.valueOf;
+import static org.bitcoinj.base.Coin.COIN;
+import static org.bitcoinj.base.Coin.valueOf;
 import static org.bitcoinj.testing.FakeTxBuilder.createFakeBlock;
 import static org.bitcoinj.testing.FakeTxBuilder.createFakeTx;
 import static org.bitcoinj.testing.FakeTxBuilder.makeSolvedTestBlock;

File: integration-test/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -19,7 +19,7 @@
 
 import org.bitcoinj.core.Address;
 import org.bitcoinj.core.BlockChain;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.LegacyAddress;

File: tools/src/main/java/org/bitcoinj/tools/TestFeeLevel.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.bitcoinj.tools;
 
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.*;
 import org.bitcoinj.core.listeners.PeerConnectedEventListener;
 import org.bitcoinj.core.listeners.PeerDisconnectedEventListener;

File: wallettemplate/src/main/java/org/bitcoinj/walletfx/utils/BitcoinUIModel.java
Patch:
@@ -17,7 +17,7 @@
 package org.bitcoinj.walletfx.utils;
 
 import org.bitcoinj.core.Address;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.listeners.DownloadProgressTracker;
 import org.bitcoinj.wallet.Wallet;
 import javafx.application.Platform;

File: wallettemplate/src/main/java/wallettemplate/MainController.java
Patch:
@@ -23,8 +23,8 @@
 import javafx.scene.input.KeyCombination;
 import javafx.scene.layout.Pane;
 import org.bitcoinj.core.listeners.DownloadProgressTracker;
-import org.bitcoinj.core.Coin;
-import org.bitcoinj.utils.MonetaryFormat;
+import org.bitcoinj.base.Coin;
+import org.bitcoinj.base.utils.MonetaryFormat;
 import javafx.animation.FadeTransition;
 import javafx.animation.ParallelTransition;
 import javafx.animation.TranslateTransition;

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -17,6 +17,7 @@
 package wallettemplate;
 
 import javafx.scene.layout.HBox;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.*;
 import org.bitcoinj.wallet.SendRequest;
 import org.bitcoinj.wallet.Wallet;

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -47,7 +47,7 @@
 import org.bitcoinj.core.Base58;
 import org.bitcoinj.core.BlockChain;
 import org.bitcoinj.core.CheckpointManager;
-import org.bitcoinj.core.Coin;
+import org.bitcoinj.base.Coin;
 import org.bitcoinj.core.Context;
 import org.bitcoinj.core.DumpedPrivateKey;
 import org.bitcoinj.core.ECKey;
@@ -108,7 +108,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import static org.bitcoinj.core.Coin.parseCoin;
+import static org.bitcoinj.base.Coin.parseCoin;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -133,7 +133,7 @@ public WalletAppKit(Context context, Script.ScriptType preferredOutputScriptType
         this.context = context;
         this.params = checkNotNull(context.getParams());
         this.preferredOutputScriptType = checkNotNull(preferredOutputScriptType);
-        this.structure = structure != null ? structure : KeyChainGroupStructure.DEFAULT;
+        this.structure = structure != null ? structure : KeyChainGroupStructure.BIP32;
         this.directory = checkNotNull(directory);
         this.filePrefix = checkNotNull(filePrefix);
     }

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -255,7 +255,7 @@ public static KeyChainGroup createBasic(NetworkParameters params) {
     }
 
     public static KeyChainGroup.Builder builder(NetworkParameters params) {
-        return new Builder(params, KeyChainGroupStructure.DEFAULT);
+        return new Builder(params, KeyChainGroupStructure.BIP32);
     }
 
     public static KeyChainGroup.Builder builder(NetworkParameters params, KeyChainGroupStructure structure) {

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroupStructure.java
Patch:
@@ -25,7 +25,7 @@
 /**
  *  Defines a structure for hierarchical deterministic wallets.
  *  <p>
- *  Use {@link KeyChainGroupStructure#DEFAULT} for BIP-32 wallets and {@link KeyChainGroupStructure#BIP43} for
+ *  Use {@link KeyChainGroupStructure#BIP32} for BIP-32 wallets and {@link KeyChainGroupStructure#BIP43} for
  *  BIP-43-family wallets.
  *  <p>
  *  <b>bitcoinj</b> BIP-32 wallets use {@link DeterministicKeyChain#ACCOUNT_ZERO_PATH} for {@link Script.ScriptType#P2PKH}
@@ -90,7 +90,9 @@ else if (outputScriptType == Script.ScriptType.P2WPKH)
 
     /**
      * Default {@link KeyChainGroupStructure} implementation. Alias for {@link KeyChainGroupStructure#BIP32}
+     * @deprecated Use {@link #BIP32} for BIP-32
      */
+    @Deprecated
     KeyChainGroupStructure DEFAULT = BIP32;
 
     /**

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -334,7 +334,7 @@ public static Wallet createBasic(NetworkParameters params) {
      */
     public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed,
             Script.ScriptType outputScriptType) {
-        return fromSeed(params, seed, outputScriptType, KeyChainGroupStructure.DEFAULT);
+        return fromSeed(params, seed, outputScriptType, KeyChainGroupStructure.BIP32);
     }
 
     /**
@@ -718,7 +718,7 @@ public List<Address> getIssuedReceiveAddresses() {
      */
     public void upgradeToDeterministic(Script.ScriptType outputScriptType, @Nullable KeyParameter aesKey)
             throws DeterministicUpgradeRequiresPassword {
-        upgradeToDeterministic(outputScriptType, KeyChainGroupStructure.DEFAULT, aesKey);
+        upgradeToDeterministic(outputScriptType, KeyChainGroupStructure.BIP32, aesKey);
     }
 
     /**
@@ -5301,7 +5301,7 @@ public boolean isKeyRotating(ECKey key) {
      */
     public ListenableCompletableFuture<List<Transaction>> doMaintenance(@Nullable KeyParameter aesKey, boolean signAndSend)
             throws DeterministicUpgradeRequiresPassword {
-        return doMaintenance(KeyChainGroupStructure.DEFAULT, aesKey, signAndSend);
+        return doMaintenance(KeyChainGroupStructure.BIP32, aesKey, signAndSend);
     }
 
     /**

File: core/src/test/java/org/bitcoinj/wallet/KeyChainGroupTest.java
Patch:
@@ -552,7 +552,7 @@ public void deterministicUpgradeUnencrypted() throws Exception {
         group = KeyChainGroup.builder(MAINNET).fromRandom(Script.ScriptType.P2PKH).lookaheadSize(LOOKAHEAD_SIZE).build();
 
         List<Protos.Key> protobufs = group.serializeToProtobuf();
-        group.upgradeToDeterministic(Script.ScriptType.P2PKH, KeyChainGroupStructure.DEFAULT, 0, null);
+        group.upgradeToDeterministic(Script.ScriptType.P2PKH, KeyChainGroupStructure.BIP32, 0, null);
         assertFalse(group.isEncrypted());
         assertFalse(group.isDeterministicUpgradeRequired(Script.ScriptType.P2PKH, 0));
         assertTrue(group.isDeterministicUpgradeRequired(Script.ScriptType.P2WPKH, 0));
@@ -561,7 +561,7 @@ public void deterministicUpgradeUnencrypted() throws Exception {
         assertNotNull(seed1);
 
         group = KeyChainGroup.fromProtobufUnencrypted(MAINNET, protobufs);
-        group.upgradeToDeterministic(Script.ScriptType.P2PKH, KeyChainGroupStructure.DEFAULT, 0, null);  // Should give same result as last time.
+        group.upgradeToDeterministic(Script.ScriptType.P2PKH, KeyChainGroupStructure.BIP32, 0, null);  // Should give same result as last time.
         assertFalse(group.isEncrypted());
         assertFalse(group.isDeterministicUpgradeRequired(Script.ScriptType.P2PKH, 0));
         assertTrue(group.isDeterministicUpgradeRequired(Script.ScriptType.P2WPKH, 0));

File: examples/src/main/java/org/bitcoinj/examples/DoubleSpend.java
Patch:
@@ -20,8 +20,10 @@
 import org.bitcoinj.core.*;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.RegTestParams;
+import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
 import org.bitcoinj.utils.Threading;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 
 import java.io.File;
@@ -37,7 +39,7 @@ public class DoubleSpend {
     public static void main(String[] args) throws Exception {
         BriefLogFormatter.init();
         final RegTestParams params = RegTestParams.get();
-        WalletAppKit kit = new WalletAppKit(params, new File("."), "doublespend");
+        WalletAppKit kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "doublespend");
         kit.connectToLocalHost();
         kit.setAutoSave(false);
         kit.startAsync();

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -29,7 +29,9 @@
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.RegTestParams;
 import org.bitcoinj.params.TestNet3Params;
+import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.SendRequest;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener;
@@ -78,7 +80,7 @@ public static void main(String[] args) throws Exception {
         System.out.println("Forwarding address: " + forwardingAddress);
 
         // Start up a basic app using a class that automates some boilerplate.
-        kit = new WalletAppKit(params, new File("."), filePrefix);
+        kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), filePrefix);
 
         if (params == RegTestParams.get()) {
             // Regression test mode is designed for testing and development only, so there's no public network for it.

File: examples/src/main/java/org/bitcoinj/examples/Kit.java
Patch:
@@ -20,6 +20,7 @@
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.TestNet3Params;
 import org.bitcoinj.script.Script;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.listeners.KeyChainEventListener;
 import org.bitcoinj.wallet.listeners.ScriptsChangeEventListener;
@@ -55,7 +56,7 @@ public static void main(String[] args) {
 
         // Now we initialize a new WalletAppKit. The kit handles all the boilerplate for us and is the easiest way to get everything up and running.
         // Have a look at the WalletAppKit documentation and its source to understand what's happening behind the scenes: https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
-        WalletAppKit kit = new WalletAppKit(params, new File("."), "walletappkit-example");
+        WalletAppKit kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "walletappkit-example");
 
         // In case you want to connect with your local bitcoind tell the kit to connect to localhost.
         // You must do that in reg test mode.

File: examples/src/main/java/org/bitcoinj/examples/SendRequest.java
Patch:
@@ -19,6 +19,8 @@
 import org.bitcoinj.core.*;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.TestNet3Params;
+import org.bitcoinj.script.Script;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 import org.bitcoinj.wallet.Wallet.BalanceType;
 
@@ -34,7 +36,7 @@ public static void main(String[] args) throws Exception {
 
         // We use the WalletAppKit that handles all the boilerplate for us. Have a look at the Kit.java example for more details.
         NetworkParameters params = TestNet3Params.get();
-        WalletAppKit kit = new WalletAppKit(params, new File("."), "sendrequest-example");
+        WalletAppKit kit = new WalletAppKit(params, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "sendrequest-example");
         kit.startAsync();
         kit.awaitRunning();
 

File: tools/src/main/java/org/bitcoinj/tools/TestFeeLevel.java
Patch:
@@ -21,7 +21,9 @@
 import org.bitcoinj.core.listeners.PeerDisconnectedEventListener;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.MainNetParams;
+import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.SendRequest;
 import org.bitcoinj.wallet.Wallet;
 
@@ -47,7 +49,7 @@ public static void main(String[] args) throws Exception {
         Coin feeRateToTest = Coin.valueOf(Long.parseLong(args[0]));
         System.out.println("Fee rate to test is " + feeRateToTest.toFriendlyString() + "/kB");
 
-        kit = new WalletAppKit(PARAMS, new File("."), "testfeelevel");
+        kit = new WalletAppKit(PARAMS, Script.ScriptType.P2WPKH, KeyChainGroupStructure.BIP32, new File("."), "testfeelevel");
         kit.startAsync();
         kit.awaitRunning();
         try {

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -36,6 +36,7 @@
 import java.net.InetAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.bitcoinj.core.Coin.CENT;
@@ -129,7 +130,7 @@ public void coinAgeOrdering() {
     public void identicalInputs() {
         // Add four outputs to a transaction with same value and destination. Select them all.
         Transaction t = new Transaction(UNITTEST);
-        java.util.List<TransactionOutput> outputs = Arrays.asList(
+        List<TransactionOutput> outputs = Arrays.asList(
             new TransactionOutput(UNITTEST, t, Coin.valueOf(30302787), myAddress),
             new TransactionOutput(UNITTEST, t, Coin.valueOf(30302787), myAddress),
             new TransactionOutput(UNITTEST, t, Coin.valueOf(30302787), myAddress),

File: core/src/main/java/org/bitcoinj/core/ECKey.java
Patch:
@@ -725,7 +725,8 @@ private static ECKey extractKeyFromASN1(byte[] asn1privkey) {
 
             ASN1TaggedObject pubkey = (ASN1TaggedObject) seq.getObjectAt(3);
             checkArgument(pubkey.getTagNo() == 1, "Input has 'publicKey' with bad tag number");
-            byte[] pubbits = ((DERBitString)pubkey.getObject()).getBytes();
+            checkArgument(pubkey.getTagClass() == BERTags.CONTEXT_SPECIFIC, "Input has 'publicKey' with bad tag class");
+            byte[] pubbits = ((DERBitString) pubkey.getBaseObject()).getBytes();
             checkArgument(pubbits.length == 33 || pubbits.length == 65, "Input has 'publicKey' with invalid length");
             int encoding = pubbits[0] & 0xFF;
             // Only allow compressed(2,3) and uncompressed(4), not infinity(0) or hybrid(6,7)

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -3841,7 +3841,7 @@ public Coin getTotalSent() {
 
             // If there is an input that isn't from us, i.e. this is a shared transaction
             Coin txInputsTotal = tx.getInputSum();
-            if (txOwnedInputsTotal != txInputsTotal) {
+            if (!txOwnedInputsTotal.equals(txInputsTotal)) {
 
                 // multiply our output total by the appropriate proportion to account for the inputs that we don't own
                 BigInteger txOutputTotalNum = new BigInteger(txOutputTotal.toString());

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -311,7 +311,7 @@ protected String getPassphrase() {
     }
 
     public static Builder<?> builder() {
-        return new Builder();
+        return new Builder<>();
     }
 
     /**

File: core/src/main/java/org/bitcoinj/crypto/HDPath.java
Patch:
@@ -95,7 +95,7 @@ public static HDPath M(List<ChildNumber> list) {
      * Returns an empty path for a public key.
      */
     public static HDPath M() {
-        return HDPath.M(Collections.<ChildNumber>emptyList());
+        return HDPath.M(Collections.emptyList());
     }
 
     /**
@@ -129,7 +129,7 @@ public static HDPath m(List<ChildNumber> list) {
      * Returns an empty path for a private key.
      */
     public static HDPath m() {
-        return HDPath.m(Collections.<ChildNumber>emptyList());
+        return HDPath.m(Collections.emptyList());
     }
 
     /**

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -840,7 +840,7 @@ private void filterAndSend(InboundMessageQueuer p1, List<Block> blocks, BloomFil
 
     @Test
     public void testMaxOfMostFreq() {
-        assertEquals(0, PeerGroup.maxOfMostFreq(Collections.<Integer>emptyList()));
+        assertEquals(0, PeerGroup.maxOfMostFreq(Collections.emptyList()));
         assertEquals(0, PeerGroup.maxOfMostFreq(Arrays.asList(0, 0, 1)));
         assertEquals(3, PeerGroup.maxOfMostFreq(Arrays.asList(1, 3, 1, 2, 2, 3, 3)));
         assertEquals(0, PeerGroup.maxOfMostFreq(Arrays.asList(1, 1, 2, 2)));

File: core/src/test/java/org/bitcoinj/crypto/HDPathTest.java
Patch:
@@ -29,14 +29,14 @@
 public class HDPathTest {
     @Test
     public void testPrimaryConstructor() {
-        HDPath path = new HDPath(true, Collections.<ChildNumber>emptyList());
+        HDPath path = new HDPath(true, Collections.emptyList());
         Assert.assertTrue("Has private key returns false incorrectly", path.hasPrivateKey);
         Assert.assertEquals("Path not empty", path.size(), 0);
     }
 
     @Test
     public void testExtendVarargs() {
-        HDPath basePath = new HDPath(true, Collections.<ChildNumber>emptyList());
+        HDPath basePath = new HDPath(true, Collections.emptyList());
         // Make sure we can do a depth of 5 as per BIP44, etc.
         // m / 44' / coinType' / accountIndex' / change / addressIndex
         HDPath path1 = basePath.extend(ChildNumber.ZERO_HARDENED);

File: core/src/test/java/org/bitcoinj/store/SPVBlockStoreTest.java
Patch:
@@ -146,7 +146,7 @@ public void performanceTest() throws BlockStoreException {
         for (int i = 0; i < ITERATIONS; i++) {
             // Using i as the nonce so that the block hashes are different.
             Block block = new Block(UNITTEST, 0, Sha256Hash.ZERO_HASH, Sha256Hash.ZERO_HASH, 0, 0, i,
-                    Collections.<Transaction> emptyList());
+                    Collections.emptyList());
             StoredBlock b = new StoredBlock(block, BigInteger.ZERO, i);
             store.put(b);
             store.setChainHead(b);

File: core/src/main/java/org/bitcoinj/utils/FutureUtils.java
Patch:
@@ -62,7 +62,7 @@ public static <T> ListenableCompletableFuture<List<T>> successfulAsList(
      * 2. As a {@code FunctionalInterface} where a lambda that throws exceptions is
      * expected or allowed.
      *
-     * @param <T>
+     * @param <T> the supplied type
      */
     @FunctionalInterface
     public interface ThrowingSupplier<T> extends Supplier<T> {

File: wallettool/src/main/java/org/bitcoinj/wallettool/WalletTool.java
Patch:
@@ -340,7 +340,7 @@ public enum ValidationMode {
         SPV
     }
 
-    public static void main(String[] args) throws Exception {
+    public static void main(String[] args) {
         int exitCode = new CommandLine(new WalletTool()).execute(args);
         System.exit(exitCode);
     }

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -93,13 +93,14 @@ public class WalletProtobufSerializer {
 
     public interface WalletFactory {
         Wallet create(NetworkParameters params, KeyChainGroup keyChainGroup);
+        WalletFactory DEFAULT = Wallet::new;
     }
 
     private final WalletFactory factory;
     private KeyChainFactory keyChainFactory;
 
     public WalletProtobufSerializer() {
-        this(Wallet::new);
+        this(WalletFactory.DEFAULT);
     }
 
     public WalletProtobufSerializer(WalletFactory factory) {

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -41,6 +41,7 @@
 import java.net.SocketAddress;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -141,7 +142,7 @@ public GetDataRequest(Sha256Hash hash) {
         }
     }
     // TODO: The types/locking should be rationalised a bit.
-    private final CopyOnWriteArrayList<GetDataRequest> getDataFutures;
+    private final Queue<GetDataRequest> getDataFutures;
     @GuardedBy("getAddrFutures") private final LinkedList<CompletableFuture<AddressMessage>> getAddrFutures;
 
     // Outstanding pings against this peer and how long the last one took to complete.
@@ -214,7 +215,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
         this.blockChain = chain;  // Allowed to be null.
         this.requiredServices = requiredServices;
         this.vDownloadData = chain != null;
-        this.getDataFutures = new CopyOnWriteArrayList<>();
+        this.getDataFutures = new ConcurrentLinkedQueue<>();
         this.getAddrFutures = new LinkedList<>();
         this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();
         this.pendingPings = new CopyOnWriteArrayList<>();

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -403,7 +403,7 @@ private void basicSpendingCommon(Wallet wallet, Address toAddress, Address desti
         assertEquals(1, unspents1.size());
         broadcastAndCommit(wallet, t2);
         List<TransactionOutput> unspents2 = wallet.getUnspents();
-        assertNotEquals(unspents1, unspents2.size());
+        assertNotSame(unspents1, unspents2);
 
         // Now check that we can spend the unconfirmed change, with a new change address of our own selection.
         // (req.aesKey is null for unencrypted / the correct aesKey for encrypted.)

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -2723,12 +2723,10 @@ public boolean maybeCommitTx(Transaction tx) throws VerificationException {
     /**
      * Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags and runs
      * the onCoinsSent/onCoinsReceived event listener. Used in two situations:
-     * <p>
      * <ol>
      *     <li>When we have just successfully transmitted the tx we created to the network.</li>
      *     <li>When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.</li>
      * </ol>
-     * <p>
      * Triggers an auto save (if enabled.)
      * <p>
      * Unlike {@link Wallet#maybeCommitTx} {@code commitTx} throws an exception if the transaction

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -552,7 +552,7 @@ public void run() {
                                     Transaction.SigHash.ALL.byteValue())
                                     .toString());
                 }
-            };
+            }.start();
         }
     }
 

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -336,7 +336,7 @@ public String toString() {
             Script script = getScriptPubKey();
             StringBuilder buf = new StringBuilder("TxOut of ");
             buf.append(Coin.valueOf(value).toFriendlyString());
-            if (ScriptPattern.isP2PKH(script) || ScriptPattern.isP2WPKH(script)
+            if (ScriptPattern.isP2PKH(script) || ScriptPattern.isP2WPKH(script) || ScriptPattern.isP2TR(script)
                     || ScriptPattern.isP2SH(script))
                 buf.append(" to ").append(script.getToAddress(params));
             else if (ScriptPattern.isP2PK(script))

File: wallettemplate/src/main/java/wallettemplate/MainController.java
Patch:
@@ -42,7 +42,7 @@
 import org.bitcoinj.walletfx.utils.easing.EasingMode;
 import org.bitcoinj.walletfx.utils.easing.ElasticInterpolator;
 
-import static wallettemplate.Main.bitcoin;
+import static wallettemplate.WalletTemplate.bitcoin;
 
 /**
  * Gets created auto-magically by FXMLLoader via reflection. The widget fields are set to the GUI controls they're named
@@ -67,7 +67,7 @@ public void initialize() {
         // Special case of initOverlay that passes null as the 2nd parameter because ClickableBitcoinAddress is loaded by FXML
         // TODO: Extract QRCode Pane to separate reusable class that is a more standard OverlayController instance
         addressControl.initOverlay(this, null);
-        addressControl.setAppName(Main.APP_NAME);
+        addressControl.setAppName(WalletTemplate.instance.applicationName);
         addressControl.setOpacity(0.0);
     }
 

File: wallettemplate/src/main/java/wallettemplate/WalletSetPasswordController.java
Patch:
@@ -117,7 +117,7 @@ protected final void onFinish(KeyParameter aesKey, int timeTakenMsec) {
                 WalletPasswordController.setTargetTime(Duration.ofMillis(timeTakenMsec));
                 // The actual encryption part doesn't take very long as most private keys are derived on demand.
                 log.info("Key derived, now encrypting");
-                Main.bitcoin.wallet().encrypt(scrypt, aesKey);
+                WalletTemplate.bitcoin.wallet().encrypt(scrypt, aesKey);
                 log.info("Encryption done");
                 informationalAlert("Wallet encrypted",
                         "You can remove the password at any time from the settings screen.");

File: core/src/test/java/org/bitcoinj/core/UtilsTest.java
Patch:
@@ -237,5 +237,6 @@ public void testDecodeMPI() {
     public void testRollMockClock() {
         Utils.setMockClock(25200);
         assertEquals(new Date("Thu Jan 01 07:00:08 GMT 1970"), Utils.rollMockClock(8));
+        Utils.resetMocking();
     }
 }

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -75,7 +75,7 @@ public enum VerifyFlag {
      */
     public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;
 
-    /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */
+    /** A value for difficultyTarget (nBits) that allows (slightly less than) half of all possible hash solutions. Used in unit testing. */
     public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL;
 
     /** Value to use if the block height is unknown */

File: core/src/main/java/org/bitcoinj/core/SendAddrV2Message.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * <p>Represents the {@code sendaddrv2} P2P protocol message, which indicates that a node can understand and prefers
- * to receive {@code addrv2] messages instead of {@code addr} messages.</p>
+ * to receive {@code addrv2} messages instead of {@code addr} messages.</p>
  *
  * <p>See <a href="https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki">BIP155</a> for details.</p>
  *

File: core/src/main/java/org/bitcoinj/core/Message.java
Patch:
@@ -89,7 +89,7 @@ protected Message(NetworkParameters params, byte[] payload, int offset, int prot
 
         parse();
 
-        if (this.length == UNKNOWN_LENGTH)
+        if (this.length == UNKNOWN_LENGTH && !(this instanceof UnknownMessage))
             checkState(false, "Length field has not been set in constructor for %s after parse.",
                        getClass().getSimpleName());
         

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4920,7 +4920,7 @@ private boolean isTxOutputBloomFilterable(TransactionOutput out) {
         Script script = out.getScriptPubKey();
         boolean isScriptTypeSupported = ScriptPattern.isP2PK(script) || ScriptPattern.isP2SH(script)
                 || ScriptPattern.isP2WPKH(script) || ScriptPattern.isP2WSH(script);
-        return (isScriptTypeSupported && myUnspents.contains(out)) || watchedScripts.contains(script);
+        return (isScriptTypeSupported && out.isMine(this)) || watchedScripts.contains(script);
     }
 
     /**

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -617,7 +617,7 @@ public void shutdown() {
 
     @Test
     public void testBloomOnP2PK() throws Exception {
-        // Cover bug 513. When a relevant transaction with a P2PK output is found, the Bloom filter should be
+        // Cover GitHub bug #879. When a relevant transaction with a P2PK output is found, the Bloom filter should be
         // recalculated to include that transaction hash but not re-broadcast as the remote nodes should have followed
         // the same procedure. However a new node that's connected should get the fresh filter.
         peerGroup.start();

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -190,8 +190,8 @@ public void testFinalizedBlocks() throws Exception {
             chain.add(rollingBlock);
         }
         
-        WeakReference<UTXO> out = new WeakReference<UTXO>
-                                       (store.getTransactionOutput(spendableOutput.getHash(), spendableOutput.getIndex()));
+        WeakReference<UTXO> out = new WeakReference<>
+                (store.getTransactionOutput(spendableOutput.getHash(), spendableOutput.getIndex()));
         rollingBlock = rollingBlock.createNextBlock(null);
         
         Transaction t = new Transaction(PARAMS);

File: examples/src/main/java/org/bitcoinj/examples/PeerMonitor.java
Patch:
@@ -49,7 +49,7 @@ public class PeerMonitor {
     private PeerTableModel peerTableModel;
     private PeerTableRenderer peerTableRenderer;
 
-    private final HashMap<Peer, String> reverseDnsLookups = new HashMap<Peer, String>();
+    private final HashMap<Peer, String> reverseDnsLookups = new HashMap<>();
 
     public static void main(String[] args) throws Exception {
         BriefLogFormatter.init();

File: examples/src/main/java/org/bitcoinj/examples/PrintPeers.java
Patch:
@@ -69,7 +69,7 @@ public static void main(String[] args) throws Exception {
         printDNS();
         System.out.println("=== Version/chain heights ===");
 
-        ArrayList<InetAddress> addrs = new ArrayList<InetAddress>();
+        ArrayList<InetAddress> addrs = new ArrayList<>();
         for (InetSocketAddress peer : dnsPeers) addrs.add(peer.getAddress());
         System.out.println("Scanning " + addrs.size() + " peers:");
 

File: tools/src/main/java/org/bitcoinj/tools/BuildCheckpoints.java
Patch:
@@ -132,7 +132,7 @@ public static void main(String[] args) throws Exception {
         }
 
         // Sorted map of block height to StoredBlock object.
-        final TreeMap<Integer, StoredBlock> checkpoints = new TreeMap<Integer, StoredBlock>();
+        final TreeMap<Integer, StoredBlock> checkpoints = new TreeMap<>();
 
         long now = new Date().getTime() / 1000;
         peerGroup.setFastCatchupTimeSecs(now);

File: tools/src/main/java/org/bitcoinj/tools/WatchMempool.java
Patch:
@@ -39,7 +39,7 @@ public class WatchMempool {
     private static final Logger log = LoggerFactory.getLogger(WatchMempool.class);
     private static final NetworkParameters PARAMS = MainNetParams.get();
     private static final ImmutableList<Transaction> NO_DEPS = ImmutableList.of();
-    private static final Map<String, Integer> counters = new HashMap<String, Integer>();
+    private static final Map<String, Integer> counters = new HashMap<>();
     private static final String TOTAL_KEY = "TOTAL";
     private static final long START_MS = System.currentTimeMillis();
     private static final long STATISTICS_FREQUENCY_MS = 1000 * 5;

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -209,7 +209,7 @@ public void done() {
 
     public <T> OverlayUI<T> overlayUI(Node node, T controller) {
         checkGuiThread();
-        OverlayUI<T> pair = new OverlayUI<T>(node, controller);
+        OverlayUI<T> pair = new OverlayUI<>(node, controller);
         // Auto-magically set the overlayUI member, if it's there.
         try {
             controller.getClass().getField("overlayUI").set(controller, pair);
@@ -228,7 +228,7 @@ public <T> OverlayUI<T> overlayUI(String name) {
             FXMLLoader loader = new FXMLLoader(location);
             Pane ui = loader.load();
             T controller = loader.getController();
-            OverlayUI<T> pair = new OverlayUI<T>(ui, controller);
+            OverlayUI<T> pair = new OverlayUI<>(ui, controller);
             // Auto-magically set the overlayUI member, if it's there.
             try {
                 if (controller != null)

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -82,7 +82,7 @@ public void send(ActionEvent event) {
             // their own money!
             req.allowUnconfirmed();
             sendResult = Main.bitcoin.wallet().sendCoins(req);
-            Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<Transaction>() {
+            Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<>() {
                 @Override
                 public void onSuccess(@Nullable Transaction result) {
                     checkGuiThread();

File: wallettemplate/src/main/java/wallettemplate/utils/KeyDerivationTasks.java
Patch:
@@ -44,7 +44,7 @@ public class KeyDerivationTasks {
     private volatile int timeTakenMsec = -1;
 
     public KeyDerivationTasks(KeyCrypterScrypt scrypt, String password, @Nullable Duration targetTime) {
-        keyDerivationTask = new Task<KeyParameter>() {
+        keyDerivationTask = new Task<>() {
             @Override
             protected KeyParameter call() throws Exception {
                 long start = System.currentTimeMillis();
@@ -63,7 +63,7 @@ protected KeyParameter call() throws Exception {
 
         // And the fake progress meter ... if the vals were calculated correctly progress bar should reach 100%
         // a brief moment after the keys were derived successfully.
-        progressTask = new Task<Void>() {
+        progressTask = new Task<>() {
             private KeyParameter aesKey;
 
             @Override

File: core/src/test/java/org/bitcoinj/core/CoinTest.java
Patch:
@@ -116,7 +116,7 @@ public void testAdditionOverflow() {
     }
 
     @Test(expected = ArithmeticException.class)
-    public void testSubstractionUnderflow() {
+    public void testSubtractionUnderflow() {
         Coin.valueOf(Long.MIN_VALUE).subtract(Coin.SATOSHI);
     }
 

File: core/src/test/java/org/bitcoinj/core/PrefixedChecksummedBytesTest.java
Patch:
@@ -93,6 +93,7 @@ public void comparisonCloneEqualTo() throws Exception {
         PrefixedChecksummedBytes a = new PrefixedChecksummedBytesToTest(params, HEX.decode("fda79a24e50ff70ff42f7d89585da5bd19d9e5cc"));
         PrefixedChecksummedBytes b = a.clone();
 
-        assertEquals(0, a.compareTo(b));
+        assertNotSame(a, b);
+        assertEquals(a, b);
     }
 }

File: core/src/test/java/org/bitcoinj/utils/AppDataDirectoryTest.java
Patch:
@@ -34,7 +34,7 @@ public void worksOnCurrentPlatform() {
         final String appName = "bitcoinj";
         String path = AppDataDirectory.get(appName).toString();
         if (Utils.isWindows()) {
-            assertEquals("Path wrong on Mac", winPath(appName), path);
+            assertEquals("Path wrong on Windows", winPath(appName), path);
         } else if (Utils.isMac()) {
             assertEquals("Path wrong on Mac",  macPath(appName), path);
         } else if (Utils.isLinux()) {
@@ -49,7 +49,7 @@ public void worksOnCurrentPlatformForBitcoinCore() {
         final String appName = "Bitcoin";
         String path = AppDataDirectory.get(appName).toString();
         if (Utils.isWindows()) {
-            assertEquals("Path wrong on Mac", winPath(appName), path);
+            assertEquals("Path wrong on Windows", winPath(appName), path);
         } else if (Utils.isMac()) {
             assertEquals("Path wrong on Mac",  macPath(appName), path);
         } else if (Utils.isLinux()) {

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -994,8 +994,7 @@ public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scrip
             input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));
             input.setWitness(null);
         } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {
-            Script scriptCode = new ScriptBuilder()
-                    .data(ScriptBuilder.createOutputScript(LegacyAddress.fromKey(params, sigKey)).getProgram()).build();
+            Script scriptCode = ScriptBuilder.createP2PKHOutputScript(sigKey);
             TransactionSignature signature = calculateWitnessSignature(inputIndex, sigKey, scriptCode, input.getValue(),
                     sigHash, anyoneCanPay);
             input.setScriptSig(ScriptBuilder.createEmpty());

File: core/src/main/java/org/bitcoinj/signers/LocalTransactionSigner.java
Patch:
@@ -131,9 +131,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                     txIn.setScriptSig(inputScript);
                     txIn.setWitness(null);
                 } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {
-                    Script scriptCode = new ScriptBuilder().data(
-                            ScriptBuilder.createOutputScript(LegacyAddress.fromKey(tx.getParams(), key)).getProgram())
-                            .build();
+                    Script scriptCode = ScriptBuilder.createP2PKHOutputScript(key);
                     Coin value = txIn.getValue();
                     TransactionSignature signature = tx.calculateWitnessSignature(i, key, scriptCode, value,
                             Transaction.SigHash.ALL, false);

File: core/src/main/java/org/bitcoinj/params/Networks.java
Patch:
@@ -31,9 +31,9 @@
  */
 public class Networks {
     /** Registered networks */
-    private static Set<? extends NetworkParameters> networks = ImmutableSet.of(TestNet3Params.get(), MainNetParams.get());
+    private static Set<NetworkParameters> networks = ImmutableSet.<NetworkParameters>of(TestNet3Params.get(), MainNetParams.get());
 
-    public static Set<? extends NetworkParameters> get() {
+    public static Set<NetworkParameters> get() {
         return networks;
     }
 

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -86,14 +86,14 @@ public DeterministicKey(List<ChildNumber> childNumberPath,
     }
 
     /** Constructs a key from its components. This is not normally something you should use. */
-    public DeterministicKey(List<ChildNumber> childNumberPath,
+    public DeterministicKey(HDPath hdPath,
                             byte[] chainCode,
                             BigInteger priv,
                             @Nullable DeterministicKey parent) {
         super(priv, ECKey.publicPointFromPrivate(priv), true);
         checkArgument(chainCode.length == 32);
         this.parent = parent;
-        this.childNumberPath = HDPath.M(checkNotNull(childNumberPath));
+        this.childNumberPath = checkNotNull(hdPath);
         this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
         this.depth = parent == null ? 0 : parent.depth + 1;
         this.parentFingerprint = (parent != null) ? parent.getFingerprint() : 0;

File: core/src/test/java/org/bitcoinj/crypto/HDKeyDerivationTest.java
Patch:
@@ -43,7 +43,7 @@ public class HDKeyDerivationTest {
 
     @Test
     public void testDeriveFromPrivateParent() {
-        DeterministicKey parent = new DeterministicKey(ImmutableList.<ChildNumber> of(), new byte[32], BigInteger.TEN,
+        DeterministicKey parent = new DeterministicKey(HDPath.M(), new byte[32], BigInteger.TEN,
                 null);
         assertFalse(parent.isPubKeyOnly());
         assertFalse(parent.isEncrypted());
@@ -74,7 +74,7 @@ public void testDeriveFromPrivateParent() {
 
     @Test
     public void testDeriveFromPublicParent() {
-        DeterministicKey parent = new DeterministicKey(ImmutableList.<ChildNumber> of(), new byte[32], BigInteger.TEN,
+        DeterministicKey parent = new DeterministicKey(HDPath.M(), new byte[32], BigInteger.TEN,
                 null).dropPrivateBytes();
         assertTrue(parent.isPubKeyOnly());
         assertFalse(parent.isEncrypted());
@@ -103,7 +103,7 @@ public void testDeriveFromPublicParent() {
 
     @Test
     public void testDeriveFromEncryptedParent() {
-        DeterministicKey parent = new DeterministicKey(ImmutableList.<ChildNumber> of(), new byte[32], BigInteger.TEN,
+        DeterministicKey parent = new DeterministicKey(HDPath.M(), new byte[32], BigInteger.TEN,
                 null);
         parent = parent.encrypt(KEY_CRYPTER, AES_KEY, null);
         assertTrue(parent.isEncrypted());

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -906,8 +906,7 @@ public String toString(@Nullable AbstractBlockChain chain, @Nullable CharSequenc
                                 .append(spentBy.getIndex());
                     }
                 }
-                if (scriptType != null || !out.isAvailableForSpending())
-                    s.append('\n');
+                s.append('\n');
             } catch (Exception e) {
                 s.append("[exception: ").append(e.getMessage()).append("]\n");
             }

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -930,7 +930,7 @@ protected int discoverPeers() {
         final Stopwatch watch = Stopwatch.createStarted();
         final List<PeerAddress> addressList = new LinkedList<>();
         for (PeerDiscovery peerDiscovery : peerDiscoverers /* COW */) {
-            InetSocketAddress[] addresses;
+            List<InetSocketAddress> addresses;
             try {
                 addresses = peerDiscovery.getPeers(requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS);
             } catch (PeerDiscoveryException e) {

File: core/src/main/java/org/bitcoinj/net/discovery/PeerDiscovery.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.net.discovery;
 
 import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import org.bitcoinj.core.VersionMessage;
@@ -30,10 +31,10 @@ public interface PeerDiscovery {
     // TODO: Flesh out this interface a lot more.
 
     /**
-     * Returns an array of addresses. This method may block.
+     * Queries the addresses. This method may block.
      * @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
      */
-    InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit) throws PeerDiscoveryException;
+    List<InetSocketAddress> getPeers(long services, long timeoutValue, TimeUnit timeoutUnit) throws PeerDiscoveryException;
 
     /** Stops any discovery in progress when we want to shut down quickly. */
     void shutdown();

File: core/src/test/java/org/bitcoinj/net/discovery/SeedPeersTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.Test;
 
 import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -49,7 +50,7 @@ public void getPeer_all() throws Exception{
     @Test
     public void getPeers_length() throws Exception{
         SeedPeers seedPeers = new SeedPeers(MAINNET);
-        InetSocketAddress[] addresses = seedPeers.getPeers(0, 0, TimeUnit.SECONDS);
-        assertThat(addresses.length, equalTo(MAINNET.getAddrSeeds().length));
+        List<InetSocketAddress> addresses = seedPeers.getPeers(0, 0, TimeUnit.SECONDS);
+        assertThat(addresses.size(), equalTo(MAINNET.getAddrSeeds().length));
     }
 }

File: examples/src/main/java/org/bitcoinj/examples/PrintPeers.java
Patch:
@@ -41,14 +41,14 @@
  * Prints a list of IP addresses obtained from DNS.
  */
 public class PrintPeers {
-    private static InetSocketAddress[] dnsPeers;
+    private static List<InetSocketAddress> dnsPeers;
 
     private static void printElapsed(long start) {
         long now = System.currentTimeMillis();
         System.out.println(String.format("Took %.2f seconds", (now - start) / 1000.0));
     }
 
-    private static void printPeers(InetSocketAddress[] addresses) {
+    private static void printPeers(List<InetSocketAddress> addresses) {
         for (InetSocketAddress address : addresses) {
             String hostAddress = address.getAddress().getHostAddress();
             System.out.println(String.format("%s:%d", hostAddress, address.getPort()));

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -102,8 +102,7 @@ public static boolean isSelectable(Transaction tx) {
                type.equals(TransactionConfidence.ConfidenceType.PENDING) &&
                confidence.getSource().equals(TransactionConfidence.Source.SELF) &&
                // In regtest mode we expect to have only one peer, so we won't see transactions propagate.
-               // TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0
-               (confidence.numBroadcastPeers() > 1 || tx.getParams().getId().equals(NetworkParameters.ID_REGTEST));
+               (confidence.numBroadcastPeers() > 0 || tx.getParams().getId().equals(NetworkParameters.ID_REGTEST));
     }
 
     private static DefaultCoinSelector instance;

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -54,7 +54,7 @@ public void selectable() throws Exception {
         t.getConfidence().setSource(TransactionConfidence.Source.SELF);
         assertFalse(DefaultCoinSelector.isSelectable(t));
         t.getConfidence().markBroadcastBy(new PeerAddress(UNITTEST, InetAddress.getByName("1.2.3.4")));
-        assertFalse(DefaultCoinSelector.isSelectable(t));
+        assertTrue(DefaultCoinSelector.isSelectable(t));
         t.getConfidence().markBroadcastBy(new PeerAddress(UNITTEST, InetAddress.getByName("5.6.7.8")));
         assertTrue(DefaultCoinSelector.isSelectable(t));
         t = new Transaction(UNITTEST);

File: core/src/main/java/org/bitcoinj/core/ChildMessage.java
Patch:
@@ -43,7 +43,8 @@ public ChildMessage(NetworkParameters params, byte[] payload, int offset, int pr
         super(params, payload, offset, protocolVersion);
     }
 
-    public ChildMessage(NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer setSerializer, int length) throws ProtocolException {
+    public ChildMessage(NetworkParameters params, byte[] payload, int offset, int protocolVersion,
+                        @Nullable Message parent, MessageSerializer setSerializer, int length) throws ProtocolException {
         super(params, payload, offset, protocolVersion, setSerializer, length);
         this.parent = parent;
     }

File: tools/src/main/java/org/bitcoinj/tools/BuildCheckpoints.java
Patch:
@@ -65,7 +65,7 @@ public static void main(String[] args) throws Exception {
         parser.accepts("help");
         OptionSpec<NetworkEnum> netFlag = parser.accepts("net").withRequiredArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.MAIN);
         parser.accepts("peer").withRequiredArg();
-        OptionSpec<Integer> daysFlag = parser.accepts("days").withRequiredArg().ofType(Integer.class).defaultsTo(30);
+        OptionSpec<Integer> daysFlag = parser.accepts("days").withRequiredArg().ofType(Integer.class).defaultsTo(7);
         OptionSet options = parser.parse(args);
 
         if (options.has("help")) {

File: core/src/main/java/org/bitcoinj/store/SPVBlockStore.java
Patch:
@@ -41,7 +41,7 @@ public class SPVBlockStore implements BlockStore {
     private static final Logger log = LoggerFactory.getLogger(SPVBlockStore.class);
 
     /** The default number of headers that will be stored in the ring buffer. */
-    public static final int DEFAULT_CAPACITY = 5000;
+    public static final int DEFAULT_CAPACITY = 10000;
     public static final String HEADER_MAGIC = "SPVB";
 
     protected volatile MappedByteBuffer buffer;

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -622,6 +622,7 @@ public void testBloomOnP2PK() throws Exception {
         tx2.addInput(tx.getOutput(0));
         TransactionOutPoint outpoint = tx2.getInput(0).getOutpoint();
         assertTrue(p1.lastReceivedFilter.contains(key.getPubKey()));
+        assertTrue(p1.lastReceivedFilter.contains(key.getPubKeyHash()));
         assertFalse(p1.lastReceivedFilter.contains(tx.getTxId().getBytes()));
         inbound(p1, tx);
         // p1 requests dep resolution, p2 is quiet.
@@ -635,6 +636,7 @@ public void testBloomOnP2PK() throws Exception {
         // Now we connect p3 and there is a new bloom filter sent, that DOES match the relevant outpoint.
         InboundMessageQueuer p3 = connectPeer(3);
         assertTrue(p3.lastReceivedFilter.contains(key.getPubKey()));
+        assertTrue(p3.lastReceivedFilter.contains(key.getPubKeyHash()));
         assertTrue(p3.lastReceivedFilter.contains(outpoint.unsafeBitcoinSerialize()));
     }
 

File: core/src/test/java/org/bitcoinj/utils/AppDataDirectoryTest.java
Patch:
@@ -67,8 +67,8 @@ public void throwsIOExceptionIfPathNotFound() {
             AppDataDirectory.get("/");
         }
         if (Utils.isMac()) {
-            // The only illegal character for folder names in OSX is the colon
-            AppDataDirectory.get(":");
+            // NUL character
+            AppDataDirectory.get("\0");
         }
         if (Utils.isLinux()) {
             // NUL character

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -230,7 +230,7 @@ protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest) {
     // that was created after it. Useful when you believe some keys have been compromised.
     private volatile long vKeyRotationTimestamp;
 
-    protected CoinSelector coinSelector = new DefaultCoinSelector();
+    protected CoinSelector coinSelector = DefaultCoinSelector.get();
 
     // The wallet version. This is an int that can be used to track breaking changes in the wallet format.
     // You can also use it to detect wallets that come from the future (ie they contain features you

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -73,7 +73,7 @@ public void depthOrdering() throws Exception {
         Transaction t2 = checkNotNull(sendMoneyToWallet(AbstractBlockChain.NewBlockType.BEST_CHAIN, COIN));
 
         // Check we selected just the oldest one.
-        DefaultCoinSelector selector = new DefaultCoinSelector();
+        DefaultCoinSelector selector = DefaultCoinSelector.get();
         CoinSelection selection = selector.select(COIN, wallet.calculateAllSpendCandidates());
         assertTrue(selection.gathered.contains(t1.getOutputs().get(0)));
         assertEquals(COIN, selection.valueGathered);
@@ -121,7 +121,7 @@ public void identicalInputs() throws Exception {
         );
         t.getConfidence().setConfidenceType(TransactionConfidence.ConfidenceType.BUILDING);
 
-        DefaultCoinSelector selector = new DefaultCoinSelector();
+        DefaultCoinSelector selector = DefaultCoinSelector.get();
         CoinSelection selection = selector.select(COIN.multiply(2), outputs);
 
         assertTrue(selection.gathered.size() == 4);

File: core/src/main/java/org/bitcoinj/core/AbstractBlockChain.java
Patch:
@@ -69,8 +69,8 @@
  * we say it is an orphan chain. Orphan chains can occur when blocks are solved and received during the initial block
  * chain download, or if we connect to a peer that doesn't send us blocks in order.</p>
  *
- * <p>A reorganize occurs when the blocks that make up the best known chain changes. Note that simply adding a
- * new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
+ * <p>A reorganize occurs when the blocks that make up the best known chain change. Note that simply adding a
+ * new block to the top of the best chain isn't a reorganize, but that a reorganize is always triggered by adding
  * a new block that connects to some other (non best head) block. By "best" we mean the chain representing the largest
  * amount of work done.</p>
  *

File: core/src/main/java/org/bitcoinj/wallet/DefaultKeyChainFactory.java
Patch:
@@ -20,15 +20,15 @@
 import org.bitcoinj.crypto.*;
 import org.bitcoinj.script.Script;
 
-import com.google.common.collect.ImmutableList;
+import java.util.List;
 
 /**
  * Default factory for creating keychains while de-serializing.
  */
 public class DefaultKeyChainFactory implements KeyChainFactory {
     @Override
     public DeterministicKeyChain makeKeyChain(DeterministicSeed seed, KeyCrypter crypter, boolean isMarried,
-            Script.ScriptType outputScriptType, ImmutableList<ChildNumber> accountPath) {
+            Script.ScriptType outputScriptType, List<ChildNumber> accountPath) {
         DeterministicKeyChain chain;
         if (isMarried)
             chain = new MarriedKeyChain(seed, crypter, outputScriptType, accountPath);

File: core/src/main/java/org/bitcoinj/wallet/KeyChainFactory.java
Patch:
@@ -17,12 +17,13 @@
 
 package org.bitcoinj.wallet;
 
-import com.google.common.collect.ImmutableList;
 import org.bitcoinj.crypto.ChildNumber;
 import org.bitcoinj.crypto.DeterministicKey;
 import org.bitcoinj.crypto.KeyCrypter;
 import org.bitcoinj.script.Script;
 
+import java.util.List;
+
 /**
  * Factory interface for creation keychains while de-serializing a wallet.
  */
@@ -37,7 +38,7 @@ public interface KeyChainFactory {
      * @param accountPath account path to generate receiving addresses on
      */
     DeterministicKeyChain makeKeyChain(DeterministicSeed seed, KeyCrypter crypter, boolean isMarried,
-            Script.ScriptType outputScriptType, ImmutableList<ChildNumber> accountPath);
+            Script.ScriptType outputScriptType, List<ChildNumber> accountPath);
 
     /**
      * Make a watching keychain.

File: core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java
Patch:
@@ -133,7 +133,7 @@ protected MarriedKeyChain(DeterministicKey accountKey, Script.ScriptType outputS
      * This constructor is not stable across releases! If you need a stable API, use {@link #builder()} to use a
      * {@link Builder}.
      */
-    protected MarriedKeyChain(DeterministicSeed seed, KeyCrypter crypter, Script.ScriptType outputScriptType, ImmutableList<ChildNumber> accountPath) {
+    protected MarriedKeyChain(DeterministicSeed seed, KeyCrypter crypter, Script.ScriptType outputScriptType, List<ChildNumber> accountPath) {
         super(seed, crypter, outputScriptType, accountPath);
     }
 

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -333,7 +333,7 @@ public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed)
      * @return an instance of a wallet from a deterministic seed.
      */
     public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed, Script.ScriptType outputScriptType,
-            ImmutableList<ChildNumber> accountPath) {
+            List<ChildNumber> accountPath) {
         DeterministicKeyChain chain = DeterministicKeyChain.builder().seed(seed).outputScriptType(outputScriptType)
                 .accountPath(accountPath).build();
         return new Wallet(params, KeyChainGroup.builder(params).addChain(chain).build());
@@ -344,10 +344,10 @@ public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed,
      * @param seed deterministic seed
      * @param accountPath account path
      * @return an instance of a wallet from a deterministic seed.
-     * @deprecated Use {@link #fromSeed(NetworkParameters, DeterministicSeed, ScriptType, ImmutableList)}
+     * @deprecated Use {@link #fromSeed(NetworkParameters, DeterministicSeed, ScriptType, List)}
      */
     @Deprecated
-    public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed, ImmutableList<ChildNumber> accountPath) {
+    public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed, List<ChildNumber> accountPath) {
         return fromSeed(params, seed, Script.ScriptType.P2PKH, accountPath);
     }
 

File: core/src/test/java/org/bitcoinj/testing/KeyChainTransactionSigner.java
Patch:
@@ -44,7 +44,7 @@ public KeyChainTransactionSigner(DeterministicKeyChain keyChain) {
 
     @Override
     protected SignatureAndKey getSignature(Sha256Hash sighash, List<ChildNumber> derivationPath) {
-        ImmutableList<ChildNumber> keyPath = ImmutableList.copyOf(derivationPath);
+        List<ChildNumber> keyPath = ImmutableList.copyOf(derivationPath);
         DeterministicKey key = keyChain.getKeyByPath(keyPath, true);
         return new SignatureAndKey(key.sign(sighash), key.dropPrivateBytes().dropParent());
     }

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -3033,7 +3033,7 @@ private Wallet roundTrip(Wallet wallet) throws UnreadableWalletException {
         int numIssuedExternal = activeKeyChain.getIssuedExternalKeys();
         DeterministicKey rootKey = wallet.getActiveKeyChain().getRootKey();
         DeterministicKey watchingKey = activeKeyChain.getWatchingKey();
-        ImmutableList<ChildNumber> accountPath = activeKeyChain.getAccountPath();
+        HDPath accountPath = activeKeyChain.getAccountPath();
         Script.ScriptType outputScriptType = activeKeyChain.getOutputScriptType();
 
         Protos.Wallet protos = new WalletProtobufSerializer().walletToProto(wallet);

File: core/src/main/java/org/bitcoinj/core/ECKey.java
Patch:
@@ -991,7 +991,7 @@ public static ECKey recoverFromSignature(int recId, ECDSASignature sig, Sha256Ha
         //   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine
         //        specified in Section 2.3.7, where mlen = (log2 p)/8 or mlen = m/8.
         //   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
-        //        conversion routine specified in Section 2.3.4. If this conversion routine outputs invalid, then
+        //        conversion routine specified in Section 2.3.4. If this conversion routine outputs "invalid", then
         //        do another iteration of Step 1.
         //
         // More concisely, what these points mean is to use X as a compressed public key.

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -1650,8 +1650,8 @@ public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, S
         // TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
         if (verifyFlags.contains(VerifyFlag.P2SH) && ScriptPattern.isP2SH(scriptPubKey)) {
             for (ScriptChunk chunk : chunks)
-                if (chunk.isOpCode() && chunk.opcode > OP_16)
-                    throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops");
+                if (!chunk.isPushData())
+                    throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained the script op " + chunk);
             
             byte[] scriptPubKeyBytes = p2shStack.pollLast();
             Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes);

File: core/src/main/java/org/bitcoinj/script/ScriptChunk.java
Patch:
@@ -42,7 +42,7 @@ public class ScriptChunk {
      */
     @Nullable
     public final byte[] data;
-    private int startLocationInProgram;
+    private final int startLocationInProgram;
 
     public ScriptChunk(int opcode, byte[] data) {
         this(opcode, data, -1);

File: core/src/main/java/org/bitcoinj/core/SegwitAddress.java
Patch:
@@ -129,7 +129,7 @@ public byte[] getHash() {
 
     /**
      * Get the type of output script that will be used for sending to the address. This is either
-     * {@link ScriptType#P2WPKH} or {@link ScriptType#P2WSH}.
+     * {@link Script.ScriptType#P2WPKH} or {@link Script.ScriptType#P2WSH}.
      * 
      * @return type of output script
      */

File: core/src/main/java/org/bitcoinj/core/SegwitAddress.java
Patch:
@@ -71,7 +71,7 @@ private SegwitAddress(NetworkParameters params, int witnessVersion, byte[] witne
     private static byte[] encode(int witnessVersion, byte[] witnessProgram) throws AddressFormatException {
         byte[] convertedProgram = convertBits(witnessProgram, 0, witnessProgram.length, 8, 5, true);
         byte[] bytes = new byte[1 + convertedProgram.length];
-        bytes[0] = (byte) (Script.encodeToOpN(witnessVersion) & 0xff);
+        bytes[0] = (byte) (witnessVersion & 0xff);
         System.arraycopy(convertedProgram, 0, bytes, 1, convertedProgram.length);
         return bytes;
     }

File: core/src/test/java/org/bitcoinj/crypto/ChildKeyDerivationTest.java
Patch:
@@ -54,8 +54,9 @@ public void testChildKeyDerivation() throws Exception {
                         "cc9c753a63b8678ce647b7457397acef",
                 "7012bc411228495f25d666d55fdce3f10a93908b5f9b9b7baa6e7573603a7bda"
         };
+        assertEquals(0, ckdTestVectors.length % 3);
 
-        for(int i = 0; i < 1; i++) {
+        for(int i = 0; i < ckdTestVectors.length / 3; i++) {
             byte[] priv  = HEX.decode(ckdTestVectors[3 * i]);
             byte[] pub   = HEX.decode(ckdTestVectors[3 * i + 1]);
             byte[] chain = HEX.decode(ckdTestVectors[3 * i + 2]); // chain code

File: core/src/main/java/org/bitcoinj/params/AbstractBitcoinNetParams.java
Patch:
@@ -28,6 +28,7 @@
 import org.bitcoinj.core.Sha256Hash;
 import org.bitcoinj.core.StoredBlock;
 import org.bitcoinj.core.Transaction;
+import org.bitcoinj.core.TransactionOutput;
 import org.bitcoinj.core.Utils;
 import org.bitcoinj.utils.MonetaryFormat;
 import org.bitcoinj.core.VerificationException;
@@ -148,7 +149,9 @@ public Coin getMaxMoney() {
         return MAX_MONEY;
     }
 
+    /** @deprecated use {@link TransactionOutput#getMinNonDustValue()} */
     @Override
+    @Deprecated
     public Coin getMinNonDustOutput() {
         return Transaction.MIN_NONDUST_OUTPUT;
     }

File: core/src/main/java/org/bitcoinj/wallet/SendRequest.java
Patch:
@@ -165,8 +165,9 @@ private SendRequest() {}
     /**
      * <p>Creates a new SendRequest to the given address for the given value.</p>
      *
-     * <p>Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction will
-     * likely be rejected by the network in this case.</p>
+     * <p>Be careful to check the output's value is reasonable using
+     * {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
+     * rejected by the network.</p>
      */
     public static SendRequest to(Address destination, Coin value) {
         SendRequest req = new SendRequest();

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -3912,7 +3912,7 @@ public enum MissingSigsMode {
      * prevent this, but that should only occur once the transaction has been accepted by the network. This implies
      * you cannot have more than one outstanding sending tx at once.</p>
      *
-     * <p>You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
+     * <p>You MUST ensure that the value is not smaller than {@link TransactionOutput#getMinNonDustValue()} or the transaction
      * will almost certainly be rejected by the network as dust.</p>
      *
      * @param address The Bitcoin address to send the money to.
@@ -3974,7 +3974,7 @@ public Transaction sendCoinsOffline(SendRequest request)
      * successfully broadcast. This means that even if the network hasn't heard about your transaction you won't be
      * able to spend those same coins again.</p>
      *
-     * <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
+     * <p>You MUST ensure that value is not smaller than {@link TransactionOutput#getMinNonDustValue()} or the transaction will
      * almost certainly be rejected by the network as dust.</p>
      *
      * @param broadcaster a {@link TransactionBroadcaster} to use to send the transactions out.

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -131,7 +131,8 @@ public void nonStandardDust() {
 
         Transaction edgeCaseTx = new Transaction(MAINNET);
         edgeCaseTx.addInput(MAINNET.getGenesisBlock().getTransactions().get(0).getOutput(0));
-        edgeCaseTx.addOutput(DefaultRiskAnalysis.MIN_ANALYSIS_NONDUST_OUTPUT, key1); // Dust threshold
+        Coin dustThreshold = new TransactionOutput(MAINNET, null, Coin.COIN, key1).getMinNonDustValue();
+        edgeCaseTx.addOutput(dustThreshold, key1);
         assertEquals(RiskAnalysis.Result.OK, DefaultRiskAnalysis.FACTORY.create(wallet, edgeCaseTx, NO_DEPS).analyze());
     }
 

File: core/src/main/java/org/bitcoinj/core/TransactionConfidence.java
Patch:
@@ -48,7 +48,7 @@
  * <li>Receiving it from multiple peers on the network. If your network connection is not being intercepted,
  *     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
  *     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
- * <li>Seeing the transaction appear appear in a block on the best chain. Your confidence increases as the transaction
+ * <li>Seeing the transaction appear in a block on the best chain. Your confidence increases as the transaction
  *     becomes further buried under work. Work can be measured either in blocks (roughly, units of time), or
  *     amount of work done.</li>
  * </ul>

File: core/src/main/java/org/bitcoinj/core/AlertMessage.java
Patch:
@@ -31,7 +31,7 @@
  * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
  * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
  * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
- * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
+ * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.</p>
  *     
  * <p>Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.</p>
  * 

File: core/src/main/java/org/bitcoinj/store/LevelDBFullPrunedBlockStore.java
Patch:
@@ -56,7 +56,7 @@
 /**
  * <p>
  * An implementation of a Fully Pruned Block Store using a leveldb implementation as the backing data store.
- * <p>
+ * </p>
  * 
  * <p>
  * Includes number of caches to optimise the initial blockchain download.

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -46,7 +46,7 @@
 import static wallettemplate.utils.GuiUtils.*;
 
 public class Main extends Application {
-    public static NetworkParameters params = MainNetParams.get();
+    public static NetworkParameters params = TestNet3Params.get();
     public static final Script.ScriptType PREFERRED_OUTPUT_SCRIPT_TYPE = Script.ScriptType.P2WPKH;
     public static final String APP_NAME = "WalletTemplate";
     private static final String WALLET_FILE_NAME = APP_NAME.replaceAll("[^a-zA-Z0-9.-]", "_") + "-"

File: core/src/test/java/org/bitcoinj/core/LegacyAddressTest.java
Patch:
@@ -68,7 +68,7 @@ public void stringification() throws Exception {
 
         LegacyAddress b = LegacyAddress.fromPubKeyHash(MAINNET, HEX.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));
         assertEquals("17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL", b.toString());
-        assertEquals(ScriptType.P2PKH, a.getOutputScriptType());
+        assertEquals(ScriptType.P2PKH, b.getOutputScriptType());
     }
 
     @Test

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -1122,7 +1122,7 @@ public List<Address> getWatchedAddresses() {
     /** @deprecated Use {@link #findKeyFromPubKeyHash(byte[], ScriptType)} */
     @Deprecated
     public ECKey findKeyFromPubHash(byte[] pubKeyHash) {
-        return findKeyFromPubKeyHash(pubKeyHash, Script.ScriptType.P2PK);
+        return findKeyFromPubKeyHash(pubKeyHash, Script.ScriptType.P2PKH);
     }
 
     /**

File: core/src/test/java/org/bitcoinj/wallet/KeyChainGroupTest.java
Patch:
@@ -707,10 +707,11 @@ public void segwitKeyChainGroup() throws Exception {
     }
 
     @Test
-    public void onlyBasicKeyEncryption() {
+    public void onlyBasicKeyEncryptionAndDecryption() {
         group = KeyChainGroup.createBasic(MAINNET);
         final ECKey key = ECKey.fromPrivate(BigInteger.TEN);
         group.importKeys(key);
         group.encrypt(KEY_CRYPTER, AES_KEY);
+        group.decrypt(AES_KEY);
     }
 }

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -359,7 +359,7 @@ private static void writeConfidence(Protos.Transaction.Builder txBuilder,
                                         TransactionConfidence confidence,
                                         Protos.TransactionConfidence.Builder confidenceBuilder) {
         synchronized (confidence) {
-            confidenceBuilder.setType(Protos.TransactionConfidence.Type.valueOf(confidence.getConfidenceType().getValue()));
+            confidenceBuilder.setType(Protos.TransactionConfidence.Type.forNumber(confidence.getConfidenceType().getValue()));
             if (confidence.getConfidenceType() == ConfidenceType.BUILDING) {
                 confidenceBuilder.setAppearedAtHeight(confidence.getAppearedAtChainHeight());
                 confidenceBuilder.setDepth(confidence.getDepthInBlocks());

File: core/src/main/java/org/bitcoinj/utils/MonetaryFormat.java
Patch:
@@ -489,7 +489,7 @@ public boolean equals(final Object o) {
             return false;
         if (!Objects.equals(this.roundingMode, other.roundingMode))
             return false;
-        if (!Objects.equals(this.codes, other.codes))
+        if (!Arrays.equals(this.codes, other.codes))
             return false;
         if (!Objects.equals(this.codeSeparator, other.codeSeparator))
             return false;
@@ -501,6 +501,6 @@ public boolean equals(final Object o) {
     @Override
     public int hashCode() {
         return Objects.hash(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift,
-                roundingMode, codes, codeSeparator, codePrefixed);
+                roundingMode, Arrays.hashCode(codes), codeSeparator, codePrefixed);
     }
 }

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -107,7 +107,7 @@ public abstract class NetworkParameters {
     protected int[] addrSeeds;
     protected HttpDiscovery.Details[] httpSeeds = {};
     protected Map<Integer, Sha256Hash> checkpoints = new HashMap<>();
-    protected transient MessageSerializer defaultSerializer = null;
+    protected volatile transient MessageSerializer defaultSerializer = null;
 
     protected NetworkParameters() {
         alertSigningKey = SATOSHI_KEY;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4880,6 +4880,8 @@ private boolean isTxOutputBloomFilterable(TransactionOutput out) {
     public boolean checkForFilterExhaustion(FilteredBlock block) {
         keyChainGroupLock.lock();
         try {
+            if (!keyChainGroup.isSupportsDeterministicChains())
+                return false;
             int epoch = keyChainGroup.getCombinedKeyLookaheadEpochs();
             for (Transaction tx : block.getAssociatedTransactions().values()) {
                 markKeysAsUsed(tx);

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -1281,8 +1281,8 @@ public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
     }
 
     /**
-     * Returns the number of currently connected peers. To be informed when this count changes, register a 
-     * {@link PeerConnectionEventListener} and use the onPeerConnected/onPeerDisconnected methods.
+     * Returns the number of currently connected peers. To be informed when this count changes, use
+     * {@link PeerConnectedEventListener#onPeerConnected} and {@link PeerDisconnectedEventListener#onPeerDisconnected}.
      */
     public int numConnectedPeers() {
         return peers.size();

File: core/src/main/java/org/bitcoinj/core/TransactionConfidence.java
Patch:
@@ -223,9 +223,9 @@ public void addEventListener(Executor executor, Listener listener) {
      *
      * <p>Note that this is NOT called when every block arrives. Instead it is called when the transaction
      * transitions between confidence states, ie, from not being seen in the chain to being seen (not necessarily in
-     * the best chain). If you want to know when the transaction gets buried under another block, implement a
-     * {@link BlockChainListener}, attach it to a {@link BlockChain} and then use the getters on the
-     * confidence object to determine the new depth.</p>
+     * the best chain). If you want to know when the transaction gets buried under another block, implement
+     * {@link org.bitcoinj.core.listeners.NewBestBlockListener} and related listeners, attach them to a
+     * {@link BlockChain} and then use the getters on the confidence object to determine the new depth.</p>
      */
     public void addEventListener(Listener listener) {
         addEventListener(Threading.USER_THREAD, listener);

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -1822,9 +1822,10 @@ private void calculate() {
                     warmupSeconds = 15;
                 }
 
-                boolean behindPeers = chain != null && chain.getBestChainHeight() < getMostCommonChainHeight();
-                if (!behindPeers)
+                int mostCommonChainHeight = getMostCommonChainHeight();
+                if (chain != null && mostCommonChainHeight > 0 && chain.getBestChainHeight() >= mostCommonChainHeight)
                     syncDone = true;
+
                 if (!syncDone) {
                     if (warmupSeconds < 0) {
                         // Calculate the moving average.

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -450,7 +450,7 @@ private Wallet loadWallet(boolean shouldReplayWallet) throws Exception {
     protected Wallet createWallet() {
         KeyChainGroup.Builder kcg = KeyChainGroup.builder(params, structure);
         if (restoreFromSeed != null)
-            kcg.addChain(DeterministicKeyChain.builder().seed(restoreFromSeed).outputScriptType(preferredOutputScriptType).build());
+            kcg.fromSeed(restoreFromSeed, preferredOutputScriptType).build();
         else if (restoreFromKey != null)
             kcg.addChain(DeterministicKeyChain.builder().spend(restoreFromKey).outputScriptType(preferredOutputScriptType).build());
         else

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -463,8 +463,7 @@ else if (restoreFromKey != null)
     }
 
     private void maybeMoveOldWalletOutOfTheWay() {
-        if (restoreFromSeed == null) return;
-        if (restoreFromKey == null) return;
+        if (restoreFromSeed == null && restoreFromKey == null) return;
         if (!vWalletFile.exists()) return;
         int counter = 1;
         File newName;

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -272,6 +272,8 @@ public void addAndActivateHDChain(DeterministicKeyChain chain) {
         if (lookaheadThreshold >= 0)
             chain.setLookaheadThreshold(lookaheadThreshold);
         chains.add(chain);
+        currentKeys.clear();
+        currentAddresses.clear();
     }
 
     /**

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -1172,7 +1172,7 @@ public boolean isAddressMine(Address address) {
             throw new IllegalArgumentException(address.toString());
     }
 
-    /** @deprecated Use {@link #isPubKeyHashMine(byte[], ScriptType))} */
+    /** @deprecated Use {@link #isPubKeyHashMine(byte[], ScriptType)} */
     @Deprecated
     public boolean isPubKeyHashMine(byte[] pubKeyHash) {
         return isPubKeyHashMine(pubKeyHash, Script.ScriptType.P2PKH);

File: core/src/test/java/org/bitcoinj/store/SPVBlockStoreTest.java
Patch:
@@ -73,6 +73,7 @@ public void basics() throws Exception {
         // Check the chain head was stored correctly also.
         StoredBlock chainHead = store.getChainHead();
         assertEquals(b1, chainHead);
+        store.close();
     }
 
     @Test(expected = BlockStoreException.class)

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -411,7 +411,7 @@ public String toString() {
     }
 
     public String toStringServices(long services) {
-        List<String> a = new LinkedList<String>();
+        List<String> a = new LinkedList<>();
         if ((services & VersionMessage.NODE_NETWORK) == VersionMessage.NODE_NETWORK) {
             a.add("NETWORK");
             services &= ~VersionMessage.NODE_NETWORK;

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -1939,7 +1939,7 @@ public void onPeerConnected(Peer peer, int peerCount) {
     public List<Peer> findPeersOfAtLeastVersion(long protocolVersion) {
         lock.lock();
         try {
-            ArrayList<Peer> results = new ArrayList<Peer>(peers.size());
+            ArrayList<Peer> results = new ArrayList<>(peers.size());
             for (Peer peer : peers)
                 if (peer.getPeerVersionMessage().clientVersion >= protocolVersion)
                     results.add(peer);
@@ -1986,7 +1986,7 @@ public void onPeerConnected(Peer peer, int peerCount) {
     public List<Peer> findPeersWithServiceMask(int mask) {
         lock.lock();
         try {
-            ArrayList<Peer> results = new ArrayList<Peer>(peers.size());
+            ArrayList<Peer> results = new ArrayList<>(peers.size());
             for (Peer peer : peers)
                 if ((peer.getPeerVersionMessage().localServices & mask) == mask)
                     results.add(peer);

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -1213,7 +1213,7 @@ public Sha256Hash hashForSignature(int inputIndex, byte[] connectedScript, byte
             if ((sigHashType & SigHash.ANYONECANPAY.value) == SigHash.ANYONECANPAY.value) {
                 // SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                 // of other inputs. For example, this is useful for building assurance contracts.
-                tx.inputs = new ArrayList<TransactionInput>();
+                tx.inputs = new ArrayList<>();
                 tx.inputs.add(input);
             }
 

File: core/src/main/java/org/bitcoinj/core/Utils.java
Patch:
@@ -611,7 +611,7 @@ public static boolean isMac() {
     }
 
     public static String toString(List<byte[]> stack) {
-        List<String> parts = new ArrayList<String>(stack.size());
+        List<String> parts = new ArrayList<>(stack.size());
         for (byte[] push : stack)
             parts.add('[' + HEX.encode(push) + ']');
         return SPACE_JOINER.join(parts);

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -1620,7 +1620,7 @@ public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, S
         if (stack.size() == 0)
             throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "Stack empty at end of script execution.");
 
-        List<byte[]> stackCopy = new LinkedList<byte[]>(stack);
+        List<byte[]> stackCopy = new LinkedList<>(stack);
         if (!castToBool(stack.pollLast()))
             throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE,
                     "Script resulted in a non-true stack: " + Utils.toString(stackCopy));
@@ -1651,7 +1651,7 @@ public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, S
             if (p2shStack.size() == 0)
                 throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH stack empty at end of script execution.");
             
-            List<byte[]> p2shStackCopy = new LinkedList<byte[]>(p2shStack);
+            List<byte[]> p2shStackCopy = new LinkedList<>(p2shStack);
             if (!castToBool(p2shStack.pollLast()))
                 throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE,
                         "P2SH script execution resulted in a non-true stack: " + Utils.toString(p2shStackCopy));

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -75,7 +75,7 @@ public class KeyChainGroup implements KeyBag {
     public static class Builder {
         private final NetworkParameters params;
         private final KeyChainGroupStructure structure;
-        private final List<DeterministicKeyChain> chains = new LinkedList<DeterministicKeyChain>();
+        private final List<DeterministicKeyChain> chains = new LinkedList<>();
         private int lookaheadSize = -1, lookaheadThreshold = -1;
 
         private Builder(NetworkParameters params, KeyChainGroupStructure structure) {
@@ -219,7 +219,7 @@ else if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))
                 this.lookaheadSize = 5; // Cut down excess computation for unit tests.
             if (lookaheadThreshold > -1)
                 this.lookaheadThreshold = lookaheadThreshold;
-            this.chains = new LinkedList<DeterministicKeyChain>(chains);
+            this.chains = new LinkedList<>(chains);
             for (DeterministicKeyChain chain : this.chains) {
                 if (this.lookaheadSize > -1)
                     chain.setLookaheadSize(this.lookaheadSize);

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4979,7 +4979,7 @@ private FeeCalculation calculateFee(SendRequest req, Coin value, List<Transactio
                 valueNeeded = valueNeeded.add(fee);
             }
             if (req.recipientsPayFees) {
-                result.updatedOutputValues = new ArrayList<Coin>();
+                result.updatedOutputValues = new ArrayList<>();
             }
             for (int i = 0; i < req.tx.getOutputs().size(); i++) {
                 TransactionOutput output = new TransactionOutput(params, tx,

File: core/src/test/java/org/bitcoinj/protocols/channels/PaymentChannelServerTest.java
Patch:
@@ -49,7 +49,7 @@ public void setUp() {
         broadcaster = createMock(TransactionBroadcaster.class);
         wallet = createMock(Wallet.class);
         connection = createMock(PaymentChannelServer.ServerConnection.class);
-        serverVersionCapture = new Capture<TwoWayChannelMessage>();
+        serverVersionCapture = new Capture<>();
         connection.sendToClient(capture(serverVersionCapture));
         Utils.setMockClock();
     }

File: core/src/main/java/org/bitcoinj/core/BloomFilter.java
Patch:
@@ -342,7 +342,7 @@ public synchronized boolean applyAndUpdate(Transaction tx) {
                 if (!chunk.isPushData())
                     continue;
                 if (contains(chunk.data)) {
-                    boolean isSendingToPubKeys = ScriptPattern.isPayToPubKey(script) || ScriptPattern.isSentToMultisig(script);
+                    boolean isSendingToPubKeys = ScriptPattern.isP2PK(script) || ScriptPattern.isSentToMultisig(script);
                     if (flag == BloomUpdate.UPDATE_ALL || (flag == BloomUpdate.UPDATE_P2PUBKEY_ONLY && isSendingToPubKeys))
                         insert(output.getOutPointFor());
                     found = true;

File: core/src/main/java/org/bitcoinj/core/FullPrunedBlockChain.java
Patch:
@@ -272,7 +272,7 @@ protected TransactionOutputChanges connectTransactions(int height, Block block)
                         // TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                         valueIn = valueIn.add(prevOut.getValue());
                         if (verifyFlags.contains(VerifyFlag.P2SH)) {
-                            if (ScriptPattern.isPayToScriptHash(prevOut.getScript()))
+                            if (ScriptPattern.isP2SH(prevOut.getScript()))
                                 sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());
                             if (sigOps > Block.MAX_BLOCK_SIGOPS)
                                 throw new VerificationException("Too many P2SH SigOps in block");
@@ -400,7 +400,7 @@ protected synchronized TransactionOutputChanges connectTransactions(StoredBlock
                                 throw new VerificationException("Tried to spend coinbase at depth " + (newBlock.getHeight() - prevOut.getHeight()));
                             valueIn = valueIn.add(prevOut.getValue());
                             if (verifyFlags.contains(VerifyFlag.P2SH)) {
-                                if (ScriptPattern.isPayToScriptHash(prevOut.getScript()))
+                                if (ScriptPattern.isP2SH(prevOut.getScript()))
                                     sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());
                                 if (sigOps > Block.MAX_BLOCK_SIGOPS)
                                     throw new VerificationException("Too many P2SH SigOps in block");

File: core/src/main/java/org/bitcoinj/core/LegacyAddress.java
Patch:
@@ -120,12 +120,12 @@ public static LegacyAddress fromP2SHHash(NetworkParameters params, byte[] hash16
 
     /**
      * @deprecated use {@link #fromScriptHash(NetworkParameters, byte[])} in combination with
-     *             {@link ScriptPattern#extractHashFromPayToScriptHash(Script)}
+     *             {@link ScriptPattern#extractHashFromP2SH(Script)}
      */
     @Deprecated
     public static LegacyAddress fromP2SHScript(NetworkParameters params, Script scriptPubKey) {
-        checkArgument(ScriptPattern.isPayToScriptHash(scriptPubKey), "Not a P2SH script");
-        return fromScriptHash(params, ScriptPattern.extractHashFromPayToScriptHash(scriptPubKey));
+        checkArgument(ScriptPattern.isP2SH(scriptPubKey), "Not a P2SH script");
+        return fromScriptHash(params, ScriptPattern.extractHashFromP2SH(scriptPubKey));
     }
 
     /**

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -199,7 +199,7 @@ public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coi
             // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't
             // and shouldn't, we should just recalculate and cache the new filter for next time.
             for (TransactionOutput output : tx.getOutputs()) {
-                if (ScriptPattern.isPayToPubKey(output.getScriptPubKey()) && output.isMine(wallet)) {
+                if (ScriptPattern.isP2PK(output.getScriptPubKey()) && output.isMine(wallet)) {
                     if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)
                         recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);
                     else

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -924,17 +924,17 @@ public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scrip
         TransactionInput input = new TransactionInput(params, this, new byte[] {}, prevOut);
         addInput(input);
         int inputIndex = inputs.size() - 1;
-        if (ScriptPattern.isPayToPubKey(scriptPubKey)) {
+        if (ScriptPattern.isP2PK(scriptPubKey)) {
             TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,
                     anyoneCanPay);
             input.setScriptSig(ScriptBuilder.createInputScript(signature));
             input.setWitness(null);
-        } else if (ScriptPattern.isPayToPubKeyHash(scriptPubKey)) {
+        } else if (ScriptPattern.isP2PKH(scriptPubKey)) {
             TransactionSignature signature = calculateSignature(inputIndex, sigKey, scriptPubKey, sigHash,
                     anyoneCanPay);
             input.setScriptSig(ScriptBuilder.createInputScript(signature, sigKey));
             input.setWitness(null);
-        } else if (ScriptPattern.isPayToWitnessPubKeyHash(scriptPubKey)) {
+        } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {
             Script scriptCode = new ScriptBuilder()
                     .data(ScriptBuilder.createOutputScript(LegacyAddress.fromKey(params, sigKey)).getProgram()).build();
             TransactionSignature signature = calculateWitnessSignature(inputIndex, sigKey, scriptCode, input.getValue(),

File: core/src/main/java/org/bitcoinj/signers/CustomTransactionSigner.java
Patch:
@@ -60,7 +60,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                 continue;
             }
             Script scriptPubKey = txOut.getScriptPubKey();
-            if (!ScriptPattern.isPayToScriptHash(scriptPubKey)) {
+            if (!ScriptPattern.isP2SH(scriptPubKey)) {
                 log.warn("CustomTransactionSigner works only with P2SH transactions");
                 return false;
             }

File: core/src/main/java/org/bitcoinj/signers/LocalTransactionSigner.java
Patch:
@@ -113,8 +113,8 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
             // a CHECKMULTISIG program for P2SH inputs
             byte[] script = redeemData.redeemScript.getProgram();
             try {
-                if (ScriptPattern.isPayToPubKey(scriptPubKey) || ScriptPattern.isPayToPubKeyHash(scriptPubKey)
-                        || ScriptPattern.isPayToScriptHash(scriptPubKey)) {
+                if (ScriptPattern.isP2PK(scriptPubKey) || ScriptPattern.isP2PKH(scriptPubKey)
+                        || ScriptPattern.isP2SH(scriptPubKey)) {
                     TransactionSignature signature = tx.calculateSignature(i, key, script, Transaction.SigHash.ALL,
                             false);
 
@@ -130,7 +130,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                             sigIndex);
                     txIn.setScriptSig(inputScript);
                     txIn.setWitness(null);
-                } else if (ScriptPattern.isPayToWitnessPubKeyHash(scriptPubKey)) {
+                } else if (ScriptPattern.isP2WPKH(scriptPubKey)) {
                     Script scriptCode = new ScriptBuilder().data(
                             ScriptBuilder.createOutputScript(LegacyAddress.fromKey(tx.getParams(), key)).getProgram())
                             .build();

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -376,9 +376,9 @@ public Address freshAddress(KeyChain.KeyPurpose purpose) {
         Script.ScriptType outputScriptType = chain.getOutputScriptType();
         if (chain.isMarried()) {
             Script outputScript = chain.freshOutputScript(purpose);
-            checkState(ScriptPattern.isPayToScriptHash(outputScript)); // Only handle P2SH for now
+            checkState(ScriptPattern.isP2SH(outputScript)); // Only handle P2SH for now
             Address freshAddress = LegacyAddress.fromScriptHash(params,
-                    ScriptPattern.extractHashFromPayToScriptHash(outputScript));
+                    ScriptPattern.extractHashFromP2SH(outputScript));
             maybeLookaheadScripts();
             currentAddresses.put(purpose, freshAddress);
             return freshAddress;

File: core/src/main/java/org/bitcoinj/wallet/RedeemData.java
Patch:
@@ -57,8 +57,8 @@ public static RedeemData of(List<ECKey> keys, Script redeemScript) {
      * to spend such inputs.
      */
     public static RedeemData of(ECKey key, Script redeemScript) {
-        checkArgument(ScriptPattern.isPayToPubKeyHash(redeemScript)
-                || ScriptPattern.isPayToWitnessPubKeyHash(redeemScript) || ScriptPattern.isPayToPubKey(redeemScript));
+        checkArgument(ScriptPattern.isP2PKH(redeemScript)
+                || ScriptPattern.isP2WPKH(redeemScript) || ScriptPattern.isP2PK(redeemScript));
         return key != null ? new RedeemData(Collections.singletonList(key), redeemScript) : null;
     }
 

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -1819,7 +1819,7 @@ private void addOnlyInputToTransaction(Transaction t, TransactionOutPointWithVal
             input.setScriptSig(new ScriptBuilder().op(OP_1).build());
         } else {
             // Sign input
-            checkState(ScriptPattern.isPayToPubKey(prevOut.scriptPubKey));
+            checkState(ScriptPattern.isP2PK(prevOut.scriptPubKey));
             Sha256Hash hash = t.hashForSignature(0, prevOut.scriptPubKey, SigHash.ALL, false);
             input.setScriptSig(ScriptBuilder.createInputScript(
                             new TransactionSignature(coinbaseOutKey.sign(hash), SigHash.ALL, false))

File: core/src/test/java/org/bitcoinj/core/LegacyAddressTest.java
Patch:
@@ -172,7 +172,7 @@ public void p2shAddress() throws Exception {
         LegacyAddress b = LegacyAddress.fromScriptHash(TESTNET, HEX.decode("18a0e827269b5211eb51a4af1b2fa69333efa722"));
         assertEquals("2MuVSxtfivPKJe93EC1Tb9UhJtGhsoWEHCe", b.toString());
         LegacyAddress c = LegacyAddress.fromScriptHash(MAINNET,
-                ScriptPattern.extractHashFromPayToScriptHash(ScriptBuilder.createP2SHOutputScript(hex)));
+                ScriptPattern.extractHashFromP2SH(ScriptBuilder.createP2SHOutputScript(hex)));
         assertEquals("35b9vsyH1KoFT5a5KtrKusaCcPLkiSo1tU", c.toString());
     }
 
@@ -189,7 +189,7 @@ public void p2shAddressCreationFromKeys() throws Exception {
         List<ECKey> keys = Arrays.asList(key1, key2, key3);
         Script p2shScript = ScriptBuilder.createP2SHOutputScript(2, keys);
         LegacyAddress address = LegacyAddress.fromScriptHash(MAINNET,
-                ScriptPattern.extractHashFromPayToScriptHash(p2shScript));
+                ScriptPattern.extractHashFromP2SH(p2shScript));
         assertEquals("3N25saC4dT24RphDAwLtD8LUN4E2gZPJke", address.toString());
     }
 

File: core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java
Patch:
@@ -108,7 +108,7 @@ public void validAddresses() {
             if (valid.expectedWitnessVersion == 0) {
                 Script expectedScriptPubKey = new Script(Utils.HEX.decode(valid.expectedScriptPubKey));
                 assertEquals(address, SegwitAddress.fromHash(valid.expectedParams,
-                        ScriptPattern.extractHashFromPayToWitnessHash(expectedScriptPubKey)));
+                        ScriptPattern.extractHashFromP2WH(expectedScriptPubKey)));
             }
             assertEquals(valid.expectedWitnessVersion, address.getWitnessVersion());
         }

File: core/src/test/java/org/bitcoinj/core/TransactionOutputTest.java
Patch:
@@ -80,8 +80,8 @@ public void getAddressTests() throws Exception {
         Transaction tx = new Transaction(MAINNET);
         tx.addOutput(Coin.CENT, ScriptBuilder.createOpReturnScript("hello world!".getBytes()));
         assertTrue(ScriptPattern.isOpReturn(tx.getOutput(0).getScriptPubKey()));
-        assertFalse(ScriptPattern.isPayToPubKey(tx.getOutput(0).getScriptPubKey()));
-        assertFalse(ScriptPattern.isPayToPubKeyHash(tx.getOutput(0).getScriptPubKey()));
+        assertFalse(ScriptPattern.isP2PK(tx.getOutput(0).getScriptPubKey()));
+        assertFalse(ScriptPattern.isP2PKH(tx.getOutput(0).getScriptPubKey()));
     }
 
     @Test

File: core/src/test/java/org/bitcoinj/protocols/channels/ChannelConnectionTest.java
Patch:
@@ -543,7 +543,7 @@ public void testChannelResume() throws Exception {
         if (isMultiSigContract()) {
             assertTrue(ScriptPattern.isSentToMultisig(broadcasts.take().getOutput(0).getScriptPubKey()));
         } else {
-            assertTrue(ScriptPattern.isPayToScriptHash(broadcasts.take().getOutput(0).getScriptPubKey()));
+            assertTrue(ScriptPattern.isP2SH(broadcasts.take().getOutput(0).getScriptPubKey()));
         }
         broadcastTxPause.release();
         assertEquals(TransactionConfidence.Source.SELF, broadcasts.take().getConfidence().getSource());

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -2299,7 +2299,7 @@ public void sendRequestP2PKTest() {
         ECKey key = new ECKey();
         SendRequest req = SendRequest.to(UNITTEST, key, SATOSHI.multiply(12));
         assertArrayEquals(key.getPubKey(),
-                ScriptPattern.extractKeyFromPayToPubKey(req.tx.getOutputs().get(0).getScriptPubKey()));
+                ScriptPattern.extractKeyFromP2PK(req.tx.getOutputs().get(0).getScriptPubKey()));
     }
 
     @Test

File: core/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -89,7 +89,9 @@ public void setUp(BlockStore blockStore) throws Exception {
         this.blockStore = blockStore;
         // Allow subclasses to override the wallet object with their own.
         if (wallet == null) {
-            wallet = new Wallet(UNITTEST, KeyChainGroup.builder(UNITTEST).build());
+            // Reduce the number of keys we need to work with to speed up these tests.
+            KeyChainGroup kcg = KeyChainGroup.builder(UNITTEST).lookaheadSize(4).lookaheadThreshold(2).build();
+            wallet = new Wallet(UNITTEST, kcg);
             key = wallet.freshReceiveKey();
             address = LegacyAddress.fromKey(UNITTEST, key);
         }

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -474,8 +474,8 @@ public void verify(TransactionOutput output) throws VerificationException {
                 throw new VerificationException("This input refers to a different output on the given tx.");
         }
         Script pubKey = output.getScriptPubKey();
-        int myIndex = getParentTransaction().getInputs().indexOf(this);
-        getScriptSig().correctlySpends(getParentTransaction(), getIndex(), pubKey);
+        getScriptSig().correctlySpends(getParentTransaction(), getIndex(), getWitness(), getValue(), pubKey,
+                Script.ALL_VERIFY_FLAGS);
     }
 
     /**

File: core/src/main/java/org/bitcoinj/crypto/ChildNumber.java
Patch:
@@ -37,8 +37,9 @@ public class ChildNumber implements Comparable<ChildNumber> {
     public static final int HARDENED_BIT = 0x80000000;
 
     public static final ChildNumber ZERO = new ChildNumber(0);
-    public static final ChildNumber ONE = new ChildNumber(1);
     public static final ChildNumber ZERO_HARDENED = new ChildNumber(0, true);
+    public static final ChildNumber ONE = new ChildNumber(1);
+    public static final ChildNumber ONE_HARDENED = new ChildNumber(1, true);
 
     /** Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private) **/
     private final int i;

File: core/src/main/java/org/bitcoinj/signers/CustomTransactionSigner.java
Patch:
@@ -1,5 +1,6 @@
 /*
  * Copyright 2014 Kosta Korenkov
+ * Copyright 2019 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -70,7 +71,8 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                 // We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                 // we sign missing pieces (to check this would require either assuming any signatures are signing
                 // standard output types or a way to get processed signatures out of script execution)
-                txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey());
+                txIn.getScriptSig().correctlySpends(tx, i, txIn.getWitness(), txOut.getValue(), txOut.getScriptPubKey(),
+                        Script.ALL_VERIFY_FLAGS);
                 log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i);
                 continue;
             } catch (ScriptException e) {

File: core/src/main/java/org/bitcoinj/wallet/DecryptingKeyBag.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.wallet;
 
 import org.bitcoinj.core.ECKey;
+import org.bitcoinj.script.Script;
 import org.bouncycastle.crypto.params.KeyParameter;
 
 import javax.annotation.Nullable;
@@ -63,8 +64,8 @@ private RedeemData maybeDecrypt(RedeemData redeemData) {
 
     @Nullable
     @Override
-    public ECKey findKeyFromPubKeyHash(byte[] pubKeyHash) {
-        return maybeDecrypt(target.findKeyFromPubKeyHash(pubKeyHash));
+    public ECKey findKeyFromPubKeyHash(byte[] pubKeyHash, @Nullable Script.ScriptType scriptType) {
+        return maybeDecrypt(target.findKeyFromPubKeyHash(pubKeyHash, scriptType));
     }
 
     @Nullable

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -22,8 +22,10 @@
 import com.google.common.util.concurrent.*;
 import org.bitcoinj.core.listeners.*;
 import org.bitcoinj.net.discovery.*;
+import org.bitcoinj.script.Script;
 import org.bitcoinj.testing.*;
 import org.bitcoinj.utils.*;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 import org.junit.*;
 import org.junit.runner.*;
@@ -781,7 +783,7 @@ public void autoRescanOnKeyExhaustion() throws Exception {
         final int NUM_KEYS = 9;
 
         // First, grab a load of keys from the wallet, and then recreate it so it forgets that those keys were issued.
-        Wallet shadow = Wallet.fromSeed(wallet.getParams(), wallet.getKeyChainSeed());
+        Wallet shadow = Wallet.fromSeed(wallet.getParams(), wallet.getKeyChainSeed(), Script.ScriptType.P2PKH);
         List<ECKey> keys = new ArrayList<>(NUM_KEYS);
         for (int i = 0; i < NUM_KEYS; i++) {
             keys.add(shadow.freshReceiveKey());

File: examples/src/main/java/org/bitcoinj/examples/GenerateLowSTests.java
Patch:
@@ -1,5 +1,6 @@
 /*
  * Copyright 2015 Ross Nicoll.
+ * Copyright 2019 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,7 +65,7 @@ public static void main(final String[] argv)
         final ECKey key = new ECKey(secureRandom);
         final KeyBag bag = new KeyBag() {
             @Override
-            public ECKey findKeyFromPubKeyHash(byte[] pubKeyHash) {
+            public ECKey findKeyFromPubKeyHash(byte[] pubkeyHash, Script.ScriptType scriptType) {
                 return key;
             }
 

File: examples/src/main/java/org/bitcoinj/examples/RestoreFromSeed.java
Patch:
@@ -20,8 +20,10 @@
 import org.bitcoinj.core.*;
 import org.bitcoinj.net.discovery.DnsDiscovery;
 import org.bitcoinj.params.TestNet3Params;
+import org.bitcoinj.script.Script;
 import org.bitcoinj.store.SPVBlockStore;
 import org.bitcoinj.wallet.DeterministicSeed;
+import org.bitcoinj.wallet.KeyChainGroupStructure;
 import org.bitcoinj.wallet.Wallet;
 
 import java.io.File;
@@ -46,7 +48,7 @@ public static void main(String[] args) throws Exception {
         DeterministicSeed seed = new DeterministicSeed(seedCode, null, passphrase, creationtime);
 
         // The wallet class provides a easy fromSeed() function that loads a new wallet from a given seed.
-        Wallet wallet = Wallet.fromSeed(params, seed);
+        Wallet wallet = Wallet.fromSeed(params, seed, Script.ScriptType.P2PKH);
 
         // Because we are importing an existing wallet which might already have transactions we must re-download the blockchain to make the wallet picks up these transactions
         // You can find some information about this in the guides: https://bitcoinj.github.io/working-with-the-wallet#setup

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -22,6 +22,7 @@
 import org.bitcoinj.core.Utils;
 import org.bitcoinj.kits.WalletAppKit;
 import org.bitcoinj.params.*;
+import org.bitcoinj.script.Script;
 import org.bitcoinj.utils.BriefLogFormatter;
 import org.bitcoinj.utils.Threading;
 import org.bitcoinj.wallet.DeterministicSeed;
@@ -46,6 +47,7 @@
 
 public class Main extends Application {
     public static NetworkParameters params = MainNetParams.get();
+    public static final Script.ScriptType PREFERRED_OUTPUT_SCRIPT_TYPE = Script.ScriptType.P2WPKH;
     public static final String APP_NAME = "WalletTemplate";
     private static final String WALLET_FILE_NAME = APP_NAME.replaceAll("[^a-zA-Z0-9.-]", "_") + "-"
             + params.getPaymentProtocolId();
@@ -132,7 +134,7 @@ public void failed(Service.State from, Throwable failure) {
 
     public void setupWalletKit(@Nullable DeterministicSeed seed) {
         // If seed is non-null it means we are restoring from backup.
-        bitcoin = new WalletAppKit(params, new File("."), WALLET_FILE_NAME) {
+        bitcoin = new WalletAppKit(params, PREFERRED_OUTPUT_SCRIPT_TYPE, null, new File("."), WALLET_FILE_NAME) {
             @Override
             protected void onSetupCompleted() {
                 // Don't make the user wait for confirmations for now, as the intention is they're sending it

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -58,6 +58,7 @@ public void initialize() {
         new TextFieldValidator(amountEdit, text ->
                 !WTUtils.didThrow(() -> checkState(Coin.parseCoin(text).compareTo(balance) <= 0)));
         amountEdit.setText(balance.toPlainString());
+        address.setPromptText(Address.fromKey(Main.params, new ECKey(), Main.PREFERRED_OUTPUT_SCRIPT_TYPE).toString());
     }
 
     public void cancel(ActionEvent event) {

File: core/src/main/java/org/bitcoinj/params/RegTestParams.java
Patch:
@@ -36,7 +36,7 @@ public RegTestParams() {
         p2shHeader = 196;
         targetTimespan = TARGET_TIMESPAN;
         dumpedPrivateKeyHeader = 239;
-        segwitAddressHrp = "tb";
+        segwitAddressHrp = "bcrt";
         genesisBlock.setTime(1296688602L);
         genesisBlock.setDifficultyTarget(0x1d07fff8L);
         genesisBlock.setNonce(384568319);

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -2212,6 +2212,8 @@ protected Peer selectDownloadPeer(List<Peer> peers) {
                 candidates2.add(peer);
             }
         }
+        if (candidates2.isEmpty())
+            return null;
         int index = (int) (Math.random() * candidates2.size());
         return candidates2.get(index);
     }

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -237,8 +237,7 @@ public void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock f
             final double target = bloomFilterMerger.getBloomFilterFPRate() * MAX_FP_RATE_INCREASE;
             if (rate > target) {
                 // TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
-                if (log.isDebugEnabled())
-                    log.debug("Force update Bloom filter due to high false positive rate ({} vs {})", rate, target);
+                log.info("Force update Bloom filter due to high false positive rate ({} vs {})", rate, target);
                 recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);
             }
         }

File: tools/src/main/java/org/bitcoinj/tools/WalletTool.java
Patch:
@@ -1267,6 +1267,8 @@ private static void setup() throws BlockStoreException {
                     System.exit(1);
                 }
             }
+        } else {
+            peerGroup.setRequiredServices(0);
         }
     }
 

File: core/src/main/java/org/bitcoinj/core/Message.java
Patch:
@@ -68,7 +68,8 @@ protected Message() {
 
     protected Message(NetworkParameters params) {
         this.params = params;
-        serializer = params.getDefaultSerializer();
+        this.protocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT);
+        this.serializer = params.getDefaultSerializer();
     }
 
     protected Message(NetworkParameters params, byte[] payload, int offset, int protocolVersion) throws ProtocolException {

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4155,7 +4155,7 @@ public boolean canSignFor(Script script) {
                 return true;
             }
             byte[] recipient = ScriptPattern.extractRecipientPubKeyFromCltvPaymentChannel(script);
-            ECKey recipientKey = findKeyFromPubKey(sender);
+            ECKey recipientKey = findKeyFromPubKey(recipient);
             if (recipientKey != null && (recipientKey.isEncrypted() || recipientKey.hasPrivKey())) {
                 return true;
             }

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4135,7 +4135,7 @@ public boolean canSignFor(Script script) {
             byte[] pubkey = ScriptPattern.extractKeyFromPayToPubKey(script);
             ECKey key = findKeyFromPubKey(pubkey);
             return key != null && (key.isEncrypted() || key.hasPrivKey());
-        } if (ScriptPattern.isPayToScriptHash(script)) {
+        } else if (ScriptPattern.isPayToScriptHash(script)) {
             RedeemData data = findRedeemDataFromScriptHash(ScriptPattern.extractHashFromPayToScriptHash(script));
             return data != null && canSignFor(data.redeemScript);
         } else if (ScriptPattern.isPayToPubKeyHash(script)) {

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -162,7 +162,7 @@ private int calcDefaultLookaheadThreshold() {
 
     public static class Builder<T extends Builder<T>> {
         protected SecureRandom random;
-        protected int bits = 128;
+        protected int bits = DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS;
         protected String passphrase;
         protected long seedCreationTimeSecs;
         protected byte[] entropy;

File: core/src/main/java/org/bitcoinj/params/MainNetParams.java
Patch:
@@ -79,6 +79,7 @@ public MainNetParams() {
                 "seed.btc.petertodd.org",       // Peter Todd
                 "seed.bitcoin.sprovoost.nl",    // Sjors Provoost
                 "seed.bitnodes.io",             // Addy Yeow
+                "dnsseed.emzy.de",              // Stephan Oeste
         };
         httpSeeds = new HttpDiscovery.Details[] {
                 // Andreas Schildbach

File: core/src/main/java/org/bitcoinj/wallet/BasicKeyChain.java
Patch:
@@ -435,7 +435,7 @@ public void run() {
 
     /**
      * Convenience wrapper around {@link #toEncrypted(KeyCrypter,
-     * org.spongycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
+     * org.bouncycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
      * parameters, derives a key from the given password and returns the created key.
      */
     @Override

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -1133,7 +1133,7 @@ public DeterministicKey getKeyByPath(List<ChildNumber> path) {
 
     /**
      * Convenience wrapper around {@link Wallet#encrypt(KeyCrypter,
-     * org.spongycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
+     * org.bouncycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
      * parameters to derive a key from the given password.
      */
     public void encrypt(CharSequence password) {

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -179,7 +179,7 @@ public DeterministicKey(DeterministicKey keyToClone, DeterministicKey newParent)
 
     /**
      * Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
-     * A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
+     * A path can be written as 0/1/0 which means the first child of the root, the second child of that node, then
      * the first child of that node.
      */
     public ImmutableList<ChildNumber> getPath() {

File: core/src/main/java/org/bitcoinj/store/LevelDBFullPrunedBlockStore.java
Patch:
@@ -317,7 +317,7 @@ private void initFromDb() throws BlockStoreException {
         this.verifiedChainHeadBlock = get(hash);
         this.verifiedChainHeadHash = hash;
         if (this.verifiedChainHeadBlock == null) {
-            throw new BlockStoreException("corrupt databse block store - verified head block not found");
+            throw new BlockStoreException("corrupt database block store - verified head block not found");
         }
     }
 

File: core/src/main/java/org/bitcoinj/core/AddressMessage.java
Patch:
@@ -36,7 +36,7 @@ public class AddressMessage extends Message {
     private List<PeerAddress> addresses;
 
     /**
-     * Contruct a new 'addr' message.
+     * Construct a new 'addr' message.
      * @param params NetworkParameters object.
      * @param offset The location of the first payload byte within the array.
      * @param serializer the serializer to use for this block.
@@ -49,7 +49,7 @@ public class AddressMessage extends Message {
     }
 
     /**
-     * Contruct a new 'addr' message.
+     * Construct a new 'addr' message.
      * @param params NetworkParameters object.
      * @param serializer the serializer to use for this block.
      * @param length The length of message if known.  Usually this is provided when deserializing of the wire

File: core/src/main/java/org/bitcoinj/core/BitcoinSerializer.java
Patch:
@@ -78,7 +78,7 @@ public class BitcoinSerializer extends MessageSerializer {
     /**
      * Constructs a BitcoinSerializer with the given behavior.
      *
-     * @param params           networkParams used to create Messages instances and termining packetMagic
+     * @param params           networkParams used to create Messages instances and determining packetMagic
      * @param parseRetain      retain the backing byte array of a message for fast reserialization.
      */
     public BitcoinSerializer(NetworkParameters params, boolean parseRetain) {

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -539,7 +539,7 @@ protected boolean checkProofOfWork(boolean throwException) throws VerificationEx
         // ridiculously easy difficulty and this function would accept them.
         //
         // To prevent this attack from being possible, elsewhere we check that the difficultyTarget
-        // field is of the right value. This requires us to have the preceeding blocks.
+        // field is of the right value. This requires us to have the preceding blocks.
         BigInteger target = getDifficultyTargetAsInteger();
 
         BigInteger h = getHash().toBigInteger();
@@ -599,7 +599,7 @@ private List<byte[]> buildMerkleTree() {
         // entry is a hash.
         //
         // The hashing algorithm is double SHA-256. The leaves are a hash of the serialized contents of the transaction.
-        // The interior nodes are hashes of the concenation of the two child hashes.
+        // The interior nodes are hashes of the concatenation of the two child hashes.
         //
         // This structure allows the creation of proof that a transaction was included into a block without having to
         // provide the full block contents. Instead, you can provide only a Merkle branch. For example to prove tx2 was
@@ -693,7 +693,7 @@ public void verifyTransactions(final int height, final EnumSet<VerifyFlag> flags
         // Now we need to check that the body of the block actually matches the headers. The network won't generate
         // an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
         // valid block from the network and simply replace the transactions in it with their own fictional
-        // transactions that reference spent or non-existant inputs.
+        // transactions that reference spent or non-existent inputs.
         if (transactions.isEmpty())
             throw new VerificationException("Block had no transactions");
         if (this.getOptimalEncodingMessageSize() > MAX_BLOCK_SIZE)

File: core/src/main/java/org/bitcoinj/core/FilteredBlock.java
Patch:
@@ -70,8 +70,8 @@ protected void parse() throws ProtocolException {
     
     /**
      * Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block
-     * 
-     * @throws ProtocolException If the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header
+     *
+     * @throws ProtocolException If the partial merkle block is invalid or the merkle root of the partial merkle block doesn't match the block header
      */
     public List<Sha256Hash> getTransactionHashes() throws VerificationException {
         if (cachedTransactionHashes != null)

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -288,7 +288,7 @@ public HttpDiscovery.Details[] getHttpSeeds() {
     /**
      * <p>Genesis block for this chain.</p>
      *
-     * <p>The first block in every chain is a well known constant shared between all Bitcoin implemenetations. For a
+     * <p>The first block in every chain is a well known constant shared between all Bitcoin implementations. For a
      * block to be valid, it must be eventually possible to work backwards to the genesis block by following the
      * prevBlockHash pointers in the block headers.</p>
      *
@@ -405,7 +405,7 @@ public int getBip32HeaderPriv() {
 
     /**
      * Returns whether this network has a maximum number of coins (finite supply) or
-     * not. Always returns true for Bitcoin, but exists to be overriden for other
+     * not. Always returns true for Bitcoin, but exists to be overridden for other
      * networks.
      */
     public abstract boolean hasMaxMoney();

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -195,7 +195,7 @@ public Peer(NetworkParameters params, VersionMessage ver, @Nullable AbstractBloc
 
     /**
      * <p>Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link TxConfidenceTable}
-     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
+     * will have their confidence levels updated when a peer announces it, to reflect the greater likelihood that
      * the transaction is valid.</p>
      *
      * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a
@@ -214,7 +214,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
 
     /**
      * <p>Construct a peer that reads/writes from the given block chain. Transactions stored in a {@link TxConfidenceTable}
-     * will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
+     * will have their confidence levels updated when a peer announces it, to reflect the greater likelihood that
      * the transaction is valid.</p>
      *
      * <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler for a
@@ -1263,7 +1263,7 @@ protected void processInv(InventoryMessage inv) {
                         // previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                         // will be different and so the getblocks req won't be dropped as a duplicate. We'll end up
                         // requesting a subset of what we already requested, which can lead to parallel chain downloads
-                        // and other nastyness. So we just do a quick removal of redundant getdatas here too.
+                        // and other nastiness. So we just do a quick removal of redundant getdatas here too.
                         //
                         // Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                         // part of chain download with newly announced blocks, so it should always be taken care of by

File: core/src/main/java/org/bitcoinj/core/StoredUndoableBlock.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 
 /**
- * Contains minimal data neccessary to disconnect/connect the transactions
+ * Contains minimal data necessary to disconnect/connect the transactions
  * in the stored block at will. Can either store the full set of
  * transactions (if the inputs for the block have not been tested to work)
  * or the set of transaction outputs created/destroyed when the block is

File: core/src/main/java/org/bitcoinj/core/listeners/BlocksDownloadedEventListener.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
- * they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
+ * they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
  * provide transactions to remote peers when they ask for them.</p>
  */
 public interface BlocksDownloadedEventListener {

File: core/src/main/java/org/bitcoinj/core/listeners/ChainDownloadStartedEventListener.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
- * they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
+ * they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
  * provide transactions to remote peers when they ask for them.</p>
  */
 public interface ChainDownloadStartedEventListener {

File: core/src/main/java/org/bitcoinj/core/listeners/GetDataEventListener.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
- * they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
+ * they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
  * provide transactions to remote peers when they ask for them.</p>
  */
 public interface GetDataEventListener {

File: core/src/main/java/org/bitcoinj/core/listeners/PreMessageReceivedEventListener.java
Patch:
@@ -21,7 +21,7 @@
 
 /**
  * <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
- * they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
+ * they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
  * provide transactions to remote peers when they ask for them.</p>
  */
 public interface PreMessageReceivedEventListener {

File: core/src/main/java/org/bitcoinj/net/BlockingClient.java
Patch:
@@ -63,7 +63,7 @@ public BlockingClient(final SocketAddress serverAddress, final StreamConnection
                           @Nullable final Set<BlockingClient> clientSet) throws IOException {
         connectFuture = SettableFuture.create();
         // Try to fit at least one message in the network buffer, but place an upper and lower limit on its size to make
-        // sure it doesnt get too large or have to call read too often.
+        // sure it doesn't get too large or have to call read too often.
         connection.setWriteTarget(this);
         socket = socketFactory.createSocket();
         final Context context = Context.get();

File: core/src/main/java/org/bitcoinj/net/StreamConnection.java
Patch:
@@ -22,7 +22,7 @@
  * A generic handler which is used in {@link NioServer}, {@link NioClient} and {@link BlockingClient} to handle incoming
  * data streams.
  *
- * Used to be callet StreamParser.
+ * Used to be called StreamParser.
  */
 public interface StreamConnection {
     /** Called when the connection socket is closed */
@@ -41,7 +41,7 @@ public interface StreamConnection {
      *     will start reading at (always 0)</li>
      * <li>May read more than one message (recursively) if there are enough bytes available</li>
      * <li>Uses some internal buffering to store message which are larger (incl their length prefix) than buff's
-     *     capacity(), ie it is up to this method to ensure we dont run out of buffer space to decode the next message.
+     *     capacity(), ie it is up to this method to ensure we don't run out of buffer space to decode the next message.
      *     </li>
      * <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
      *     bytes have been read (the same as its return value)</li>

File: core/src/main/java/org/bitcoinj/utils/BtcFixedFormat.java
Patch:
@@ -70,7 +70,7 @@ public final class BtcFixedFormat extends BtcFormat {
     public static final int[] REPEATING_TRIPLETS = {3,3,3,3,3};
 
     /** The number of places the decimal point of formatted values is shifted rightward from
-     *  thet same value expressed in bitcoins. */
+     *  the same value expressed in bitcoins. */
     private final int scale;
 
     /** Constructor */

File: core/src/main/java/org/bitcoinj/wallet/BasicKeyChain.java
Patch:
@@ -44,7 +44,7 @@
 public class BasicKeyChain implements EncryptableKeyChain {
     private final ReentrantLock lock = Threading.lock("BasicKeyChain");
 
-    // Maps used to let us quickly look up a key given data we find in transcations or the block chain.
+    // Maps used to let us quickly look up a key given data we find in transactions or the block chain.
     private final LinkedHashMap<ByteString, ECKey> hashToKeys;
     private final LinkedHashMap<ByteString, ECKey> pubkeyToKeys;
     @Nullable private final KeyCrypter keyCrypter;

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -341,7 +341,7 @@ public void testUTXOProviderWithWallet() throws Exception {
             totalPendingTxAmount = totalPendingTxAmount.add(tx.getValueSentToMe(wallet));
         }
 
-        // The availbale balance should be the 0 (as we spent the 1 BTC that's pending) and estimated should be 1/2 - fee BTC
+        // The available balance should be the 0 (as we spent the 1 BTC that's pending) and estimated should be 1/2 - fee BTC
         assertEquals("Available balance is incorrect", Coin.ZERO, wallet.getBalance(Wallet.BalanceType.AVAILABLE));
         assertEquals("Estimated balance is incorrect", amount2.subtract(fee), wallet.getBalance(Wallet.BalanceType.ESTIMATED));
         assertEquals("Pending tx amount is incorrect", amount2.subtract(fee), totalPendingTxAmount);

File: core/src/test/java/org/bitcoinj/core/FilteredBlockAndPartialMerkleTreeTests.java
Patch:
@@ -129,7 +129,7 @@ public void merkleTreeMalleability() throws Exception {
 
     @Test
     public void serializeDownloadBlockWithWallet() throws Exception {
-        // First we create all the neccessary objects, including lots of serialization and double-checks
+        // First we create all the necessary objects, including lots of serialization and double-checks
         // Note that all serialized forms here are generated by Bitcoin Core/pulled from block explorer
         Block block = new Block(UNITTEST, HEX.decode("0100000006e533fd1ada86391f3f6c343204b0d278d4aaec1c0b20aa27ba0300000000006abbb3eb3d733a9fe18967fd7d4c117e4ccbbac5bec4d910d900b3ae0793e77f54241b4d4c86041b4089cc9b0c01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff07044c86041b010dffffffff0100f2052a01000000434104b27f7e9475ccf5d9a431cb86d665b8302c140144ec2397fce792f4a4e7765fecf8128534eaa71df04f93c74676ae8279195128a1506ebf7379d23dab8fca0f63ac000000000100000001d992e5a888a86d4c7a6a69167a4728ee69497509740fc5f456a24528c340219a000000008b483045022100f0519bdc9282ff476da1323b8ef7ffe33f495c1a8d52cc522b437022d83f6a230220159b61d197fbae01b4a66622a23bc3f1def65d5fa24efd5c26fa872f3a246b8e014104839f9023296a1fabb133140128ca2709f6818c7d099491690bd8ac0fd55279def6a2ceb6ab7b5e4a71889b6e739f09509565eec789e86886f6f936fa42097adeffffffff02000fe208010000001976a914948c765a6914d43f2a7ac177da2c2f6b52de3d7c88ac00e32321000000001976a9140c34f4e29ab5a615d5ea28d4817f12b137d62ed588ac0000000001000000059daf0abe7a92618546a9dbcfd65869b6178c66ec21ccfda878c1175979cfd9ef000000004a493046022100c2f7f25be5de6ce88ac3c1a519514379e91f39b31ddff279a3db0b1a229b708b022100b29efbdbd9837cc6a6c7318aa4900ed7e4d65662c34d1622a2035a3a5534a99a01ffffffffd516330ebdf075948da56db13d22632a4fb941122df2884397dda45d451acefb0000000048473044022051243debe6d4f2b433bee0cee78c5c4073ead0e3bde54296dbed6176e128659c022044417bfe16f44eb7b6eb0cdf077b9ce972a332e15395c09ca5e4f602958d266101ffffffffe1f5aa33961227b3c344e57179417ce01b7ccd421117fe2336289b70489883f900000000484730440220593252bb992ce3c85baf28d6e3aa32065816271d2c822398fe7ee28a856bc943022066d429dd5025d3c86fd8fd8a58e183a844bd94aa312cefe00388f57c85b0ca3201ffffffffe207e83718129505e6a7484831442f668164ae659fddb82e9e5421a081fb90d50000000049483045022067cf27eb733e5bcae412a586b25a74417c237161a084167c2a0b439abfebdcb2022100efcc6baa6824b4c5205aa967e0b76d31abf89e738d4b6b014e788c9a8cccaf0c01ffffffffe23b8d9d80a9e9d977fab3c94dbe37befee63822443c3ec5ae5a713ede66c3940000000049483045022020f2eb35036666b1debe0d1d2e77a36d5d9c4e96c1dba23f5100f193dbf524790221008ce79bc1321fb4357c6daee818038d41544749127751726e46b2b320c8b565a201ffffffff0200ba1dd2050000001976a914366a27645806e817a6cd40bc869bdad92fe5509188ac40420f00000000001976a914ee8bd501094a7d5ca318da2506de35e1cb025ddc88ac0000000001000000010abad2dc0c9b4b1dbb023077da513f81e5a71788d8680fca98ef1c37356c459c000000004a493046022100a894e521c87b3dbe23007079db4ac2896e9e791f8b57317ba6c0d99a7becd27a022100bc40981393eafeb33e89079f857c728701a9af4523c3f857cd96a500f240780901ffffffff024026ee22010000001976a914d28f9cefb58c1f7a5f97aa6b79047585f58fbd4388acc0cb1707000000001976a9142229481696e417aa5f51ad751d8cd4c6a669e4fe88ac000000000100000001f66d89b3649e0b18d84db056930676cb81c0168042fc4324c3682e252ea9410d0000000048473044022038e0b55b37c9253bfeda59c76c0134530f91fb586d6eb21738a77a984f370a44022048d4d477aaf97ef9c8275bbc5cb19b9c8a0e9b1f9fdafdd39bc85bf6c2f04a4d01ffffffff024041a523010000001976a914955f70ac8792b48b7bd52b15413bd8500ecf32c888ac00f36f06000000001976a91486116d15f3dbb23a2b58346f36e6ec2d867eba2b88ac00000000010000000126c384984f63446a4f2be8dd6531ba9837bd5f2c3d37403c5f51fb9192ee754e010000008b48304502210083af8324456f052ff1b2597ff0e6a8cce8b006e379a410cf781be7874a2691c2022072259e2f7292960dea0ffc361bbad0b861f719beb8550476f22ce0f82c023449014104f3ed46a81cba02af0593e8572a9130adb0d348b538c829ccaaf8e6075b78439b2746a76891ce7ba71abbcbb7ca76e8a220782738a6789562827c1065b0ce911dffffffff02c0dd9107000000001976a91463d4dd1b29d95ed601512b487bfc1c49d84d057988ac00a0491a010000001976a91465746bef92511df7b34abf71c162efb7ae353de388ac0000000001000000011b56cf3aab3286d582c055a42af3a911ee08423f276da702bb67f1222ac1a5b6000000008c4930460221009e9fba682e162c9627b96b7df272006a727988680b956c61baff869f0907b8fb022100a9c19adc7c36144bafe526630783845e5cb9554d30d3edfb56f0740274d507f30141046e0efbfac7b1615ad553a6f097615bc63b7cdb3b8e1cb3263b619ba63740012f51c7c5b09390e3577e377b7537e61226e315f95f926444fc5e5f2978c112e448ffffffff02c0072b11010000001976a914b73e9e01933351ca076faf8e0d94dd58079d0b1f88ac80b63908000000001976a9141aca0bdf0d2cee63db19aa4a484f45a4e26a880c88ac000000000100000001251b187504ea873b2c3915fad401f7a7734cc13567e0417708e86294a29f4f68010000008b4830450221009bef423141ed1ae60d0a5bcaa57b1673fc96001f0d4e105535cca817ba5a7724022037c399bd30374f22481ffc81327cfca4951c7264b227f765fcd6a429f3d9d2080141044d0d1b4f194c31a73dbce41c42b4b3946849117c5bb320467e014bad3b1532f28a9a1568ba7108f188e7823b6e618e91d974306701379a27b9339e646e156e7bffffffff02c00fd103010000001976a914ef7f5d9e1bc6ed68cfe0b1db9d8f09cef0f3ba4a88ac004dd208000000001976a914c22420641cea028c9e06c4d9104c1646f8b1769088ac0000000001000000013486dd5f0a2f3efcc04f64cb03872c021f98ee39f514747ce5336b874bbe47a7010000008b48304502201cadddc2838598fee7dc35a12b340c6bde8b389f7bfd19a1252a17c4b5ed2d71022100c1a251bbecb14b058a8bd77f65de87e51c47e95904f4c0e9d52eddc21c1415ac014104fe7df86d58aafa9246ca6fd30c905714533c25f700e2329b8ecec8aa52083b844baa3a8acd5d6b9732dcb39079bb56ba2711a3580dec824955fce0596a460c11ffffffff02c011f6e1000000001976a91490fac83c9adde91d670dde8755f8b475ab9e427d88acc0f9df15000000001976a91437f691b3e8ee5dcb56c2e31af4c80caa2df3b09b88ac00000000010000000170016bd1274b795b262f32a53003a4714b22b62f9057adf5fbe6ed939003b5190100000089463043022061456499582170a94d6b54308f792e37dad28bf0ed7aa61021f0301d2774d378021f4224b33f707efd810a01dd34ea86d6069cd599cc435513a0eef8c83c137bf7014104a2c95d6b98e745448eb45ed0ba95cf24dd7c3b16386e1028e24a0358ee4afc33e2f0199139853edaf32845d8a42254c75f7dc8add3286c682c650fbd93f0a4a1ffffffff02001bd2b7000000001976a9141b11c6acaa5223013f3a3240fdb024ecd9f8135488ac8023ad18000000001976a914ada27ca87bbaa1ee6fb1cb61bb0a29baaf6da2c988ac000000000100000001c8ff91f031ec6a5aba4baee6549e61dd01f26f61b70e2f1574f24cd680f464ad000000008b48304502210082235e21a2300022738dabb8e1bbd9d19cfb1e7ab8c30a23b0afbb8d178abcf3022024bf68e256c534ddfaf966bf908deb944305596f7bdcc38d69acad7f9c868724014104174f9eef1157dc1ad5eac198250b70d1c3b04b2fca12ad1483f07358486f02909b088bbc83f4de55f767f6cdf9d424aa02b5eeaffa08394d39b717895fc08d0affffffff0200ea3b43000000001976a914fb32df708f0610901f6d1b6df8c9c368fe0d981c88ac800f1777000000001976a914462c501c70fb996d15ac0771e7fc8d3ca3f7201888ac000000000100000001c67323867de802402e780a70e0deba3c708c4d87497e17590afee9c321f1c680010000008a473044022042734b25f54845d662e6499b75ff8529ff47f42fd224498a9f752d212326dbfa0220523e4b7b570bbb1f3af02baa2c04ea8eb7b0fccb1522cced130b666ae9a9d014014104b5a23b922949877e9eaf7512897ed091958e2e8cf05b0d0eb9064e7976043fde6023b4e2c188b7e38ef94eec6845dc4933f5e8635f1f6a3702290956aa9e284bffffffff0280041838030000001976a91436e5884215f7d3044be5d37bdd8c987d9d942c8488ac404b4c00000000001976a91460085d6838f8a44a21a0de56ff963cfa6242a96188ac00000000"));
         FilteredBlock filteredBlock = new FilteredBlock(UNITTEST, HEX.decode("0100000006e533fd1ada86391f3f6c343204b0d278d4aaec1c0b20aa27ba0300000000006abbb3eb3d733a9fe18967fd7d4c117e4ccbbac5bec4d910d900b3ae0793e77f54241b4d4c86041b4089cc9b0c000000084c30b63cfcdc2d35e3329421b9805ef0c6565d35381ca857762ea0b3a5a128bbca5065ff9617cbcba45eb23726df6498a9b9cafed4f54cbab9d227b0035ddefbbb15ac1d57d0182aaee61c74743a9c4f785895e563909bafec45c9a2b0ff3181d77706be8b1dcc91112eada86d424e2d0a8907c3488b6e44fda5a74a25cbc7d6bb4fa04245f4ac8a1a571d5537eac24adca1454d65eda446055479af6c6d4dd3c9ab658448c10b6921b7a4ce3021eb22ed6bb6a7fde1e5bcc4b1db6615c6abc5ca042127bfaf9f44ebce29cb29c6df9d05b47f35b2edff4f0064b578ab741fa78276222651209fe1a2c4c0fa1c58510aec8b090dd1eb1f82f9d261b8273b525b02ff1a"));

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -321,7 +321,7 @@ public boolean add(Rule element) {
 
         NewBlock b13 = createNextBlock(b12, chainHeadHeight + 5, out4, null);
         blocks.add(new BlockAndValidity(b13, false, false, b6.getHash(), chainHeadHeight + 4, "b13"));
-        // Make sure we dont die if an orphan gets added twice
+        // Make sure we don't die if an orphan gets added twice
         blocks.add(new BlockAndValidity(b13, false, false, b6.getHash(), chainHeadHeight + 4, "b13"));
         spendableOutputs.offer(b13.getCoinbaseOutput());
 
@@ -332,7 +332,7 @@ public boolean add(Rule element) {
         // and will be discarded when an attempt is made to reorg to it.
         // TODO: Use a WeakReference to check that it is freed properly after the reorg
         blocks.add(new BlockAndValidity(b14, false, false, b6.getHash(), chainHeadHeight + 4, "b14"));
-        // Make sure we dont die if an orphan gets added twice
+        // Make sure we don't die if an orphan gets added twice
         blocks.add(new BlockAndValidity(b14, false, false, b6.getHash(), chainHeadHeight + 4, "b14"));
 
         blocks.add(new BlockAndValidity(b12, false, true, b13.getHash(), chainHeadHeight + 5, "b12"));

File: core/src/test/java/org/bitcoinj/protocols/channels/ChannelConnectionTest.java
Patch:
@@ -120,7 +120,7 @@ public void setUp() throws Exception {
         serverWallet = new Wallet(UNITTEST);
         serverWallet.addExtension(new StoredPaymentChannelServerStates(serverWallet, failBroadcaster));
         serverWallet.freshReceiveKey();
-        // Use an atomic boolean to indicate failure because fail()/assert*() dont work in network threads
+        // Use an atomic boolean to indicate failure because fail()/assert*() don't work in network threads
         fail = new AtomicBoolean(false);
 
         // Set up a way to monitor broadcast transactions. When you expect a broadcast, you must release a permit

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -1478,7 +1478,7 @@ public void transactionsList() throws Exception {
         assertEquals(tx2, transactions.get(0));
         assertEquals(tx1, transactions.get(1));
         assertEquals(2, transactions.size());
-        // Check we get only the last transaction if we request a subrage.
+        // Check we get only the last transaction if we request a subrange.
         transactions = wallet.getRecentTransactions(1, false);
         assertEquals(1, transactions.size());
         assertEquals(tx2,  transactions.get(0));
@@ -2498,7 +2498,7 @@ public void feeSolverAndCoinSelectionTests2() throws Exception {
         assertEquals(COIN, request20.tx.getInput(0).getValue());
         assertEquals(CENT, request20.tx.getInput(1).getValue());
 
-        // Same as request 19, but make the change 0 (so it doesnt force fee) and make us require min fee
+        // Same as request 19, but make the change 0 (so it doesn't force fee) and make us require min fee
         SendRequest request21 = SendRequest.to(OTHER_ADDRESS, CENT);
         request21.feePerKb = ZERO;
         request21.ensureMinRequiredFee = true;

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4640,7 +4640,7 @@ public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTwea
                     // Only add long (at least 64 bit) data to the bloom filter.
                     // If any long constants become popular in scripts, we will need logic
                     // here to exclude them.
-                    if (!chunk.isOpCode() && chunk.data.length >= MINIMUM_BLOOM_DATA_LENGTH) {
+                    if (!chunk.isOpCode() && (chunk.data != null) && chunk.data.length >= MINIMUM_BLOOM_DATA_LENGTH) {
                         filter.insert(chunk.data);
                     }
                 }

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -237,7 +237,7 @@ protected void parseTransactions(final int transactionsOffset) throws ProtocolEx
 
         int numTransactions = (int) readVarInt();
         optimalEncodingMessageSize += VarInt.sizeOf(numTransactions);
-        transactions = new ArrayList<>(numTransactions);
+        transactions = new ArrayList<>(Math.min(numTransactions, Utils.MAX_INITIAL_ARRAY_LENGTH));
         for (int i = 0; i < numTransactions; i++) {
             Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH);
             // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.

File: core/src/main/java/org/bitcoinj/core/PartialMerkleTree.java
Patch:
@@ -118,7 +118,7 @@ protected void parse() throws ProtocolException {
         transactionCount = (int)readUint32();
 
         int nHashes = (int) readVarInt();
-        hashes = new ArrayList<>(nHashes);
+        hashes = new ArrayList<>(Math.min(nHashes, Utils.MAX_INITIAL_ARRAY_LENGTH));
         for (int i = 0; i < nHashes; i++)
             hashes.add(readHash());
 

File: core/src/main/java/org/bitcoinj/core/TransactionWitness.java
Patch:
@@ -26,7 +26,7 @@ public class TransactionWitness {
     private final List<byte[]> pushes;
 
     public TransactionWitness(int pushCount) {
-        pushes = new ArrayList<>(pushCount);
+        pushes = new ArrayList<>(Math.min(pushCount, Utils.MAX_INITIAL_ARRAY_LENGTH));
     }
 
     public byte[] getPush(int i) {

File: core/src/test/java/org/bitcoinj/core/TransactionWitnessTest.java
Patch:
@@ -25,12 +25,12 @@ public void testToString() throws Exception {
         assertEquals("", w1.toString());
 
         TransactionWitness w2 = new TransactionWitness(2);
-        assertEquals("NULL NULL", w2.toString());
+        assertEquals("", w2.toString());
 
         TransactionWitness w3 = new TransactionWitness(3);
         w3.setPush(0, Utils.HEX.decode("123aaa"));
         w3.setPush(1, Utils.HEX.decode("123bbb"));
-        w3.setPush(2, Utils.HEX.decode("123ccc"));
-        assertEquals("123aaa 123bbb 123ccc", w3.toString());
+        w3.setPush(3, Utils.HEX.decode("123ccc"));
+        assertEquals("123aaa 123bbb EMPTY 123ccc", w3.toString());
     }
 }

File: core/src/main/java/org/bitcoinj/store/SPVBlockStore.java
Patch:
@@ -95,7 +95,7 @@ public SPVBlockStore(NetworkParameters params, File file) throws BlockStoreExcep
      * it's missing. This operation will block on disk.
      * @param file file to use for the block store
      * @param capacity custom capacity in number of block headers
-     * @param wether or not to migrate an existing block store of different capacity
+     * @param grow wether or not to migrate an existing block store of different capacity
      * @throws BlockStoreException if something goes wrong
      */
     public SPVBlockStore(NetworkParameters params, File file, int capacity, boolean grow) throws BlockStoreException {

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -912,13 +912,12 @@ public static List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, @N
                     // If this is not a following chain and previous was, this must be married
                     boolean isMarried = !isFollowingKey && !chains.isEmpty() && chains.get(chains.size() - 1).isFollowing();
                     // If this has a private key but no seed, then all we know is the spending key H
-                    if (seed == null & key.hasSecretBytes()) {
+                    if (seed == null && key.hasSecretBytes()) {
                         DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, new BigInteger(1, key.getSecretBytes().toByteArray()), null);
                         accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);
                         chain = factory.makeSpendingKeyChain(key, iter.peek(), accountKey, isMarried);
                         isSpendingKey = true;
-                    }
-                    else if (seed == null) {
+                    } else if (seed == null) {
                         DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, null, null);
                         accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);
                         chain = factory.makeWatchingKeyChain(key, iter.peek(), accountKey, isFollowingKey, isMarried);

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -523,6 +523,7 @@ public static enum ProtocolVersion {
         MINIMUM(70000),
         PONG(60001),
         BLOOM_FILTER(70000),
+        WITNESS_VERSION(70012),
         CURRENT(70012);
 
         private final int bitcoinProtocol;

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -66,7 +66,7 @@ public void tearDown() {
     @Test
     public void fourPeers() throws Exception {
         InboundMessageQueuer[] channels = { connectPeer(1), connectPeer(2), connectPeer(3), connectPeer(4) };
-        Transaction tx = new Transaction(UNITTEST);
+        Transaction tx = FakeTxBuilder.createFakeTx(UNITTEST);
         tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
         TransactionBroadcast broadcast = new TransactionBroadcast(peerGroup, tx);
         final AtomicDouble lastProgress = new AtomicDouble();
@@ -127,7 +127,7 @@ public void onBroadcastProgress(double progress) {
     @Test
     public void rejectHandling() throws Exception {
         InboundMessageQueuer[] channels = { connectPeer(0), connectPeer(1), connectPeer(2), connectPeer(3), connectPeer(4) };
-        Transaction tx = new Transaction(UNITTEST);
+        Transaction tx = FakeTxBuilder.createFakeTx(UNITTEST);
         TransactionBroadcast broadcast = new TransactionBroadcast(peerGroup, tx);
         ListenableFuture<Transaction> future = broadcast.broadcast();
         // 0 and 3 are randomly selected to receive the broadcast.

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -425,7 +425,7 @@ protected DeterministicKeyChain(DeterministicSeed seed, @Nullable KeyCrypter cry
      * For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called, so that
      * subclasses can override that method and create an instance of the right class.
      *
-     * See also {@link #makeKeyChainFromSeed(DeterministicSeed, ImmutableList<ChildNumber>)}
+     * See also {@link #makeKeyChainFromSeed(DeterministicSeed, ImmutableList)}
      */
     protected DeterministicKeyChain(KeyCrypter crypter, KeyParameter aesKey, DeterministicKeyChain chain) {
         // Can't encrypt a watching chain.

File: core/src/main/java/org/bitcoinj/core/LegacyAddress.java
Patch:
@@ -58,8 +58,8 @@ public class LegacyAddress extends Address {
      * 
      * @param params
      *            network this address is valid for
-     * @param version
-     *            version header of the address
+     * @param p2sh
+     *            true if hash160 is hash of a script, false if it is hash of a pubkey
      * @param hash160
      *            20-byte hash of pubkey or script
      */

File: core/src/main/java/org/bitcoinj/core/UTXOProvider.java
Patch:
@@ -36,7 +36,7 @@ public interface UTXOProvider {
     /**
      * Get the height of the chain head.
      * @return The chain head height.
-     * @throws UTXOProvider If there is an error.
+     * @throws UTXOProviderException If there is an error.
      */
     int getChainHeadHeight() throws UTXOProviderException;
 

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -686,7 +686,7 @@ private static boolean castToBool(byte[] data) {
     /**
      * Cast a script chunk to a BigInteger.
      *
-     * @see #castToBigInteger(byte[], int) for values with different maximum
+     * @see #castToBigInteger(byte[], int, boolean) for values with different maximum
      * sizes.
      * @throws ScriptException if the chunk is longer than 4 bytes.
      */
@@ -696,7 +696,7 @@ private static BigInteger castToBigInteger(byte[] chunk, final boolean requireMi
 
     /**
      * Cast a script chunk to a BigInteger. Normally you would want
-     * {@link #castToBigInteger(byte[])} instead, this is only for cases where
+     * {@link #castToBigInteger(byte[], boolean)} instead, this is only for cases where
      * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
      *
      * @param maxLength the maximum length in bytes.

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -36,7 +36,7 @@
  * It records a set of {@link Transaction}s together with some data that links it into a place in the global block
  * chain, and proves that a difficult calculation was done over its contents. See
  * <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for
- * more detail on blocks. <p/>
+ * more detail on blocks.</p>
  *
  * <p>To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
  * specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.</p>

File: core/src/main/java/org/bitcoinj/core/Ping.java
Patch:
@@ -33,7 +33,7 @@ public Ping(NetworkParameters params, byte[] payloadBytes) throws ProtocolExcept
     
     /**
      * Create a Ping with a nonce value.
-     * Only use this if the remote node has a protocol version > 60000
+     * Only use this if the remote node has a protocol version greater than 60000
      */
     public Ping(long nonce) {
         this.nonce = nonce;
@@ -42,7 +42,7 @@ public Ping(long nonce) {
     
     /**
      * Create a Ping without a nonce value.
-     * Only use this if the remote node has a protocol version <= 60000
+     * Only use this if the remote node has a protocol version lower than or equal 60000
      */
     public Ping() {
         this.hasNonce = false;

File: core/src/main/java/org/bitcoinj/core/Pong.java
Patch:
@@ -32,7 +32,7 @@ public Pong(NetworkParameters params, byte[] payloadBytes) throws ProtocolExcept
     
     /**
      * Create a Pong with a nonce value.
-     * Only use this if the remote node has a protocol version > 60000
+     * Only use this if the remote node has a protocol version greater than 60000
      */
     public Pong(long nonce) {
         this.nonce = nonce;

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -306,7 +306,7 @@ public enum ConnectMode {
      * Connecting means updating the internal pointers and spent flags. If the mode is to ABORT_ON_CONFLICT then
      * the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
      *
-     * @param transactions Map of txhash->transaction.
+     * @param transactions Map of txhash to transaction.
      * @param mode   Whether to abort if there's a pre-existing connection or not.
      * @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
      */

File: core/src/main/java/org/bitcoinj/script/ScriptBuilder.java
Patch:
@@ -145,7 +145,7 @@ public ScriptBuilder smallNum(int num) {
     }
 
     /** Adds the given number as a push data chunk.
-     * This is intended to use for negative numbers or values > 16, and although
+     * This is intended to use for negative numbers or values greater than 16, and although
      * it will accept numbers in the range 0-16 inclusive, the encoding would be
      * considered non-standard.
      * 
@@ -169,7 +169,7 @@ public ScriptBuilder smallNum(int index, int num) {
 
     /**
      * Adds the given number as a push data chunk to the given index in the program.
-     * This is intended to use for negative numbers or values > 16, and although
+     * This is intended to use for negative numbers or values greater than 16, and although
      * it will accept numbers in the range 0-16 inclusive, the encoding would be
      * considered non-standard.
      * 

File: core/src/main/java/org/bitcoinj/store/FullPrunedBlockStore.java
Patch:
@@ -32,7 +32,7 @@
  * 
  * <p>It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height and
  * all those after verifiedHead.height.
- * It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
+ * It is advisable to store any {@link StoredUndoableBlock} which has a {@code height > verifiedHead.height - N}.
  * Because N determines the memory usage, it is recommended that N be customizable. N should be chosen such that
  * re-orgs beyond that point are vanishingly unlikely, for example, a few thousand blocks is a reasonable choice.</p>
  * 

File: core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java
Patch:
@@ -81,7 +81,7 @@ public T followingKeys(DeterministicKey followingKey, DeterministicKey ...follow
         }
 
         /**
-         * Threshold, or {@code (followingKeys.size() + 1) / 2 + 1)} (majority) if unspecified.</p>
+         * <p>Threshold, or {@code (followingKeys.size() + 1) / 2 + 1)} (majority) if unspecified.</p>
          * <p>IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard
          * and such spends won't be processed by peers with default settings, essentially making such transactions almost
          * nonspendable</p>

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -314,8 +314,6 @@ private void writeTransactions(OutputStream stream) throws IOException {
     /**
      * Special handling to check if we have a valid byte array for both header
      * and transactions
-     *
-     * @throws IOException
      */
     @Override
     public byte[] bitcoinSerialize() {

File: core/src/main/java/org/bitcoinj/core/FullPrunedBlockChain.java
Patch:
@@ -341,10 +341,10 @@ protected TransactionOutputChanges connectTransactions(int height, Block block)
         return new TransactionOutputChanges(txOutsCreated, txOutsSpent);
     }
 
-    @Override
     /**
      * Used during reorgs to connect a block previously on a fork
      */
+    @Override
     protected synchronized TransactionOutputChanges connectTransactions(StoredBlock newBlock)
             throws VerificationException, BlockStoreException, PrunedException {
         checkState(lock.isHeldByCurrentThread());

File: core/src/test/java/org/bitcoinj/net/NetworkAbstractionTests.java
Patch:
@@ -363,7 +363,7 @@ public void connectionClosed(ProtobufConnection<TwoWayChannelMessage> handler) {
 
     @Test
     public void largeDataTest() throws Exception {
-        /** Test various large-data handling, essentially testing {@link ProtobufConnection#receiveBytes(java.nio.ByteBuffer)} */
+        // Test various large-data handling, essentially testing {@link ProtobufConnection#receiveBytes(java.nio.ByteBuffer)}
         final SettableFuture<Void> serverConnectionOpen = SettableFuture.create();
         final SettableFuture<Void> clientConnectionOpen = SettableFuture.create();
         final SettableFuture<Void> serverConnectionClosed = SettableFuture.create();

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.common.collect.Lists;
 import org.bitcoinj.core.*;
 import org.bitcoinj.script.Script;
+import org.bitcoinj.script.Script.ScriptType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -959,7 +960,8 @@ public void addUnspentTransactionOutput(UTXO out) throws BlockStoreException {
             s.setLong(4, out.getValue().value);
             s.setBytes(5, out.getScript().getProgram());
             s.setString(6, out.getAddress());
-            s.setInt(7, out.getScript().getScriptType().id);
+            ScriptType scriptType = out.getScript().getScriptType();
+            s.setInt(7, scriptType != null ? scriptType.id : 0);
             s.setBoolean(8, out.isCoinbase());
             s.executeUpdate();
             s.close();

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -959,7 +959,7 @@ public void addUnspentTransactionOutput(UTXO out) throws BlockStoreException {
             s.setLong(4, out.getValue().value);
             s.setBytes(5, out.getScript().getProgram());
             s.setString(6, out.getAddress());
-            s.setInt(7, out.getScript().getScriptType().ordinal());
+            s.setInt(7, out.getScript().getScriptType().id);
             s.setBoolean(8, out.isCoinbase());
             s.executeUpdate();
             s.close();

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -59,7 +59,7 @@ public enum ScriptType {
         // Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
         NO_TYPE,
         P2PKH, // pay to pubkey hash (aka pay to address)
-        PUB_KEY, // pay to pubkey
+        P2PK, // pay to pubkey
         P2SH, // pay to script hash
         P2WPKH, // pay to witness pubkey hash
         P2WSH, // pay to witness script hash
@@ -1608,7 +1608,7 @@ public ScriptType getScriptType() {
         if (ScriptPattern.isPayToPubKeyHash(this)) {
             type = ScriptType.P2PKH;
         } else if (ScriptPattern.isPayToPubKey(this)) {
-            type = ScriptType.PUB_KEY;
+            type = ScriptType.P2PK;
         } else if (ScriptPattern.isPayToScriptHash(this)) {
             type = ScriptType.P2SH;
         }

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -1366,7 +1366,7 @@ public boolean isTimeLocked() {
     /**
      * A transaction has a relative lock time
      * (<a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP 68</a>) if it is version 2 or
-     * higher and at least one of its inputs has its {@link TransactionInput.SEQUENCE_LOCKTIME_DISABLE_FLAG} cleared.
+     * higher and at least one of its inputs has its {@link TransactionInput#SEQUENCE_LOCKTIME_DISABLE_FLAG} cleared.
      */
     public boolean hasRelativeLockTime() {
         if (version < 2)

File: core/src/main/java/org/bitcoinj/core/Bech32.java
Patch:
@@ -143,7 +143,7 @@ public static Bech32Data decode(final String str) throws AddressFormatException
             }
         }
         final int pos = str.lastIndexOf('1');
-        if (pos < 1) throw new AddressFormatException("Missing human-readable part");
+        if (pos < 1) throw new AddressFormatException.InvalidPrefix("Missing human-readable part");
         final int dataPartLength = str.length() - 1 - pos;
         if (dataPartLength < 6) throw new AddressFormatException.InvalidDataLength("Data part too short: " + dataPartLength);
         byte[] values = new byte[dataPartLength];

File: core/src/main/java/org/bitcoinj/core/DumpedPrivateKey.java
Patch:
@@ -52,7 +52,7 @@ public static DumpedPrivateKey fromBase58(@Nullable NetworkParameters params, St
             for (NetworkParameters p : Networks.get())
                 if (version == p.getDumpedPrivateKeyHeader())
                     return new DumpedPrivateKey(p, bytes);
-            throw new AddressFormatException("No network found for version " + version);
+            throw new AddressFormatException.InvalidPrefix("No network found for version " + version);
         } else {
             if (version == params.getDumpedPrivateKeyHeader())
                 return new DumpedPrivateKey(params, bytes);

File: core/src/main/java/org/bitcoinj/core/LegacyAddress.java
Patch:
@@ -151,7 +151,7 @@ public static LegacyAddress fromBase58(@Nullable NetworkParameters params, Strin
                 else if (version == p.getP2SHHeader())
                     return new LegacyAddress(p, true, bytes);
             }
-            throw new AddressFormatException("No network found for " + base58);
+            throw new AddressFormatException.InvalidPrefix("No network found for " + base58);
         } else {
             if (version == params.getAddressHeader())
                 return new LegacyAddress(params, false, bytes);

File: core/src/main/java/org/bitcoinj/core/SegwitAddress.java
Patch:
@@ -177,7 +177,7 @@ public static SegwitAddress fromBech32(@Nullable NetworkParameters params, Strin
                 if (bechData.hrp.equals(p.getSegwitAddressHrp()))
                     return new SegwitAddress(p, bechData.data);
             }
-            throw new AddressFormatException("No network found for " + bech32);
+            throw new AddressFormatException.InvalidPrefix("No network found for " + bech32);
         } else {
             if (bechData.hrp.equals(params.getSegwitAddressHrp()))
                 return new SegwitAddress(params, bechData.data);

File: core/src/main/java/org/bitcoinj/crypto/BIP38PrivateKey.java
Patch:
@@ -60,7 +60,7 @@ public static BIP38PrivateKey fromBase58(NetworkParameters params, String base58
         byte[] bytes = Arrays.copyOfRange(versionAndDataBytes, 1, versionAndDataBytes.length);
 
         if (version != 0x01)
-            throw new AddressFormatException("Mismatched version number: " + version);
+            throw new AddressFormatException.InvalidPrefix("Mismatched version number: " + version);
         if (bytes.length != 38)
             throw new AddressFormatException.InvalidDataLength("Wrong number of bytes: " + bytes.length);
         boolean hasLotAndSequence = (bytes[1] & 0x04) != 0; // bit 2

File: core/src/main/java/org/bitcoinj/core/Base58.java
Patch:
@@ -25,7 +25,7 @@
  * <p>
  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
  * <p>
- * You may want to consider working with {@link VersionedChecksummedBytes} instead, which
+ * You may want to consider working with {@link PrefixedChecksummedBytes} instead, which
  * adds support for testing the prefix and suffix bytes commonly found in addresses.
  * <p>
  * Satoshi explains: why base-58 instead of standard base-64 encoding?

File: core/src/main/java/org/bitcoinj/core/DumpedPrivateKey.java
Patch:
@@ -30,7 +30,7 @@
  * bytes with a header byte and 4 checksum bytes at the end. If there are 33 private key bytes instead of 32, then
  * the last byte is a discriminator value for the compressed pubkey.
  */
-public class DumpedPrivateKey extends VersionedChecksummedBytes {
+public class DumpedPrivateKey extends PrefixedChecksummedBytes {
 
     /**
      * Construct a private key from its Base58 representation.

File: core/src/main/java/org/bitcoinj/core/ECKey.java
Patch:
@@ -1268,7 +1268,7 @@ private String toString(boolean includePrivate, @Nullable KeyParameter aesKey, N
 
     public void formatKeyWithAddress(boolean includePrivateKeys, @Nullable KeyParameter aesKey, StringBuilder builder,
             NetworkParameters params) {
-        final Address address = Address.fromKey(params, this);
+        final LegacyAddress address = LegacyAddress.fromKey(params, this);
         builder.append("  addr:");
         builder.append(address.toString());
         builder.append("  hash160:");

File: core/src/main/java/org/bitcoinj/core/GetAddrMessage.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * <p>Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer. Not to
- * be confused with {@link Address} which is sort of like an account number.</p>
+ * be confused with {@link LegacyAddress} which is sort of like an account number.</p>
  * 
  * <p>Instances of this class are not safe for use by multiple threads.</p>
  */

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -317,7 +317,7 @@ public long getPacketMagic() {
     }
 
     /**
-     * First byte of a base58 encoded address. See {@link org.bitcoinj.core.Address}. This is the same as acceptableAddressCodes[0] and
+     * First byte of a base58 encoded address. See {@link org.bitcoinj.core.LegacyAddress}. This is the same as acceptableAddressCodes[0] and
      * is the one used for "normal" addresses. Other types of address may be encountered with version codes found in
      * the acceptableAddressCodes array.
      */

File: core/src/main/java/org/bitcoinj/core/SegwitAddress.java
Patch:
@@ -42,7 +42,7 @@
  * segwit address.
  * </p>
  */
-public class SegwitAddress extends AbstractAddress {
+public class SegwitAddress extends Address {
     public static final int WITNESS_PROGRAM_LENGTH_PKH = 20;
     public static final int WITNESS_PROGRAM_LENGTH_SH = 32;
     public static final int WITNESS_PROGRAM_MIN_LENGTH = 2;

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -884,7 +884,7 @@ public TransactionOutput addOutput(TransactionOutput to) {
     /**
      * Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
      */
-    public TransactionOutput addOutput(Coin value, Address address) {
+    public TransactionOutput addOutput(Coin value, LegacyAddress address) {
         return addOutput(new TransactionOutput(params, this, value, address));
     }
 

File: core/src/main/java/org/bitcoinj/core/UTXOProvider.java
Patch:
@@ -33,7 +33,7 @@ public interface UTXOProvider {
      * @return The list of transaction outputs.
      * @throws UTXOProviderException If there is an error.
      */
-    List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXOProviderException;
+    List<UTXO> getOpenTransactionOutputs(List<LegacyAddress> addresses) throws UTXOProviderException;
 
     /**
      * Get the height of the chain head.

File: core/src/main/java/org/bitcoinj/crypto/BIP38PrivateKey.java
Patch:
@@ -35,7 +35,7 @@
  * Implementation of <a href="https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki">BIP 38</a>
  * passphrase-protected private keys. Currently, only decryption is supported.
  */
-public class BIP38PrivateKey extends VersionedChecksummedBytes {
+public class BIP38PrivateKey extends PrefixedChecksummedBytes {
     public final boolean ecMultiply;
     public final boolean compressed;
     public final boolean hasLotAndSequence;
@@ -117,7 +117,7 @@ public String toBase58() {
     public ECKey decrypt(String passphrase) throws BadPassphraseException {
         String normalizedPassphrase = Normalizer.normalize(passphrase, Normalizer.Form.NFC);
         ECKey key = ecMultiply ? decryptEC(normalizedPassphrase) : decryptNoEC(normalizedPassphrase);
-        Sha256Hash hash = Sha256Hash.twiceOf(Address.fromKey(params, key).toString().getBytes(Charsets.US_ASCII));
+        Sha256Hash hash = Sha256Hash.twiceOf(LegacyAddress.fromKey(params, key).toString().getBytes(Charsets.US_ASCII));
         byte[] actualAddressHash = Arrays.copyOfRange(hash.getBytes(), 0, 4);
         if (!Arrays.equals(actualAddressHash, addressHash))
             throw new BadPassphraseException();

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -617,7 +617,7 @@ public String toString() {
     @Override
     public void formatKeyWithAddress(boolean includePrivateKeys, @Nullable KeyParameter aesKey, StringBuilder builder,
             NetworkParameters params) {
-        final Address address = Address.fromKey(params, this);
+        final LegacyAddress address = LegacyAddress.fromKey(params, this);
         builder.append("  addr:").append(address);
         builder.append("  hash160:").append(Utils.HEX.encode(getPubKeyHash()));
         builder.append("  (").append(getPathAsString()).append(")\n");

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java
Patch:
@@ -245,7 +245,7 @@ private synchronized Transaction makeUnsignedChannelContract(Coin valueToMe) thr
         // Our output always comes first.
         // TODO: We should drop myKey in favor of output key + multisig key separation
         // (as its always obvious who the client is based on T2 output order)
-        tx.addOutput(valueToMe, Address.fromKey(wallet.getParams(), myKey));
+        tx.addOutput(valueToMe, LegacyAddress.fromKey(wallet.getParams(), myKey));
         return tx;
     }
 

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -220,7 +220,7 @@ public synchronized ListenableFuture<PaymentChannelServerState> provideContract(
     protected synchronized SendRequest makeUnsignedChannelContract(Coin valueToMe) {
         Transaction tx = new Transaction(wallet.getParams());
         if (!getTotalValue().subtract(valueToMe).equals(Coin.ZERO)) {
-            tx.addOutput(getTotalValue().subtract(valueToMe), Address.fromKey(wallet.getParams(), getClientKey()));
+            tx.addOutput(getTotalValue().subtract(valueToMe), LegacyAddress.fromKey(wallet.getParams(), getClientKey()));
         }
         tx.addInput(contract.getOutput(0));
         return SendRequest.forTx(tx);

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelV1ClientState.java
Patch:
@@ -163,10 +163,10 @@ public synchronized void initiate(@Nullable KeyParameter userKey, ClientChannelP
             final Coin valueAfterFee = totalValue.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
             if (Transaction.MIN_NONDUST_OUTPUT.compareTo(valueAfterFee) > 0)
                 throw new ValueOutOfRangeException("totalValue too small to use");
-            refundTx.addOutput(valueAfterFee, Address.fromKey(params, myKey));
+            refundTx.addOutput(valueAfterFee, LegacyAddress.fromKey(params, myKey));
             refundFees = multisigFee.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
         } else {
-            refundTx.addOutput(totalValue, Address.fromKey(params, myKey));
+            refundTx.addOutput(totalValue, LegacyAddress.fromKey(params, myKey));
             refundFees = multisigFee;
         }
         refundTx.getConfidence().setSource(TransactionConfidence.Source.SELF);

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelV2ClientState.java
Patch:
@@ -134,10 +134,10 @@ public synchronized void initiate(@Nullable KeyParameter userKey, ClientChannelP
             final Coin valueAfterFee = totalValue.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
             if (Transaction.MIN_NONDUST_OUTPUT.compareTo(valueAfterFee) > 0)
                 throw new ValueOutOfRangeException("totalValue too small to use");
-            refundTx.addOutput(valueAfterFee, Address.fromKey(params, myKey));
+            refundTx.addOutput(valueAfterFee, LegacyAddress.fromKey(params, myKey));
             refundFees = multisigFee.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
         } else {
-            refundTx.addOutput(totalValue, Address.fromKey(params, myKey));
+            refundTx.addOutput(totalValue, LegacyAddress.fromKey(params, myKey));
             refundFees = multisigFee;
         }
 

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocol.java
Patch:
@@ -66,7 +66,7 @@ public class PaymentProtocol {
      * @return created payment request, in its builder form
      */
     public static Protos.PaymentRequest.Builder createPaymentRequest(NetworkParameters params,
-            @Nullable Coin amount, Address toAddress, @Nullable String memo, @Nullable String paymentUrl,
+            @Nullable Coin amount, LegacyAddress toAddress, @Nullable String memo, @Nullable String paymentUrl,
             @Nullable byte[] merchantData) {
         return createPaymentRequest(params, ImmutableList.of(createPayToAddressOutput(amount, toAddress)), memo,
                 paymentUrl, merchantData);
@@ -292,7 +292,7 @@ public String toString() {
      * @return created payment message
      */
     public static Protos.Payment createPaymentMessage(List<Transaction> transactions,
-            @Nullable Coin refundAmount, @Nullable Address refundAddress, @Nullable String memo,
+            @Nullable Coin refundAmount, @Nullable LegacyAddress refundAddress, @Nullable String memo,
             @Nullable byte[] merchantData) {
         if (refundAddress != null) {
             if (refundAmount == null)
@@ -397,7 +397,7 @@ public static Ack parsePaymentAck(Protos.PaymentACK paymentAck) {
      * @param address address to pay to
      * @return output
      */
-    public static Protos.Output createPayToAddressOutput(@Nullable Coin amount, Address address) {
+    public static Protos.Output createPayToAddressOutput(@Nullable Coin amount, LegacyAddress address) {
         Protos.Output.Builder output = Protos.Output.newBuilder();
         if (amount != null) {
             final NetworkParameters params = address.getParameters();

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentSession.java
Patch:
@@ -316,7 +316,7 @@ public SendRequest getSendRequest() {
      * @param memo is a message to include in the payment message sent to the merchant.
      */
     @Nullable
-    public ListenableFuture<PaymentProtocol.Ack> sendPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)
+    public ListenableFuture<PaymentProtocol.Ack> sendPayment(List<Transaction> txns, @Nullable LegacyAddress refundAddr, @Nullable String memo)
             throws PaymentProtocolException, VerificationException, IOException {
         Protos.Payment payment = getPayment(txns, refundAddr, memo);
         if (payment == null)
@@ -341,7 +341,7 @@ public ListenableFuture<PaymentProtocol.Ack> sendPayment(List<Transaction> txns,
      * @param memo is a message to include in the payment message sent to the merchant.
      */
     @Nullable
-    public Protos.Payment getPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)
+    public Protos.Payment getPayment(List<Transaction> txns, @Nullable LegacyAddress refundAddr, @Nullable String memo)
             throws IOException, PaymentProtocolException.InvalidNetwork {
         if (paymentDetails.hasPaymentUrl()) {
             for (Transaction tx : txns)

File: core/src/main/java/org/bitcoinj/script/ScriptPattern.java
Patch:
@@ -17,7 +17,7 @@
 
 package org.bitcoinj.script;
 
-import org.bitcoinj.core.Address;
+import org.bitcoinj.core.LegacyAddress;
 
 import java.math.BigInteger;
 import java.util.List;
@@ -41,7 +41,7 @@ public static boolean isPayToPubKeyHash(Script script) {
                chunks.get(0).equalsOpCode(OP_DUP) &&
                chunks.get(1).equalsOpCode(OP_HASH160) &&
                chunks.get(2).data != null &&
-               chunks.get(2).data.length == Address.LENGTH &&
+               chunks.get(2).data.length == LegacyAddress.LENGTH &&
                chunks.get(3).equalsOpCode(OP_EQUALVERIFY) &&
                chunks.get(4).equalsOpCode(OP_CHECKSIG);
     }
@@ -70,7 +70,7 @@ public static boolean isPayToScriptHash(Script script) {
                chunks.get(0).equalsOpCode(OP_HASH160) &&
                chunks.get(1).opcode == 0x14 &&
                chunks.get(1).data != null &&
-               chunks.get(1).data.length == Address.LENGTH &&
+               chunks.get(1).data.length == LegacyAddress.LENGTH &&
                chunks.get(2).equalsOpCode(OP_EQUAL);
     }
 

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -1124,7 +1124,7 @@ public void deleteStore() throws BlockStoreException {
      *         address, the return value is 0.
      * @throws BlockStoreException If there is an error getting the balance.
      */
-    public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreException {
+    public BigInteger calculateBalanceForAddress(LegacyAddress address) throws BlockStoreException {
         maybeConnect();
         PreparedStatement s = null;
         try {
@@ -1150,13 +1150,13 @@ public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreE
     }
 
     @Override
-    public List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXOProviderException {
+    public List<UTXO> getOpenTransactionOutputs(List<LegacyAddress> addresses) throws UTXOProviderException {
         PreparedStatement s = null;
         List<UTXO> outputs = new ArrayList<>();
         try {
             maybeConnect();
             s = conn.get().prepareStatement(getTransactionOutputSelectSQL());
-            for (Address address : addresses) {
+            for (LegacyAddress address : addresses) {
                 s.setString(1, address.toString());
                 ResultSet rs = s.executeQuery();
                 while (rs.next()) {

File: core/src/main/java/org/bitcoinj/store/MemoryFullPrunedBlockStore.java
Patch:
@@ -412,13 +412,13 @@ public int getChainHeadHeight() throws UTXOProviderException {
     }
 
     @Override
-    public List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXOProviderException {
+    public List<UTXO> getOpenTransactionOutputs(List<LegacyAddress> addresses) throws UTXOProviderException {
         // This is *NOT* optimal: We go through all the outputs and select the ones we are looking for.
         // If someone uses this store for production then they have a lot more to worry about than an inefficient impl :)
         List<UTXO> foundOutputs = new ArrayList<>();
         List<UTXO> outputsList = transactionOutputMap.values();
         for (UTXO output : outputsList) {
-            for (Address address : addresses) {
+            for (LegacyAddress address : addresses) {
                 if (output.getAddress().equals(address.toString())) {
                     foundOutputs.add(output);
                 }

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -261,7 +261,7 @@ public void testGetOpenTransactionOutputs() throws Exception {
         // Create bitcoin spend of 1 BTC.
         ECKey toKey = new ECKey();
         Coin amount = Coin.valueOf(100000000);
-        Address address = Address.fromKey(PARAMS, toKey);
+        LegacyAddress address = LegacyAddress.fromKey(PARAMS, toKey);
         Coin totalAmount = Coin.ZERO;
 
         Transaction t = new Transaction(PARAMS);
@@ -328,7 +328,7 @@ public void testUTXOProviderWithWallet() throws Exception {
         // Create another spend of 1/2 the value of BTC we have available using the wallet (store coin selector).
         ECKey toKey2 = new ECKey();
         Coin amount2 = amount.divide(2);
-        Address address2 = Address.fromKey(PARAMS, toKey2);
+        LegacyAddress address2 = LegacyAddress.fromKey(PARAMS, toKey2);
         SendRequest req = SendRequest.to(address2, amount2);
         wallet.completeTx(req);
         wallet.commitTx(req.tx);

File: core/src/test/java/org/bitcoinj/core/Base58Test.java
Patch:
@@ -46,7 +46,7 @@ public void testEncode() throws Exception {
 
     @Test
     public void testEncodeChecked_address() throws Exception {
-        String encoded = Base58.encodeChecked(111, new byte[Address.LENGTH]);
+        String encoded = Base58.encodeChecked(111, new byte[LegacyAddress.LENGTH]);
         assertEquals("mfWxJ45yp2SFn7UciZyNpvDKrzbhyfKrY8", encoded);
     }
 

File: core/src/test/java/org/bitcoinj/core/BloomFilterTest.java
Patch:
@@ -74,7 +74,7 @@ public void walletTest() throws Exception {
 
         DumpedPrivateKey privKey = DumpedPrivateKey.fromBase58(MAINNET, "5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C");
 
-        Address addr = Address.fromKey(MAINNET, privKey.getKey());
+        LegacyAddress addr = LegacyAddress.fromKey(MAINNET, privKey.getKey());
         assertTrue(addr.toString().equals("17Wx1GQfyPTNWpQMHrTwRSMTCAonSiZx9e"));
 
         KeyChainGroup group = new KeyChainGroup(MAINNET);

File: core/src/test/java/org/bitcoinj/core/FilteredBlockAndPartialMerkleTreeTests.java
Patch:
@@ -92,8 +92,8 @@ public void createFilteredBlock() throws Exception {
         ECKey key1 = new ECKey();
         ECKey key2 = new ECKey();
         Transaction tx1 = FakeTxBuilder.createFakeTx(UNITTEST, Coin.COIN,  key1);
-        Transaction tx2 = FakeTxBuilder.createFakeTx(UNITTEST, Coin.FIFTY_COINS, Address.fromKey(UNITTEST, key2));
-        Block block = FakeTxBuilder.makeSolvedTestBlock(UNITTEST.getGenesisBlock(), Address.fromBase58(UNITTEST, "msg2t2V2sWNd85LccoddtWysBTR8oPnkzW"), tx1, tx2);
+        Transaction tx2 = FakeTxBuilder.createFakeTx(UNITTEST, Coin.FIFTY_COINS, LegacyAddress.fromKey(UNITTEST, key2));
+        Block block = FakeTxBuilder.makeSolvedTestBlock(UNITTEST.getGenesisBlock(), LegacyAddress.fromBase58(UNITTEST, "msg2t2V2sWNd85LccoddtWysBTR8oPnkzW"), tx1, tx2);
         BloomFilter filter = new BloomFilter(4, 0.1, 1);
         filter.insert(key1);
         filter.insert(key2);

File: core/src/test/java/org/bitcoinj/core/ParseByteCacheTest.java
Patch:
@@ -92,17 +92,17 @@ public void setUp() throws Exception {
         
         Transaction tx1 = createFakeTx(UNITTEST,
                 valueOf(2, 0),
-                Address.fromKey(UNITTEST, wallet.currentReceiveKey()));
+                LegacyAddress.fromKey(UNITTEST, wallet.currentReceiveKey()));
         
         // add a second input so can test granularity of byte cache.
         Transaction prevTx = new Transaction(UNITTEST);
-        TransactionOutput prevOut = new TransactionOutput(UNITTEST, prevTx, COIN, Address.fromKey(UNITTEST, wallet.currentReceiveKey()));
+        TransactionOutput prevOut = new TransactionOutput(UNITTEST, prevTx, COIN, LegacyAddress.fromKey(UNITTEST, wallet.currentReceiveKey()));
         prevTx.addOutput(prevOut);
         // Connect it.
         tx1.addInput(prevOut);
         
         Transaction tx2 = createFakeTx(UNITTEST, COIN,
-                Address.fromKey(UNITTEST, new ECKey()));
+                LegacyAddress.fromKey(UNITTEST, new ECKey()));
 
         Block b1 = createFakeBlock(blockStore, BLOCK_HEIGHT_GENESIS, tx1, tx2).block;
 

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -245,7 +245,7 @@ public void receiveTxBroadcastOnAddedWallet() throws Exception {
         
         Wallet wallet2 = new Wallet(UNITTEST);
         ECKey key2 = wallet2.freshReceiveKey();
-        Address address2 = Address.fromKey(UNITTEST, key2);
+        LegacyAddress address2 = LegacyAddress.fromKey(UNITTEST, key2);
         
         peerGroup.addWallet(wallet2);
         blockChain.addWallet(wallet2);
@@ -804,7 +804,7 @@ public void autoRescanOnKeyExhaustion() throws Exception {
         Coin expectedBalance = Coin.ZERO;
         Block prev = blockStore.getChainHead().getHeader();
         for (ECKey key1 : keys) {
-            Address addr = Address.fromKey(UNITTEST, key1);
+            LegacyAddress addr = LegacyAddress.fromKey(UNITTEST, key1);
             Block next = FakeTxBuilder.makeSolvedTestBlock(prev, FakeTxBuilder.createFakeTx(UNITTEST, Coin.FIFTY_COINS, addr));
             expectedBalance = expectedBalance.add(next.getTransactions().get(2).getOutput(0).getValue());
             blocks.add(next);

File: core/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -870,7 +870,7 @@ public void run() {
         connect();
         Transaction t1 = new Transaction(UNITTEST);
         t1.addInput(new TransactionInput(UNITTEST, t1, new byte[]{}));
-        t1.addOutput(COIN, Address.fromKey(UNITTEST, new ECKey()));
+        t1.addOutput(COIN, LegacyAddress.fromKey(UNITTEST, new ECKey()));
         Transaction t2 = new Transaction(UNITTEST);
         t2.addInput(t1.getOutput(0));
         t2.addOutput(COIN, wallet.currentChangeAddress());

File: core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java
Patch:
@@ -165,7 +165,7 @@ public void testJavaSerialization() throws Exception {
 
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         new ObjectOutputStream(os).writeObject(address);
-        VersionedChecksummedBytes addressCopy = (VersionedChecksummedBytes) new ObjectInputStream(
+        PrefixedChecksummedBytes addressCopy = (PrefixedChecksummedBytes) new ObjectInputStream(
                 new ByteArrayInputStream(os.toByteArray())).readObject();
 
         assertEquals(address, addressCopy);

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -159,7 +159,7 @@ public void retryFailedBroadcast() throws Exception {
         assertEquals(FIFTY_COINS, wallet.getBalance());
 
         // Now create a spend, and expect the announcement on p1.
-        Address dest = Address.fromKey(UNITTEST, new ECKey());
+        LegacyAddress dest = LegacyAddress.fromKey(UNITTEST, new ECKey());
         Wallet.SendResult sendResult = wallet.sendCoins(peerGroup, dest, COIN);
         assertFalse(sendResult.broadcastComplete.isDone());
         Transaction t1;
@@ -208,7 +208,7 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         });
 
         // Now create a spend, and expect the announcement on p1.
-        Address dest = Address.fromKey(UNITTEST, new ECKey());
+        LegacyAddress dest = LegacyAddress.fromKey(UNITTEST, new ECKey());
         Wallet.SendResult sendResult = wallet.sendCoins(peerGroup, dest, COIN);
         assertNotNull(sendResult.tx);
         Threading.waitForUserCode();

File: core/src/test/java/org/bitcoinj/core/TransactionInputTest.java
Patch:
@@ -38,7 +38,7 @@ public class TransactionInputTest {
     public void testStandardWalletDisconnect() throws Exception {
         Wallet w = new Wallet(new Context(UNITTEST));
         w.setCoinSelector(new AllowUnconfirmedCoinSelector());
-        Address a = w.currentReceiveAddress();
+        LegacyAddress a = w.currentReceiveAddress();
         Transaction tx1 = FakeTxBuilder.createFakeTxWithoutChangeAddress(UNITTEST, Coin.COIN, a);
         w.receivePending(tx1, null);
         Transaction tx2 = new Transaction(UNITTEST);
@@ -59,7 +59,7 @@ public void testStandardWalletDisconnect() throws Exception {
     @Test
     public void testUTXOWalletDisconnect() throws Exception {
         Wallet w = new Wallet(new Context(UNITTEST));
-        Address a = w.currentReceiveAddress();
+        LegacyAddress a = w.currentReceiveAddress();
         final UTXO utxo = new UTXO(Sha256Hash.of(new byte[] { 1, 2, 3 }), 1, Coin.COIN, 0, false,
                 ScriptBuilder.createOutputScript(a));
         w.setUTXOProvider(new UTXOProvider() {
@@ -69,7 +69,7 @@ public NetworkParameters getParams() {
             }
 
             @Override
-            public List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXOProviderException {
+            public List<UTXO> getOpenTransactionOutputs(List<LegacyAddress> addresses) throws UTXOProviderException {
                 return Lists.newArrayList(utxo);
             }
 

File: core/src/test/java/org/bitcoinj/core/TransactionOutputTest.java
Patch:
@@ -67,7 +67,7 @@ public void testMultiSigOutputToString() throws Exception {
     @Test
     public void testP2SHOutputScript() throws Exception {
         String P2SHAddressString = "35b9vsyH1KoFT5a5KtrKusaCcPLkiSo1tU";
-        Address P2SHAddress = Address.fromBase58(MAINNET, P2SHAddressString);
+        LegacyAddress P2SHAddress = LegacyAddress.fromBase58(MAINNET, P2SHAddressString);
         Script script = ScriptBuilder.createOutputScript(P2SHAddress);
         Transaction tx = new Transaction(MAINNET);
         tx.addOutput(Coin.COIN, script);

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -40,7 +40,7 @@
  */
 public class TransactionTest {
     private static final NetworkParameters UNITTEST = UnitTestParams.get();
-    private static final Address ADDRESS = Address.fromKey(UNITTEST, new ECKey());
+    private static final LegacyAddress ADDRESS = LegacyAddress.fromKey(UNITTEST, new ECKey());
 
     private Transaction tx;
 
@@ -344,7 +344,7 @@ public void testTheTXByHeightComparator() {
     @Test(expected = ScriptException.class)
     public void testAddSignedInputThrowsExceptionWhenScriptIsNotToRawPubKeyAndIsNotToAddress() {
         ECKey key = new ECKey();
-        Address addr = Address.fromKey(UNITTEST, key);
+        LegacyAddress addr = LegacyAddress.fromKey(UNITTEST, key);
         Transaction fakeTx = FakeTxBuilder.createFakeTx(UNITTEST, Coin.COIN, addr);
 
         Transaction tx = new Transaction(UNITTEST);
@@ -409,7 +409,7 @@ public void optInFullRBF() {
     @Test
     public void testHashForSignatureThreadSafety() {
         Block genesis = UNITTEST.getGenesisBlock();
-        Block block1 = genesis.createNextBlock(Address.fromKey(UNITTEST, new ECKey()),
+        Block block1 = genesis.createNextBlock(LegacyAddress.fromKey(UNITTEST, new ECKey()),
                     genesis.getTransactions().get(0).getOutput(0).getOutPointFor());
 
         final Transaction tx = block1.getTransactions().get(1);

File: core/src/test/java/org/bitcoinj/core/TxConfidenceTableTest.java
Patch:
@@ -38,8 +38,8 @@ public void setup() throws Exception {
         Context context = new Context(UNITTEST);
         table = context.getConfidenceTable();
 
-        Address to = Address.fromKey(UNITTEST, new ECKey());
-        Address change = Address.fromKey(UNITTEST, new ECKey());
+        LegacyAddress to = LegacyAddress.fromKey(UNITTEST, new ECKey());
+        LegacyAddress change = LegacyAddress.fromKey(UNITTEST, new ECKey());
 
         tx1 = FakeTxBuilder.createFakeTxWithChangeAddress(UNITTEST, COIN, to, change);
         tx2 = FakeTxBuilder.createFakeTxWithChangeAddress(UNITTEST, COIN, to, change);

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentProtocolTest.java
Patch:
@@ -46,7 +46,7 @@ public class PaymentProtocolTest {
 
     // static test data
     private static final Coin AMOUNT = Coin.SATOSHI;
-    private static final Address TO_ADDRESS = Address.fromKey(UNITTEST, new ECKey());
+    private static final LegacyAddress TO_ADDRESS = LegacyAddress.fromKey(UNITTEST, new ECKey());
     private static final String MEMO = "memo";
     private static final String PAYMENT_URL = "https://example.com";
     private static final byte[] MERCHANT_DATA = { 0, 1, 2 };
@@ -125,7 +125,7 @@ public void testPaymentMessage() throws Exception {
         List<Transaction> transactions = new LinkedList<>();
         transactions.add(FakeTxBuilder.createFakeTx(UNITTEST, AMOUNT, TO_ADDRESS));
         Coin refundAmount = Coin.SATOSHI;
-        Address refundAddress = Address.fromKey(UNITTEST, new ECKey());
+        LegacyAddress refundAddress = LegacyAddress.fromKey(UNITTEST, new ECKey());
         Payment payment = PaymentProtocol.createPaymentMessage(transactions, refundAmount, refundAddress, MEMO,
                 MERCHANT_DATA);
         byte[] paymentBytes = payment.toByteArray();

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentSessionTest.java
Patch:
@@ -75,7 +75,7 @@ public void testSimplePayment() throws Exception {
         tx.addInput(new TransactionInput(TESTNET, tx, outputToMe.getScriptBytes()));
         ArrayList<Transaction> txns = new ArrayList<>();
         txns.add(tx);
-        Address refundAddr = Address.fromKey(TESTNET, serverKey);
+        LegacyAddress refundAddr = LegacyAddress.fromKey(TESTNET, serverKey);
         paymentSession.sendPayment(txns, refundAddr, paymentMemo);
         assertEquals(1, paymentSession.getPaymentLog().size());
         assertEquals(simplePaymentUrl, paymentSession.getPaymentLog().get(0).getUrl().toString());
@@ -147,7 +147,7 @@ public void testWrongNetwork() throws Exception {
         tx.addInput(new TransactionInput(TESTNET, tx, outputToMe.getScriptBytes()));
         ArrayList<Transaction> txns = new ArrayList<>();
         txns.add(tx);
-        Address refundAddr = Address.fromKey(TESTNET, serverKey);
+        LegacyAddress refundAddr = LegacyAddress.fromKey(TESTNET, serverKey);
         paymentSession.sendPayment(txns, refundAddr, paymentMemo);
         assertEquals(1, paymentSession.getPaymentLog().size());
     }

File: core/src/test/java/org/bitcoinj/script/ScriptPatternTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import com.google.common.collect.Lists;
 
-import org.bitcoinj.core.Address;
+import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.params.MainNetParams;
@@ -37,7 +37,7 @@ public class ScriptPatternTest {
     @Test
     public void testCommonScripts() {
         assertTrue(ScriptPattern.isPayToPubKeyHash(
-                ScriptBuilder.createOutputScript(Address.fromKey(MAINNET, keys.get(0)))
+                ScriptBuilder.createOutputScript(LegacyAddress.fromKey(MAINNET, keys.get(0)))
         ));
         assertTrue(ScriptPattern.isPayToScriptHash(
                 ScriptBuilder.createP2SHOutputScript(2, keys)

File: core/src/test/java/org/bitcoinj/store/LevelDBBlockStoreTest.java
Patch:
@@ -42,7 +42,7 @@ public void basics() throws Exception {
         assertEquals(0, genesis.getHeight());
 
         // Build a new block.
-        Address to = Address.fromBase58(UNITTEST, "mrj2K6txjo2QBcSmuAzHj4nD1oXSEJE1Qo");
+        LegacyAddress to = LegacyAddress.fromBase58(UNITTEST, "mrj2K6txjo2QBcSmuAzHj4nD1oXSEJE1Qo");
         StoredBlock b1 = genesis.build(genesis.getHeader().createNextBlock(to).cloneAsHeader());
         store.put(b1);
         store.setChainHead(b1);

File: core/src/test/java/org/bitcoinj/store/SPVBlockStoreTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.store;
 
-import org.bitcoinj.core.Address;
+import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
 import org.bitcoinj.core.StoredBlock;
@@ -37,7 +37,7 @@ public void basics() throws Exception {
         f.deleteOnExit();
         SPVBlockStore store = new SPVBlockStore(UNITTEST, f);
 
-        Address to = Address.fromKey(UNITTEST, new ECKey());
+        LegacyAddress to = LegacyAddress.fromKey(UNITTEST, new ECKey());
         // Check the first block in a new store is the genesis block.
         StoredBlock genesis = store.getChainHead();
         assertEquals(UNITTEST.getGenesisBlock(), genesis.getHeader());

File: core/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -54,7 +54,7 @@ public class TestWithNetworkConnections {
     protected BlockChain blockChain;
     protected Wallet wallet;
     protected ECKey key;
-    protected Address address;
+    protected LegacyAddress address;
     protected SocketAddress socketAddress;
 
     private NioServer[] peerServers = new NioServer[PEER_SERVERS];
@@ -90,7 +90,7 @@ public void setUp(BlockStore blockStore) throws Exception {
         if (wallet == null) {
             wallet = new Wallet(UNITTEST);
             key = wallet.freshReceiveKey();
-            address = Address.fromKey(UNITTEST, key);
+            address = LegacyAddress.fromKey(UNITTEST, key);
         }
         blockChain = new BlockChain(UNITTEST, wallet, blockStore);
 

File: core/src/test/java/org/bitcoinj/uri/BitcoinURITest.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.bitcoinj.uri;
 
-import org.bitcoinj.core.Address;
+import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.params.MainNetParams;
 import org.bitcoinj.params.TestNet3Params;
 import com.google.common.collect.ImmutableList;
@@ -36,7 +36,7 @@ public class BitcoinURITest {
 
     @Test
     public void testConvertToBitcoinURI() throws Exception {
-        Address goodAddress = Address.fromBase58(MAINNET, MAINNET_GOOD_ADDRESS);
+        LegacyAddress goodAddress = LegacyAddress.fromBase58(MAINNET, MAINNET_GOOD_ADDRESS);
         
         // simple example
         assertEquals("bitcoin:" + MAINNET_GOOD_ADDRESS + "?amount=12.34&label=Hello&message=AMessage", BitcoinURI.convertToBitcoinURI(goodAddress, parseCoin("12.34"), "Hello", "AMessage"));
@@ -79,7 +79,7 @@ public String getUriScheme() {
         };
 
         assertEquals("test:" + MAINNET_GOOD_ADDRESS + "?amount=12.34&label=Hello&message=AMessage",
-             BitcoinURI.convertToBitcoinURI(Address.fromBase58(alternativeParameters, MAINNET_GOOD_ADDRESS), parseCoin("12.34"), "Hello", "AMessage"));
+             BitcoinURI.convertToBitcoinURI(LegacyAddress.fromBase58(alternativeParameters, MAINNET_GOOD_ADDRESS), parseCoin("12.34"), "Hello", "AMessage"));
     }
 
     @Test

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -208,7 +208,7 @@ public void standardOutputs() throws Exception {
         Transaction tx = new Transaction(MAINNET);
         tx.addInput(MAINNET.getGenesisBlock().getTransactions().get(0).getOutput(0));
         // A pay to address output
-        tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(Address.fromKey(MAINNET, key1)));
+        tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(LegacyAddress.fromKey(MAINNET, key1)));
         // A pay to pubkey output
         tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(key1));
         tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(key1));

File: examples/src/main/java/org/bitcoinj/examples/DoubleSpend.java
Patch:
@@ -46,8 +46,8 @@ public static void main(String[] args) throws Exception {
         System.out.println(kit.wallet());
 
         kit.wallet().getBalanceFuture(COIN, Wallet.BalanceType.AVAILABLE).get();
-        Transaction tx1 = kit.wallet().createSend(Address.fromBase58(params, "muYPFNCv7KQEG2ZLM7Z3y96kJnNyXJ53wm"), CENT);
-        Transaction tx2 = kit.wallet().createSend(Address.fromBase58(params, "muYPFNCv7KQEG2ZLM7Z3y96kJnNyXJ53wm"), CENT.add(SATOSHI.multiply(10)));
+        Transaction tx1 = kit.wallet().createSend(LegacyAddress.fromBase58(params, "muYPFNCv7KQEG2ZLM7Z3y96kJnNyXJ53wm"), CENT);
+        Transaction tx2 = kit.wallet().createSend(LegacyAddress.fromBase58(params, "muYPFNCv7KQEG2ZLM7Z3y96kJnNyXJ53wm"), CENT.add(SATOSHI.multiply(10)));
         final Peer peer = kit.peerGroup().getConnectedPeers().get(0);
         peer.addPreMessageReceivedEventListener(Threading.SAME_THREAD,
             new PreMessageReceivedEventListener() {

File: examples/src/main/java/org/bitcoinj/examples/ExamplePaymentChannelClient.java
Patch:
@@ -210,7 +210,7 @@ private void waitForSufficientBalance(Coin amount) {
         ListenableFuture<Coin> balanceFuture = appKit.wallet().getBalanceFuture(amountPlusFee, Wallet.BalanceType.ESTIMATED);
         if (!balanceFuture.isDone()) {
             System.out.println("Please send " + amountPlusFee.toFriendlyString() +
-                    " to " + Address.fromKey(params, myKey));
+                    " to " + LegacyAddress.fromKey(params, myKey));
             Futures.getUnchecked(balanceFuture);
         }
     }

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -40,7 +40,7 @@
  * sends them onwards to an address given on the command line.
  */
 public class ForwardingService {
-    private static Address forwardingAddress;
+    private static LegacyAddress forwardingAddress;
     private static WalletAppKit kit;
 
     public static void main(String[] args) throws Exception {
@@ -65,7 +65,7 @@ public static void main(String[] args) throws Exception {
             filePrefix = "forwarding-service";
         }
         // Parse the address given as the first parameter.
-        forwardingAddress = Address.fromBase58(params, args[0]);
+        forwardingAddress = LegacyAddress.fromBase58(params, args[0]);
 
         // Start up a basic app using a class that automates some boilerplate.
         kit = new WalletAppKit(params, new File("."), filePrefix);
@@ -111,7 +111,7 @@ public void onFailure(Throwable t) {
             }
         });
 
-        Address sendToAddress = Address.fromKey(params, kit.wallet().currentReceiveKey());
+        LegacyAddress sendToAddress = LegacyAddress.fromKey(params, kit.wallet().currentReceiveKey());
         System.out.println("Send coins to: " + sendToAddress);
         System.out.println("Waiting for coins to arrive. Press Ctrl-C to quit.");
 

File: examples/src/main/java/org/bitcoinj/examples/GenerateLowSTests.java
Patch:
@@ -24,7 +24,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import org.bitcoinj.core.Address;
+import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
@@ -82,11 +82,11 @@ public RedeemData findRedeemDataFromScriptHash(byte[] scriptHash) {
 
         final Transaction outputTransaction = new Transaction(params);
         final Transaction inputTransaction = new Transaction(params);
-        final TransactionOutput output = new TransactionOutput(params, inputTransaction, Coin.ZERO, Address.fromKey(params, key));
+        final TransactionOutput output = new TransactionOutput(params, inputTransaction, Coin.ZERO, LegacyAddress.fromKey(params, key));
 
         inputTransaction.addOutput(output);
         outputTransaction.addInput(output);
-        outputTransaction.addOutput(Coin.ZERO, Address.fromKey(params, new ECKey(secureRandom)));
+        outputTransaction.addOutput(Coin.ZERO, LegacyAddress.fromKey(params, new ECKey(secureRandom)));
 
         addOutputs(outputTransaction, bag);
 

File: examples/src/main/java/org/bitcoinj/examples/PrivateKeys.java
Patch:
@@ -50,9 +50,9 @@ public static void main(String[] args) throws Exception {
                 BigInteger privKey = Base58.decodeToBigInteger(args[0]);
                 key = ECKey.fromPrivate(privKey);
             }
-            System.out.println("Address from private key is: " + Address.fromKey(params, key).toString());
+            System.out.println("Address from private key is: " + LegacyAddress.fromKey(params, key).toString());
             // And the address ...
-            Address destination = Address.fromBase58(params, args[1]);
+            LegacyAddress destination = LegacyAddress.fromBase58(params, args[1]);
 
             // Import the private key to a fresh wallet.
             Wallet wallet = new Wallet(params);

File: examples/src/main/java/org/bitcoinj/examples/SendRequest.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String[] args) throws Exception {
 
         // To which address you want to send the coins?
         // The Address class represents a Bitcoin address.
-        Address to = Address.fromBase58(params, "mupBAFeT63hXfeeT4rnAUcpKHDkz1n4fdw");
+        LegacyAddress to = LegacyAddress.fromBase58(params, "mupBAFeT63hXfeeT4rnAUcpKHDkz1n4fdw");
         System.out.println("Send money to: " + to.toString());
 
         // There are different ways to create and publish a SendRequest. This is probably the easiest one.

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -68,7 +68,7 @@ public void send(ActionEvent event) {
         // Address exception cannot happen as we validated it beforehand.
         try {
             Coin amount = Coin.parseCoin(amountEdit.getText());
-            Address destination = Address.fromBase58(Main.params, address.getText());
+            LegacyAddress destination = LegacyAddress.fromBase58(Main.params, address.getText());
             SendRequest req;
             if (amount.equals(Main.bitcoin.wallet().getBalance()))
                 req = SendRequest.emptyWallet(destination);

File: wallettemplate/src/main/java/wallettemplate/controls/BitcoinAddressValidator.java
Patch:
@@ -16,7 +16,7 @@
 
 package wallettemplate.controls;
 
-import org.bitcoinj.core.Address;
+import org.bitcoinj.core.LegacyAddress;
 import org.bitcoinj.core.AddressFormatException;
 import org.bitcoinj.core.NetworkParameters;
 import javafx.scene.Node;
@@ -52,7 +52,7 @@ private void toggleButtons(String current) {
 
     private boolean testAddr(String text) {
         try {
-            Address.fromBase58(params, text);
+            LegacyAddress.fromBase58(params, text);
             return true;
         } catch (AddressFormatException e) {
             return false;

File: wallettemplate/src/main/java/wallettemplate/utils/BitcoinUIModel.java
Patch:
@@ -32,7 +32,7 @@
  * A class that exposes relevant bitcoin stuff as JavaFX bindable properties.
  */
 public class BitcoinUIModel {
-    private SimpleObjectProperty<Address> address = new SimpleObjectProperty<>();
+    private SimpleObjectProperty<LegacyAddress> address = new SimpleObjectProperty<>();
     private SimpleObjectProperty<Coin> balance = new SimpleObjectProperty<>(Coin.ZERO);
     private SimpleDoubleProperty syncProgress = new SimpleDoubleProperty(-1);
     private ProgressBarUpdater syncProgressUpdater = new ProgressBarUpdater();
@@ -77,7 +77,7 @@ protected void doneDownload() {
 
     public ReadOnlyDoubleProperty syncProgressProperty() { return syncProgress; }
 
-    public ReadOnlyObjectProperty<Address> addressProperty() {
+    public ReadOnlyObjectProperty<LegacyAddress> addressProperty() {
         return address;
     }
 

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentSessionTest.java
Patch:
@@ -52,6 +52,7 @@ public class PaymentSessionTest {
 
     @Before
     public void setUp() throws Exception {
+        new Context(TESTNET);
         serverKey = new ECKey();
         tx = new Transaction(TESTNET);
         outputToMe = new TransactionOutput(TESTNET, tx, coin, serverKey);

File: core/src/main/java/org/bitcoinj/core/DumpedPrivateKey.java
Patch:
@@ -69,7 +69,7 @@ private static byte[] encode(byte[] keyBytes, boolean compressed) {
     public DumpedPrivateKey(@Nullable NetworkParameters params, String encoded) throws AddressFormatException {
         super(encoded);
         if (params != null && version != params.getDumpedPrivateKeyHeader())
-            throw new WrongNetworkException(version, new int[]{ params.getDumpedPrivateKeyHeader() });
+            throw new WrongNetworkException(version);
         if (bytes.length != 32 && bytes.length != 33) {
             throw new AddressFormatException("Wrong number of bytes for a private key, not 32 or 33");
         }

File: core/src/main/java/org/bitcoinj/params/MainNetParams.java
Patch:
@@ -40,7 +40,6 @@ public MainNetParams() {
         dumpedPrivateKeyHeader = 128;
         addressHeader = 0;
         p2shHeader = 5;
-        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         port = 8333;
         packetMagic = 0xf9beb4d9L;
         bip32HeaderPub = 0x0488B21E; //The 4 byte header that serializes in base58 to "xpub".

File: core/src/main/java/org/bitcoinj/params/TestNet2Params.java
Patch:
@@ -36,7 +36,6 @@ public TestNet2Params() {
         port = 18333;
         addressHeader = 111;
         p2shHeader = 196;
-        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         interval = INTERVAL;
         targetTimespan = TARGET_TIMESPAN;
         maxTarget = Utils.decodeCompactBits(0x1d0fffffL);

File: core/src/main/java/org/bitcoinj/params/TestNet3Params.java
Patch:
@@ -46,7 +46,6 @@ public TestNet3Params() {
         port = 18333;
         addressHeader = 111;
         p2shHeader = 196;
-        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         dumpedPrivateKeyHeader = 239;
         genesisBlock.setTime(1296688602L);
         genesisBlock.setDifficultyTarget(0x1d00ffffL);

File: core/src/main/java/org/bitcoinj/params/UnitTestParams.java
Patch:
@@ -35,7 +35,6 @@ public UnitTestParams() {
         packetMagic = 0x0b110907;
         addressHeader = 111;
         p2shHeader = 196;
-        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         maxTarget = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
         genesisBlock.setTime(System.currentTimeMillis() / 1000);
         genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);

File: core/src/test/java/org/bitcoinj/core/AddressTest.java
Patch:
@@ -105,7 +105,6 @@ public void errorPaths() {
         } catch (WrongNetworkException e) {
             // Success.
             assertEquals(e.verCode, MainNetParams.get().getAddressHeader());
-            assertTrue(Arrays.equals(e.acceptableVersions, TestNet3Params.get().getAcceptableAddressCodes()));
         } catch (AddressFormatException e) {
             fail();
         }
@@ -128,7 +127,6 @@ class AltNetwork extends MainNetParams {
                 id = "alt.network";
                 addressHeader = 48;
                 p2shHeader = 5;
-                acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
             }
         }
         AltNetwork altNetwork = new AltNetwork();

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -460,8 +460,6 @@ private Wallet spendUnconfirmedChange(Wallet wallet, Transaction t2, KeyParamete
     }
 
     @Test
-    @SuppressWarnings("deprecation")
-    // Having a test for deprecated method getFromAddress() is no evil so we suppress the warning here.
     public void customTransactionSpending() throws Exception {
         // We'll set up a wallet that receives a coin, then sends a coin of lesser value and keeps the change.
         Coin v1 = valueOf(3, 0);
@@ -483,7 +481,8 @@ public void customTransactionSpending() throws Exception {
 
         // Do some basic sanity checks.
         assertEquals(1, t2.getInputs().size());
-        assertEquals(myAddress, t2.getInput(0).getScriptSig().getFromAddress(PARAMS));
+        // check 'from address' -- in a unit test this is fine
+        assertEquals(myAddress, new Address(PARAMS, Utils.sha256hash160(t2.getInput(0).getScriptSig().getPubKey())));
         assertEquals(TransactionConfidence.ConfidenceType.UNKNOWN, t2.getConfidence().getConfidenceType());
 
         // We have NOT proven that the signature is correct!

File: core/src/main/java/org/bitcoinj/crypto/BIP38PrivateKey.java
Patch:
@@ -107,7 +107,7 @@ public BIP38PrivateKey(NetworkParameters params, String encoded) throws AddressF
     public ECKey decrypt(String passphrase) throws BadPassphraseException {
         String normalizedPassphrase = Normalizer.normalize(passphrase, Normalizer.Form.NFC);
         ECKey key = ecMultiply ? decryptEC(normalizedPassphrase) : decryptNoEC(normalizedPassphrase);
-        Sha256Hash hash = Sha256Hash.twiceOf(key.toAddress(params).toString().getBytes(Charsets.US_ASCII));
+        Sha256Hash hash = Sha256Hash.twiceOf(Address.fromKey(params, key).toString().getBytes(Charsets.US_ASCII));
         byte[] actualAddressHash = Arrays.copyOfRange(hash.getBytes(), 0, 4);
         if (!Arrays.equals(actualAddressHash, addressHash))
             throw new BadPassphraseException();

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -617,7 +617,7 @@ public String toString() {
     @Override
     public void formatKeyWithAddress(boolean includePrivateKeys, @Nullable KeyParameter aesKey, StringBuilder builder,
             NetworkParameters params) {
-        final Address address = toAddress(params);
+        final Address address = Address.fromKey(params, this);
         builder.append("  addr:").append(address);
         builder.append("  hash160:").append(Utils.HEX.encode(getPubKeyHash()));
         builder.append("  (").append(getPathAsString()).append(")\n");

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java
Patch:
@@ -245,7 +245,7 @@ private synchronized Transaction makeUnsignedChannelContract(Coin valueToMe) thr
         // Our output always comes first.
         // TODO: We should drop myKey in favor of output key + multisig key separation
         // (as its always obvious who the client is based on T2 output order)
-        tx.addOutput(valueToMe, myKey.toAddress(wallet.getParams()));
+        tx.addOutput(valueToMe, Address.fromKey(wallet.getParams(), myKey));
         return tx;
     }
 

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -220,7 +220,7 @@ public synchronized ListenableFuture<PaymentChannelServerState> provideContract(
     protected synchronized SendRequest makeUnsignedChannelContract(Coin valueToMe) {
         Transaction tx = new Transaction(wallet.getParams());
         if (!getTotalValue().subtract(valueToMe).equals(Coin.ZERO)) {
-            tx.addOutput(getTotalValue().subtract(valueToMe), getClientKey().toAddress(wallet.getParams()));
+            tx.addOutput(getTotalValue().subtract(valueToMe), Address.fromKey(wallet.getParams(), getClientKey()));
         }
         tx.addInput(contract.getOutput(0));
         return SendRequest.forTx(tx);

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelV1ClientState.java
Patch:
@@ -163,10 +163,10 @@ public synchronized void initiate(@Nullable KeyParameter userKey, ClientChannelP
             final Coin valueAfterFee = totalValue.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
             if (Transaction.MIN_NONDUST_OUTPUT.compareTo(valueAfterFee) > 0)
                 throw new ValueOutOfRangeException("totalValue too small to use");
-            refundTx.addOutput(valueAfterFee, myKey.toAddress(params));
+            refundTx.addOutput(valueAfterFee, Address.fromKey(params, myKey));
             refundFees = multisigFee.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
         } else {
-            refundTx.addOutput(totalValue, myKey.toAddress(params));
+            refundTx.addOutput(totalValue, Address.fromKey(params, myKey));
             refundFees = multisigFee;
         }
         refundTx.getConfidence().setSource(TransactionConfidence.Source.SELF);

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelV2ClientState.java
Patch:
@@ -134,10 +134,10 @@ public synchronized void initiate(@Nullable KeyParameter userKey, ClientChannelP
             final Coin valueAfterFee = totalValue.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
             if (Transaction.MIN_NONDUST_OUTPUT.compareTo(valueAfterFee) > 0)
                 throw new ValueOutOfRangeException("totalValue too small to use");
-            refundTx.addOutput(valueAfterFee, myKey.toAddress(params));
+            refundTx.addOutput(valueAfterFee, Address.fromKey(params, myKey));
             refundFees = multisigFee.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
         } else {
-            refundTx.addOutput(totalValue, myKey.toAddress(params));
+            refundTx.addOutput(totalValue, Address.fromKey(params, myKey));
             refundFees = multisigFee;
         }
 

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -345,7 +345,7 @@ public Address getToAddress(NetworkParameters params, boolean forcePayToPubKey)
         else if (ScriptPattern.isPayToScriptHash(this))
             return Address.fromP2SHScript(params, this);
         else if (forcePayToPubKey && ScriptPattern.isPayToPubKey(this))
-            return ECKey.fromPublicOnly(getPubKey()).toAddress(params);
+            return Address.fromKey(params, ECKey.fromPublicOnly(getPubKey()));
         else
             throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type");
     }

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -188,7 +188,7 @@ public Address currentAddress(KeyChain.KeyPurpose purpose) {
             }
             return current;
         } else {
-            return currentKey(purpose).toAddress(params);
+            return Address.fromKey(params, currentKey(purpose));
         }
     }
 
@@ -242,7 +242,7 @@ public Address freshAddress(KeyChain.KeyPurpose purpose) {
             currentAddresses.put(purpose, freshAddress);
             return freshAddress;
         } else {
-            return freshKey(purpose).toAddress(params);
+            return Address.fromKey(params, freshKey(purpose));
         }
     }
 
@@ -727,7 +727,7 @@ public DeterministicKeyChain upgradeToDeterministic(long keyRotationTimeSecs, @N
         } else {
             log.info("Wallet with existing HD chain is being re-upgraded due to change in key rotation time.");
         }
-        log.info("Instantiating new HD chain using oldest non-rotating private key (address: {})", keyToUse.toAddress(params));
+        log.info("Instantiating new HD chain using oldest non-rotating private key (address: {})", Address.fromKey(params, keyToUse));
         byte[] entropy = checkNotNull(keyToUse.getSecretBytes());
         // Private keys should be at least 128 bits long.
         checkState(entropy.length >= DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -545,7 +545,7 @@ public List<Address> getIssuedReceiveAddresses() {
         final List<ECKey> keys = getIssuedReceiveKeys();
         List<Address> addresses = new ArrayList<>(keys.size());
         for (ECKey key : keys)
-            addresses.add(key.toAddress(getParams()));
+            addresses.add(Address.fromKey(getParams(), key));
         return addresses;
     }
 

File: core/src/test/java/org/bitcoinj/core/BloomFilterTest.java
Patch:
@@ -73,7 +73,7 @@ public void walletTest() throws Exception {
 
         DumpedPrivateKey privKey = DumpedPrivateKey.fromBase58(params, "5Kg1gnAjaLfKiwhhPpGS3QfRg2m6awQvaj98JCZBZQ5SuS2F15C");
 
-        Address addr = privKey.getKey().toAddress(params);
+        Address addr = Address.fromKey(params, privKey.getKey());
         assertTrue(addr.toString().equals("17Wx1GQfyPTNWpQMHrTwRSMTCAonSiZx9e"));
 
         KeyChainGroup group = new KeyChainGroup(params);

File: core/src/test/java/org/bitcoinj/core/ECKeyTest.java
Patch:
@@ -186,7 +186,7 @@ public void base58Encoding() throws Exception {
         String privkey = "92shANodC6Y4evT5kFzjNFQAdjqTtHAnDTLzqBBq4BbKUPyx6CD";
         ECKey key = DumpedPrivateKey.fromBase58(TestNet3Params.get(), privkey).getKey();
         assertEquals(privkey, key.getPrivateKeyEncoded(TestNet3Params.get()).toString());
-        assertEquals(addr, key.toAddress(TestNet3Params.get()).toString());
+        assertEquals(addr, Address.fromKey(TestNet3Params.get(), key).toString());
     }
 
     @Test
@@ -214,7 +214,7 @@ public void signTextMessage() throws Exception {
         ECKey key = new ECKey();
         String message = "";
         String signatureBase64 = key.signMessage(message);
-        log.info("Message signed with " + key.toAddress(MainNetParams.get()) + ": " + signatureBase64);
+        log.info("Message signed with " + Address.fromKey(MainNetParams.get(), key) + ": " + signatureBase64);
         // Should verify correctly.
         key.verifyMessage(message, signatureBase64);
         try {
@@ -232,7 +232,7 @@ public void verifyMessage() throws Exception {
         String sigBase64 = "HxNZdo6ggZ41hd3mM3gfJRqOQPZYcO8z8qdX2BwmpbF11CaOQV+QiZGGQxaYOncKoNW61oRuSMMF8udfK54XqI8=";
         Address expectedAddress = Address.fromBase58(MainNetParams.get(), "14YPSNPi6NSXnUxtPAsyJSuw3pv7AU3Cag");
         ECKey key = ECKey.signedMessageToKey(message, sigBase64);
-        Address gotAddress = key.toAddress(MainNetParams.get());
+        Address gotAddress = Address.fromKey(MainNetParams.get(), key);
         assertEquals(expectedAddress, gotAddress);
     }
 

File: core/src/test/java/org/bitcoinj/core/FilteredBlockAndPartialMerkleTreeTests.java
Patch:
@@ -92,7 +92,7 @@ public void createFilteredBlock() throws Exception {
         ECKey key1 = new ECKey();
         ECKey key2 = new ECKey();
         Transaction tx1 = FakeTxBuilder.createFakeTx(PARAMS, Coin.COIN,  key1);
-        Transaction tx2 = FakeTxBuilder.createFakeTx(PARAMS, Coin.FIFTY_COINS, key2.toAddress(PARAMS));
+        Transaction tx2 = FakeTxBuilder.createFakeTx(PARAMS, Coin.FIFTY_COINS, Address.fromKey(PARAMS, key2));
         Block block = FakeTxBuilder.makeSolvedTestBlock(PARAMS.getGenesisBlock(), Address.fromBase58(PARAMS, "msg2t2V2sWNd85LccoddtWysBTR8oPnkzW"), tx1, tx2);
         BloomFilter filter = new BloomFilter(4, 0.1, 1);
         filter.insert(key1);

File: core/src/test/java/org/bitcoinj/core/ParseByteCacheTest.java
Patch:
@@ -90,17 +90,17 @@ public void setUp() throws Exception {
         
         Transaction tx1 = createFakeTx(PARAMS,
                 valueOf(2, 0),
-                wallet.currentReceiveKey().toAddress(PARAMS));
+                Address.fromKey(PARAMS, wallet.currentReceiveKey()));
         
         // add a second input so can test granularity of byte cache.
         Transaction prevTx = new Transaction(PARAMS);
-        TransactionOutput prevOut = new TransactionOutput(PARAMS, prevTx, COIN, wallet.currentReceiveKey().toAddress(PARAMS));
+        TransactionOutput prevOut = new TransactionOutput(PARAMS, prevTx, COIN, Address.fromKey(PARAMS, wallet.currentReceiveKey()));
         prevTx.addOutput(prevOut);
         // Connect it.
         tx1.addInput(prevOut);
         
         Transaction tx2 = createFakeTx(PARAMS, COIN,
-                new ECKey().toAddress(PARAMS));
+                Address.fromKey(PARAMS, new ECKey()));
 
         Block b1 = createFakeBlock(blockStore, BLOCK_HEIGHT_GENESIS, tx1, tx2).block;
 

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -245,7 +245,7 @@ public void receiveTxBroadcastOnAddedWallet() throws Exception {
         
         Wallet wallet2 = new Wallet(PARAMS);
         ECKey key2 = wallet2.freshReceiveKey();
-        Address address2 = key2.toAddress(PARAMS);
+        Address address2 = Address.fromKey(PARAMS, key2);
         
         peerGroup.addWallet(wallet2);
         blockChain.addWallet(wallet2);
@@ -804,7 +804,7 @@ public void autoRescanOnKeyExhaustion() throws Exception {
         Coin expectedBalance = Coin.ZERO;
         Block prev = blockStore.getChainHead().getHeader();
         for (ECKey key1 : keys) {
-            Address addr = key1.toAddress(PARAMS);
+            Address addr = Address.fromKey(PARAMS, key1);
             Block next = FakeTxBuilder.makeSolvedTestBlock(prev, FakeTxBuilder.createFakeTx(PARAMS, Coin.FIFTY_COINS, addr));
             expectedBalance = expectedBalance.add(next.getTransactions().get(2).getOutput(0).getValue());
             blocks.add(next);

File: core/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -870,7 +870,7 @@ public void run() {
         connect();
         Transaction t1 = new Transaction(PARAMS);
         t1.addInput(new TransactionInput(PARAMS, t1, new byte[]{}));
-        t1.addOutput(COIN, new ECKey().toAddress(PARAMS));
+        t1.addOutput(COIN, Address.fromKey(PARAMS, new ECKey()));
         Transaction t2 = new Transaction(PARAMS);
         t2.addInput(t1.getOutput(0));
         t2.addOutput(COIN, wallet.currentChangeAddress());

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -159,7 +159,7 @@ public void retryFailedBroadcast() throws Exception {
         assertEquals(FIFTY_COINS, wallet.getBalance());
 
         // Now create a spend, and expect the announcement on p1.
-        Address dest = new ECKey().toAddress(PARAMS);
+        Address dest = Address.fromKey(PARAMS, new ECKey());
         Wallet.SendResult sendResult = wallet.sendCoins(peerGroup, dest, COIN);
         assertFalse(sendResult.broadcastComplete.isDone());
         Transaction t1;
@@ -208,7 +208,7 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         });
 
         // Now create a spend, and expect the announcement on p1.
-        Address dest = new ECKey().toAddress(PARAMS);
+        Address dest = Address.fromKey(PARAMS, new ECKey());
         Wallet.SendResult sendResult = wallet.sendCoins(peerGroup, dest, COIN);
         assertNotNull(sendResult.tx);
         Threading.waitForUserCode();

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -40,7 +40,7 @@
  */
 public class TransactionTest {
     private static final NetworkParameters PARAMS = UnitTestParams.get();
-    private static final Address ADDRESS = new ECKey().toAddress(PARAMS);
+    private static final Address ADDRESS = Address.fromKey(PARAMS, new ECKey());
 
     private Transaction tx;
 
@@ -344,7 +344,7 @@ public void testTheTXByHeightComparator() {
     @Test(expected = ScriptException.class)
     public void testAddSignedInputThrowsExceptionWhenScriptIsNotToRawPubKeyAndIsNotToAddress() {
         ECKey key = new ECKey();
-        Address addr = key.toAddress(PARAMS);
+        Address addr = Address.fromKey(PARAMS, key);
         Transaction fakeTx = FakeTxBuilder.createFakeTx(PARAMS, Coin.COIN, addr);
 
         Transaction tx = new Transaction(PARAMS);
@@ -409,7 +409,7 @@ public void optInFullRBF() {
     @Test
     public void testHashForSignatureThreadSafety() {
         Block genesis = UnitTestParams.get().getGenesisBlock();
-        Block block1 = genesis.createNextBlock(new ECKey().toAddress(UnitTestParams.get()),
+        Block block1 = genesis.createNextBlock(Address.fromKey(UnitTestParams.get(), new ECKey()),
                     genesis.getTransactions().get(0).getOutput(0).getOutPointFor());
 
         final Transaction tx = block1.getTransactions().get(1);

File: core/src/test/java/org/bitcoinj/core/TxConfidenceTableTest.java
Patch:
@@ -38,8 +38,8 @@ public void setup() throws Exception {
         Context context = new Context(PARAMS);
         table = context.getConfidenceTable();
 
-        Address to = new ECKey().toAddress(PARAMS);
-        Address change = new ECKey().toAddress(PARAMS);
+        Address to = Address.fromKey(PARAMS, new ECKey());
+        Address change = Address.fromKey(PARAMS, new ECKey());
 
         tx1 = FakeTxBuilder.createFakeTxWithChangeAddress(PARAMS, COIN, to, change);
         tx2 = FakeTxBuilder.createFakeTxWithChangeAddress(PARAMS, COIN, to, change);

File: core/src/test/java/org/bitcoinj/script/ScriptPatternTest.java
Patch:
@@ -18,6 +18,8 @@
 package org.bitcoinj.script;
 
 import com.google.common.collect.Lists;
+
+import org.bitcoinj.core.Address;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.params.MainNetParams;
 import org.junit.Test;
@@ -33,7 +35,7 @@ public class ScriptPatternTest {
     @Test
     public void testCommonScripts() {
         assertTrue(ScriptPattern.isPayToPubKeyHash(
-                ScriptBuilder.createOutputScript(keys.get(0).toAddress(MainNetParams.get()))
+                ScriptBuilder.createOutputScript(Address.fromKey(MainNetParams.get(), keys.get(0)))
         ));
         assertTrue(ScriptPattern.isPayToScriptHash(
                 ScriptBuilder.createP2SHOutputScript(2, keys)

File: core/src/test/java/org/bitcoinj/script/ScriptTest.java
Patch:
@@ -439,7 +439,7 @@ public void testCLTVPaymentChannelOutput() {
     public void getToAddress() throws Exception {
         // pay to pubkey
         ECKey toKey = new ECKey();
-        Address toAddress = toKey.toAddress(PARAMS);
+        Address toAddress = Address.fromKey(PARAMS, toKey);
         assertEquals(toAddress, ScriptBuilder.createOutputScript(toKey).getToAddress(PARAMS, true));
         // pay to pubkey hash
         assertEquals(toAddress, ScriptBuilder.createOutputScript(toAddress).getToAddress(PARAMS, true));

File: core/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -90,7 +90,7 @@ public void setUp(BlockStore blockStore) throws Exception {
         if (wallet == null) {
             wallet = new Wallet(PARAMS);
             key = wallet.freshReceiveKey();
-            address = key.toAddress(PARAMS);
+            address = Address.fromKey(PARAMS, key);
         }
         blockChain = new BlockChain(PARAMS, wallet, blockStore);
 

File: core/src/test/java/org/bitcoinj/testing/TestWithWallet.java
Patch:
@@ -49,7 +49,7 @@ public void setUp() throws Exception {
         Context.propagate(new Context(PARAMS, 100, Coin.ZERO, false));
         wallet = new Wallet(PARAMS);
         myKey = wallet.currentReceiveKey();
-        myAddress = myKey.toAddress(PARAMS);
+        myAddress = Address.fromKey(PARAMS, myKey);
         blockStore = new MemoryBlockStore(PARAMS);
         chain = new BlockChain(PARAMS, wallet, blockStore);
     }

File: core/src/test/java/org/bitcoinj/wallet/DefaultRiskAnalysisTest.java
Patch:
@@ -208,7 +208,7 @@ public void standardOutputs() throws Exception {
         Transaction tx = new Transaction(PARAMS);
         tx.addInput(PARAMS.getGenesisBlock().getTransactions().get(0).getOutput(0));
         // A pay to address output
-        tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(key1.toAddress(PARAMS)));
+        tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(Address.fromKey(PARAMS, key1)));
         // A pay to pubkey output
         tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(key1));
         tx.addOutput(Coin.CENT, ScriptBuilder.createOutputScript(key1));

File: examples/src/main/java/org/bitcoinj/examples/ExamplePaymentChannelClient.java
Patch:
@@ -210,7 +210,7 @@ private void waitForSufficientBalance(Coin amount) {
         ListenableFuture<Coin> balanceFuture = appKit.wallet().getBalanceFuture(amountPlusFee, Wallet.BalanceType.ESTIMATED);
         if (!balanceFuture.isDone()) {
             System.out.println("Please send " + amountPlusFee.toFriendlyString() +
-                    " to " + myKey.toAddress(params));
+                    " to " + Address.fromKey(params, myKey));
             Futures.getUnchecked(balanceFuture);
         }
     }

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -111,7 +111,7 @@ public void onFailure(Throwable t) {
             }
         });
 
-        Address sendToAddress = kit.wallet().currentReceiveKey().toAddress(params);
+        Address sendToAddress = Address.fromKey(params, kit.wallet().currentReceiveKey());
         System.out.println("Send coins to: " + sendToAddress);
         System.out.println("Waiting for coins to arrive. Press Ctrl-C to quit.");
 

File: examples/src/main/java/org/bitcoinj/examples/GenerateLowSTests.java
Patch:
@@ -24,6 +24,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import org.bitcoinj.core.Address;
 import org.bitcoinj.core.Coin;
 import org.bitcoinj.core.ECKey;
 import org.bitcoinj.core.NetworkParameters;
@@ -81,11 +82,11 @@ public RedeemData findRedeemDataFromScriptHash(byte[] scriptHash) {
 
         final Transaction outputTransaction = new Transaction(params);
         final Transaction inputTransaction = new Transaction(params);
-        final TransactionOutput output = new TransactionOutput(params, inputTransaction, Coin.ZERO, key.toAddress(params));
+        final TransactionOutput output = new TransactionOutput(params, inputTransaction, Coin.ZERO, Address.fromKey(params, key));
 
         inputTransaction.addOutput(output);
         outputTransaction.addInput(output);
-        outputTransaction.addOutput(Coin.ZERO, new ECKey(secureRandom).toAddress(params));
+        outputTransaction.addOutput(Coin.ZERO, Address.fromKey(params, new ECKey(secureRandom)));
 
         addOutputs(outputTransaction, bag);
 

File: examples/src/main/java/org/bitcoinj/examples/PrivateKeys.java
Patch:
@@ -50,7 +50,7 @@ public static void main(String[] args) throws Exception {
                 BigInteger privKey = Base58.decodeToBigInteger(args[0]);
                 key = ECKey.fromPrivate(privKey);
             }
-            System.out.println("Address from private key is: " + key.toAddress(params).toString());
+            System.out.println("Address from private key is: " + Address.fromKey(params, key).toString());
             // And the address ...
             Address destination = Address.fromBase58(params, args[1]);
 

File: tools/src/main/java/org/bitcoinj/tools/WalletTool.java
Patch:
@@ -1355,7 +1355,7 @@ private static void addKey() {
                 }
                 key = wallet.freshReceiveKey();
             }
-            System.out.println(key.toAddress(params) + " " + key);
+            System.out.println(Address.fromKey(params, key) + " " + key);
         }
     }
 
@@ -1420,7 +1420,7 @@ private static void importKey() {
                 key = key.encrypt(checkNotNull(wallet.getKeyCrypter()), aesKey);
             }
             wallet.importKey(key);
-            System.out.println(key.toAddress(params) + " " + key);
+            System.out.println(Address.fromKey(params, key) + " " + key);
         } catch (KeyCrypterException kce) {
             System.err.println("There was an encryption related error when adding the key. The error was '" + kce.getMessage() + "'.");
         }
@@ -1480,7 +1480,7 @@ private static void deleteKey() {
 
     private static void currentReceiveAddr() {
         ECKey key = wallet.currentReceiveKey();
-        System.out.println(key.toAddress(params) + " " + key);
+        System.out.println(Address.fromKey(params, key) + " " + key);
     }
 
     private static void dumpWallet() throws BlockStoreException {

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -105,7 +105,7 @@ public int compare(final Transaction tx1, final Transaction tx2) {
     /**
      * If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
      */
-    public static final Coin REFERENCE_DEFAULT_MIN_TX_FEE = Coin.valueOf(5000); // 0.05 mBTC
+    public static final Coin REFERENCE_DEFAULT_MIN_TX_FEE = Coin.valueOf(1000); // 0.01 mBTC
 
     /**
      * If using this feePerKb, transactions will get confirmed within the next couple of blocks.
@@ -118,7 +118,7 @@ public int compare(final Transaction tx1, final Transaction tx2) {
      * This is calculated by assuming a standard output will be 34 bytes, and then using the formula used in
      * {@link TransactionOutput#getMinNonDustValue(Coin)}.
      */
-    public static final Coin MIN_NONDUST_OUTPUT = Coin.valueOf(2730); // satoshis
+    public static final Coin MIN_NONDUST_OUTPUT = Coin.valueOf(546); // satoshis
 
     // These are bitcoin serialized.
     private long version;

File: core/src/test/java/org/bitcoinj/wallet/WalletTest.java
Patch:
@@ -2690,7 +2690,7 @@ public void transactionGetFeeTest() throws Exception {
 
     @Test
     public void lowerThanDefaultFee() throws InsufficientMoneyException {
-        int feeFactor = 10;
+        int feeFactor = 50;
         Coin fee = Transaction.DEFAULT_TX_FEE.divide(feeFactor);
         receiveATransactionAmount(wallet, myAddress, Coin.COIN);
         SendRequest req = SendRequest.to(myAddress, Coin.CENT);

File: examples/src/main/java/org/bitcoinj/examples/SendRequest.java
Patch:
@@ -40,7 +40,6 @@ public static void main(String[] args) throws Exception {
         kit.startAsync();
         kit.awaitRunning();
 
-        System.out.println("Send money to: " + kit.wallet().currentReceiveAddress().toString());
 
         // How much coins do we want to send?
         // The Coin class represents a monetary Bitcoin value.
@@ -50,6 +49,7 @@ public static void main(String[] args) throws Exception {
         // To which address you want to send the coins?
         // The Address class represents a Bitcoin address.
         Address to = Address.fromBase58(params, "mupBAFeT63hXfeeT4rnAUcpKHDkz1n4fdw");
+        System.out.println("Send money to: " + to.toString());
 
         // There are different ways to create and publish a SendRequest. This is probably the easiest one.
         // Have a look at the code of the SendRequest class to see what's happening and what other options you have: https://bitcoinj.github.io/javadoc/0.11/com/google/bitcoin/core/Wallet.SendRequest.html

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -3226,14 +3226,14 @@ public String toString() {
     @Deprecated
     public String toString(boolean includePrivateKeys, boolean includeTransactions, boolean includeExtensions,
             @Nullable AbstractBlockChain chain) {
-        return toString(includePrivateKeys, includeTransactions, includeExtensions, chain);
+        return toString(includePrivateKeys, null, includeTransactions, includeExtensions, chain);
     }
 
     /**
      * Formats the wallet as a human readable piece of text. Intended for debugging, the format is not meant to be
      * stable or human readable.
      * @param includePrivateKeys Whether raw private key data should be included.
-     * @param key for decrypting private key data for if the wallet is encrypted.
+     * @param aesKey for decrypting private key data for if the wallet is encrypted.
      * @param includeTransactions Whether to print transaction data.
      * @param includeExtensions Whether to print extension data.
      * @param chain If set, will be used to estimate lock times for block timelocked transactions.

File: core/src/main/java/org/bitcoinj/crypto/DeterministicHierarchy.java
Patch:
@@ -58,7 +58,7 @@ public DeterministicHierarchy(DeterministicKey rootKey) {
     }
 
     /**
-     * Inserts a key into the heirarchy. Used during deserialization: you normally don't need this. Keys must be
+     * Inserts a key into the hierarchy. Used during deserialization: you normally don't need this. Keys must be
      * inserted in order.
      */
     public final void putKey(DeterministicKey key) {

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -355,13 +355,13 @@ else if (parent != null)
     public ECDSASignature sign(Sha256Hash input, @Nullable KeyParameter aesKey) throws KeyCrypterException {
         if (isEncrypted()) {
             // If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign. Decryption walks the
-            // key heirarchy to find the private key (see below), so, we can just run the inherited method.
+            // key hierarchy to find the private key (see below), so, we can just run the inherited method.
             return super.sign(input, aesKey);
         } else {
             // If it's not encrypted, derive the private via the parents.
             final BigInteger privateKey = findOrDerivePrivateKey();
             if (privateKey == null) {
-                // This key is a part of a public-key only heirarchy and cannot be used for signing
+                // This key is a part of a public-key only hierarchy and cannot be used for signing
                 throw new MissingPrivateKeyException();
             }
             return super.doSign(input, privateKey);
@@ -583,7 +583,7 @@ public void setCreationTimeSeconds(long newCreationTimeSeconds) {
     }
 
     /**
-     * Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
+     * Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate hierarchy
      * objects will equal each other.
      */
     @Override

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -894,7 +894,7 @@ public static List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, @N
                 if (!isWatchingAccountKey) {
                     // If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                     // been rederived and inserted at this point. In the encrypted case though,
-                    // we can't rederive and we must reinsert, potentially building the heirarchy object
+                    // we can't rederive and we must reinsert, potentially building the hierarchy object
                     // if need be.
                     if (path.size() == 0) {
                         // Master key.

File: core/src/test/java/org/bitcoinj/crypto/ChildKeyDerivationTest.java
Patch:
@@ -136,7 +136,7 @@ public void inverseEqualsNormal() throws Exception {
 
     @Test
     public void encryptedDerivation() throws Exception {
-        // Check that encrypting a parent key in the heirarchy and then deriving from it yields a DeterministicKey
+        // Check that encrypting a parent key in the hierarchy and then deriving from it yields a DeterministicKey
         // with no private key component, and that the private key bytes are derived on demand.
         KeyCrypter scrypter = new KeyCrypterScrypt();
         KeyParameter aesKey = scrypter.deriveKey("we never went to the moon");

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -643,9 +643,9 @@ protected void processNotFoundMessage(NotFoundMessage m) {
     protected void processAlert(AlertMessage m) {
         try {
             if (m.isSignatureValid()) {
-                log.info("Received alert from peer {}: {}", this, m.getStatusBar());
+                log.debug("Received alert from peer {}: {}", this, m.getStatusBar());
             } else {
-                log.warn("Received alert with invalid signature from peer {}: {}", this, m.getStatusBar());
+                log.debug("Received alert with invalid signature from peer {}: {}", this, m.getStatusBar());
             }
         } catch (Throwable t) {
             // Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their

File: core/src/main/java/org/bitcoin/NativeSecp256k1.java
Patch:
@@ -78,7 +78,7 @@ public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws A
      * libsecp256k1 Create an ECDSA signature.
      *
      * @param data Message hash, 32 bytes
-     * @param key Secret key, 32 bytes
+     * @param sec Secret key, 32 bytes
      * @return sig byte array of signature
      */
     public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException {
@@ -200,7 +200,7 @@ public static long cloneContext() {
      * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it
      *
      * @param tweak some bytes to tweak with
-     * @param seckey 32-byte seckey
+     * @param privkey 32-byte seckey
      */
     public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException {
         Preconditions.checkArgument(privkey.length == 32);
@@ -239,7 +239,7 @@ public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws Assert
      * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it
      *
      * @param tweak some bytes to tweak with
-     * @param seckey 32-byte seckey
+     * @param privkey 32-byte seckey
      */
     public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException {
         Preconditions.checkArgument(privkey.length == 32);

File: core/src/main/java/org/bitcoinj/core/ChildMessage.java
Patch:
@@ -29,7 +29,7 @@ public abstract class ChildMessage extends Message {
     @Nullable protected Message parent;
 
     /**
-     * @deprecated Use {@link #ChildMessage(NetworkParameters) instead.
+     * @deprecated Use {@link #ChildMessage(NetworkParameters)} instead.
      */
     @Deprecated
     protected ChildMessage() {

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.bitcoinj.core;
 
+import org.bitcoinj.wallet.SendRequest;
 import org.slf4j.*;
 
 import static com.google.common.base.Preconditions.*;

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -422,7 +422,7 @@ public int getBip32HeaderPriv() {
 
     /**
      * Return the default serializer for this network. This is a shared serializer.
-     * @return 
+     * @return the default serializer for this network.
      */
     public final MessageSerializer getDefaultSerializer() {
         // Construct a default serializer if we don't have one
@@ -448,7 +448,7 @@ public final MessageSerializer getDefaultSerializer() {
     public abstract BitcoinSerializer getSerializer(boolean parseRetain);
 
     /**
-     * The number of blocks in the last {@link getMajorityWindow()} blocks
+     * The number of blocks in the last {@link #getMajorityWindow()} blocks
      * at which to trigger a notice to the user to upgrade their client, where
      * the client does not understand those blocks.
      */
@@ -457,7 +457,7 @@ public int getMajorityEnforceBlockUpgrade() {
     }
 
     /**
-     * The number of blocks in the last {@link getMajorityWindow()} blocks
+     * The number of blocks in the last {@link #getMajorityWindow()} blocks
      * at which to enforce the requirement that all new blocks are of the
      * newer type (i.e. outdated blocks are rejected).
      */

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -727,7 +727,7 @@ public void addDisconnectedEventListener(Executor executor, PeerDisconnectedEven
             peer.addDisconnectedEventListener(executor, listener);
     }
 
-    /** See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)} */
+    /** See {@link PeerGroup#addDiscoveredEventListener(Executor, PeerDiscoveredEventListener)} */
     public void addDiscoveredEventListener(PeerDiscoveredEventListener listener) {
         addDiscoveredEventListener(Threading.USER_THREAD, listener);
     }

File: core/src/main/java/org/bitcoinj/core/TransactionConfidence.java
Patch:
@@ -19,6 +19,8 @@
 
 import com.google.common.collect.*;
 import com.google.common.util.concurrent.*;
+
+import org.bitcoinj.core.listeners.BlockChainListener;
 import org.bitcoinj.utils.*;
 import org.bitcoinj.wallet.Wallet;
 

File: core/src/main/java/org/bitcoinj/core/listeners/NewBestBlockListener.java
Patch:
@@ -26,8 +26,8 @@ public interface NewBestBlockListener {
     /**
      * Called when a new block on the best chain is seen, after relevant
      * transactions are extracted and sent to us via either
-     * {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int relativityOffset)}
-     * or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
+     * {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, StoredBlock, org.bitcoinj.core.AbstractBlockChain.NewBlockType, int)}
+     * or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, StoredBlock, org.bitcoinj.core.AbstractBlockChain.NewBlockType, int)}.
      * If this block is causing a re-organise to a new chain, this method is NOT
      * called even though the block may be the new best block: your reorganize
      * implementation is expected to do whatever would normally be done do for a

File: core/src/main/java/org/bitcoinj/core/listeners/PeerConnectedEventListener.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core.listeners;
 
 import org.bitcoinj.core.Peer;
+import org.bitcoinj.core.PeerGroup;
 
 /**
  * <p>Implementors can listen to events indicating a new peer connecting.</p>

File: core/src/main/java/org/bitcoinj/core/listeners/PeerConnectionEventListener.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core.listeners;
 
 import org.bitcoinj.core.Peer;
+import org.bitcoinj.core.PeerGroup;
 
 /**
  * <p>Implementors can listen to events like peer discovery, connect or disconnects.</p>

File: core/src/main/java/org/bitcoinj/core/listeners/PeerDisconnectedEventListener.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core.listeners;
 
 import org.bitcoinj.core.Peer;
+import org.bitcoinj.core.PeerGroup;
 
 /**
  * <p>Implementors can listen to events indicating a peer disconnecting.</p>

File: core/src/main/java/org/bitcoinj/core/listeners/PeerDiscoveredEventListener.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.bitcoinj.core.Peer;
 import org.bitcoinj.core.PeerAddress;
+import org.bitcoinj.core.PeerGroup;
+
 import java.util.Set;
 
 /**

File: core/src/main/java/org/bitcoinj/core/listeners/TransactionReceivedInBlockListener.java
Patch:
@@ -17,6 +17,7 @@
 package org.bitcoinj.core.listeners;
 
 import org.bitcoinj.core.BlockChain;
+import org.bitcoinj.core.FilteredBlock;
 import org.bitcoinj.core.Sha256Hash;
 import org.bitcoinj.core.StoredBlock;
 import org.bitcoinj.core.Transaction;

File: core/src/main/java/org/bitcoinj/crypto/TransactionSignature.java
Patch:
@@ -162,7 +162,7 @@ public ECKey.ECDSASignature toCanonicalised() {
      * @param requireCanonicalEncoding if the encoding of the signature must
      * be canonical.
      * @throws RuntimeException if the signature is invalid or unparseable in some way.
-     * @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean} instead}.
+     * @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead}.
      */
     @Deprecated
     public static TransactionSignature decodeFromBitcoin(byte[] bytes,

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -128,7 +128,7 @@ public WalletAppKit setAutoSave(boolean value) {
 
     /**
      * If you want to learn about the sync process, you can provide a listener here. For instance, a
-     * {@link org.bitcoinj.core.DownloadProgressTracker} is a good choice. This has no effect unless setBlockingStartup(false) has been called
+     * {@link DownloadProgressTracker} is a good choice. This has no effect unless setBlockingStartup(false) has been called
      * too, due to some missing implementation code.
      */
     public WalletAppKit setDownloadListener(DownloadProgressTracker listener) {

File: core/src/main/java/org/bitcoinj/net/ClientConnectionManager.java
Patch:
@@ -25,7 +25,7 @@
  * <p>A generic interface for an object which keeps track of a set of open client connections, creates new ones and
  * ensures they are serviced properly.</p>
  *
- * <p>When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed and
+ * <p>When the service is stopped via {@link com.google.common.util.concurrent.Service#stopAsync()}, all connections will be closed and
  * the appropriate connectionClosed() calls must be made.</p>
  */
 public interface ClientConnectionManager extends Service {

File: core/src/main/java/org/bitcoinj/net/NioServer.java
Patch:
@@ -123,7 +123,7 @@ protected void run() throws Exception {
     /**
      * Invoked by the Execution service when it's time to stop.
      * Calling this method directly will NOT stop the service, call
-     * {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
+     * {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stopAsync()} instead.
      */
     @Override
     public void triggerShutdown() {

File: core/src/main/java/org/bitcoinj/net/ProtobufConnection.java
Patch:
@@ -84,7 +84,7 @@ public interface Listener<MessageType extends MessageLite> {
      *
      * @param handler The callback listener
      * @param prototype The default instance of the message type used in both directions of this channel.
-     *                  This should be the return value from {@link MessageType#getDefaultInstanceForType()}
+     *                  This should be the return value from {@link MessageLite#getDefaultInstanceForType()}
      * @param maxMessageSize The maximum message size (not including the 4-byte length prefix).
      *                       Note that this has an upper bound of {@link Integer#MAX_VALUE} - 4
      * @param timeoutMillis The timeout between messages before the connection is automatically closed. Only enabled

File: core/src/main/java/org/bitcoinj/net/discovery/DnsDiscovery.java
Patch:
@@ -31,7 +31,7 @@
  * However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().
  * </p>
  *
- * <p>DNS seeds do not attempt to enumerate every peer on the network. {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)}
+ * <p>DNS seeds do not attempt to enumerate every peer on the network. {@link DnsDiscovery#getPeers(long, long, TimeUnit)}
  * will return up to 30 random peers from the set of those returned within the timeout period. If you want more peers
  * to connect to, you need to discover them via other means (like addr broadcasts).</p>
  */

File: core/src/main/java/org/bitcoinj/net/discovery/PeerDiscovery.java
Patch:
@@ -20,6 +20,8 @@
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;
 
+import org.bitcoinj.core.VersionMessage;
+
 /**
  * A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network. Note that
  * the addresses returned may or may not be accepting connections.

File: core/src/main/java/org/bitcoinj/protocols/channels/IPaymentChannelClient.java
Patch:
@@ -47,7 +47,7 @@ public interface IPaymentChannelClient {
      * intending to reopen the channel later. There is likely little reason to use this in a stateless protocol.</p>
      *
      * <p>Note that this <b>MUST</b> still be called even after either
-     * {@link PaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
+     * {@link org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
      * {@link IPaymentChannelClient#settle()} is called, to actually handle the connection close logic.</p>
      */
     void connectionClosed();
@@ -56,7 +56,7 @@ public interface IPaymentChannelClient {
      * <p>Settles the channel, notifying the server it can broadcast the most recent payment transaction.</p>
      *
      * <p>Note that this only generates a CLOSE message for the server and calls
-     * {@link PaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)}
+     * {@link org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)}
      * to settle the connection, it does not actually handle connection close logic, and
      * {@link PaymentChannelClient#connectionClosed()} must still be called after the connection fully settles.</p>
      *

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClient.java
Patch:
@@ -539,7 +539,7 @@ private void receiveClose(Protos.TwoWayChannelMessage msg) throws VerificationEx
      * intending to reopen the channel later. There is likely little reason to use this in a stateless protocol.</p>
      *
      * <p>Note that this <b>MUST</b> still be called even after either
-     * {@link ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
+     * {@link org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
      * {@link PaymentChannelClient#settle()} is called, to actually handle the connection close logic.</p>
      */
     @Override
@@ -559,7 +559,7 @@ public void connectionClosed() {
      * payment transaction.</p>
      *
      * <p>Note that this only generates a CLOSE message for the server and calls
-     * {@link ClientConnection#destroyConnection(CloseReason)} to settle the connection, it does not
+     * {@link org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} to settle the connection, it does not
      * actually handle connection close logic, and {@link PaymentChannelClient#connectionClosed()} must still be called
      * after the connection fully closes.</p>
      *

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientConnection.java
Patch:
@@ -102,7 +102,7 @@ public PaymentChannelClientConnection(InetSocketAddress server, int timeoutSecon
 
     /**
      * Attempts to open a new connection to and open a payment channel with the given host and port, blocking until the
-     * connection is open.  The server is requested to keep the channel open for {@param timeWindow}
+     * connection is open.  The server is requested to keep the channel open for {@code timeoutSeconds}
      * seconds. If the server proposes a longer time the channel will be closed.
      *
      * @param server The host/port pair where the server is listening.

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServer.java
Patch:
@@ -595,7 +595,7 @@ public void onFailure(Throwable t) {
      * resume this channel in the future and stops generating messages for the client.</p>
      *
      * <p>Note that this <b>MUST</b> still be called even after either
-     * {@link ServerConnection#destroyConnection(CloseReason)} or
+     * {@link org.bitcoinj.protocols.channels.PaymentChannelServer.ServerConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
      * {@link PaymentChannelServer#close()} is called to actually handle the connection close logic.</p>
      */
     public void connectionClosed() {
@@ -638,7 +638,7 @@ public void connectionOpen() {
 
     /**
      * <p>Closes the connection by generating a settle message for the client and calls
-     * {@link ServerConnection#destroyConnection(CloseReason)}. Note that this does not broadcast
+     * {@link org.bitcoinj.protocols.channels.PaymentChannelServer.ServerConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)}. Note that this does not broadcast
      * the payment transaction and the client may still resume the same channel if they reconnect</p>
      * <p>
      * <p>Note that {@link PaymentChannelServer#connectionClosed()} must still be called after the connection fully

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -386,7 +386,7 @@ public Script getContractScript() {
     /**
      * Gets the script that signatures should sign against. This is never a P2SH
      * script, rather the script that would be inside a P2SH script.
-     * @return
+     * @return the script that signatures should sign against.
      */
     protected abstract Script getSignedScript();
 

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelV1ClientState.java
Patch:
@@ -72,9 +72,9 @@ public class PaymentChannelV1ClientState extends PaymentChannelClientState {
 
     /**
      * Creates a state object for a payment channel client. It is expected that you be ready to
-     * {@link PaymentChannelClientState#initiate(KeyParameter, ClientChannelProperties)} after construction (to avoid creating objects for channels which are
+     * {@link PaymentChannelClientState#initiate(KeyParameter, org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientChannelProperties)} after construction (to avoid creating objects for channels which are
      * not going to finish opening) and thus some parameters provided here are only used in
-     * {@link PaymentChannelClientState#initiate(KeyParameter, ClientChannelProperties)} to create the Multisig contract and refund transaction.
+     * {@link PaymentChannelClientState#initiate(KeyParameter, org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientChannelProperties)} to create the Multisig contract and refund transaction.
      *
      * @param wallet a wallet that contains at least the specified amount of value.
      * @param myKey a freshly generated private key for this channel.

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelV2ServerState.java
Patch:
@@ -118,7 +118,7 @@ protected void verifyContract(final Transaction contract) {
 
     /**
      * Creates a P2SH script outputting to the client and server pubkeys
-     * @return
+     * @return a P2SH script.
      */
     @Override
     protected Script createOutputScript() {

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocol.java
Patch:
@@ -54,7 +54,7 @@ public class PaymentProtocol {
 
     /**
      * Create a payment request with one standard pay to address output. You may want to sign the request using
-     * {@link #signPaymentRequest}. Use {@link Protos.PaymentRequest.Builder#build} to get the actual payment
+     * {@link #signPaymentRequest}. Use {@link org.bitcoin.protocols.payments.Protos.PaymentRequest.Builder#build} to get the actual payment
      * request.
      *
      * @param params network parameters
@@ -74,7 +74,7 @@ public static Protos.PaymentRequest.Builder createPaymentRequest(NetworkParamete
 
     /**
      * Create a payment request. You may want to sign the request using {@link #signPaymentRequest}. Use
-     * {@link Protos.PaymentRequest.Builder#build} to get the actual payment request.
+     * {@link org.bitcoin.protocols.payments.Protos.PaymentRequest.Builder#build} to get the actual payment request.
      * 
      * @param params network parameters
      * @param outputs list of outputs to request coins to
@@ -157,7 +157,7 @@ public static void signPaymentRequest(Protos.PaymentRequest.Builder paymentReque
      * 
      * @param paymentRequest Payment request to verify.
      * @param trustStore KeyStore of trusted root certificate authorities.
-     * @return verification data, or null if no PKI method was specified in the {@link Protos.PaymentRequest}.
+     * @return verification data, or null if no PKI method was specified in the {@link org.bitcoin.protocols.payments.Protos.PaymentRequest}.
      * @throws PaymentProtocolException if payment request could not be verified.
      */
     @Nullable

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -310,7 +310,7 @@ public byte[] getPubKey() throws ScriptException {
 
     /**
      * Retrieves the sender public key from a LOCKTIMEVERIFY transaction
-     * @return
+     * @return the sender public key
      * @throws ScriptException
      */
     public byte[] getCLTVPaymentChannelSenderPubKey() throws ScriptException {
@@ -322,7 +322,7 @@ public byte[] getCLTVPaymentChannelSenderPubKey() throws ScriptException {
 
     /**
      * Retrieves the recipient public key from a LOCKTIMEVERIFY transaction
-     * @return
+     * @return the recipient public key
      * @throws ScriptException
      */
     public byte[] getCLTVPaymentChannelRecipientPubKey() throws ScriptException {

File: core/src/main/java/org/bitcoinj/signers/LocalTransactionSigner.java
Patch:
@@ -37,7 +37,7 @@
  * </p>
  * <p>This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
  * completion. As the first signer to create a signature, it stores derivation path of the signing key in a given
- * {@link ProposedTransaction} object that will be also passed then to the next signer in chain. This allows other
+ * {@link org.bitcoinj.signers.TransactionSigner.ProposedTransaction} object that will be also passed then to the next signer in chain. This allows other
  * signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
  * the same derivation path.</p>
  * <p>This signer always uses {@link org.bitcoinj.core.Transaction.SigHash#ALL} signing mode.</p>

File: core/src/main/java/org/bitcoinj/utils/BtcFormat.java
Patch:
@@ -1378,7 +1378,6 @@ private static DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat,
      *
      * @param scale Number of places the decimal point will be shifted when formatting
      *              a quantity of satoshis.
-     * @return The DecimalFormatSymbols before changing
      */
     protected static void prefixUnitsIndicator(DecimalFormat numberFormat, int scale) {
         checkState(Thread.holdsLock(numberFormat)); // make sure caller intends to reset before changing

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -594,7 +594,6 @@ public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTwea
         return filter;
     }
 
-    /** {@inheritDoc} */
     public boolean isRequiringUpdateAllBloomFilter() {
         throw new UnsupportedOperationException();   // Unused.
     }

File: core/src/main/java/org/bitcoinj/wallet/SendRequest.java
Patch:
@@ -58,7 +58,7 @@ public class SendRequest {
      *
      * <p>If there are already inputs to the transaction, make sure their out point has a connected output,
      * otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by a wallet
-     * key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined (likely
+     * key, otherwise the behavior of {@link Wallet#completeTx(SendRequest)} is undefined (likely
      * RuntimeException).</p>
      */
     public Transaction tx;

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -125,7 +125,7 @@ public void setRequireAllExtensionsKnown(boolean value) {
     }
 
     /**
-     * Change buffer size for writing wallet to output stream. Default is {@link com.google.protobuf.CodedOutputStream.DEFAULT_BUFFER_SIZE}
+     * Change buffer size for writing wallet to output stream. Default is {@link com.google.protobuf.CodedOutputStream#DEFAULT_BUFFER_SIZE}
      * @param walletWriteBufferSize - buffer size in bytes
      */
     public void setWalletWriteBufferSize(int walletWriteBufferSize) {
@@ -418,7 +418,7 @@ public Wallet readWallet(InputStream input, @Nullable WalletExtension... walletE
      * Wallet object with {@code forceReset} set {@code true}. It won't work.</p>
      *
      * <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is configured
-     * to replay transactions from the blockchain (as if the wallet had been loaded and {@link Wallet.reset}
+     * to replay transactions from the blockchain (as if the wallet had been loaded and {@link Wallet#reset()}
      * had been called immediately thereafter).
      *
      * <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data, internally
@@ -467,7 +467,7 @@ public Wallet readWallet(NetworkParameters params, @Nullable WalletExtension[] e
      * Wallet object with {@code forceReset} set {@code true}. It won't work.</p>
      *
      * <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is configured
-     * to replay transactions from the blockchain (as if the wallet had been loaded and {@link Wallet.reset}
+     * to replay transactions from the blockchain (as if the wallet had been loaded and {@link Wallet#reset()}
      * had been called immediately thereafter).
      *
      * <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data, internally

File: core/src/main/java/org/bitcoinj/wallet/listeners/WalletCoinsReceivedEventListener.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.bitcoinj.core.Coin;
 import org.bitcoinj.core.Transaction;
+import org.bitcoinj.core.TransactionConfidence;
 import org.bitcoinj.wallet.Wallet;
 
 /**

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServer.java
Patch:
@@ -526,8 +526,9 @@ private void error(String message, Protos.Error.ErrorCode errorCode, CloseReason
         log.error(message);
         Protos.Error.Builder errorBuilder;
         errorBuilder = Protos.Error.newBuilder()
-                .setCode(errorCode)
-                .setExplanation(message);
+                .setCode(errorCode);
+        if (message != null)
+            errorBuilder.setExplanation(message);
         conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()
                 .setError(errorBuilder)
                 .setType(Protos.TwoWayChannelMessage.MessageType.ERROR)

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -717,7 +717,7 @@ public boolean isSentToMultiSig() {
             }
             // First chunk must be an OP_N opcode too.
             if (decodeFromOpN(chunks.get(0).opcode) < 1) return false;
-        } catch (IllegalStateException e) {
+        } catch (IllegalArgumentException e) { // thrown by decodeFromOpN()
             return false;   // Not an OP_N opcode.
         }
         return true;

File: core/src/main/java/org/bitcoinj/core/ECKey.java
Patch:
@@ -190,7 +190,7 @@ protected ECKey(@Nullable BigInteger priv, ECPoint pub) {
 
     protected ECKey(@Nullable BigInteger priv, LazyECPoint pub) {
         if (priv != null) {
-            checkArgument(priv.bitLength() <= 32 * 8, "private key exceeds 32 bytes: {} bits", priv.bitLength());
+            checkArgument(priv.bitLength() <= 32 * 8, "private key exceeds 32 bytes: %s bits", priv.bitLength());
             // Try and catch buggy callers or bad key imports, etc. Zero and one are special because these are often
             // used as sentinel values and because scripting languages have a habit of auto-casting true and false to
             // 1 and 0 or vice-versa. Type confusion bugs could therefore result in private keys with these values.

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -21,6 +21,7 @@
 import org.bitcoinj.crypto.TransactionSignature;
 import org.bitcoinj.script.Script;
 import org.bitcoinj.script.ScriptBuilder;
+import org.bitcoinj.script.ScriptError;
 import org.bitcoinj.script.ScriptOpCodes;
 import org.bitcoinj.signers.TransactionSigner;
 import org.bitcoinj.utils.ExchangeRate;
@@ -827,7 +828,7 @@ public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scrip
         else if (scriptPubKey.isSentToAddress())
             input.setScriptSig(ScriptBuilder.createInputScript(txSig, sigKey));
         else
-            throw new ScriptException("Don't know how to sign for this kind of scriptPubKey: " + scriptPubKey);
+            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Don't know how to sign for this kind of scriptPubKey: " + scriptPubKey);
         return input;
     }
 

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -18,6 +18,7 @@
 package org.bitcoinj.core;
 
 import org.bitcoinj.script.Script;
+import org.bitcoinj.script.ScriptError;
 import org.bitcoinj.wallet.DefaultRiskAnalysis;
 import org.bitcoinj.wallet.KeyBag;
 import org.bitcoinj.wallet.RedeemData;
@@ -186,6 +187,7 @@ public void setScriptSig(Script scriptSig) {
     public Address getFromAddress() throws ScriptException {
         if (isCoinBase()) {
             throw new ScriptException(
+                    ScriptError.SCRIPT_ERR_UNKNOWN_ERROR,
                     "This is a coinbase transaction which generates new coins. It does not have a from address.");
         }
         return getScriptSig().getFromAddress(params);

File: core/src/main/java/org/bitcoinj/core/TransactionOutPoint.java
Patch:
@@ -148,7 +148,7 @@ public ECKey getConnectedKey(KeyBag keyBag) throws ScriptException {
             byte[] pubkeyBytes = connectedScript.getPubKey();
             return keyBag.findKeyFromPubKey(pubkeyBytes);
         } else {
-            throw new ScriptException("Could not understand form of connected output script: " + connectedScript);
+            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript);
         }
     }
 
@@ -174,7 +174,7 @@ public RedeemData getConnectedRedeemData(KeyBag keyBag) throws ScriptException {
             byte[] scriptHash = connectedScript.getPubKeyHash();
             return keyBag.findRedeemDataFromScriptHash(scriptHash);
         } else {
-            throw new ScriptException("Could not understand form of connected output script: " + connectedScript);
+            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript);
         }
     }
 

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -299,7 +299,7 @@ public void testToStringWhenIteratingOverAnInputCatchesAnException() {
         TransactionInput ti = new TransactionInput(PARAMS, tx, new byte[0]) {
             @Override
             public Script getScriptSig() throws ScriptException {
-                throw new ScriptException("");
+                throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "");
             }
         };
 

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -4842,7 +4842,7 @@ private static class FeeCalculation {
 
     //region Fee calculation code
 
-    public FeeCalculation calculateFee(SendRequest req, Coin value, List<TransactionInput> originalInputs,
+    private FeeCalculation calculateFee(SendRequest req, Coin value, List<TransactionInput> originalInputs,
                                        boolean needAtLeastReferenceFee, List<TransactionOutput> candidates) throws InsufficientMoneyException {
         checkState(lock.isHeldByCurrentThread());
         FeeCalculation result;

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -974,7 +974,7 @@ public static void executeScript(@Nullable Transaction txContainingThis, long in
                     break;
                 case OP_FROMALTSTACK:
                     if (altstack.size() < 1)
-                        throw new ScriptException("Attempted OP_TOALTSTACK on an empty altstack");
+                        throw new ScriptException("Attempted OP_FROMALTSTACK on an empty altstack");
                     stack.add(altstack.pollLast());
                     break;
                 case OP_2DROP:
@@ -1125,7 +1125,7 @@ public static void executeScript(@Nullable Transaction txContainingThis, long in
                     throw new ScriptException("Attempted to use disabled Script Op.");
                 case OP_EQUAL:
                     if (stack.size() < 2)
-                        throw new ScriptException("Attempted OP_EQUALVERIFY on a stack with size < 2");
+                        throw new ScriptException("Attempted OP_EQUAL on a stack with size < 2");
                     stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {});
                     break;
                 case OP_EQUALVERIFY:

File: core/src/main/java/org/bitcoinj/script/ScriptBuilder.java
Patch:
@@ -112,7 +112,7 @@ public ScriptBuilder data(int index, byte[] data) {
      * shortest encoding possible.
      */
     public ScriptBuilder number(long num) {
-        if (num >= 0 && num < 16) {
+        if (num >= 0 && num <= 16) {
             return smallNum((int) num);
         } else {
             return bigNum(num);
@@ -124,7 +124,7 @@ public ScriptBuilder number(long num) {
      * uses shortest encoding possible.
      */
     public ScriptBuilder number(int index, long num) {
-        if (num >= 0 && num < 16) {
+        if (num >= 0 && num <= 16) {
             return addChunk(index, new ScriptChunk(Script.encodeToOpN((int) num), null));
         } else {
             return bigNum(index, num);

File: core/src/main/java/org/bitcoinj/core/PeerAddress.java
Patch:
@@ -93,7 +93,7 @@ public PeerAddress(NetworkParameters params, InetAddress addr, int port) {
      * parameters.
      */
     public PeerAddress(NetworkParameters params, InetAddress addr) {
-        this(params, addr, MainNetParams.get().getPort());
+        this(params, addr, params.getPort());
     }
 
     /**

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -102,9 +102,9 @@ public int compare(final Transaction tx1, final Transaction tx2) {
 
     /**
      * If using this feePerKb, transactions will get confirmed within the next couple of blocks.
-     * This should be adjusted from time to time. Last adjustment: March 2016.
+     * This should be adjusted from time to time. Last adjustment: February 2017.
      */
-    public static final Coin DEFAULT_TX_FEE = Coin.valueOf(50000); // 0.5 mBTC
+    public static final Coin DEFAULT_TX_FEE = Coin.valueOf(100000); // 1 mBTC
 
     /**
      * Any standard (ie pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -627,6 +627,9 @@ public static Protos.Wallet parseToProto(InputStream input) throws IOException {
 
     private void readTransaction(Protos.Transaction txProto, NetworkParameters params) throws UnreadableWalletException {
         Transaction tx = new Transaction(params);
+
+        tx.setVersion(txProto.getVersion());
+
         if (txProto.hasUpdatedAt()) {
             tx.setUpdateTime(new Date(txProto.getUpdatedAt()));
         }

File: core/src/main/java/org/bitcoin/NativeSecp256k1.java
Patch:
@@ -42,7 +42,7 @@ public class NativeSecp256k1 {
     private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
     private static final Lock r = rwl.readLock();
     private static final Lock w = rwl.writeLock();
-    private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();
+    private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<>();
 
     /**
      * Verifies the given secp256k1 signature in native code. Calling when enabled == false is undefined (probably

File: core/src/main/java/org/bitcoinj/core/AddressMessage.java
Patch:
@@ -76,7 +76,7 @@ protected void parse() throws ProtocolException {
         // Guard against ultra large messages that will crash us.
         if (numAddresses > MAX_ADDRESSES)
             throw new ProtocolException("Address message too large.");
-        addresses = new ArrayList<PeerAddress>((int) numAddresses);
+        addresses = new ArrayList<>((int) numAddresses);
         for (int i = 0; i < numAddresses; i++) {
             PeerAddress addr = new PeerAddress(params, payload, cursor, protocolVersion, this, serializer);
             addresses.add(addr);

File: core/src/main/java/org/bitcoinj/core/AlertMessage.java
Patch:
@@ -87,7 +87,7 @@ protected void parse() throws ProtocolException {
         }
         // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
         // make it easy to do better. What we really want is just an array-backed set.
-        Set<Long> cancelSet = new HashSet<Long>((int) cancelSetSize);
+        Set<Long> cancelSet = new HashSet<>((int) cancelSetSize);
         for (long i = 0; i < cancelSetSize; i++) {
             cancelSet.add(readUint32());
         }
@@ -98,7 +98,7 @@ protected void parse() throws ProtocolException {
         if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
             throw new ProtocolException("Bad subver set size: " + subverSetSize);
         }
-        Set<String> matchingSubVers = new HashSet<String>((int) subverSetSize);
+        Set<String> matchingSubVers = new HashSet<>((int) subverSetSize);
         for (long i = 0; i < subverSetSize; i++) {
             matchingSubVers.add(readStr());
         }

File: core/src/main/java/org/bitcoinj/core/BitcoinSerializer.java
Patch:
@@ -48,7 +48,7 @@ public class BitcoinSerializer extends MessageSerializer {
     private final NetworkParameters params;
     private final boolean parseRetain;
 
-    private static final Map<Class<? extends Message>, String> names = new HashMap<Class<? extends Message>, String>();
+    private static final Map<Class<? extends Message>, String> names = new HashMap<>();
 
     static {
         names.put(VersionMessage.class, "version");

File: core/src/main/java/org/bitcoinj/core/BloomFilter.java
Patch:
@@ -301,7 +301,7 @@ else if (nFlags == 2)
      */
     public synchronized FilteredBlock applyAndUpdate(Block block) {
         List<Transaction> txns = block.getTransactions();
-        List<Sha256Hash> txHashes = new ArrayList<Sha256Hash>(txns.size());
+        List<Sha256Hash> txHashes = new ArrayList<>(txns.size());
         List<Transaction> matched = Lists.newArrayList();
         byte[] bits = new byte[(int) Math.ceil(txns.size() / 8.0)];
         for (int i = 0; i < txns.size(); i++) {

File: core/src/main/java/org/bitcoinj/core/CheckpointManager.java
Patch:
@@ -76,7 +76,7 @@ public class CheckpointManager {
     private static final int MAX_SIGNATURES = 256;
 
     // Map of block header time to data.
-    protected final TreeMap<Long, StoredBlock> checkpoints = new TreeMap<Long, StoredBlock>();
+    protected final TreeMap<Long, StoredBlock> checkpoints = new TreeMap<>();
 
     protected final NetworkParameters params;
     protected final Sha256Hash dataHash;

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -89,7 +89,7 @@ public Context(NetworkParameters params, int eventHorizon, Coin feePerKb, boolea
 
     private static volatile Context lastConstructed;
     private static boolean isStrictMode;
-    private static final ThreadLocal<Context> slot = new ThreadLocal<Context>();
+    private static final ThreadLocal<Context> slot = new ThreadLocal<>();
 
     /**
      * Returns the current context that is associated with the <b>calling thread</b>. BitcoinJ is an API that has thread

File: core/src/main/java/org/bitcoinj/core/FilteredBlock.java
Patch:
@@ -36,7 +36,7 @@ public class FilteredBlock extends Message {
     
     // A set of transactions whose hashes are a subset of getTransactionHashes()
     // These were relayed as a part of the filteredblock getdata, ie likely weren't previously received as loose transactions
-    private Map<Sha256Hash, Transaction> associatedTransactions = new HashMap<Sha256Hash, Transaction>();
+    private Map<Sha256Hash, Transaction> associatedTransactions = new HashMap<>();
     
     public FilteredBlock(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
         super(params, payloadBytes, 0);
@@ -76,7 +76,7 @@ protected void parse() throws ProtocolException {
     public List<Sha256Hash> getTransactionHashes() throws VerificationException {
         if (cachedTransactionHashes != null)
             return Collections.unmodifiableList(cachedTransactionHashes);
-        List<Sha256Hash> hashesMatched = new LinkedList<Sha256Hash>();
+        List<Sha256Hash> hashesMatched = new LinkedList<>();
         if (header.getMerkleRoot().equals(merkleTree.getTxnHashAndMerkleRoot(hashesMatched))) {
             cachedTransactionHashes = hashesMatched;
             return Collections.unmodifiableList(cachedTransactionHashes);

File: core/src/main/java/org/bitcoinj/core/GetBlocksMessage.java
Patch:
@@ -53,7 +53,7 @@ protected void parse() throws ProtocolException {
         if (startCount > 500)
             throw new ProtocolException("Number of locators cannot be > 500, received: " + startCount);
         length = cursor - offset + ((startCount + 1) * 32);
-        locator = new ArrayList<Sha256Hash>(startCount);
+        locator = new ArrayList<>(startCount);
         for (int i = 0; i < startCount; i++) {
             locator.add(readHash());
         }

File: core/src/main/java/org/bitcoinj/core/HeadersMessage.java
Patch:
@@ -71,7 +71,7 @@ protected void parse() throws ProtocolException {
             throw new ProtocolException("Too many headers: got " + numHeaders + " which is larger than " +
                                          MAX_HEADERS);
 
-        blockHeaders = new ArrayList<Block>();
+        blockHeaders = new ArrayList<>();
         final BitcoinSerializer serializer = this.params.getSerializer(true);
 
         for (int i = 0; i < numHeaders; ++i) {

File: core/src/main/java/org/bitcoinj/core/ListMessage.java
Patch:
@@ -47,7 +47,7 @@ public ListMessage(NetworkParameters params, byte[] payload, MessageSerializer s
 
     public ListMessage(NetworkParameters params) {
         super(params);
-        items = new ArrayList<InventoryItem>();
+        items = new ArrayList<>();
         length = 1; //length of 0 varint;
     }
 
@@ -77,7 +77,7 @@ protected void parse() throws ProtocolException {
         length = (int) (cursor - offset + (arrayLen * InventoryItem.MESSAGE_LENGTH));
 
         // An inv is vector<CInv> where CInv is int+hash. The int is either 1 or 2 for tx or block.
-        items = new ArrayList<InventoryItem>((int) arrayLen);
+        items = new ArrayList<>((int) arrayLen);
         for (int i = 0; i < arrayLen; i++) {
             if (cursor + InventoryItem.MESSAGE_LENGTH > payload.length) {
                 throw new ProtocolException("Ran off the end of the INV");

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -104,7 +104,7 @@ public abstract class NetworkParameters {
     protected String[] dnsSeeds;
     protected int[] addrSeeds;
     protected HttpDiscovery.Details[] httpSeeds = {};
-    protected Map<Integer, Sha256Hash> checkpoints = new HashMap<Integer, Sha256Hash>();
+    protected Map<Integer, Sha256Hash> checkpoints = new HashMap<>();
     protected transient MessageSerializer defaultSerializer = null;
 
     protected NetworkParameters() {

File: core/src/main/java/org/bitcoinj/core/NotFoundMessage.java
Patch:
@@ -38,6 +38,6 @@ public NotFoundMessage(NetworkParameters params, byte[] payloadBytes) throws Pro
 
     public NotFoundMessage(NetworkParameters params, List<InventoryItem> items) {
         super(params);
-        this.items = new ArrayList<InventoryItem>(items);
+        this.items = new ArrayList<>(items);
     }
 }

File: core/src/main/java/org/bitcoinj/core/PartialMerkleTree.java
Patch:
@@ -89,8 +89,8 @@ public static PartialMerkleTree buildFromLeaves(NetworkParameters params, byte[]
         int height = 0;
         while (getTreeWidth(allLeafHashes.size(), height) > 1)
             height++;
-        List<Boolean> bitList = new ArrayList<Boolean>();
-        List<Sha256Hash> hashes = new ArrayList<Sha256Hash>();
+        List<Boolean> bitList = new ArrayList<>();
+        List<Sha256Hash> hashes = new ArrayList<>();
         traverseAndBuild(height, 0, allLeafHashes, includeBits, bitList, hashes);
         byte[] bits = new byte[(int)Math.ceil(bitList.size() / 8.0)];
         for (int i = 0; i < bitList.size(); i++)
@@ -116,7 +116,7 @@ protected void parse() throws ProtocolException {
         transactionCount = (int)readUint32();
 
         int nHashes = (int) readVarInt();
-        hashes = new ArrayList<Sha256Hash>(nHashes);
+        hashes = new ArrayList<>(nHashes);
         for (int i = 0; i < nHashes; i++)
             hashes.add(readHash());
 

File: core/src/main/java/org/bitcoinj/core/TransactionConfidence.java
Patch:
@@ -145,8 +145,8 @@ public enum Source {
 
     public TransactionConfidence(Sha256Hash hash) {
         // Assume a default number of peers for our set.
-        broadcastBy = new CopyOnWriteArrayList<PeerAddress>();
-        listeners = new CopyOnWriteArrayList<ListenerRegistration<Listener>>();
+        broadcastBy = new CopyOnWriteArrayList<>();
+        listeners = new CopyOnWriteArrayList<>();
         this.hash = hash;
     }
 
@@ -206,7 +206,7 @@ enum ChangeReason {
      */
     public void addEventListener(Executor executor, Listener listener) {
         checkNotNull(listener);
-        listeners.addIfAbsent(new ListenerRegistration<Listener>(listener, executor));
+        listeners.addIfAbsent(new ListenerRegistration<>(listener, executor));
         pinnedConfidenceObjects.add(this);
     }
 

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -165,14 +165,14 @@ public Script getScriptSig() throws ScriptException {
         Script script = scriptSig == null ? null : scriptSig.get();
         if (script == null) {
             script = new Script(scriptBytes);
-            scriptSig = new WeakReference<Script>(script);
+            scriptSig = new WeakReference<>(script);
         }
         return script;
     }
 
     /** Set the given program as the scriptSig that is supposed to satisfy the connected output script. */
     public void setScriptSig(Script scriptSig) {
-        this.scriptSig = new WeakReference<Script>(checkNotNull(scriptSig));
+        this.scriptSig = new WeakReference<>(checkNotNull(scriptSig));
         // TODO: This should all be cleaned up so we have a consistent internal representation.
         setScriptBytes(scriptSig.getProgram());
     }

File: core/src/main/java/org/bitcoinj/core/TransactionOutputChanges.java
Patch:
@@ -42,15 +42,15 @@ public TransactionOutputChanges(InputStream in) throws IOException {
                              ((in.read() & 0xFF) << 8) |
                              ((in.read() & 0xFF) << 16) |
                              ((in.read() & 0xFF) << 24);
-        txOutsCreated = new LinkedList<UTXO>();
+        txOutsCreated = new LinkedList<>();
         for (int i = 0; i < numOutsCreated; i++)
             txOutsCreated.add(new UTXO(in));
         
         int numOutsSpent = (in.read() & 0xFF) |
                            ((in.read() & 0xFF) << 8) |
                            ((in.read() & 0xFF) << 16) |
                            ((in.read() & 0xFF) << 24);
-        txOutsSpent = new LinkedList<UTXO>();
+        txOutsSpent = new LinkedList<>();
         for (int i = 0; i < numOutsSpent; i++)
             txOutsSpent.add(new UTXO(in));
     }

File: core/src/main/java/org/bitcoinj/core/TxConfidenceTable.java
Patch:
@@ -72,7 +72,7 @@ protected boolean removeEldestEntry(Map.Entry<Sha256Hash, WeakConfidenceReferenc
                 return size() > size;
             }
         };
-        referenceQueue = new ReferenceQueue<TransactionConfidence>();
+        referenceQueue = new ReferenceQueue<>();
     }
 
     /**

File: core/src/main/java/org/bitcoinj/core/UTXOsMessage.java
Patch:
@@ -67,7 +67,7 @@ public UTXOsMessage(NetworkParameters params, List<TransactionOutput> outputs, l
             if (outputs.get(i) != null)
                 Utils.setBitLE(hits, i);
         }
-        this.outputs = new ArrayList<TransactionOutput>(outputs.size());
+        this.outputs = new ArrayList<>(outputs.size());
         for (TransactionOutput output : outputs) {
             if (output != null) this.outputs.add(output);
         }
@@ -111,7 +111,7 @@ protected void parse() throws ProtocolException {
         int numOuts = (int) readVarInt();
         if (numOuts < 0 || numOuts > InventoryMessage.MAX_INVENTORY_ITEMS)
             throw new ProtocolException("numOuts out of range: " + numOuts);
-        outputs = new ArrayList<TransactionOutput>(numOuts);
+        outputs = new ArrayList<>(numOuts);
         heights = new long[numOuts];
         for (int i = 0; i < numOuts; i++) {
             long version = readUint32();
@@ -135,7 +135,7 @@ public byte[] getHitMap() {
 
     /** Returns the list of outputs that matched the query. */
     public List<TransactionOutput> getOutputs() {
-        return new ArrayList<TransactionOutput>(outputs);
+        return new ArrayList<>(outputs);
     }
 
     /** Returns the block heights of each output returned in getOutputs(), or MEMPOOL_HEIGHT if not confirmed yet. */

File: core/src/main/java/org/bitcoinj/core/Utils.java
Patch:
@@ -552,7 +552,7 @@ public static void sleep(long millis) {
     /** Enable or disable mock sleep.  If enabled, set mock time to current time. */
     public static void setMockSleep(boolean isEnable) {
         if (isEnable) {
-            mockSleepQueue = new ArrayBlockingQueue<Boolean>(1);
+            mockSleepQueue = new ArrayBlockingQueue<>(1);
             mockTime = new Date(System.currentTimeMillis());
         } else {
             mockSleepQueue = null;
@@ -589,7 +589,7 @@ private static class Pair implements Comparable<Pair> {
 
     public static int maxOfMostFreq(int... items) {
         // Java 6 sucks.
-        ArrayList<Integer> list = new ArrayList<Integer>(items.length);
+        ArrayList<Integer> list = new ArrayList<>(items.length);
         for (int item : items) list.add(item);
         return maxOfMostFreq(list);
     }

File: core/src/main/java/org/bitcoinj/crypto/HDUtils.java
Patch:
@@ -91,7 +91,7 @@ public static String formatPath(List<ChildNumber> path) {
      */
     public static List<ChildNumber> parsePath(@Nonnull String path) {
         String[] parsedNodes = path.replace("M", "").split("/");
-        List<ChildNumber> nodes = new ArrayList<ChildNumber>();
+        List<ChildNumber> nodes = new ArrayList<>();
 
         for (String n : parsedNodes) {
             n = n.replaceAll(" ", "");

File: core/src/main/java/org/bitcoinj/crypto/MnemonicCode.java
Patch:
@@ -87,7 +87,7 @@ private static InputStream openDefaultWords() throws IOException {
      */
     public MnemonicCode(InputStream wordstream, String wordListDigest) throws IOException, IllegalArgumentException {
         BufferedReader br = new BufferedReader(new InputStreamReader(wordstream, "UTF-8"));
-        this.wordList = new ArrayList<String>(2048);
+        this.wordList = new ArrayList<>(2048);
         MessageDigest md = Sha256Hash.newDigest();
         String word;
         while ((word = br.readLine()) != null) {
@@ -216,7 +216,7 @@ public List<String> toMnemonic(byte[] entropy) throws MnemonicException.Mnemonic
         // which is a position in a wordlist.  We convert numbers into
         // words and use joined words as mnemonic sentence.
 
-        ArrayList<String> words = new ArrayList<String>();
+        ArrayList<String> words = new ArrayList<>();
         int nwords = concatBits.length / 11;
         for (int i = 0; i < nwords; ++i) {
             int index = 0;

File: core/src/main/java/org/bitcoinj/net/ConnectionHandler.java
Patch:
@@ -61,7 +61,7 @@ class ConnectionHandler implements MessageWriteTarget {
     @GuardedBy("lock") private boolean closeCalled = false;
 
     @GuardedBy("lock") private long bytesToWriteRemaining = 0;
-    @GuardedBy("lock") private final LinkedList<ByteBuffer> bytesToWrite = new LinkedList<ByteBuffer>();
+    @GuardedBy("lock") private final LinkedList<ByteBuffer> bytesToWrite = new LinkedList<>();
 
     private Set<ConnectionHandler> connectedHandlers;
 

File: core/src/main/java/org/bitcoinj/net/NioClientManager.java
Patch:
@@ -46,7 +46,7 @@ class PendingConnect {
 
         PendingConnect(SocketChannel sc, StreamConnection connection, SocketAddress address) { this.sc = sc; this.connection = connection; this.address = address; }
     }
-    final Queue<PendingConnect> newConnectionChannels = new LinkedBlockingQueue<PendingConnect>();
+    final Queue<PendingConnect> newConnectionChannels = new LinkedBlockingQueue<>();
 
     // Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
     private final Set<ConnectionHandler> connectedHandlers = Collections.synchronizedSet(new HashSet<ConnectionHandler>());

File: core/src/main/java/org/bitcoinj/net/ProtobufConnection.java
Patch:
@@ -77,7 +77,7 @@ public interface Listener<MessageType extends MessageLite> {
     @GuardedBy("lock") private byte[] messageBytes;
     private final ReentrantLock lock = Threading.lock("ProtobufConnection");
 
-    @VisibleForTesting final AtomicReference<MessageWriteTarget> writeTarget = new AtomicReference<MessageWriteTarget>();
+    @VisibleForTesting final AtomicReference<MessageWriteTarget> writeTarget = new AtomicReference<>();
 
     /**
      * Creates a new protobuf handler.

File: core/src/main/java/org/bitcoinj/net/discovery/DnsDiscovery.java
Patch:
@@ -56,7 +56,7 @@ public DnsDiscovery(String[] dnsSeeds, NetworkParameters params) {
     }
 
     private static List<PeerDiscovery> buildDiscoveries(NetworkParameters params, String[] seeds) {
-        List<PeerDiscovery> discoveries = new ArrayList<PeerDiscovery>();
+        List<PeerDiscovery> discoveries = new ArrayList<>();
         if (seeds != null)
             for (String seed : seeds)
                 discoveries.add(new DnsSeedDiscovery(params, seed));

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java
Patch:
@@ -103,7 +103,7 @@ public enum State {
     protected StoredClientChannel storedChannel;
 
     PaymentChannelClientState(StoredClientChannel storedClientChannel, Wallet wallet) throws VerificationException {
-        this.stateMachine = new StateMachine<State>(State.UNINITIALISED, getStateTransitions());
+        this.stateMachine = new StateMachine<>(State.UNINITIALISED, getStateTransitions());
         this.wallet = checkNotNull(wallet);
         this.myKey = checkNotNull(storedClientChannel.myKey);
         this.serverKey = checkNotNull(storedClientChannel.serverKey);
@@ -140,7 +140,7 @@ public synchronized boolean isSettlementTransaction(Transaction tx) {
      */
     public PaymentChannelClientState(Wallet wallet, ECKey myKey, ECKey serverKey,
                                      Coin value, long expiryTimeInSeconds) throws VerificationException {
-        this.stateMachine = new StateMachine<State>(State.UNINITIALISED, getStateTransitions());
+        this.stateMachine = new StateMachine<>(State.UNINITIALISED, getStateTransitions());
         this.wallet = checkNotNull(wallet);
         this.serverKey = checkNotNull(serverKey);
         this.myKey = checkNotNull(myKey);

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -117,7 +117,7 @@ public enum State {
 
     PaymentChannelServerState(StoredServerChannel storedServerChannel, Wallet wallet, TransactionBroadcaster broadcaster) throws VerificationException {
         synchronized (storedServerChannel) {
-            this.stateMachine = new StateMachine<State>(State.UNINITIALISED, getStateTransitions());
+            this.stateMachine = new StateMachine<>(State.UNINITIALISED, getStateTransitions());
             this.wallet = checkNotNull(wallet);
             this.broadcaster = checkNotNull(broadcaster);
             this.contract = checkNotNull(storedServerChannel.contract);
@@ -141,7 +141,7 @@ public enum State {
      * @param minExpireTime The earliest time at which the client can claim the refund transaction (UNIX timestamp of block)
      */
     public PaymentChannelServerState(TransactionBroadcaster broadcaster, Wallet wallet, ECKey serverKey, long minExpireTime) {
-        this.stateMachine = new StateMachine<State>(State.UNINITIALISED, getStateTransitions());
+        this.stateMachine = new StateMachine<>(State.UNINITIALISED, getStateTransitions());
         this.serverKey = checkNotNull(serverKey);
         this.wallet = checkNotNull(wallet);
         this.broadcaster = checkNotNull(broadcaster);

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelServerStates.java
Patch:
@@ -47,7 +47,7 @@ public class StoredPaymentChannelServerStates implements WalletExtension {
     static final String EXTENSION_ID = StoredPaymentChannelServerStates.class.getName();
     static final int MAX_SECONDS_TO_WAIT_FOR_BROADCASTER_TO_BE_SET = 10;
 
-    @GuardedBy("lock") @VisibleForTesting final Map<Sha256Hash, StoredServerChannel> mapChannels = new HashMap<Sha256Hash, StoredServerChannel>();
+    @GuardedBy("lock") @VisibleForTesting final Map<Sha256Hash, StoredServerChannel> mapChannels = new HashMap<>();
     private Wallet wallet;
     private final SettableFuture<TransactionBroadcaster> broadcasterFuture = SettableFuture.create();
 

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocol.java
Patch:
@@ -340,7 +340,7 @@ public static Protos.Payment createPaymentMessage(List<Transaction> transactions
      */
     public static List<Transaction> parseTransactionsFromPaymentMessage(NetworkParameters params,
             Protos.Payment paymentMessage) {
-        final List<Transaction> transactions = new ArrayList<Transaction>(paymentMessage.getTransactionsCount());
+        final List<Transaction> transactions = new ArrayList<>(paymentMessage.getTransactionsCount());
         for (final ByteString transaction : paymentMessage.getTransactionsList())
             transactions.add(params.getDefaultSerializer().makeTransaction(transaction.toByteArray()));
         return transactions;

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentSession.java
Patch:
@@ -224,7 +224,7 @@ public PaymentSession(Protos.PaymentRequest request, boolean verifyPki, @Nullabl
      * Returns the outputs of the payment request.
      */
     public List<PaymentProtocol.Output> getOutputs() {
-        List<PaymentProtocol.Output> outputs = new ArrayList<PaymentProtocol.Output>(paymentDetails.getOutputsCount());
+        List<PaymentProtocol.Output> outputs = new ArrayList<>(paymentDetails.getOutputsCount());
         for (Protos.Output output : paymentDetails.getOutputsList()) {
             Coin amount = output.hasAmount() ? Coin.valueOf(output.getAmount()) : null;
             outputs.add(new PaymentProtocol.Output(amount, output.getScript().toByteArray()));

File: core/src/main/java/org/bitcoinj/signers/TransactionSigner.java
Patch:
@@ -54,7 +54,7 @@ class ProposedTransaction {
 
         public ProposedTransaction(Transaction partialTx) {
             this.partialTx = partialTx;
-            this.keyPaths = new HashMap<Script, List<ChildNumber>>();
+            this.keyPaths = new HashMap<>();
         }
     }
 

File: core/src/main/java/org/bitcoinj/store/H2FullPrunedBlockStore.java
Patch:
@@ -133,7 +133,7 @@ protected String getDuplicateKeyErrorCode() {
 
     @Override
     protected List<String> getCreateTablesSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add(CREATE_SETTINGS_TABLE);
         sqlStatements.add(CREATE_HEADERS_TABLE);
         sqlStatements.add(CREATE_UNDOABLE_TABLE);
@@ -143,7 +143,7 @@ protected List<String> getCreateTablesSQL() {
 
     @Override
     protected List<String> getCreateIndexesSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add(CREATE_UNDOABLE_TABLE_INDEX);
         sqlStatements.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
         sqlStatements.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);

File: core/src/main/java/org/bitcoinj/store/MySQLFullPrunedBlockStore.java
Patch:
@@ -125,7 +125,7 @@ protected String getTransactionOutputSelectSQL() {
 
     @Override
     protected List<String> getCreateTablesSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add(CREATE_SETTINGS_TABLE);
         sqlStatements.add(CREATE_HEADERS_TABLE);
         sqlStatements.add(CREATE_UNDOABLE_TABLE);
@@ -135,7 +135,7 @@ protected List<String> getCreateTablesSQL() {
 
     @Override
     protected List<String> getCreateIndexesSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add(CREATE_UNDOABLE_TABLE_INDEX);
         sqlStatements.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
         sqlStatements.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);

File: core/src/main/java/org/bitcoinj/store/PostgresFullPrunedBlockStore.java
Patch:
@@ -133,7 +133,7 @@ protected String getDuplicateKeyErrorCode() {
 
     @Override
     protected List<String> getCreateTablesSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add(CREATE_SETTINGS_TABLE);
         sqlStatements.add(CREATE_HEADERS_TABLE);
         sqlStatements.add(CREATE_UNDOABLE_TABLE);
@@ -143,7 +143,7 @@ protected List<String> getCreateTablesSQL() {
 
     @Override
     protected List<String> getCreateIndexesSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add(CREATE_UNDOABLE_TABLE_INDEX);
         sqlStatements.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
         sqlStatements.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);
@@ -154,7 +154,7 @@ protected List<String> getCreateIndexesSQL() {
 
     @Override
     protected List<String> getCreateSchemeSQL() {
-        List<String> sqlStatements = new ArrayList<String>();
+        List<String> sqlStatements = new ArrayList<>();
         sqlStatements.add("CREATE SCHEMA IF NOT EXISTS " + schemaName);
         sqlStatements.add("set search_path to '" + schemaName +"'");
         return sqlStatements;

File: core/src/main/java/org/bitcoinj/uri/BitcoinURI.java
Patch:
@@ -98,7 +98,7 @@ public class BitcoinURI {
     /**
      * Contains all the parameters in the order in which they were processed
      */
-    private final Map<String, Object> parameterMap = new LinkedHashMap<String, Object>();
+    private final Map<String, Object> parameterMap = new LinkedHashMap<>();
 
     /**
      * Constructs a new BitcoinURI from the given string. Can be for any network.
@@ -299,7 +299,7 @@ public final String getPaymentRequestUrl() {
      * all subsequent URLs are fallbacks.
      */
     public List<String> getPaymentRequestUrls() {
-        ArrayList<String> urls = new ArrayList<String>();
+        ArrayList<String> urls = new ArrayList<>();
         while (true) {
             int i = urls.size();
             String paramName = FIELD_PAYMENT_REQUEST_URL + (i > 0 ? Integer.toString(i) : "");

File: core/src/main/java/org/bitcoinj/utils/BaseTaggableObject.java
Patch:
@@ -57,7 +57,7 @@ public synchronized void setTag(String tag, ByteString value) {
         checkNotNull(tag);
         checkNotNull(value);
         if (tags == null)
-            tags = new HashMap<String, ByteString>();
+            tags = new HashMap<>();
         tags.put(tag, value);
     }
 

File: core/src/main/java/org/bitcoinj/utils/BlockFileLoader.java
Patch:
@@ -61,7 +61,7 @@ public static List<File> getReferenceClientBlockFileList() {
             defaultDataDir = System.getProperty("user.home") + "/.bitcoin/blocks/";
         }
         
-        List<File> list = new LinkedList<File>();
+        List<File> list = new LinkedList<>();
         for (int i = 0; true; i++) {
             File file = new File(defaultDataDir + String.format(Locale.US, "blk%05d.dat", i));
             if (!file.exists())

File: core/src/main/java/org/bitcoinj/utils/BtcFormat.java
Patch:
@@ -923,7 +923,7 @@ public static BtcFormat getInstance(Style style, Locale locale, int fractionPlac
     public static BtcFormat getCoinInstance() { return getCoinInstance(defaultLocale()); }
 
     private static List<Integer> boxAsList(int[] elements) throws IllegalArgumentException {
-        List<Integer> list = new ArrayList<Integer>(elements.length);
+        List<Integer> list = new ArrayList<>(elements.length);
         for (int e : elements) {
             checkArgument(e > 0, "Size of decimal group must be at least one.");
             list.add(e);

File: core/src/main/java/org/bitcoinj/utils/MonetaryFormat.java
Patch:
@@ -157,7 +157,7 @@ public MonetaryFormat minDecimals(int minDecimals) {
      *            any number numbers of decimals, one for each group
      */
     public MonetaryFormat optionalDecimals(int... groups) {
-        List<Integer> decimalGroups = new ArrayList<Integer>(groups.length);
+        List<Integer> decimalGroups = new ArrayList<>(groups.length);
         for (int group : groups)
             decimalGroups.add(group);
         return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups,
@@ -183,7 +183,7 @@ public MonetaryFormat optionalDecimals(int... groups) {
      */
     public MonetaryFormat repeatOptionalDecimals(int decimals, int repetitions) {
         checkArgument(repetitions >= 0);
-        List<Integer> decimalGroups = new ArrayList<Integer>(repetitions);
+        List<Integer> decimalGroups = new ArrayList<>(repetitions);
         for (int i = 0; i < repetitions; i++)
             decimalGroups.add(decimals);
         return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups,

File: core/src/main/java/org/bitcoinj/utils/Threading.java
Patch:
@@ -95,7 +95,7 @@ public static class UserThread extends Thread implements Executor {
         public UserThread() {
             super("bitcoinj user thread");
             setDaemon(true);
-            tasks = new LinkedBlockingQueue<Runnable>();
+            tasks = new LinkedBlockingQueue<>();
             start();
         }
 

File: core/src/main/java/org/bitcoinj/utils/VersionTally.java
Patch:
@@ -99,7 +99,7 @@ public Integer getCountAtOrAbove(final long version) {
     public void initialize(final BlockStore blockStore, final StoredBlock chainHead)
         throws BlockStoreException {
         StoredBlock versionBlock = chainHead;
-        final Stack<Long> versions = new Stack<Long>();
+        final Stack<Long> versions = new Stack<>();
 
         // We don't know how many blocks back we can go, so load what we can first
         versions.push(versionBlock.getHeader().getVersion());

File: core/src/main/java/org/bitcoinj/wallet/DecryptingKeyBag.java
Patch:
@@ -54,7 +54,7 @@ else if (key.isEncrypted()) {
     }
 
     private RedeemData maybeDecrypt(RedeemData redeemData) {
-        List<ECKey> decryptedKeys = new ArrayList<ECKey>();
+        List<ECKey> decryptedKeys = new ArrayList<>();
         for (ECKey key : redeemData.keys) {
             decryptedKeys.add(maybeDecrypt(key));
         }

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -34,10 +34,10 @@
 public class DefaultCoinSelector implements CoinSelector {
     @Override
     public CoinSelection select(Coin target, List<TransactionOutput> candidates) {
-        ArrayList<TransactionOutput> selected = new ArrayList<TransactionOutput>();
+        ArrayList<TransactionOutput> selected = new ArrayList<>();
         // Sort the inputs by age*value so we get the highest "coindays" spent.
         // TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
-        ArrayList<TransactionOutput> sortedOutputs = new ArrayList<TransactionOutput>(candidates);
+        ArrayList<TransactionOutput> sortedOutputs = new ArrayList<>(candidates);
         // When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid sorting
         // them in order to improve performance.
         // TODO: Take in network parameters when instanatiated, and then test against the current network. Or just have a boolean parameter for "give me everything"

File: core/src/main/java/org/bitcoinj/wallet/FilteringCoinSelector.java
Patch:
@@ -27,7 +27,7 @@
  */
 public class FilteringCoinSelector implements CoinSelector {
     protected CoinSelector delegate;
-    protected HashSet<TransactionOutPoint> spent = new HashSet<TransactionOutPoint>();
+    protected HashSet<TransactionOutPoint> spent = new HashSet<>();
 
     public FilteringCoinSelector(CoinSelector delegate) {
         this.delegate = delegate;

File: core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java
Patch:
@@ -57,7 +57,7 @@
 public class MarriedKeyChain extends DeterministicKeyChain {
     // The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
     // mapped to redeem script hashes.
-    private LinkedHashMap<ByteString, RedeemData> marriedKeysRedeemData = new LinkedHashMap<ByteString, RedeemData>();
+    private LinkedHashMap<ByteString, RedeemData> marriedKeysRedeemData = new LinkedHashMap<>();
 
     private List<DeterministicKeyChain> followingKeyChains;
 

File: core/src/main/java/org/bitcoinj/wallet/RedeemData.java
Patch:
@@ -39,7 +39,7 @@ public class RedeemData {
 
     private RedeemData(List<ECKey> keys, Script redeemScript) {
         this.redeemScript = redeemScript;
-        List<ECKey> sortedKeys = new ArrayList<ECKey>(keys);
+        List<ECKey> sortedKeys = new ArrayList<>(keys);
         Collections.sort(sortedKeys, ECKey.PUBKEY_COMPARATOR);
         this.keys = sortedKeys;
     }

File: core/src/main/java/org/bitcoinj/wallet/WalletProtobufSerializer.java
Patch:
@@ -99,7 +99,7 @@ public Wallet create(NetworkParameters params, KeyChainGroup keyChainGroup) {
     }
 
     public WalletProtobufSerializer(WalletFactory factory) {
-        txMap = new HashMap<ByteString, Transaction>();
+        txMap = new HashMap<>();
         this.factory = factory;
         this.keyChainFactory = new DefaultKeyChainFactory();
     }
@@ -577,7 +577,7 @@ public Wallet readWallet(NetworkParameters params, @Nullable WalletExtension[] e
     }
 
     private void loadExtensions(Wallet wallet, WalletExtension[] extensionsList, Protos.Wallet walletProto) throws UnreadableWalletException {
-        final Map<String, WalletExtension> extensions = new HashMap<String, WalletExtension>();
+        final Map<String, WalletExtension> extensions = new HashMap<>();
         for (WalletExtension e : extensionsList)
             extensions.put(e.getWalletExtensionID(), e);
         // The Wallet object, if subclassed, might have added some extensions to itself already. In that case, don't

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -193,12 +193,12 @@ public void testFinalizedBlocks() throws Exception {
         rollingBlock.solve();
         
         chain.add(rollingBlock);
-        WeakReference<StoredUndoableBlock> undoBlock = new WeakReference<StoredUndoableBlock>(store.getUndoBlock(rollingBlock.getHash()));
+        WeakReference<StoredUndoableBlock> undoBlock = new WeakReference<>(store.getUndoBlock(rollingBlock.getHash()));
 
         StoredUndoableBlock storedUndoableBlock = undoBlock.get();
         assertNotNull(storedUndoableBlock);
         assertNull(storedUndoableBlock.getTransactions());
-        WeakReference<TransactionOutputChanges> changes = new WeakReference<TransactionOutputChanges>(storedUndoableBlock.getTxOutChanges());
+        WeakReference<TransactionOutputChanges> changes = new WeakReference<>(storedUndoableBlock.getTxOutChanges());
         assertNotNull(changes.get());
         storedUndoableBlock = null;   // Blank the reference so it can be GCd.
         

File: core/src/test/java/org/bitcoinj/core/ChainSplitTest.java
Patch:
@@ -400,7 +400,7 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
     public void txConfidenceLevels() throws Exception {
         // Check that as the chain forks and re-orgs, the confidence data associated with each transaction is
         // maintained correctly.
-        final ArrayList<Transaction> txns = new ArrayList<Transaction>(3);
+        final ArrayList<Transaction> txns = new ArrayList<>(3);
         wallet.addCoinsReceivedEventListener(new WalletCoinsReceivedEventListener() {
             @Override
             public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {
@@ -558,7 +558,7 @@ public void coinbaseDeath() throws Exception {
         // Check that a coinbase tx is marked as dead after a reorg rather than pending as normal non-double-spent
         // transactions would be. Also check that a dead coinbase on a sidechain is resurrected if the sidechain
         // becomes the best chain once more. Finally, check that dependent transactions are killed recursively.
-        final ArrayList<Transaction> txns = new ArrayList<Transaction>(3);
+        final ArrayList<Transaction> txns = new ArrayList<>(3);
         wallet.addCoinsReceivedEventListener(Threading.SAME_THREAD, new WalletCoinsReceivedEventListener() {
             @Override
             public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {

File: core/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -224,7 +224,7 @@ public void invTickle() throws Exception {
         inbound(writeTarget, inv);
 
         GetBlocksMessage getblocks = (GetBlocksMessage)outbound(writeTarget);
-        List<Sha256Hash> expectedLocator = new ArrayList<Sha256Hash>();
+        List<Sha256Hash> expectedLocator = new ArrayList<>();
         expectedLocator.add(b1.getHash());
         expectedLocator.add(PARAMS.getGenesisBlock().getHash());
         
@@ -395,7 +395,7 @@ public void onChainDownloadStarted(Peer p, int blocksLeft) {
         });
         peer.startBlockChainDownload();
 
-        List<Sha256Hash> expectedLocator = new ArrayList<Sha256Hash>();
+        List<Sha256Hash> expectedLocator = new ArrayList<>();
         expectedLocator.add(b2.getHash());
         expectedLocator.add(b1.getHash());
         expectedLocator.add(PARAMS.getGenesisBlock().getHash());
@@ -477,7 +477,7 @@ public void fastCatchup() throws Exception {
         peer.setDownloadParameters(Utils.currentTimeSeconds() - (600*2) + 1, false);
         peer.startBlockChainDownload();
         GetHeadersMessage getheaders = (GetHeadersMessage) outbound(writeTarget);
-        List<Sha256Hash> expectedLocator = new ArrayList<Sha256Hash>();
+        List<Sha256Hash> expectedLocator = new ArrayList<>();
         expectedLocator.add(b1.getHash());
         expectedLocator.add(PARAMS.getGenesisBlock().getHash());
         assertEquals(getheaders.getLocator(), expectedLocator);

File: core/src/test/java/org/bitcoinj/core/TransactionTest.java
Patch:
@@ -299,7 +299,7 @@ public void testTheTXByHeightComparator() {
         Transaction tx3 = FakeTxBuilder.createFakeTx(PARAMS);
         tx3.getConfidence().setAppearedAtChainHeight(3);
 
-        SortedSet<Transaction> set = new TreeSet<Transaction>(Transaction.SORT_TX_BY_HEIGHT);
+        SortedSet<Transaction> set = new TreeSet<>(Transaction.SORT_TX_BY_HEIGHT);
         set.add(tx2);
         set.add(tx1);
         set.add(tx3);

File: core/src/test/java/org/bitcoinj/crypto/MnemonicCodeTest.java
Patch:
@@ -213,6 +213,6 @@ public void testEmptyEntropy() throws Exception {
     }
 
     public static List<String> split(String words) {
-        return new ArrayList<String>(Arrays.asList(words.split("\\s+")));
+        return new ArrayList<>(Arrays.asList(words.split("\\s+")));
     }
 }

File: core/src/test/java/org/bitcoinj/protocols/channels/ChannelConnectionTest.java
Patch:
@@ -124,7 +124,7 @@ public void setUp() throws Exception {
 
         // Set up a way to monitor broadcast transactions. When you expect a broadcast, you must release a permit
         // to the broadcastTxPause semaphore so state can be queried in between.
-        broadcasts = new LinkedBlockingQueue<Transaction>();
+        broadcasts = new LinkedBlockingQueue<>();
         broadcastTxPause = new Semaphore(0);
         mockBroadcaster = new TransactionBroadcaster() {
             @Override
@@ -177,7 +177,7 @@ private void exectuteSimpleChannelTest(KeyParameter userKeySetup) throws Excepti
         // Test with network code and without any issues. We'll broadcast two txns: multisig contract and settle transaction.
         final SettableFuture<ListenableFuture<PaymentChannelV1ServerState>> serverCloseFuture = SettableFuture.create();
         final SettableFuture<Sha256Hash> channelOpenFuture = SettableFuture.create();
-        final BlockingQueue<ChannelTestUtils.UpdatePair> q = new LinkedBlockingQueue<ChannelTestUtils.UpdatePair>();
+        final BlockingQueue<ChannelTestUtils.UpdatePair> q = new LinkedBlockingQueue<>();
         final PaymentChannelServerListener server = new PaymentChannelServerListener(mockBroadcaster, serverWallet, 30, COIN,
                 new PaymentChannelServerListener.HandlerFactory() {
                     @Nullable

File: core/src/test/java/org/bitcoinj/protocols/channels/ChannelTestUtils.java
Patch:
@@ -39,7 +39,7 @@
  */
 public class ChannelTestUtils {
     public static class RecordingServerConnection implements PaymentChannelServer.ServerConnection {
-        public BlockingQueue<Object> q = new LinkedBlockingQueue<Object>();
+        public BlockingQueue<Object> q = new LinkedBlockingQueue<>();
 
         @Override
         public void sendToClient(Protos.TwoWayChannelMessage msg) {
@@ -85,7 +85,7 @@ public void checkTotalPayment(Coin valueSoFar) throws InterruptedException {
     }
 
     public static class RecordingClientConnection implements PaymentChannelClient.ClientConnection {
-        public BlockingQueue<Object> q = new LinkedBlockingQueue<Object>();
+        public BlockingQueue<Object> q = new LinkedBlockingQueue<>();
         static final int IGNORE_EXPIRE = -1;
         private final int maxExpireTime;
 

File: core/src/test/java/org/bitcoinj/protocols/channels/PaymentChannelClientTest.java
Patch:
@@ -85,7 +85,7 @@ public void before() {
         maxValue = Coin.COIN;
         serverHash = Sha256Hash.of("serverId".getBytes());
         connection = createMock(IPaymentChannelClient.ClientConnection.class);
-        clientVersionCapture = new Capture<TwoWayChannelMessage>();
+        clientVersionCapture = new Capture<>();
     }
 
     @Test

File: core/src/test/java/org/bitcoinj/protocols/channels/PaymentChannelStateTest.java
Patch:
@@ -105,7 +105,7 @@ public TransactionBroadcast broadcastTransaction(Transaction tx) {
         serverKey = serverWallet.freshReceiveKey();
         chain.addWallet(serverWallet);
 
-        broadcasts = new LinkedBlockingQueue<TxFuturePair>();
+        broadcasts = new LinkedBlockingQueue<>();
         mockBroadcaster = new TransactionBroadcaster() {
             @Override
             public TransactionBroadcast broadcastTransaction(Transaction tx) {

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentProtocolTest.java
Patch:
@@ -121,7 +121,7 @@ public void testPaymentRequest() throws Exception {
     @Test
     public void testPaymentMessage() throws Exception {
         // Create
-        List<Transaction> transactions = new LinkedList<Transaction>();
+        List<Transaction> transactions = new LinkedList<>();
         transactions.add(FakeTxBuilder.createFakeTx(NETWORK_PARAMS, AMOUNT, TO_ADDRESS));
         Coin refundAmount = Coin.SATOSHI;
         Address refundAddress = new ECKey().toAddress(NETWORK_PARAMS);

File: core/src/test/java/org/bitcoinj/store/WalletProtobufSerializerTest.java
Patch:
@@ -233,7 +233,7 @@ public void testAppearedAtChainHeightDepthAndWorkDone() throws Exception {
 
         BlockChain chain = new BlockChain(PARAMS, myWallet, new MemoryBlockStore(PARAMS));
 
-        final ArrayList<Transaction> txns = new ArrayList<Transaction>(2);
+        final ArrayList<Transaction> txns = new ArrayList<>(2);
         myWallet.addCoinsReceivedEventListener(new WalletCoinsReceivedEventListener() {
             @Override
             public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {

File: core/src/test/java/org/bitcoinj/testing/InboundMessageQueuer.java
Patch:
@@ -29,8 +29,8 @@
  * An extension of {@link org.bitcoinj.core.PeerSocketHandler} that keeps inbound messages in a queue for later processing
  */
 public abstract class InboundMessageQueuer extends PeerSocketHandler {
-    public final BlockingQueue<Message> inboundMessages = new ArrayBlockingQueue<Message>(1000);
-    public final Map<Long, SettableFuture<Void>> mapPingFutures = new HashMap<Long, SettableFuture<Void>>();
+    public final BlockingQueue<Message> inboundMessages = new ArrayBlockingQueue<>(1000);
+    public final Map<Long, SettableFuture<Void>> mapPingFutures = new HashMap<>();
 
     public Peer peer;
     public BloomFilter lastReceivedFilter;

File: core/src/test/java/org/bitcoinj/testing/MockTransactionBroadcaster.java
Patch:
@@ -52,7 +52,7 @@ public void succeed() {
         }
     }
 
-    private final LinkedBlockingQueue<TxFuturePair> broadcasts = new LinkedBlockingQueue<TxFuturePair>();
+    private final LinkedBlockingQueue<TxFuturePair> broadcasts = new LinkedBlockingQueue<>();
 
     /** Sets this mock broadcaster on the given wallet. */
     public MockTransactionBroadcaster(Wallet wallet) {

File: core/src/test/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -59,7 +59,7 @@ public class TestWithNetworkConnections {
 
     private NioServer[] peerServers = new NioServer[PEER_SERVERS];
     private final ClientConnectionManager channels;
-    protected final BlockingQueue<InboundMessageQueuer> newPeerWriteTargetQueue = new LinkedBlockingQueue<InboundMessageQueuer>();
+    protected final BlockingQueue<InboundMessageQueuer> newPeerWriteTargetQueue = new LinkedBlockingQueue<>();
 
     public enum ClientType {
         NIO_CLIENT_MANAGER,

File: core/src/test/java/org/bitcoinj/utils/BtcFormatTest.java
Patch:
@@ -44,7 +44,7 @@ public class BtcFormatTest {
 
     @Parameters
     public static Set<Locale[]> data() {
-        Set<Locale[]> localeSet = new HashSet<Locale[]>();
+        Set<Locale[]> localeSet = new HashSet<>();
         for (Locale locale : Locale.getAvailableLocales()) {
             localeSet.add(new Locale[]{locale});
         }

File: core/src/test/java/org/bitcoinj/utils/ExponentialBackoffTest.java
Patch:
@@ -60,7 +60,7 @@ public void testFailure() {
 
     @Test
     public void testInQueue() {
-        PriorityQueue<ExponentialBackoff> queue = new PriorityQueue<ExponentialBackoff>();
+        PriorityQueue<ExponentialBackoff> queue = new PriorityQueue<>();
         ExponentialBackoff backoff1 = new ExponentialBackoff(params);
         backoff.trackFailure();
         backoff.trackFailure();

File: core/src/test/java/org/bitcoinj/wallet/BasicKeyChainTest.java
Patch:
@@ -50,7 +50,7 @@ public class BasicKeyChainTest {
     @Before
     public void setup() {
         chain = new BasicKeyChain();
-        onKeysAdded = new AtomicReference<List<ECKey>>();
+        onKeysAdded = new AtomicReference<>();
         onKeysAddedRan = new AtomicBoolean();
         chain.addEventListener(new AbstractKeyChainEventListener() {
             @Override

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -78,7 +78,7 @@ public void depthOrdering() throws Exception {
         assertEquals(COIN, selection.valueGathered);
 
         // Check we ordered them correctly (by depth).
-        ArrayList<TransactionOutput> candidates = new ArrayList<TransactionOutput>();
+        ArrayList<TransactionOutput> candidates = new ArrayList<>();
         candidates.add(t2.getOutput(0));
         candidates.add(t1.getOutput(0));
         DefaultCoinSelector.sortOutputs(candidates);
@@ -98,7 +98,7 @@ public void coinAgeOrdering() throws Exception {
         Transaction t3 = checkNotNull(sendMoneyToWallet(AbstractBlockChain.NewBlockType.BEST_CHAIN, CENT));
 
         // Should be ordered t2, t1, t3.
-        ArrayList<TransactionOutput> candidates = new ArrayList<TransactionOutput>();
+        ArrayList<TransactionOutput> candidates = new ArrayList<>();
         candidates.add(t3.getOutput(0));
         candidates.add(t2.getOutput(0));
         candidates.add(t1.getOutput(0));

File: core/src/test/java/org/bitcoinj/wallet/KeyChainGroupTest.java
Patch:
@@ -389,7 +389,7 @@ public void earliestKeyTime() throws Exception {
     public void events() throws Exception {
         // Check that events are registered with the right chains and that if a chain is added, it gets the event
         // listeners attached properly even post-hoc.
-        final AtomicReference<ECKey> ran = new AtomicReference<ECKey>(null);
+        final AtomicReference<ECKey> ran = new AtomicReference<>(null);
         final KeyChainEventListener listener = new KeyChainEventListener() {
             @Override
             public void onKeysAdded(List<ECKey> keys) {

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -362,7 +362,7 @@ public boolean allowEmptyPeerChain() {
         return true;
     }
 
-    /** How many blocks pass between difficulty adjustment periods. Bitcoin standardises this to be 2015. */
+    /** How many blocks pass between difficulty adjustment periods. Bitcoin standardises this to be 2016. */
     public int getInterval() {
         return interval;
     }

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -2206,7 +2206,7 @@ public void onFailure(Throwable throwable) {
     /**
      * Returns the period between pings for an individual peer. Setting this lower means more accurate and timely ping
      * times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
-     * remote node. It defaults to 5000.
+     * remote node. It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
      */
     public long getPingIntervalMsec() {
         lock.lock();

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -255,7 +255,7 @@ protected List<String> getCompatibilitySQL() {
      * Get the SQL to select the transaction outputs for a given address.
      * @return The SQL prepared statement.
      */
-    protected String getTrasactionOutputSelectSQL() {
+    protected String getTransactionOutputSelectSQL() {
         return SELECT_TRANSACTION_OUTPUTS_SQL;
     }
 
@@ -606,7 +606,7 @@ private void initFromDatabase() throws SQLException, BlockStoreException {
         this.verifiedChainHeadBlock = get(hash);
         this.verifiedChainHeadHash = hash;
         if (this.verifiedChainHeadBlock == null) {
-            throw new BlockStoreException("corrupt databse block store - verified head block not found");
+            throw new BlockStoreException("corrupt database block store - verified head block not found");
         }
     }
 
@@ -1161,7 +1161,7 @@ public List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXO
         List<UTXO> outputs = new ArrayList<UTXO>();
         try {
             maybeConnect();
-            s = conn.get().prepareStatement(getTrasactionOutputSelectSQL());
+            s = conn.get().prepareStatement(getTransactionOutputSelectSQL());
             for (Address address : addresses) {
                 s.setString(1, address.toString());
                 ResultSet rs = s.executeQuery();

File: core/src/main/java/org/bitcoinj/store/MySQLFullPrunedBlockStore.java
Patch:
@@ -119,7 +119,7 @@ protected String getDeleteOpenoutputsSQL() {
     }
 
     @Override
-    protected String getTrasactionOutputSelectSQL() {
+    protected String getTransactionOutputSelectSQL() {
         return SELECT_TRANSACTION_OUTPUTS_SQL;
     }
 

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -5069,7 +5069,8 @@ public void setTransactionBroadcaster(@Nullable org.bitcoinj.core.TransactionBro
         // is no inversion.
         for (Transaction tx : toBroadcast) {
             ConfidenceType confidenceType = tx.getConfidence().getConfidenceType();
-            checkState(confidenceType == ConfidenceType.PENDING, "Expected PENDING, was %s.", confidenceType);
+            checkState(confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT,
+                    "Expected PENDING or IN_CONFLICT, was %s.", confidenceType);
             // Re-broadcast even if it's marked as already seen for two reasons
             // 1) Old wallets may have transactions marked as broadcast by 1 peer when in reality the network
             //    never saw it, due to bugs.

File: core/src/main/java/org/bitcoinj/wallet/Wallet.java
Patch:
@@ -5068,7 +5068,8 @@ public void setTransactionBroadcaster(@Nullable org.bitcoinj.core.TransactionBro
         // Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
         // is no inversion.
         for (Transaction tx : toBroadcast) {
-            checkState(tx.getConfidence().getConfidenceType() == ConfidenceType.PENDING);
+            ConfidenceType confidenceType = tx.getConfidence().getConfidenceType();
+            checkState(confidenceType == ConfidenceType.PENDING, "Expected PENDING, was %s.", confidenceType);
             // Re-broadcast even if it's marked as already seen for two reasons
             // 1) Old wallets may have transactions marked as broadcast by 1 peer when in reality the network
             //    never saw it, due to bugs.

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -419,8 +419,8 @@ public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         TransactionOutput other = (TransactionOutput) o;
-        return value == other.value && (parent == null || parent == other.parent)
-            && Arrays.equals(scriptBytes, other.scriptBytes);
+        return value == other.value && (parent == null || (parent == other.parent && getIndex() == other.getIndex()))
+                && Arrays.equals(scriptBytes, other.scriptBytes);
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/store/H2FullPrunedBlockStore.java
Patch:
@@ -101,7 +101,7 @@ public H2FullPrunedBlockStore(NetworkParameters params, String dbName, String us
      */
     public H2FullPrunedBlockStore(NetworkParameters params, String dbName, int fullStoreDepth)
             throws BlockStoreException {
-        this(params, DATABASE_CONNECTION_URL_PREFIX + dbName + ";create=true;LOCK_TIMEOUT=60000;DB_CLOSE_ON_EXIT=FALSE", null, null, fullStoreDepth);
+        this(params, dbName, null, null, fullStoreDepth);
     }
 
     /**

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -101,7 +101,7 @@ public int compare(final Transaction tx1, final Transaction tx2) {
      * If using this feePerKb, transactions will get confirmed within the next couple of blocks.
      * This should be adjusted from time to time. Last adjustment: March 2016.
      */
-    public static final Coin DEFAULT_TX_FEE = Coin.valueOf(10000); // 0.1 mBTC
+    public static final Coin DEFAULT_TX_FEE = Coin.valueOf(50000); // 0.5 mBTC
 
     /**
      * Any standard (ie pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -32,7 +32,7 @@ public class Context {
     private NetworkParameters params;
     private int eventHorizon = 100;
     private boolean ensureMinRequiredFee = true;
-    private Coin feePerKb = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;
+    private Coin feePerKb = Transaction.DEFAULT_TX_FEE;
 
     /**
      * Creates a new context object. For now, this will be done for you by the framework. Eventually you will be

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -5459,7 +5459,7 @@ private Transaction rekeyOneBatch(long timeSecs, @Nullable KeyParameter aesKey,
             }
             // When not signing, don't waste addresses.
             rekeyTx.addOutput(toMove.valueGathered, sign ? freshReceiveAddress() : currentReceiveAddress());
-            if (!adjustOutputDownwardsForFee(rekeyTx, toMove, Transaction.REFERENCE_DEFAULT_MIN_TX_FEE, true)) {
+            if (!adjustOutputDownwardsForFee(rekeyTx, toMove, Transaction.DEFAULT_TX_FEE, true)) {
                 log.error("Failed to adjust rekey tx for fees.");
                 return null;
             }

File: core/src/main/java/org/bitcoinj/core/BitcoinSerializer.java
Patch:
@@ -367,7 +367,7 @@ public BitcoinPacketHeader(ByteBuffer in) throws ProtocolException, BufferUnderf
             size = (int) readUint32(header, cursor);
             cursor += 4;
 
-            if (size > Message.MAX_SIZE)
+            if (size > Message.MAX_SIZE || size < 0)
                 throw new ProtocolException("Message size too large: " + size);
 
             // Old clients don't send the checksum.

File: core/src/main/java/org/bitcoinj/store/WalletProtobufSerializer.java
Patch:
@@ -623,9 +623,8 @@ private void readTransaction(Protos.Transaction txProto, NetworkParameters param
             );
             Coin value = inputProto.hasValue() ? Coin.valueOf(inputProto.getValue()) : null;
             TransactionInput input = new TransactionInput(params, tx, scriptBytes, outpoint, value);
-            if (inputProto.hasSequence()) {
-                input.setSequenceNumber(inputProto.getSequence());
-            }
+            if (inputProto.hasSequence())
+                input.setSequenceNumber(0xffffffffL & inputProto.getSequence());
             tx.addInput(input);
         }
 

File: core/src/test/java/org/bitcoinj/core/ChainSplitTest.java
Patch:
@@ -59,10 +59,9 @@ public class ChainSplitTest {
     public void setUp() throws Exception {
         BriefLogFormatter.init();
         Utils.setMockClock(); // Use mock clock
-        Wallet.SendRequest.DEFAULT_FEE_PER_KB = Coin.ZERO;
-        Context context = new Context(PARAMS);
+        Context.propagate(new Context(PARAMS, 100, Coin.ZERO, false));
         MemoryBlockStore blockStore = new MemoryBlockStore(PARAMS);
-        wallet = new Wallet(context);
+        wallet = new Wallet(PARAMS);
         ECKey key1 = wallet.freshReceiveKey();
         ECKey key2 = wallet.freshReceiveKey();
         chain = new BlockChain(PARAMS, wallet, blockStore);

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -244,7 +244,6 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         // Do the same thing with an offline transaction.
         peerGroup.removeWallet(wallet);
         Wallet.SendRequest req = Wallet.SendRequest.to(dest, valueOf(2, 0));
-        req.ensureMinRequiredFee = false;
         Transaction t3 = checkNotNull(wallet.sendCoinsOffline(req));
         assertNull(outbound(p1));  // Nothing sent.
         // Add the wallet to the peer group (simulate initialization). Transactions should be announced.

File: core/src/test/java/org/bitcoinj/protocols/channels/PaymentChannelStateTest.java
Patch:
@@ -88,6 +88,7 @@ public TxFuturePair(Transaction tx, SettableFuture<Transaction> future) {
     public void setUp() throws Exception {
         Utils.setMockClock(); // Use mock clock
         super.setUp();
+        Context.propagate(new Context(PARAMS, 100, Coin.ZERO, true));
         wallet.addExtension(new StoredPaymentChannelClientStates(wallet, new TransactionBroadcaster() {
             @Override
             public TransactionBroadcast broadcastTransaction(Transaction tx) {
@@ -710,7 +711,7 @@ public void feesTest() throws Exception {
         } catch (ValueOutOfRangeException e) {}
 
         clientState = makeClientState(wallet, myKey, ECKey.fromPublicOnly(serverKey.getPubKey()),
-                                                    Transaction.MIN_NONDUST_OUTPUT.subtract(Coin.SATOSHI).add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE),
+                Transaction.MIN_NONDUST_OUTPUT.subtract(Coin.SATOSHI).add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE),
                 EXPIRE_TIME);
         assertEquals(PaymentChannelClientState.State.NEW, clientState.getState());
         try {

File: core/src/test/java/org/bitcoinj/testing/TestWithWallet.java
Patch:
@@ -47,8 +47,7 @@ public class TestWithWallet {
 
     public void setUp() throws Exception {
         BriefLogFormatter.init();
-        Wallet.SendRequest.DEFAULT_FEE_PER_KB = Coin.ZERO;
-        Context ctx = new Context(PARAMS);
+        Context.propagate(new Context(PARAMS, 100, Coin.ZERO, false));
         wallet = new Wallet(PARAMS);
         myKey = wallet.currentReceiveKey();
         myAddress = myKey.toAddress(PARAMS);
@@ -57,7 +56,6 @@ public void setUp() throws Exception {
     }
 
     public void tearDown() throws Exception {
-        Wallet.SendRequest.DEFAULT_FEE_PER_KB = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;
     }
 
     @Nullable

File: examples/src/main/java/org/bitcoinj/examples/ExamplePaymentChannelClient.java
Patch:
@@ -198,7 +198,7 @@ public void onFailure(Throwable throwable) {
 
     private void waitForSufficientBalance(Coin amount) {
         // Not enough money in the wallet.
-        Coin amountPlusFee = amount.add(Wallet.SendRequest.DEFAULT_FEE_PER_KB);
+        Coin amountPlusFee = amount.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
         // ESTIMATED because we don't really need to wait for confirmation.
         ListenableFuture<Coin> balanceFuture = appKit.wallet().getBalanceFuture(amountPlusFee, Wallet.BalanceType.ESTIMATED);
         if (!balanceFuture.isDone()) {

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -1048,7 +1048,7 @@ public void setLockTime(long lockTime) {
                 break;
             }
         }
-        if (!seqNumSet || inputs.isEmpty()) {
+        if (lockTime != 0 && (!seqNumSet || inputs.isEmpty())) {
             // At least one input must have a non-default sequence number for lock times to have any effect.
             // For instance one of them can be set to zero to make this feature work.
             log.warn("You are setting the lock time on a transaction but none of the inputs have non-default sequence numbers. This will not do what you expect!");

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -5084,7 +5084,7 @@ public FeeCalculation calculateFee(SendRequest req, Coin value, List<Transaction
                     changeAddress = currentChangeAddress();
                 changeOutput = new TransactionOutput(params, req.tx, change, changeAddress);
                 // If the change output would result in this transaction being rejected as dust, just drop the change and make it a fee
-                if (req.ensureMinRequiredFee && Transaction.MIN_NONDUST_OUTPUT.compareTo(change) >= 0) {
+                if (req.ensureMinRequiredFee && change.isLessThan(Transaction.MIN_NONDUST_OUTPUT)) {
                     // This solution definitely fits in category 3
                     isCategory3 = true;
                     additionalValueForNextCategory = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(

File: core/src/main/java/org/bitcoinj/wallet/BasicKeyChain.java
Patch:
@@ -384,7 +384,7 @@ private void deserializeFromProtobuf(List<Protos.Key> keys) throws UnreadableWal
                     else
                         ecKey = ECKey.fromPublicOnly(pub);
                 }
-                ecKey.setCreationTimeSeconds((key.getCreationTimestamp() + 500) / 1000);
+                ecKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);
                 importKeyLocked(ecKey);
             }
         } finally {

File: core/src/test/java/org/bitcoinj/wallet/DeterministicKeyChainTest.java
Patch:
@@ -323,7 +323,7 @@ public void watchingChain() throws UnreadableWalletException {
         watchingKey = DeterministicKey.deserializeB58(null, pub58, params);
         watchingKey.setCreationTimeSeconds(100000);
         chain = DeterministicKeyChain.watch(watchingKey);
-        assertEquals(DeterministicHierarchy.BIP32_STANDARDISATION_TIME_SECS, chain.getEarliestKeyCreationTime());
+        assertEquals(100000, chain.getEarliestKeyCreationTime());
         chain.setLookaheadSize(10);
         chain.maybeLookAhead();
 

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -3024,7 +3024,8 @@ public void cleanup() {
                         for (TransactionInput input : tx.getInputs()) {
                             TransactionOutput output = input.getConnectedOutput();
                             if (output == null) continue;
-                            myUnspents.add(output);
+                            if (output.isMineOrWatched(this))
+                                checkState(myUnspents.add(output));
                             input.disconnect();
                         }
                         for (TransactionOutput output : tx.getOutputs())

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -157,7 +157,7 @@ public WalletAppKit setCheckpoints(InputStream checkpoints) {
 
     /**
      * If true (the default) then the startup of this service won't be considered complete until the network has been
-     * brought up, peer connections established and the block chain synchronised. Therefore {@link #startAndWait()} can
+     * brought up, peer connections established and the block chain synchronised. Therefore {@link #awaitRunning()} can
      * potentially take a very long time. If false, then startup is considered complete once the network activity
      * begins and peer connections/block chain sync will continue in the background.
      */

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -623,7 +623,7 @@ public String toString(@Nullable AbstractBlockChain chain) {
             s.append(String.format(Locale.US, "  time locked until %s%n", time));
         }
         if (isOptInFullRBF()) {
-            s.append("  opts into full replace-by-fee%n");
+            s.append("  opts into full replace-by-fee\n");
         }
         if (inputs.size() == 0) {
             s.append(String.format(Locale.US, "  INCOMPLETE: No inputs!%n"));

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -1607,7 +1607,7 @@ private boolean isNotFoundMessageSupported() {
      * Returns true if this peer will try and download things it is sent in "inv" messages. Normally you only need
      * one peer to be downloading data. Defaults to true.
      */
-    public boolean getDownloadData() {
+    public boolean isDownloadData() {
         return vDownloadData;
     }
 
@@ -1791,7 +1791,7 @@ public ListenableFuture<UTXOsMessage> getUTXOs(List<TransactionOutPoint> outPoin
      * before handing the transaction off to the wallet. The wallet can do risk analysis on pending/recent transactions
      * to try and discover if a pending tx might be at risk of double spending.
      */
-    public boolean getDownloadTxDependencies() {
+    public boolean isDownloadTxDependencies() {
         return vDownloadTxDependencies;
     }
 

File: tools/src/main/java/org/bitcoinj/tools/WalletTool.java
Patch:
@@ -1247,7 +1247,8 @@ private static void syncChain() {
     private static void shutdown() {
         try {
             if (peers == null) return;  // setup() never called so nothing to do.
-            peers.stop();
+            if (peers.isRunning())
+                peers.stop();
             saveWallet(walletFile);
             store.close();
             wallet = null;

File: core/src/main/java/org/bitcoinj/core/listeners/PeerConnectionEventListener.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
- * they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
+ * they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
  * provide transactions to remote peers when they ask for them.</p>
  */
 public interface PeerConnectionEventListener {

File: core/src/main/java/org/bitcoinj/core/listeners/PeerDataEventListener.java
Patch:
@@ -23,7 +23,7 @@
 
 /**
  * <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
- * they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
+ * they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
  * provide transactions to remote peers when they ask for them.</p>
  */
 public interface PeerDataEventListener {

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -122,6 +122,7 @@ public enum State {
             this.serverKey = checkNotNull(storedServerChannel.myKey);
             this.storedServerChannel = storedServerChannel;
             this.bestValueToMe = checkNotNull(storedServerChannel.bestValueToMe);
+            this.minExpireTime = storedServerChannel.refundTransactionUnlockTimeSecs;
             this.bestValueSignature = storedServerChannel.bestValueSignature;
             checkArgument(bestValueToMe.equals(Coin.ZERO) || bestValueSignature != null);
             storedServerChannel.state = this;

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -235,6 +235,7 @@ public synchronized ListenableFuture<PaymentChannelServerState> provideMultiSigC
             throw e;
         }
         log.info("Broadcasting multisig contract: {}", multisigContract);
+        wallet.addWatchedScripts(ImmutableList.of(multisigContract.getOutput(0).getScriptPubKey()));
         state = State.WAITING_FOR_MULTISIG_ACCEPTANCE;
         final SettableFuture<PaymentChannelServerState> future = SettableFuture.create();
         Futures.addCallback(broadcaster.broadcastTransaction(multisigContract).future(), new FutureCallback<Transaction>() {

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -549,8 +549,8 @@ protected void processAlert(AlertMessage m) {
             }
         } catch (Throwable t) {
             // Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
-            // BigInteger implementations! See issue 160 for discussion. As alerts are just optional and not that
-            // useful, we just swallow the error here.
+            // BigInteger implementations! See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion. As
+            // alerts are just optional and not that useful, we just swallow the error here.
             log.error("Failed to check signature: bug in platform libraries?", t);
         }
     }

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -102,7 +102,7 @@ public TransactionOutput(NetworkParameters params, @Nullable Transaction parent,
         // Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
         // SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
         checkArgument(value.signum() >= 0 || value.equals(Coin.NEGATIVE_SATOSHI), "Negative values not allowed");
-        checkArgument(value.compareTo(NetworkParameters.MAX_MONEY) < 0, "Values larger than MAX_MONEY not allowed");
+        checkArgument(value.compareTo(NetworkParameters.MAX_MONEY) <= 0, "Values larger than MAX_MONEY not allowed");
         this.value = value.value;
         this.scriptBytes = scriptBytes;
         setParent(parent);

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelClientStates.java
Patch:
@@ -272,8 +272,8 @@ public byte[] serializeWalletExtension() {
             ClientState.StoredClientPaymentChannels.Builder builder = ClientState.StoredClientPaymentChannels.newBuilder();
             for (StoredClientChannel channel : mapChannels.values()) {
                 // First a few asserts to make sure things won't break
-                checkState(channel.valueToMe.signum() >= 0 && channel.valueToMe.compareTo(NetworkParameters.MAX_MONEY) < 0);
-                checkState(channel.refundFees.signum() >= 0 && channel.refundFees.compareTo(NetworkParameters.MAX_MONEY) < 0);
+                checkState(channel.valueToMe.signum() >= 0 && channel.valueToMe.compareTo(NetworkParameters.MAX_MONEY) <= 0);
+                checkState(channel.refundFees.signum() >= 0 && channel.refundFees.compareTo(NetworkParameters.MAX_MONEY) <= 0);
                 checkNotNull(channel.myKey.getPubKey());
                 checkState(channel.refund.getConfidence().getSource() == TransactionConfidence.Source.SELF);
                 final ClientState.StoredClientPaymentChannel.Builder value = ClientState.StoredClientPaymentChannel.newBuilder()

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelServerStates.java
Patch:
@@ -217,7 +217,7 @@ public byte[] serializeWalletExtension() {
             for (StoredServerChannel channel : mapChannels.values()) {
                 // First a few asserts to make sure things won't break
                 // TODO: Pull MAX_MONEY from network parameters
-                checkState(channel.bestValueToMe.signum() >= 0 && channel.bestValueToMe.compareTo(NetworkParameters.MAX_MONEY) < 0);
+                checkState(channel.bestValueToMe.signum() >= 0 && channel.bestValueToMe.compareTo(NetworkParameters.MAX_MONEY) <= 0);
                 checkState(channel.refundTransactionUnlockTimeSecs > 0);
                 checkNotNull(channel.myKey.getPrivKeyBytes());
                 ServerState.StoredServerPaymentChannel.Builder channelBuilder = ServerState.StoredServerPaymentChannel.newBuilder()

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -560,7 +560,7 @@ private void checkTimestamp() throws VerificationException {
         // Allow injection of a fake clock to allow unit testing.
         long currentTime = Utils.currentTimeSeconds();
         if (time > currentTime + ALLOWED_TIME_DRIFT)
-            throw new VerificationException(String.format("Block too far in future: %d vs %d", time, currentTime + ALLOWED_TIME_DRIFT));
+            throw new VerificationException(String.format(Locale.US, "Block too far in future: %d vs %d", time, currentTime + ALLOWED_TIME_DRIFT));
     }
 
     private void checkSigOps() throws VerificationException {

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -489,7 +489,7 @@ private void processVersionMessage(VersionMessage m) throws ProtocolException {
                 peerVersion,
                 vPeerVersionMessage.subVer,
                 vPeerVersionMessage.localServices,
-                String.format("%tF %tT", peerTime, peerTime),
+                String.format(Locale.US, "%tF %tT", peerTime, peerTime),
                 vPeerVersionMessage.bestHeight);
         // Now it's our turn ...
         // Send an ACK message stating we accept the peers protocol version.

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -1719,7 +1719,7 @@ private void calculate() {
                         for (long sample : samples) average += sample;
                         average /= samples.length;
 
-                        log.info(String.format("%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)",
+                        log.info(String.format(Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)",
                                 blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0,
                                 minSpeedBytesPerSec / 1024.0, samples.length));
 
@@ -1736,7 +1736,7 @@ private void calculate() {
                                 log.warn("This network seems to be slower than the requested stall threshold - won't do stall disconnects any more.");
                             } else {
                                 Peer peer = getDownloadPeer();
-                                log.warn(String.format("Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s", average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer));
+                                log.warn(String.format(Locale.US, "Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s", average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer));
                                 peer.close();
                                 // Reset the sample buffer and give the next peer time to get going.
                                 samples = null;
@@ -1746,7 +1746,7 @@ private void calculate() {
                     } else {
                         warmupSeconds--;
                         if (bytesInLastSecond > 0)
-                            log.info(String.format("%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec",
+                            log.info(String.format(Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec",
                                     blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0));
                     }
                 }

File: core/src/main/java/org/bitcoinj/core/RejectMessage.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.common.base.Objects;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.Locale;
 
 /**
  * A message sent by nodes when a message we sent was rejected (ie a transaction had too little fee/was invalid/etc)
@@ -145,7 +146,7 @@ public String getReasonString() {
     @Override
     public String toString() {
         Sha256Hash hash = getRejectedObjectHash();
-        return String.format("Reject: %s %s for reason '%s' (%d)", getRejectedMessage(),
+        return String.format(Locale.US, "Reject: %s %s for reason '%s' (%d)", getRejectedMessage(),
             hash != null ? hash : "", getReasonString(), getReasonCode().code);
     }
 

File: core/src/main/java/org/bitcoinj/core/StoredBlock.java
Patch:
@@ -22,6 +22,7 @@
 
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
+import java.util.Locale;
 
 import static com.google.common.base.Preconditions.checkState;
 
@@ -143,7 +144,7 @@ public static StoredBlock deserializeCompact(NetworkParameters params, ByteBuffe
 
     @Override
     public String toString() {
-        return String.format("Block %s at height %d: %s",
+        return String.format(Locale.US, "Block %s at height %d: %s",
                 getHeader().getHashAsString(), getHeight(), getHeader().toString());
     }
 }

File: core/src/main/java/org/bitcoinj/core/TransactionConfidence.java
Patch:
@@ -336,7 +336,7 @@ public synchronized String toString() {
                 builder.append("In conflict.");
                 break;
             case BUILDING:
-                builder.append(String.format("Appeared in best chain at height %d, depth %d.",
+                builder.append(String.format(Locale.US, "Appeared in best chain at height %d, depth %d.",
                         getAppearedAtChainHeight(), getDepthInBlocks()));
                 break;
         }

File: core/src/main/java/org/bitcoinj/core/UTXO.java
Patch:
@@ -21,6 +21,7 @@
 
 import java.io.*;
 import java.math.*;
+import java.util.Locale;
 
 // TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc
 
@@ -156,7 +157,7 @@ public String getAddress() {
 
     @Override
     public String toString() {
-        return String.format("Stored TxOut of %s (%s:%d)", value.toFriendlyString(), hash, index);
+        return String.format(Locale.US, "Stored TxOut of %s (%s:%d)", value.toFriendlyString(), hash, index);
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/core/VersionMessage.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.OutputStream;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.Locale;
 
 /**
  * A VersionMessage holds information exchanged during connection setup with another peer. Most of the fields are not
@@ -259,9 +260,9 @@ public void appendToSubVer(String name, String version, @Nullable String comment
         checkSubVerComponent(version);
         if (comments != null) {
             checkSubVerComponent(comments);
-            subVer = subVer.concat(String.format("%s:%s(%s)/", name, version, comments));
+            subVer = subVer.concat(String.format(Locale.US, "%s:%s(%s)/", name, version, comments));
         } else {
-            subVer = subVer.concat(String.format("%s:%s/", name, version));
+            subVer = subVer.concat(String.format(Locale.US, "%s:%s/", name, version));
         }
     }
 

File: core/src/main/java/org/bitcoinj/core/listeners/DownloadProgressTracker.java
Patch:
@@ -28,6 +28,7 @@
 
 import javax.annotation.*;
 import java.util.Date;
+import java.util.Locale;
 import java.util.concurrent.ExecutionException;
 
 /**
@@ -86,7 +87,7 @@ public void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock f
      * @param date the date of the last block downloaded
      */
     protected void progress(double pct, int blocksSoFar, Date date) {
-        log.info(String.format("Chain download %d%% done with %d blocks to go, block date %s", (int) pct, blocksSoFar,
+        log.info(String.format(Locale.US, "Chain download %d%% done with %d blocks to go, block date %s", (int) pct, blocksSoFar,
                 Utils.dateTimeFormat(date)));
     }
 

File: core/src/main/java/org/bitcoinj/crypto/ChildNumber.java
Patch:
@@ -16,6 +16,8 @@
 
 package org.bitcoinj.crypto;
 
+import java.util.Locale;
+
 import com.google.common.primitives.Ints;
 
 /**
@@ -73,7 +75,7 @@ public int num() {
 
     @Override
     public String toString() {
-        return String.format("%d%s", num(), isHardened() ? "H" : "");
+        return String.format(Locale.US, "%d%s", num(), isHardened() ? "H" : "");
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/crypto/DeterministicHierarchy.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.common.collect.Maps;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 import static com.google.common.base.Preconditions.checkArgument;
@@ -85,7 +86,7 @@ public DeterministicKey get(List<ChildNumber> path, boolean relativePath, boolea
                 : ImmutableList.copyOf(path);
         if (!keys.containsKey(absolutePath)) {
             if (!create)
-                throw new IllegalArgumentException(String.format("No key found for %s path %s.",
+                throw new IllegalArgumentException(String.format(Locale.US, "No key found for %s path %s.",
                     relativePath ? "relative" : "absolute", HDUtils.formatPath(path)));
             checkArgument(absolutePath.size() > 0, "Can't derive the master key: nothing to derive from.");
             DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), false, true);

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -31,6 +31,7 @@
 
 import javax.annotation.Nullable;
 import java.util.Arrays;
+import java.util.Locale;
 
 import static com.google.common.base.Preconditions.*;
 
@@ -399,7 +400,7 @@ public synchronized ListenableFuture<Transaction> close() throws InsufficientMon
             feePaidForPayment = req.tx.getFee();
             log.info("Calculated fee is {}", feePaidForPayment);
             if (feePaidForPayment.compareTo(bestValueToMe) > 0) {
-                final String msg = String.format("Had to pay more in fees (%s) than the channel was worth (%s)",
+                final String msg = String.format(Locale.US, "Had to pay more in fees (%s) than the channel was worth (%s)",
                         feePaidForPayment, bestValueToMe);
                 throw new InsufficientMoneyException(feePaidForPayment.subtract(bestValueToMe), msg);
             }

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelClientStates.java
Patch:
@@ -28,6 +28,7 @@
 
 import javax.annotation.Nullable;
 import java.util.Date;
+import java.util.Locale;
 import java.util.Set;
 import java.util.Timer;
 import java.util.TimerTask;
@@ -371,9 +372,9 @@ long expiryTimeSeconds() {
 
     @Override
     public String toString() {
-        final String newline = String.format("%n");
+        final String newline = String.format(Locale.US, "%n");
         final String closeStr = close == null ? "still open" : close.toString().replaceAll(newline, newline + "   ");
-        return String.format("Stored client channel for server ID %s (%s)%n" +
+        return String.format(Locale.US, "Stored client channel for server ID %s (%s)%n" +
                 "    Key:         %s%n" +
                 "    Value left:  %s%n" +
                 "    Refund fees: %s%n" +

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredServerChannel.java
Patch:
@@ -20,6 +20,7 @@
 
 import javax.annotation.Nullable;
 import java.util.Date;
+import java.util.Locale;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -103,8 +104,8 @@ public synchronized PaymentChannelServerState getOrCreateState(Wallet wallet, Tr
 
     @Override
     public synchronized String toString() {
-        final String newline = String.format("%n");
-        return String.format("Stored server channel (%s)%n" +
+        final String newline = String.format(Locale.US, "%n");
+        return String.format(Locale.US, "Stored server channel (%s)%n" +
                 "    Key:           %s%n" +
                 "    Value to me:   %s%n" +
                 "    Client output: %s%n" +

File: core/src/main/java/org/bitcoinj/store/WalletProtobufSerializer.java
Patch:
@@ -666,7 +666,7 @@ private void readTransaction(Protos.Transaction txProto, NetworkParameters param
         // Transaction should now be complete.
         Sha256Hash protoHash = byteStringToHash(txProto.getHash());
         if (!tx.getHash().equals(protoHash))
-            throw new UnreadableWalletException(String.format("Transaction did not deserialize completely: %s vs %s", tx.getHash(), protoHash));
+            throw new UnreadableWalletException(String.format(Locale.US, "Transaction did not deserialize completely: %s vs %s", tx.getHash(), protoHash));
         if (txMap.containsKey(txProto.getHash()))
             throw new UnreadableWalletException("Wallet contained duplicate transaction " + byteStringToHash(txProto.getHash()));
         txMap.put(txProto.getHash(), tx);
@@ -699,7 +699,7 @@ private WalletTransaction connectTransactionOutputs(final NetworkParameters para
                 final ByteString spentByTransactionHash = transactionOutput.getSpentByTransactionHash();
                 Transaction spendingTx = txMap.get(spentByTransactionHash);
                 if (spendingTx == null) {
-                    throw new UnreadableWalletException(String.format("Could not connect %s to %s",
+                    throw new UnreadableWalletException(String.format(Locale.US, "Could not connect %s to %s",
                             tx.getHashAsString(), byteStringToHash(spentByTransactionHash)));
                 }
                 final int spendingIndex = transactionOutput.getSpentByTransactionIndex();

File: core/src/main/java/org/bitcoinj/uri/BitcoinURI.java
Patch:
@@ -225,9 +225,9 @@ private void parseParameters(@Nullable NetworkParameters params, String addressT
                         throw new ArithmeticException("Negative coins specified");
                     putWithValidation(FIELD_AMOUNT, amount);
                 } catch (IllegalArgumentException e) {
-                    throw new OptionalFieldValidationException(String.format("'%s' is not a valid amount", valueToken), e);
+                    throw new OptionalFieldValidationException(String.format(Locale.US, "'%s' is not a valid amount", valueToken), e);
                 } catch (ArithmeticException e) {
-                    throw new OptionalFieldValidationException(String.format("'%s' has too many decimal places", valueToken), e);
+                    throw new OptionalFieldValidationException(String.format(Locale.US, "'%s' has too many decimal places", valueToken), e);
                 }
             } else {
                 if (nameToken.startsWith("req-")) {
@@ -257,7 +257,7 @@ private void parseParameters(@Nullable NetworkParameters params, String addressT
      */
     private void putWithValidation(String key, Object value) throws BitcoinURIParseException {
         if (parameterMap.containsKey(key)) {
-            throw new BitcoinURIParseException(String.format("'%s' is duplicated, URI is invalid", key));
+            throw new BitcoinURIParseException(String.format(Locale.US, "'%s' is duplicated, URI is invalid", key));
         } else {
             parameterMap.put(key, value);
         }

File: core/src/main/java/org/bitcoinj/utils/BlockFileLoader.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.NoSuchElementException;
 
 /**
@@ -62,7 +63,7 @@ public static List<File> getReferenceClientBlockFileList() {
         
         List<File> list = new LinkedList<File>();
         for (int i = 0; true; i++) {
-            File file = new File(defaultDataDir + String.format("blk%05d.dat", i));
+            File file = new File(defaultDataDir + String.format(Locale.US, "blk%05d.dat", i));
             if (!file.exists())
                 break;
             list.add(file);

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -808,7 +808,7 @@ public String toString(boolean includePrivateKeys) {
         for (DeterministicKeyChain chain : chains) {
             chainStrs.add(chain.toString(includePrivateKeys, params));
         }
-        builder.append(Joiner.on(String.format("%n")).join(chainStrs));
+        builder.append(Joiner.on(String.format(Locale.US, "%n")).join(chainStrs));
         return builder.toString();
     }
 

File: core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java
Patch:
@@ -32,6 +32,7 @@
 import java.security.SecureRandom;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 import javax.annotation.Nullable;
@@ -238,9 +239,9 @@ public List<Protos.Key> serializeToProtobuf() {
     @Override
     protected void formatAddresses(boolean includePrivateKeys, NetworkParameters params, StringBuilder builder2) {
         for (DeterministicKeyChain followingChain : followingKeyChains) {
-            builder2.append(String.format("Following chain:  %s%n", followingChain.getWatchingKey().serializePubB58(params)));
+            builder2.append(String.format(Locale.US, "Following chain:  %s%n", followingChain.getWatchingKey().serializePubB58(params)));
         }
-        builder2.append(String.format("%n"));
+        builder2.append(String.format(Locale.US, "%n"));
         for (RedeemData redeemData : marriedKeysRedeemData.values())
             formatScript(ScriptBuilder.createP2SHOutputScript(redeemData.redeemScript), builder2, params);
     }

File: core/src/test/java/org/bitcoinj/crypto/BIP32Test.java
Patch:
@@ -29,6 +29,7 @@
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
 
 import static org.bitcoinj.core.Utils.HEX;
 import static org.junit.Assert.assertEquals;
@@ -137,7 +138,7 @@ private void testVector(int testCase) {
         for (int i = 0; i < tv.derived.size(); i++) {
             HDWTestVector.DerivedTestCase tc = tv.derived.get(i);
             log.info("{}", tc.name);
-            assertEquals(tc.name, String.format("Test%d %s", testCase + 1, tc.getPathDescription()));
+            assertEquals(tc.name, String.format(Locale.US, "Test%d %s", testCase + 1, tc.getPathDescription()));
             int depth = tc.path.length - 1;
             DeterministicKey ehkey = dh.deriveChild(Arrays.asList(tc.path).subList(0, depth), false, true, tc.path[depth]);
             assertEquals(testEncode(tc.priv), testEncode(ehkey.serializePrivB58(params)));

File: core/src/main/java/org/bitcoinj/core/AbstractBlockChain.java
Patch:
@@ -920,7 +920,7 @@ private void tryConnectingOrphans() throws VerificationException, BlockStoreExce
                 StoredBlock prev = getStoredBlockInCurrentScope(orphanBlock.block.getPrevBlockHash());
                 if (prev == null) {
                     // This is still an unconnected/orphan block.
-                    log.debug("  but it is not connectable right now");
+                    log.debug("Orphan block {} is not connectable right now", orphanBlock.block.getHash());
                     continue;
                 }
                 // Otherwise we can connect it now.

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -478,7 +478,7 @@ protected final void copyBitcoinHeaderTo(final Block block) {
     public String toString() {
         StringBuilder s = new StringBuilder();
         s.append(" block: \n");
-        s.append("   hash: ").append(getHashAsString());
+        s.append("   hash: ").append(getHashAsString()).append('\n');
         s.append("   version: ").append(version);
         String bips = Joiner.on(", ").skipNulls().join(isBIP34() ? "BIP34" : null, isBIP66() ? "BIP66" : null,
                 isBIP65() ? "BIP65" : null, isBIP101() ? "BIP101" : null);

File: core/src/main/java/org/bitcoinj/store/WalletProtobufSerializer.java
Patch:
@@ -733,6 +733,7 @@ private void readConfidence(final NetworkParameters params, final Transaction tx
             // These two are equivalent (must be able to read old wallets).
             case NOT_IN_BEST_CHAIN: confidenceType = ConfidenceType.PENDING; break;
             case PENDING: confidenceType = ConfidenceType.PENDING; break;
+            case IN_CONFLICT: confidenceType = ConfidenceType.IN_CONFLICT; break;
             case UNKNOWN:
                 // Fall through.
             default:

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -47,10 +47,10 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
 
     /**
      * Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely be
-     * rejected by the network. Currently it's 546 satoshis. This is different from {@link Transaction#MIN_NONDUST_OUTPUT}
-     * because of an upcoming fee change in Bitcoin Core 0.9.
+     * rejected by the network. This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can be
+     * different when the fee is about to change in Bitcoin Core.
      */
-    public static final Coin MIN_ANALYSIS_NONDUST_OUTPUT = Coin.valueOf(546);
+    public static final Coin MIN_ANALYSIS_NONDUST_OUTPUT = Transaction.MIN_NONDUST_OUTPUT;
 
     protected final Transaction tx;
     protected final List<Transaction> dependencies;

File: core/src/main/java/org/bitcoinj/net/discovery/MultiplexingDiscovery.java
Patch:
@@ -112,7 +112,8 @@ public InetSocketAddress[] call() throws Exception {
                 Collections.addAll(addrs, inetAddresses);
             }
             if (addrs.size() == 0)
-                throw new PeerDiscoveryException("No peer discovery returned any results: check internet connection?");
+                throw new PeerDiscoveryException("No peer discovery returned any results in "
+                        + timeoutUnit.toMillis(timeoutValue) + "ms. Check internet connection?");
             Collections.shuffle(addrs);
             vThreadPool.shutdownNow();
             return addrs.toArray(new InetSocketAddress[addrs.size()]);

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -71,7 +71,7 @@ public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
         this.parent = parent;
         this.childNumberPath = checkNotNull(childNumberPath);
         this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
-        this.depth = this.childNumberPath.size();
+        this.depth = parent == null ? 0 : parent.depth + 1;
         this.parentFingerprint = (parent != null) ? parent.getFingerprint() : 0;
     }
 
@@ -93,7 +93,7 @@ public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
         this.parent = parent;
         this.childNumberPath = checkNotNull(childNumberPath);
         this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
-        this.depth = this.childNumberPath.size();
+        this.depth = parent == null ? 0 : parent.depth + 1;
         this.parentFingerprint = (parent != null) ? parent.getFingerprint() : 0;
     }
 

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -184,6 +184,8 @@ public static RuleViolation isInputStandard(TransactionInput input) {
                 if (signature != null) {
                     if (!TransactionSignature.isEncodingCanonical(chunk.data))
                         return RuleViolation.SIGNATURE_CANONICAL_ENCODING;
+                    if (!signature.isCanonical())
+                        return RuleViolation.SIGNATURE_CANONICAL_ENCODING;
                 }
             }
         }

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -2088,7 +2088,7 @@ private void updateForSpends(Transaction tx, boolean fromChain) throws Verificat
                     log.warn("  offending input is input {}", tx.getInputs().indexOf(input));
                     log.warn("{}: {}", tx.getHash(), Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
                     Transaction other = output.getSpentBy().getParentTransaction();
-                    log.warn("{}: {}", other.getHash(), Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
+                    log.warn("{}: {}", other.getHash(), Utils.HEX.encode(other.unsafeBitcoinSerialize()));
                 }
             } else if (result == TransactionInput.ConnectionResult.SUCCESS) {
                 // Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -831,14 +831,14 @@ private void addInactive(PeerAddress peerAddress) {
     /**
      * Convenience for connecting only to peers that can serve specific services. It will configure suitable peer
      * discoveries.
-     * @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
+     * @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
      */
     public void setRequiredServices(long requiredServices) {
         lock.lock();
         try {
             this.requiredServices = requiredServices;
             peerDiscoverers.clear();
-            peerDiscoverers.add(MultiplexingDiscovery.forServices(params, requiredServices));
+            addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices));
         } finally {
             lock.unlock();
         }

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -3971,7 +3971,8 @@ protected LinkedList<TransactionOutput> calculateAllSpendCandidatesFromUTXOProvi
     protected List<UTXO> getStoredOutputsFromUTXOProvider() throws UTXOProviderException {
         UTXOProvider utxoProvider = checkNotNull(vUTXOProvider, "No UTXO provider has been set");
         List<UTXO> candidates = new ArrayList<UTXO>();
-        List<DeterministicKey> keys = getActiveKeyChain().getLeafKeys();
+        List<ECKey> keys = getImportedKeys();
+        keys.addAll(getActiveKeyChain().getLeafKeys());
         List<Address> addresses = new ArrayList<Address>();
         for (ECKey key : keys) {
             Address address = new Address(params, key.getPubKeyHash());

File: core/src/main/java/org/bitcoinj/script/Script.java
Patch:
@@ -1022,7 +1022,7 @@ public static void executeScript(@Nullable Transaction txContainingThis, long in
                 case OP_EQUAL:
                     if (stack.size() < 2)
                         throw new ScriptException("Attempted OP_EQUALVERIFY on a stack with size < 2");
-                    stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {0});
+                    stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {});
                     break;
                 case OP_EQUALVERIFY:
                     if (stack.size() < 2)
@@ -1301,7 +1301,7 @@ private static void executeCheckSig(Transaction txContainingThis, int index, Scr
         }
 
         if (opcode == OP_CHECKSIG)
-            stack.add(sigValid ? new byte[] {1} : new byte[] {0});
+            stack.add(sigValid ? new byte[] {1} : new byte[] {});
         else if (opcode == OP_CHECKSIGVERIFY)
             if (!sigValid)
                 throw new ScriptException("Script failed OP_CHECKSIGVERIFY");
@@ -1378,7 +1378,7 @@ private static int executeMultiSig(Transaction txContainingThis, int index, Scri
             throw new ScriptException("OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " + Arrays.toString(nullDummy));
 
         if (opcode == OP_CHECKMULTISIG) {
-            stack.add(valid ? new byte[] {1} : new byte[] {0});
+            stack.add(valid ? new byte[] {1} : new byte[] {});
         } else if (opcode == OP_CHECKMULTISIGVERIFY) {
             if (!valid)
                 throw new ScriptException("Script failed OP_CHECKMULTISIGVERIFY");

File: core/src/main/java/org/bitcoinj/testing/TestWithWallet.java
Patch:
@@ -68,7 +68,7 @@ protected Transaction sendMoneyToWallet(Wallet wallet, Transaction tx, AbstractB
             if (wallet.isPendingTransactionRelevant(tx))
                 wallet.receivePending(tx, null);
         } else {
-            FakeTxBuilder.BlockPair bp = createFakeBlock(blockStore, tx);
+            FakeTxBuilder.BlockPair bp = createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS, tx);
             wallet.receiveFromBlock(tx, bp.storedBlock, type, 0);
             if (type == AbstractBlockChain.NewBlockType.BEST_CHAIN)
                 wallet.notifyNewBestBlock(bp.storedBlock);

File: core/src/main/java/org/bitcoinj/utils/VersionTally.java
Patch:
@@ -68,19 +68,19 @@ public void add(final long version) {
     }
 
     /**
-     * Get the count for a block version within the window.
+     * Get the count of blocks at or above the given version, within the window.
      *
      * @param version the block version to query.
      * @return the count for the block version, or null if the window is not yet
      * full.
      */
-    public Integer getCount(final long version) {
+    public Integer getCountAtOrAbove(final long version) {
         if (versionsStored < versionWindow.length) {
             return null;
         }
         int count = 0;
         for (int versionIdx = 0; versionIdx < versionWindow.length; versionIdx++) {
-            if (versionWindow[versionIdx] == version) {
+            if (versionWindow[versionIdx] >= version) {
                 count++;
             }
         }

File: core/src/test/java/org/bitcoinj/core/ChainSplitTest.java
Patch:
@@ -566,7 +566,7 @@ public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coi
 
         Block b1 = unitTestParams.getGenesisBlock().createNextBlock(someOtherGuy);
         final ECKey coinsTo2 = wallet.freshReceiveKey();
-        Block b2 = b1.createNextBlockWithCoinbase(coinsTo2.getPubKey());
+        Block b2 = b1.createNextBlockWithCoinbase(Block.BLOCK_VERSION_GENESIS, coinsTo2.getPubKey(), 2);
         Block b3 = b2.createNextBlock(someOtherGuy);
 
         log.debug("Adding block b1");

File: core/src/test/java/org/bitcoinj/core/CoinbaseBlockTest.java
Patch:
@@ -26,6 +26,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigInteger;
+import java.util.EnumSet;
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
@@ -63,7 +64,7 @@ public void testReceiveCoinbaseTransaction() throws Exception {
 
         // Check block.
         assertNotNull(block);
-        block.verify();
+        block.verify(169482, EnumSet.noneOf(VerificationFlags.class));
         assertEquals(BLOCK_NONCE, block.getNonce());
 
         StoredBlock storedBlock = new StoredBlock(block, BigInteger.ONE, BLOCK_OF_INTEREST); // Nonsense work - not used in test.

File: core/src/test/java/org/bitcoinj/core/ParseByteCacheTest.java
Patch:
@@ -35,6 +35,7 @@
 import static org.junit.Assert.*;
 
 public class ParseByteCacheTest {
+    private static final int BLOCK_HEIGHT_GENESIS = 0;
 
     private final byte[] txMessage = HEX.withSeparator(" ", 2).decode(
             "f9 be b4 d9 74 78 00 00  00 00 00 00 00 00 00 00" +
@@ -101,7 +102,7 @@ public void setUp() throws Exception {
         Transaction tx2 = createFakeTx(unitTestParams, COIN,
                 new ECKey().toAddress(unitTestParams));
 
-        Block b1 = createFakeBlock(blockStore, tx1, tx2).block;
+        Block b1 = createFakeBlock(blockStore, BLOCK_HEIGHT_GENESIS, tx1, tx2).block;
 
         MessageSerializer bs = unitTestParams.getDefaultSerializer();
         

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -237,7 +237,7 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         assertEquals(transactions[0], sendResult.tx);
         assertEquals(1, transactions[0].getConfidence().numBroadcastPeers());
         // Confirm it.
-        Block b2 = FakeTxBuilder.createFakeBlock(blockStore, t1).block;
+        Block b2 = FakeTxBuilder.createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS, t1).block;
         inbound(p1, b2);
         pingAndWait(p1);
         assertNull(outbound(p1));

File: core/src/test/java/org/bitcoinj/protocols/channels/ChannelConnectionTest.java
Patch:
@@ -226,9 +226,9 @@ public void onAfterAutoSave(File newlySavedFile) {
 
         // Now confirm the settle TX and see if the channel deletes itself from the wallet.
         assertEquals(1, StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
-        wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
+        wallet.notifyNewBestBlock(createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).storedBlock);
         assertEquals(1, StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
-        wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
+        wallet.notifyNewBestBlock(createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS + 1).storedBlock);
         assertEquals(0, StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
     }
 

File: core/src/test/java/org/bitcoinj/store/WalletProtobufSerializerTest.java
Patch:
@@ -323,7 +323,7 @@ public void testRoundTripMarriedWallet() throws Exception {
     @Test
     public void coinbaseTxns() throws Exception {
         // Covers issue 420 where the outpoint index of a coinbase tx input was being mis-serialized.
-        Block b = params.getGenesisBlock().createNextBlockWithCoinbase(myKey.getPubKey(), FIFTY_COINS);
+        Block b = params.getGenesisBlock().createNextBlockWithCoinbase(Block.BLOCK_VERSION_GENESIS, myKey.getPubKey(), FIFTY_COINS, Block.BLOCK_HEIGHT_GENESIS);
         Transaction coinbase = b.getTransactions().get(0);
         assertTrue(coinbase.isCoinBase());
         BlockChain chain = new BlockChain(params, myWallet, new MemoryBlockStore(params));

File: core/src/test/java/org/bitcoinj/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -92,7 +92,7 @@ public void coinAgeOrdering() throws Exception {
         // and t3=0.01.
         Transaction t1 = checkNotNull(sendMoneyToWallet(COIN, AbstractBlockChain.NewBlockType.BEST_CHAIN));
         // Padding block.
-        wallet.notifyNewBestBlock(FakeTxBuilder.createFakeBlock(blockStore).storedBlock);
+        wallet.notifyNewBestBlock(FakeTxBuilder.createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).storedBlock);
         final Coin TWO_COINS = COIN.multiply(2);
         Transaction t2 = checkNotNull(sendMoneyToWallet(TWO_COINS, AbstractBlockChain.NewBlockType.BEST_CHAIN));
         Transaction t3 = checkNotNull(sendMoneyToWallet(CENT, AbstractBlockChain.NewBlockType.BEST_CHAIN));

File: core/src/main/java/org/bitcoinj/core/AbstractBlockChain.java
Patch:
@@ -216,21 +216,21 @@ public final void addNewBestBlockListener(final NewBestBlockListener listener) {
     }
 
     /**
-     * Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
+     * Adds a generic {@link NewBestBlockListener} listener to the chain.
      */
     public final void addNewBestBlockListener(Executor executor, final NewBestBlockListener listener) {
         newBestBlockListeners.add(new ListenerRegistration<NewBestBlockListener>(executor, listener));
     }
 
     /**
-     * Adds a generic {@link NewBestBlockListener} listener to the chain.
+     * Adds a generic {@link ReorganizeListener} listener to the chain.
      */
     public final void addReorganizeListener(final ReorganizeListener listener) {
         addReorganizeListener(Threading.USER_THREAD, listener);
     }
 
     /**
-     * Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
+     * Adds a generic {@link ReorganizeListener} listener to the chain.
      */
     public final void addReorganizeListener(Executor executor, final ReorganizeListener listener) {
         reorganizeListeners.add(new ListenerRegistration<ReorganizeListener>(executor, listener));

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -16,6 +16,8 @@
 import static com.google.common.base.Preconditions.checkState;
 import static wallettemplate.utils.GuiUtils.*;
 
+import javax.annotation.Nullable;
+
 public class SendMoneyController {
     public Button sendBtn;
     public Button cancelBtn;
@@ -57,7 +59,7 @@ public void send(ActionEvent event) {
             sendResult = Main.bitcoin.wallet().sendCoins(req);
             Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<Transaction>() {
                 @Override
-                public void onSuccess(Transaction result) {
+                public void onSuccess(@Nullable Transaction result) {
                     checkGuiThread();
                     overlayUI.done();
                 }

File: core/src/main/java/org/bitcoinj/core/AddressFormatException.java
Patch:
@@ -1,5 +1,6 @@
-/**
+/*
  * Copyright 2011 Google Inc.
+ * Copyright 2015 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +18,7 @@
 package org.bitcoinj.core;
 
 @SuppressWarnings("serial")
-public class AddressFormatException extends Exception {
+public class AddressFormatException extends IllegalArgumentException {
     public AddressFormatException() {
         super();
     }

File: core/src/test/java/org/bitcoinj/core/Base58Test.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -84,7 +84,7 @@ public void testDecode() throws Exception {
     }
 
     @Test
-    public void testDecodeToBigInteger() throws AddressFormatException {
+    public void testDecodeToBigInteger() {
         byte[] input = Base58.decode("129");
         assertEquals(new BigInteger(1, input), Base58.decodeToBigInteger("129"));
     }

File: core/src/test/java/org/bitcoinj/script/ScriptTest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2011 Google Inc.
  * Copyright 2014 Andreas Schildbach
  *
@@ -118,7 +118,7 @@ public void testIp() throws Exception {
     }
     
     @Test
-    public void testCreateMultiSigInputScript() throws AddressFormatException {
+    public void testCreateMultiSigInputScript() {
         // Setup transaction and signatures
         ECKey key1 = DumpedPrivateKey.fromBase58(params, "cVLwRLTvz3BxDAWkvS3yzT9pUcTCup7kQnfT2smRjvmmm1wAP6QT").getKey();
         ECKey key2 = DumpedPrivateKey.fromBase58(params, "cTine92s8GLpVqvebi8rYce3FrUYq78ZGQffBYCS1HmDPJdSTxUo").getKey();

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -83,9 +83,6 @@ public void onFailure(Throwable t) {
             overlayUI.done();
         } catch (ECKey.KeyIsEncryptedException e) {
             askForPasswordAndRetry();
-        } catch (AddressFormatException e) {
-            // Cannot happen because we already validated it when the text field changed.
-            throw new RuntimeException(e);
         }
     }
 

File: core/src/main/java/org/bitcoinj/store/PostgresFullPrunedBlockStore.java
Patch:
@@ -86,7 +86,7 @@ public class PostgresFullPrunedBlockStore extends DatabaseFullPrunedBlockStore {
     private static final String CREATE_OUTPUTS_HASH_INDEX               = "CREATE INDEX openoutputs_hash_idx ON openoutputs USING btree (hash)";
     private static final String CREATE_UNDOABLE_TABLE_INDEX             = "CREATE INDEX undoableblocks_height_idx ON undoableBlocks USING btree (height)";
 
-    private static final String SELECT_UNDOABLEBLOCKS_EXISTS_SQL        = "select 1 from undoableBlocks where hash = ?";
+    private static final String SELECT_UNDOABLEBLOCKS_EXISTS_SQL        = "select 1 from undoableblocks where hash = ?";
 
     /**
      * Creates a new PostgresFullPrunedBlockStore.

File: examples/src/main/java/org/bitcoinj/examples/DumpWallet.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: examples/src/main/java/org/bitcoinj/examples/ForwardingService.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2013 Google Inc.
  * Copyright 2014 Andreas Schildbach
  *

File: examples/src/main/java/org/bitcoinj/examples/PrintPeers.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2011 John Sample.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: examples/src/main/java/org/bitcoinj/examples/PrivateKeys.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2011 Google Inc.
  * Copyright 2014 Andreas Schildbach
  *

File: tools/src/main/java/org/bitcoinj/tools/NetworkEnum.java
Patch:
@@ -1,5 +1,3 @@
-package org.bitcoinj.tools;
-
 /*
  * Copyright 2014 Mike Hearn
  *
@@ -16,6 +14,8 @@
  * limitations under the License.
  */
 
+package org.bitcoinj.tools;
+
 public enum NetworkEnum {
     MAIN,
     PROD, // alias for MAIN

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -2590,6 +2590,7 @@ private void clearTransactions() {
         pending.clear();
         dead.clear();
         transactions.clear();
+        myUnspents.clear();
     }
 
     /**

File: core/src/main/java/org/bitcoinj/core/VersionMessage.java
Patch:
@@ -262,8 +262,8 @@ public VersionMessage duplicate() {
 
     /**
      * Appends the given user-agent information to the subVer field. The subVer is composed of a series of
-     * name:version pairs separated by slashes in the form of a path. For example a typical subVer field for BitCoinJ
-     * users might look like "/BitCoinJ:0.4-SNAPSHOT/MultiBit:1.2/" where libraries come further to the left.<p>
+     * name:version pairs separated by slashes in the form of a path. For example a typical subVer field for bitcoinj
+     * users might look like "/bitcoinj:0.13/MultiBit:1.2/" where libraries come further to the left.<p>
      *
      * There can be as many components as you feel a need for, and the version string can be anything, but it is
      * recommended to use A.B.C where A = major, B = minor and C = revision for software releases, and dates for
@@ -272,7 +272,7 @@ public VersionMessage duplicate() {
      *
      * Anything put in the "comments" field will appear in brackets and may be used for platform info, or anything
      * else. For example, calling <tt>appendToSubVer("MultiBit", "1.0", "Windows")</tt> will result in a subVer being
-     * set of "/BitCoinJ:1.0/MultiBit:1.0(Windows)/". Therefore the / ( and ) characters are reserved in all these
+     * set of "/bitcoinj:1.0/MultiBit:1.0(Windows)/". Therefore the / ( and ) characters are reserved in all these
      * components. If you don't want to add a comment (recommended), pass null.<p>
      *
      * See <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a> for more information.

File: core/src/main/java/org/bitcoinj/net/discovery/IrcDiscovery.java
Patch:
@@ -197,7 +197,7 @@ private void logAndSend(String command) throws Exception {
     static ArrayList<InetSocketAddress> parseUserList(String[] userNames) throws UnknownHostException {
         ArrayList<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();
         for (String user : userNames) {
-            // All BitCoin peers start their nicknames with a 'u' character.
+            // All peers start their nicknames with a 'u' character.
             if (!user.startsWith("u")) {
                 continue;
             }
@@ -208,7 +208,7 @@ static ArrayList<InetSocketAddress> parseUserList(String[] userNames) throws Unk
             byte[] addressBytes;
             try {
                 // Strip off the "u" before decoding. Note that it's possible for anyone to join these IRC channels and
-                // so simply beginning with "u" does not imply this is a valid BitCoin encoded address.
+                // so simply beginning with "u" does not imply this is a valid encoded address.
                 //
                 // decodeChecked removes the checksum from the returned bytes.
                 addressBytes = Base58.decodeChecked(user.substring(1));

File: core/src/main/java/org/bitcoinj/store/BlockStore.java
Patch:
@@ -25,7 +25,7 @@
  * different ways. An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will want to
  * use implementations that save to disk.<p>
  *
- * A BlockStore is a map of hashes to StoredBlock. The hash is the double digest of the BitCoin serialization
+ * A BlockStore is a map of hashes to StoredBlock. The hash is the double digest of the Bitcoin serialization
  * of the block header, <b>not</b> the header with the extra data as well.<p>
  *
  * BlockStores are thread safe.

File: core/src/test/java/org/bitcoinj/core/BlockTest.java
Patch:
@@ -128,7 +128,7 @@ public void testHeaderParse() throws Exception {
     }
 
     @Test
-    public void testBitCoinSerialization() throws Exception {
+    public void testBitcoinSerialization() throws Exception {
         // We have to be able to reserialize everything exactly as we found it for hashing to work. This test also
         // proves that transaction serialization works, along with all its subobjects like scripts and in/outpoints.
         //

File: core/src/main/java/org/bitcoinj/core/DumpedPrivateKey.java
Patch:
@@ -90,6 +90,6 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hashCode(bytes, version, compressed);
+        return Objects.hashCode(version, compressed, Arrays.hashCode(bytes));
     }
 }

File: core/src/main/java/org/bitcoinj/core/GetBlocksMessage.java
Patch:
@@ -102,14 +102,14 @@ public boolean equals(Object o) {
         GetBlocksMessage other = (GetBlocksMessage) o;
         return version == other.version &&
                locator.size() == other.locator.size() &&
-               locator.containsAll(other.locator) &&
+               locator.containsAll(other.locator) && // ignores locator ordering
                stopHash.equals(other.stopHash);
     }
 
     @Override
     public int hashCode() {
         int hashCode = (int) version ^ "getblocks".hashCode();
-        for (Sha256Hash aLocator : locator) hashCode ^= aLocator.hashCode();
+        for (Sha256Hash aLocator : locator) hashCode ^= aLocator.hashCode(); // ignores locator ordering
         hashCode ^= stopHash.hashCode();
         return hashCode;
     }

File: core/src/main/java/org/bitcoinj/core/GetHeadersMessage.java
Patch:
@@ -49,14 +49,14 @@ public boolean equals(Object o) {
         GetHeadersMessage other = (GetHeadersMessage) o;
         return version == other.version &&
                locator.size() == other.locator.size() &&
-               locator.containsAll(other.locator) &&
+               locator.containsAll(other.locator) && // ignores locator ordering
                stopHash.equals(other.stopHash);
     }
 
     @Override
     public int hashCode() {
         int hashCode = (int) version ^ "getheaders".hashCode();
-        for (Sha256Hash aLocator : locator) hashCode ^= aLocator.hashCode();
+        for (Sha256Hash aLocator : locator) hashCode ^= aLocator.hashCode(); // ignores locator ordering
         hashCode ^= stopHash.hashCode();
         return hashCode;
     }

File: core/src/main/java/org/bitcoinj/core/Sha256Hash.java
Patch:
@@ -265,6 +265,7 @@ public byte[] getReversedBytes() {
 
     @Override
     public int compareTo(Sha256Hash o) {
-        return this.hashCode() - o.hashCode();
+        // note that in this implementation compareTo() is not consistent with equals()
+        return this.hashCode() - o.hashCode(); // arbitrary but consistent
     }
 }

File: core/src/main/java/org/bitcoinj/core/TransactionInput.java
Patch:
@@ -479,7 +479,6 @@ public boolean equals(Object o) {
         if (sequence != input.sequence) return false;
         if (!outpoint.equals(input.outpoint)) return false;
         if (!Arrays.equals(scriptBytes, input.scriptBytes)) return false;
-        if (scriptSig != null ? !scriptSig.equals(input.scriptSig) : input.scriptSig != null) return false;
         if (parent != input.parent) return false;
 
         return true;
@@ -490,7 +489,6 @@ public int hashCode() {
         int result = (int) (sequence ^ (sequence >>> 32));
         result = 31 * result + outpoint.hashCode();
         result = 31 * result + (scriptBytes != null ? Arrays.hashCode(scriptBytes) : 0);
-        result = 31 * result + (scriptSig != null ? scriptSig.hashCode() : 0);
         return result;
     }
 }

File: core/src/main/java/org/bitcoinj/core/TransactionOutPoint.java
Patch:
@@ -239,6 +239,6 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return 31 * hash.hashCode() + (int) (index ^ (index >>> 32));
+        return 31 * getHash().hashCode() + (int) (getIndex() ^ (getIndex() >>> 32));
     }
 }

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -444,7 +444,7 @@ public int hashCode() {
         int result = (int) (value ^ (value >>> 32));
         result = 31 * result + Arrays.hashCode(scriptBytes);
         if (parent != null)
-            result *= parent.getHash().hashCode() + getIndex();
+            result *= parent.getHash().hashCode();
         return result;
     }
 }

File: core/src/main/java/org/bitcoinj/core/Utils.java
Patch:
@@ -578,6 +578,7 @@ public static boolean isAndroidRuntime() {
     private static class Pair implements Comparable<Pair> {
         int item, count;
         public Pair(int item, int count) { this.count = count; this.item = item; }
+        // note that in this implementation compareTo() is not consistent with equals()
         @Override public int compareTo(Pair o) { return -Ints.compare(count, o.count); }
     }
 

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4050,6 +4050,7 @@ public TxOffsetPair(Transaction tx, int offset) {
         }
 
         @Override public int compareTo(TxOffsetPair o) {
+            // note that in this implementation compareTo() is not consistent with equals()
             return Ints.compare(offset, o.offset);
         }
     }

File: core/src/main/java/org/bitcoinj/crypto/ChildNumber.java
Patch:
@@ -91,6 +91,7 @@ public int hashCode() {
 
     @Override
     public int compareTo(ChildNumber other) {
+        // note that in this implementation compareTo() is not consistent with equals()
         return Ints.compare(this.num(), other.num());
     }
 }

File: core/src/main/java/org/bitcoinj/utils/ExponentialBackoff.java
Patch:
@@ -90,6 +90,7 @@ public long getRetryTime() {
 
     @Override
     public int compareTo(ExponentialBackoff other) {
+        // note that in this implementation compareTo() is not consistent with equals()
         if (retryTime < other.retryTime)
             return -1;
         if (retryTime > other.retryTime)

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -501,8 +501,8 @@ public void onPeerDisconnected(Peer peer, int peerCount) {
             }
         }, Threading.SAME_THREAD);
         // connect to peer but don't do handshake
+        long start = System.currentTimeMillis(); // before connection so we don't get elapsed < timeout
         connectPeerWithoutVersionExchange(0);
-        long start = System.currentTimeMillis();
         // wait for disconnect (plus a bit more, in case test server is overloaded)
         try {
             peerDisconnectedFuture.get(timeout + 200, TimeUnit.MILLISECONDS);

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -619,7 +619,7 @@ public boolean hasKey(ECKey key) {
 
     /** Returns the deterministic key for the given absolute path in the hierarchy. */
     protected DeterministicKey getKeyByPath(ChildNumber... path) {
-        return getKeyByPath(ImmutableList.<ChildNumber>copyOf(path));
+        return getKeyByPath(ImmutableList.copyOf(path));
     }
 
     /** Returns the deterministic key for the given absolute path in the hierarchy. */

File: core/src/main/java/org/bitcoinj/core/BlockChain.java
Patch:
@@ -38,8 +38,8 @@ public class BlockChain extends AbstractBlockChain {
 
     /**
      * <p>Constructs a BlockChain connected to the given wallet and store. To obtain a {@link Wallet} you can construct
-     * one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}
-     * </p>
+     * one from scratch, or you can deserialize a saved wallet from disk using
+     * {@link Wallet#loadFromFile(java.io.File, WalletExtension...)}</p>
      *
      * <p>For the store, you should use {@link org.bitcoinj.store.SPVBlockStore} or you could also try a
      * {@link org.bitcoinj.store.MemoryBlockStore} if you want to hold all headers in RAM and don't care about

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -2555,7 +2555,7 @@ public Map<Sha256Hash, Transaction> getTransactionPool(Pool pool) {
 
     /**
      * Prepares the wallet for a blockchain replay. Removes all transactions (as they would get in the way of the
-     * replay) and makes the wallet think it has never seen a block. {@link WalletEventListener#onWalletChanged()} will
+     * replay) and makes the wallet think it has never seen a block. {@link WalletEventListener#onWalletChanged} will
      * be fired.
      */
     public void reset() {

File: core/src/main/java/org/bitcoinj/crypto/ChildNumber.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
- * and a getter for the actual 0-based child number. A {@link List} of these forms a <i>path</i> through a
+ * and a getter for the actual 0-based child number. A {@link java.util.List} of these forms a <i>path</i> through a
  * {@link DeterministicHierarchy}. This class is immutable.
  */
 public class ChildNumber implements Comparable<ChildNumber> {

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypterException.java
Patch:
@@ -1,7 +1,7 @@
 package org.bitcoinj.crypto;
 
 /**
- * <p>Exception to provide the following to {@link EncrypterDecrypterOpenSSL}:</p>
+ * <p>Exception to provide the following:</p>
  * <ul>
  * <li>Provision of encryption / decryption exception</li>
  * </ul>

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientConnection.java
Patch:
@@ -162,7 +162,9 @@ public void connectionClosed(ProtobufParser<Protos.TwoWayChannelMessage> handler
      * an error before the channel has reached the open state.</p>
      *
      * <p>After this future completes successfully, you may call
-     * {@link PaymentChannelClientConnection#incrementPayment(Coin)} or {@link PaymentChannelClientConnection#incrementPayment(Coin, com.google.protobuf.ByteString)} to begin paying the server.</p>
+     * {@link PaymentChannelClientConnection#incrementPayment(Coin)} or
+     * {@link PaymentChannelClientConnection#incrementPayment(Coin, com.google.protobuf.ByteString, KeyParameter)} to
+     * begin paying the server.</p>
      */
     public ListenableFuture<PaymentChannelClientConnection> getChannelOpenFuture() {
         return channelOpenFuture;

File: core/src/main/java/org/bitcoinj/store/WalletProtobufSerializer.java
Patch:
@@ -539,8 +539,8 @@ private void loadExtensions(Wallet wallet, WalletExtension[] extensionsList, Pro
 
     /**
      * Returns the loaded protocol buffer from the given byte stream. You normally want
-     * {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for low level work involving the
-     * wallet file format itself.
+     * {@link Wallet#loadFromFile(java.io.File, WalletExtension...)} instead - this method is designed for low level
+     * work involving the wallet file format itself.
      */
     public static Protos.Wallet parseToProto(InputStream input) throws IOException {
         CodedInputStream codedInput = CodedInputStream.newInstance(input);

File: core/src/main/java/org/bitcoinj/uri/BitcoinURI.java
Patch:
@@ -93,8 +93,8 @@ public class BitcoinURI {
     public static final String FIELD_PAYMENT_REQUEST_URL = "r";
 
     /**
-     * URI for Bitcoin network. Use {@link org.bitcoinj.params.AbstractBitcoinNetParams.BITCOIN_SCHEME} if you specifically
-     * need Bitcoin, or use {@link org.bitcoinj.core.NetworkParams.getUriScheme()} to get the scheme
+     * URI for Bitcoin network. Use {@link org.bitcoinj.params.AbstractBitcoinNetParams#BITCOIN_SCHEME} if you specifically
+     * need Bitcoin, or use {@link org.bitcoinj.core.NetworkParameters#getUriScheme} to get the scheme
      * from network parameters.
      */
     @Deprecated

File: core/src/main/java/org/bitcoinj/uri/OptionalFieldValidationException.java
Patch:
@@ -1,7 +1,7 @@
 package org.bitcoinj.uri;
 
 /**
- * <p>Exception to provide the following to {@link org.multibit.qrcode.BitcoinURI}:</p>
+ * <p>Exception to provide the following to {@link org.bitcoinj.uri.BitcoinURI}:</p>
  * <ul>
  * <li>Provision of parsing error messages</li>
  * </ul>

File: core/src/main/java/org/bitcoinj/utils/BtcFixedFormat.java
Patch:
@@ -31,7 +31,7 @@
  *
  * <p>By default, neither currency codes nor symbols are included in formatted values as
  * output, nor recognized in parsed values as input.  The can be overridden by applying a
- * custom pattern using either the {@link BtcFormat.Builder#localizedPattern} or {@link BtcFormat.Builder#localizedPattern()} methods, as described in the documentation for the {@link BtcFormat.Builder}
+ * custom pattern using either the {@link BtcFormat.Builder#localizedPattern} or {@link BtcFormat.Builder#localizedPattern} methods, as described in the documentation for the {@link BtcFormat.Builder}
  * class.<ol>
  *
  * <p>A more detailed explanation, including examples, is in the documentation for the

File: core/src/main/java/org/bitcoinj/utils/BtcFormat.java
Patch:
@@ -409,7 +409,7 @@
  * specified by <code></code>, <code>u</code>, <code>B</code>, <code></code>,
  * <code>BTC</code> or other appropriate permutations of those characters.  Additionally, if
  * either or both of a custom currency code or symbol is configured using {@link
- * BtcFormat.Builder#code()} or {@link BtcFormat.Builder.code()}, then such code or symbol will
+ * BtcFormat.Builder#code} or {@link BtcFormat.Builder#code}, then such code or symbol will
  * be recognized in addition to those recognized by default..
  *
  * <p>Instances of this class that recognize currency signs will recognize both currency
@@ -1247,7 +1247,7 @@ private static ImmutableList<Integer> setFormatterDigits(DecimalFormat formatter
      *  @param unitCount      the number of monetary units to be formatted
      *  @param scale          the denomination of those units as the decimal-place shift from coins
      *  @param minDecimals    the minimum number of fractional decimal places
-     *  @param fractiongroups the sizes of option fractional decimal-place groups
+     *  @param fractionGroups the sizes of option fractional decimal-place groups
      */
     private static int calculateFractionPlaces(
         BigDecimal unitCount, int scale, int minDecimals, List<Integer> fractionGroups)
@@ -1538,7 +1538,7 @@ public String coinCode() { synchronized(numberFormat) {
 
     /** Return a representation of the pattern used by this instance for formatting and
      *  parsing.  The format is similar to, but not the same as the format recognized by the
-     *  {@link Builder.pattern()} and {@link Builder.localizedPattern()} methods.  The pattern
+     *  {@link Builder#pattern} and {@link Builder#localizedPattern} methods.  The pattern
      *  returned by this method is localized, any currency signs expressed are literally, and
      *  optional fractional decimal places are shown grouped in parentheses. */
     public String pattern() { synchronized(numberFormat) {

File: core/src/main/java/org/bitcoinj/utils/Fiat.java
Patch:
@@ -25,8 +25,8 @@
 import com.google.common.math.LongMath;
 
 /**
- * Represents a monetary fiat value. It was decided to not fold this into {@link Coin} because of type safety. Fiat
- * values always come with an attached currency code.
+ * Represents a monetary fiat value. It was decided to not fold this into {@link org.bitcoinj.core.Coin} because of type
+ * safety. Fiat values always come with an attached currency code.
  * 
  * This class is immutable.
  */

File: core/src/main/java/org/bitcoinj/utils/MonetaryFormat.java
Patch:
@@ -228,7 +228,7 @@ public MonetaryFormat noCode() {
      * Configure currency code for given decimal separator shift. This configuration is not relevant for parsing.
      * 
      * @param codeShift
-     *            decimal separator shift, see {@link #shift()}
+     *            decimal separator shift, see {@link #shift}
      * @param code
      *            currency code
      */
@@ -401,7 +401,7 @@ public Coin parse(String str) throws NumberFormatException {
     }
 
     /**
-     * Parse a human readable fiat value to a {@link org.bitcoinj.core.Fiat} instance.
+     * Parse a human readable fiat value to a {@link org.bitcoinj.utils.Fiat} instance.
      * 
      * @throws NumberFormatException
      *             if the string cannot be parsed for some reason

File: core/src/main/java/org/bitcoinj/wallet/KeyTimeCoinSelector.java
Patch:
@@ -34,7 +34,7 @@
 public class KeyTimeCoinSelector implements CoinSelector {
     private static final Logger log = LoggerFactory.getLogger(KeyTimeCoinSelector.class);
 
-    /** A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction.MAX_STANDARD_TX_SIZE} */
+    /** A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction#MAX_STANDARD_TX_SIZE} */
     public static final int MAX_SIMULTANEOUS_INPUTS = 600;
 
     private final long unixTimeSeconds;

File: core/src/main/java/org/bitcoinj/core/Base58.java
Patch:
@@ -142,7 +142,7 @@ public static BigInteger decodeToBigInteger(String input) throws AddressFormatEx
      * @throws AddressFormatException if the input is not base 58 or the checksum does not validate.
      */
     public static byte[] decodeChecked(String input) throws AddressFormatException {
-        byte tmp [] = decode(input);
+        byte[] tmp  = decode(input);
         if (tmp.length < 4)
             throw new AddressFormatException("Input too short");
         byte[] bytes = copyOfRange(tmp, 0, tmp.length - 4);

File: core/src/main/java/org/bitcoinj/core/EmptyMessage.java
Patch:
@@ -40,7 +40,7 @@ public EmptyMessage(NetworkParameters params, byte[] payload, int offset) throws
     }
 
     @Override
-    final protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
+    protected final void bitcoinSerializeToStream(OutputStream stream) throws IOException {
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/core/Message.java
Patch:
@@ -55,8 +55,8 @@ public abstract class Message implements Serializable {
 
     protected transient boolean parsed = false;
     protected transient boolean recached = false;
-    protected transient final boolean parseLazy;
-    protected transient final boolean parseRetain;
+    protected final transient boolean parseLazy;
+    protected final transient boolean parseRetain;
 
     protected transient int protocolVersion;
 

File: core/src/main/java/org/bitcoinj/core/NetworkParameters.java
Patch:
@@ -102,7 +102,7 @@ public abstract class NetworkParameters implements Serializable {
     protected int[] acceptableAddressCodes;
     protected String[] dnsSeeds;
     protected int[] addrSeeds;
-    protected HttpDiscovery.Details[] httpSeeds = new HttpDiscovery.Details[] {};
+    protected HttpDiscovery.Details[] httpSeeds = {};
     protected Map<Integer, Sha256Hash> checkpoints = new HashMap<Integer, Sha256Hash>();
 
     protected NetworkParameters() {

File: core/src/main/java/org/bitcoinj/core/UnsafeByteArrayOutputStream.java
Patch:
@@ -63,7 +63,7 @@ public void write(int b) {
      * @param len the number of bytes to write.
      */
     @Override
-    public void write(byte b[], int off, int len) {
+    public void write(byte[] b, int off, int len) {
         if ((off < 0) || (off > b.length) || (len < 0) ||
                 ((off + len) > b.length) || ((off + len) < 0)) {
             throw new IndexOutOfBoundsException();

File: core/src/main/java/org/bitcoinj/core/Utils.java
Patch:
@@ -516,7 +516,7 @@ public static byte[] formatMessageForSigning(String message) {
     }
     
     // 00000001, 00000010, 00000100, 00001000, ...
-    private static final int bitMask[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
+    private static final int[] bitMask = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
     
     /** Checks if the given bit is set in data, using little endian (not the same as Java native big endian) */
     public static boolean checkBitLE(byte[] data, int index) {

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -202,7 +202,7 @@ protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest) {
     @GuardedBy("lock") private List<TransactionSigner> signers;
 
     // If this is set then the wallet selects spendable candidate outputs from a UTXO provider.
-    @Nullable volatile private UTXOProvider vUTXOProvider;
+    @Nullable private volatile UTXOProvider vUTXOProvider;
 
     /**
      * Creates a new, empty wallet with a randomly chosen seed and no transactions. Make sure to provide for sufficient

File: core/src/main/java/org/bitcoinj/crypto/X509Utils.java
Patch:
@@ -48,7 +48,8 @@ public class X509Utils {
      * can also be the org (O) field, org+location+country if withLocation is set, or the email
      * address for S/MIME certificates.
      */
-    public static @Nullable String getDisplayNameFromCertificate(@Nonnull X509Certificate certificate, boolean withLocation) throws CertificateParsingException {
+    @Nullable
+    public static String getDisplayNameFromCertificate(@Nonnull X509Certificate certificate, boolean withLocation) throws CertificateParsingException {
         X500Name name = new X500Name(certificate.getSubjectX500Principal().getName());
         String commonName = null, org = null, location = null, country = null;
         for (RDN rdn : name.getRDNs()) {

File: core/src/main/java/org/bitcoinj/net/discovery/IrcDiscovery.java
Patch:
@@ -222,7 +222,7 @@ static ArrayList<InetSocketAddress> parseUserList(String[] userNames) throws Unk
                 continue;
             }
 
-            byte[] ipBytes = new byte[]{addressBytes[0], addressBytes[1], addressBytes[2], addressBytes[3]};
+            byte[] ipBytes = {addressBytes[0], addressBytes[1], addressBytes[2], addressBytes[3]};
             int port = Utils.readUint16BE(addressBytes, 4);
 
             InetAddress ip;

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocol.java
Patch:
@@ -159,7 +159,8 @@ public static void signPaymentRequest(Protos.PaymentRequest.Builder paymentReque
      * @return verification data, or null if no PKI method was specified in the {@link Protos.PaymentRequest}.
      * @throws PaymentProtocolException if payment request could not be verified.
      */
-    public static @Nullable PkiVerificationData verifyPaymentRequestPki(Protos.PaymentRequest paymentRequest, KeyStore trustStore)
+    @Nullable
+    public static PkiVerificationData verifyPaymentRequestPki(Protos.PaymentRequest paymentRequest, KeyStore trustStore)
             throws PaymentProtocolException {
         List<X509Certificate> certs = null;
         try {
@@ -412,7 +413,7 @@ public static Protos.Output createPayToAddressOutput(@Nullable Coin amount, Addr
      * Value object to hold amount/script pairs.
      */
     public static class Output implements Serializable {
-        public final @Nullable Coin amount;
+        @Nullable public final Coin amount;
         public final byte[] scriptData;
 
         public Output(@Nullable Coin amount, byte[] scriptData) {

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -1137,7 +1137,7 @@ public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreE
             s.setString(1, address.toString());
             ResultSet rs = s.executeQuery();
             BigInteger balance = BigInteger.ZERO;
-            while (rs.next()) {
+            if (rs.next()) {
                 return BigInteger.valueOf(rs.getLong(1));
             }
             return balance;

File: core/src/main/java/org/bitcoinj/testing/FooWalletExtension.java
Patch:
@@ -8,7 +8,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 
 public class FooWalletExtension implements WalletExtension {
-    private final byte[] data = new byte[]{1, 2, 3};
+    private final byte[] data = {1, 2, 3};
 
     private final boolean isMandatory;
     private final String id;
@@ -37,4 +37,4 @@ public byte[] serializeWalletExtension() {
     public void deserializeWalletExtension(Wallet wallet, byte[] data) {
         checkArgument(Arrays.equals(this.data, data));
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -53,7 +53,7 @@ public class TestWithNetworkConnections {
     protected Address address;
     protected SocketAddress socketAddress;
 
-    private NioServer peerServers[] = new NioServer[PEER_SERVERS];
+    private NioServer[] peerServers = new NioServer[PEER_SERVERS];
     private final ClientConnectionManager channels;
     protected final BlockingQueue<InboundMessageQueuer> newPeerWriteTargetQueue = new LinkedBlockingQueue<InboundMessageQueuer>();
 

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -54,7 +54,7 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
 
     protected final Transaction tx;
     protected final List<Transaction> dependencies;
-    protected final @Nullable Wallet wallet;
+    @Nullable protected final Wallet wallet;
 
     private Transaction nonStandard;
     protected Transaction nonFinal;
@@ -78,7 +78,8 @@ public Result analyze() {
         return analyzeIsStandard();
     }
 
-    private @Nullable Result analyzeIsFinal() {
+    @Nullable
+    private Result analyzeIsFinal() {
         // Transactions we create ourselves are, by definition, not at risk of double spending against us.
         if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF)
             return Result.OK;

File: core/src/test/java/org/bitcoinj/core/BitcoinSerializerTest.java
Patch:
@@ -184,7 +184,7 @@ public void testHeaders1() throws Exception {
         ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
         bs.serialize(hm, byteArrayOutputStream);
         byte[] serializedBytes = byteArrayOutputStream.toByteArray();
-        String serializedBytesHex = new String(HEX.encode(serializedBytes));
+        String serializedBytesHex = HEX.encode(serializedBytes);
         assertEquals(headersMessageBytes.length, serializedBytes.length);
         assertEquals(true, Arrays.equals(headersMessageBytes, serializedBytes));
     }

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -221,7 +221,7 @@ public boolean add(Rule element) {
         {
             Transaction coinbase = b2.block.getTransactions().get(0);
             TransactionOutPoint outpoint = new TransactionOutPoint(params, 0, coinbase.getHash());
-            long[] heights = new long[] {chainHeadHeight + 2};
+            long[] heights = {chainHeadHeight + 2};
             UTXOsMessage result = new UTXOsMessage(params, ImmutableList.of(coinbase.getOutput(0)), heights, b2.getHash(), chainHeadHeight + 2);
             utxo1 = new UTXORule("utxo1", outpoint, result);
             blocks.add(utxo1);
@@ -242,7 +242,7 @@ public boolean add(Rule element) {
             TransactionOutPoint outpoint = new TransactionOutPoint(params, 0, coinbase.getHash());
             List<TransactionOutPoint> queries = ImmutableList.of(utxo1.query.get(0), outpoint);
             List<TransactionOutput> results = Lists.asList(null, coinbase.getOutput(0), new TransactionOutput[]{});
-            long[] heights = new long[] {chainHeadHeight + 3};
+            long[] heights = {chainHeadHeight + 3};
             UTXOsMessage result = new UTXOsMessage(params, results, heights, b4.getHash(), chainHeadHeight + 3);
             UTXORule utxo2 = new UTXORule("utxo2", queries, result);
             blocks.add(utxo2);
@@ -1502,7 +1502,7 @@ public boolean add(Rule element) {
         // Check the UTXO query takes mempool into account.
         {
             TransactionOutPoint outpoint = new TransactionOutPoint(params, 0, b79tx.getHash());
-            long[] heights = new long[] { UTXOsMessage.MEMPOOL_HEIGHT };
+            long[] heights = { UTXOsMessage.MEMPOOL_HEIGHT };
             UTXOsMessage result = new UTXOsMessage(params, ImmutableList.of(b79tx.getOutput(0)), heights, b82.getHash(), chainHeadHeight + 28);
             UTXORule utxo3 = new UTXORule("utxo3", outpoint, result);
             blocks.add(utxo3);

File: core/src/test/java/org/bitcoinj/crypto/ChildKeyDerivationTest.java
Patch:
@@ -34,7 +34,7 @@ public class ChildKeyDerivationTest {
 
     @Test
     public void testChildKeyDerivation() throws Exception {
-        String ckdTestVectors[] = {
+        String[] ckdTestVectors = {
                 // test case 1:
                 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                 "04" +  "6a04ab98d9e4774ad806e302dddeb63b" +

File: core/src/test/java/org/bitcoinj/crypto/HDUtilsTest.java
Patch:
@@ -27,7 +27,7 @@
 public class HDUtilsTest {
     @Test
     public void testHmac() throws Exception {
-        String tv[] = {
+        String[] tv = {
                 "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b" +
                         "0b0b0b0b",
                 "4869205468657265",
@@ -127,7 +127,7 @@ public void testLongToByteArray() throws Exception {
 
     @Test
     public void testFormatPath() {
-        Object tv[] = {
+        Object[] tv = {
                 "M/44H/0H/0H/1/1",
                 ImmutableList.of(new ChildNumber(44, true), new ChildNumber(0, true), new ChildNumber(0, true),
                         new ChildNumber(1, false), new ChildNumber(1, false)),
@@ -156,7 +156,7 @@ public void testFormatPath() {
 
     @Test
     public void testParsePath() {
-        Object tv[] = {
+        Object[] tv = {
                 "M / 44H / 0H / 0H / 1 / 1",
                 ImmutableList.of(new ChildNumber(44, true), new ChildNumber(0, true), new ChildNumber(0, true),
                         new ChildNumber(1, false), new ChildNumber(1, false)),

File: core/src/test/java/org/bitcoinj/crypto/MnemonicCodeTest.java
Patch:
@@ -32,7 +32,7 @@
 
 public class MnemonicCodeTest {
     // These vectors are from https://github.com/trezor/python-mnemonic/blob/master/vectors.json
-    String vectors[] = {
+    String[] vectors = {
         "00000000000000000000000000000000",
         "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
         "c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
@@ -208,11 +208,11 @@ public void testEmptyMnemonic() throws Exception {
 
     @Test(expected = MnemonicException.MnemonicLengthException.class)
     public void testEmptyEntropy() throws Exception {
-        byte[] entropy = new byte[]{};
+        byte[] entropy = {};
         mc.toMnemonic(entropy);
     }
 
-    static public List<String> split(String words) {
+    public static List<String> split(String words) {
         return new ArrayList<String>(Arrays.asList(words.split("\\s+")));
     }
 }

File: core/src/test/java/org/bitcoinj/protocols/channels/ChannelTestUtils.java
Patch:
@@ -62,7 +62,7 @@ public void checkTotalPayment(Coin valueSoFar) throws InterruptedException {
 
     public static class RecordingClientConnection implements PaymentChannelClient.ClientConnection {
         public BlockingQueue<Object> q = new LinkedBlockingQueue<Object>();
-        final static int IGNORE_EXPIRE = -1;
+        static final int IGNORE_EXPIRE = -1;
         private final int maxExpireTime;
 
         // An arbitrary sentinel object for equality testing.

File: core/src/test/java/org/bitcoinj/protocols/payments/PaymentProtocolTest.java
Patch:
@@ -48,7 +48,7 @@ public class PaymentProtocolTest {
     private static final Address TO_ADDRESS = new ECKey().toAddress(NETWORK_PARAMS);
     private static final String MEMO = "memo";
     private static final String PAYMENT_URL = "https://example.com";
-    private static final byte[] MERCHANT_DATA = new byte[] { 0, 1, 2 };
+    private static final byte[] MERCHANT_DATA = { 0, 1, 2 };
 
     private KeyStore caStore;
     private X509Certificate caCert;

File: examples/src/main/java/org/bitcoinj/examples/PrivateKeys.java
Patch:
@@ -76,7 +76,6 @@ public static void main(String[] args) throws Exception {
         } catch (ArrayIndexOutOfBoundsException e) {
             System.out.println("First arg should be private key in Base58 format. Second argument should be address " +
                     "to send to.");
-            return;
         }
     }
 }

File: tools/src/main/java/org/bitcoinj/tools/WatchMempool.java
Patch:
@@ -68,15 +68,15 @@ public void onTransaction(Peer peer, Transaction tx) {
         }
     }
 
-    private synchronized static void incrementCounter(String name) {
+    private static synchronized void incrementCounter(String name) {
         Integer count = counters.get(name);
         if (count == null)
             count = 0;
         count++;
         counters.put(name, count);
     }
 
-    private synchronized static void printCounters() {
+    private static synchronized void printCounters() {
         System.out.printf("Runtime: %d minutes\n", (System.currentTimeMillis() - START_MS) / 1000 / 60);
         Integer total = counters.get(TOTAL_KEY);
         if (total == null)

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -791,7 +791,7 @@ public TransactionInput addSignedInput(TransactionOutput output, ECKey signingKe
     }
 
     /**
-     * Removes all the inputs from this transaction.
+     * Removes all the outputs from this transaction.
      * Note that this also invalidates the length attribute
      */
     public void clearOutputs() {

File: core/src/test/java/org/bitcoinj/crypto/KeyCrypterScryptTest.java
Patch:
@@ -111,11 +111,11 @@ public void testKeyCrypterWrongPassword() throws KeyCrypterException {
             stringBuffer.append(i).append(" ").append("The quick brown fox");
         }
 
-        EncryptedData encryptedPrivateKey = keyCrypter.encrypt(stringBuffer.toString().getBytes(), keyCrypter.deriveKey(PASSWORD2));
-        assertNotNull(encryptedPrivateKey);
+        EncryptedData data = keyCrypter.encrypt(stringBuffer.toString().getBytes(), keyCrypter.deriveKey(PASSWORD2));
+        assertNotNull(data);
 
         try {
-            keyCrypter.decrypt(encryptedPrivateKey, keyCrypter.deriveKey(WRONG_PASSWORD));
+            keyCrypter.decrypt(data, keyCrypter.deriveKey(WRONG_PASSWORD));
             // TODO: This test sometimes fails due to relying on padding.
             fail("Decrypt with wrong password did not throw exception");
         } catch (KeyCrypterException ede) {

File: core/src/main/java/org/bitcoinj/core/AbstractBlockChain.java
Patch:
@@ -664,14 +664,15 @@ private void handleNewBestChain(StoredBlock storedPrev, StoredBlock newChainHead
             // Walk in ascending chronological order.
             for (Iterator<StoredBlock> it = newBlocks.descendingIterator(); it.hasNext();) {
                 cursor = it.next();
-                if (expensiveChecks && cursor.getHeader().getTimeSeconds() <= getMedianTimestampOfRecentBlocks(cursor.getPrev(blockStore), blockStore))
+                Block cursorBlock = cursor.getHeader();
+                if (expensiveChecks && cursorBlock.getTimeSeconds() <= getMedianTimestampOfRecentBlocks(cursor.getPrev(blockStore), blockStore))
                     throw new VerificationException("Block's timestamp is too early during reorg");
                 TransactionOutputChanges txOutChanges;
                 if (cursor != newChainHead || block == null)
                     txOutChanges = connectTransactions(cursor);
                 else
                     txOutChanges = connectTransactions(newChainHead.getHeight(), block);
-                storedNewHead = addToBlockStore(storedNewHead, cursor.getHeader(), txOutChanges);
+                storedNewHead = addToBlockStore(storedNewHead, cursorBlock.cloneAsHeader(), txOutChanges);
             }
         } else {
             // (Finally) write block to block store

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -619,7 +619,7 @@ protected void putUpdateStoredBlock(StoredBlock storedBlock, boolean wasUndoable
             s.setBytes(1, hashBytes);
             s.setBytes(2, storedBlock.getChainWork().toByteArray());
             s.setInt(3, storedBlock.getHeight());
-            s.setBytes(4, storedBlock.getHeader().unsafeBitcoinSerialize());
+            s.setBytes(4, storedBlock.getHeader().cloneAsHeader().unsafeBitcoinSerialize());
             s.setBoolean(5, wasUndoable);
             s.executeUpdate();
             s.close();

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4462,6 +4462,7 @@ public Map<String, WalletExtension> getExtensions() {
      */
     public void deserializeExtension(WalletExtension extension, byte[] data) throws Exception {
         lock.lock();
+        keychainLock.lock();
         try {
             // This method exists partly to establish a lock ordering of wallet > extension.
             extension.deserializeWalletExtension(this, data);
@@ -4471,6 +4472,7 @@ public void deserializeExtension(WalletExtension extension, byte[] data) throws
             extensions.remove(extension.getWalletExtensionID());
             Throwables.propagate(throwable);
         } finally {
+            keychainLock.unlock();
             lock.unlock();
         }
     }

File: examples/src/main/java/org/bitcoinj/examples/ExamplePaymentChannelServer.java
Patch:
@@ -42,7 +42,6 @@
 public class ExamplePaymentChannelServer implements PaymentChannelServerListener.HandlerFactory {
     private static final org.slf4j.Logger log = LoggerFactory.getLogger(ExamplePaymentChannelServer.class);
 
-    private StoredPaymentChannelServerStates storedStates;
     private WalletAppKit appKit;
 
     public static void main(String[] args) throws Exception {
@@ -88,6 +87,8 @@ public void channelOpen(Sha256Hash channelId) {
                 // Try to get the state object from the stored state set in our wallet
                 PaymentChannelServerState state = null;
                 try {
+                    StoredPaymentChannelServerStates storedStates = (StoredPaymentChannelServerStates)
+                            appKit.wallet().getExtensions().get(StoredPaymentChannelServerStates.class.getName());
                     state = storedStates.getChannel(channelId).getOrCreateState(appKit.wallet(), appKit.peerGroup());
                 } catch (VerificationException e) {
                     // This indicates corrupted data, and since the channel was just opened, cannot happen

File: core/src/test/java/org/bitcoinj/core/WalletTest.java
Patch:
@@ -2893,7 +2893,7 @@ public void completeTxPartiallySignedMarried(Wallet.MissingSigsMode missSigMode,
         assertTrue("Only one of the signatures should be missing/dummy", firstSigIsMissing ^ secondSigIsMissing);
         int localSigIndex = firstSigIsMissing ? 2 : 1;
         int length = input.getScriptSig().getChunks().get(localSigIndex).data.length;
-        assertTrue("Local sig should be present: " + length, length > 70);
+        assertTrue("Local sig should be present: " + length, length >= 70);
     }
 
 

File: core/src/main/java/org/bitcoinj/crypto/DeterministicKey.java
Patch:
@@ -88,7 +88,7 @@ public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
                             byte[] chainCode,
                             BigInteger priv,
                             @Nullable DeterministicKey parent) {
-        super(priv, compressPoint(ECKey.CURVE.getG().multiply(priv)));
+        super(priv, compressPoint(ECKey.publicPointFromPrivate(priv)));
         checkArgument(chainCode.length == 32);
         this.parent = parent;
         this.childNumberPath = checkNotNull(childNumberPath);
@@ -156,7 +156,7 @@ private DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
                             @Nullable DeterministicKey parent,
                             int depth,
                             int parentFingerprint) {
-        super(priv, compressPoint(ECKey.CURVE.getG().multiply(priv)));
+        super(priv, compressPoint(ECKey.publicPointFromPrivate(priv)));
         checkArgument(chainCode.length == 32);
         this.parent = parent;
         this.childNumberPath = checkNotNull(childNumberPath);

File: core/src/main/java/org/bitcoinj/core/UTXOProvider.java
Patch:
@@ -25,12 +25,12 @@
  */
 public interface UTXOProvider {
 
+    // TODO currently the access to outputs is by address. Change to ECKey
     /**
-     * // TODO currently the access to outputs is by address. Change to ECKey
      * Get the list of {@link UTXO}'s for a given address.
      * @param addresses List of address.
      * @return The list of transaction outputs.
-     * @throws UTXOProvider If there is an error.
+     * @throws UTXOProviderException If there is an error.
      */
     List<UTXO> getOpenTransactionOutputs(List<Address> addresses) throws UTXOProviderException;
 

File: core/src/main/java/org/bitcoinj/params/TestNet3Params.java
Patch:
@@ -85,7 +85,7 @@ public String getPaymentProtocolId() {
     @Override
     public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock,
         final BlockStore blockStore) throws VerificationException, BlockStoreException {
-        if (nextBlock.getTime().after(testnetDiffDate)) {
+        if (!isDifficultyTransitionPoint(storedPrev) && nextBlock.getTime().after(testnetDiffDate)) {
             Block prev = storedPrev.getHeader();
 
             // After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty

File: core/src/main/java/org/bitcoinj/core/FullPrunedBlockChain.java
Patch:
@@ -177,7 +177,7 @@ public VerificationException call() throws Exception {
     }
 
     /**
-     * Get the {@link Script} from the script bytes or null if it doesn't parse.
+     * Get the {@link Script} from the script bytes or return Script of empty byte array.
      */
     private Script getScript(byte[] scriptBytes) {
         try {

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -3977,7 +3977,7 @@ public void allowSpendingUnconfirmedTransactions() {
      *
      * @param vUTXOProvider The UTXO provider.
      */
-    public void setUTXOProvider(@Nullable FullPrunedBlockStore vUTXOProvider) {
+    public void setUTXOProvider(@Nullable UTXOProvider vUTXOProvider) {
         lock.lock();
         try {
             checkArgument(vUTXOProvider == null ? true : vUTXOProvider.getParams().equals(params));

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4006,7 +4006,7 @@ private class FreeStandingTransactionOutput extends TransactionOutput {
          * @param output The stored output (free standing).
          */
         public FreeStandingTransactionOutput(NetworkParameters params, UTXO output, int chainHeight) {
-            super(params, null, output.getValue(), output.getScriptBytes());
+            super(params, null, output.getValue(), output.getScript().getProgram());
             this.output = output;
             this.chainHeight = chainHeight;
         }

File: core/src/main/java/org/bitcoinj/net/BlockingClient.java
Patch:
@@ -100,7 +100,7 @@ public void run() {
                     }
                 } catch (Exception e) {
                     if (!vCloseRequested) {
-                        log.error("Error trying to open/read from connection: " + serverAddress, e);
+                        log.error("Error trying to open/read from connection: {}: {}", serverAddress, e.getMessage());
                         connectFuture.setException(e);
                     }
                 } finally {

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -148,7 +148,7 @@ protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest) {
     @GuardedBy("keychainLock") protected KeyChainGroup keychain;
 
     // A list of scripts watched by this wallet.
-    private Set<Script> watchedScripts;
+    @GuardedBy("keychainLock") private Set<Script> watchedScripts;
 
     protected final Context context;
     protected final NetworkParameters params;
@@ -2739,6 +2739,7 @@ public String toString() {
     public String toString(boolean includePrivateKeys, boolean includeTransactions, boolean includeExtensions,
                            @Nullable AbstractBlockChain chain) {
         lock.lock();
+        keychainLock.lock();
         try {
             StringBuilder builder = new StringBuilder();
             Coin estimatedBalance = getBalance(BalanceType.ESTIMATED);
@@ -2800,6 +2801,7 @@ public String toString(boolean includePrivateKeys, boolean includeTransactions,
             }
             return builder.toString();
         } finally {
+            keychainLock.unlock();
             lock.unlock();
         }
     }

File: core/src/main/java/org/bitcoinj/store/WalletProtobufSerializer.java
Patch:
@@ -519,10 +519,8 @@ private void loadExtensions(Wallet wallet, WalletExtension[] extensionsList, Pro
                     wallet.deserializeExtension(extension, extProto.getData().toByteArray());
                 } catch (Exception e) {
                     if (extProto.getMandatory() && requireMandatoryExtensions) {
-                        log.error("Error whilst reading extension {}, failing to read wallet", id, e);
+                        log.error("Error whilst reading mandatory extension {}, failing to read wallet", id);
                         throw new UnreadableWalletException("Could not parse mandatory extension in wallet: " + id);
-                    } else {
-                        log.error("Error whilst reading extension {}, ignoring", id, e);
                     }
                 }
             }

File: core/src/main/java/org/bitcoinj/wallet/CoinSelector.java
Patch:
@@ -6,7 +6,7 @@
 import java.util.List;
 
 /**
- * A CoinSelector is responsible for picking some outputs to spend, from the list of all spendable outputs. It
+ * A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs. It
  * allows you to customize the policies for creation of transactions to suit your needs. The select operation
  * may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
  * enough money in the wallet.

File: core/src/main/java/org/bitcoinj/kits/WalletAppKit.java
Patch:
@@ -238,14 +238,16 @@ protected void onSetupCompleted() { }
     /**
      * Tests to see if the spvchain file has an operating system file lock on it. Useful for checking if your app
      * is already running. If another copy of your app is running and you start the appkit anyway, an exception will
-     * be thrown during the startup process. Returns false if the chain file does not exist.
+     * be thrown during the startup process. Returns false if the chain file does not exist or is a directory.
      */
     public boolean isChainFileLocked() throws IOException {
         RandomAccessFile file2 = null;
         try {
             File file = new File(directory, filePrefix + ".spvchain");
             if (!file.exists())
                 return false;
+            if (file.isDirectory())
+                return false;
             file2 = new RandomAccessFile(file, "rw");
             FileLock lock = file2.getChannel().tryLock();
             if (lock == null)

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -1073,6 +1073,9 @@ private void processInv(InventoryMessage inv) {
             if (conf.numBroadcastPeers() > 1) {
                 // Some other peer already announced this so don't download.
                 it.remove();
+            } else if (conf.getSource().equals(TransactionConfidence.Source.SELF)) {
+                // We created this transaction ourselves, so don't download.
+                it.remove();
             } else {
                 log.debug("{}: getdata on tx {}", getAddress(), item.hash);
                 getdata.addItem(item);

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -64,6 +64,7 @@ public void tearDown() {
     public void fourPeers() throws Exception {
         InboundMessageQueuer[] channels = { connectPeer(1), connectPeer(2), connectPeer(3), connectPeer(4) };
         Transaction tx = new Transaction(params);
+        tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
         TransactionBroadcast broadcast = new TransactionBroadcast(peerGroup, tx);
         final AtomicDouble lastProgress = new AtomicDouble();
         broadcast.setProgressCallback(new TransactionBroadcast.ProgressCallback() {
@@ -92,10 +93,11 @@ public void onBroadcastProgress(double progress) {
         assertFalse(future.isDone());
         assertEquals(0.0, lastProgress.get(), 0.0);
         inbound(channels[1], InventoryMessage.with(tx));
-        pingAndWait(channels[1]);
         future.get();
         Threading.waitForUserCode();
         assertEquals(1.0, lastProgress.get(), 0.0);
+        // There is no response from the Peer as it has nothing to do.
+        assertNull(outbound(channels[1]));
     }
 
     @Test

File: core/src/main/java/org/bitcoinj/core/UTXOsMessage.java
Patch:
@@ -79,10 +79,11 @@ void bitcoinSerializeToStream(OutputStream stream) throws IOException {
         stream.write(new VarInt(hits.length).encode());
         stream.write(hits);
         stream.write(new VarInt(outputs.size()).encode());
-        for (TransactionOutput output : outputs) {
+        for (int i = 0; i < outputs.size(); i++) {
+            TransactionOutput output = outputs.get(i);
             Transaction tx = output.getParentTransaction();
             Utils.uint32ToByteStreamLE(tx != null ? tx.getVersion() : 0L, stream);  // Version
-            Utils.uint32ToByteStreamLE(height, stream);  // Height
+            Utils.uint32ToByteStreamLE(heights[i], stream);  // Height
             output.bitcoinSerializeToStream(stream);
         }
     }

File: core/src/main/java/org/bitcoinj/core/PeerSocketHandler.java
Patch:
@@ -140,6 +140,7 @@ public int receiveBytes(ByteBuffer buff) {
                         processMessage(serializer.deserializePayload(header, ByteBuffer.wrap(largeReadBuffer)));
                         largeReadBuffer = null;
                         header = null;
+                        firstMessage = false;
                     } else // ...or just returning if we don't have enough bytes yet
                         return buff.position();
                 }

File: core/src/main/java/org/bitcoinj/utils/ListenerRegistration.java
Patch:
@@ -33,6 +33,7 @@ public ListenerRegistration(T listener, Executor executor) {
         this.executor = checkNotNull(executor);
     }
 
+    /** Returns true if the listener was removed, else false. */
     public static <T> boolean removeFromList(T listener, List<? extends ListenerRegistration<T>> list) {
         checkNotNull(listener);
 

File: core/src/main/java/org/bitcoinj/core/BlockChain.java
Patch:
@@ -46,6 +46,7 @@ public class BlockChain extends AbstractBlockChain {
      */
     public BlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore) throws BlockStoreException {
         this(params, new ArrayList<BlockChainListener>(), blockStore);
+        Context.getOrCreate();
         if (wallet != null)
             addWallet(wallet);
     }

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -149,6 +149,7 @@ protected boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest) {
     // A list of scripts watched by this wallet.
     private Set<Script> watchedScripts;
 
+    protected final Context context;
     protected final NetworkParameters params;
 
     @Nullable private Sha256Hash lastBlockSeenHash;
@@ -246,6 +247,7 @@ public static Wallet fromKeys(NetworkParameters params, List<ECKey> keys) {
     // TODO: When this class moves to the Wallet package, along with the protobuf serializer, then hide this.
     /** For internal use only. */
     public Wallet(NetworkParameters params, KeyChainGroup keyChainGroup) {
+        this.context = Context.getOrCreate();
         this.params = checkNotNull(params);
         this.keychain = checkNotNull(keyChainGroup);
         if (params == UnitTestParams.get())

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -376,8 +376,7 @@ public void onTransaction(Peer peer, Transaction t) {
         // Peer 2 advertises the tx but does not receive it yet.
         inbound(p2, inv);
         assertTrue(outbound(p2) instanceof GetDataMessage);
-        assertEquals(0, tx.getConfidence().numBroadcastPeers());
-        assertTrue(Context.get().getConfidenceTable().maybeWasSeen(tx.getHash()));
+        assertEquals(1, tx.getConfidence().numBroadcastPeers());
         assertNull(event[0]);
         // Peer 1 advertises the tx, we don't do anything as it's already been requested.
         inbound(p1, inv);

File: core/src/main/java/org/bitcoinj/core/Context.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * The Context object holds various objects that are scoped to a specific instantiation of bitcoinj for a specific
- * network. You can get an instance of this class through {@link AbstractBlockChain#getContext()}. At the momemnt it
+ * network. You can get an instance of this class through calling {@link #get()}. At the moment it
  * only contains a {@link org.bitcoinj.core.TxConfidenceTable} but in future it will likely contain file paths and
  * other global configuration of use.
  */

File: core/src/main/java/org/bitcoinj/core/FullPrunedBlockChain.java
Patch:
@@ -21,7 +21,7 @@
 import org.bitcoinj.script.Script.VerifyFlag;
 import org.bitcoinj.store.BlockStoreException;
 import org.bitcoinj.store.FullPrunedBlockStore;
-import org.bitcoinj.utils.DaemonThreadFactory;
+import org.bitcoinj.utils.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -123,7 +123,7 @@ public void setRunScripts(boolean value) {
     
     // TODO: execute in order of largest transaction (by input count) first
     ExecutorService scriptVerificationExecutor = Executors.newFixedThreadPool(
-            Runtime.getRuntime().availableProcessors(), new DaemonThreadFactory());
+            Runtime.getRuntime().availableProcessors(), new ContextPropagatingThreadFactory("Script verification"));
 
     /** A job submitted to the executor which verifies signatures. */
     private static class Verifier implements Callable<VerificationException> {

File: core/src/main/java/org/bitcoinj/net/NioClientManager.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.base.Throwables;
 import com.google.common.util.concurrent.*;
+import org.bitcoinj.utils.*;
 import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
@@ -188,9 +189,7 @@ protected Executor executor() {
         return new Executor() {
             @Override
             public void execute(Runnable command) {
-                Thread thread = new Thread(command, "NioClientManager");
-                thread.setDaemon(true);
-                thread.start();
+                new ContextPropagatingThreadFactory("NioClientManager").newThread(command).start();
             }
         };
     }

File: core/src/main/java/org/bitcoinj/net/discovery/DnsDiscovery.java
Patch:
@@ -67,9 +67,9 @@ protected ExecutorService createExecutor() {
         // Attempted workaround for reported bugs on Linux in which gethostbyname does not appear to be properly
         // thread safe and can cause segfaults on some libc versions.
         if (System.getProperty("os.name").toLowerCase().contains("linux"))
-            return Executors.newSingleThreadExecutor(new DaemonThreadFactory());
+            return Executors.newSingleThreadExecutor(new ContextPropagatingThreadFactory("DNS seed lookups"));
         else
-            return Executors.newFixedThreadPool(seeds.size(), new DaemonThreadFactory());
+            return Executors.newFixedThreadPool(seeds.size(), new DaemonThreadFactory("DNS seed lookups"));
     }
 
     /** Implements discovery from a single DNS host. */

File: core/src/main/java/org/bitcoinj/net/discovery/MultiplexingDiscovery.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.common.collect.Lists;
 import org.bitcoinj.core.NetworkParameters;
-import org.bitcoinj.utils.DaemonThreadFactory;
+import org.bitcoinj.utils.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -94,7 +94,7 @@ public InetSocketAddress[] call() throws Exception {
     }
 
     protected ExecutorService createExecutor() {
-        return Executors.newFixedThreadPool(seeds.size(), new DaemonThreadFactory());
+        return Executors.newFixedThreadPool(seeds.size(), new ContextPropagatingThreadFactory("Multiplexing discovery"));
     }
 
     @Override

File: core/src/main/java/org/bitcoinj/testing/TestWithNetworkConnections.java
Patch:
@@ -81,6 +81,7 @@ public void setUp(BlockStore blockStore) throws Exception {
         BriefLogFormatter.init();
 
         unitTestParams = UnitTestParams.get();
+        new Context();
         Wallet.SendRequest.DEFAULT_FEE_PER_KB = Coin.ZERO;
         this.blockStore = blockStore;
         // Allow subclasses to override the wallet object with their own.

File: core/src/main/java/org/bitcoinj/testing/TestWithPeerGroup.java
Patch:
@@ -25,7 +25,7 @@
 import org.bitcoinj.store.BlockStore;
 import org.bitcoinj.store.MemoryBlockStore;
 import com.google.common.base.Preconditions;
-import org.bitcoinj.utils.DaemonThreadFactory;
+import org.bitcoinj.utils.*;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.*;
@@ -98,7 +98,7 @@ private PeerGroup createPeerGroup(final ClientConnectionManager manager) {
         return new PeerGroup(unitTestParams, blockChain, manager) {
             @Override
             protected ListeningScheduledExecutorService createPrivateExecutor() {
-                return MoreExecutors.listeningDecorator(new ScheduledThreadPoolExecutor(1, new DaemonThreadFactory("PeerGroup test thread")) {
+                return MoreExecutors.listeningDecorator(new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory("PeerGroup test thread")) {
                     @Override
                     public ScheduledFuture<?> schedule(final Runnable command, final long delay, final TimeUnit unit) {
                         if (!blockJobs)

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -377,7 +377,7 @@ public void onTransaction(Peer peer, Transaction t) {
         inbound(p2, inv);
         assertTrue(outbound(p2) instanceof GetDataMessage);
         assertEquals(0, tx.getConfidence().numBroadcastPeers());
-        assertTrue(blockChain.getContext().getConfidenceTable().maybeWasSeen(tx.getHash()));
+        assertTrue(Context.get().getConfidenceTable().maybeWasSeen(tx.getHash()));
         assertNull(event[0]);
         // Peer 1 advertises the tx, we don't do anything as it's already been requested.
         inbound(p1, inv);

File: core/src/test/java/org/bitcoinj/core/PeerTest.java
Patch:
@@ -78,7 +78,7 @@ public PeerTest(ClientType clientType) {
     public void setUp() throws Exception {
         super.setUp();
 
-        confidenceTable = blockChain.getContext().getConfidenceTable();
+        confidenceTable = Context.get().getConfidenceTable();
         VersionMessage ver = new VersionMessage(unitTestParams, 100);
         InetSocketAddress address = new InetSocketAddress("127.0.0.1", 4000);
         peer = new Peer(unitTestParams, ver, new PeerAddress(address), blockChain);
@@ -601,7 +601,6 @@ public void onTransaction(Peer peer1, Transaction t) {
         assertEquals(t3.getHash(), getdata.getItems().get(1).hash);
         assertEquals(someHash, getdata.getItems().get(2).hash);
         assertEquals(anotherHash, getdata.getItems().get(3).hash);
-        long nonce = -1;
         // For some random reason, t4 is delivered at this point before it's needed - perhaps it was a Bloom filter
         // false positive. We do this to check that the mempool is being checked for seen transactions before
         // requesting them.

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -1216,17 +1216,15 @@ public ListenableFuture<AddressMessage> getAddr() {
     public void setDownloadParameters(long secondsSinceEpoch, boolean useFilteredBlocks) {
         lock.lock();
         try {
-            Preconditions.checkNotNull(blockChain);
             if (secondsSinceEpoch == 0) {
                 fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();
                 downloadBlockBodies = true;
             } else {
                 fastCatchupTimeSecs = secondsSinceEpoch;
                 // If the given time is before the current chains head block time, then this has no effect (we already
                 // downloaded everything we need).
-                if (fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds()) {
+                if (blockChain != null && fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds())
                     downloadBlockBodies = false;
-                }
             }
             this.useFilteredBlocks = useFilteredBlocks;
         } finally {

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -88,13 +88,15 @@ public void onFailure(Throwable t) {
     private void askForPasswordAndRetry() {
         Main.OverlayUI<WalletPasswordController> pwd = Main.instance.overlayUI("wallet_password.fxml");
         final String addressStr = address.getText();
+        final String amountStr = amountEdit.getText();
         pwd.controller.aesKeyProperty().addListener((observable, old, cur) -> {
             // We only get here if the user found the right password. If they don't or they cancel, we end up back on
             // the main UI screen. By now the send money screen is history so we must recreate it.
             checkGuiThread();
             Main.OverlayUI<SendMoneyController> screen = Main.instance.overlayUI("send_money.fxml");
             screen.controller.aesKey = cur;
             screen.controller.address.setText(addressStr);
+            screen.controller.amountEdit.setText(amountStr);
             screen.controller.send(null);
         });
     }

File: core/src/main/java/org/bitcoinj/store/FullPrunedBlockStore.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * <p>An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.</p>
  * 
- * <p>In addition to keeping tack of a chain using {@link StoredBlock}s, it should also keep track of a second
+ * <p>In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of a second
  * copy of the chain which holds {@link StoredUndoableBlock}s. In this way, an application can perform a
  * headers-only initial sync and then use that information to more efficiently download a locally verified
  * full copy of the block chain.</p>

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -486,9 +486,10 @@ public void downloadPeerSelection() throws Exception {
         assertEquals(a, peerGroup.getDownloadPeer());  // No change yet.
         connectPeer(4, versionMessage3);
         assertEquals(3, peerGroup.getMostCommonChainHeight());
-        assertEquals(c, peerGroup.getDownloadPeer());  // Switch to first peer advertising new height.
+        assertEquals(a, peerGroup.getDownloadPeer());  // Still no change.
+
         // New peer with a higher protocol version but same chain height.
-        //TODO: When PeerGroup.selectDownloadPeer.PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion,
+        // TODO: When PeerGroup.selectDownloadPeer.PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion,
         // reenable this test
         /*VersionMessage versionMessage4 = new VersionMessage(params, 3);
         versionMessage4.clientVersion = 100000;

File: core/src/test/java/org/bitcoinj/core/WalletTest.java
Patch:
@@ -3092,15 +3092,15 @@ public void sendRequestMemo() throws Exception {
 
     @Test(expected = java.lang.IllegalStateException.class)
     public void sendCoinsNoBroadcasterTest() throws InsufficientMoneyException {
-        ECKey key = ECKey.fromPrivate(BigInteger.ONE);
+        ECKey key = ECKey.fromPrivate(BigInteger.TEN);
         Address notMyAddr = key.toAddress(params);
         SendRequest req = SendRequest.to(notMyAddr.getParameters(), key, SATOSHI.multiply(12));
         wallet.sendCoins(req);
     }
 
     @Test
     public void sendCoinsWithBroadcasterTest() throws InsufficientMoneyException {
-        ECKey key = ECKey.fromPrivate(BigInteger.ONE);
+        ECKey key = ECKey.fromPrivate(BigInteger.TEN);
         Address notMyAddr = key.toAddress(params);
         receiveATransactionAmount(wallet, myAddress, Coin.COIN);
         MockTransactionBroadcaster broadcaster = new MockTransactionBroadcaster(wallet);

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -1434,6 +1434,7 @@ protected void handlePeerDeath(final Peer peer, @Nullable Throwable exception) {
                     ipv6Unreachable = true;
                     log.warn("IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on");
                 }
+            } else {
                 backoffMap.get(address).trackFailure();
                 // Put back on inactive list
                 inactives.offer(address);

File: core/src/main/java/org/bitcoinj/core/PeerEventListener.java
Patch:
@@ -65,7 +65,8 @@ public interface PeerEventListener {
     /**
      * Called when a peer is disconnected. Note that this won't be called if the listener is registered on a
      * {@link PeerGroup} and the group is in the process of shutting down. If this listener is registered to a
-     * {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0.
+     * {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0. This handler can be called without
+     * a corresponding invocation of onPeerConnected if the initial connection is never successful.
      *
      * @param peer
      * @param peerCount the total number of connected peers

File: core/src/main/java/org/bitcoinj/net/ClientConnectionManager.java
Patch:
@@ -30,7 +30,8 @@
  */
 public interface ClientConnectionManager extends Service {
     /**
-     * Creates a new connection to the given address, with the given parser used to handle incoming data.
+     * Creates a new connection to the given address, with the given parser used to handle incoming data. Any errors
+     * that occur during connection will be returned in the given future, including errors that can occur immediately.
      */
     ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamParser parser);
 

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -239,7 +239,7 @@ public void receiveTxBroadcast() throws Exception {
 
     
     @Test
-    public void receiveTxBroadcastOnAddeweldWallet() throws Exception {
+    public void receiveTxBroadcastOnAddedWallet() throws Exception {
         // Check that when we receive transactions on all our peers, we do the right thing.
         peerGroup.start();
 

File: tools/src/main/java/org/bitcoinj/tools/WatchMempool.java
Patch:
@@ -27,7 +27,7 @@
 public class WatchMempool {
     private static Logger log = LoggerFactory.getLogger(WatchMempool.class);
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws InterruptedException {
         BriefLogFormatter.init();
         NetworkParameters params = MainNetParams.get();
         PeerGroup peerGroup = new PeerGroup(params);
@@ -44,6 +44,7 @@ public void onTransaction(Peer peer, Transaction tx) {
                 }
             }
         });
-        peerGroup.startAsync();
+        peerGroup.start();
+        Thread.sleep(Long.MAX_VALUE);
     }
 }

File: core/src/main/java/org/bitcoinj/core/Peer.java
Patch:
@@ -89,7 +89,7 @@ public PeerListenerRegistration(PeerEventListener listener, Executor executor, b
     private final AtomicInteger blocksAnnounced = new AtomicInteger();
     // A class that tracks recent transactions that have been broadcast across the network, counts how many
     // peers announced them and updates the transaction confidence data. It is passed to each Peer.
-    private final TxConfidenceTable confidenceTable;
+    @Nullable private final TxConfidenceTable confidenceTable;
     // Each wallet added to the peer will be notified of downloaded transaction data.
     private final CopyOnWriteArrayList<Wallet> wallets;
     // A time before which we only download block headers, after that point we download block bodies.
@@ -203,7 +203,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
         super(params, remoteAddress);
         this.params = Preconditions.checkNotNull(params);
         this.versionMessage = Preconditions.checkNotNull(ver);
-        this.vDownloadTxDependencies = downloadTxDependencies;
+        this.vDownloadTxDependencies = chain != null && downloadTxDependencies;
         this.blockChain = chain;  // Allowed to be null.
         this.vDownloadData = chain != null;
         this.getDataFutures = new CopyOnWriteArrayList<GetDataRequest>();
@@ -213,7 +213,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
         this.isAcked = false;
         this.pendingPings = new CopyOnWriteArrayList<PendingPing>();
         this.wallets = new CopyOnWriteArrayList<Wallet>();
-        this.confidenceTable = chain.getContext().getConfidenceTable();
+        this.confidenceTable = chain != null ? chain.getContext().getConfidenceTable() : null;
     }
 
     /**

File: core/src/main/java/org/bitcoinj/store/DatabaseFullPrunedBlockStore.java
Patch:
@@ -503,9 +503,8 @@ private void checkCompatibility() throws SQLException, BlockStoreException {
                 ResultSet results = ps.executeQuery();
                 results.close();
             } catch (SQLException ex) {
-                String message = "Database block store is not compatible with the current release.  " +
-                        "See bitcoinj release notes for further information.";
-                throw new BlockStoreException(message);
+                throw new BlockStoreException("Database block store is not compatible with the current release.  " +
+                        "See bitcoinj release notes for further information: " + ex.getMessage());
             } finally {
                 if (ps != null && !ps.isClosed()) {
                     ps.close();

File: core/src/test/java/org/bitcoinj/core/TransactionBroadcastTest.java
Patch:
@@ -72,7 +72,7 @@ public void tearDown() {
     public void fourPeers() throws Exception {
         InboundMessageQueuer[] channels = { connectPeer(1), connectPeer(2), connectPeer(3), connectPeer(4) };
         Transaction tx = new Transaction(params);
-        TransactionBroadcast broadcast = new TransactionBroadcast(peerGroup, tx);
+        TransactionBroadcast broadcast = new TransactionBroadcast(peerGroup, blockChain.getContext(), tx);
         ListenableFuture<Transaction> future = broadcast.broadcast();
         assertFalse(future.isDone());
         // We expect two peers to receive a tx message, and at least one of the others must announce for the future to

File: core/src/test/java/org/bitcoinj/core/PeerGroupTest.java
Patch:
@@ -376,7 +376,7 @@ public void onTransaction(Peer peer, Transaction t) {
         inbound(p2, inv);
         assertTrue(outbound(p2) instanceof GetDataMessage);
         assertEquals(0, tx.getConfidence().numBroadcastPeers());
-        assertTrue(peerGroup.getConfidenceTable().maybeWasSeen(tx.getHash()));
+        assertTrue(blockChain.getContext().getConfidenceTable().maybeWasSeen(tx.getHash()));
         assertNull(event[0]);
         // Peer 1 advertises the tx, we don't do anything as it's already been requested.
         inbound(p1, inv);

File: tools/src/main/java/org/bitcoinj/tools/WalletTool.java
Patch:
@@ -86,7 +86,7 @@ public class WalletTool {
 
     private static OptionSet options;
     private static OptionSpec<Date> dateFlag;
-    private static OptionSpec<Integer> unixtimeFlag;
+    private static OptionSpec<Long> unixtimeFlag;
     private static OptionSpec<String> seedFlag, watchFlag;
     private static OptionSpec<String> xpubkeysFlag;
 
@@ -218,7 +218,7 @@ public static void main(String[] args) throws Exception {
         OptionSpec<String> outputFlag = parser.accepts("output").withRequiredArg();
         parser.accepts("value").withRequiredArg();
         parser.accepts("fee").withRequiredArg();
-        unixtimeFlag = parser.accepts("unixtime").withRequiredArg().ofType(Integer.class);
+        unixtimeFlag = parser.accepts("unixtime").withRequiredArg().ofType(Long.class);
         OptionSpec<String> conditionFlag = parser.accepts("condition").withRequiredArg();
         parser.accepts("locktime").withRequiredArg();
         parser.accepts("allow-unconfirmed");

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4227,7 +4227,7 @@ public void deserializeExtension(WalletExtension extension, byte[] data) throws
     }
 
     @Override
-    public synchronized void setTag(String tag, ByteString value) {
+    public void setTag(String tag, ByteString value) {
         super.setTag(tag, value);
         saveNow();
     }

File: core/src/main/java/org/bitcoinj/wallet/DefaultCoinSelector.java
Patch:
@@ -20,7 +20,7 @@ public class DefaultCoinSelector implements CoinSelector {
     @Override
     public CoinSelection select(Coin biTarget, List<TransactionOutput> candidates) {
         long target = biTarget.value;
-        HashSet<TransactionOutput> selected = new HashSet<TransactionOutput>();
+        ArrayList<TransactionOutput> selected = new ArrayList<TransactionOutput>();
         // Sort the inputs by age*value so we get the highest "coindays" spent.
         // TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
         ArrayList<TransactionOutput> sortedOutputs = new ArrayList<TransactionOutput>(candidates);

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4459,13 +4459,13 @@ private List<Transaction> maybeRotateKeys(@Nullable KeyParameter aesKey, boolean
         checkState(keychainLock.isHeldByCurrentThread());
         List<Transaction> results = Lists.newLinkedList();
         // TODO: Handle chain replays here.
-        long keyRotationTimestamp = vKeyRotationTimestamp;
+        final long keyRotationTimestamp = vKeyRotationTimestamp;
         if (keyRotationTimestamp == 0) return results;  // Nothing to do.
 
         // We might have to create a new HD hierarchy if the previous ones are now rotating.
         boolean allChainsRotating = true;
         for (DeterministicKeyChain chain : keychain.getDeterministicKeyChains()) {
-            if (chain.getEarliestKeyCreationTime() >= vKeyRotationTimestamp) {
+            if (chain.getEarliestKeyCreationTime() >= keyRotationTimestamp) {
                 allChainsRotating = false;
                 break;
             }

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -1043,12 +1043,12 @@ Block createNextBlock(@Nullable Address to, @Nullable TransactionOutPoint prevOu
 
     @VisibleForTesting
     public Block createNextBlock(@Nullable Address to, TransactionOutPoint prevOut) {
-        return createNextBlock(to, prevOut, Utils.currentTimeSeconds(), pubkeyForTesting, FIFTY_COINS);
+        return createNextBlock(to, prevOut, getTimeSeconds() + 5, pubkeyForTesting, FIFTY_COINS);
     }
 
     @VisibleForTesting
     public Block createNextBlock(@Nullable Address to, Coin value) {
-        return createNextBlock(to, null, Utils.currentTimeSeconds(), pubkeyForTesting, value);
+        return createNextBlock(to, null, getTimeSeconds() + 5, pubkeyForTesting, value);
     }
 
     @VisibleForTesting

File: core/src/main/java/org/bitcoinj/core/Block.java
Patch:
@@ -1,5 +1,6 @@
 /**
  * Copyright 2011 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -588,7 +589,7 @@ public String toString() {
         s.append("   time: [");
         s.append(time);
         s.append("] ");
-        s.append(new Date(time * 1000));
+        s.append(Utils.dateTimeFormat(time * 1000));
         s.append("\n");
         s.append("   difficulty target (nBits): ");
         s.append(difficultyTarget);

File: core/src/main/java/org/bitcoinj/core/DownloadListener.java
Patch:
@@ -1,5 +1,6 @@
 /**
  * Copyright 2011 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +20,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.text.DateFormat;
 import java.util.Date;
 import java.util.concurrent.Semaphore;
 
@@ -80,8 +80,8 @@ public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {
      * @param date the date of the last block downloaded
      */
     protected void progress(double pct, int blocksSoFar, Date date) {
-        log.info(String.format("Chain download %d%% done with %d blocks to go, block date %s", (int) pct,
-                blocksSoFar, DateFormat.getDateTimeInstance().format(date)));
+        log.info(String.format("Chain download %d%% done with %d blocks to go, block date %s", (int) pct, blocksSoFar,
+                Utils.dateTimeFormat(date)));
     }
 
     /**

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2013 The bitcoinj developers.
+ * Copyright 2014 The bitcoinj developers.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1277,7 +1277,8 @@ public String toString(boolean includePrivateKeys, NetworkParameters params) {
                                 seed.toHexString())
                 );
             }
-            builder2.append(String.format("Seed birthday: %d  [%s]%n", seed.getCreationTimeSeconds(), new Date(seed.getCreationTimeSeconds() * 1000)));
+            builder2.append(String.format("Seed birthday: %d  [%s]%n", seed.getCreationTimeSeconds(),
+                    Utils.dateTimeFormat(seed.getCreationTimeSeconds() * 1000)));
         }
         final DeterministicKey watchingKey = getWatchingKey();
         // Don't show if it's been imported from a watching wallet already, because it'd result in a weird/

File: core/src/test/java/org/bitcoinj/core/BitcoindComparisonTool.java
Patch:
@@ -210,7 +210,7 @@ public Message onPreMessageReceived(Peer peer, Message m) {
         bitcoindChainHead = params.getGenesisBlock().getHash();
         
         // bitcoind MUST be on localhost or we will get banned as a DoSer
-        new NioClient(new InetSocketAddress(InetAddress.getLoopbackAddress(), args.length > 2 ? Integer.parseInt(args[2]) : params.getPort()), bitcoind, 1000);
+        new NioClient(new InetSocketAddress(InetAddress.getLocalHost(), args.length > 2 ? Integer.parseInt(args[2]) : params.getPort()), bitcoind, 1000);
 
         connectedFuture.get();
 

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4522,7 +4522,8 @@ private Transaction rekeyOneBatch(long timeSecs, @Nullable KeyParameter aesKey,
             for (TransactionOutput output : toMove.gathered) {
                 rekeyTx.addInput(output);
             }
-            rekeyTx.addOutput(toMove.valueGathered, freshReceiveAddress());
+            // When not signing, don't waste addresses.
+            rekeyTx.addOutput(toMove.valueGathered, sign ? freshReceiveAddress() : currentReceiveAddress());
             if (!adjustOutputDownwardsForFee(rekeyTx, toMove, Coin.ZERO, Transaction.REFERENCE_DEFAULT_MIN_TX_FEE)) {
                 log.error("Failed to adjust rekey tx for fees.");
                 return null;

File: core/src/test/java/org/bitcoinj/core/BitcoindComparisonTool.java
Patch:
@@ -287,6 +287,8 @@ public void endBloomFilterCalculation() {
                     differingBlocks++;
                     log.error("bitcoind and bitcoinj acceptance differs on block \"" + block.ruleName + "\"");
                 }
+                if (block.sendOnce)
+                    preloadedBlocks.remove(nextBlock.getHash());
                 log.info("Block \"" + block.ruleName + "\" completed processing");
             } else if (rule instanceof MemoryPoolState) {
                 MemoryPoolMessage message = new MemoryPoolMessage();

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -1632,7 +1632,7 @@ public boolean add(Rule element) {
                 new TransactionOutPoint(params, 0, b1001.getTransactions().get(0).getHash()),
                 b1001.getTransactions().get(0).getOutputs().get(0).getValue(),
                 b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
-        int nextHeight = chainHeadHeight + 31;
+        int heightAfter1001 = chainHeadHeight + 31;
         
         if (runLargeReorgs) {
             // No way you can fit this test in memory
@@ -1641,6 +1641,7 @@ public boolean add(Rule element) {
             Block lastBlock = b1001;
             TransactionOutPoint lastOutput = new TransactionOutPoint(params, 2, b1001.getTransactions().get(1).getHash());
             int blockCountAfter1001;
+            int nextHeight = heightAfter1001;
             
             List<Sha256Hash> hashesToSpend = new LinkedList<Sha256Hash>(); // all index 0
             final int TRANSACTION_CREATION_BLOCKS = 100;
@@ -1679,7 +1680,7 @@ public boolean add(Rule element) {
             // Reorg back to b1001 + empty blocks
             Sha256Hash firstHash = lastBlock.getHash();
             int height = nextHeight-1;
-            nextHeight = chainHeadHeight + 26;
+            nextHeight = heightAfter1001;
             lastBlock = b1001;
             for (int i = 0; i < blockCountAfter1001; i++) {
                 Block block = createNextBlock(lastBlock, nextHeight++, null, null);

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -1039,7 +1039,9 @@ public boolean add(Rule element) {
         
         // Block with invalid merkle hash
         Block b49 = createNextBlock(b44, chainHeadHeight + 16, out15, null);
-        b49.setMerkleRoot(Sha256Hash.ZERO_HASH);
+        byte[] b49MerkleHash = Sha256Hash.ZERO_HASH.getBytes().clone();
+        b49MerkleHash[1] = (byte) 0xDE;
+        b49.setMerkleRoot(Sha256Hash.create(b49MerkleHash));
         b49.solve();
         blocks.add(new BlockAndValidity(blockToHeightMap, hashHeaderMap, b49, false, true, b44.getHash(), chainHeadHeight + 15, "b49"));
         

File: core/src/test/java/org/bitcoinj/core/FullBlockTestGenerator.java
Patch:
@@ -53,6 +53,7 @@ class Rule {
  */
 class BlockAndValidity extends Rule {
     Block block;
+    Sha256Hash blockHash;
     boolean connects;
     boolean throwsException;
     Sha256Hash hashChainTipAfterBlock;
@@ -64,6 +65,7 @@ public BlockAndValidity(Map<Sha256Hash, Integer> blockToHeightMap, Map<Sha256Has
         if (connects && throwsException)
             throw new RuntimeException("A block cannot connect if an exception was thrown while adding it.");
         this.block = block;
+        this.blockHash = block.getHash();
         this.connects = connects;
         this.throwsException = throwsException;
         this.hashChainTipAfterBlock = hashChainTipAfterBlock;

File: core/src/main/java/org/bitcoinj/script/ScriptChunk.java
Patch:
@@ -81,6 +81,8 @@ public int decodeOpN() {
      */
     public boolean isShortestPossiblePushData() {
         checkState(isPushData());
+        if (data == null)
+            return true;   // OP_N
         if (data.length == 0)
             return opcode == OP_0;
         if (data.length == 1) {

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -648,11 +648,11 @@ public void addAndActivateHDChain(DeterministicKeyChain chain) {
 
     /** See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. */
     public void setKeychainLookaheadSize(int lookaheadSize) {
-        lock.lock();
+        keychainLock.lock();
         try {
             keychain.setLookaheadSize(lookaheadSize);
         } finally {
-            lock.unlock();
+            keychainLock.unlock();
         }
     }
 

File: core/src/main/java/org/bitcoinj/store/PostgresFullPrunedBlockStore.java
Patch:
@@ -167,7 +167,7 @@ protected String getDatabaseDriverClass() {
     @Override
     public void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock) throws BlockStoreException {
         maybeConnect();
-        // We skip the first 4 bytes because (on prodnet) the minimum target has 4 0-bytes
+        // We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes
         byte[] hashBytes = new byte[28];
         System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
         int height = storedBlock.getHeight();

File: core/src/test/java/org/bitcoinj/core/AbstractFullPrunedBlockChainTest.java
Patch:
@@ -44,9 +44,9 @@ public abstract class AbstractFullPrunedBlockChainTest
 {
     private static final Logger log = LoggerFactory.getLogger(AbstractFullPrunedBlockChainTest.class);
 
-    private NetworkParameters params;
-    private FullPrunedBlockChain chain;
-    private FullPrunedBlockStore store;
+    protected NetworkParameters params;
+    protected FullPrunedBlockChain chain;
+    protected FullPrunedBlockStore store;
 
     @Before
     public void setUp() throws Exception {

File: core/src/main/java/org/bitcoinj/store/WalletProtobufSerializer.java
Patch:
@@ -513,7 +513,7 @@ private void loadExtensions(Wallet wallet, WalletExtension[] extensionsList, Pro
             } else {
                 log.info("Loading wallet extension {}", id);
                 try {
-                    wallet.deserializeAndAddExtension(extension, extProto.getData().toByteArray());
+                    wallet.deserializeExtension(extension, extProto.getData().toByteArray());
                 } catch (Exception e) {
                     if (extProto.getMandatory() && requireMandatoryExtensions) {
                         log.error("Error whilst reading extension {}, failing to read wallet", id, e);

File: core/src/main/java/org/bitcoinj/core/TransactionOutput.java
Patch:
@@ -253,7 +253,7 @@ public Coin getMinNonDustValue(Coin feePerKbRequired) {
 
     /**
      * Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
-     * and mined by default miners. For normal pay to address outputs, this is 5460 satoshis, the same as
+     * and mined by default miners. For normal pay to address outputs, this is 546 satoshis, the same as
      * {@link Transaction#MIN_NONDUST_OUTPUT}.
      */
     public Coin getMinNonDustValue() {

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -939,6 +939,9 @@ private void markKeysAsUsed(Transaction tx) {
                     } else if (script.isSentToAddress()) {
                         byte[] pubkeyHash = script.getPubKeyHash();
                         keychain.markPubKeyHashAsUsed(pubkeyHash);
+                    } else if (script.isPayToScriptHash() && keychain.isMarried()) {
+                        Address a = Address.fromP2SHScript(tx.getParams(), script);
+                        keychain.markP2SHAddressAsUsed(a);
                     }
                 } catch (ScriptException e) {
                     // Just means we didn't understand the output of this transaction: ignore it.

File: core/src/main/java/org/bitcoinj/script/ScriptChunk.java
Patch:
@@ -87,7 +87,7 @@ public boolean isShortestPossiblePushData() {
             byte b = data[0];
             if (b >= 0x01 && b <= 0x10)
                 return opcode == OP_1 + b - 1;
-            if (b == 0x81)
+            if ((b & 0xFF) == 0x81)
                 return opcode == OP_1NEGATE;
         }
         if (data.length < OP_PUSHDATA1)
@@ -106,7 +106,6 @@ public void write(OutputStream stream) throws IOException {
             checkState(data == null);
             stream.write(opcode);
         } else if (data != null) {
-            checkNotNull(data);
             if (opcode < OP_PUSHDATA1) {
                 checkState(data.length == opcode);
                 stream.write(opcode);

File: core/src/main/java/org/bitcoinj/testing/TestWithPeerGroup.java
Patch:
@@ -80,6 +80,7 @@ protected void initPeerGroup() {
             peerGroup = new PeerGroup(unitTestParams, blockChain, new BlockingClientManager());
         peerGroup.setPingIntervalMsec(0);  // Disable the pings as they just get in the way of most tests.
         peerGroup.addWallet(wallet);
+        peerGroup.setUseLocalhostPeerWhenPossible(false); // Prevents from connecting to bitcoin nodes on localhost.
     }
 
     protected InboundMessageQueuer connectPeerWithoutVersionExchange(int id) throws Exception {

File: core/src/test/java/org/bitcoinj/core/FilteredBlockAndPartialMerkleTreeTests.java
Patch:
@@ -141,6 +141,8 @@ public void serializeDownloadBlockWithWallet() throws Exception {
         super.setUp(blockStore);
         
         peerGroup.addWallet(wallet);
+        peerGroup.setUseLocalhostPeerWhenPossible(false); // Prevents from connecting to bitcoin nodes on localhost.
+
         blockChain.addWallet(wallet);
 
         peerGroup.startAsync();

File: core/src/main/java/org/bitcoinj/core/Transaction.java
Patch:
@@ -379,7 +379,7 @@ public Coin getValueSentFromMe(TransactionBag wallet) throws ScriptException {
     }
 
     /**
-     * Returns the difference of {@link Transaction#getValueSentFromMe(TransactionBag)} and {@link Transaction#getValueSentToMe(TransactionBag)}.
+     * Returns the difference of {@link Transaction#getValueSentToMe(TransactionBag)} and {@link Transaction#getValueSentFromMe(TransactionBag)}.
      */
     public Coin getValue(TransactionBag wallet) throws ScriptException {
         return getValueSentToMe(wallet).subtract(getValueSentFromMe(wallet));

File: core/src/main/java/org/bitcoinj/core/AbstractWalletEventListener.java
Patch:
@@ -51,7 +51,7 @@ public void onKeysAdded(List<ECKey> keys) {
     }
 
     @Override
-    public void onScriptsAdded(Wallet wallet, List<Script> scripts) {
+    public void onScriptsChanged(Wallet wallet, List<Script> scripts, boolean isAddingScripts) {
         onChange();
     }
 

File: core/src/main/java/org/bitcoinj/core/PeerGroup.java
Patch:
@@ -190,7 +190,7 @@ private synchronized void queueRecalc(boolean andTransmit) {
             }
         }
 
-        @Override public void onScriptsAdded(Wallet wallet, List<Script> scripts) {
+        @Override public void onScriptsChanged(Wallet wallet, List<Script> scripts, boolean isAddingScripts) {
             queueRecalc(true);
         }
 

File: core/src/main/java/org/bitcoinj/jni/NativeWalletEventListener.java
Patch:
@@ -52,5 +52,5 @@ public class NativeWalletEventListener implements WalletEventListener {
     public native void onKeysAdded(List<ECKey> keys);
 
     @Override
-    public native void onScriptsAdded(Wallet wallet, List<Script> scripts);
+    public native void onScriptsChanged(Wallet wallet, List<Script> scripts, boolean isAddingScripts);
 }

File: examples/src/main/java/org/bitcoinj/examples/Kit.java
Patch:
@@ -91,7 +91,7 @@ public void onKeysAdded(List<ECKey> keys) {
         }
 
         @Override
-        public void onScriptsAdded(Wallet wallet, List<Script> scripts) {
+        public void onScriptsChanged(Wallet wallet, List<Script> scripts, boolean isAddingScripts) {
             System.out.println("new script added");
         }
     }

File: core/src/main/java/org/bitcoinj/wallet/MarriedKeyChain.java
Patch:
@@ -97,9 +97,9 @@ public MarriedKeyChain build() {
             if (threshold == 0)
                 threshold = (followingKeys.size() + 1) / 2 + 1;
             if (random != null) {
-                chain = new MarriedKeyChain(random, bits, passphrase, seedCreationTimeSecs);
+                chain = new MarriedKeyChain(random, bits, getPassphrase(), seedCreationTimeSecs);
             } else if (entropy != null) {
-                chain = new MarriedKeyChain(entropy, passphrase, seedCreationTimeSecs);
+                chain = new MarriedKeyChain(entropy, getPassphrase(), seedCreationTimeSecs);
             } else {
                 chain = new MarriedKeyChain(seed);
             }

File: core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
Patch:
@@ -151,7 +151,7 @@ public static RuleViolation isStandard(Transaction tx) {
      * Checks the output to see if the script violates a standardness rule. Not complete.
      */
     public static RuleViolation isOutputStandard(TransactionOutput output) {
-        if (MIN_ANALYSIS_NONDUST_OUTPUT.compareTo(output.getValue()) > 0)
+        if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) < 0)
             return RuleViolation.DUST;
         for (ScriptChunk chunk : output.getScriptPubKey().getChunks()) {
             if (chunk.isPushData() && !chunk.isShortestPossiblePushData())

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -4363,7 +4363,7 @@ private List<Transaction> maybeRotateKeys(@Nullable KeyParameter aesKey, boolean
         // We might have to create a new HD hierarchy if the previous ones are now rotating.
         boolean allChainsRotating = true;
         for (DeterministicKeyChain chain : keychain.getDeterministicKeyChains()) {
-            if (chain.getEarliestKeyCreationTime() > vKeyRotationTimestamp) {
+            if (chain.getEarliestKeyCreationTime() >= vKeyRotationTimestamp) {
                 allChainsRotating = false;
                 break;
             }

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -68,7 +68,7 @@ public class KeyChainGroup implements KeyBag {
 
     private BasicKeyChain basic;
     private NetworkParameters params;
-    private final LinkedList<DeterministicKeyChain> chains;
+    protected final LinkedList<DeterministicKeyChain> chains;
     private final EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys;
 
     private EnumMap<KeyChain.KeyPurpose, Address> currentAddresses;

File: core/src/main/java/org/bitcoinj/wallet/DeterministicKeyChain.java
Patch:
@@ -1186,8 +1186,8 @@ public DeterministicSeed getSeed() {
                 DeterministicKey parent = detkey.getParent();
                 if (parent == null) continue;
                 if (detkey.getPath().size() <= treeSize) continue;
-                if (parent.equals(internalKey) && detkey.getChildNumber().i() > issuedInternalKeys) continue;
-                if (parent.equals(externalKey) && detkey.getChildNumber().i() > issuedExternalKeys) continue;
+                if (parent.equals(internalKey) && detkey.getChildNumber().i() >= issuedInternalKeys) continue;
+                if (parent.equals(externalKey) && detkey.getChildNumber().i() >= issuedExternalKeys) continue;
                 issuedKeys.add(detkey);
             }
             return issuedKeys;

File: core/src/test/java/org/bitcoinj/core/WalletTest.java
Patch:
@@ -2288,7 +2288,6 @@ public void keyRotationRandom() throws Exception {
         wallet = new Wallet(params);
         // Watch out for wallet-initiated broadcasts.
         MockTransactionBroadcaster broadcaster = new MockTransactionBroadcaster(wallet);
-        wallet.setKeyRotationEnabled(true);
         // Send three cents to two different random keys, then add a key and mark the initial keys as compromised.
         ECKey key1 = new ECKey();
         key1.setCreationTimeSeconds(Utils.currentTimeSeconds() - (86400 * 2));
@@ -2375,7 +2374,6 @@ public void keyRotationHD() throws Exception {
         // A day later, we get compromised.
         Utils.rollMockClock(86400);
         wallet.setKeyRotationTime(Utils.currentTimeSeconds());
-        wallet.setKeyRotationEnabled(true);
 
         List<Transaction> txns = wallet.maybeDoMaintenance(null, false).get();
         assertEquals(1, txns.size());
@@ -2400,7 +2398,6 @@ public void fragmentedReKeying() throws Exception {
         }
 
         MockTransactionBroadcaster broadcaster = new MockTransactionBroadcaster(wallet);
-        wallet.setKeyRotationEnabled(true);
 
         Date compromise = Utils.now();
         Utils.rollMockClock(86400);

File: tools/src/main/java/org/bitcoinj/tools/WalletTool.java
Patch:
@@ -448,7 +448,6 @@ private static void rotate() throws BlockStoreException {
             rotationTimeSecs = options.valueOf(dateFlag).getTime() / 1000;
         }
         log.info("Setting wallet key rotation time to {}", rotationTimeSecs);
-        wallet.setKeyRotationEnabled(true);
         wallet.setKeyRotationTime(rotationTimeSecs);
         KeyParameter aesKey = null;
         if (wallet.isEncrypted()) {

File: core/src/main/java/org/bitcoinj/wallet/KeyChainGroup.java
Patch:
@@ -726,7 +726,9 @@ private static void extractFollowingKeychains(List<DeterministicKeyChain> chains
     public String toString(boolean includePrivateKeys) {
         final StringBuilder builder = new StringBuilder();
         if (basic != null) {
-            for (ECKey key : basic.getKeys())
+            List<ECKey> keys = basic.getKeys();
+            Collections.sort(keys, ECKey.AGE_COMPARATOR);
+            for (ECKey key : keys)
                 key.formatKeyWithAddress(includePrivateKeys, builder, params);
         }
         List<String> chainStrs = Lists.newLinkedList();

File: core/src/main/java/org/bitcoinj/core/Wallet.java
Patch:
@@ -3427,7 +3427,7 @@ public void completeTx(SendRequest req) throws InsufficientMoneyException {
 
             final Coin calculatedFee = req.tx.getFee();
             if (calculatedFee != null) {
-                log.info("  with a fee of {} BTC", calculatedFee.toFriendlyString());
+                log.info("  with a fee of {}", calculatedFee.toFriendlyString());
             }
 
             // Label the transaction as being self created. We can use this later to spend its change output even before

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -124,7 +124,7 @@ protected void onSetupCompleted() {
             // last months worth or more (takes a few seconds).
             bitcoin.setCheckpoints(getClass().getResourceAsStream("checkpoints"));
         } else if (params == TestNet3Params.get()) {
-            bitcoin.setCheckpoints(getClass().getResourceAsStream("checkpoints.testnet"));
+            bitcoin.setCheckpoints(getClass().getResourceAsStream("org.bitcoin.test.checkpoints"));
             // As an example!
             bitcoin.useTor();
         }

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelClientStates.java
Patch:
@@ -360,8 +360,8 @@ public String toString() {
         final String closeStr = close == null ? "still open" : close.toString().replaceAll(newline, newline + "   ");
         return String.format("Stored client channel for server ID %s (%s)%n" +
                 "    Key:         %s%n" +
-                "    Value left:  %d%n" +
-                "    Refund fees: %d%n" +
+                "    Value left:  %s%n" +
+                "    Refund fees: %s%n" +
                 "    Contract:  %s" +
                 "Refund:    %s" +
                 "Close:     %s",

File: core/src/main/java/org/bitcoinj/core/AbstractBlockChainListener.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/core/AbstractPeerEventListener.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/core/AbstractWalletEventListener.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.script.Script;
-import com.google.bitcoin.wallet.AbstractKeyChainEventListener;
+import org.bitcoinj.script.Script;
+import org.bitcoinj.wallet.AbstractKeyChainEventListener;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/core/Address.java
Patch:
@@ -15,10 +15,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.params.Networks;
-import com.google.bitcoin.script.Script;
+import org.bitcoinj.params.Networks;
+import org.bitcoinj.script.Script;
 
 import javax.annotation.Nullable;
 

File: core/src/main/java/org/bitcoinj/core/AddressFormatException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 @SuppressWarnings("serial")
 public class AddressFormatException extends Exception {

File: core/src/main/java/org/bitcoinj/core/AddressMessage.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/AlertMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.Date;
 import java.util.HashSet;

File: core/src/main/java/org/bitcoinj/core/Base58.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.UnsupportedEncodingException;
 import java.math.BigInteger;

File: core/src/main/java/org/bitcoinj/core/BitcoinSerializer.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -28,7 +28,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.google.bitcoin.core.Utils.*;
+import static org.bitcoinj.core.Utils.*;
 
 /**
  * <p>Methods to serialize and de-serialize messages to the Bitcoin network format as defined in

File: core/src/main/java/org/bitcoinj/core/BlockChainListener.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.List;
 
@@ -26,8 +26,8 @@
 public interface BlockChainListener {
     /**
      * Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to
-     * us via either {@link #receiveFromBlock(Transaction, StoredBlock, com.google.bitcoin.core.BlockChain.NewBlockType, int)}
-     * or {@link #notifyTransactionIsInBlock(Sha256Hash, StoredBlock, com.google.bitcoin.core.BlockChain.NewBlockType, int)}.
+     * us via either {@link #receiveFromBlock(Transaction, StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}
+     * or {@link #notifyTransactionIsInBlock(Sha256Hash, StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
      * If this block is causing a re-organise to a new chain, this method is NOT called even though the block may be
      * the new best block: your reorganize implementation is expected to do whatever would normally be done do for a new
      * best block in this case.

File: core/src/main/java/org/bitcoinj/core/ChildMessage.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import javax.annotation.Nullable;
 

File: core/src/main/java/org/bitcoinj/core/Coin.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.utils.MonetaryFormat;
+import org.bitcoinj.utils.MonetaryFormat;
 import com.google.common.math.LongMath;
 
 import java.io.Serializable;

File: core/src/main/java/org/bitcoinj/core/DownloadListener.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/core/DumpedPrivateKey.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;

File: core/src/main/java/org/bitcoinj/core/EmptyMessage.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/FilteredBlock.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/GetAddrMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 /**
  * Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer. Not to

File: core/src/main/java/org/bitcoinj/core/GetBlocksMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/GetDataMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 /**
  * Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their

File: core/src/main/java/org/bitcoinj/core/GetHeadersMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/core/GetUTXOsMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import com.google.common.collect.ImmutableList;
 

File: core/src/main/java/org/bitcoinj/core/HeadersMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/core/InsufficientMoneyException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import javax.annotation.Nullable;
 

File: core/src/main/java/org/bitcoinj/core/InventoryItem.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 public class InventoryItem {
     

File: core/src/main/java/org/bitcoinj/core/InventoryMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: core/src/main/java/org/bitcoinj/core/ListMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/MemoryPool.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.utils.Threading;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/core/MemoryPoolMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/Message.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/core/Monetary.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.Serializable;
 

File: core/src/main/java/org/bitcoinj/core/NotFoundMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.ArrayList;
 import java.util.List;

File: core/src/main/java/org/bitcoinj/core/PartialMerkleTree.java
Patch:
@@ -15,15 +15,15 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import static com.google.bitcoin.core.Utils.*;
+import static org.bitcoinj.core.Utils.*;
 
 /**
  * <p>A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.</p>

File: core/src/main/java/org/bitcoinj/core/PeerEventListener.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import javax.annotation.Nullable;
 import java.util.List;
@@ -70,7 +70,7 @@ public interface PeerEventListener {
      * callback is passed as "m" to the next, forming a chain.</p>
      *
      * <p>Note that this will never be called if registered with any executor other than
-     * {@link com.google.bitcoin.utils.Threading#SAME_THREAD}</p>
+     * {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
      */
     public Message onPreMessageReceived(Peer peer, Message m);
 
@@ -84,7 +84,7 @@ public interface PeerEventListener {
      * items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.</p>
      *
      * <p>Note that this will never be called if registered with any executor other than
-     * {@link com.google.bitcoin.utils.Threading#SAME_THREAD}</p>
+     * {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
      */
     @Nullable
     public List<Message> getData(Peer peer, GetDataMessage m);

File: core/src/main/java/org/bitcoinj/core/PeerException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 /**
  * Thrown when a problem occurs in communicating with a peer, and we should

File: core/src/main/java/org/bitcoinj/core/PeerFilterProvider.java
Patch:
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.concurrent.locks.Lock;
 
 /**
  * An interface which provides the information required to properly filter data downloaded from Peers.
- * Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(com.google.bitcoin.core.PeerGroup.FilterRecalculateMode)}
+ * Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(org.bitcoinj.core.PeerGroup.FilterRecalculateMode)}
  * whenever a change occurs which effects the data provided via this interface.
  */
 public interface PeerFilterProvider {
@@ -49,7 +49,7 @@ public interface PeerFilterProvider {
     /**
      * Returns an object that will be locked before any other methods are called and unlocked afterwards. You must
      * provide one of these because the results from calling the above methods must be consistent. Otherwise it's
-     * possible for the {@link com.google.bitcoin.net.FilterMerger} to request the counts of a bunch of providers
+     * possible for the {@link org.bitcoinj.net.FilterMerger} to request the counts of a bunch of providers
      * with {@link #getBloomFilterElementCount()}, create a filter of the right size, call {@link #getBloomFilter(int, double, long)}
      * and then the filter provider discovers it's been mutated in the mean time and now has a different number of
      * elements. For instance, a Wallet that has keys added to it whilst a filter recalc is in progress could cause

File: core/src/main/java/org/bitcoinj/core/Ping.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/Pong.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/ProtocolException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 @SuppressWarnings("serial")
 public class ProtocolException extends VerificationException {

File: core/src/main/java/org/bitcoinj/core/PrunedException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 // TODO: Rename PrunedException to something like RequiredDataWasPrunedException
 

File: core/src/main/java/org/bitcoinj/core/RejectMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/main/java/org/bitcoinj/core/ScriptException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 @SuppressWarnings("serial")
 public class ScriptException extends VerificationException {

File: core/src/main/java/org/bitcoinj/core/Sha256Hash.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import com.google.common.io.ByteStreams;
 

File: core/src/main/java/org/bitcoinj/core/StoredBlock.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.store.BlockStore;
-import com.google.bitcoin.store.BlockStoreException;
+import org.bitcoinj.store.BlockStore;
+import org.bitcoinj.store.BlockStoreException;
 
 import java.io.*;
 import java.math.BigInteger;

File: core/src/main/java/org/bitcoinj/core/StoredTransactionOutput.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.*;
 import java.math.BigInteger;

File: core/src/main/java/org/bitcoinj/core/StoredUndoableBlock.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.Serializable;
 import java.util.List;

File: core/src/main/java/org/bitcoinj/core/TransactionBroadcast.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.utils.Threading;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
 import com.google.common.util.concurrent.ListenableFuture;

File: core/src/main/java/org/bitcoinj/core/TransactionBroadcaster.java
Patch:
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import com.google.common.util.concurrent.ListenableFuture;
 
 /**
  * A general interface which declares the ability to broadcast transactions. This is implemented
- * by {@link com.google.bitcoin.core.PeerGroup}.
+ * by {@link org.bitcoinj.core.PeerGroup}.
  */
 public interface TransactionBroadcaster {
     /** Broadcast the given transaction on the network */

File: core/src/main/java/org/bitcoinj/core/TransactionOutputChanges.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.InputStream;

File: core/src/main/java/org/bitcoinj/core/UTXOsMessage.java
Patch:
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.BitSet;
 import java.util.List;
 
 /** Message representing a list of unspent transaction outputs, returned in response to sending a GetUTXOsMessage. */

File: core/src/main/java/org/bitcoinj/core/UnknownMessage.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 public class UnknownMessage extends EmptyMessage {
     private static final long serialVersionUID = 3614705938207918775L;

File: core/src/main/java/org/bitcoinj/core/UnsafeByteArrayOutputStream.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;

File: core/src/main/java/org/bitcoinj/core/Utils.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import com.google.common.base.Charsets;
 import com.google.common.base.Joiner;

File: core/src/main/java/org/bitcoinj/core/VarInt.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import static com.google.bitcoin.core.Utils.isLessThanUnsigned;
-import static com.google.bitcoin.core.Utils.isLessThanOrEqualToUnsigned;
+import static org.bitcoinj.core.Utils.isLessThanUnsigned;
+import static org.bitcoinj.core.Utils.isLessThanOrEqualToUnsigned;
 
 /**
  * A variable-length encoded integer using Satoshis encoding.

File: core/src/main/java/org/bitcoinj/core/VerificationException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 @SuppressWarnings("serial")
 public class VerificationException extends RuntimeException {

File: core/src/main/java/org/bitcoinj/core/VersionAck.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 /**
  * The verack message, sent by a client accepting the version message they

File: core/src/main/java/org/bitcoinj/core/VersionMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import javax.annotation.Nullable;
 import java.io.IOException;

File: core/src/main/java/org/bitcoinj/core/VersionedChecksummedBytes.java
Patch:
@@ -14,15 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
 import java.io.Serializable;
 import java.util.Arrays;
 
-import org.spongycastle.util.Integers;
-
 import com.google.common.base.Objects;
 
 /**

File: core/src/main/java/org/bitcoinj/core/WalletExtension.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 /**
  * <p>An object implementing this interface can be added to a {@link Wallet} and provide arbitrary byte arrays that will

File: core/src/main/java/org/bitcoinj/core/WrongNetworkException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.util.Arrays;
 

File: core/src/main/java/org/bitcoinj/crypto/BIP38PrivateKey.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 import com.google.common.base.Charsets;
 import com.google.common.base.Objects;
 import com.google.common.primitives.Bytes;

File: core/src/main/java/org/bitcoinj/crypto/ChildNumber.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 /**
  * <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit

File: core/src/main/java/org/bitcoinj/crypto/DRMWorkaround.java
Patch:
@@ -1,6 +1,6 @@
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
-import com.google.bitcoin.core.Utils;
+import org.bitcoinj.core.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/crypto/DeterministicHierarchy.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;

File: core/src/main/java/org/bitcoinj/crypto/EncryptableItem.java
Patch:
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import org.bitcoinj.wallet.Protos;
 
 import javax.annotation.Nullable;
 
 /**
  * Provides a uniform way to access something that can be optionally encrypted with a
- * {@link com.google.bitcoin.crypto.KeyCrypter}, yielding an {@link com.google.bitcoin.crypto.EncryptedData}, and
+ * {@link org.bitcoinj.crypto.KeyCrypter}, yielding an {@link org.bitcoinj.crypto.EncryptedData}, and
  * which can have a creation time associated with it.
  */
 public interface EncryptableItem {

File: core/src/main/java/org/bitcoinj/crypto/EncryptedData.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import java.util.Arrays;
 

File: core/src/main/java/org/bitcoinj/crypto/EncryptedPrivateKey.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import com.google.common.base.Objects;
 

File: core/src/main/java/org/bitcoinj/crypto/HDDerivationException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 public class HDDerivationException extends RuntimeException {
     public HDDerivationException(String message) {

File: core/src/main/java/org/bitcoinj/crypto/HDKeyDerivation.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
-import com.google.bitcoin.core.ECKey;
-import com.google.bitcoin.core.Utils;
+import org.bitcoinj.core.ECKey;
+import org.bitcoinj.core.Utils;
 import com.google.common.collect.ImmutableList;
 import org.spongycastle.crypto.macs.HMac;
 import org.spongycastle.math.ec.ECPoint;

File: core/src/main/java/org/bitcoinj/crypto/HDUtils.java
Patch:
@@ -15,9 +15,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
-import com.google.bitcoin.core.ECKey;
+import org.bitcoinj.core.ECKey;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypter.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
 import org.spongycastle.crypto.params.KeyParameter;

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypterException.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 /**
  * <p>Exception to provide the following to {@link EncrypterDecrypterOpenSSL}:</p>

File: core/src/main/java/org/bitcoinj/crypto/KeyCrypterScrypt.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import com.google.common.base.Objects;
 import com.google.protobuf.ByteString;

File: core/src/main/java/org/bitcoinj/crypto/MnemonicException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 /**
  * Exceptions thrown by the MnemonicCode module.

File: core/src/main/java/org/bitcoinj/crypto/PBKDF2SHA512.java
Patch:
@@ -21,7 +21,7 @@
  * 
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import javax.crypto.Mac;
 import javax.crypto.spec.SecretKeySpec;

File: core/src/main/java/org/bitcoinj/crypto/TrustStoreLoader.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import javax.annotation.Nonnull;
 import java.io.File;

File: core/src/main/java/org/bitcoinj/crypto/X509Utils.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import com.google.common.base.Joiner;
 import org.spongycastle.asn1.ASN1ObjectIdentifier;
@@ -38,7 +38,7 @@
 
 /**
  * X509Utils provides tools for working with X.509 certificates and keystores, as used in the BIP 70 payment protocol.
- * For more details on this, see {@link com.google.bitcoin.protocols.payments.PaymentSession}, the article "Working with
+ * For more details on this, see {@link org.bitcoinj.protocols.payments.PaymentSession}, the article "Working with
  * the payment protocol" on the bitcoinj website, or the Bitcoin developer guide.
  */
 public class X509Utils {

File: core/src/main/java/org/bitcoinj/jni/NativeBlockChainListener.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.jni;
+package org.bitcoinj.jni;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/jni/NativeFutureCallback.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.jni;
+package org.bitcoinj.jni;
 
 import com.google.common.util.concurrent.FutureCallback;
 

File: core/src/main/java/org/bitcoinj/jni/NativePaymentChannelHandlerFactory.java
Patch:
@@ -1,7 +1,7 @@
-package com.google.bitcoin.jni;
+package org.bitcoinj.jni;
 
-import com.google.bitcoin.protocols.channels.PaymentChannelServerListener;
-import com.google.bitcoin.protocols.channels.ServerConnectionEventHandler;
+import org.bitcoinj.protocols.channels.PaymentChannelServerListener;
+import org.bitcoinj.protocols.channels.ServerConnectionEventHandler;
 
 import javax.annotation.Nullable;
 import java.net.SocketAddress;

File: core/src/main/java/org/bitcoinj/jni/NativePeerEventListener.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.jni;
+package org.bitcoinj.jni;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/jni/NativeTransactionConfidenceListener.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.jni;
+package org.bitcoinj.jni;
 
-import com.google.bitcoin.core.Transaction;
-import com.google.bitcoin.core.TransactionConfidence;
+import org.bitcoinj.core.Transaction;
+import org.bitcoinj.core.TransactionConfidence;
 
 /**
  * An event listener that relays events to a native C++ object. A pointer to that object is stored in

File: core/src/main/java/org/bitcoinj/net/AbstractTimeoutHandler.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import java.util.Timer;
 import java.util.TimerTask;

File: core/src/main/java/org/bitcoinj/net/BlockingClient.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/net/BlockingClientManager.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import com.google.common.util.concurrent.AbstractIdleService;
 

File: core/src/main/java/org/bitcoinj/net/ClientConnectionManager.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import com.google.common.util.concurrent.Service;
 

File: core/src/main/java/org/bitcoinj/net/ConnectionHandler.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
-import com.google.bitcoin.core.Message;
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.core.Message;
+import org.bitcoinj.utils.Threading;
 import com.google.common.base.Throwables;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/net/MessageWriteTarget.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import java.io.IOException;
 

File: core/src/main/java/org/bitcoinj/net/NioClient.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import java.io.IOException;
 import java.net.SocketAddress;

File: core/src/main/java/org/bitcoinj/net/NioClientManager.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import com.google.common.base.Throwables;
 import com.google.common.util.concurrent.AbstractExecutionThreadService;

File: core/src/main/java/org/bitcoinj/net/NioServer.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;

File: core/src/main/java/org/bitcoinj/net/ProtobufParser.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
-import com.google.bitcoin.core.Utils;
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.core.Utils;
+import org.bitcoinj.utils.Threading;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.MessageLite;

File: core/src/main/java/org/bitcoinj/net/StreamParser.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import java.nio.ByteBuffer;
 

File: core/src/main/java/org/bitcoinj/net/StreamParserFactory.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
 import java.net.InetAddress;
 import javax.annotation.Nullable;

File: core/src/main/java/org/bitcoinj/net/discovery/DnsDiscovery.java
Patch:
@@ -15,9 +15,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net.discovery;
+package org.bitcoinj.net.discovery;
 
-import com.google.bitcoin.core.NetworkParameters;
+import org.bitcoinj.core.NetworkParameters;
 import com.google.common.collect.Lists;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/net/discovery/PeerDiscovery.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net.discovery;
+package org.bitcoinj.net.discovery;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;

File: core/src/main/java/org/bitcoinj/net/discovery/PeerDiscoveryException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net.discovery;
+package org.bitcoinj.net.discovery;
 
 public class PeerDiscoveryException extends Exception {
     private static final long serialVersionUID = -2863411151549391392L;

File: core/src/main/java/org/bitcoinj/net/discovery/SeedPeers.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.net.discovery;
+package org.bitcoinj.net.discovery;
 
-import com.google.bitcoin.core.NetworkParameters;
+import org.bitcoinj.core.NetworkParameters;
 
 import javax.annotation.Nullable;
 import java.net.InetAddress;

File: core/src/main/java/org/bitcoinj/net/discovery/TorDiscovery.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net.discovery;
+package org.bitcoinj.net.discovery;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import com.google.bitcoin.core.NetworkParameters;
+import org.bitcoinj.core.NetworkParameters;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;

File: core/src/main/java/org/bitcoinj/params/Networks.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.params;
+package org.bitcoinj.params;
 
-import com.google.bitcoin.core.NetworkParameters;
+import org.bitcoinj.core.NetworkParameters;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 

File: core/src/main/java/org/bitcoinj/params/RegTestParams.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.params;
+package org.bitcoinj.params;
 
-import com.google.bitcoin.core.Block;
+import org.bitcoinj.core.Block;
 
 import java.math.BigInteger;
 

File: core/src/main/java/org/bitcoinj/params/TestNet2Params.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.params;
+package org.bitcoinj.params;
 
-import com.google.bitcoin.core.NetworkParameters;
-import com.google.bitcoin.core.Utils;
+import org.bitcoinj.core.NetworkParameters;
+import org.bitcoinj.core.Utils;
 
 import static com.google.common.base.Preconditions.checkState;
 

File: core/src/main/java/org/bitcoinj/params/TestNet3Params.java
Patch:
@@ -15,10 +15,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.params;
+package org.bitcoinj.params;
 
-import com.google.bitcoin.core.NetworkParameters;
-import com.google.bitcoin.core.Utils;
+import org.bitcoinj.core.NetworkParameters;
+import org.bitcoinj.core.Utils;
 
 import static com.google.common.base.Preconditions.checkState;
 

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelCloseException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
 /**
  * Used to indicate that a channel was closed before it was expected to be closed.
@@ -34,7 +34,7 @@ public enum CloseReason {
         // Values after here indicate its probably possible to try reopening channel again
 
         /**
-         * <p>The {@link com.google.bitcoin.protocols.channels.PaymentChannelClient#settle()} method was called or the
+         * <p>The {@link org.bitcoinj.protocols.channels.PaymentChannelClient#settle()} method was called or the
          * client sent a CLOSE message.</p>
          * <p>As long as the server received the CLOSE message, this means that the channel is settling and the payment
          * transaction (if any) will be broadcast. If the client attempts to open a new connection, a new channel will
@@ -43,7 +43,7 @@ public enum CloseReason {
         CLIENT_REQUESTED_CLOSE,
 
         /**
-         * <p>The {@link com.google.bitcoin.protocols.channels.PaymentChannelServer#close()} method was called or server
+         * <p>The {@link org.bitcoinj.protocols.channels.PaymentChannelServer#close()} method was called or server
          * sent a CLOSE message.</p>
          *
          * <p>This may occur if the server opts to close the connection for some reason, or automatically if the channel

File: core/src/main/java/org/bitcoinj/protocols/channels/PaymentIncrementAck.java
Patch:
@@ -1,6 +1,6 @@
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
-import com.google.bitcoin.core.Coin;
+import org.bitcoinj.core.Coin;
 import com.google.protobuf.ByteString;
 
 import javax.annotation.Nullable;

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelClientStates.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
-import com.google.bitcoin.core.*;
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.core.*;
+import org.bitcoinj.utils.Threading;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.HashMultimap;
 import com.google.common.util.concurrent.SettableFuture;

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredPaymentChannelServerStates.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
-import com.google.bitcoin.core.*;
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.core.*;
+import org.bitcoinj.utils.Threading;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.util.concurrent.SettableFuture;
 import com.google.protobuf.ByteString;

File: core/src/main/java/org/bitcoinj/protocols/channels/StoredServerChannel.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 
 import javax.annotation.Nullable;
 import java.util.Date;
@@ -78,7 +78,7 @@ synchronized void clearConnectedHandler() {
     }
 
     /**
-     * If a handler is connected, call its {@link com.google.bitcoin.protocols.channels.PaymentChannelServer#close()}
+     * If a handler is connected, call its {@link org.bitcoinj.protocols.channels.PaymentChannelServer#close()}
      * method thus disconnecting the TCP connection.
      */
     synchronized void closeConnectedHandler() {

File: core/src/main/java/org/bitcoinj/protocols/channels/ValueOutOfRangeException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
 /**
  * Used when a given value is either too large too afford or too small for the network to accept.

File: core/src/main/java/org/bitcoinj/protocols/payments/PaymentProtocolException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.payments;
+package org.bitcoinj.protocols.payments;
 
 import java.security.cert.X509Certificate;
 import java.util.List;

File: core/src/main/java/org/bitcoinj/script/ScriptOpCodes.java
Patch:
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.script;
+package org.bitcoinj.script;
 
 import com.google.common.collect.ImmutableMap;
 
 import java.util.Map;
 
 /**
  * Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
- * See {@link com.google.bitcoin.script.Script} for details. Also provides a method to convert them to a string.
+ * See {@link org.bitcoinj.script.Script} for details. Also provides a method to convert them to a string.
  */
 public class ScriptOpCodes {
     // push value

File: core/src/main/java/org/bitcoinj/signers/StatelessTransactionSigner.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.signers;
+package org.bitcoinj.signers;
 
 /**
  * A signer that doesn't have any state to be serialized.

File: core/src/main/java/org/bitcoinj/store/BlockStoreException.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.store;
+package org.bitcoinj.store;
 
 /**
  * Thrown when something goes wrong with storing a block. Examples: out of disk space.

File: core/src/main/java/org/bitcoinj/store/H2FullPrunedBlockStore.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.store;
+package org.bitcoinj.store;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 import com.google.common.collect.Lists;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/store/MemoryBlockStore.java
Patch:
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.store;
+package org.bitcoinj.store;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
 
 /**
- * Keeps {@link com.google.bitcoin.core.StoredBlock}s in memory. Used primarily for unit testing.
+ * Keeps {@link org.bitcoinj.core.StoredBlock}s in memory. Used primarily for unit testing.
  */
 public class MemoryBlockStore implements BlockStore {
     private LinkedHashMap<Sha256Hash, StoredBlock> blockMap = new LinkedHashMap<Sha256Hash, StoredBlock>() {

File: core/src/main/java/org/bitcoinj/store/MemoryFullPrunedBlockStore.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.store;
+package org.bitcoinj.store;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;

File: core/src/main/java/org/bitcoinj/store/SPVBlockStore.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.store;
+package org.bitcoinj.store;
 
-import com.google.bitcoin.core.*;
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.core.*;
+import org.bitcoinj.utils.Threading;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: core/src/main/java/org/bitcoinj/store/UnreadableWalletException.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.store;
+package org.bitcoinj.store;
 
 /**
  * Thrown by the {@link WalletProtobufSerializer} when the serialized protocol buffer is either corrupted,

File: core/src/main/java/org/bitcoinj/testing/InboundMessageQueuer.java
Patch:
@@ -1,6 +1,6 @@
-package com.google.bitcoin.testing;
+package org.bitcoinj.testing;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 import com.google.common.util.concurrent.SettableFuture;
 
 import java.net.InetSocketAddress;
@@ -10,7 +10,7 @@
 import java.util.concurrent.BlockingQueue;
 
 /**
- * An extension of {@link com.google.bitcoin.core.PeerSocketHandler} that keeps inbound messages in a queue for later processing
+ * An extension of {@link org.bitcoinj.core.PeerSocketHandler} that keeps inbound messages in a queue for later processing
  */
 public abstract class InboundMessageQueuer extends PeerSocketHandler {
     public final BlockingQueue<Message> inboundMessages = new ArrayBlockingQueue<Message>(1000);

File: core/src/main/java/org/bitcoinj/testing/NopTransactionSigner.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.testing;
+package org.bitcoinj.testing;
 
-import com.google.bitcoin.signers.TransactionSigner;
-import com.google.bitcoin.wallet.KeyBag;
+import org.bitcoinj.signers.TransactionSigner;
+import org.bitcoinj.wallet.KeyBag;
 
 public class NopTransactionSigner implements TransactionSigner {
     private boolean isReady;

File: core/src/main/java/org/bitcoinj/uri/BitcoinURIParseException.java
Patch:
@@ -16,7 +16,7 @@
  *
  */
 
-package com.google.bitcoin.uri;
+package org.bitcoinj.uri;
 
 /**
  * <p>Exception to provide the following to {@link BitcoinURI}:</p>

File: core/src/main/java/org/bitcoinj/uri/OptionalFieldValidationException.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.uri;
+package org.bitcoinj.uri;
 
 /**
  * <p>Exception to provide the following to {@link org.multibit.qrcode.BitcoinURI}:</p>

File: core/src/main/java/org/bitcoinj/uri/RequiredFieldValidationException.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.uri;
+package org.bitcoinj.uri;
 
 /**
  * <p>Exception to provide the following to {@link BitcoinURI}:</p>

File: core/src/main/java/org/bitcoinj/utils/BaseTaggableObject.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import com.google.common.collect.Maps;
 import com.google.protobuf.ByteString;

File: core/src/main/java/org/bitcoinj/utils/BriefLogFormatter.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;

File: core/src/main/java/org/bitcoinj/utils/BtcAutoFormat.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
-import static com.google.bitcoin.core.Coin.SMALLEST_UNIT_EXPONENT;
+import static org.bitcoinj.core.Coin.SMALLEST_UNIT_EXPONENT;
 import com.google.common.collect.ImmutableList;
 
 import java.math.BigInteger;
@@ -54,7 +54,7 @@
  * @see          java.text.NumberFormat
  * @see          java.text.DecimalFormat
  * @see          DecimalFormatSymbols
- * @see          com.google.bitcoin.core.Coin
+ * @see          org.bitcoinj.core.Coin
  */
 
 public final class BtcAutoFormat extends BtcFormat {

File: core/src/main/java/org/bitcoinj/utils/ExchangeRate.java
Patch:
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
 import java.io.Serializable;
 import java.math.BigInteger;
 
-import com.google.bitcoin.core.Coin;
+import org.bitcoinj.core.Coin;
 
 /**
  * An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.

File: core/src/main/java/org/bitcoinj/utils/ExponentialBackoff.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
-import com.google.bitcoin.core.Utils;
+import org.bitcoinj.core.Utils;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: core/src/main/java/org/bitcoinj/utils/Fiat.java
Patch:
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
 import java.io.Serializable;
 import java.math.BigDecimal;
 
-import com.google.bitcoin.core.Monetary;
+import org.bitcoinj.core.Monetary;
 import com.google.common.math.LongMath;
 
 /**

File: core/src/main/java/org/bitcoinj/utils/ListenerRegistration.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import java.util.List;
 import java.util.concurrent.Executor;

File: core/src/main/java/org/bitcoinj/utils/TaggableObject.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import com.google.protobuf.ByteString;
 

File: core/src/main/java/org/bitcoinj/utils/Threading.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import com.google.common.util.concurrent.CycleDetectingLockFactory;
 import com.google.common.util.concurrent.ListeningExecutorService;

File: core/src/main/java/org/bitcoinj/wallet/AbstractKeyChainEventListener.java
Patch:
@@ -1,6 +1,6 @@
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.ECKey;
+import org.bitcoinj.core.ECKey;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/wallet/AllowUnconfirmedCoinSelector.java
Patch:
@@ -1,6 +1,6 @@
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.Transaction;
+import org.bitcoinj.core.Transaction;
 
 /**
  * This coin selector will select any transaction at all, regardless of where it came from or whether it was

File: core/src/main/java/org/bitcoinj/wallet/DecryptingKeyBag.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.ECKey;
+import org.bitcoinj.core.ECKey;
 import org.spongycastle.crypto.params.KeyParameter;
 
 import javax.annotation.Nullable;
@@ -28,7 +28,7 @@
 
 /**
  * A DecryptingKeyBag filters a pre-existing key bag, decrypting keys as they are requested using the provided
- * AES key. If the keys are encrypted and no AES key provided, {@link com.google.bitcoin.core.ECKey.KeyIsEncryptedException}
+ * AES key. If the keys are encrypted and no AES key provided, {@link org.bitcoinj.core.ECKey.KeyIsEncryptedException}
  * will be thrown.
  */
 public class DecryptingKeyBag implements KeyBag {

File: core/src/main/java/org/bitcoinj/wallet/DeterministicUpgradeRequiredException.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
 /**
  * Indicates that an attempt was made to use HD wallet features on a wallet that was deserialized from an old,

File: core/src/main/java/org/bitcoinj/wallet/DeterministicUpgradeRequiresPassword.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
 /**
  * Indicates that the pre-HD random wallet is encrypted, so you should try the upgrade again after getting the

File: core/src/main/java/org/bitcoinj/wallet/FilteringCoinSelector.java
Patch:
@@ -15,9 +15,9 @@
  */
 
 
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 
 import java.util.HashSet;
 import java.util.Iterator;

File: core/src/main/java/org/bitcoinj/wallet/KeyBag.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.ECKey;
+import org.bitcoinj.core.ECKey;
 
 import javax.annotation.Nullable;
 

File: core/src/main/java/org/bitcoinj/wallet/KeyChainEventListener.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.ECKey;
+import org.bitcoinj.core.ECKey;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/wallet/RedeemData.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.ECKey;
-import com.google.bitcoin.script.Script;
+import org.bitcoinj.core.ECKey;
+import org.bitcoinj.script.Script;
 
 import java.util.ArrayList;
 import java.util.Arrays;

File: core/src/main/java/org/bitcoinj/wallet/RiskAnalysis.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.Transaction;
-import com.google.bitcoin.core.Wallet;
+import org.bitcoinj.core.Transaction;
+import org.bitcoinj.core.Wallet;
 
 import java.util.List;
 

File: core/src/main/java/org/bitcoinj/wallet/WalletFiles.java
Patch:
@@ -15,10 +15,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.Wallet;
-import com.google.bitcoin.utils.Threading;
+import org.bitcoinj.core.Wallet;
+import org.bitcoinj.utils.Threading;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: core/src/main/java/org/bitcoinj/wallet/WalletTransaction.java
Patch:
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.wallet;
+package org.bitcoinj.wallet;
 
-import com.google.bitcoin.core.Transaction;
+import org.bitcoinj.core.Transaction;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
- * Stores data about a transaction that is only relevant to the {@link com.google.bitcoin.core.Wallet} class.
+ * Stores data about a transaction that is only relevant to the {@link org.bitcoinj.core.Wallet} class.
  */
 public class WalletTransaction {
     public enum Pool {

File: core/src/test/java/org/bitcoinj/core/AlertMessageTest.java
Patch:
@@ -15,13 +15,13 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.params.UnitTestParams;
+import org.bitcoinj.params.UnitTestParams;
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.google.bitcoin.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.HEX;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 

File: core/src/test/java/org/bitcoinj/core/Base58Test.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import junit.framework.TestCase;
 import org.junit.Test;

File: core/src/test/java/org/bitcoinj/core/BitcoinSerializerTest.java
Patch:
@@ -15,17 +15,17 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.params.MainNetParams;
+import org.bitcoinj.params.MainNetParams;
 import org.junit.Test;
 
 import java.io.ByteArrayOutputStream;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
-import static com.google.bitcoin.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.HEX;
 import static org.junit.Assert.*;
 
 public class BitcoinSerializerTest {

File: core/src/test/java/org/bitcoinj/core/CoinTest.java
Patch:
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import static com.google.bitcoin.core.Coin.*;
-import static com.google.bitcoin.core.NetworkParameters.MAX_MONEY;
+import static org.bitcoinj.core.Coin.*;
+import static org.bitcoinj.core.NetworkParameters.MAX_MONEY;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;

File: core/src/test/java/org/bitcoinj/core/DumpedPrivateKeyTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import static org.junit.Assert.assertEquals;
 
@@ -25,7 +25,7 @@
 
 import org.junit.Test;
 
-import com.google.bitcoin.params.MainNetParams;
+import org.bitcoinj.params.MainNetParams;
 
 public class DumpedPrivateKeyTest {
     @Test

File: core/src/test/java/org/bitcoinj/core/MessageTest.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.params.UnitTestParams;
+import org.bitcoinj.params.UnitTestParams;
 import org.junit.Test;
 
 public class MessageTest {

File: core/src/test/java/org/bitcoinj/core/PeerAddressTest.java
Patch:
@@ -15,14 +15,14 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.params.MainNetParams;
+import org.bitcoinj.params.MainNetParams;
 import org.junit.Test;
 
 import java.net.InetAddress;
 
-import static com.google.bitcoin.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.HEX;
 import static org.junit.Assert.assertEquals;
 
 public class PeerAddressTest

File: core/src/test/java/org/bitcoinj/core/UtilsTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import java.math.BigInteger;
 import org.junit.Test;

File: core/src/test/java/org/bitcoinj/core/VarIntTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
 import junit.framework.TestCase;
 

File: core/src/test/java/org/bitcoinj/core/VersionMessageTest.java
Patch:
@@ -15,12 +15,12 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core;
+package org.bitcoinj.core;
 
-import com.google.bitcoin.params.UnitTestParams;
+import org.bitcoinj.params.UnitTestParams;
 import org.junit.Test;
 
-import static com.google.bitcoin.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.HEX;
 import static org.junit.Assert.assertTrue;
 
 public class VersionMessageTest {

File: core/src/test/java/org/bitcoinj/crypto/HDUtilsTest.java
Patch:
@@ -15,13 +15,13 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import com.google.common.collect.ImmutableList;
 import org.junit.Assert;
 import org.junit.Test;
 
-import static com.google.bitcoin.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.HEX;
 import java.util.List;
 
 public class HDUtilsTest {

File: core/src/test/java/org/bitcoinj/crypto/KeyCrypterScryptTest.java
Patch:
@@ -14,10 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
-import com.google.bitcoin.core.Utils;
-import com.google.bitcoin.utils.BriefLogFormatter;
+import org.bitcoinj.core.Utils;
+import org.bitcoinj.utils.BriefLogFormatter;
 import com.google.protobuf.ByteString;
 
 import org.bitcoinj.wallet.Protos;

File: core/src/test/java/org/bitcoinj/crypto/MnemonicCodeTest.java
Patch:
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
@@ -27,7 +27,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static com.google.bitcoin.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.HEX;
 import static org.junit.Assert.assertEquals;
 
 public class MnemonicCodeTest {

File: core/src/test/java/org/bitcoinj/crypto/X509UtilsTest.java
Patch:
@@ -14,9 +14,8 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto;
+package org.bitcoinj.crypto;
 
-import com.google.bitcoin.crypto.X509Utils;
 import org.junit.Test;
 
 import java.security.cert.CertificateFactory;

File: core/src/test/java/org/bitcoinj/net/NetworkAbstractionTests.java
Patch:
@@ -15,9 +15,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.net;
+package org.bitcoinj.net;
 
-import com.google.bitcoin.core.Utils;
+import org.bitcoinj.core.Utils;
 import com.google.common.util.concurrent.SettableFuture;
 import com.google.protobuf.ByteString;
 import org.bitcoin.paymentchannel.Protos;

File: core/src/test/java/org/bitcoinj/net/discovery/SeedPeersTest.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.bitcoin.net.discovery;
+package org.bitcoinj.net.discovery;
 
-import com.google.bitcoin.params.MainNetParams;
+import org.bitcoinj.params.MainNetParams;
 import org.junit.Test;
 
 import java.net.InetSocketAddress;

File: core/src/test/java/org/bitcoinj/protocols/channels/PaymentChannelClientTest.java
Patch:
@@ -1,6 +1,6 @@
-package com.google.bitcoin.protocols.channels;
+package org.bitcoinj.protocols.channels;
 
-import com.google.bitcoin.core.*;
+import org.bitcoinj.core.*;
 import org.bitcoin.paymentchannel.Protos;
 import org.easymock.Capture;
 import org.easymock.EasyMock;

File: core/src/test/java/org/bitcoinj/utils/BaseTaggableObjectTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import com.google.protobuf.ByteString;
 import org.junit.Before;

File: core/src/test/java/org/bitcoinj/utils/ExchangeRateTest.java
Patch:
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
 import static org.junit.Assert.assertEquals;
 
 import org.junit.Test;
 
-import com.google.bitcoin.core.Coin;
+import org.bitcoinj.core.Coin;
 
 public class ExchangeRateTest {
 

File: core/src/test/java/org/bitcoinj/utils/ExponentialBackoffTest.java
Patch:
@@ -14,10 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
-import com.google.bitcoin.core.Utils;
-import com.google.bitcoin.utils.ExponentialBackoff;
+import org.bitcoinj.core.Utils;
 
 import org.junit.Before;
 import org.junit.Test;

File: core/src/test/java/org/bitcoinj/utils/FiatTest.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.utils;
+package org.bitcoinj.utils;
 
-import static com.google.bitcoin.utils.Fiat.parseFiat;
+import static org.bitcoinj.utils.Fiat.parseFiat;
 import static org.junit.Assert.assertEquals;
 
 import org.junit.Test;

File: core/src/main/java/com/google/bitcoin/testing/TestWithNetworkConnections.java
Patch:
@@ -232,7 +232,7 @@ protected Message outbound(InboundMessageQueuer p1) throws Exception {
         return p1.nextMessage();
     }
 
-    protected Object waitForOutbound(InboundMessageQueuer ch) throws InterruptedException {
+    protected Message waitForOutbound(InboundMessageQueuer ch) throws InterruptedException {
         return ch.nextMessageBlocking();
     }
 

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -904,7 +904,6 @@ public void recalculateFastCatchupAndFilter(FilterRecalculateMode mode) {
             // Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
             if (chain != null && chain.shouldVerifyTransactions())
                 return;
-            log.info("Recalculating filter in mode {}", mode);
             FilterMerger.Result result = bloomFilterMerger.calculate(ImmutableList.copyOf(peerFilterProviders));
             boolean send;
             switch (mode) {

File: core/src/main/java/com/google/bitcoin/net/NioClientManager.java
Patch:
@@ -67,7 +67,8 @@ private void handleKey(SelectionKey key) throws IOException {
                 // If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                 // may cause this. Otherwise it may be any arbitrary kind of connection failure.
                 // Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself
-                log.error("Failed to connect with exception: {}", Throwables.getRootCause(e).getMessage());
+                Throwable cause = Throwables.getRootCause(e);
+                log.error("Failed to connect with exception: {}: {}", cause.getClass().getName(), cause.getMessage());
                 handler.closeConnection();
             }
         } else // Process bytes read

File: core/src/main/java/com/google/bitcoin/signers/CustomTransactionSigner.java
Patch:
@@ -71,9 +71,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
             Sha256Hash sighash = tx.hashForSignature(i, redeemData.redeemScript, Transaction.SigHash.ALL, false);
             SignatureAndKey sigKey = getSignature(sighash, propTx.keyPaths.get(scriptPubKey));
             TransactionSignature txSig = new TransactionSignature(sigKey.sig, Transaction.SigHash.ALL, false);
-            int sigIndex = redeemData.getKeyIndex(sigKey.pubKey);
-            if (sigIndex < 0)
-                throw new RuntimeException("Redeem script doesn't contain our key"); // This should not happen
+            int sigIndex = inputScript.getSigInsertionIndex(sighash, sigKey.pubKey);
             inputScript = scriptPubKey.getScriptSigWithSignature(inputScript, txSig.encodeToBitcoin(), sigIndex);
             txIn.setScriptSig(inputScript);
         }

File: core/src/main/java/com/google/bitcoin/signers/MissingSigResolutionSigner.java
Patch:
@@ -86,6 +86,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                     }
                 }
             }
+            // TODO handle non-P2SH multisig
         }
         return true;
     }

File: core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
Patch:
@@ -629,7 +629,7 @@ public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTwea
 
         for (Map.Entry<ByteString, RedeemData> entry : marriedKeysRedeemData.entrySet()) {
             filter.insert(entry.getKey().toByteArray());
-            filter.insert(ScriptBuilder.createP2SHOutputScript(entry.getValue().redeemScript).getProgram());
+            filter.insert(entry.getValue().redeemScript.getProgram());
         }
 
         for (DeterministicKeyChain chain : chains) {

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServer.java
Patch:
@@ -135,7 +135,7 @@ public interface ServerConnection {
 
     /**
      * Maximum channel duration, in seconds, that the client can request. Defaults to 1 week.
-     * Note that the server need to be online for the whole time the channel is open.
+     * Note that the server needs to be online for the whole time the channel is open.
      * Failure to do this could cause loss of all payments received on the channel.
      */
     protected final long maxTimeWindow;

File: core/src/main/java/com/google/bitcoin/core/VersionMessage.java
Patch:
@@ -77,7 +77,7 @@ public class VersionMessage extends Message {
     /** The version of this library release, as a string. */
     public static final String BITCOINJ_VERSION = "0.12-SNAPSHOT";
     /** The value that is prepended to the subVer field of this application. */
-    public static final String LIBRARY_SUBVER = "/BitCoinJ:" + BITCOINJ_VERSION + "/";
+    public static final String LIBRARY_SUBVER = "/bitcoinj:" + BITCOINJ_VERSION + "/";
 
     public VersionMessage(NetworkParameters params, byte[] payload) throws ProtocolException {
         super(params, payload, 0);

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -3028,10 +3028,10 @@ public static class SendRequest {
 
         /**
          * Specifies what to do with missing signatures left after completing this request. Default strategy is to
-         * replace missing signatures with dummy sigs ({@link MissingSigsMode#USE_DUMMY_SIG}).
+         * throw an exception on missing signature ({@link MissingSigsMode#THROW}).
          * @see MissingSigsMode
          */
-        public MissingSigsMode missingSigsMode = MissingSigsMode.USE_DUMMY_SIG;
+        public MissingSigsMode missingSigsMode = MissingSigsMode.THROW;
 
         /**
          * If not null, this exchange rate is recorded with the transaction during completion.

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -394,6 +394,7 @@ public synchronized ListenableFuture<Transaction> close() throws InsufficientMon
             signMultisigInput(tx, Transaction.SigHash.NONE, true);
             // Let wallet handle adding additional inputs/fee as necessary.
             req.shuffleOutputs = false;
+            req.missingSigsMode = Wallet.MissingSigsMode.USE_DUMMY_SIG;
             wallet.completeTx(req);  // TODO: Fix things so shuffling is usable.
             feePaidForPayment = req.tx.getFee();
             log.info("Calculated fee is {}", feePaidForPayment);

File: core/src/main/java/com/google/bitcoin/net/NioClientManager.java
Patch:
@@ -146,6 +146,9 @@ public void openConnection(SocketAddress serverAddress, StreamParser parser) {
         } catch (IOException e) {
             log.error("Could not connect to " + serverAddress);
             throw new RuntimeException(e); // This should only happen if we are, eg, out of system resources
+        } catch (AssertionError e) {
+            log.error("Could not connect to " + serverAddress);
+            throw new RuntimeException(e); // Happens on Android when libcore.io.Posix.getsockname() throws libcore.io.ErrnoException.
         }
     }
 

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.*;
 
 import static com.google.bitcoin.core.Utils.*;
+import static com.google.common.base.Preconditions.checkState;
 
 /**
  * <p>A transaction represents the movement of coins from some addresses to some other addresses. It can also represent
@@ -744,6 +745,8 @@ public TransactionInput addInput(Sha256Hash spendTxHash, long outputIndex, Scrip
      */
     public TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey,
                                            SigHash sigHash, boolean anyoneCanPay) throws ScriptException {
+        // Verify the API user didn't try to do operations out of order.
+        checkState(!outputs.isEmpty(), "Attempting to sign tx without outputs.");
         TransactionInput input = new TransactionInput(params, this, new byte[]{}, prevOut);
         addInput(input);
         Sha256Hash hash = hashForSignature(inputs.size() - 1, scriptPubKey, sigHash, anyoneCanPay);

File: core/src/main/java/com/google/bitcoin/signers/TransactionSigner.java
Patch:
@@ -57,6 +57,9 @@ public ProposedTransaction(Transaction partialTx) {
         }
     }
 
+    public static class MissingSignatureException extends RuntimeException {
+    }
+
     /**
      * Returns true if this signer is ready to be used.
      */

File: core/src/main/java/com/google/bitcoin/signers/DummySigSigner.java
Patch:
@@ -52,7 +52,7 @@ public boolean signInputs(ProposedTransaction propTx, KeyBag keyBag) {
                 for (int j = 1; j < inputScript.getChunks().size() - 1; j++) {
                     ScriptChunk scriptChunk = inputScript.getChunks().get(j);
                     if (scriptChunk.equalsOpCode(0)) {
-                        txIn.setScriptSig(scriptPubKey.getScriptSigWithSignature(inputScript, dummySig, j));
+                        txIn.setScriptSig(scriptPubKey.getScriptSigWithSignature(inputScript, dummySig, j - 1));
                     }
                 }
             } else {

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -123,10 +123,10 @@ protected void onSetupCompleted() {
             // Checkpoint files are made using the BuildCheckpoints tool and usually we have to download the
             // last months worth or more (takes a few seconds).
             bitcoin.setCheckpoints(getClass().getResourceAsStream("checkpoints"));
-            // As an example!
-            // bitcoin.useTor();
         } else if (params == TestNet3Params.get()) {
             bitcoin.setCheckpoints(getClass().getResourceAsStream("checkpoints.testnet"));
+            // As an example!
+            bitcoin.useTor();
         }
         bitcoin.setDownloadListener(controller.progressBarUpdater())
                .setBlockingStartup(false)

File: orchid/src/com/subgraph/orchid/connections/ConnectionCacheImpl.java
Patch:
@@ -94,6 +94,9 @@ public void close() {
 					logger.warning("Exception closing connection: "+ e.getCause());
 				}
 			} else {
+				// FIXME this doesn't close the socket, so the connection task lingers
+				// A proper fix would require maintaining pending connections in a separate
+				// collection.
 				f.cancel(true);
 			}
 		}

File: orchid/src/com/subgraph/orchid/ConnectionCache.java
Patch:
@@ -18,4 +18,6 @@ public interface ConnectionCache {
 	Connection getConnectionTo(Router router, boolean isDirectoryConnection) throws InterruptedException, ConnectionTimeoutException, ConnectionFailedException, ConnectionHandshakeException;
 	
 	void close();
+
+	boolean isClosed();
 }

File: core/src/main/java/com/google/bitcoin/utils/CoinFormat.java
Patch:
@@ -376,10 +376,9 @@ else if (positiveSign != 0)
             }
         }
 
-        // convert to non-arabic digits
+        // Convert to non-arabic digits.
         if (zeroDigit != '0') {
             int offset = zeroDigit - '0';
-            System.out.println(offset);
             for (int d = 0; d < str.length(); d++) {
                 char c = str.charAt(d);
                 if(Character.isDigit(c))
@@ -432,7 +431,7 @@ private long parseValue(String str, int smallestUnitExponent) {
         for (char c : satoshis.toCharArray())
             if (!Character.isDigit(c))
                 throw new NumberFormatException("illegal character: " + c);
-        long value = Long.parseLong(satoshis); // non-arabic digits allowed here
+        long value = Long.parseLong(satoshis); // Non-arabic digits allowed here.
         if (first == negativeSign)
             value = -value;
         return value;

File: core/src/main/java/com/google/bitcoin/utils/BtcFormat.java
Patch:
@@ -520,7 +520,7 @@ public abstract class BtcFormat extends Format {
      *  units indicated by the given scale differs from that same value denominated in satoshis */
     private static int offSatoshis(int scale) { return Coin.SMALLEST_UNIT_EXPONENT - scale; }
 
-    private static Locale defaultLocale() { return Locale.getDefault(Locale.Category.FORMAT); }
+    private static Locale defaultLocale() { return Locale.getDefault(); }
 
     /**
      * <p>This class constructs new instances of {@link BtcFormat}, allowing for the

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -2352,6 +2352,7 @@ public void keyRotationRandom() throws Exception {
     public void keyRotationHD() throws Exception {
         // Test that if we rotate an HD chain, a new one is created and all arrivals on the old keys are moved.
         Utils.setMockClock();
+        wallet = new Wallet(params);
         ECKey key1 = wallet.freshReceiveKey();
         ECKey key2 = wallet.freshReceiveKey();
         sendMoneyToWallet(wallet, CENT, key1.toAddress(params), AbstractBlockChain.NewBlockType.BEST_CHAIN);

File: core/src/main/java/com/google/bitcoin/core/VersionMessage.java
Patch:
@@ -312,7 +312,7 @@ public boolean isBloomFilteringSupported() {
 
     /** Returns true if the protocol version and service bits both indicate support for the getutxos message. */
     public boolean isGetUTXOsSupported() {
-        return clientVersion >= GetUTXOSMessage.MIN_PROTOCOL_VERSION &&
+        return clientVersion >= GetUTXOsMessage.MIN_PROTOCOL_VERSION &&
                 (localServices & NODE_GETUTXOS) == NODE_GETUTXOS;
     }
 }

File: core/src/test/java/com/google/bitcoin/core/BitcoindComparisonTool.java
Patch:
@@ -248,7 +248,7 @@ public Lock getLock() {
                 mostRecentInv = null;
             } else if (rule instanceof UTXORule) {
                 UTXORule r = (UTXORule) rule;
-                UTXOSMessage result = bitcoind.getUTXOs(r.query).get();
+                UTXOsMessage result = bitcoind.getUTXOs(r.query).get();
                 if (!result.equals(r.result)) {
                     log.error("utxo result was not what we expected.");
                     log.error("Wanted  {}", r.result);

File: core/src/main/java/com/google/bitcoin/testing/NopTransactionSigner.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.google.bitcoin.testing;
 
-import com.google.bitcoin.core.Transaction;
 import com.google.bitcoin.signers.TransactionSigner;
 import com.google.bitcoin.wallet.KeyBag;
 
@@ -46,7 +45,7 @@ public void deserialize(byte[] data) {
     }
 
     @Override
-    public boolean signInputs(Transaction t, KeyBag keyBag) {
+    public boolean signInputs(ProposedTransaction t, KeyBag keyBag) {
         return false;
     }
 }

File: core/src/main/java/com/google/bitcoin/net/NioClientManager.java
Patch:
@@ -57,7 +57,7 @@ private void handleKey(SelectionKey key) throws IOException {
             try {
                 if (sc.finishConnect()) {
                     log.info("Successfully connected to {}", sc.socket().getRemoteSocketAddress());
-                    key.interestOps(key.interestOps() | SelectionKey.OP_READ).attach(handler);
+                    key.interestOps((key.interestOps() | SelectionKey.OP_READ) & ~SelectionKey.OP_CONNECT).attach(handler);
                     handler.parser.connectionOpened();
                 } else {
                     log.error("Failed to connect to {}", sc.socket().getRemoteSocketAddress());

File: core/src/main/java/com/google/bitcoin/net/ConnectionHandler.java
Patch:
@@ -74,7 +74,6 @@ private ConnectionHandler(@Nullable StreamParser parser, SelectionKey key) {
         this.channel = checkNotNull(((SocketChannel)key.channel()));
         if (parser == null) {
             readBuff = null;
-            closeConnection();
             return;
         }
         this.parser = parser;

File: core/src/test/java/com/google/bitcoin/wallet/DeterministicKeyChainTest.java
Patch:
@@ -23,9 +23,7 @@
 import com.google.bitcoin.store.UnreadableWalletException;
 import com.google.bitcoin.utils.BriefLogFormatter;
 import com.google.bitcoin.utils.Threading;
-import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.io.Resources;
 import org.bitcoinj.wallet.Protos;
 import org.junit.Before;
 import org.junit.Test;
@@ -310,7 +308,7 @@ private String protoToString(List<Protos.Key> keys) {
     private String checkSerialization(List<Protos.Key> keys, String filename) {
         try {
             String sb = protoToString(keys);
-            String expected = Resources.toString(getClass().getResource(filename), Charsets.UTF_8);
+            String expected = Utils.getResourceAsString(getClass().getResource(filename));
             assertEquals(expected, sb);
             return expected;
         } catch (IOException e) {

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -1482,7 +1482,7 @@ public void onFailure(Throwable throwable) {
             }
         });
         // Keep a reference to the TransactionBroadcast object. This is important because otherwise, the entire tree
-        // of objects we just created would become garbage if the user doens't hold on to the returned future, and
+        // of objects we just created would become garbage if the user doesn't hold on to the returned future, and
         // eventually be collected. This in turn could result in the transaction not being committed to the wallet
         // at all.
         runningBroadcasts.add(broadcast);

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -1356,7 +1356,7 @@ public void spendOutputFromPendingTransaction() throws Exception {
         Transaction t3 = new Transaction(params);
         t3.addOutput(v3, k3.toAddress(params));
         t3.addInput(o2);
-        wallet.signTransaction(t3, Transaction.SigHash.ALL, null);
+        wallet.signTransaction(t3, null);
 
         // Commit t3, so the coins from the pending t2 are spent
         wallet.commitTx(t3);
@@ -1897,7 +1897,7 @@ public void feeSolverAndCoinSelectionTest() throws Exception {
         Transaction spendTx5 = new Transaction(params);
         spendTx5.addOutput(CENT, notMyAddr);
         spendTx5.addInput(tx5.getOutput(0));
-        wallet.signTransaction(spendTx5, Transaction.SigHash.ALL, null);
+        wallet.signTransaction(spendTx5, null);
 
         wallet.receiveFromBlock(spendTx5, block, AbstractBlockChain.NewBlockType.BEST_CHAIN, 4);
         assertEquals(COIN, wallet.getBalance());
@@ -2148,7 +2148,7 @@ public void testCompleteTxWithExistingInputs() throws Exception {
         SendRequest request4 = SendRequest.to(notMyAddr, CENT);
         request4.tx.addInput(tx3.getOutput(0));
         // Now if we manually sign it, completeTx will not replace our signature
-        wallet.signTransaction(request4.tx, Transaction.SigHash.ALL, null);
+        wallet.signTransaction(request4.tx, null);
         byte[] scriptSig = request4.tx.getInput(0).getScriptBytes();
         wallet.completeTx(request4);
         assertEquals(1, request4.tx.getInputs().size());

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -550,7 +550,7 @@ private static void send(List<String> outputs, Coin fee, String lockTimeStr, boo
                     // For lock times to take effect, at least one output must have a non-final sequence number.
                     t.getInputs().get(0).setSequenceNumber(0);
                     // And because we modified the transaction after it was completed, we must re-sign the inputs.
-                    wallet.signTransaction(t, Transaction.SigHash.ALL, req.aesKey);
+                    wallet.signTransaction(t, req.aesKey);
                 }
             } catch (ParseException e) {
                 System.err.println("Could not understand --locktime of " + lockTimeStr);

File: core/src/main/java/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -99,10 +99,9 @@ public TransactionInput(NetworkParameters params, @Nullable Transaction parentTr
     /**
      * Deserializes an input message. This is usually part of a transaction message.
      */
-    public TransactionInput(NetworkParameters params, Transaction parentTransaction,
-                            byte[] payload, int offset) throws ProtocolException {
+    public TransactionInput(NetworkParameters params, @Nullable Transaction parentTransaction, byte[] payload, int offset) throws ProtocolException {
         super(params, payload, offset);
-        setParent(checkNotNull(parentTransaction));
+        setParent(parentTransaction);
         this.value = null;
     }
 

File: core/src/main/java/com/google/bitcoin/core/Block.java
Patch:
@@ -239,7 +239,7 @@ public int getOptimalEncodingMessageSize() {
         maybeParseTransactions();
         if (optimalEncodingMessageSize != 0)
             return optimalEncodingMessageSize;
-        optimalEncodingMessageSize = getMessageSize();
+        optimalEncodingMessageSize = bitcoinSerialize().length;
         return optimalEncodingMessageSize;
     }
 

File: core/src/main/java/com/google/bitcoin/crypto/MnemonicCode.java
Patch:
@@ -77,7 +77,7 @@ public MnemonicCode() throws IOException {
     private static InputStream openDefaultWords() throws IOException {
         InputStream stream = MnemonicCode.class.getResourceAsStream(BIP39_ENGLISH_RESOURCE_NAME);
         if (stream == null)
-            throw new FileNotFoundException(BIP39_ENGLISH_RESOURCE_NAME); // Handle Dalvik vs ART vs JVM divergence.
+            throw new FileNotFoundException(BIP39_ENGLISH_RESOURCE_NAME);
         return stream;
     }
 

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -222,6 +222,7 @@ public static void main(String[] args) throws Exception {
         OptionSpec<String> paymentRequestLocation = parser.accepts("payment-request").withRequiredArg();
         parser.accepts("no-pki");
         parser.accepts("tor");
+        parser.accepts("dump-privkeys");
         options = parser.parse(args);
 
         final String HELP_TEXT = Resources.toString(WalletTool.class.getResource("wallet-tool-help.txt"), Charsets.UTF_8);
@@ -1057,6 +1058,6 @@ private static void dumpWallet() throws BlockStoreException {
         // there just for the dump case.
         if (chainFileName.exists())
             setup();
-        System.out.println(wallet.toString(true, true, true, chain));
+        System.out.println(wallet.toString(options.has("dump-privkeys"), true, true, chain));
     }
 }

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -435,7 +435,7 @@ private void maybeUpgradeToHD(@Nullable KeyParameter aesKey) throws Deterministi
         if (keychain.isDeterministicUpgradeRequired()) {
             log.info("Upgrade to HD wallets is required, attempting to do so.");
             try {
-                upgradeToDeterministic(null);
+                upgradeToDeterministic(aesKey);
             } catch (DeterministicUpgradeRequiresPassword e) {
                 log.error("Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic " +
                         "with the users AES key to avoid this error.");

File: core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
Patch:
@@ -157,7 +157,7 @@ private KeyChainGroup(NetworkParameters params, @Nullable BasicKeyChain basicKey
         marriedKeysScripts = new LinkedHashMap<ByteString, Script>();
         maybeLookaheadScripts();
 
-        if (!this.currentKeys.isEmpty()) {
+        if (!this.followingKeychains.isEmpty()) {
             DeterministicKey followedWatchKey = getActiveKeyChain().getWatchingKey();
             for (Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry : this.currentKeys.entrySet()) {
                 Address address = makeP2SHOutputScript(entry.getValue(), followedWatchKey).getToAddress(params);

File: orchid/src/com/subgraph/orchid/circuits/TorInitializationTracker.java
Patch:
@@ -20,7 +20,7 @@ public class TorInitializationTracker {
 		messageMap.put(Tor.BOOTSTRAP_STATUS_HANDSHAKE_DIR, "Finishing handshake with directory server");
 		messageMap.put(Tor.BOOTSTRAP_STATUS_ONEHOP_CREATE, "Establishing an encrypted directory connection");
 		messageMap.put(Tor.BOOTSTRAP_STATUS_REQUESTING_STATUS, "Asking for network status consensus");
-		messageMap.put(Tor.BOOTSTRAP_STATUS_LOADING_STATUS, "Loading networkstatus consensus");
+		messageMap.put(Tor.BOOTSTRAP_STATUS_LOADING_STATUS, "Loading network status consensus");
 		messageMap.put(Tor.BOOTSTRAP_STATUS_REQUESTING_KEYS, "Asking for authority key certs");
 		messageMap.put(Tor.BOOTSTRAP_STATUS_LOADING_KEYS, "Loading authority key certs");
 		messageMap.put(Tor.BOOTSTRAP_STATUS_REQUESTING_DESCRIPTORS, "Asking for relay descriptors");

File: core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
Patch:
@@ -868,8 +868,6 @@ public String toString(boolean includePrivateKeys) {
                 for (ECKey key : chain.getKeys())
                     formatKeyWithAddress(includePrivateKeys, key, builder2);
             }
-            for (ECKey key : chain.getKeys())
-                formatKeyWithAddress(includePrivateKeys, key, builder2);
             chainStrs.add(builder2.toString());
         }
         builder.append(Joiner.on(String.format("%n")).join(chainStrs));

File: core/src/main/java/com/google/bitcoin/net/ConnectionHandler.java
Patch:
@@ -92,11 +92,11 @@ public ConnectionHandler(StreamParser parser, SelectionKey key, Set<ConnectionHa
         try {
             alreadyClosed = closeCalled;
             this.connectedHandlers = connectedHandlers;
+            if (!alreadyClosed)
+                checkState(connectedHandlers.add(this));
         } finally {
             lock.unlock();
         }
-        if (!alreadyClosed)
-            checkState(connectedHandlers.add(this));
     }
 
     @GuardedBy("lock")

File: core/src/main/java/com/google/bitcoin/core/PeerAddress.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.bitcoin.core;
 
 import com.google.bitcoin.params.MainNetParams;
+import com.google.common.net.InetAddresses;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -100,7 +101,7 @@ public PeerAddress(InetSocketAddress addr) {
     }
 
     public static PeerAddress localhost(NetworkParameters params) {
-        return new PeerAddress(InetAddress.getLoopbackAddress(), params.getPort());
+        return new PeerAddress(InetAddresses.forString("127.0.0.1"), params.getPort());
     }
 
     @Override

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.bitcoin.utils.Threading;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.common.net.InetAddresses;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
 import org.junit.After;
@@ -652,7 +653,7 @@ public void waitForPeersOfVersion() throws Exception {
     @Test
     public void preferLocalPeer() throws IOException {
         // Check that if we have a localhost port 8333 then it's used instead of the p2p network.
-        ServerSocket local = new ServerSocket(params.getPort(), 100, InetAddress.getLoopbackAddress());
+        ServerSocket local = new ServerSocket(params.getPort(), 100, InetAddresses.forString("127.0.0.1"));
         try {
             peerGroup.startAsync();
             peerGroup.awaitRunning();

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -1198,7 +1198,7 @@ public List<TransactionOutput> getOutputs() {
     /**
      * <p>Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
      * watched by a wallet, i.e., transaction outputs whose script's address is controlled by the wallet and transaction
-     * outputs whose script is watched by the wallet./p>
+     * outputs whose script is watched by the wallet.</p>
      *
      * @param wallet The wallet that controls addresses and watches scripts.
      * @return linked list of outputs relevant to the wallet in this transaction

File: core/src/main/java/com/google/bitcoin/script/Script.java
Patch:
@@ -459,7 +459,7 @@ public int getNumberOfBytesRequiredToSpend(@Nullable ECKey pubKey, @Nullable Scr
             // for N of M CHECKMULTISIG redeem script we will need N signatures to spend
             ScriptChunk nChunk = redeemScript.getChunks().get(0);
             int n = Script.decodeFromOpN(nChunk.opcode);
-            return n * SIG_SIZE + getProgram().length;
+            return n * SIG_SIZE + redeemScript.getProgram().length;
         } else if (isSentToMultiSig()) {
             // scriptSig: OP_0 <sig> [sig] [sig...]
             // for N of M CHECKMULTISIG script we will need N signatures to spend

File: core/src/main/java/com/google/bitcoin/crypto/BIP38PrivateKey.java
Patch:
@@ -96,8 +96,7 @@ public ECKey decrypt(String passphrase) throws BadPassphraseException {
 
     private ECKey decryptNoEC(String normalizedPassphrase) {
         try {
-            final byte[] passwd = normalizedPassphrase.getBytes(Charsets.UTF_8);
-            byte[] derived = SCrypt.scrypt(passwd, addressHash, 16384, 8, 8, 64);
+            byte[] derived = SCrypt.scrypt(normalizedPassphrase.getBytes(Charsets.UTF_8), addressHash, 16384, 8, 8, 64);
             byte[] key = Arrays.copyOfRange(derived, 32, 64);
             SecretKeySpec keyspec = new SecretKeySpec(key, "AES");
 

File: wallettemplate/src/main/java/wallettemplate/WalletSettingsController.java
Patch:
@@ -173,6 +173,7 @@ public void passwordButtonClicked(ActionEvent event) {
             Main.bitcoin.wallet().decrypt(aesKey);
             informationalAlert("Wallet decrypted", "A password will no longer be required to send money or edit settings.");
             passwordButton.setText("Set password");
+            aesKey = null;
         }
     }
 }

File: core/src/main/java/com/google/bitcoin/crypto/BIP38PrivateKey.java
Patch:
@@ -57,9 +57,9 @@ public BIP38PrivateKey(NetworkParameters params, String encoded) throws AddressF
         hasLotAndSequence = (bytes[1] & 0x04) != 0; // bit 2
         compressed = (bytes[1] & 0x20) != 0; // bit 5
         if ((bytes[1] & 0x01) != 0) // bit 0
-            throw new AddressFormatException("Bit 0x40 reserved for future use.");
+            throw new AddressFormatException("Bit 0x01 reserved for future use.");
         if ((bytes[1] & 0x02) != 0) // bit 1
-            throw new AddressFormatException("Bit 0x80 reserved for future use.");
+            throw new AddressFormatException("Bit 0x02 reserved for future use.");
         if ((bytes[1] & 0x08) != 0) // bit 3
             throw new AddressFormatException("Bit 0x08 reserved for future use.");
         if ((bytes[1] & 0x10) != 0) // bit 4

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1816,7 +1816,9 @@ public boolean maybeCommitTx(Transaction tx) throws VerificationException {
             tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);
             confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);
             addWalletTransaction(Pool.PENDING, tx);
-
+            // Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance the current key
+            // they are showing to the user in qr codes etc.
+            markKeysAsUsed(tx);
             try {
                 Coin valueSentFromMe = tx.getValueSentFromMe(this);
                 Coin valueSentToMe = tx.getValueSentToMe(this);

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -2443,7 +2443,7 @@ public void onKeysAdded(List<ECKey> k) {
             }
         }, Threading.SAME_THREAD);
         wallet.freshReceiveKey();
-        assertEquals(6, keys.size());
+        assertEquals(7, keys.size());
     }
 
     @Test

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -84,7 +84,7 @@ public int compare(final Transaction tx1, final Transaction tx2) {
     public static final int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC
 
     /** How many bytes a transaction can be before it won't be relayed anymore. Currently 100kb. */
-    public static final int MAX_STANDARD_TX_SIZE = 100 * 1024;
+    public static final int MAX_STANDARD_TX_SIZE = 100000;
 
     /**
      * If fee is lower than this value (in satoshis), a default reference client will treat it as if there were no fee.

File: core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java
Patch:
@@ -221,7 +221,7 @@ public boolean isChainFileLocked() throws IOException {
             FileLock lock = file2.getChannel().tryLock();
             if (lock == null)
                 return true;
-            lock.close();
+            lock.release();
             return false;
         } finally {
             if (file2 != null)

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -1513,7 +1513,7 @@ public void setBloomFilter(BloomFilter filter, boolean andQueryMemPool) {
         if (ver == null || !ver.isBloomFilteringSupported())
             return;
         vBloomFilter = filter;
-        log.info("{}: Sending Bloom filter{}", this, andQueryMemPool ? " and querying mempool" : "");
+        log.debug("{}: Sending Bloom filter{}", this, andQueryMemPool ? " and querying mempool" : "");
         sendMessage(filter);
         if (andQueryMemPool)
             sendMessage(new MemoryPoolMessage());

File: wallettemplate/src/main/java/wallettemplate/Controller.java
Patch:
@@ -91,6 +91,6 @@ public void onWalletChanged(Wallet wallet) {
 
     public void refreshBalanceLabel() {
         final Coin amount = bitcoin.wallet().getBalance(Wallet.BalanceType.ESTIMATED);
-        balance.setText(amount.toFriendlyString());
+        balance.setText(amount.toPlainString());
     }
 }

File: core/src/main/java/com/google/bitcoin/wallet/DeterministicSeed.java
Patch:
@@ -93,7 +93,7 @@ private static synchronized MnemonicCode getCachedMnemonicCodec() {
      * @param creationTimeSeconds When the seed was originally created, UNIX time.
      */
     public DeterministicSeed(List<String> mnemonicCode, String passphrase, long creationTimeSeconds) {
-        this(getCachedMnemonicCodec().toSeed(mnemonicCode, passphrase), mnemonicCode, creationTimeSeconds);
+        this(MnemonicCode.toSeed(mnemonicCode, passphrase), mnemonicCode, creationTimeSeconds);
     }
 
     /**
@@ -125,7 +125,7 @@ public DeterministicSeed(byte[] entropy, String passphrase, long creationTimeSec
             // cannot happen
             throw new RuntimeException(e);
         }
-        this.seed = getCachedMnemonicCodec().toSeed(mnemonicCode, passphrase);
+        this.seed = MnemonicCode.toSeed(mnemonicCode, passphrase);
         this.encryptedMnemonicCode = null;
         this.creationTimeSeconds = creationTimeSeconds;
     }

File: core/src/test/java/com/google/bitcoin/utils/ExponentialBackoffTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.core.utils;
+package com.google.bitcoin.utils;
 
 import com.google.bitcoin.core.Utils;
 import com.google.bitcoin.utils.ExponentialBackoff;

File: core/src/main/java/com/google/bitcoin/core/Coin.java
Patch:
@@ -206,7 +206,7 @@ public long longValue() {
         return this.value;
     }
 
-    private static final CoinFormat FRIENDLY_FORMAT = CoinFormat.BTC.minDecimals(2).repeatOptionalDecimals(1, 6);
+    private static final CoinFormat FRIENDLY_FORMAT = CoinFormat.BTC.minDecimals(2).repeatOptionalDecimals(1, 6).noCode();
 
     /**
      * Returns the value as a 0.12 type string. More digits after the decimal place will be used
@@ -216,7 +216,7 @@ public String toFriendlyString() {
         return FRIENDLY_FORMAT.format(this).toString();
     }
 
-    private static final CoinFormat PLAIN_FORMAT = CoinFormat.BTC.minDecimals(0).repeatOptionalDecimals(1, 8);
+    private static final CoinFormat PLAIN_FORMAT = CoinFormat.BTC.minDecimals(0).repeatOptionalDecimals(1, 8).noCode();
 
     /**
      * <p>

File: core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
Patch:
@@ -857,7 +857,7 @@ private void formatKeyWithAddress(boolean includePrivateKeys, ECKey key, StringB
         builder.append(address.toString());
         builder.append("  hash160:");
         builder.append(Utils.HEX.encode(key.getPubKeyHash()));
-        builder.append(" ");
+        builder.append("\n  ");
         builder.append(includePrivateKeys ? key.toStringWithPrivate() : key.toString());
         builder.append("\n");
     }

File: core/src/test/java/com/google/bitcoin/core/ECKeyTest.java
Patch:
@@ -318,8 +318,8 @@ public void testEncryptionIsReversible() throws Exception {
     public void testToString() throws Exception {
         ECKey key = ECKey.fromPrivate(BigInteger.TEN).decompress(); // An example private key.
 
-        assertEquals("pub:04a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7893aba425419bc27a3b6c7e693a24c696f794c2ed877a1593cbee53b037368d7", key.toString());
-        assertEquals("pub:04a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7893aba425419bc27a3b6c7e693a24c696f794c2ed877a1593cbee53b037368d7 priv:0a", key.toStringWithPrivate());
+        assertEquals("ECKey{pub=04a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7893aba425419bc27a3b6c7e693a24c696f794c2ed877a1593cbee53b037368d7, isEncrypted=false}", key.toString());
+        assertEquals("ECKey{pub=04a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7893aba425419bc27a3b6c7e693a24c696f794c2ed877a1593cbee53b037368d7, priv=0a, isEncrypted=false}", key.toStringWithPrivate());
     }
 
     @Test

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -1227,7 +1227,7 @@ private void blockChainDownloadLocked(Sha256Hash toHash) {
         //   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
         //
         // This is because it requires scanning all the block chain headers, which is very slow. Instead we add the top
-        // 50 block headers. If there is a re-org deeper than that, we'll end up downloading the entire chain. We
+        // 100 block headers. If there is a re-org deeper than that, we'll end up downloading the entire chain. We
         // must always put the genesis block as the first entry.
         BlockStore store = checkNotNull(blockChain).getBlockStore();
         StoredBlock chainHead = blockChain.getChainHead();

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -2400,6 +2400,7 @@ public void upgradeToHDUnencrypted() throws Exception {
         assertFalse(wallet.isDeterministicUpgradeRequired());
     }
 
+    @Test
     public void upgradeToHDEncrypted() throws Exception {
         // Create an old-style random wallet.
         wallet = new Wallet(params);
@@ -2411,7 +2412,7 @@ public void upgradeToHDEncrypted() throws Exception {
         wallet.encrypt(crypter, aesKey);
         try {
             wallet.freshReceiveKey();
-        } catch (DeterministicUpgradeRequiredException e) {
+        } catch (DeterministicUpgradeRequiresPassword e) {
             // Expected.
         }
         wallet.upgradeToDeterministic(aesKey);

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -1093,7 +1093,7 @@ public synchronized Sha256Hash hashForSignature(int inputIndex, byte[] connected
                 // that position are "nulled out". Unintuitively, the value in a "null" transaction is set to -1.
                 this.outputs = new ArrayList<TransactionOutput>(this.outputs.subList(0, inputIndex + 1));
                 for (int i = 0; i < inputIndex; i++)
-                    this.outputs.set(i, new TransactionOutput(params, this, Coin.NEGATIVE_ONE, new byte[] {}));
+                    this.outputs.set(i, new TransactionOutput(params, this, Coin.NEGATIVE_SATOSHI, new byte[] {}));
                 // The signature isn't broken by new versions of the transaction issued by other parties.
                 for (int i = 0; i < inputs.size(); i++)
                     if (i != inputIndex)

File: core/src/main/java/com/google/bitcoin/core/TransactionOutput.java
Patch:
@@ -112,7 +112,7 @@ public TransactionOutput(NetworkParameters params, @Nullable Transaction parent,
         super(params);
         // Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
         // SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
-        checkArgument(value.signum() >= 0 || value.equals(Coin.NEGATIVE_ONE), "Negative values not allowed");
+        checkArgument(value.signum() >= 0 || value.equals(Coin.NEGATIVE_SATOSHI), "Negative values not allowed");
         checkArgument(value.compareTo(NetworkParameters.MAX_MONEY) < 0, "Values larger than MAX_MONEY not allowed");
         this.value = value;
         this.scriptBytes = scriptBytes;

File: core/src/main/java/com/google/bitcoin/uri/BitcoinURI.java
Patch:
@@ -209,8 +209,10 @@ private void parseParameters(@Nullable NetworkParameters params, String addressT
                 // Decode the amount (contains an optional decimal component to 8dp).
                 try {
                     Coin amount = Coin.parseCoin(valueToken);
+                    if (amount.signum() < 0)
+                        throw new ArithmeticException("Negative coins specified");
                     putWithValidation(FIELD_AMOUNT, amount);
-                } catch (NumberFormatException e) {
+                } catch (IllegalArgumentException e) {
                     throw new OptionalFieldValidationException(String.format("'%s' is not a valid amount", valueToken), e);
                 } catch (ArithmeticException e) {
                     throw new OptionalFieldValidationException(String.format("'%s' has too many decimal places", valueToken), e);

File: core/src/main/java/com/google/bitcoin/crypto/DeterministicHierarchy.java
Patch:
@@ -95,7 +95,7 @@ public DeterministicKey get(List<ChildNumber> path, boolean relativePath, boolea
                 throw new IllegalArgumentException(String.format("No key found for %s path %s.",
                     relativePath ? "relative" : "absolute", HDUtils.formatPath(path)));
             checkArgument(absolutePath.size() > 0, "Can't derive the master key: nothing to derive from.");
-            DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), relativePath, true);
+            DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), false, true);
             putKey(HDKeyDerivation.deriveChildKey(parent, absolutePath.get(absolutePath.size() - 1)));
         }
         return keys.get(absolutePath);

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java
Patch:
@@ -252,7 +252,7 @@ public synchronized void initiate() throws ValueOutOfRangeException, Insufficien
         editContractSendRequest(req);
         req.shuffleOutputs = false;   // TODO: Fix things so shuffling is usable.
         wallet.completeTx(req);
-        Coin multisigFee = req.fee;
+        Coin multisigFee = req.tx.getFee();
         multisigContract = req.tx;
         // Build a refund transaction that protects us in the case of a bad server that's just trying to cause havoc
         // by locking up peoples money (perhaps as a precursor to a ransom attempt). We time lock it so the server

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -395,7 +395,7 @@ public synchronized ListenableFuture<Transaction> close() throws InsufficientMon
             // Let wallet handle adding additional inputs/fee as necessary.
             req.shuffleOutputs = false;
             wallet.completeTx(req);  // TODO: Fix things so shuffling is usable.
-            feePaidForPayment = req.fee;
+            feePaidForPayment = req.tx.getFee();
             log.info("Calculated fee is {}", feePaidForPayment);
             if (feePaidForPayment.compareTo(bestValueToMe) >= 0) {
                 final String msg = String.format("Had to pay more in fees (%s) than the channel was worth (%s)",

File: core/src/main/java/com/google/bitcoin/crypto/MnemonicCode.java
Patch:
@@ -78,7 +78,7 @@ public MnemonicCode(InputStream wordstream, String wordListDigest) throws IOExce
         // If a wordListDigest is supplied check to make sure it matches.
         if (wordListDigest != null) {
             byte[] digest = md.digest();
-            String hexdigest = new String(HEX.encode(digest));
+            String hexdigest = HEX.encode(digest);
             if (!hexdigest.equals(wordListDigest))
                 throw new IllegalArgumentException("wordlist digest mismatch");
         }

File: core/src/test/java/com/google/bitcoin/wallet/KeyChainGroupTest.java
Patch:
@@ -284,6 +284,7 @@ public void onKeysAdded(List<ECKey> keys) {
     @Test
     public void serialization() throws Exception {
         assertEquals(INITIAL_KEYS + 1 /* for the seed */, group.serializeToProtobuf().size());
+        group = KeyChainGroup.fromProtobufUnencrypted(group.serializeToProtobuf());
         group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
         DeterministicKey key1 = group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
         DeterministicKey key2 = group.freshKey(KeyChain.KeyPurpose.CHANGE);

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1036,7 +1036,7 @@ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundE
     
     /**
      * Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
-     * received by a call to @{link receivePending}.<p>
+     * received by a call to {@link #receivePending}.<p>
      *
      * This is necessary for the internal book-keeping Wallet does. When a transaction is received that sends us
      * coins it is added to a pool so we can use it later to create spends. When a transaction is received that

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1229,7 +1229,7 @@ public boolean isTransactionRelevant(Transaction tx) throws ScriptException {
 
     /**
      * Checks if "tx" is spending any inputs of pending transactions. Not a general check, but it can work even if
-     * the double spent inputs are not ours. Returns the pending tx that was double spent or null if none found.
+     * the double spent inputs are not ours.
      */
     private boolean checkForDoubleSpendAgainstPending(Transaction tx, boolean takeAction) {
         checkState(lock.isHeldByCurrentThread());

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1209,7 +1209,7 @@ public boolean isPendingTransactionRelevant(Transaction tx) throws ScriptExcepti
 
     /**
      * <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
-     * and if includeDoubleSpending is true, also returns true if tx has inputs that are spending outputs which are
+     * and also returns true if tx has inputs that are spending outputs which are
      * not ours but which are spent by pending transactions.</p>
      *
      * <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -225,7 +225,7 @@ public Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddr
      * used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
      */
     public Peer(NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion) {
-        this(params, new VersionMessage(params, blockChain.getBestChainHeight(), true), blockChain, peerAddress);
+        this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);
         this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, null);
     }
 

File: core/src/main/java/com/google/bitcoin/core/FullPrunedBlockChain.java
Patch:
@@ -224,7 +224,7 @@ protected TransactionOutputChanges connectTransactions(int height, Block block)
                 // All values were already checked for being non-negative (as it is verified in Transaction.verify())
                 // but we check again here just for defence in depth. Transactions with zero output value are OK.
                 if (valueOut.signum() < 0 || valueOut.compareTo(NetworkParameters.MAX_MONEY) > 0)
-                    throw new VerificationException("Transaction output value out of rage");
+                    throw new VerificationException("Transaction output value out of range");
                 if (isCoinBase) {
                     coinbaseValue = valueOut;
                 } else {
@@ -346,7 +346,7 @@ protected synchronized TransactionOutputChanges connectTransactions(StoredBlock
                     // All values were already checked for being non-negative (as it is verified in Transaction.verify())
                     // but we check again here just for defence in depth. Transactions with zero output value are OK.
                     if (valueOut.signum() < 0 || valueOut.compareTo(NetworkParameters.MAX_MONEY) > 0)
-                        throw new VerificationException("Transaction output value out of rage");
+                        throw new VerificationException("Transaction output value out of range");
                     if (isCoinBase) {
                         coinbaseValue = valueOut;
                     } else {

File: examples/src/main/java/com/google/bitcoin/examples/PrivateKeys.java
Patch:
@@ -39,9 +39,10 @@ public static void main(String[] args) throws Exception {
         NetworkParameters params = MainNetParams.get();
         try {
             // Decode the private key from Satoshis Base58 variant. If 51 characters long then it's from Bitcoins
-            // dumpprivkey command and includes a version byte and checksum. Otherwise assume it's a raw key.
+            // dumpprivkey command and includes a version byte and checksum, or if 52 characters long then it has 
+            // compressed pub key. Otherwise assume it's a raw key.
             ECKey key;
-            if (args[0].length() == 51) {
+            if (args[0].length() == 51 || args[0].length() == 52) {
                 DumpedPrivateKey dumpedPrivateKey = new DumpedPrivateKey(params, args[0]);
                 key = dumpedPrivateKey.getKey();
             } else {

File: core/src/main/java/com/google/bitcoin/core/AddressMessage.java
Patch:
@@ -8,7 +8,7 @@
 
 /**
  * Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers. This is
- * one of the ways peers can find each other without using the DNS or IRC discovery mechansisms. However storing and
+ * one of the ways peers can find each other without using the DNS or IRC discovery mechanisms. However storing and
  * using addr messages is not presently implemented.
  */
 public class AddressMessage extends Message {
@@ -20,7 +20,7 @@ public class AddressMessage extends Message {
     /**
      * Contruct a new 'addr' message.
      * @param params NetworkParameters object.
-     * @param offset The location of the first msg byte within the array.
+     * @param offset The location of the first payload byte within the array.
      * @param parseLazy Whether to perform a full parse immediately or delay until a read is requested.
      * @param parseRetain Whether to retain the backing byte array for quick reserialization.  
      * If true and the backing byte array is invalidated due to modification of a field then 
@@ -68,7 +68,7 @@ void parse() throws ProtocolException {
             throw new ProtocolException("Address message too large.");
         addresses = new ArrayList<PeerAddress>((int) numAddresses);
         for (int i = 0; i < numAddresses; i++) {
-            PeerAddress addr = new PeerAddress(params, bytes, cursor, protocolVersion, this, parseLazy, parseRetain);
+            PeerAddress addr = new PeerAddress(params, payload, cursor, protocolVersion, this, parseLazy, parseRetain);
             addresses.add(addr);
             cursor += addr.getMessageSize();
         }

File: core/src/main/java/com/google/bitcoin/core/EmptyMessage.java
Patch:
@@ -34,8 +34,8 @@ public EmptyMessage(NetworkParameters params) {
         length = 0;
     }
 
-    public EmptyMessage(NetworkParameters params, byte[] msg, int offset) throws ProtocolException {
-        super(params, msg, offset);
+    public EmptyMessage(NetworkParameters params, byte[] payload, int offset) throws ProtocolException {
+        super(params, payload, offset);
         length = 0;
     }
 

File: core/src/main/java/com/google/bitcoin/core/FilteredBlock.java
Patch:
@@ -53,10 +53,10 @@ public void bitcoinSerializeToStream(OutputStream stream) throws IOException {
     @Override
     void parse() throws ProtocolException {
         byte[] headerBytes = new byte[Block.HEADER_SIZE];
-        System.arraycopy(bytes, 0, headerBytes, 0, Block.HEADER_SIZE);
+        System.arraycopy(payload, 0, headerBytes, 0, Block.HEADER_SIZE);
         header = new Block(params, headerBytes);
         
-        merkleTree = new PartialMerkleTree(params, bytes, Block.HEADER_SIZE);
+        merkleTree = new PartialMerkleTree(params, payload, Block.HEADER_SIZE);
         
         length = Block.HEADER_SIZE + merkleTree.getMessageSize();
     }

File: core/src/main/java/com/google/bitcoin/core/GetBlocksMessage.java
Patch:
@@ -38,8 +38,8 @@ public GetBlocksMessage(NetworkParameters params, List<Sha256Hash> locator, Sha2
         this.stopHash = stopHash;
     }
 
-    public GetBlocksMessage(NetworkParameters params, byte[] msg) throws ProtocolException {
-        super(params, msg, 0);
+    public GetBlocksMessage(NetworkParameters params, byte[] payload) throws ProtocolException {
+        super(params, payload, 0);
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/GetDataMessage.java
Patch:
@@ -30,7 +30,7 @@ public GetDataMessage(NetworkParameters params, byte[] payloadBytes) throws Prot
     /**
      * Deserializes a 'getdata' message.
      * @param params NetworkParameters object.
-     * @param msg Bitcoin protocol formatted byte array containing message content.
+     * @param payload Bitcoin protocol formatted byte array containing message content.
      * @param parseLazy Whether to perform a full parse immediately or delay until a read is requested.
      * @param parseRetain Whether to retain the backing byte array for quick reserialization.  
      * If true and the backing byte array is invalidated due to modification of a field then 
@@ -39,9 +39,9 @@ public GetDataMessage(NetworkParameters params, byte[] payloadBytes) throws Prot
      * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
      * @throws ProtocolException
      */
-    public GetDataMessage(NetworkParameters params, byte[] msg, boolean parseLazy, boolean parseRetain, int length)
+    public GetDataMessage(NetworkParameters params, byte[] payload, boolean parseLazy, boolean parseRetain, int length)
             throws ProtocolException {
-        super(params, msg, parseLazy, parseRetain, length);
+        super(params, payload, parseLazy, parseRetain, length);
     }
 
     public GetDataMessage(NetworkParameters params) {

File: core/src/main/java/com/google/bitcoin/core/GetHeadersMessage.java
Patch:
@@ -29,8 +29,8 @@ public GetHeadersMessage(NetworkParameters params, List<Sha256Hash> locator, Sha
         super(params, locator, stopHash);
     }
 
-    public GetHeadersMessage(NetworkParameters params, byte[] msg) throws ProtocolException {
-        super(params, msg);
+    public GetHeadersMessage(NetworkParameters params, byte[] payload) throws ProtocolException {
+        super(params, payload);
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/InventoryMessage.java
Patch:
@@ -34,7 +34,7 @@ public InventoryMessage(NetworkParameters params, byte[] bytes) throws ProtocolE
     /**
      * Deserializes an 'inv' message.
      * @param params NetworkParameters object.
-     * @param msg Bitcoin protocol formatted byte array containing message content.
+     * @param payload Bitcoin protocol formatted byte array containing message content.
      * @param parseLazy Whether to perform a full parse immediately or delay until a read is requested.
      * @param parseRetain Whether to retain the backing byte array for quick reserialization.  
      * If true and the backing byte array is invalidated due to modification of a field then 
@@ -43,9 +43,9 @@ public InventoryMessage(NetworkParameters params, byte[] bytes) throws ProtocolE
      * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
      * @throws ProtocolException
      */
-    public InventoryMessage(NetworkParameters params, byte[] msg, boolean parseLazy, boolean parseRetain, int length)
+    public InventoryMessage(NetworkParameters params, byte[] payload, boolean parseLazy, boolean parseRetain, int length)
             throws ProtocolException {
-        super(params, msg, parseLazy, parseRetain, length);
+        super(params, payload, parseLazy, parseRetain, length);
     }
 
     public InventoryMessage(NetworkParameters params) {

File: core/src/main/java/com/google/bitcoin/core/TransactionOutPoint.java
Patch:
@@ -76,7 +76,7 @@ public TransactionOutPoint(NetworkParameters params, byte[] payload, int offset)
     /**
      * Deserializes the message. This is usually part of a transaction message.
      * @param params NetworkParameters object.
-     * @param offset The location of the first msg byte within the array.
+     * @param offset The location of the first payload byte within the array.
      * @param parseLazy Whether to perform a full parse immediately or delay until a read is requested.
      * @param parseRetain Whether to retain the backing byte array for quick reserialization.  
      * If true and the backing byte array is invalidated due to modification of a field then 

File: core/src/main/java/com/google/bitcoin/core/UnknownMessage.java
Patch:
@@ -27,7 +27,7 @@ public UnknownMessage(NetworkParameters params, String name, byte[] payloadBytes
 
     @Override
     public String toString() {
-        return "Unknown message [" + name + "]: " + (bytes == null ? "" : Utils.bytesToHexString(bytes));
+        return "Unknown message [" + name + "]: " + (payload == null ? "" : Utils.bytesToHexString(payload));
     }
 
 }

File: core/src/main/java/com/google/bitcoin/core/TransactionOutput.java
Patch:
@@ -92,7 +92,7 @@ public TransactionOutput(NetworkParameters params, @Nullable Transaction parent,
     /**
      * Creates an output that sends 'value' to the given address (public key hash). The amount should be created with
      * something like {@link Utils#valueOf(int, int)}. Typically you would use
-     * {@link Transaction#addOutput(java.math.Coin, Address)} instead of creating a TransactionOutput directly.
+     * {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
      */
     public TransactionOutput(NetworkParameters params, @Nullable Transaction parent, Coin value, Address to) {
         this(params, parent, value, ScriptBuilder.createOutputScript(to).getProgram());
@@ -101,7 +101,7 @@ public TransactionOutput(NetworkParameters params, @Nullable Transaction parent,
     /**
      * Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses). The
      * amount should be created with something like {@link Utils#valueOf(int, int)}. Typically you would use
-     * {@link Transaction#addOutput(java.math.Coin, ECKey)} instead of creating an output directly.
+     * {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
      */
     public TransactionOutput(NetworkParameters params, @Nullable Transaction parent, Coin value, ECKey to) {
         this(params, parent, value, ScriptBuilder.createOutputScript(to).getProgram());

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -2141,7 +2141,7 @@ public static SendRequest to(Address destination, Coin value) {
          *
          * <p>Be careful to check the output's value is reasonable using
          * {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
-         * rejected by the network. Note that using {@link SendRequest#to(Address, java.math.Coin)} will result
+         * rejected by the network. Note that using {@link SendRequest#to(Address, Coin)} will result
          * in a smaller output, and thus the ability to use a smaller output value without rejection.</p>
          */
         public static SendRequest to(NetworkParameters params, ECKey destination, Coin value) {
@@ -2174,11 +2174,11 @@ public static SendRequest emptyWallet(Address destination) {
      * {@link Wallet#getChangeAddress()}, so you must have added at least one key.</p>
      *
      * <p>If you just want to send money quickly, you probably want
-     * {@link Wallet#sendCoins(TransactionBroadcaster, Address, java.math.Coin)} instead. That will create the sending
+     * {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead. That will create the sending
      * transaction, commit to the wallet and broadcast it to the network all in one go. This method is lower level
      * and lets you see the proposed transaction before anything is done with it.</p>
      *
-     * <p>This is a helper method that is equivalent to using {@link Wallet.SendRequest#to(Address, java.math.Coin)}
+     * <p>This is a helper method that is equivalent to using {@link Wallet.SendRequest#to(Address, Coin)}
      * followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
      * Note that this means a fee may be automatically added if required, if you want more control over the process,
      * just do those two steps yourself.</p>

File: core/src/main/java/com/google/bitcoin/protocols/channels/IPaymentChannelClient.java
Patch:
@@ -118,7 +118,7 @@ interface ClientConnection {
 
         /**
          * <p>Indicates the channel has been successfully opened and
-         * {@link com.google.bitcoin.protocols.channels.PaymentChannelClient#incrementPayment(java.math.Coin)}
+         * {@link com.google.bitcoin.protocols.channels.PaymentChannelClient#incrementPayment(Coin)}
          * may be called at will.</p>
          *
          * <p>Called while holding a lock on the {@link com.google.bitcoin.protocols.channels.PaymentChannelClient}

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientConnection.java
Patch:
@@ -120,7 +120,7 @@ public void connectionClosed(ProtobufParser<Protos.TwoWayChannelMessage> handler
      * an error before the channel has reached the open state.</p>
      *
      * <p>After this future completes successfully, you may call
-     * {@link PaymentChannelClientConnection#incrementPayment(java.math.Coin)} to begin paying the server.</p>
+     * {@link PaymentChannelClientConnection#incrementPayment(Coin)} to begin paying the server.</p>
      */
     public ListenableFuture<PaymentChannelClientConnection> getChannelOpenFuture() {
         return channelOpenFuture;

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java
Patch:
@@ -291,7 +291,7 @@ protected void editContractSendRequest(Wallet.SendRequest req) {
 
     /**
      * Returns the transaction that locks the money to the agreement of both parties. Do not mutate the result.
-     * Once this step is done, you can use {@link PaymentChannelClientState#incrementPaymentBy(java.math.Coin)} to
+     * Once this step is done, you can use {@link PaymentChannelClientState#incrementPaymentBy(Coin)} to
      * start paying the server.
      */
     public synchronized Transaction getMultisigContract() {

File: core/src/main/java/com/google/bitcoin/wallet/CoinSelection.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * Represents the results of a
- * {@link com.google.bitcoin.wallet.CoinSelector#select(java.math.Coin, java.util.LinkedList)} operation. A
+ * {@link com.google.bitcoin.wallet.CoinSelector#select(Coin, java.util.LinkedList)} operation. A
  * coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
  * Different coin selections could be produced by different coin selectors from the same input set, according
  * to their varying policies.

File: core/src/main/java/com/google/bitcoin/core/Sha256Hash.java
Patch:
@@ -34,7 +34,7 @@
  * A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly, allowing it to be used as keys in a
  * map. It also checks that the length is correct and provides a bit more type safety.
  */
-public class Sha256Hash implements Serializable, Comparable {
+public class Sha256Hash implements Serializable, Comparable<Sha256Hash> {
     private byte[] bytes;
     public static final Sha256Hash ZERO_HASH = new Sha256Hash(new byte[32]);
 
@@ -128,8 +128,7 @@ public Sha256Hash duplicate() {
     }
 
     @Override
-    public int compareTo(Object o) {
-        checkArgument(o instanceof Sha256Hash);
+    public int compareTo(Sha256Hash o) {
         int thisCode = this.hashCode();
         int oCode = ((Sha256Hash)o).hashCode();
         return thisCode > oCode ? 1 : (thisCode == oCode ? 0 : -1);

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientConnection.java
Patch:
@@ -88,7 +88,7 @@ public void channelOpen(boolean wasInitiated) {
         // And glue back in the opposite direction - network to the channelClient.
         wireParser = new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>() {
             @Override
-            public void messageReceived(ProtobufParser handler, Protos.TwoWayChannelMessage msg) {
+            public void messageReceived(ProtobufParser<Protos.TwoWayChannelMessage> handler, Protos.TwoWayChannelMessage msg) {
                 try {
                     channelClient.receiveMessage(msg);
                 } catch (InsufficientMoneyException e) {
@@ -98,12 +98,12 @@ public void messageReceived(ProtobufParser handler, Protos.TwoWayChannelMessage
             }
 
             @Override
-            public void connectionOpen(ProtobufParser handler) {
+            public void connectionOpen(ProtobufParser<Protos.TwoWayChannelMessage> handler) {
                 channelClient.connectionOpen();
             }
 
             @Override
-            public void connectionClosed(ProtobufParser handler) {
+            public void connectionClosed(ProtobufParser<Protos.TwoWayChannelMessage> handler) {
                 channelClient.connectionClosed();
                 channelOpenFuture.setException(new PaymentChannelCloseException("The TCP socket died",
                         PaymentChannelCloseException.CloseReason.CONNECTION_CLOSED));

File: core/src/main/java/com/google/bitcoin/protocols/channels/ServerConnectionEventHandler.java
Patch:
@@ -29,10 +29,10 @@
  * {@link PaymentChannelServerListener}
 */
 public abstract class ServerConnectionEventHandler {
-    private ProtobufParser connectionChannel;
+    private ProtobufParser<Protos.TwoWayChannelMessage> connectionChannel;
     // Called by ServerListener before channelOpen to set connectionChannel when it is ready to received application messages
     // Also called with null to clear connectionChannel after channelClosed()
-    synchronized void setConnectionChannel(@Nullable ProtobufParser connectionChannel) { this.connectionChannel = connectionChannel; }
+    synchronized void setConnectionChannel(@Nullable ProtobufParser<Protos.TwoWayChannelMessage> connectionChannel) { this.connectionChannel = connectionChannel; }
 
     /**
      * <p>Closes the channel with the client (will generate a

File: core/src/main/java/com/google/bitcoin/crypto/DeterministicHierarchy.java
Patch:
@@ -52,6 +52,8 @@ public class DeterministicHierarchy implements Serializable {
     // Keep track of how many child keys each node has. This is kind of weak.
     private final Map<ImmutableList<ChildNumber>, ChildNumber> lastChildNumbers = Maps.newHashMap();
 
+    public static final int BIP32_STANDARDISATION_TIME_SECS = 1369267200;
+
     /**
      * Constructs a new hierarchy rooted at the given key. Note that this does not have to be the top of the tree.
      * You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.

File: core/src/main/java/com/google/bitcoin/crypto/DeterministicKey.java
Patch:
@@ -289,6 +289,9 @@ private BigInteger derivePrivateKeyDownwards(DeterministicKey cursor, byte[] par
         return checkNotNull(downCursor.priv);
     }
 
+    /**
+     * Derives a child at the given index (note: not the "i" value).
+     */
     public DeterministicKey derive(int child) {
         return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, true));
     }

File: core/src/main/java/com/google/bitcoin/wallet/DeterministicKeyChain.java
Patch:
@@ -553,6 +553,9 @@ public DeterministicKeyChain toDecrypted(KeyParameter aesKey) {
         checkState(seed.isEncrypted());
         DeterministicSeed decSeed = seed.decrypt(getKeyCrypter(), aesKey);
         DeterministicKeyChain chain = new DeterministicKeyChain(decSeed);
+        // Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
+        if (!chain.getWatchingKey().getPubKeyPoint().equals(getWatchingKey().getPubKeyPoint()))
+            throw new KeyCrypterException("Provided AES key is wrong");
         chain.lookaheadSize = lookaheadSize;
         // Now copy the (pubkey only) leaf keys across to avoid rederiving them. The private key bytes are missing
         // anyway so there's nothing to decrypt.

File: core/src/test/java/com/google/bitcoin/wallet/KeyChainGroupTest.java
Patch:
@@ -27,6 +27,7 @@
 import com.google.bitcoin.utils.Threading;
 import com.google.common.collect.ImmutableList;
 import org.bitcoinj.wallet.Protos;
+import org.junit.Before;
 import org.junit.Test;
 import org.spongycastle.crypto.params.KeyParameter;
 
@@ -43,7 +44,8 @@ public class KeyChainGroupTest {
     private static final int LOOKAHEAD_SIZE = 5;
     private KeyChainGroup group;
 
-    public KeyChainGroupTest() {
+    @Before
+    public void setup() {
         BriefLogFormatter.init();
         Utils.setMockClock();
         group = new KeyChainGroup();
@@ -92,7 +94,6 @@ public void imports() throws Exception {
     @Test
     public void findKey() throws Exception {
         ECKey a = group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
-        assertTrue(a instanceof DeterministicKey);
         ECKey b = group.freshKey(KeyChain.KeyPurpose.CHANGE);
         ECKey c = new ECKey();
         ECKey d = new ECKey();   // Not imported.

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -362,6 +362,9 @@ public Wallet readWallet(InputStream input) throws UnreadableWalletException {
      */
     public Wallet readWallet(NetworkParameters params, @Nullable WalletExtension[] extensions,
                              Protos.Wallet walletProto) throws UnreadableWalletException {
+        if (walletProto.getVersion() > 1)
+            throw new UnreadableWalletException.FutureVersion();
+
         // Read the scrypt parameters that specify how encryption and decryption is performed.
         KeyChainGroup chain;
         if (walletProto.hasEncryptionParameters()) {

File: core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java
Patch:
@@ -226,7 +226,7 @@ protected void startUp() throws Exception {
                     vWallet = new Wallet(params);
                     WalletExtension[] extArray = extensions.toArray(new WalletExtension[extensions.size()]);
                     Protos.Wallet proto = WalletProtobufSerializer.parseToProto(walletStream);
-                    new WalletProtobufSerializer().readWallet(params, extArray, proto);
+                    vWallet = new WalletProtobufSerializer().readWallet(params, extArray, proto);
                     if (shouldReplayWallet)
                         vWallet.clearTransactions(0);
                 } finally {

File: core/src/main/java/com/google/bitcoin/wallet/DeterministicKeyChain.java
Patch:
@@ -325,7 +325,7 @@ public int numKeys() {
 
     @Override
     public long getEarliestKeyCreationTime() {
-        return seed.getCreationTimeSeconds();
+        return seed != null ? seed.getCreationTimeSeconds() : Utils.currentTimeSeconds();
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.bitcoin.crypto.DeterministicKey;
 import com.google.bitcoin.crypto.KeyCrypter;
 import com.google.bitcoin.store.UnreadableWalletException;
+import com.google.bitcoin.utils.ListenerRegistration;
 import com.google.bitcoin.utils.Threading;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
@@ -85,6 +86,8 @@ private KeyChainGroup(@Nullable BasicKeyChain basicKeyChain, List<DeterministicK
 
     private void createAndActivateNewHDChain() {
         final DeterministicKeyChain chain = new DeterministicKeyChain(new SecureRandom());
+        for (ListenerRegistration<KeyChainEventListener> registration : basic.getListeners())
+            chain.addEventListener(registration.listener, registration.executor);
         if (lookaheadSize >= 0)
             chain.setLookaheadSize(lookaheadSize);
         chains.add(chain);

File: core/src/main/java/com/google/bitcoin/testing/TestWithWallet.java
Patch:
@@ -51,11 +51,10 @@ public class TestWithWallet {
     public void setUp() throws Exception {
         BriefLogFormatter.init();
         Wallet.SendRequest.DEFAULT_FEE_PER_KB = BigInteger.ZERO;
-        myKey = new ECKey();
-        myAddress = myKey.toAddress(params);
         wallet = new Wallet(params);
         wallet.setKeychainLookaheadSize(5);
-        wallet.importKey(myKey);
+        myKey = wallet.currentReceiveKey();
+        myAddress = myKey.toAddress(params);
         blockStore = new MemoryBlockStore(params);
         chain = new BlockChain(params, wallet, blockStore);
     }

File: core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java
Patch:
@@ -224,8 +224,9 @@ protected void startUp() throws Exception {
                 try {
                     List<WalletExtension> extensions = provideWalletExtensions();
                     vWallet = new Wallet(params);
+                    WalletExtension[] extArray = extensions.toArray(new WalletExtension[extensions.size()]);
                     Protos.Wallet proto = WalletProtobufSerializer.parseToProto(walletStream);
-                    new WalletProtobufSerializer().readWallet(params, (WalletExtension[]) extensions.toArray(), proto);
+                    new WalletProtobufSerializer().readWallet(params, extArray, proto);
                     if (shouldReplayWallet)
                         vWallet.clearTransactions(0);
                 } finally {

File: core/src/main/java/com/google/bitcoin/crypto/DeterministicKey.java
Patch:
@@ -157,8 +157,8 @@ public byte[] getPrivKeyBytes33() {
      */
     public DeterministicKey getPubOnly() {
         if (isPubKeyOnly()) return this;
-        final DeterministicKey parentPub = getParent() == null ? null : getParent().getPubOnly();
-        return new DeterministicKey(getPath(), getChainCode(), getPubKeyPoint(), null, parentPub);
+        //final DeterministicKey parentPub = getParent() == null ? null : getParent().getPubOnly();
+        return new DeterministicKey(getPath(), getChainCode(), getPubKeyPoint(), null, parent);
     }
 
 

File: core/src/main/java/com/google/bitcoin/crypto/HDUtils.java
Patch:
@@ -64,7 +64,7 @@ static byte[] longTo4ByteArray(long n) {
         return bytes;
     }
 
-    static ImmutableList<ChildNumber> append(ImmutableList<ChildNumber> path, ChildNumber childNumber) {
+    public static ImmutableList<ChildNumber> append(ImmutableList<ChildNumber> path, ChildNumber childNumber) {
         return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build();
     }
 

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChainListener.java
Patch:
@@ -41,7 +41,8 @@ public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBl
     }
 
     @Override
-    public void notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType,
-                                           int relativityOffset) throws VerificationException {
+    public boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType,
+                                              int relativityOffset) throws VerificationException {
+        return false;
     }
 }

File: core/src/main/java/com/google/bitcoin/jni/NativeBlockChainListener.java
Patch:
@@ -42,6 +42,6 @@ public native void receiveFromBlock(Transaction tx, StoredBlock block, BlockChai
                                         int relativityOffset) throws VerificationException;
 
     @Override
-    public native void notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType,
-                                                  int relativityOffset) throws VerificationException;
+    public native boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType,
+                                                     int relativityOffset) throws VerificationException;
 }

File: core/src/main/java/com/google/bitcoin/wallet/DefaultRiskAnalysis.java
Patch:
@@ -144,7 +144,7 @@ public static RuleViolation isStandard(Transaction tx) {
         for (int i = 0; i < inputs.size(); i++) {
             TransactionInput input = inputs.get(i);
             for (ScriptChunk chunk : input.getScriptSig().getChunks()) {
-                if (chunk.data != null && chunk.isShortestPossiblePushData()) {
+                if (chunk.data != null && !chunk.isShortestPossiblePushData()) {
                     log.warn("TX considered non-standard due to input {} having a longer than necessary data push: {}",
                             i, chunk);
                     return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;

File: core/src/main/java/com/google/bitcoin/net/ProtobufParser.java
Patch:
@@ -122,6 +122,9 @@ protected void timeoutOccurred() {
 
     // Deserializes and provides a listener event (buff must not have the length prefix in it)
     // Does set the buffers's position to its limit
+    @SuppressWarnings("unchecked")
+    // The warning 'unchecked cast' being suppressed here comes from the build() formally returning
+    // a MessageLite-derived class that cannot be statically guaranteed to be the MessageType.
     private void deserializeMessage(ByteBuffer buff) throws Exception {
         MessageType msg = (MessageType) prototype.newBuilderForType().mergeFrom(ByteString.copyFrom(buff)).build();
         resetTimeout();

File: core/src/main/java/com/google/bitcoin/store/PostgresFullPrunedBlockStore.java
Patch:
@@ -765,7 +765,7 @@ public void addUnspentTransactionOutput(StoredTransactionOutput out) throws Bloc
         // Calculate the toAddress (if any)
         String dbAddress = "";
         int type = 0;
-        Script  outputScript = null;
+        Script outputScript = null;
         try
         {
             outputScript = new Script(out.getScriptBytes());

File: examples/src/main/java/com/google/bitcoin/examples/PrintPeers.java
Patch:
@@ -82,7 +82,7 @@ public static void main(String[] args) throws Exception {
         for (final InetAddress addr : addrs) {
             InetSocketAddress address = new InetSocketAddress(addr, params.getPort());
             final Peer peer = new Peer(params, new VersionMessage(params, 0), null, new PeerAddress(address));
-            final SettableFuture future = SettableFuture.create();
+            final SettableFuture<Void> future = SettableFuture.create();
             // Once the connection has completed version handshaking ...
             peer.addEventListener(new AbstractPeerEventListener() {
                 public void onPeerConnected(Peer p, int peerCount) {

File: core/src/main/java/com/google/bitcoin/crypto/ChildNumber.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the first bit and a getter
- * for the actual 0-based child number. A {@link List} of these forms a <i>path</i> through a
+ * for the actual 0-based child number. A {@link java.util.List} of these forms a <i>path</i> through a
  * {@link DeterministicHierarchy}. This class is immutable.
  */
 public class ChildNumber {

File: core/src/main/java/com/google/bitcoin/crypto/EncryptedPrivateKey.java
Patch:
@@ -43,7 +43,7 @@ public EncryptedPrivateKey(EncryptedPrivateKey encryptedPrivateKey) {
     }
 
     /**
-     * @param iv
+     * @param initialisationVector
      * @param encryptedPrivateKeys
      */
     public EncryptedPrivateKey(byte[] initialisationVector, byte[] encryptedPrivateKeys) {

File: core/src/main/java/com/google/bitcoin/store/MemoryFullPrunedBlockStore.java
Patch:
@@ -168,8 +168,8 @@ public ValueType remove(KeyType key) {
 /**
  * A Map with multiple key types that is DB per-thread-transaction-aware.
  * However, this class is not thread-safe.
- * @param UniqueKeyType is a key that must be unique per object
- * @param MultiKeyType is a key that can have multiple values
+ * @param <UniqueKeyType> is a key that must be unique per object
+ * @param <MultiKeyType> is a key that can have multiple values
  */
 class TransactionalMultiKeyHashMap<UniqueKeyType, MultiKeyType, ValueType> {
     TransactionalHashMap<UniqueKeyType, ValueType> mapValues;

File: core/src/main/java/com/google/bitcoin/core/Block.java
Patch:
@@ -805,8 +805,8 @@ public void verify() throws VerificationException {
 
     @Override
     public boolean equals(Object o) {
-        if (!(o instanceof Block))
-            return false;
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
         Block other = (Block) o;
         return getHash().equals(other.getHash());
     }

File: core/src/main/java/com/google/bitcoin/core/PeerAddress.java
Patch:
@@ -246,13 +246,14 @@ public String toString() {
 
     @Override
     public boolean equals(Object o) {
-        if (!(o instanceof PeerAddress)) return false;
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
         PeerAddress other = (PeerAddress) o;
         return other.addr.equals(addr) &&
                 other.port == port &&
                 other.services.equals(services) &&
                 other.time == time;
-        //FIXME including services and time could cause same peer to be added multiple times in collections
+        //TODO: including services and time could cause same peer to be added multiple times in collections
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -89,7 +89,6 @@ public TransactionInput(NetworkParameters params, @Nullable Transaction parentTr
         scriptBytes = EMPTY_ARRAY;
         sequence = NO_SEQUENCE;
         this.parentTransaction = parentTransaction;
-
         length = 41;
     }
 

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -87,7 +87,7 @@ private void init(Stage mainWindow) throws IOException {
             // last months worth or more (takes a few seconds).
             bitcoin.setCheckpoints(getClass().getResourceAsStream("checkpoints"));
             // As an example!
-            bitcoin.useTor();
+            // bitcoin.useTor();
         }
 
         // Now configure and start the appkit. This will take a second or two - we could show a temporary splash screen

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1738,8 +1738,8 @@ public static SendRequest emptyWallet(Address destination) {
      * prevent this, but that should only occur once the transaction has been accepted by the network. This implies
      * you cannot have more than one outstanding sending tx at once.</p>
      *
-     * <p>You MUST ensure that nanocoins is larger than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
-     * almost certainly be rejected by the network as dust.</p>
+     * <p>You MUST ensure that nanocoins is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
+     * will almost certainly be rejected by the network as dust.</p>
      *
      * @param address       The Bitcoin address to send the money to.
      * @param nanocoins     How much currency to send, in nanocoins.
@@ -1788,7 +1788,7 @@ public Transaction sendCoinsOffline(SendRequest request) throws InsufficientMone
      * successfully broadcast. This means that even if the network hasn't heard about your transaction you won't be
      * able to spend those same coins again.</p>
      *
-     * <p>You MUST ensure that value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
+     * <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
      * almost certainly be rejected by the network as dust.</p>
      *
      * @param broadcaster a {@link TransactionBroadcaster} to use to send the transactions out.

File: core/src/main/java/com/google/bitcoin/utils/TaggableObject.java
Patch:
@@ -31,6 +31,6 @@ public interface TaggableObject {
     /** Associates the given immutable byte array with the string tag. See the docs for TaggableObject to learn more. */
     void setTag(String tag, ByteString value);
 
-    /** Returns a copy of all the tags held by this wallet. */
+    /** Returns a copy of all the tags held by this object. */
     public Map<String, ByteString> getTags();
 }

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -173,7 +173,7 @@ public void removeWallet(Wallet wallet) {
      * Adds a generic {@link BlockChainListener} listener to the chain.
      */
     public void addListener(BlockChainListener listener) {
-        addListener(listener, Threading.SAME_THREAD);
+        addListener(listener, Threading.USER_THREAD);
     }
 
     /**

File: core/src/main/java/com/google/bitcoin/protocols/payments/PaymentSession.java
Patch:
@@ -323,9 +323,11 @@ public Wallet.SendRequest getSendRequest() {
      * @param memo is a message to include in the payment message sent to the merchant.
      */
     public @Nullable Protos.Payment getPayment(List<Transaction> txns, @Nullable Address refundAddr, @Nullable String memo)
-            throws IOException {
+            throws IOException, PaymentRequestException.InvalidNetwork {
         if (!paymentDetails.hasPaymentUrl())
             return null;
+        if (!txns.get(0).getParams().equals(params))
+            throw new PaymentRequestException.InvalidNetwork(params.getPaymentProtocolId());
         Protos.Payment.Builder payment = Protos.Payment.newBuilder();
         if (paymentDetails.hasMerchantData())
             payment.setMerchantData(paymentDetails.getMerchantData());

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -3450,8 +3450,8 @@ public FeeCalculation(SendRequest req, BigInteger value, List<TransactionInput>
 
                 // Of the coins we could spend, pick some that we actually will spend.
                 CoinSelector selector = req.coinSelector == null ? coinSelector : req.coinSelector;
-                CoinSelection selection = selector.select(valueNeeded, candidates);
-                candidates = null;  // Selector took ownership and might have changed candidates. Don't access again.
+                // selector is allowed to modify candidates list.
+                CoinSelection selection = selector.select(valueNeeded, new LinkedList<TransactionOutput>(candidates));
                 // Can we afford this?
                 if (selection.valueGathered.compareTo(valueNeeded) < 0) {
                     valueMissing = valueNeeded.subtract(selection.valueGathered);

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -654,7 +654,8 @@ public synchronized void onChange() {
                 break;
 
         }
-        peers.startAsync();
+        if (!peers.isRunning())
+            peers.startAsync();
         try {
             latch.await();
         } catch (InterruptedException e) {

File: core/src/main/java/com/google/bitcoin/protocols/payments/PaymentSession.java
Patch:
@@ -176,7 +176,7 @@ private static ListenableFuture<PaymentSession> fetchPaymentRequest(final URI ur
             @Override
             public PaymentSession call() throws Exception {
                 HttpURLConnection connection = (HttpURLConnection)uri.toURL().openConnection();
-                connection.setRequestProperty("Accept", "application/bitcoin-paymentrequest");
+                connection.setRequestProperty("Accept", PaymentProtocol.MIMETYPE_PAYMENTREQUEST);
                 connection.setUseCaches(false);
                 Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.parseFrom(connection.getInputStream());
                 return new PaymentSession(paymentRequest, verifyPki, trustStoreLoader);
@@ -359,8 +359,8 @@ protected ListenableFuture<Ack> sendPayment(final URL url, final Protos.Payment
             public Ack call() throws Exception {
                 HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                 connection.setRequestMethod("POST");
-                connection.setRequestProperty("Content-Type", "application/bitcoin-payment");
-                connection.setRequestProperty("Accept", "application/bitcoin-paymentack");
+                connection.setRequestProperty("Content-Type", PaymentProtocol.MIMETYPE_PAYMENT);
+                connection.setRequestProperty("Accept", PaymentProtocol.MIMETYPE_PAYMENTACK);
                 connection.setRequestProperty("Content-Length", Integer.toString(payment.getSerializedSize()));
                 connection.setUseCaches(false);
                 connection.setDoInput(true);

File: core/src/test/java/com/google/bitcoin/crypto/X509UtilsTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.protocols.payments;
+package com.google.bitcoin.crypto;
 
 import com.google.bitcoin.crypto.X509Utils;
 import org.junit.Test;

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -704,7 +704,7 @@ private static void setup() throws BlockStoreException {
         } else {
             if (params == RegTestParams.get()) {
                 log.info("Assuming regtest node on localhost");
-                peers.addAddress(InetAddress.getLoopbackAddress());
+                peers.addAddress(PeerAddress.localhost(params));
             } else {
                 peers.addPeerDiscovery(new DnsDiscovery(params));
             }

File: core/src/test/java/com/google/bitcoin/core/BitcoindComparisonTool.java
Patch:
@@ -1,5 +1,6 @@
 /*
  * Copyright 2012 Matt Corallo.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -142,7 +143,7 @@ public boolean isRequiringUpdateAllBloomFilter() {
         bitcoindChainHead = params.getGenesisBlock().getHash();
         
         // Connect to bitcoind and make sure it has no blocks
-        peers.start();
+        peers.startAsync();
         peers.setMaxConnections(1);
         peers.downloadBlockChain();
         

File: examples/src/main/java/com/google/bitcoin/examples/ExamplePaymentChannelServer.java
Patch:
@@ -1,5 +1,6 @@
 /*
  * Copyright 2013 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -57,7 +58,8 @@ protected void addWalletExtensions() {
                 wallet().addExtension(storedStates);
             }
         };
-        appKit.startAndWait();
+        appKit.startAsync();
+        appKit.awaitRunning();
 
         System.out.println(appKit.wallet());
 

File: examples/src/main/java/com/google/bitcoin/examples/ForwardingService.java
Patch:
@@ -1,5 +1,6 @@
 /**
  * Copyright 2013 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -74,7 +75,8 @@ public static void main(String[] args) throws Exception {
         }
 
         // Download the block chain and wait until it's done.
-        kit.startAndWait();
+        kit.startAsync();
+        kit.awaitRunning();
 
         // We want to know when we receive money.
         kit.wallet().addEventListener(new AbstractWalletEventListener() {

File: examples/src/main/java/com/google/bitcoin/examples/PrivateKeys.java
Patch:
@@ -1,5 +1,6 @@
 /**
  * Copyright 2011 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -61,9 +62,9 @@ public static void main(String[] args) throws Exception {
 
             final PeerGroup peerGroup = new PeerGroup(params, chain);
             peerGroup.addAddress(new PeerAddress(InetAddress.getLocalHost()));
-            peerGroup.start();
+            peerGroup.startAsync();
             peerGroup.downloadBlockChain();
-            peerGroup.stop();
+            peerGroup.stopAsync();
 
             // And take them!
             System.out.println("Claiming " + Utils.bitcoinValueToFriendlyString(wallet.getBalance()) + " coins");

File: examples/src/main/java/com/google/bitcoin/examples/RefreshWallet.java
Patch:
@@ -1,5 +1,6 @@
 /*
  * Copyright 2011 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,7 +42,7 @@ public static void main(String[] args) throws Exception {
 
         final PeerGroup peerGroup = new PeerGroup(params, chain);
         peerGroup.addAddress(new PeerAddress(InetAddress.getLocalHost()));
-        peerGroup.start();
+        peerGroup.startAsync();
 
         wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
@@ -53,7 +54,7 @@ public synchronized void onCoinsReceived(Wallet w, Transaction tx, BigInteger pr
 
         // Now download and process the block chain.
         peerGroup.downloadBlockChain();
-        peerGroup.stop();
+        peerGroup.stopAsync();
         wallet.saveToFile(file);
         System.out.println("\nDone!\n");
         System.out.println(wallet.toString());

File: core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java
Patch:
@@ -127,9 +127,8 @@ private static RawKeyBytes deriveChildKeyBytes(DeterministicKey parent, ChildNum
         } else {
             checkArgument(!childNumber.isPrivateDerivation(), "Can't use private derivation with public keys only.");
             ECPoint Ki = ECKey.CURVE.getG().multiply(ilInt).add(parent.getPubPoint());
-            checkArgument(!Ki.equals(ECKey.CURVE.getCurve().getInfinity()),
-                    "Illegal derived key: derived public key equals infinity.");
-            keyBytes = HDUtils.toCompressed(Ki.getEncoded());
+            checkArgument(!Ki.isInfinity(), "Illegal derived key: derived public key equals infinity.");
+            keyBytes = Ki.getEncoded(true);
         }
         return new RawKeyBytes(keyBytes, chainCode);
     }

File: core/src/test/java/com/google/bitcoin/core/FullBlockTestGenerator.java
Patch:
@@ -1617,7 +1617,8 @@ public boolean add(Rule element) {
         // (finally) return the created chain
         return ret;
     }
-    
+
+    private byte uniquenessCounter = 0;
     private Block createNextBlock(Block baseBlock, int nextBlockHeight, TransactionOutPointWithValue prevOut,
             BigInteger additionalCoinbaseValue) throws ScriptException {
         Integer height = blockToHeightMap.get(baseBlock.getHash());
@@ -1634,7 +1635,7 @@ private Block createNextBlock(Block baseBlock, int nextBlockHeight, TransactionO
             t.addOutput(new TransactionOutput(params, t, BigInteger.valueOf(1),
                     ScriptBuilder.createOutputScript(new ECKey(null, coinbaseOutKeyPubKey)).getProgram()));
             // Spendable output
-            t.addOutput(new TransactionOutput(params, t, BigInteger.ZERO, new byte[] {OP_1}));
+            t.addOutput(new TransactionOutput(params, t, BigInteger.ZERO, new byte[] {OP_1, uniquenessCounter++}));
             addOnlyInputToTransaction(t, prevOut);
             block.addTransaction(t);
             block.solve();

File: core/src/test/java/com/google/bitcoin/core/ECKeyTest.java
Patch:
@@ -97,6 +97,9 @@ public ECKey.ECDSASignature call() throws Exception {
         for (ECKey.ECDSASignature signature : sigs) {
             assertTrue(signature.s.compareTo(ECKey.HALF_CURVE_ORDER) <= 0);
         }
+        final ECKey.ECDSASignature duplicate = new ECKey.ECDSASignature(sigs.get(0).r, sigs.get(0).s);
+        assertEquals(sigs.get(0), duplicate);
+        assertEquals(sigs.get(0).hashCode(), duplicate.hashCode());
     }
 
     @Test

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -658,7 +658,7 @@ protected void connectToAnyPeer() throws PeerDiscoveryException {
             if (retryTime > nowMillis) {
                 // Sleep until retry time
                 final long millis = retryTime - nowMillis;
-                log.info("Waiting {} msec before next connect attempt", millis, addr == null ? "" : " to " + addr);
+                log.info("Waiting {} msec before next connect attempt {}", millis, addr == null ? "" : " to " + addr);
                 Utils.sleep(millis);
             }
         }

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -500,9 +500,7 @@ public void shutdown() {
         stopPeerServer(2);
         assertEquals(2002, disconnectedPeers.take().getAddress().getPort()); // peer died
 
-        // Peer 2 is tried twice before peer 1, since it has a lower backoff due to recent success
-        Utils.passMockSleep();
-        assertEquals(2002, disconnectedPeers.take().getAddress().getPort());
+        // Peer 2 is tried before peer 1, since it has a lower backoff due to recent success
         Utils.passMockSleep();
         assertEquals(2002, disconnectedPeers.take().getAddress().getPort());
         Utils.passMockSleep();

File: core/src/test/java/com/google/bitcoin/core/ChainSplitTest.java
Patch:
@@ -52,6 +52,7 @@ public class ChainSplitTest {
     @Before
     public void setUp() throws Exception {
         BriefLogFormatter.init();
+        Utils.setMockClock(); // Use mock clock
         Wallet.SendRequest.DEFAULT_FEE_PER_KB = BigInteger.ZERO;
         unitTestParams = UnitTestParams.get();
         wallet = new Wallet(unitTestParams);

File: core/src/test/java/com/google/bitcoin/core/TransactionBroadcastTest.java
Patch:
@@ -52,6 +52,7 @@ public TransactionBroadcastTest(ClientType clientType) {
     @Override
     @Before
     public void setUp() throws Exception {
+        Utils.setMockClock(); // Use mock clock
         super.setUp(new MemoryBlockStore(UnitTestParams.get()));
         peerGroup.addWallet(wallet);
         // Fix the random permutation that TransactionBroadcast uses to shuffle the peers.

File: core/src/test/java/com/google/bitcoin/protocols/channels/ChannelConnectionTest.java
Patch:
@@ -63,6 +63,7 @@ public ListenableFuture<Transaction> broadcastTransaction(Transaction tx) {
     @Before
     public void setUp() throws Exception {
         super.setUp();
+        Utils.setMockClock(); // Use mock clock
         sendMoneyToWallet(Utils.COIN, AbstractBlockChain.NewBlockType.BEST_CHAIN);
         sendMoneyToWallet(Utils.COIN, AbstractBlockChain.NewBlockType.BEST_CHAIN);
         wallet.addExtension(new StoredPaymentChannelClientStates(wallet, failBroadcaster));

File: core/src/test/java/com/google/bitcoin/wallet/DefaultCoinSelectorTest.java
Patch:
@@ -39,6 +39,7 @@ public class DefaultCoinSelectorTest extends TestWithWallet {
     @Override
     public void setUp() throws Exception {
         super.setUp();
+        Utils.setMockClock(); // Use mock clock
     }
 
     @After

File: examples/src/main/java/com/google/bitcoin/examples/ForwardingService.java
Patch:
@@ -43,18 +43,18 @@ public class ForwardingService {
     public static void main(String[] args) throws Exception {
         // This line makes the log output more compact and easily read, especially when using the JDK log adapter.
         BriefLogFormatter.init();
-        if (args.length < 2) {
+        if (args.length < 1) {
             System.err.println("Usage: address-to-send-back-to [regtest|testnet]");
             return;
         }
 
         // Figure out which network we should connect to. Each one gets its own set of files.
         NetworkParameters params;
         String filePrefix;
-        if (args[1].equals("testnet")) {
+        if (args.length > 1 && args[1].equals("testnet")) {
             params = TestNet3Params.get();
             filePrefix = "forwarding-service-testnet";
-        } else if (args[1].equals("regtest")) {
+        } else if (args.length > 1 && args[1].equals("regtest")) {
             params = RegTestParams.get();
             filePrefix = "forwarding-service-regtest";
         } else {

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1620,7 +1620,7 @@ public static class SendRequest {
         /**
          * The AES key to use to decrypt the private keys before signing.
          * If null then no decryption will be performed and if decryption is required an exception will be thrown.
-         * You can get this from a password by doing wallet.getKeyCrypter().derivePassword(password).
+         * You can get this from a password by doing wallet.getKeyCrypter().deriveKey(password).
          */
         public KeyParameter aesKey = null;
 

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -805,11 +805,12 @@ public void recalculateFastCatchupAndFilter(FilterRecalculateMode mode) {
                 BloomFilter filter = new BloomFilter(lastBloomFilterElementCount, bloomFilterFPRate, bloomFilterTweak, bloomFlags);
                 for (PeerFilterProvider p : peerFilterProviders)
                     filter.merge(p.getBloomFilter(lastBloomFilterElementCount, bloomFilterFPRate, bloomFilterTweak));
-                bloomFilter = filter;
 
                 boolean changed = !filter.equals(bloomFilter);
                 boolean send = false;
 
+                bloomFilter = filter;
+
                 switch (mode) {
                     case SEND_IF_CHANGED: send = changed; break;
                     case DONT_SEND: send = false; break;

File: core/src/main/java/com/google/bitcoin/protocols/payments/PaymentSession.java
Patch:
@@ -1,5 +1,6 @@
 /**
  * Copyright 2013 Google Inc.
+ * Copyright 2014 Andreas Schildbach
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,6 +73,7 @@
  * tx itself later if needed.</p>
  *
  * @author Kevin Greene
+ * @author Andreas Schildbach
  * @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki">BIP 0070</a>
  */
 public class PaymentSession {
@@ -597,8 +599,6 @@ private void parsePaymentRequest(Protos.PaymentRequest request) throws PaymentRe
         try {
             if (request == null)
                 throw new PaymentRequestException("request cannot be null");
-            if (!request.hasPaymentDetailsVersion())
-                throw new PaymentRequestException.InvalidVersion("No version");
             if (request.getPaymentDetailsVersion() != 1)
                 throw new PaymentRequestException.InvalidVersion("Version 1 required. Received version " + request.getPaymentDetailsVersion());
             paymentRequest = request;

File: core/src/main/java/com/google/bitcoin/core/TransactionOutput.java
Patch:
@@ -52,7 +52,7 @@ public class TransactionOutput extends ChildMessage implements Serializable {
     // was owned by us and was sent to somebody else. If false and spentBy is set it means this output was owned by
     // us and used in one of our own transactions (eg, because it is a change output).
     private boolean availableForSpending;
-    private TransactionInput spentBy;
+    @Nullable private TransactionInput spentBy;
 
     // A reference to the transaction which holds this output.
     Transaction parentTransaction;
@@ -311,6 +311,7 @@ public String toString() {
     /**
      * Returns the connected input.
      */
+    @Nullable
     public TransactionInput getSpentBy() {
         return spentBy;
     }

File: core/src/test/java/com/google/bitcoin/core/MemoryFullPrunedBlockChainTest.java
Patch:
@@ -10,7 +10,7 @@
 public class MemoryFullPrunedBlockChainTest extends AbstractFullPrunedBlockChainTest
 {
     @Override
-    public FullPrunedBlockStore createStoreFromParamsAndBlockCount(NetworkParameters params, int blockCount) throws BlockStoreException
+    public FullPrunedBlockStore createStore(NetworkParameters params, int blockCount) throws BlockStoreException
     {
         return new MemoryFullPrunedBlockStore(params, blockCount);
     }

File: core/src/test/java/com/google/bitcoin/core/PostgresFullPrunedBlockChainTest.java
Patch:
@@ -18,7 +18,7 @@ public class PostgresFullPrunedBlockChainTest extends AbstractFullPrunedBlockCha
     private static final String DB_PASSWORD = "password";
 
     @Override
-    public FullPrunedBlockStore createStoreFromParamsAndBlockCount(NetworkParameters params, int blockCount)
+    public FullPrunedBlockStore createStore(NetworkParameters params, int blockCount)
             throws BlockStoreException {
         return new PostgresFullPrunedBlockStore(params, blockCount, DB_HOSTNAME, DB_NAME, DB_USERNAME, DB_PASSWORD);
     }

File: core/src/test/java/com/google/bitcoin/core/TestWithPeerGroup.java
Patch:
@@ -16,11 +16,10 @@
 
 package com.google.bitcoin.core;
 
-import com.google.bitcoin.params.UnitTestParams;
 import com.google.bitcoin.net.BlockingClientManager;
 import com.google.bitcoin.net.NioClientManager;
+import com.google.bitcoin.params.UnitTestParams;
 import com.google.bitcoin.store.BlockStore;
-import com.google.bitcoin.utils.ExponentialBackoff;
 import com.google.common.base.Preconditions;
 
 import java.net.InetSocketAddress;
@@ -50,7 +49,7 @@ public void setUp(BlockStore blockStore) throws Exception {
 
         remoteVersionMessage = new VersionMessage(unitTestParams, 1);
         remoteVersionMessage.localServices = VersionMessage.NODE_NETWORK;
-        remoteVersionMessage.clientVersion = FilteredBlock.MIN_PROTOCOL_VERSION;
+        remoteVersionMessage.clientVersion = NotFoundMessage.MIN_PROTOCOL_VERSION;
         initPeerGroup();
     }
 

File: core/src/main/java/com/google/bitcoin/protocols/payments/PaymentSession.java
Patch:
@@ -512,10 +512,9 @@ private KeyStore createKeyStore(@Nullable String path)
         }
         try {
             // Check if we are on Android.
-            Class Build = Class.forName("android.os.Build");
-            Object version = Build.getDeclaredField("VERSION").get(Build);
+            Class version = Class.forName("android.os.Build$VERSION");
             // Build.VERSION_CODES.ICE_CREAM_SANDWICH is 14.
-            if (version.getClass().getDeclaredField("SDK_INT").getInt(version) >= 14) {
+            if (version.getDeclaredField("SDK_INT").getInt(version) >= 14) {
                 // After ICS, Android provided this nice method for loading the keystore,
                 // so we don't have to specify the location explicitly.
                 KeyStore keystore = KeyStore.getInstance("AndroidCAStore");

File: core/src/test/java/com/google/bitcoin/core/TestWithNetworkConnections.java
Patch:
@@ -24,6 +24,8 @@
 import com.google.bitcoin.utils.Threading;
 import com.google.common.util.concurrent.SettableFuture;
 
+import javax.annotation.Nullable;
+import javax.net.SocketFactory;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.net.InetAddress;
@@ -32,7 +34,6 @@
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
-import javax.annotation.Nullable;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static org.junit.Assert.assertTrue;
@@ -152,7 +153,7 @@ public void onPeerDisconnected(Peer p, int peerCount) {
         else if (clientType == ClientType.NIO_CLIENT)
             new NioClient(new InetSocketAddress("127.0.0.1", 2000), peer, 100);
         else if (clientType == ClientType.BLOCKING_CLIENT)
-            new BlockingClient(new InetSocketAddress("127.0.0.1", 2000), peer, 100, null);
+            new BlockingClient(new InetSocketAddress("127.0.0.1", 2000), peer, 100, SocketFactory.getDefault(), null);
         else
             throw new RuntimeException();
         // Claim we are connected to a different IP that what we really are, so tx confidence broadcastBy sets work

File: core/src/main/java/com/google/bitcoin/core/FullPrunedBlockChain.java
Patch:
@@ -22,6 +22,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -124,6 +125,7 @@ public Verifier(final Transaction tx, final List<Script> prevOutScripts, final b
             this.tx = tx; this.prevOutScripts = prevOutScripts; this.enforcePayToScriptHash = enforcePayToScriptHash;
         }
 
+        @Nullable
         @Override
         public VerificationException call() throws Exception {
             try{

File: core/src/main/java/com/google/bitcoin/core/Message.java
Patch:
@@ -380,16 +380,14 @@ void bitcoinSerializeToStream(OutputStream stream) throws IOException {
      * so BitcoinSerializer can avoid 2 instanceof checks + a casting.
      */
     public Sha256Hash getHash() {
-        return null;
+        throw new UnsupportedOperationException();
     }
 
     /**
      * This should be overridden to extract correct message size in the case of lazy parsing.  Until this method is
      * implemented in a subclass of ChildMessage lazy parsing may have no effect.
      *
      * This default implementation is a safe fall back that will ensure it returns a correct value by parsing the message.
-     *
-     * @return
      */
     public int getMessageSize() {
         if (length != UNKNOWN_LENGTH)

File: core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.common.base.Objects;
 import org.spongycastle.util.encoders.Hex;
 
+import javax.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
 import java.io.Serializable;
 import java.math.BigInteger;
@@ -185,6 +186,7 @@ public int hashCode() {
     }
 
     /** Returns the network parameters for the given string ID or NULL if not recognized. */
+    @Nullable
     public static NetworkParameters fromID(String id) {
         if (id.equals(ID_MAINNET)) {
             return MainNetParams.get();

File: core/src/main/java/com/google/bitcoin/core/PeerEventListener.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.bitcoin.core;
 
+import javax.annotation.Nullable;
 import java.util.List;
 
 /**
@@ -85,5 +86,6 @@ public interface PeerEventListener {
      * <p>Note that this will never be called if registered with any executor other than
      * {@link com.google.bitcoin.utils.Threading#SAME_THREAD}</p>
      */
+    @Nullable
     public List<Message> getData(Peer peer, GetDataMessage m);
 }

File: core/src/main/java/com/google/bitcoin/core/VersionMessage.java
Patch:
@@ -218,14 +218,15 @@ public boolean equals(Object o) {
      */
     @Override
     byte[] getChecksum() {
-        return null;
+        throw new UnsupportedOperationException();
     }
 
     /**
      * VersionMessage does not handle cached byte array so should not have a cached checksum.
      */
     @Override
     void setChecksum(byte[] checksum) {
+        throw new UnsupportedOperationException();
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/net/BlockingClient.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.slf4j.LoggerFactory;
 
-import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -42,8 +41,8 @@ public class BlockingClient implements MessageWriteTarget {
     private static final int BUFFER_SIZE_LOWER_BOUND = 4096;
     private static final int BUFFER_SIZE_UPPER_BOUND = 65536;
 
-    @Nonnull private final ByteBuffer dbuf;
-    @Nonnull private final Socket socket;
+    private final ByteBuffer dbuf;
+    private final Socket socket;
     private volatile boolean vCloseRequested = false;
 
     /**

File: core/src/main/java/com/google/bitcoin/net/discovery/SeedPeers.java
Patch:
@@ -17,6 +17,7 @@
 
 import com.google.bitcoin.core.NetworkParameters;
 
+import javax.annotation.Nullable;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
@@ -42,6 +43,7 @@ public SeedPeers(NetworkParameters params) {
      * @return InetSocketAddress - The address/port of the next node.
      * @throws PeerDiscoveryException
      */
+    @Nullable
     public InetSocketAddress getPeer() throws PeerDiscoveryException {
         try {
             return nextPeer();
@@ -50,6 +52,7 @@ public InetSocketAddress getPeer() throws PeerDiscoveryException {
         }
     }
 
+    @Nullable
     private InetSocketAddress nextPeer() throws UnknownHostException {
         if (pnseedIndex >= seedAddrs.length) return null;
         return new InetSocketAddress(convertAddress(seedAddrs[pnseedIndex++]),

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -303,7 +303,7 @@ public synchronized boolean incrementPayment(BigInteger refundSize, byte[] signa
         // was not connected to the peergroup when the contract was broadcast (which may cause issues down the road, and
         // disables our double-spend check next)
         Transaction walletContract = wallet.getTransaction(multisigContract.getHash());
-        checkState(walletContract != null, "Wallet did not contain multisig contract {} after state was marked READY", multisigContract.getHash());
+        checkNotNull(walletContract, "Wallet did not contain multisig contract {} after state was marked READY", multisigContract.getHash());
 
         // Note that we check for DEAD state here, but this test is essentially useless in production because we will
         // miss most double-spends due to bloom filtering right now anyway. This will eventually fixed by network-wide

File: core/src/main/java/com/google/bitcoin/protocols/channels/ServerConnectionEventHandler.java
Patch:
@@ -22,6 +22,8 @@
 import com.google.bitcoin.net.ProtobufParser;
 import org.bitcoin.paymentchannel.Protos;
 
+import javax.annotation.Nullable;
+
 /**
 * A connection-specific event handler that handles events generated by client connections on a
  * {@link PaymentChannelServerListener}
@@ -30,7 +32,7 @@ public abstract class ServerConnectionEventHandler {
     private ProtobufParser connectionChannel;
     // Called by ServerListener before channelOpen to set connectionChannel when it is ready to received application messages
     // Also called with null to clear connectionChannel after channelClosed()
-    synchronized void setConnectionChannel(ProtobufParser connectionChannel) { this.connectionChannel = connectionChannel; }
+    synchronized void setConnectionChannel(@Nullable ProtobufParser connectionChannel) { this.connectionChannel = connectionChannel; }
 
     /**
      * <p>Closes the channel with the client (will generate a

File: core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelClientStates.java
Patch:
@@ -141,6 +141,7 @@ StoredClientChannel getUsableChannelForServerID(Sha256Hash id) {
     /**
      * Finds a channel with the given id and contract hash and returns it, or returns null.
      */
+    @Nullable
     StoredClientChannel getChannel(Sha256Hash id, Sha256Hash contractHash) {
         lock.lock();
         try {

File: core/src/main/java/com/google/bitcoin/protocols/channels/StoredServerChannel.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.bitcoin.core.*;
 
+import javax.annotation.Nullable;
 import java.math.BigInteger;
 import java.util.Date;
 
@@ -41,8 +42,8 @@ public class StoredServerChannel {
     private PaymentChannelServer connectedHandler = null;
     PaymentChannelServerState state = null;
 
-    StoredServerChannel(PaymentChannelServerState state, Transaction contract, TransactionOutput clientOutput,
-                        long refundTransactionUnlockTimeSecs, ECKey myKey, BigInteger bestValueToMe, byte[] bestValueSignature) {
+    StoredServerChannel(@Nullable PaymentChannelServerState state, Transaction contract, TransactionOutput clientOutput,
+                        long refundTransactionUnlockTimeSecs, ECKey myKey, BigInteger bestValueToMe, @Nullable byte[] bestValueSignature) {
         this.contract = contract;
         this.clientOutput = clientOutput;
         this.refundTransactionUnlockTimeSecs = refundTransactionUnlockTimeSecs;

File: core/src/main/java/com/google/bitcoin/wallet/KeyTimeCoinSelector.java
Patch:
@@ -25,6 +25,8 @@
 import java.math.BigInteger;
 import java.util.LinkedList;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * A coin selector that takes all coins assigned to keys created before the given timestamp.
  * Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
@@ -65,6 +67,7 @@ public CoinSelection select(BigInteger target, LinkedList<TransactionOutput> can
                     log.info("Skipping tx output {} because it's not of simple form.", output);
                     continue;
                 }
+                checkNotNull(controllingKey, "Coin selector given output as candidate for which we lack the key");
                 if (controllingKey.getCreationTimeSeconds() >= unixTimeSeconds) continue;
                 // It's older than the cutoff time so select.
                 valueGathered = valueGathered.add(output.getValue());

File: core/src/main/java/com/google/bitcoin/core/PeerAddress.java
Patch:
@@ -252,6 +252,7 @@ public boolean equals(Object o) {
                 other.port == port &&
                 other.services.equals(services) &&
                 other.time == time;
+        //FIXME including services and time could cause same peer to be added multiple times in collections
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -179,7 +179,7 @@ public void onPeerDisconnected(Peer peer, int peerCount) {
     private int lastBloomFilterElementCount;
 
     /** The default timeout between when a connection attempt begins and version message exchange completes */
-    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 2000;
+    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;
     private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;
 
     /**

File: core/src/main/java/com/google/bitcoin/net/ConnectionHandler.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.bitcoin.core.Message;
 import com.google.bitcoin.utils.Threading;
+import com.google.common.base.Throwables;
 import org.slf4j.LoggerFactory;
 
 import javax.annotation.concurrent.GuardedBy;
@@ -222,7 +223,7 @@ else if (read == -1) { // Socket was closed
         } catch (Exception e) {
             // This can happen eg if the channel closes while the thread is about to get killed
             // (ClosedByInterruptException), or if handler.parser.receiveBytes throws something
-            log.error("Error handling SelectionKey: ", e);
+            log.error("Error handling SelectionKey: {}", Throwables.getRootCause(e).getMessage());
             handler.closeConnection();
         }
     }

File: core/src/test/java/com/google/bitcoin/net/NetworkAbstractionTests.java
Patch:
@@ -388,10 +388,8 @@ public void connectionClosed(ProtobufParser handler) {
         } catch (IllegalStateException e) {}
 
         // Override max size and make sure the server drops our connection
-        byte[] messageBytes5 = msg5.toByteArray();
         byte[] messageLength5 = new byte[4];
-        Utils.uint32ToByteArrayBE(messageBytes5.length, messageLength5, 0);
-        client.writeBytes(messageBytes5);
+        Utils.uint32ToByteArrayBE(msg5.toByteArray().length, messageLength5, 0);
         client.writeBytes(messageLength5);
 
         serverConnectionClosed.get();

File: core/src/main/java/com/google/bitcoin/networkabstraction/NioClientManager.java
Patch:
@@ -56,8 +56,8 @@ private void handleKey(SelectionKey key) throws IOException {
             try {
                 if (sc.finishConnect()) {
                     log.info("Successfully connected to {}", sc.socket().getRemoteSocketAddress());
-                    handler.parser.connectionOpened();
                     key.interestOps(SelectionKey.OP_READ).attach(handler);
+                    handler.parser.connectionOpened();
                 } else {
                     log.error("Failed to connect to {}", sc.socket().getRemoteSocketAddress());
                     handler.closeConnection(); // Failed to connect for some reason

File: core/src/main/java/com/google/bitcoin/networkabstraction/ConnectionHandler.java
Patch:
@@ -211,7 +211,7 @@ else if (read == -1) { // Socket was closed
         } catch (Exception e) {
             // This can happen eg if the channel closes while the thread is about to get killed
             // (ClosedByInterruptException), or if handler.parser.receiveBytes throws something
-            log.error("Error handling SelectionKey", e);
+            log.error("Error handling SelectionKey: " + e.getMessage());
             if (handler != null)
                 handler.closeConnection();
         }

File: core/src/main/java/com/google/bitcoin/networkabstraction/NioClientManager.java
Patch:
@@ -64,11 +64,11 @@ private void handleKey(SelectionKey key) throws IOException {
                 }
             } catch (IOException e) {
                 // Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself
-                log.error("Failed to connect with exception", e);
+                log.error("Failed to connect with exception: {}", e.getMessage());
                 handler.closeConnection();
             } catch (CancelledKeyException e) { // There is a race to get to interestOps after finishConnect() which may cause this
                 // Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself
-                log.error("Failed to connect with exception", e);
+                log.error("Failed to connect with exception: {}", e.getMessage());
                 handler.closeConnection();
             }
         } else // Process bytes read

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -975,7 +975,7 @@ public void watchingScripts() throws Exception {
         assertTrue(wallet.isPendingTransactionRelevant(t1));
     }
 
-    @Test
+    @Test(expected = InsufficientMoneyException.class)
     public void watchingScriptsConfirmed() throws Exception {
         ECKey key = new ECKey();
         Address watchedAddress = key.toAddress(params);
@@ -988,7 +988,7 @@ public void watchingScriptsConfirmed() throws Exception {
 
         // We can't spend watched balances
         Address notMyAddr = new ECKey().toAddress(params);
-        assertNull(wallet.createSend(notMyAddr, CENT));
+        wallet.createSend(notMyAddr, CENT);
     }
 
     @Test

File: core/src/main/java/com/google/bitcoin/params/MainNetParams.java
Patch:
@@ -31,9 +31,10 @@ public MainNetParams() {
         interval = INTERVAL;
         targetTimespan = TARGET_TIMESPAN;
         proofOfWorkLimit = Utils.decodeCompactBits(0x1d00ffffL);
-        acceptableAddressCodes = new int[] { 0 };
         dumpedPrivateKeyHeader = 128;
         addressHeader = 0;
+        p2shHeader = 5;
+        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         port = 8333;
         packetMagic = 0xf9beb4d9L;
         genesisBlock.setDifficultyTarget(0x1d00ffffL);

File: core/src/main/java/com/google/bitcoin/params/TestNet2Params.java
Patch:
@@ -32,10 +32,11 @@ public TestNet2Params() {
         packetMagic = 0xfabfb5daL;
         port = 18333;
         addressHeader = 111;
+        p2shHeader = 196;
+        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         interval = INTERVAL;
         targetTimespan = TARGET_TIMESPAN;
         proofOfWorkLimit = Utils.decodeCompactBits(0x1d0fffffL);
-        acceptableAddressCodes = new int[] { 111 };
         dumpedPrivateKeyHeader = 239;
         genesisBlock.setTime(1296688602L);
         genesisBlock.setDifficultyTarget(0x1d07fff8L);

File: core/src/main/java/com/google/bitcoin/params/TestNet3Params.java
Patch:
@@ -37,7 +37,8 @@ public TestNet3Params() {
         proofOfWorkLimit = Utils.decodeCompactBits(0x1d00ffffL);
         port = 18333;
         addressHeader = 111;
-        acceptableAddressCodes = new int[] { 111 };
+        p2shHeader = 196;
+        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         dumpedPrivateKeyHeader = 239;
         genesisBlock.setTime(1296688602L);
         genesisBlock.setDifficultyTarget(0x1d00ffffL);

File: core/src/main/java/com/google/bitcoin/params/UnitTestParams.java
Patch:
@@ -31,6 +31,8 @@ public UnitTestParams() {
         id = ID_UNITTESTNET;
         packetMagic = 0x0b110907;
         addressHeader = 111;
+        p2shHeader = 196;
+        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
         proofOfWorkLimit = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
         genesisBlock.setTime(System.currentTimeMillis() / 1000);
         genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
@@ -40,7 +42,6 @@ public UnitTestParams() {
         dumpedPrivateKeyHeader = 239;
         targetTimespan = 200000000;  // 6 years. Just a very big number.
         spendableCoinbaseDepth = 5;
-        acceptableAddressCodes = new int[] { 111 };
         subsidyDecreaseBlockCount = 100;
         dnsSeeds = null;
     }

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -795,7 +795,6 @@ public synchronized void signInputs(SigHash hashType, Wallet wallet) throws Scri
      * @param aesKey The AES key to use to decrypt the key before signing. Null if no decryption is required.
      */
     public synchronized void signInputs(SigHash hashType, Wallet wallet, @Nullable KeyParameter aesKey) throws ScriptException {
-        // TODO: This should be a method of the TransactionInput that (possibly?) operates with a copy of this object.
         Preconditions.checkState(inputs.size() > 0);
         Preconditions.checkState(outputs.size() > 0);
 

File: core/src/main/java/com/google/bitcoin/core/VerificationException.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.bitcoin.core;
 
 @SuppressWarnings("serial")
-public class VerificationException extends Exception {
+public class VerificationException extends RuntimeException {
     public VerificationException(String msg) {
         super(msg);
     }

File: core/src/main/java/com/google/bitcoin/protocols/channels/IPaymentChannelClient.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.bitcoin.protocols.channels;
 
+import com.google.bitcoin.core.InsufficientMoneyException;
 import com.google.common.util.concurrent.ListenableFuture;
 import org.bitcoin.paymentchannel.Protos;
 
@@ -31,7 +32,7 @@ public interface IPaymentChannelClient {
      * Called when a message is received from the server. Processes the given message and generates events based on its
      * content.
      */
-    void receiveMessage(Protos.TwoWayChannelMessage msg) throws ValueOutOfRangeException;
+    void receiveMessage(Protos.TwoWayChannelMessage msg) throws InsufficientMoneyException;
 
     /**
      * <p>Called when the connection to the server terminates.</p>

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientConnection.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.bitcoin.protocols.channels;
 
 import com.google.bitcoin.core.ECKey;
+import com.google.bitcoin.core.InsufficientMoneyException;
 import com.google.bitcoin.core.Sha256Hash;
 import com.google.bitcoin.core.Wallet;
 import com.google.bitcoin.protocols.niowrapper.NioClient;
@@ -89,7 +90,7 @@ public void channelOpen(boolean wasInitiated) {
             public void messageReceived(ProtobufParser handler, Protos.TwoWayChannelMessage msg) {
                 try {
                     channelClient.receiveMessage(msg);
-                } catch (ValueOutOfRangeException e) {
+                } catch (InsufficientMoneyException e) {
                     // We should only get this exception during INITIATE, so channelOpen wasn't called yet.
                     channelOpenFuture.setException(e);
                 }

File: core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelServerStates.java
Patch:
@@ -84,7 +84,7 @@ public void closeChannel(StoredServerChannel channel) {
             channel.closeConnectedHandler();
             try {
                 channel.getOrCreateState(wallet, broadcaster).close();
-            } catch (ValueOutOfRangeException e) {
+            } catch (InsufficientMoneyException e) {
                 e.printStackTrace();
             } catch (VerificationException e) {
                 e.printStackTrace();

File: core/src/test/java/com/google/bitcoin/protocols/channels/ChannelConnectionTest.java
Patch:
@@ -559,7 +559,7 @@ public void testEmptyWallet() throws Exception {
                             .setMinPayment(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.longValue()))
                     .setType(MessageType.INITIATE).build());
             fail();
-        } catch (ValueOutOfRangeException expected) {
+        } catch (InsufficientMoneyException expected) {
             // This should be thrown.
         }
     }

File: examples/src/main/java/com/google/bitcoin/examples/ForwardingService.java
Patch:
@@ -139,6 +139,9 @@ public void run() {
         } catch (KeyCrypterException e) {
             // We don't use encrypted wallets in this example - can never happen.
             throw new RuntimeException(e);
+        } catch (InsufficientMoneyException e) {
+            // This should never happen - we're only trying to forward what we received!
+            throw new RuntimeException(e);
         }
     }
 }

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -688,7 +688,7 @@ private static void addKey() {
         }
         if (options.has("privkey")) {
             String data = (String) options.valueOf("privkey");
-            if (data.charAt(0) == 'L') {
+            if (data.startsWith("5J") || data.startsWith("5H") || data.startsWith("5K")) {
                 DumpedPrivateKey dpk;
                 try {
                     dpk = new DumpedPrivateKey(params, data);

File: core/src/test/java/com/google/bitcoin/core/FullPrunedBlockChainTest.java
Patch:
@@ -69,6 +69,7 @@ public void testGeneratedChain() throws Exception {
             if (!(rule instanceof BlockAndValidity))
                 continue;
             BlockAndValidity block = (BlockAndValidity) rule;
+            log.info("Testing rule " + block.ruleName + " with block hash " + block.block.getHash());
             boolean threw = false;
             try {
                 if (chain.add(block.block) != block.connects) {

File: core/src/test/java/com/google/bitcoin/core/PeerTest.java
Patch:
@@ -657,7 +657,7 @@ public void onCoinsReceived(Wallet wallet, Transaction tx, BigInteger prevBalanc
         Threading.waitForUserCode();
         assertNull(vtx[0]);
         // Now we want to hear about them. Send another, we are told about it.
-        wallet.setAcceptTimeLockedTransactions(true);
+        wallet.setAcceptRiskyTransactions(true);
         inbound(peer, t2);
         getdata = (GetDataMessage) outbound();
         if (useNotFound) {
@@ -702,7 +702,7 @@ private void checkTimeLockedDependency(boolean shouldAccept, boolean useNotFound
         ECKey key = new ECKey();
         Wallet wallet = new Wallet(unitTestParams);
         wallet.addKey(key);
-        wallet.setAcceptTimeLockedTransactions(shouldAccept);
+        wallet.setAcceptRiskyTransactions(shouldAccept);
         peer.addWallet(wallet);
         final Transaction[] vtx = new Transaction[1];
         wallet.addEventListener(new AbstractWalletEventListener() {

File: wallettemplate/src/main/java/wallettemplate/Main.java
Patch:
@@ -96,6 +96,7 @@ private void init(Stage mainWindow) throws IOException {
                .startAndWait();
         // Don't make the user wait for confirmations for now, as the intention is they're sending it their own money!
         bitcoin.wallet().allowSpendingUnconfirmedTransactions();
+        bitcoin.peerGroup().setMaxConnections(11);
         System.out.println(bitcoin.wallet());
         controller.onBitcoinSetup();
         mainWindow.show();

File: core/src/main/java/com/google/bitcoin/script/Script.java
Patch:
@@ -481,7 +481,7 @@ public static byte[] removeAllInstancesOf(byte[] inputScript, byte[] chunkToRemo
             if (opcode >= 0 && opcode < OP_PUSHDATA1) {
                 additionalBytes = opcode;
             } else if (opcode == OP_PUSHDATA1) {
-                additionalBytes = inputScript[cursor] + 1;
+                additionalBytes = (0xFF & inputScript[cursor]) + 1;
             } else if (opcode == OP_PUSHDATA2) {
                 additionalBytes = ((0xFF & inputScript[cursor]) |
                                   ((0xFF & inputScript[cursor+1]) << 8)) + 2;

File: core/src/main/java/com/google/bitcoin/params/RegTestParams.java
Patch:
@@ -32,7 +32,7 @@ public RegTestParams() {
         super();
         interval = 10000;
         proofOfWorkLimit = PROOF_OF_WORK_LIMIT;
-        subsidyDecreaseBlockCount = 10000;
+        subsidyDecreaseBlockCount = 150;
         port = 18444;
     }
 

File: core/src/main/java/com/google/bitcoin/script/ScriptChunk.java
Patch:
@@ -48,6 +48,9 @@ public boolean equalsOpCode(int opCode) {
         return isOpCode && data.length == 1 && (0xFF & data[0]) == opCode;
     }
 
+    /**
+     * If this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid Opcode)
+     */
     public boolean isOpCode() {
         return isOpCode;
     }

File: core/src/main/java/com/google/bitcoin/store/H2FullPrunedBlockStore.java
Patch:
@@ -686,17 +686,17 @@ public void addUnspentTransactionOutput(StoredTransactionOutput out) throws Bloc
 
     public void removeUnspentTransactionOutput(StoredTransactionOutput out) throws BlockStoreException {
         maybeConnect();
-        // TODO: This should only need one query (maybe a stored procedure)
-        if (getTransactionOutput(out.getHash(), out.getIndex()) == null)
-            throw new BlockStoreException("Tried to remove a StoredTransactionOutput from H2FullPrunedBlockStore that it didn't have!");
         try {
             PreparedStatement s = conn.get()
                 .prepareStatement("DELETE FROM openOutputs WHERE hash = ? AND index = ?");
             s.setBytes(1, out.getHash().getBytes());
             // index is actually an unsigned int
             s.setInt(2, (int)out.getIndex());
             s.executeUpdate();
+            int updateCount = s.getUpdateCount();
             s.close();
+            if (updateCount == 0)
+                throw new BlockStoreException("Tried to remove a StoredTransactionOutput from H2FullPrunedBlockStore that it didn't have!");
         } catch (SQLException e) {
             throw new BlockStoreException(e);
         }

File: core/src/main/java/com/google/bitcoin/core/FilteredBlock.java
Patch:
@@ -33,7 +33,7 @@ public class FilteredBlock extends Message {
     private PartialMerkleTree merkleTree;
     private List<Sha256Hash> cachedTransactionHashes = null;
     
-    // A set of transactions who's hashes are a subset of getTransactionHashes()
+    // A set of transactions whose hashes are a subset of getTransactionHashes()
     // These were relayed as a part of the filteredblock getdata, ie likely weren't previously received as loose transactions
     private Map<Sha256Hash, Transaction> associatedTransactions = new HashMap<Sha256Hash, Transaction>();
     

File: core/src/main/java/com/google/bitcoin/utils/TestWithWallet.java
Patch:
@@ -68,7 +68,7 @@ protected Transaction sendMoneyToWallet(Wallet wallet, Transaction tx, AbstractB
                 wallet.receivePending(tx, null);
         } else {
             TestUtils.BlockPair bp = createFakeBlock(blockStore, tx);
-            wallet.receiveFromBlock(tx, bp.storedBlock, type);
+            wallet.receiveFromBlock(tx, bp.storedBlock, type, 0);
             if (type == AbstractBlockChain.NewBlockType.BEST_CHAIN)
                 wallet.notifyNewBestBlock(bp.storedBlock);
         }

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -70,8 +70,9 @@ public void setUp() throws Exception {
         unitTestParams = UnitTestParams.get();
         wallet = new Wallet(unitTestParams) {
             @Override
-            public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType) throws VerificationException {
-                super.receiveFromBlock(tx, block, blockType);
+            public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType,
+                                         int relativityOffset) throws VerificationException {
+                super.receiveFromBlock(tx, block, blockType, relativityOffset);
                 BlockChainTest.this.block[0] = block;
                 if (tx.isCoinBase()) {
                     BlockChainTest.this.coinbaseTransaction = tx;

File: core/src/test/java/com/google/bitcoin/core/CoinbaseBlockTest.java
Patch:
@@ -75,7 +75,7 @@ public void testReceiveCoinbaseTransaction() throws Exception {
         // Give the wallet the first transaction in the block - this is the coinbase tx.
         List<Transaction> transactions = block.getTransactions();
         assertNotNull(transactions);
-        wallet.receiveFromBlock(transactions.get(0), storedBlock, NewBlockType.BEST_CHAIN);
+        wallet.receiveFromBlock(transactions.get(0), storedBlock, NewBlockType.BEST_CHAIN, 0);
 
         // Coinbase transaction should have been received successfully but be unavailable to spend (too young).
         assertEquals(BALANCE_AFTER_BLOCK, wallet.getBalance(BalanceType.ESTIMATED));

File: core/src/test/java/com/google/bitcoin/core/FilteredBlockAndPartialMerkleTreeTests.java
Patch:
@@ -121,7 +121,7 @@ public void serializeDownloadBlockWithWallet() throws Exception {
         for (Transaction tx : transactions) {
             assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);
             assertTrue(tx.getConfidence().getDepthInBlocks() == 1);
-            assertTrue(tx.getAppearsInHashes().contains(block.getHash()));
+            assertTrue(tx.getAppearsInHashes().keySet().contains(block.getHash()));
             assertTrue(tx.getAppearsInHashes().size() == 1);
         }
 

File: core/src/test/java/com/google/bitcoin/protocols/channels/PaymentChannelStateTest.java
Patch:
@@ -701,7 +701,7 @@ protected void editContractSendRequest(Wallet.SendRequest req) {
         // Now give the server enough coins to pay the fee
         StoredBlock block = new StoredBlock(makeSolvedTestBlock(blockStore, new ECKey().toAddress(params)), BigInteger.ONE, 1);
         Transaction tx1 = createFakeTx(params, Utils.COIN, serverKey.toAddress(params));
-        serverWallet.receiveFromBlock(tx1, block, AbstractBlockChain.NewBlockType.BEST_CHAIN);
+        serverWallet.receiveFromBlock(tx1, block, AbstractBlockChain.NewBlockType.BEST_CHAIN, 0);
 
         // The contract is still not worth redeeming - its worth less than we pay in fee
         try {
@@ -796,7 +796,7 @@ public void doubleSpendContractTest() throws Exception {
         doubleSpendContract = new Transaction(params, doubleSpendContract.bitcoinSerialize());
 
         StoredBlock block = new StoredBlock(params.getGenesisBlock().createNextBlock(myKey.toAddress(params)), BigInteger.TEN, 1);
-        serverWallet.receiveFromBlock(doubleSpendContract, block, AbstractBlockChain.NewBlockType.BEST_CHAIN);
+        serverWallet.receiveFromBlock(doubleSpendContract, block, AbstractBlockChain.NewBlockType.BEST_CHAIN, 0);
 
         // Now if we try to spend again the server will reject it since it saw a double-spend
         try {

File: core/src/test/java/com/google/bitcoin/store/WalletProtobufSerializerTest.java
Patch:
@@ -100,7 +100,7 @@ public void doubleSpend() throws Exception {
         // t1 spends to our wallet.
         myWallet.receivePending(doubleSpends.t1, null);
         // t2 rolls back t1 and spends somewhere else.
-        myWallet.receiveFromBlock(doubleSpends.t2, null, BlockChain.NewBlockType.BEST_CHAIN);
+        myWallet.receiveFromBlock(doubleSpends.t2, null, BlockChain.NewBlockType.BEST_CHAIN, 0);
         Wallet wallet1 = roundTrip(myWallet);
         assertEquals(1, wallet1.getTransactions(true).size());
         Transaction t1 = wallet1.getTransaction(doubleSpends.t1.getHash());

File: wallettemplate/src/main/java/wallettemplate/SendMoneyController.java
Patch:
@@ -45,7 +45,6 @@ public void send(ActionEvent event) {
             Futures.addCallback(sendResult.broadcastComplete, new FutureCallback<Transaction>() {
                 @Override
                 public void onSuccess(Transaction result) {
-                    // TODO: Fix bitcoinj so these callbacks run on the user thread.
                     Platform.runLater(overlayUi::done);
                 }
 

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -68,7 +68,7 @@ public class WalletTool {
             "  --chain=<file>       Specifies the name of the file that stores the block chain.\n" +
             "  --force              Overrides any safety checks on the requested action.\n" +
             "  --date               Provide a date in form YYYY/MM/DD to any action that requires one.\n" +
-            "  --peers=1.2.3.4      Comma separaterd IP addresses/domain names for connections instead of peer discovery.\n" +
+            "  --peers=1.2.3.4      Comma separated IP addresses/domain names for connections instead of peer discovery.\n" +
             "  --condition=...      Allows you to specify a numeric condition for other commands. The format is\n" +
             "                       one of the following operators = < > <= >= immediately followed by a number.\n" +
             "                       For example --condition=\">5.10\" or --condition=\"<=1\"\n" +

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClient.java
Patch:
@@ -298,13 +298,16 @@ private void receiveClose(Protos.TwoWayChannelMessage msg) throws VerificationEx
         checkState(lock.isHeldByCurrentThread());
         if (msg.hasClose()) {
             Transaction closeTx = new Transaction(wallet.getParams(), msg.getClose().getTx().toByteArray());
+            log.info("CLOSE message received with final contract {}", closeTx.getHash());
             // TODO: set source
             if (state != null && state().isCloseTransaction(closeTx)) {
                 // The wallet has a listener on it that the state object will use to do the right thing at this
                 // point (like watching it for confirmations). The tx has been checked by now for syntactical validity
                 // and that it correctly spends the multisig contract.
                 wallet.receivePending(closeTx, null);
             }
+        } else {
+            log.info("CLOSE message received without final contract");
         }
         if (step == InitStep.WAITING_FOR_CHANNEL_CLOSE)
             conn.destroyConnection(CloseReason.CLIENT_REQUESTED_CLOSE);

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServer.java
Patch:
@@ -319,8 +319,10 @@ public void onSuccess(Transaction result) {
                                         // properly and so on.
                                         msg.getCloseBuilder().setTx(ByteString.copyFrom(result.bitcoinSerialize()));
                                     }
+                                    log.info("Sending CLOSE back with finalized broadcast contract.");
                                     conn.sendToClient(msg.build());
-                                    conn.destroyConnection(CloseReason.CLIENT_REQUESTED_CLOSE);
+                                    // The client is expected to hang up the TCP connection after we send back the
+                                    // CLOSE message.
                                 }
 
                                 @Override

File: core/src/main/java/com/google/bitcoin/protocols/channels/ServerConnectionEventHandler.java
Patch:
@@ -23,7 +23,8 @@
 import org.bitcoin.paymentchannel.Protos;
 
 /**
-* A connection-specific event handler that handles events generated by client connections on a {@link PaymentChannelServerListener}
+* A connection-specific event handler that handles events generated by client connections on a
+ * {@link PaymentChannelServerListener}
 */
 public abstract class ServerConnectionEventHandler {
     private ProtobufParser connectionChannel;

File: core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java
Patch:
@@ -34,7 +34,7 @@ public final class HDKeyDerivation {
 
     private HDKeyDerivation() { }
 
-    private static final HMac MASTER_HMAC_SHA256 = HDUtils.createHmacSha256Digest("Bitcoin seed".getBytes());
+    private static final HMac MASTER_HMAC_SHA512 = HDUtils.createHmacSha512Digest("Bitcoin seed".getBytes());
 
     /**
      * Generates a new deterministic key from the given seed, which can be any arbitrary byte array. However resist
@@ -45,7 +45,7 @@ private HDKeyDerivation() { }
      */
     public static DeterministicKey createMasterPrivateKey(byte[] seed) throws HDDerivationException {
         // Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S)
-        byte[] i = HDUtils.hmacSha256(MASTER_HMAC_SHA256, seed);
+        byte[] i = HDUtils.hmacSha512(MASTER_HMAC_SHA512, seed);
         // Split I into two 32-byte sequences, Il and Ir.
         // Use Il as master secret key, and Ir as master chain code.
         checkState(i.length == 64, i.length);
@@ -108,7 +108,7 @@ private static RawKeyBytes deriveChildKeyBytes(DeterministicKey parent, ChildNum
             data.put(parentPublicKey);
         }
         data.putInt(childNumber.getI());
-        byte[] i = HDUtils.hmacSha256(parent.getChainCode(), data.array());
+        byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array());
         assert i.length == 64 : i.length;
         byte[] il = Arrays.copyOfRange(i, 0, 32);
         byte[] chainCode = Arrays.copyOfRange(i, 32, 64);

File: core/src/test/java/com/google/bitcoin/crypto/HDUtilsTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.google.bitcoin.crypto;
 
-import com.google.bitcoin.crypto.HDUtils;
 import org.junit.Assert;
 import org.junit.Test;
 import org.slf4j.Logger;
@@ -105,7 +104,7 @@ public void testHmac() throws Exception {
         };
 
         for (int i = 0; i < tv.length; i += 3) {
-            Assert.assertArrayEquals("Case " + i, getBytes(tv, i + 2), HDUtils.hmacSha256(getBytes(tv, i), getBytes(tv, i + 1)));
+            Assert.assertArrayEquals("Case " + i, getBytes(tv, i + 2), HDUtils.hmacSha512(getBytes(tv, i), getBytes(tv, i + 1)));
         }
     }
 

File: core/src/main/java/com/google/bitcoin/crypto/TransactionSignature.java
Patch:
@@ -55,7 +55,7 @@ public TransactionSignature(ECKey.ECDSASignature signature, Transaction.SigHash
      * real signature later.
      */
     public static TransactionSignature dummy() {
-        BigInteger val = BigInteger.ONE.shiftLeft(32 * 8);   // 32 byte signatures.
+        BigInteger val = BigInteger.ONE.shiftLeft(32 * 8);   // 32 byte components.
         return new TransactionSignature(val, val);
     }
 

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -1290,7 +1290,7 @@ public void onConfidenceChanged(Transaction tx, TransactionConfidence.Listener.C
                 // any peer discovery source and the user just calls connectTo() once.
                 if (minConnections == 1) {
                     sendComplete.addListener(new ChannelFutureListener() {
-                        public void operationComplete(ChannelFuture operation) throws Exception {
+                        public void operationComplete(ChannelFuture ignored) throws Exception {
                             for (Wallet wallet : wallets) {
                                 try {
                                     // Assumption here is there are no dependencies of the created transaction.

File: core/src/test/java/com/google/bitcoin/protocols/channels/PaymentChannelStateTest.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.bitcoin.script.Script;
 import com.google.bitcoin.script.ScriptBuilder;
 import com.google.bitcoin.utils.TestWithWallet;
+import com.google.bitcoin.wallet.DefaultCoinSelector;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
@@ -193,7 +194,7 @@ public void basic() throws Exception {
         // Create a block with the payment transaction in it and give it to both wallets
         chain.add(makeSolvedTestBlock(blockStore.getChainHead().getHeader(), new Transaction(params, closeTx.bitcoinSerialize())));
 
-        assertEquals(size.multiply(BigInteger.valueOf(5)), serverWallet.getBalance(new Wallet.DefaultCoinSelector() {
+        assertEquals(size.multiply(BigInteger.valueOf(5)), serverWallet.getBalance(new DefaultCoinSelector() {
             @Override
             protected boolean shouldSelect(Transaction tx) {
                 if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)
@@ -203,7 +204,7 @@ protected boolean shouldSelect(Transaction tx) {
         }));
         assertEquals(0, serverWallet.getPendingTransactions().size());
 
-        assertEquals(Utils.COIN.subtract(size.multiply(BigInteger.valueOf(5))), wallet.getBalance(new Wallet.DefaultCoinSelector() {
+        assertEquals(Utils.COIN.subtract(size.multiply(BigInteger.valueOf(5))), wallet.getBalance(new DefaultCoinSelector() {
             @Override
             protected boolean shouldSelect(Transaction tx) {
                 if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -1436,9 +1436,9 @@ public void feeSolverAndCoinSelectionTest() throws Exception {
         assertEquals(999, theoreticalMaxLength17);
         Transaction spend17 = request17.tx;
         {
-            // Its actual size must be between 997 and 999 (inclusive) as signatures have a 3-byte size range (almost always)
+            // Its actual size must be between 996 and 999 (inclusive) as signatures have a 3-byte size range (almost always)
             final int length = spend17.bitcoinSerialize().length;
-            assertTrue(Integer.toString(length), length >= 997 && length <= 999);
+            assertTrue(Integer.toString(length), length >= 996 && length <= 999);
         }
         // Now check that it got a fee of 1 since its max size is 999 (1kb).
         assertEquals(25, spend17.getOutputs().size());

File: core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java
Patch:
@@ -61,7 +61,8 @@ public static DeterministicKey createMasterPrivateKey(byte[] seed) throws HDDeri
     /**
      * @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
      */
-    static DeterministicKey createMasterPrivKeyFromBytes(byte[] privKeyBytes, byte[] chainCode) throws HDDerivationException {
+    public static DeterministicKey createMasterPrivKeyFromBytes(
+            byte[] privKeyBytes, byte[] chainCode) throws HDDerivationException {
         BigInteger privateKeyFieldElt = HDUtils.toBigInteger(privKeyBytes);
         assertNonZero(privateKeyFieldElt, "Generated master key is invalid.");
         assertLessThanN(privateKeyFieldElt, "Generated master key is invalid.");

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -396,6 +396,7 @@ public synchronized ListenableFuture<PaymentChannelServerState> close() throws V
             if (!wallet.completeTx(req)) // Let wallet handle adding additional inputs/fee as necessary.
                 throw new ValueOutOfRangeException("Unable to complete transaction - unable to pay required fee");
             feePaidForPayment = req.fee;
+            log.info("Calculated fee is {}", feePaidForPayment);
             if (feePaidForPayment.compareTo(bestValueToMe) >= 0)
                 throw new ValueOutOfRangeException(String.format("Had to pay more in fees (%s) than the channel was worth (%s)",
                         feePaidForPayment, bestValueToMe));

File: core/src/main/java/com/google/bitcoin/core/Message.java
Patch:
@@ -372,7 +372,7 @@ final public void bitcoinSerialize(OutputStream stream) throws IOException {
      * Serializes this message to the provided stream. If you just want the raw bytes use bitcoinSerialize().
      */
     void bitcoinSerializeToStream(OutputStream stream) throws IOException {
-        log.debug("Warning: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass());
+        log.error("Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass());
     }
 
     /**

File: core/src/main/java/com/google/bitcoin/protocols/niowrapper/NioServer.java
Patch:
@@ -88,7 +88,7 @@ public void run() {
                 } catch (Exception e) {
                     log.error("Error trying to open/read from connection: {}", e);
                 } finally {
-                    // Go through and close everything, without letting IOExceptions getting in our way
+                    // Go through and close everything, without letting IOExceptions get in our way
                     for (SelectionKey key : selector.keys()) {
                         try {
                             key.channel().close();

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -247,6 +247,7 @@ public void onConfidenceChanged(Transaction tx, TransactionConfidence.Listener.C
         });
         // A straggler reports in.
         inbound(p3, inv);
+        Threading.waitForUserCode();
         assertEquals(tx, event[1]);
         assertEquals(3, tx.getConfidence().numBroadcastPeers());
         assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p3).getAddress()));

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClient.java
Patch:
@@ -180,7 +180,7 @@ private void receiveRefund(Protos.TwoWayChannelMessage msg) throws VerificationE
 
     @GuardedBy("lock")
     private void receiveChannelOpen() throws VerificationException {
-        checkState(step == InitStep.WAITING_FOR_CHANNEL_OPEN || (step == InitStep.WAITING_FOR_INITIATE && storedChannel != null));
+        checkState(step == InitStep.WAITING_FOR_CHANNEL_OPEN || (step == InitStep.WAITING_FOR_INITIATE && storedChannel != null), step);
         log.info("Got CHANNEL_OPEN message, ready to pay");
 
         if (step == InitStep.WAITING_FOR_INITIATE)

File: core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelServerStates.java
Patch:
@@ -78,9 +78,9 @@ public void closeChannel(StoredServerChannel channel) {
             lock.unlock();
         }
         synchronized (channel) {
-            if (channel.connectedHandler != null) // connectedHandler will be reset to null in connectionClosed
-                channel.connectedHandler.close(); // Closes the actual connection, not the channel
-            try {//TODO add event listener to PaymentChannelServerStateManager
+            channel.closeConnectedHandler();
+            try {
+                //TODO add event listener to PaymentChannelServerStateManager
                 channel.getOrCreateState(wallet, broadcaster).close();
             } catch (ValueOutOfRangeException e) {
                 e.printStackTrace();

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1070,6 +1070,7 @@ private void updateForSpends(Transaction tx, boolean fromChain) throws Verificat
             if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
                 if (fromChain) {
                     // Double spend from chain: this will be handled later by checkForDoubleSpendAgainstPending.
+                    log.warn("updateForSpends: saw double spend from chain, handling later.");
                 } else {
                     // We saw two pending transactions that double spend each other. We don't know which will win.
                     // This should not happen.
@@ -1082,6 +1083,7 @@ private void updateForSpends(Transaction tx, boolean fromChain) throws Verificat
                 // The outputs are already marked as spent by the connect call above, so check if there are any more for
                 // us to use. Move if not.
                 Transaction connected = checkNotNull(input.getOutpoint().fromTx);
+                log.info("  marked {} as spent", input.getOutpoint());
                 maybeMovePool(connected, "prevtx");
             }
         }

File: core/src/main/java/com/google/bitcoin/params/MainNetParams.java
Patch:
@@ -39,7 +39,7 @@ public MainNetParams() {
         genesisBlock.setDifficultyTarget(0x1d00ffffL);
         genesisBlock.setTime(1231006505L);
         genesisBlock.setNonce(2083236893);
-        id = ID_PRODNET;
+        id = ID_MAINNET;
         subsidyDecreaseBlockCount = 210000;
         spendableCoinbaseDepth = 100;
         String genesisHash = genesisBlock.getHashAsString();

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java
Patch:
@@ -363,7 +363,7 @@ public synchronized void disconnectFromChannel() {
         StoredPaymentChannelClientStates channels = (StoredPaymentChannelClientStates)
                 wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);
         checkState(channels.getChannel(id, multisigContract.getHash()) == null);
-        storedChannel = new StoredClientChannel(id, multisigContract, refundTx, myKey, valueToMe, refundFees);
+        storedChannel = new StoredClientChannel(id, multisigContract, refundTx, myKey, valueToMe, refundFees, true);
         channels.putChannel(storedChannel);
         wallet.addOrUpdateExtension(channels);
     }

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -303,7 +303,7 @@ public synchronized void incrementPayment(BigInteger refundSize, byte[] signatur
         // was not connected to the peergroup when the contract was broadcast (which may cause issues down the road, and
         // disables our double-spend check next)
         Transaction walletContract = wallet.getTransaction(multisigContract.getHash());
-        checkState(walletContract != null, "Wallet did not contain multisig contract after state was marked READY");
+        checkState(walletContract != null, "Wallet did not contain multisig contract {} after state was marked READY", multisigContract.getHash());
 
         // Note that we check for DEAD state here, but this test is essentially useless in production because we will
         // miss most double-spends due to bloom filtering right now anyway. This will eventually fixed by network-wide

File: core/src/main/java/com/google/bitcoin/core/Address.java
Patch:
@@ -19,6 +19,8 @@
 import com.google.bitcoin.params.MainNetParams;
 import com.google.bitcoin.params.TestNet3Params;
 
+import javax.annotation.Nullable;
+
 /**
  * <p>A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
  * plus a set of network parameters. Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
@@ -57,7 +59,7 @@ public Address(NetworkParameters params, byte[] hash160) {
      * @throws AddressFormatException if the given address doesn't parse or the checksum is invalid
      * @throws WrongNetworkException if the given address is valid but for a different chain (eg testnet vs prodnet)
      */
-    public Address(NetworkParameters params, String address) throws AddressFormatException, WrongNetworkException {
+    public Address(@Nullable NetworkParameters params, String address) throws AddressFormatException, WrongNetworkException {
         super(address);
         if (params != null) {
             boolean found = false;

File: core/src/main/java/com/google/bitcoin/core/MemoryPool.java
Patch:
@@ -266,7 +266,7 @@ public void seen(Sha256Hash hash, PeerAddress byPeer) {
     }
 
     private void markBroadcast(PeerAddress byPeer, Transaction tx) {
-        checkState(lock.isLocked());
+        checkState(lock.isHeldByCurrentThread());
         final TransactionConfidence confidence = tx.getConfidence();
         confidence.markBroadcastBy(byPeer);
         confidence.queueListeners(TransactionConfidence.Listener.ChangeReason.SEEN_PEERS);

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -884,7 +884,7 @@ public void run() {
     }
 
     private void setupPingingForNewPeer(final Peer peer) {
-        checkState(lock.isLocked());
+        checkState(lock.isHeldByCurrentThread());
         if (peer.getPeerVersionMessage().clientVersion < Pong.MIN_PROTOCOL_VERSION)
             return;
         if (getPingIntervalMsec() <= 0)
@@ -930,7 +930,7 @@ public void run() {
     /** Returns true if at least one peer received an inv. */
     private boolean announcePendingWalletTransactions(List<Wallet> announceWallets,
                                                       List<Peer> announceToPeers) {
-        checkState(lock.isLocked());
+        checkState(lock.isHeldByCurrentThread());
         // Build up an inv announcing the hashes of all pending transactions in all our wallets.
         InventoryMessage inv = new InventoryMessage(params);
         for (Wallet w : announceWallets) {

File: core/src/test/java/com/google/bitcoin/store/WalletProtobufSerializerTest.java
Patch:
@@ -275,8 +275,8 @@ public void testExtensions() throws Exception {
         try {
             new WalletProtobufSerializer().readWallet(proto, wallet2);
             fail();
-        } catch (IllegalArgumentException e) {
-            // Expected.
+        } catch (UnreadableWalletException e) {
+            assertTrue(e.getMessage().contains("mandatory"));
         }
         Wallet wallet3 = new Wallet(params);
         // This time it works.

File: examples/src/main/java/com/google/bitcoin/examples/PingService.java
Patch:
@@ -24,13 +24,13 @@
 import com.google.bitcoin.params.TestNet3Params;
 import com.google.bitcoin.store.BlockStore;
 import com.google.bitcoin.store.SPVBlockStore;
+import com.google.bitcoin.store.UnreadableWalletException;
 import com.google.bitcoin.utils.BriefLogFormatter;
 import com.google.common.util.concurrent.FutureCallback;
 import com.google.common.util.concurrent.Futures;
 
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.IOException;
 import java.math.BigInteger;
 import java.net.InetAddress;
 
@@ -97,7 +97,7 @@ public PingService(String[] args) throws Exception {
             // Wipe the wallet if the chain file was deleted.
             if (walletFile.exists() && chainFile.exists())
                 w = Wallet.loadFromFile(walletFile);
-        } catch (IOException e) {
+        } catch (UnreadableWalletException e) {
             System.err.println("Couldn't load wallet: " + e);
             // Fall through.
         }

File: examples/src/main/java/com/google/bitcoin/examples/toywallet/ToyWallet.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.bitcoin.params.TestNet3Params;
 import com.google.bitcoin.store.H2FullPrunedBlockStore;
 import com.google.bitcoin.store.SPVBlockStore;
+import com.google.bitcoin.store.UnreadableWalletException;
 import com.google.bitcoin.utils.BriefLogFormatter;
 import com.google.common.collect.Lists;
 import org.spongycastle.util.encoders.Hex;
@@ -34,7 +35,6 @@
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;
 import java.io.File;
-import java.io.IOException;
 import java.math.BigInteger;
 import java.util.Date;
 import java.util.LinkedList;
@@ -125,7 +125,7 @@ public ToyWallet(boolean testnet, boolean fullChain, String[] args) throws Excep
         walletFile = new File("toy.wallet");
         try {
             wallet = Wallet.loadFromFile(walletFile);
-        } catch (IOException e) {
+        } catch (UnreadableWalletException e) {
             wallet = new Wallet(params);
 
             // Allow user to specify the first key on the command line as:

File: core/src/test/java/com/google/bitcoin/crypto/BIP32Test.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.bitcoin.crypto.hd;
+package com.google.bitcoin.crypto;
 
 import com.google.bitcoin.core.AddressFormatException;
 import com.google.bitcoin.core.Base58;

File: core/src/test/java/com/google/bitcoin/crypto/HDUtilsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.google.bitcoin.crypto.hd;
+package com.google.bitcoin.crypto;
 
 import com.google.bitcoin.crypto.HDUtils;
 import org.junit.Assert;

File: core/src/main/java/com/google/bitcoin/core/BloomFilter.java
Patch:
@@ -157,7 +157,7 @@ protected void parseLite() throws ProtocolException {
     }
 
     private int ROTL32 (int x, int r) {
-      return (x << r) | (x >>> (32 - r));
+        return (x << r) | (x >>> (32 - r));
     }
     
     private int hash(int hashNum, byte[] object) {

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -673,8 +673,8 @@ private void recalculateFastCatchupAndFilter() {
      * Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
      * compare transactions against both the new and old filters to significantly decrease the false positive rate.
      * 
-     * See the docs for {@link BloomFilter#BloomFilter(int, double, long)} for a brief explanation of anonymity when
-     * using bloom filters.
+     * See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
+     * explanation of anonymity when using bloom filters.
      */
     public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
         lock.lock();

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -2887,7 +2887,7 @@ public int getBloomFilterElementCount() {
                     if (out.isMine(this) && out.getScriptPubKey().isSentToRawPubKey())
                         size++;
                 } catch (ScriptException e) {
-                    throw new RuntimeException(e); // If it is ours, we parsed the script corectly, so this shouldn't happen
+                    throw new RuntimeException(e); // If it is ours, we parsed the script correctly, so this shouldn't happen
                 }
             }
         }
@@ -2932,7 +2932,7 @@ public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTwea
                         filter.insert(outPoint.bitcoinSerialize());
                     }
                 } catch (ScriptException e) {
-                    throw new RuntimeException(e); // If it is ours, we parsed the script corectly, so this shouldn't happen
+                    throw new RuntimeException(e); // If it is ours, we parsed the script correctly, so this shouldn't happen
                 }
             }
         }

File: core/src/test/java/com/google/bitcoin/core/PeerTest.java
Patch:
@@ -381,7 +381,7 @@ public void startBlockChainDownload() throws Exception {
 
         GetBlocksMessage message = (GetBlocksMessage) event.getValue().getMessage();
         assertEquals(message.getLocator(), expectedLocator);
-        assertEquals(message.getStopHash(), Sha256Hash.ZERO_HASH);
+        assertEquals(Sha256Hash.ZERO_HASH, message.getStopHash());
     }
 
     @Test

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -414,7 +414,7 @@ private void connectBlock(final Block block, StoredBlock storedPrev, boolean exp
             if (filtered && filteredTxn.size() > 0)  {
                 // Some temp debug logging to try and track down where transactions are going missing.
                 log.info("Block {} connects to top of best chain with {} transaction(s)",
-                        block.getHashAsString(), filteredTxn.size() + filteredTxHashList.size());
+                        block.getHashAsString(), filteredTxn.size());
                 for (Sha256Hash hash : filteredTxHashList) log.info("  matched tx {}", hash);
             }
             if (expensiveChecks && block.getTimeSeconds() <= getMedianTimestampOfRecentBlocks(head, blockStore))

File: core/src/main/java/com/google/bitcoin/crypto/KeyCrypterScrypt.java
Patch:
@@ -49,9 +49,7 @@
  * the AES symmetric cipher. Eight bytes of salt is used to prevent dictionary attacks.</p>
  */
 public class KeyCrypterScrypt implements KeyCrypter, Serializable {
-
-    public Logger log = LoggerFactory.getLogger(KeyCrypterScrypt.class.getName());
-
+    private static final Logger log = LoggerFactory.getLogger(KeyCrypterScrypt.class.getName());
     private static final long serialVersionUID = 949662512049152670L;
 
     /**

File: core/src/test/java/com/google/bitcoin/core/BitcoinSerializerTest.java
Patch:
@@ -82,8 +82,6 @@ public void testLazyParsing()  throws Exception {
         
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         bs.serialize(tx, bos);
-        System.out.println(Utils.bytesToHexString(txMessage));
-        System.out.println(Utils.bytesToHexString(bos.toByteArray()));
         assertEquals(true, Arrays.equals(txMessage, bos.toByteArray()));
         
     }

File: core/src/test/java/com/google/bitcoin/core/ECKeyTest.java
Patch:
@@ -45,7 +45,7 @@
 import static org.junit.Assert.*;
 
 public class ECKeyTest {
-    public Logger log = LoggerFactory.getLogger(ECKeyTest.class.getName());
+    private static final Logger log = LoggerFactory.getLogger(ECKeyTest.class);
 
     private SecureRandom secureRandom;
 

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -50,7 +50,7 @@
 import static org.junit.Assert.*;
 
 public class WalletTest extends TestWithWallet {
-    public Logger log = LoggerFactory.getLogger(WalletTest.class.getName());
+    private static final Logger log = LoggerFactory.getLogger(WalletTest.class);
 
     private Address myEncryptedAddress;
     private Address myEncryptedAddress2;
@@ -1541,7 +1541,6 @@ public void feeSolverAndCoinSelectionTest() throws Exception {
         assertEquals(BigInteger.ZERO, request25.fee);
         assertEquals(1, request25.tx.getInputs().size());
         assertEquals(72, request25.tx.getOutputs().size());
-        System.out.println(request25.tx.bitcoinSerialize().length);
         // Now reset request19 and give it a fee per kb
         request25.tx.clearInputs();
         request25 = SendRequest.forTx(request25.tx);

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -162,7 +162,7 @@ public void addListener(BlockChainListener listener, Executor executor) {
      * Removes the given {@link BlockChainListener} from the chain.
      */
     public void removeListener(BlockChainListener listener) {
-        listeners.remove(listener);
+        ListenerRegistration.removeFromList(listener, listeners);
     }
     
     /**
@@ -177,7 +177,7 @@ public BlockStore getBlockStore() {
      * This version is used when the transactions have not been verified.
      * @param storedPrev The {@link StoredBlock} which immediately precedes block.
      * @param block The {@link Block} to add/update.
-     * @returns the newly created {@link StoredBlock}
+     * @return the newly created {@link StoredBlock}
      */
     protected abstract StoredBlock addToBlockStore(StoredBlock storedPrev, Block block)
             throws BlockStoreException, VerificationException;
@@ -188,7 +188,7 @@ protected abstract StoredBlock addToBlockStore(StoredBlock storedPrev, Block blo
      * @param storedPrev The {@link StoredBlock} which immediately precedes block.
      * @param header The {@link StoredBlock} to add/update.
      * @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs (from a call to connectTransactions)
-     * @returns the newly created {@link StoredBlock}
+     * @return the newly created {@link StoredBlock}
      */
     protected abstract StoredBlock addToBlockStore(StoredBlock storedPrev, Block header,
                                                    TransactionOutputChanges txOutputChanges)

File: tools/src/main/java/com/google/bitcoin/tools/BuildCheckpoints.java
Patch:
@@ -5,6 +5,7 @@
 import com.google.bitcoin.store.BlockStore;
 import com.google.bitcoin.store.MemoryBlockStore;
 import com.google.bitcoin.utils.BriefLogFormatter;
+import com.google.bitcoin.utils.Threading;
 
 import java.io.DataOutputStream;
 import java.io.FileInputStream;
@@ -51,7 +52,7 @@ public void notifyNewBestBlock(StoredBlock block) throws VerificationException {
                     checkpoints.put(height, block);
                 }
             }
-        });
+        }, Threading.SAME_THREAD);
 
         peerGroup.startAndWait();
         peerGroup.downloadBlockChain();

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1367,15 +1367,15 @@ public void addEventListener(WalletEventListener listener) {
      * like receiving money. The listener is executed by the given executor.
      */
     public void addEventListener(WalletEventListener listener, Executor executor) {
-        eventListeners.add(new ListenerRegistration(listener, executor));
+        eventListeners.add(new ListenerRegistration<WalletEventListener>(listener, executor));
     }
 
     /**
      * Removes the given event listener object. Returns true if the listener was removed, false if that listener
      * was never added.
      */
     public boolean removeEventListener(WalletEventListener listener) {
-        return eventListeners.remove(listener);
+        return ListenerRegistration.removeFromList(listener, eventListeners);
     }
 
     /**

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -478,7 +478,7 @@ private void connectBlock(Block block, StoredBlock storedPrev, boolean expensive
                     // is relevant to both of them, they don't end up accidentally sharing the same object (which can
                     // result in temporary in-memory corruption during re-orgs). See bug 257. We only duplicate in
                     // the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
-                    sendTransactionsToListener(newBlock, NewBlockType.SIDE_CHAIN, listener, txnToNotify, first);
+                    sendTransactionsToListener(newBlock, NewBlockType.SIDE_CHAIN, listener, txnToNotify, !first);
                     if (filteredTxHashList != null) {
                         for (Sha256Hash hash : filteredTxHashList) {
                             listener.notifyTransactionIsInBlock(hash, newBlock, NewBlockType.SIDE_CHAIN);

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -2036,8 +2036,6 @@ public boolean completeTx(SendRequest req) {
             // the transaction is confirmed. We deliberately won't bother notifying listeners here as there's not much
             // point - the user isn't interested in a confidence transition they made themselves.
             req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
-            // TODO: Remove this - a newly completed tx isn't really pending, nothing was done with it yet.
-            req.tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);
             req.completed = true;
             req.fee = calculatedFee;
             log.info("  completed {} with {} inputs", req.tx.getHashAsString(), req.tx.getInputs().size());

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -206,7 +206,6 @@ private void receiveAPendingTransaction(Wallet wallet, Address toAddress) throws
     private void basicSanityChecks(Wallet wallet, Transaction t, Address fromAddress, Address destination) throws VerificationException {
         assertEquals("Wrong number of tx inputs", 1, t.getInputs().size());
         assertEquals(fromAddress, t.getInputs().get(0).getScriptSig().getFromAddress(params));
-        assertEquals(TransactionConfidence.ConfidenceType.PENDING, t.getConfidence().getConfidenceType());
         assertEquals("Wrong number of tx outputs",2, t.getOutputs().size());
         assertEquals(destination, t.getOutputs().get(0).getScriptPubKey().getToAddress(params));
         assertEquals(wallet.getChangeAddress(), t.getOutputs().get(1).getScriptPubKey().getToAddress(params));
@@ -283,7 +282,7 @@ public void customTransactionSpending() throws Exception {
         assertTrue(complete);
         assertEquals(1, t2.getInputs().size());
         assertEquals(myAddress, t2.getInputs().get(0).getScriptSig().getFromAddress(params));
-        assertEquals(TransactionConfidence.ConfidenceType.PENDING, t2.getConfidence().getConfidenceType());
+        assertEquals(TransactionConfidence.ConfidenceType.UNKNOWN, t2.getConfidence().getConfidenceType());
 
         // We have NOT proven that the signature is correct!
         wallet.commitTx(t2);

File: core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
Patch:
@@ -343,9 +343,9 @@ public synchronized ListenableFuture<PaymentChannelServerState> close() throws V
             storedServerChannel = null;
             StoredPaymentChannelServerStates channels = (StoredPaymentChannelServerStates)
                     wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);
-            channels.closeChannel(temp); // Calls this method again for us
-            checkState(state.compareTo(State.CLOSING) >= 0);
-            return closedFuture;
+            channels.closeChannel(temp); // May call this method again for us (if it wasn't the original caller)
+            if (state.compareTo(State.CLOSING) >= 0)
+                return closedFuture;
         }
 
         if (state.ordinal() < State.READY.ordinal()) {

File: core/src/main/java/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -150,7 +150,7 @@ protected void bitcoinSerializeToStream(OutputStream stream) throws IOException
     public boolean isCoinBase() {
         maybeParse();
         return outpoint.getHash().equals(Sha256Hash.ZERO_HASH) &&
-                outpoint.getIndex() == NO_SEQUENCE;
+                (outpoint.getIndex() & 0xFFFFFFFFL) == 0xFFFFFFFFL;  // -1 but all is serialized to the wire as unsigned int.
     }
 
     /**

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -440,7 +440,7 @@ private void readTransaction(Protos.Transaction txProto, NetworkParameters param
         for (Protos.TransactionInput transactionInput : txProto.getTransactionInputList()) {
             byte[] scriptBytes = transactionInput.getScriptBytes().toByteArray();
             TransactionOutPoint outpoint = new TransactionOutPoint(params,
-                    transactionInput.getTransactionOutPointIndex(),
+                    transactionInput.getTransactionOutPointIndex() & 0xFFFFFFFFL,
                     byteStringToHash(transactionInput.getTransactionOutPointHash())
             );
             TransactionInput input = new TransactionInput(params, tx, scriptBytes, outpoint);
@@ -515,7 +515,7 @@ private void readConfidence(Transaction tx, Protos.TransactionConfidence confide
             case DEAD: confidenceType = ConfidenceType.DEAD; break;
             // These two are equivalent (must be able to read old wallets).
             case NOT_IN_BEST_CHAIN: confidenceType = ConfidenceType.PENDING; break;
-            case NOT_SEEN_IN_CHAIN: confidenceType = ConfidenceType.PENDING; break;
+            case PENDING: confidenceType = ConfidenceType.PENDING; break;
             case UNKNOWN:
                 // Fall through.
             default:

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -197,7 +197,7 @@ private void receiveAPendingTransaction(Wallet wallet, Address toAddress) throws
         assertTrue(depthFuture.isDone());
     }
 
-    private void basicSanityChecks(Wallet wallet, Transaction t, Address fromAddress, Address destination) throws ScriptException {
+    private void basicSanityChecks(Wallet wallet, Transaction t, Address fromAddress, Address destination) throws VerificationException {
         assertEquals("Wrong number of tx inputs", 1, t.getInputs().size());
         assertEquals(fromAddress, t.getInputs().get(0).getScriptSig().getFromAddress(params));
         assertEquals(TransactionConfidence.ConfidenceType.PENDING, t.getConfidence().getConfidenceType());

File: core/src/main/java/com/google/bitcoin/core/ECKey.java
Patch:
@@ -417,7 +417,7 @@ public ECDSASignature sign(Sha256Hash input, KeyParameter aesKey) throws KeyCryp
     }
 
     /**
-     * <p>xVerifies the given ECDSA signature against the message bytes using the public key bytes.</p>
+     * <p>Verifies the given ECDSA signature against the message bytes using the public key bytes.</p>
      * 
      * <p>When using native ECDSA verification, data must be 32 bytes, and no element may be
      * larger than 520 bytes.</p>

File: core/src/main/java/com/google/bitcoin/core/DumpedPrivateKey.java
Patch:
@@ -61,7 +61,7 @@ public DumpedPrivateKey(NetworkParameters params, String encoded) throws Address
         if (params != null && version != params.getDumpedPrivateKeyHeader())
             throw new AddressFormatException("Mismatched version number, trying to cross networks? " + version +
                     " vs " + params.getDumpedPrivateKeyHeader());
-        if (bytes.length == 33) {
+        if (bytes.length == 33 && bytes[32] == 1) {
             compressed = true;
             bytes = Arrays.copyOf(bytes, 32);  // Chop off the additional marker byte.
         } else if (bytes.length == 32) {

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -457,7 +457,7 @@ private void readTransaction(Protos.Transaction txProto, NetworkParameters param
         }
 
         if (txProto.hasLockTime()) {
-            tx.setLockTime(txProto.getLockTime());
+            tx.setLockTime(0xffffffffL & txProto.getLockTime());
         }
 
         // Transaction should now be complete.

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -307,7 +307,7 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         // Do the same thing with an offline transaction.
         peerGroup.removeWallet(wallet);
         Wallet.SendRequest req = Wallet.SendRequest.to(dest, Utils.toNanoCoins(2, 0));
-        req.enforceDefaultReferenceClientFeeRelayRules = false;
+        req.ensureMinRequiredFee = false;
         Transaction t3 = wallet.sendCoinsOffline(req);
         assertNull(outbound(p1));  // Nothing sent.
         // Add the wallet to the peer group (simulate initialization). Transactions should be announced.

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -306,7 +306,9 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         
         // Do the same thing with an offline transaction.
         peerGroup.removeWallet(wallet);
-        Transaction t3 = wallet.sendCoinsOffline(Wallet.SendRequest.to(dest, Utils.toNanoCoins(2, 0)), false);
+        Wallet.SendRequest req = Wallet.SendRequest.to(dest, Utils.toNanoCoins(2, 0));
+        req.enforceDefaultReferenceClientFeeRelayRules = false;
+        Transaction t3 = wallet.sendCoinsOffline(req);
         assertNull(outbound(p1));  // Nothing sent.
         // Add the wallet to the peer group (simulate initialization). Transactions should be announced.
         peerGroup.addWallet(wallet);

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -437,7 +437,7 @@ private static void send(List<String> outputs, BigInteger fee, String lockTimeSt
                 }
                 req.aesKey = wallet.getKeyCrypter().deriveKey(password);
             }
-            if (wallet.completeTx(req, false) == null) {
+            if (wallet.completeTx(req) == null) {
                 System.err.println("Insufficient funds: have " + Utils.bitcoinValueToFriendlyString(wallet.getBalance()));
                 return;
             }

File: core/src/main/java/com/google/bitcoin/params/RegTestParams.java
Patch:
@@ -35,6 +35,7 @@ public RegTestParams() {
         subsidyDecreaseBlockCount = 10000;
         port = 18444;
         acceptableAddressCodes = new int[] { 0 };
+        addressHeader = 0;
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/params/RegTestParams.java
Patch:
@@ -29,10 +29,12 @@ public class RegTestParams extends TestNet2Params {
     private static final BigInteger PROOF_OF_WORK_LIMIT = new BigInteger("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
 
     public RegTestParams() {
+        super();
         interval = 10000;
         proofOfWorkLimit = PROOF_OF_WORK_LIMIT;
         subsidyDecreaseBlockCount = 10000;
         port = 18444;
+        acceptableAddressCodes = new int[] { 0 };
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1933,7 +1933,7 @@ public BigInteger completeTx(SendRequest req, boolean enforceDefaultReferenceCli
                     log.warn("SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.");
             value = value.subtract(totalInput);
 
-            List<TransactionInput> originalInputs = new ArrayList(req.tx.getInputs());
+            List<TransactionInput> originalInputs = new ArrayList<TransactionInput>(req.tx.getInputs());
 
             // We need to know if we need to add an additional fee because one of our values are smaller than 0.01 BTC
             boolean needAtLeastReferenceFee = false;

File: core/src/main/java/com/google/bitcoin/core/TransactionOutput.java
Patch:
@@ -138,7 +138,7 @@ void parse() throws ProtocolException {
     @Override
     protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
         checkNotNull(scriptBytes);
-        Utils.uint64ToByteStreamLE(getValue(), stream);
+        Utils.int64ToByteStreamLE(getValue().longValue(), stream);
         // TODO: Move script serialization into the Script class, where it belongs.
         stream.write(new VarInt(scriptBytes.length).encode());
         stream.write(scriptBytes);

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -591,7 +591,7 @@ private ListenableFuture<Object> downloadDependenciesInternal(final Transaction
             GetDataMessage getdata = new GetDataMessage(params);
             final long nonce = (long)(Math.random()*Long.MAX_VALUE);
             if (needToRequest.size() > 1)
-                log.info("{}: Requesting {} transactions for dep resolution", needToRequest.size());
+                log.info("{}: Requesting {} transactions for dep resolution", vAddress, needToRequest.size());
             for (Sha256Hash hash : needToRequest) {
                 getdata.addTransaction(hash);
                 GetDataRequest req = new GetDataRequest();

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -602,7 +602,7 @@ else if (scriptSig.getChunks().size() == 1) {
                     s.append(bytesToHexString(scriptSig.getChunks().get(0).data));
                     s.append("]");
                 } else
-                    s.append("???");
+                    s.append(scriptSig);
                 s.append(" / ");
                 s.append(in.getOutpoint().toString());
             } catch (Exception e) {
@@ -621,6 +621,8 @@ else if (scriptSig.getChunks().size() == 1) {
                     s.append("[pubkey:");
                     s.append(bytesToHexString(scriptPubKey.getPubKey()));
                     s.append("]");
+                } else {
+                    s.append(scriptPubKey);
                 }
                 s.append(" ");
                 s.append(bitcoinValueToFriendlyString(out.getValue()));

File: core/src/test/java/com/google/bitcoin/core/FilteredBlockAndPartialMerkleTreeTests.java
Patch:
@@ -114,7 +114,7 @@ public void serializeDownloadBlockWithWallet() throws Exception {
         inbound(p1, tx3);
         inbound(p1, new Pong(((Ping)ping).getNonce()));
         
-        Set<Transaction> transactions = wallet.getTransactions(false, false);
+        Set<Transaction> transactions = wallet.getTransactions(false);
         assertTrue(transactions.size() == 4);
         for (Transaction tx : transactions) {
             assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -562,7 +562,7 @@ private static void reset() {
     private static void setup() throws BlockStoreException {
         if (store != null) return;  // Already done.
         // Will create a fresh chain if one doesn't exist or there is an issue with this one.
-        if (!chainFileName.exists() && wallet.getTransactions(true, true).size() > 0) {
+        if (!chainFileName.exists() && wallet.getTransactions(true).size() > 0) {
             // No chain, so reset the wallet as we will be downloading from scratch.
             System.out.println("Chain file is missing so clearing transactions from the wallet.");
             reset();
@@ -599,7 +599,7 @@ private static void setup() throws BlockStoreException {
     private static void syncChain() {
         try {
             setup();
-            int startTransactions = wallet.getTransactions(true, true).size();
+            int startTransactions = wallet.getTransactions(true).size();
             DownloadListener listener = new DownloadListener();
             peers.startAndWait();
             peers.startBlockChainDownload(listener);
@@ -609,7 +609,7 @@ private static void syncChain() {
                 System.err.println("Chain download interrupted, quitting ...");
                 System.exit(1);
             }
-            int endTransactions = wallet.getTransactions(true, true).size();
+            int endTransactions = wallet.getTransactions(true).size();
             if (endTransactions > startTransactions) {
                 System.out.println("Synced " + (endTransactions - startTransactions) + " transactions.");
             }

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -1153,7 +1153,7 @@ public void onConfidenceChanged(Transaction tx) {
                         // Thread safe - this can run in parallel.
                         final TransactionConfidence conf = tx.getConfidence();
                         int numSeenPeers = conf.numBroadcastPeers();
-                        boolean mined = conf.getConfidenceType() != TransactionConfidence.ConfidenceType.NOT_SEEN_IN_CHAIN;
+                        boolean mined = tx.getAppearsInHashes() != null;
                         log.info("broadcastTransaction: TX {} seen by {} peers{}",
                                  new Object[]{pinnedTx.getHashAsString(), numSeenPeers, mined ? " and mined" : ""});
                         if (!(numSeenPeers >= minConnections || mined))

File: core/src/main/java/com/google/bitcoin/script/ScriptOpCodes.java
Patch:
@@ -162,7 +162,7 @@ public static String getOpCodeName(byte opCode) {
             case OP_PUSHDATA1:
                 return "PUSHDATA1";
             case OP_PUSHDATA2:
-                return "PUSHDATA1";
+                return "PUSHDATA2";
             case OP_PUSHDATA4:
                 return "PUSHDATA4";
             case OP_1NEGATE:

File: core/src/test/java/com/google/bitcoin/core/BitcoindComparisonTool.java
Patch:
@@ -43,7 +43,7 @@ public class BitcoindComparisonTool {
     private static FullPrunedBlockChain chain;
     private static PeerGroup peers;
     private static Sha256Hash bitcoindChainHead;
-    private static Peer bitcoind;
+    private static volatile Peer bitcoind;
     
     public static void main(String[] args) throws Exception {
         BriefLogFormatter.init();
@@ -130,7 +130,6 @@ else if (m instanceof Block) {
         while (bitcoind == null)
             Thread.sleep(50);
         
-        Random rng = new Random();
         ArrayList<Sha256Hash> locator = new ArrayList<Sha256Hash>(1);
         locator.add(params.genesisBlock.getHash());
         Sha256Hash hashTo = new Sha256Hash("0000000000000000000000000000000000000000000000000000000000000000");

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1116,8 +1116,6 @@ private void receive(Transaction tx, StoredBlock block, BlockChain.NewBlockType
             }
         }
 
-        log.info("Balance is now: " + bitcoinValueToFriendlyString(getBalance()));
-
         // WARNING: The code beyond this point can trigger event listeners on transaction confidence objects, which are
         // in turn allowed to re-enter the Wallet. This means we cannot assume anything about the state of the wallet
         // from now on. The balance just received may already be spent.
@@ -1134,6 +1132,9 @@ private void receive(Transaction tx, StoredBlock block, BlockChain.NewBlockType
             }
         }
 
+        BigInteger newBalance = getBalance();  // This is slow.
+        log.info("Balance is now: " + bitcoinValueToFriendlyString(newBalance));
+
         // Inform anyone interested that we have received or sent coins but only if:
         //  - This is not due to a re-org.
         //  - The coins appeared on the best chain.
@@ -1145,7 +1146,6 @@ private void receive(Transaction tx, StoredBlock block, BlockChain.NewBlockType
         // TODO: Decide whether to run the event listeners, if a tx confidence listener already modified the wallet.
         boolean wasPending = wtx != null;
         if (!reorg && bestChain && !wasPending) {
-            BigInteger newBalance = getBalance();
             int diff = valueDifference.compareTo(BigInteger.ZERO);
             // We pick one callback based on the value difference, though a tx can of course both send and receive
             // coins from the wallet.

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -207,6 +207,7 @@ protected abstract StoredBlock addToBlockStore(StoredBlock storedPrev, Block hea
      * Processes a received block and tries to add it to the chain. If there's something wrong with the block an
      * exception is thrown. If the block is OK but cannot be connected to the chain at this time, returns false.
      * If the block can be connected to the chain, returns true.
+     * Accessing block's transactions in another thread while this method runs may result in undefined behavior.
      */
     public boolean add(Block block) throws VerificationException, PrunedException {
         try {

File: core/src/main/java/com/google/bitcoin/core/Script.java
Patch:
@@ -1480,6 +1480,7 @@ else if (opcode == OP_CHECKMULTISIGVERIFY)
     /**
      * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
      * @param txContainingThis The transaction in which this input scriptSig resides.
+     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
      * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
      * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
      * @param enforceP2SH Whether "pay to script hash" rules should be enforced. If in doubt, set to true.

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -415,6 +415,9 @@ private void saveToFile(File temp, File destFile) throws IOException {
             if (stream != null) {
                 stream.close();
             }
+            if (temp.delete()) {
+                log.warn("Deleted temp file after failed save.");
+            }
         }
     }
 

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -394,6 +394,9 @@ public Wallet readWallet(InputStream input) throws IOException {
             wallet.setVersion(walletProto.getVersion());
         }
 
+        // Make sure the object can be re-used to read another wallet without corruption.
+        txMap.clear();
+
         return wallet;
     }
 

File: core/src/main/java/com/google/bitcoin/store/H2FullPrunedBlockStore.java
Patch:
@@ -99,7 +99,9 @@ public class H2FullPrunedBlockStore implements FullPrunedBlockStore {
     public H2FullPrunedBlockStore(NetworkParameters params, String dbName, int fullStoreDepth) throws BlockStoreException {
         this.params = params;
         this.fullStoreDepth = fullStoreDepth;
-        connectionURL = "jdbc:h2:" + dbName + ";create=true";
+        // We choose a very lax timeout to avoid the database throwing exceptions on complex operations, as time is not
+        // a particularly precious resource when just keeping up with the chain.
+        connectionURL = "jdbc:h2:" + dbName + ";create=true;LOCK_TIMEOUT=60000";
         
         conn = new ThreadLocal<Connection>();
         allConnections = new LinkedList<Connection>();

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -495,7 +495,7 @@ private static long getMedianTimestampOfRecentBlocks(StoredBlock storedBlock,
         while (unused >= 0 && (storedBlock = storedBlock.getPrev(store)) != null)
             timestamps[unused--] = storedBlock.getHeader().getTimeSeconds();
         
-        Arrays.sort(timestamps, unused+1, 10);
+        Arrays.sort(timestamps, unused+1, 11);
         return timestamps[unused + (11-unused)/2];
     }
     

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -510,7 +510,7 @@ protected void discoverPeers() throws PeerDiscoveryException {
         Set<PeerAddress> addressSet = Sets.newHashSet();
         for (PeerDiscovery peerDiscovery : peerDiscoverers) {
             InetSocketAddress[] addresses;
-            addresses = peerDiscovery.getPeers(10, TimeUnit.SECONDS);
+            addresses = peerDiscovery.getPeers(5, TimeUnit.SECONDS);
             for (InetSocketAddress address : addresses) addressSet.add(new PeerAddress(address));
             if (addressSet.size() > 0) break;
         }

File: core/src/main/java/com/google/bitcoin/discovery/IrcDiscovery.java
Patch:
@@ -30,7 +30,10 @@
 
 /**
  * IrcDiscovery provides a way to find network peers by joining a pre-agreed rendevouz point on the LFnet IRC network.
+ * <b>This class is deprecated because LFnet has ceased to operate and DNS seeds now exist for both prod and test
+ * networks.</b> It may conceivably still be useful for running small ad-hoc networks by yourself.
  */
+@Deprecated
 public class IrcDiscovery implements PeerDiscovery {
     private static final Logger log = LoggerFactory.getLogger(IrcDiscovery.class);
 

File: core/src/main/java/com/google/bitcoin/core/TCPNetworkConnection.java
Patch:
@@ -110,9 +110,10 @@ public static ListenableFuture<TCPNetworkConnection> connectTo(NetworkParameters
         ChannelPipeline pipeline = Channels.pipeline();
         final TCPNetworkConnection conn = new TCPNetworkConnection(params, new VersionMessage(params, 0));
         conn.handshakeFuture = SettableFuture.create();
+        conn.setRemoteAddress(address);
         pipeline.addLast("codec", conn.getHandler());
         clientBootstrap.setPipeline(pipeline);
-        clientBootstrap.setOption("connectTimeoutMillis", Integer.valueOf(connectTimeoutMsec));
+        clientBootstrap.setOption("connectTimeoutMillis", connectTimeoutMsec);
         ChannelFuture socketFuture = clientBootstrap.connect(address);
         // Once the socket is either connected on the TCP level, or failed ...
         socketFuture.addListener(new ChannelFutureListener() {

File: core/src/main/java/com/google/bitcoin/core/ECKey.java
Patch:
@@ -375,6 +375,9 @@ public ECDSASignature sign(Sha256Hash input, KeyParameter aesKey) throws KeyCryp
             }
 
             privateKeyForSigning = new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey));
+            // Check encryption was correct.
+            if (!Arrays.equals(pub, publicKeyFromPrivate(privateKeyForSigning, isCompressed())))
+                throw new KeyCrypterException("Could not decrypt bytes");
         } else {
             // No decryption of private key required.
             if (priv == null) {

File: core/src/main/java/com/google/bitcoin/core/Utils.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.bitcoin.core;
 
-import com.google.common.util.concurrent.CycleDetectingLockFactory;
+import com.google.common.primitives.UnsignedLongs;
 import org.spongycastle.crypto.digests.RIPEMD160Digest;
 import org.spongycastle.util.encoders.Hex;
 
@@ -202,7 +202,7 @@ public static byte[] doubleDigestTwoBuffers(byte[] input1, int offset1, int leng
      * Work around lack of unsigned types in Java.
      */
     public static boolean isLessThanUnsigned(long n1, long n2) {
-        return (n1 < n2) ^ ((n1 < 0) != (n2 < 0));
+        return UnsignedLongs.compare(n1, n2) < 0;
     }
 
     /**

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -300,7 +300,7 @@ public static boolean isSelectable(Transaction tx) {
     // do not know how to deal with).
     private int version;
     // User-provided description that may help people keep track of what a wallet is for.
-    String description;
+    private String description;
 
     /**
      * Creates a new, empty wallet with no keys and no transactions. If you want to restore a wallet from disk instead,

File: core/src/main/java/com/google/bitcoin/crypto/KeyCrypter.java
Patch:
@@ -59,10 +59,8 @@ public interface KeyCrypter extends Serializable {
     /**
      * Encrypt the supplied bytes, converting them into ciphertext.
      *
-     * @param plainBytes
-     * @param aesKey
      * @return encryptedPrivateKey An encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
-     * @throws keyCrypterException if encryption was unsuccessful
+     * @throws KeyCrypterException if encryption was unsuccessful
      */
     public EncryptedPrivateKey encrypt(byte[] plainBytes, KeyParameter aesKey) throws KeyCrypterException;
 }

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -1197,7 +1197,6 @@ public long getPingTime() {
     }
 
     private void processPong(Pong m) {
-        log.info("{}: pong! {}", this, m.getNonce());
         // Iterates over a snapshot of the list, so we can run unlocked here.
         for (PendingPing ping : pendingPings) {
             if (m.getNonce() == ping.nonce) {

File: core/src/main/java/com/google/bitcoin/core/GetBlocksMessage.java
Patch:
@@ -100,7 +100,7 @@ public boolean equals(Object o) {
     @Override
     public int hashCode() {
         int hashCode = (int) version ^ "getblocks".hashCode();
-        for (int i = 0; i < locator.size(); i++) hashCode ^= locator.get(i).hashCode();
+        for (Sha256Hash aLocator : locator) hashCode ^= aLocator.hashCode();
         hashCode ^= stopHash.hashCode();
         return hashCode;
     }

File: core/src/main/java/com/google/bitcoin/core/GetHeadersMessage.java
Patch:
@@ -56,7 +56,7 @@ public boolean equals(Object o) {
     @Override
     public int hashCode() {
         int hashCode = (int) version ^ "getheaders".hashCode();
-        for (int i = 0; i < locator.size(); i++) hashCode ^= locator.get(i).hashCode();
+        for (Sha256Hash aLocator : locator) hashCode ^= aLocator.hashCode();
         hashCode ^= stopHash.hashCode();
         return hashCode;
     }

File: core/src/main/java/com/google/bitcoin/core/HeadersMessage.java
Patch:
@@ -70,7 +70,7 @@ void parse() throws ProtocolException {
             // Read 80 bytes of the header and one more byte for the transaction list, which is always a 00 because the
             // transaction list is empty.
             byte[] blockHeader = readBytes(81);
-            if (blockHeader[80] != 00)
+            if (blockHeader[80] != 0)
                 throw new ProtocolException("Block header does not end with a null byte");
             Block newBlockHeader = new Block(this.params, blockHeader, true, true, 81);
             blockHeaders.add(newBlockHeader);

File: core/src/main/java/com/google/bitcoin/store/WalletExtensionSerializer.java
Patch:
@@ -43,6 +43,6 @@ public void readExtension(Wallet wallet, Protos.Extension extProto) {
      * Get collection of extensions to add, should be overridden by any class adding wallet extensions.
      */
     public Collection<Protos.Extension> getExtensionsToWrite(Wallet wallet) {
-        return Collections.<Protos.Extension>emptyList();
+        return Collections.emptyList();
     }
 }

File: core/src/main/java/com/google/bitcoin/uri/BitcoinURI.java
Patch:
@@ -185,11 +185,11 @@ private void parseParameters(NetworkParameters params, String addressToken, Stri
         }
         
         // Attempt to decode the rest of the tokens into a parameter map.
-        for (int i = 0; i < nameValuePairTokens.length; i++) {
-            String[] tokens = nameValuePairTokens[i].split("=");
+        for (String nameValuePairToken : nameValuePairTokens) {
+            String[] tokens = nameValuePairToken.split("=");
             if (tokens.length != 2 || "".equals(tokens[0])) {
                 throw new BitcoinURIParseException("Malformed Bitcoin URI - cannot parse name value pair '" +
-                        nameValuePairTokens[i] + "'");
+                        nameValuePairToken + "'");
             }
 
             String nameToken = tokens[0].toLowerCase();

File: core/src/main/java/com/google/bitcoin/core/AddressMessage.java
Patch:
@@ -127,14 +127,12 @@ public void addAddress(PeerAddress address) {
             getMessageSize();
         else
             length += address.getMessageSize();
-        ;
     }
 
     public void removeAddress(int index) {
         unCache();
         PeerAddress address = addresses.remove(index);
-        if (address != null)
-            address.setParent(null);
+        address.setParent(null);
         if (length == UNKNOWN_LENGTH)
             getMessageSize();
         else

File: core/src/main/java/com/google/bitcoin/core/BitcoinSerializer.java
Patch:
@@ -193,7 +193,7 @@ public Message deserializePayload(BitcoinPacketHeader header, InputStream in) th
         }
 
         // Verify the checksum.
-        byte[] hash = null;
+        byte[] hash;
         hash = doubleDigest(payloadBytes);
         if (header.checksum[0] != hash[0] || header.checksum[1] != hash[1] ||
                 header.checksum[2] != hash[2] || header.checksum[3] != hash[3]) {

File: core/src/main/java/com/google/bitcoin/core/MemoryPool.java
Patch:
@@ -60,7 +60,7 @@ public WeakTransactionReference(Transaction tx, ReferenceQueue<Transaction> queu
             super(tx, queue);
             hash = tx.getHash();
         }
-    };
+    }
     private static class Entry {
         // Invariants: one of the two fields must be null, to indicate which is used.
         Set<PeerAddress> addresses;

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -1213,7 +1213,6 @@ public void operationComplete(ChannelFuture _) throws Exception {
                                 lock.unlock();
                             }
                             future.set(pinnedTx);
-                            return;
                         }
                     });
                 }

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -439,15 +439,15 @@ protected void parseLite() throws ProtocolException {
 
             //parse();
             //parsed = true;
-            length = calcLength(bytes, cursor, offset);
+            length = calcLength(bytes, offset);
             cursor = offset + length;
         }
     }
 
-    protected static int calcLength(byte[] buf, int cursor, int offset) {
+    protected static int calcLength(byte[] buf, int offset) {
         VarInt varint;
         // jump past version (uint32)
-        cursor = offset + 4;
+        int cursor = offset + 4;
 
         int i;
         long scriptLen;

File: core/src/main/java/com/google/bitcoin/core/TransactionConfidence.java
Patch:
@@ -125,7 +125,7 @@ public static ConfidenceType valueOf(int value) {
             }
         }
 
-    };
+    }
 
     private ConfidenceType confidenceType = ConfidenceType.UNKNOWN;
     private int appearedAtChainHeight = -1;
@@ -165,7 +165,7 @@ public TransactionConfidence(Transaction tx) {
      */
     public interface Listener {
         public void onConfidenceChanged(Transaction tx);
-    };
+    }
 
     /**
      * <p>Adds an event listener that will be run when this confidence object is updated. The listener will be locked and

File: core/src/main/java/com/google/bitcoin/uri/BitcoinURI.java
Patch:
@@ -335,8 +335,7 @@ public static String convertToBitcoinURI(String address, BigInteger amount, Stri
             if (questionMarkHasBeenOutput) {
                 builder.append(AMPERSAND_SEPARATOR);
             } else {
-                builder.append(QUESTION_MARK_SEPARATOR);                
-                questionMarkHasBeenOutput = true;
+                builder.append(QUESTION_MARK_SEPARATOR);
             }
             builder.append(FIELD_MESSAGE).append("=").append(encodeURLString(message));
         }

File: core/src/test/java/com/google/bitcoin/core/PeerTest.java
Patch:
@@ -463,7 +463,7 @@ public void pingPong() throws Exception {
         assertEquals(elapsed, peer.getPingTime());
         // Do it again and make sure it affects the average.
         future = peer.ping();
-        outbound();
+        pingMsg = (Ping) outbound();
         Utils.rollMockClock(50);
         inbound(peer, new Pong(pingMsg.getNonce()));
         elapsed = future.get();

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -361,7 +361,8 @@ private void saveToFile(File temp, File destFile) throws IOException {
             if (Utils.isWindows()) {
                 // Work around an issue on Windows whereby you can't rename over existing files.
                 File canonical = destFile.getCanonicalFile();
-                if (canonical.delete() && temp.renameTo(canonical))
+                canonical.delete();
+                if (temp.renameTo(canonical))
                     return;  // else fall through.
                 throw new IOException("Failed to rename " + temp + " to " + canonical);
             } else if (!temp.renameTo(destFile)) {

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -894,7 +894,7 @@ private void processInv(InventoryMessage inv) throws IOException {
         }
 
         if (pingAfterGetData)
-            sendMessage(new Ping((long) Math.random() * Long.MAX_VALUE));
+            sendMessage(new Ping((long) (Math.random() * Long.MAX_VALUE)));
     }
 
     /**
@@ -1150,7 +1150,7 @@ private void addPingTimeData(long sample) {
      * @throws ProtocolException if the peer version is too low to support measurable pings.
      */
     public ListenableFuture<Long> ping() throws IOException, ProtocolException {
-        return ping((long) Math.random() * Long.MAX_VALUE);
+        return ping((long) (Math.random() * Long.MAX_VALUE));
     }
 
     protected ListenableFuture<Long> ping(long nonce) throws IOException, ProtocolException {

File: examples/src/main/java/com/google/bitcoin/examples/PingService.java
Patch:
@@ -120,6 +120,7 @@ public void onCoinsReceived(Wallet w, Transaction tx, BigInteger prevBalance, Bi
                         ": " + tx);
                 tx.getConfidence().addEventListener(new TransactionConfidence.Listener() {
                     public void onConfidenceChanged(Transaction tx2) {
+                        // Must be thread safe.
                         if (tx2.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING) {
                             // Coins were confirmed (appeared in a block).
                             tx2.getConfidence().removeEventListener(this);

File: examples/src/main/java/com/google/bitcoin/examples/PingService.java
Patch:
@@ -111,7 +111,7 @@ public PingService(String[] args) throws Exception {
         wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
             public void onCoinsReceived(Wallet w, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {
-                // Running on a peer thread.
+                // MUST BE THREAD SAFE
                 assert !newBalance.equals(BigInteger.ZERO);
                 if (!tx.isPending()) return;
                 // It was broadcast, but we can't really verify it's valid until it appears in a block.

File: examples/src/main/java/com/google/bitcoin/examples/RefreshWallet.java
Patch:
@@ -44,7 +44,7 @@ public static void main(String[] args) throws Exception {
 
         wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
-            public void onCoinsReceived(Wallet w, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {
+            public synchronized void onCoinsReceived(Wallet w, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {
                 System.out.println("\nReceived tx " + tx.getHashAsString());
                 System.out.println(tx.toString());
             }

File: examples/src/main/java/com/google/bitcoin/examples/toywallet/ToyWallet.java
Patch:
@@ -205,7 +205,7 @@ public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {
         wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
             public void onWalletChanged(Wallet wallet) {
-                // This is running in some arbitrary bitcoinj provided thread with the wallet locked.
+                // MUST BE THREAD SAFE.
                 final List<Transaction> txns = wallet.getTransactionsByTime();
                 SwingUtilities.invokeLater(new Runnable() {
                     public void run() {

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -503,7 +503,7 @@ public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {
                 }
                 wallet.addEventListener(new AbstractWalletEventListener() {
                     @Override
-                    public void onChange() {
+                    public synchronized void onChange() {
                         super.onChange();
                         saveWallet(walletFile);
                         BigInteger balance = wallet.getBalance(Wallet.BalanceType.ESTIMATED);

File: core/src/main/java/com/google/bitcoin/store/SPVBlockStore.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.bitcoin.store;
 
 import com.google.bitcoin.core.*;
+import com.google.bitcoin.utils.Locks;
 import com.google.common.base.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -54,7 +55,7 @@ public class SPVBlockStore implements BlockStore {
     protected int numHeaders;
     protected NetworkParameters params;
 
-    protected ReentrantLock lock = Utils.lock("SPVBlockStore");
+    protected ReentrantLock lock = Locks.lock("SPVBlockStore");
 
     // The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
     // faulted in. Unfortunately, in theory practice and theory are the same. In practice they aren't.

File: core/src/main/java/com/google/bitcoin/core/Utils.java
Patch:
@@ -433,7 +433,7 @@ public static BigInteger decodeCompactBits(long compact) {
     /**
      * If non-null, overrides the return value of now().
      */
-    public static Date mockTime;
+    public static volatile Date mockTime;
 
     /**
      * Advances (or rewinds) the mock clock by the given number of seconds.

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -245,7 +245,7 @@ else if (depth1 > depth2)
             for (TransactionOutput output : sortedOutputs) {
                 if (total >= target) break;
                 // Only pick chain-included transactions, or transactions that are ours and pending.
-                if (!isSelectable(output)) continue;
+                if (!isSelectable(output.parentTransaction)) continue;
                 selected.add(output);
                 total += output.getValue().longValue();
             }
@@ -254,9 +254,9 @@ else if (depth1 > depth2)
             return new CoinSelection(BigInteger.valueOf(total), selected);
         }
 
-        public static boolean isSelectable(TransactionOutput output) {
+        public static boolean isSelectable(Transaction tx) {
             // Only pick chain-included transactions, or transactions that are ours and pending.
-            TransactionConfidence confidence = output.parentTransaction.getConfidence();
+            TransactionConfidence confidence = tx.getConfidence();
             ConfidenceType type = confidence.getConfidenceType();
             boolean pending = type.equals(ConfidenceType.NOT_SEEN_IN_CHAIN) ||
                     type.equals(ConfidenceType.NOT_IN_BEST_CHAIN);

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -1017,7 +1017,7 @@ private synchronized void blockChainDownload(Sha256Hash toHash) throws IOExcepti
             log.info("blockChainDownload({}): ignoring duplicated request", toHash.toString());
             return;
         }
-        log.info("{}: blockChainDownload({}) current head = {}", new Object[] { toString(),
+        log.debug("{}: blockChainDownload({}) current head = {}", new Object[] { toString(),
                 toHash.toString(), chainHead.getHeader().getHashAsString() });
         StoredBlock cursor = chainHead;
         for (int i = 100; cursor != null && i > 0; i--) {

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -61,7 +61,7 @@ public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBl
                 BlockChainTest.this.block[0] = block;
                 if (tx.isCoinBase()) {
                     BlockChainTest.this.coinbaseTransaction = tx;
-                 }
+                }
             }
         };
         wallet.addKey(new ECKey());

File: core/src/main/java/com/google/bitcoin/store/BoundedOverheadBlockStore.java
Patch:
@@ -114,7 +114,7 @@ public static void write(FileChannel channel, StoredBlock block) throws IOExcept
                 buf.put(EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length);
             }
             buf.put(chainWorkBytes);
-            buf.put(block.getHeader().bitcoinSerialize());
+            buf.put(block.getHeader().cloneAsHeader().bitcoinSerialize());
             buf.position(0);
             channel.position(channel.size());
             if (channel.write(buf) < Record.SIZE)

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -379,7 +379,8 @@ private void connectBlock(Block block, StoredBlock storedPrev, boolean expensive
             TransactionOutputChanges txOutChanges = null;
             if (shouldVerifyTransactions())
                 txOutChanges = connectTransactions(storedPrev.getHeight() + 1, block);
-            StoredBlock newStoredBlock = addToBlockStore(storedPrev, block, txOutChanges);
+            StoredBlock newStoredBlock = addToBlockStore(storedPrev,
+                    block.transactions == null ? block : block.cloneAsHeader(), txOutChanges);
             setChainHead(newStoredBlock);
             log.debug("Chain is now {} blocks high", newStoredBlock.getHeight());
             // Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated

File: core/src/test/java/com/google/bitcoin/core/BitcoinSerializerTest.java
Patch:
@@ -26,6 +26,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 
 public class BitcoinSerializerTest {
     private final byte[] addrMessage = Hex.decode("f9beb4d96164647200000000000000001f000000" +
@@ -177,7 +178,7 @@ public void testHeaders1() throws Exception {
         String hash = block.getHashAsString();
         assertEquals(hash, "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048");
 
-        assertEquals(block.transactions.size(), 0);
+        assertNull(block.transactions);
 
         assertEquals(Utils.bytesToHexString(block.getMerkleRoot().getBytes()),
                 "0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098");

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -101,7 +101,7 @@ public class PeerGroup extends AbstractIdleService {
     // and network latency. We ping peers every pingIntervalMsec milliseconds.
     private Timer pingTimer;
     /** How many milliseconds to wait after receiving a pong before sending another ping. */
-    public static final long DEFAULT_PING_INTERVAL_MSEC = 1000;
+    public static final long DEFAULT_PING_INTERVAL_MSEC = 2000;
     private long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;
 
     private final NetworkParameters params;

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -562,15 +562,16 @@ public void onKeyAdded(ECKey key) {
 
     private synchronized void recalculateFastCatchupAndFilter() {
         // Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
-        if (chain != null && chain.shouldVerifyTransactions()) return;
+        if (chain != null && chain.shouldVerifyTransactions())
+            return;
         long earliestKeyTime = Long.MAX_VALUE;
         int elements = 0;
         for (Wallet w : wallets) {
             earliestKeyTime = Math.min(earliestKeyTime, w.getEarliestKeyCreationTime());
             elements += w.getBloomFilterElementCount();
         }
 
-        if (chain == null || !chain.shouldVerifyTransactions() && elements > 0) {
+        if (elements > 0) {
             // We stair-step our element count so that we avoid creating a filter with different parameters
             // as much as possible as that results in a loss of privacy.
             // The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -

File: core/src/test/java/com/google/bitcoin/core/FakeChannel.java
Patch:
@@ -1,14 +1,14 @@
 package com.google.bitcoin.core;
 
 import org.jboss.netty.channel.*;
-import org.jboss.netty.util.internal.QueueFactory;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
 
 public class FakeChannel extends AbstractChannel {
-    final BlockingQueue<ChannelEvent> events = QueueFactory.createQueue(ChannelEvent.class);
+    final BlockingQueue<ChannelEvent> events = new ArrayBlockingQueue<ChannelEvent>(1000);
 
     private final ChannelConfig config;
     private SocketAddress localAddress;

File: core/src/test/java/com/google/bitcoin/core/TestWithPeerGroup.java
Patch:
@@ -44,6 +44,7 @@ public Channel newChannel(ChannelPipeline pipeline) {
                 ChannelSink sink = new FakeChannelSink();
                 return new FakeChannel(this, pipeline, sink);
             }
+            public void shutdown() {}
         });
         bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
             public ChannelPipeline getPipeline() throws Exception {

File: core/src/main/java/com/google/bitcoin/core/Block.java
Patch:
@@ -47,7 +47,7 @@ public class Block extends Message {
     private static final Logger log = LoggerFactory.getLogger(Block.class);
     private static final long serialVersionUID = 2738848929966035281L;
 
-    /** How many bytes are required to represent a block header. */
+    /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */
     public static final int HEADER_SIZE = 80;
 
     static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as official client.
@@ -380,7 +380,6 @@ private void writeTransactions(OutputStream stream) throws IOException {
      * @throws IOException
      */
     public byte[] bitcoinSerialize() {
-
         // we have completely cached byte array.
         if (headerBytesValid && transactionBytesValid) {
             Preconditions.checkNotNull(bytes, "Bytes should never be null if headerBytesValid && transactionBytesValid");

File: core/src/main/java/com/google/bitcoin/core/VersionMessage.java
Patch:
@@ -113,7 +113,7 @@ public VersionMessage(NetworkParameters params, int newBestHeight, boolean relay
         length = 85;
         if (protocolVersion > 31402)
             length += 8;
-        length += subVer == null ? 1 : VarInt.sizeOf(subVer.length()) + subVer.length();
+        length += VarInt.sizeOf(subVer.length()) + subVer.length();
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/Block.java
Patch:
@@ -536,7 +536,7 @@ public Block cloneAsHeader() {
     @Override
     public String toString() {
         StringBuffer s = new StringBuffer("v" + version + " block: \n" + "   previous block: "
-                + prevBlockHash.toString() + "\n" + "   merkle root: " + getMerkleRoot().toString() + "\n"
+                + getPrevBlockHash().toString() + "\n" + "   merkle root: " + getMerkleRoot().toString() + "\n"
                 + "   time: [" + time + "] " + new Date(time * 1000).toString() + "\n"
                 + "   difficulty target (nBits): " + difficultyTarget + "\n" + "   nonce: " + nonce + "\n");
         if (transactions != null && transactions.size() > 0) {

File: core/src/main/java/com/google/bitcoin/core/DumpedPrivateKey.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.bitcoin.core;
 
+import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 
 import java.math.BigInteger;
 import java.util.Arrays;
-import java.util.Objects;
 
 /**
  * Parses and generates private keys in the form used by the Bitcoin "dumpprivkey" command. This is the private key
@@ -96,6 +96,6 @@ public boolean equals(Object other) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(bytes, version, compressed);
+        return Objects.hashCode(bytes, version, compressed);
     }
 }

File: core/src/main/java/com/google/bitcoin/core/ECKey.java
Patch:
@@ -507,7 +507,7 @@ public static ECKey recoverFromSignature(int recId, ECDSASignature sig, Sha256Ha
         }
         // Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
         // So it's encoded in the recId.
-        ECPoint R = decompressKey(x, recId % 2 == 1);
+        ECPoint R = decompressKey(x, (recId & 1) == 1);
         //   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
         if (!R.multiply(n).isInfinity())
             return null;

File: core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -344,7 +344,7 @@ public void setSpendableCoinbaseDepth(int coinbaseDepth) {
      * Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
      */
     public boolean passesCheckpoint(int height, Sha256Hash hash) {
-        Sha256Hash checkpointHash = checkpoints.get(new Integer(height));
+        Sha256Hash checkpointHash = checkpoints.get(Integer.valueOf(height));
         if (checkpointHash != null)
             return checkpointHash.equals(hash);
         return true;
@@ -356,7 +356,7 @@ public boolean passesCheckpoint(int height, Sha256Hash hash) {
      * @return
      */
     public boolean isCheckpoint(int height) {
-        Sha256Hash checkpointHash = checkpoints.get(new Integer(height));
+        Sha256Hash checkpointHash = checkpoints.get(Integer.valueOf(height));
         if (checkpointHash != null)
             return true;
         return false;

File: core/src/main/java/com/google/bitcoin/core/Script.java
Patch:
@@ -726,6 +726,7 @@ private static int getSigOpCount(List<ScriptChunk> chunks, boolean accurate) thr
                         sigOps += getOpNValue(lastOpCode);
                     else
                         sigOps += 20;
+                    break;
                 default:
                     break;
                 }
@@ -1181,6 +1182,8 @@ private static void executeScript(Transaction txContainingThis, long index,
                         else
                             numericOPnum = BigInteger.ONE;
                         break;
+                    default:
+                        throw new AssertionError("Unreachable");
                     }
                     
                     stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum, false)));

File: core/src/main/java/com/google/bitcoin/core/FullPrunedBlockChain.java
Patch:
@@ -107,7 +107,7 @@ protected synchronized TransactionOutputChanges connectTransactions(int height,
         LinkedList<StoredTransactionOutput> txOutsSpent = new LinkedList<StoredTransactionOutput>();
         LinkedList<StoredTransactionOutput> txOutsCreated = new LinkedList<StoredTransactionOutput>();  
         long sigOps = 0;
-        final boolean enforceBIP16 = block.getTimeSeconds() >= params.BIP16_ENFORCE_TIME;
+        final boolean enforceBIP16 = block.getTimeSeconds() >= NetworkParameters.BIP16_ENFORCE_TIME;
         
         if (scriptVerificationExecutor.isShutdown())
             scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
@@ -261,7 +261,7 @@ protected synchronized TransactionOutputChanges connectTransactions(StoredBlock
                 LinkedList<StoredTransactionOutput> txOutsSpent = new LinkedList<StoredTransactionOutput>();
                 LinkedList<StoredTransactionOutput> txOutsCreated = new LinkedList<StoredTransactionOutput>();
                 long sigOps = 0;
-                final boolean enforcePayToScriptHash = newBlock.getHeader().getTimeSeconds() >= params.BIP16_ENFORCE_TIME;
+                final boolean enforcePayToScriptHash = newBlock.getHeader().getTimeSeconds() >= NetworkParameters.BIP16_ENFORCE_TIME;
                 if (!params.isCheckpoint(newBlock.getHeight())) {
                     for(Transaction tx : transactions) {
                         Sha256Hash hash = tx.getHash();

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1512,7 +1512,7 @@ public static class SendRequest {
          * don't really control as it depends on who sent you money), and the value being sent somewhere else. The
          * change address should be selected from this wallet, normally. <b>If null this will be chosen for you.</b>
          */
-        public Address changeAddress;
+        public Address changeAddress = null;
 
         /**
          * A transaction can have a fee attached, which is defined as the difference between the input values

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -212,7 +212,7 @@ public void connectRequested(ChannelHandlerContext ctx, ChannelStateEvent e) thr
         public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
             String s;
             PeerAddress addr = address.get();
-            s = address == null ? "?" : address.toString();
+            s = addr == null ? "?" : addr.toString();
             if (e.getCause() instanceof ConnectException || e.getCause() instanceof IOException) {
                 // Short message for network errors
                 log.info(s + " - " + e.getCause().getMessage());

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -953,7 +953,7 @@ public TransactionOutput getOutput(int index) {
         maybeParse();
         return outputs.get(index);
     }
-    
+
     public synchronized TransactionConfidence getConfidence() {
         if (confidence == null) {
             confidence = new TransactionConfidence(this);

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -96,7 +96,7 @@ public abstract class AbstractBlockChain {
     private final List<BlockChainListener> listeners;
 
     // Holds a block header and, optionally, a list of tx hashes or block's transactions
-    class OrphanBlock {
+    protected static class OrphanBlock {
         Block block;
         Set<Sha256Hash> filteredTxHashes;
         List<Transaction> filteredTxn;

File: core/src/main/java/com/google/bitcoin/core/BitcoinSerializer.java
Patch:
@@ -302,7 +302,7 @@ public boolean isParseRetainMode() {
     }
 
 
-    public class BitcoinPacketHeader {
+    public static class BitcoinPacketHeader {
         public final byte[] header;
         public final String command;
         public final int size;

File: core/src/main/java/com/google/bitcoin/core/PartialMerkleTree.java
Patch:
@@ -92,7 +92,7 @@ private int getTreeWidth(int height) {
         return (transactionCount+(1 << height)-1) >> height;
     }
     
-    class ValuesUsed {
+    private static class ValuesUsed {
         public int bitsUsed = 0, hashesUsed = 0;
     }
     

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -139,7 +139,7 @@ public void onPeerDisconnected(Peer peer) {
     // The false positive rate for bloomFilter
     private double bloomFilterFPRate = DEFAULT_BLOOM_FILTER_FP_RATE;
     // We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys
-    private final long bloomFilterTweak = new Random().nextLong();
+    private final long bloomFilterTweak = (long) (Math.random() * Long.MAX_VALUE);
     private int lastBloomFilterElementCount;
     
     /**

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -286,7 +286,7 @@ public Wallet(NetworkParameters params) {
         createTransientState();
     }
 
-    private void createTransientState() {
+    private synchronized void createTransientState() {
         eventListeners = new ArrayList<WalletEventListener>();
         ignoreNextNewBlock = new HashSet<Sha256Hash>();
         txConfidenceListener = new TransactionConfidence.Listener() {
@@ -2392,7 +2392,7 @@ public int getBloomFilterElementCount() {
      * See the docs for {@link BloomFilter#BloomFilter(int, double)} for a brief explanation of anonymity when using bloom filters.
      */
     public BloomFilter getBloomFilter(double falsePositiveRate) {
-        return getBloomFilter(getBloomFilterElementCount(), falsePositiveRate, new Random().nextLong());
+        return getBloomFilter(getBloomFilterElementCount(), falsePositiveRate, (long)(Math.random()*Long.MAX_VALUE));
     }
     
     /**

File: core/src/main/java/com/google/bitcoin/store/MemoryFullPrunedBlockStore.java
Patch:
@@ -308,7 +308,7 @@ public void removeByMultiKey(MultiKeyType key) {
  * Used primarily for unit testing.
  */
 public class MemoryFullPrunedBlockStore implements FullPrunedBlockStore {
-    class StoredBlockAndWasUndoableFlag {
+    protected static class StoredBlockAndWasUndoableFlag {
         public StoredBlock block;
         public boolean wasUndoable;
         public StoredBlockAndWasUndoableFlag(StoredBlock block, boolean wasUndoable) { this.block = block; this.wasUndoable = wasUndoable; }

File: core/src/test/java/com/google/bitcoin/store/WalletProtobufSerializerTest.java
Patch:
@@ -290,15 +290,15 @@ private Wallet roundTripExtension(Wallet wallet) throws IOException {
     /**
      * An extension of a wallet that stores a number.
      */
-    public class WalletExtension extends Wallet {
+    public static class WalletExtension extends Wallet {
         public byte[] random_bytes;
 
         public WalletExtension(NetworkParameters params) {
             super(params);
         }
     }
 
-    public class WalletExtensionSerializerRandom extends WalletExtensionSerializer {
+    public static class WalletExtensionSerializerRandom extends WalletExtensionSerializer {
         @Override
         public Collection<Protos.Extension> getExtensionsToWrite(Wallet wallet) {
             List<Protos.Extension> lst = new LinkedList<Protos.Extension>();

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -596,9 +596,10 @@ private synchronized void recalculateFastCatchupAndFilter() {
      * Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
      * compare transactions against both the new and old filters to significantly decrease the false positive rate.
      * 
-     * See the docs for {@link BloomFilter#BloomFilter(int, double)} for a brief explanation of anonymity when using bloom filters.
+     * See the docs for {@link BloomFilter#BloomFilter(int, double, long)} for a brief explanation of anonymity when
+     * using bloom filters.
      */
-    public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
+    public synchronized void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
         this.bloomFilterFPRate = bloomFilterFPRate;
         recalculateFastCatchupAndFilter();
     }

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -570,7 +570,7 @@ private synchronized void recalculateFastCatchupAndFilter() {
             elements += w.getBloomFilterElementCount();
         }
 
-        if (chain == null || !chain.shouldVerifyTransactions()) {
+        if (chain == null || !chain.shouldVerifyTransactions() && elements > 0) {
             // We stair-step our element count so that we avoid creating a filter with different parameters
             // as much as possible as that results in a loss of privacy.
             // The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
@@ -587,7 +587,7 @@ private synchronized void recalculateFastCatchupAndFilter() {
                     peer.sendMessage(filter);
                 } catch (IOException e) { }
         }
-        //Do this last so that bloomFilter is already set when it gets called
+        // Do this last so that bloomFilter is already set when it gets called.
         setFastCatchupTimeSecs(earliestKeyTime);
     }
     

File: core/src/test/java/com/google/bitcoin/core/VersionMessageTest.java
Patch:
@@ -1,10 +1,10 @@
 package com.google.bitcoin.core;
 
-import static org.junit.Assert.assertTrue;
-
 import org.junit.Test;
 import org.spongycastle.util.encoders.Hex;
 
+import static org.junit.Assert.assertTrue;
+
 public class VersionMessageTest {
     @Test
     // Test that we can decode version messages which miss data which some old nodes may not include

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -139,7 +139,7 @@ public void onCoinsSent(Wallet wallet, Transaction tx, BigInteger prevBalance, B
         assertEquals(1, txns.size());
 
         // Now check that we can spend the unconfirmed change.
-        assertEquals(v3, wallet.getBalance(Wallet.BalanceType.ESTIMATED));
+        assertEquals(v3, wallet.getBalance());
         Transaction t3 = wallet.createSend(new ECKey().toAddress(params), v3);
         assertNotNull(t3);
     }

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -596,7 +596,7 @@ public String toString(AbstractBlockChain chain) {
                 if (scriptSig.chunks.size() == 2)
                     s.append(scriptSig.getFromAddress().toString());
                 else if (scriptSig.chunks.size() == 1)
-                    s.append("[sig:" + bytesToHexString(scriptSig.getPubKey()) + "]");
+                    s.append("[sig:" + bytesToHexString(scriptSig.chunks.get(0).data) + "]");
                 else
                     s.append("???");
                 s.append(" / ");

File: core/src/main/java/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -54,15 +54,14 @@ public class TransactionInput extends ChildMessage implements Serializable {
     private Transaction parentTransaction;
 
     /**
-     * Used only in creation of the genesis block.
+     * Creates an input that connects to nothing - used only in creation of coinbase transactions.
      */
-    TransactionInput(NetworkParameters params, Transaction parentTransaction, byte[] scriptBytes) {
+    public TransactionInput(NetworkParameters params, Transaction parentTransaction, byte[] scriptBytes) {
         super(params);
         this.scriptBytes = scriptBytes;
         this.outpoint = new TransactionOutPoint(params, NO_SEQUENCE, (Transaction)null);
         this.sequence = NO_SEQUENCE;
         this.parentTransaction = parentTransaction;
-
         length = 40 + (scriptBytes == null ? 1 : VarInt.sizeOf(scriptBytes.length) + scriptBytes.length);
     }
 

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -416,7 +416,7 @@ private static void send(List<String> outputs, BigInteger fee, String lockTimeSt
             Wallet.SendRequest req = Wallet.SendRequest.forTx(t);
             req.fee = fee;
             if (!wallet.completeTx(req)) {
-                System.err.println("Insufficient funds: have " + wallet.getBalance());
+                System.err.println("Insufficient funds: have " + Utils.bitcoinValueToFriendlyString(wallet.getBalance()));
                 return;
             }
             try {
@@ -593,7 +593,7 @@ private static void syncChain() {
     private static void shutdown() {
         try {
             if (peers == null) return;  // setup() never called so nothing to do.
-            peers.stop();
+            peers.stopAndWait();
             saveWallet(walletFile);
             store.close();
             wallet = null;

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -34,7 +34,7 @@
 // Handling of chain splits/reorgs are in ChainSplitTests.
 
 public class BlockChainTest {
-    private static final NetworkParameters testNet = NetworkParameters.oldTestNet();
+    private static final NetworkParameters testNet = NetworkParameters.testNet2();
     private BlockChain testNetChain;
 
     private Wallet wallet;

File: core/src/test/java/com/google/bitcoin/core/BlockTest.java
Patch:
@@ -29,7 +29,7 @@
 import static org.junit.Assert.*;
 
 public class BlockTest {
-    static final NetworkParameters params = NetworkParameters.oldTestNet();
+    static final NetworkParameters params = NetworkParameters.testNet2();
 
     public static final byte[] blockBytes;
 

File: core/src/main/java/com/google/bitcoin/discovery/IrcDiscovery.java
Patch:
@@ -97,11 +97,12 @@ public InetSocketAddress[] getPeers(long timeoutValue, TimeUnit timeoutUnit) thr
             int ipCursor = ipCursorStart;
             do {
                 connection = new Socket();
+                int timeoutMsec = (int) TimeUnit.MILLISECONDS.convert(timeoutValue, timeoutUnit);
+                connection.setSoTimeout(timeoutMsec);
                 try {
                     InetAddress ip = ips[ipCursor];
-                    long timeoutMsec = TimeUnit.MILLISECONDS.convert(timeoutValue, timeoutUnit);
                     log.info("Connecting to IRC with " + ip);
-                    connection.connect(new InetSocketAddress(ip, port), (int)timeoutMsec);
+                    connection.connect(new InetSocketAddress(ip, port), timeoutMsec);
                 } catch (SocketTimeoutException e) {
                     connection = null;
                 } catch (IOException e) {

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -850,7 +850,7 @@ synchronized Sha256Hash hashTransactionForSignature(int inputIndex, byte[] conne
                 }
                 // In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                 // that position are "nulled out". Unintuitively, the value in a "null" transaction is set to -1.
-                this.outputs = new ArrayList<TransactionOutput>(this.outputs.subList(0, inputIndex));
+                this.outputs = new ArrayList<TransactionOutput>(this.outputs.subList(0, inputIndex + 1));
                 for (int i = 0; i < inputIndex; i++)
                     this.outputs.set(i, new TransactionOutput(params, this, BigInteger.valueOf(-1), new byte[] {}));
                 // The signature isn't broken by new versions of the transaction issued by other parties.

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -869,8 +869,8 @@ synchronized Sha256Hash hashTransactionForSignature(int inputIndex, byte[] conne
 
             ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
             bitcoinSerialize(bos);
-            // We also have to write a hash type.
-            uint32ToByteStreamLE(sigHashType, bos);
+            // We also have to write a hash type (sigHashType is actually an unsigned char)
+            uint32ToByteStreamLE(0x000000ff & sigHashType, bos);
             // Note that this is NOT reversed to ensure it will be signed correctly. If it were to be printed out
             // however then we would expect that it is IS reversed.
             Sha256Hash hash = new Sha256Hash(doubleDigest(bos.toByteArray()));

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -160,7 +160,7 @@ public PeerGroup(NetworkParameters params, AbstractBlockChain chain) {
      *
      * <pre>
      *   ClientBootstrap bootstrap = PeerGroup.createClientBootstrap();
-     *   bootstrap.setOption("connectionTimeoutMillis", 3000);
+     *   bootstrap.setOption("connectTimeoutMillis", 3000);
      *   PeerGroup peerGroup = new PeerGroup(params, chain, bootstrap);
      * </pre>
      *

File: core/src/test/java/com/google/bitcoin/core/FakeChannelSink.java
Patch:
@@ -48,6 +48,7 @@ public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) throws Exception
             FakeChannel channel = (FakeChannel) event.getChannel();
             boolean offered = channel.events.offer(event);
             assert offered;
+            event.getFuture().setSuccess();
         }
     }
 }

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -369,6 +369,6 @@ public void estimatedBlockTime() throws Exception {
         BlockChain prod = new BlockChain(params, new MemoryBlockStore(params));
         Date d = prod.estimateBlockTime(200000);
         // The actual date of block 200,000 was 2012-09-22 10:47:00
-        assertEquals(new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").parse("2012/10/23 17:35:05"), d);
+        assertEquals(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").parse("2012-10-23T08:35:05.000-0700"), d);
     }
 }

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -605,8 +605,8 @@ public void removeWallet(Wallet wallet) {
     /**
      * Sends the given message on the peers Channel.
      */
-    public void sendMessage(Message m) throws IOException {
-        Channels.write(channel, m);
+    public ChannelFuture sendMessage(Message m) throws IOException {
+        return Channels.write(channel, m);
     }
 
     // Keep track of the last request we made to the peer in blockChainDownload so we can avoid redundant and harmful

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -968,7 +968,7 @@ public void run() {
                     // transaction or not. However, we are not a fully validating node and this is advertised in
                     // our version message, as SPV nodes cannot relay it doesn't give away any additional information
                     // to skip the inv here - we wouldn't send invs anyway.
-                    somePeer.sendMessage(pinnedTx);
+                    somePeer.sendMessage(pinnedTx).awaitUninterruptibly();
                 } catch (IOException e) {
                     future.setException(e);
                     return;

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -34,7 +34,7 @@
 // Handling of chain splits/reorgs are in ChainSplitTests.
 
 public class BlockChainTest {
-    private static final NetworkParameters testNet = NetworkParameters.testNet();
+    private static final NetworkParameters testNet = NetworkParameters.oldTestNet();
     private BlockChain testNetChain;
 
     private Wallet wallet;

File: core/src/test/java/com/google/bitcoin/core/BlockTest.java
Patch:
@@ -29,7 +29,7 @@
 import static org.junit.Assert.*;
 
 public class BlockTest {
-    static final NetworkParameters params = NetworkParameters.testNet();
+    static final NetworkParameters params = NetworkParameters.oldTestNet();
 
     public static final byte[] blockBytes;
 

File: examples/src/main/java/com/google/bitcoin/examples/toywallet/ToyWallet.java
Patch:
@@ -114,7 +114,7 @@ public void setTransactions(List<Transaction> txns) {
     public ToyWallet(boolean testnet, boolean fullChain, String[] args) throws Exception {
         // Set up a Bitcoin connection + empty wallet. TODO: Simplify the setup for this use case.
         if (testnet) {
-            params = NetworkParameters.testNet3();
+            params = NetworkParameters.testNet();
         } else {
             params = NetworkParameters.prodNet();
         }

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -271,7 +271,7 @@ public static void main(String[] args) throws Exception {
                 discovery = new DnsDiscovery(params);
                 break;
             case TEST: 
-                params = NetworkParameters.testNet3();
+                params = NetworkParameters.testNet();
                 chainFileName = new File("testnet.chain");
                 discovery = new IrcDiscovery("#bitcoinTEST3");
                 break;

File: core/src/main/java/com/google/bitcoin/core/MemoryPool.java
Patch:
@@ -188,7 +188,9 @@ public synchronized Transaction seen(Transaction tx, PeerAddress byPeer) {
                 return tx;
             }
         } else {
-            log.info("{}: Provided with a downloaded transaction we didn't see announced yet: {}", 
+            // This often happens when we are downloading a Bloom filtered chain, or recursively downloading
+            // dependencies of a relevant transaction (see Peer.downloadDependencies).
+            log.debug("{}: Provided with a downloaded transaction we didn't see announced yet: {}",
                     byPeer, tx.getHashAsString());
             entry = new Entry();
             entry.tx = new WeakTransactionReference(tx, referenceQueue);

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -219,7 +219,7 @@ public static ClientBootstrap createClientBootstrap() {
         ExecutorService workerExecutor = Executors.newCachedThreadPool(new PeerGroupThreadFactory());
         NioClientSocketChannelFactory channelFactory = new NioClientSocketChannelFactory(bossExecutor, workerExecutor);
         ClientBootstrap bs = new ClientBootstrap(channelFactory);
-        bs.setOption("connectionTimeoutMillis", 2000);
+        bs.setOption("connectTimeoutMillis", 2000);
         return bs;
     }
 

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -996,7 +996,7 @@ public void run() {
                 tx.getConfidence().addEventListener(new TransactionConfidence.Listener() {
                     public void onConfidenceChanged(Transaction tx) {
                         // This will run in a peer thread.
-                        final int numSeenPeers = tx.getConfidence().getBroadcastBy().size();
+                        final int numSeenPeers = tx.getConfidence().numBroadcastPeers();
                         boolean done = false;
                         log.info("broadcastTransaction: TX {} seen by {} peers", pinnedTx.getHashAsString(),
                                 numSeenPeers);

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -268,8 +268,8 @@ public void onTransaction(Peer peer, Transaction t) {
         inbound(p1, tx);   // returns nothing after a queue drain.
         // Two peers saw this tx hash.
         assertEquals(2, tx.getConfidence().numBroadcastPeers());
-        assertTrue(tx.getConfidence().getBroadcastBy().contains(peerOf(p1).getAddress()));
-        assertTrue(tx.getConfidence().getBroadcastBy().contains(peerOf(p2).getAddress()));
+        assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p1).getAddress()));
+        assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p2).getAddress()));
 
         tx.getConfidence().addEventListener(new TransactionConfidence.Listener() {
             public void onConfidenceChanged(Transaction tx) {
@@ -280,7 +280,7 @@ public void onConfidenceChanged(Transaction tx) {
         inbound(p3, inv);
         assertEquals(tx, event[1]);
         assertEquals(3, tx.getConfidence().numBroadcastPeers());
-        assertTrue(tx.getConfidence().getBroadcastBy().contains(peerOf(p3).getAddress()));
+        assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p3).getAddress()));
     }
 
     @Test

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -83,9 +83,9 @@ public class WalletTool {
             "  --action=SYNC        Sync the wallet with the latest block chain (download new transactions).\n" +
             "                       If the chain file does not exist this will RESET the wallet.\n" +
             "  --action=RESET       Deletes all transactions from the wallet, for if you want to replay the chain.\n" +
-            "  --action=SEND        Creates a transaction with the given --output from this wallet and broadcasts.\n" +
-            "                       You can repeat --output=address:value multiple times, eg:\n" +
+            "  --action=SEND        Creates a transaction with the given --output from this wallet and broadcasts, eg:\n" +
             "                         --output=1GthXFQMktFLWdh5EPNGqbq3H6WdG8zsWj:1.245\n" +
+            "                       You can repeat --output=address:value multiple times.\n" +
             "                       If the output destination starts with 04 and is 65 bytes (130 chars) it will be\n" +
             "                       treated as a public key instead of an address and the send will use \n" +
             "                       <key> CHECKSIG as the script. You can also specify a --fee=0.01\n" +

File: core/src/main/java/com/google/bitcoin/discovery/IrcDiscovery.java
Patch:
@@ -93,7 +93,7 @@ public InetSocketAddress[] getPeers(long timeoutValue, TimeUnit timeoutUnit) thr
         ArrayList<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>();
         connection = null;
         try {
-            InetAddress ip = InetAddress.getByName("irc.lfnet.org");
+            InetAddress ip = InetAddress.getByName(server);
             log.info("Connecting to IRC with " + ip);
             connection = new Socket(server, port);
             writer = new BufferedWriter(new OutputStreamWriter(connection.getOutputStream(), "UTF-8"));

File: core/src/main/java/com/google/bitcoin/core/Utils.java
Patch:
@@ -304,9 +304,10 @@ public static String bitcoinValueToFriendlyString(BigInteger value) {
             value = value.negate();
         BigDecimal bd = new BigDecimal(value, 8);
         String formatted = bd.toPlainString();   // Don't use scientific notation.
+        int decimalPoint = formatted.indexOf(".");
         // Drop unnecessary zeros from the end.
         int toDelete = 0;
-        for (int i = formatted.length() - 1; i > 1; i--) {
+        for (int i = formatted.length() - 1; i > decimalPoint + 2; i--) {
             if (formatted.charAt(i) == '0')
                 toDelete++;
             else

File: core/src/test/java/com/google/bitcoin/core/UtilsTest.java
Patch:
@@ -50,6 +50,7 @@ public void testToNanoCoins() {
 
     @Test
     public void testFormatting() {
+        assertEquals("1.00", bitcoinValueToFriendlyString(toNanoCoins(1, 0)));
         assertEquals("1.23", bitcoinValueToFriendlyString(toNanoCoins(1, 23)));
         assertEquals("0.001", bitcoinValueToFriendlyString(BigInteger.valueOf(COIN.longValue() / 1000)));
         assertEquals("-1.23", bitcoinValueToFriendlyString(toNanoCoins(1, 23).negate()));

File: core/src/test/java/com/google/bitcoin/core/ECKeyTest.java
Patch:
@@ -165,8 +165,7 @@ public void keyRecovery() throws Exception {
         key = new ECKey(null, key.getPubKey());
         boolean found = false;
         for (int i = 0; i < 4; i++) {
-            ECKey key2 = ECKey.recoverFromSignature(i, sig, hash, false);
-            assertNotNull("Key recovery did not work", key2);
+            ECKey key2 = ECKey.recoverFromSignature(i, sig, hash, true);
             if (key.equals(key2)) {
                 found = true;
                 break;

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -533,7 +533,7 @@ public void onKeyAdded(ECKey key) {
 
     private synchronized void recalculateFastCatchupTime() {
         // Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
-        if (chain.shouldVerifyTransactions()) return;
+        if (chain != null && chain.shouldVerifyTransactions()) return;
         long earliestKeyTime = Long.MAX_VALUE;
         for (Wallet w : wallets) {
             earliestKeyTime = Math.min(earliestKeyTime, w.getEarliestKeyCreationTime());
@@ -786,7 +786,7 @@ public MemoryPool getMemoryPool() {
      * {@link Peer#setFastCatchupTime(long)} for further explanation. Call this before starting block chain download.
      */
     public synchronized void setFastCatchupTimeSecs(long secondsSinceEpoch) {
-        Preconditions.checkState(!chain.shouldVerifyTransactions(), "Fast catchup is incompatible with fully verifying");
+        Preconditions.checkState(chain == null || !chain.shouldVerifyTransactions(), "Fast catchup is incompatible with fully verifying");
         fastCatchupTimeSecs = secondsSinceEpoch;
         if (downloadPeer != null) {
             downloadPeer.setFastCatchupTime(secondsSinceEpoch);

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -68,7 +68,6 @@ public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBl
         chain = new BlockChain(unitTestParams, wallet, blockStore);
 
         coinbaseTo = wallet.keychain.get(0).toAddress(unitTestParams);
-
     }
 
     @Test
@@ -200,7 +199,7 @@ public void badDifficulty() throws Exception {
             // allowable difficulty.
             fail();
         } catch (VerificationException e) {
-            assertTrue(e.getMessage(), e.getMessage().indexOf("Difficulty target is bad") >= 0);
+            assertTrue(e.getMessage(), e.getCause().getMessage().indexOf("Difficulty target is bad") >= 0);
         }
 
         // Accept any level of difficulty now.
@@ -211,7 +210,7 @@ public void badDifficulty() throws Exception {
             // We should not get here as the difficulty target should not be changing at this point.
             fail();
         } catch (VerificationException e) {
-            assertTrue(e.getMessage(), e.getMessage().indexOf("Unexpected change in difficulty") >= 0);
+            assertTrue(e.getMessage(), e.getCause().getMessage().indexOf("Unexpected change in difficulty") >= 0);
         }
 
         // TODO: Test difficulty change is not out of range when a transition period becomes valid.

File: core/src/main/java/com/google/bitcoin/core/AbstractBlockChain.java
Patch:
@@ -188,7 +188,8 @@ public synchronized boolean add(Block block) throws VerificationException, Prune
             } catch (BlockStoreException e1) {
                 throw new RuntimeException(e1);
             }
-            throw e;
+            throw new VerificationException("Could not verify block " + block.getHashAsString() + "\n" +
+                    block.toString(), e);
         }
     }
     
@@ -672,7 +673,7 @@ private void checkDifficultyTransitions(StoredBlock storedPrev, Block nextBlock)
         if (timespan > params.targetTimespan * 4)
             timespan = params.targetTimespan * 4;
 
-        BigInteger newDifficulty = Utils.decodeCompactBits(blockIntervalAgo.getDifficultyTarget());
+        BigInteger newDifficulty = Utils.decodeCompactBits(prev.getDifficultyTarget());
         newDifficulty = newDifficulty.multiply(BigInteger.valueOf(timespan));
         newDifficulty = newDifficulty.divide(BigInteger.valueOf(params.targetTimespan));
 

File: core/src/main/java/com/google/bitcoin/core/PeerEventListener.java
Patch:
@@ -56,7 +56,8 @@ public interface PeerEventListener {
     public void onPeerConnected(Peer peer, int peerCount);
 
     /**
-     * Called when a peer is disconnected
+     * Called when a peer is disconnected. Note that this won't be called if the listener is registered on a
+     * {@link PeerGroup} and the group is in the process of shutting down.
      *
      * @param peer
      * @param peerCount the total number of connected peers

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -154,7 +154,7 @@ public PeerGroup(NetworkParameters params, AbstractBlockChain chain) {
      *
      * <pre>
      *   ClientBootstrap bootstrap = PeerGroup.createClientBootstrap();
-     *   bootstrap.setOption("oonnectionTimeoutMillis", 3000);
+     *   bootstrap.setOption("connectionTimeoutMillis", 3000);
      *   PeerGroup peerGroup = new PeerGroup(params, chain, bootstrap);
      * </pre>
      *

File: core/src/test/java/com/google/bitcoin/core/PeerTest.java
Patch:
@@ -467,7 +467,7 @@ public void pingPong() throws Exception {
         inbound(peer, new Pong(pingMsg.getNonce()));
         elapsed = future.get();
         assertEquals(elapsed, peer.getLastPingTime());
-        assertEquals(14000, peer.getPingTime());
+        assertEquals(7250, peer.getPingTime());
     }
     
     private Message outbound() {

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -218,6 +218,7 @@ public static ClientBootstrap createClientBootstrap() {
         ExecutorService workerExecutor = Executors.newCachedThreadPool(new PeerGroupThreadFactory());
         NioClientSocketChannelFactory channelFactory = new NioClientSocketChannelFactory(bossExecutor, workerExecutor);
         ClientBootstrap bs = new ClientBootstrap(channelFactory);
+        bs.setOption("connectionTimeoutMillis", 2000);
         return bs;
     }
 
@@ -755,6 +756,8 @@ private synchronized boolean announcePendingWalletTransactions(List<Wallet> anno
     }
 
     private synchronized void setDownloadPeer(Peer peer) {
+        if (chain == null)
+            return;
         if (downloadPeer != null) {
             log.info("Unsetting download peer: {}", downloadPeer);
             downloadPeer.setDownloadData(false);

File: core/src/main/java/com/google/bitcoin/core/TCPNetworkConnection.java
Patch:
@@ -41,6 +41,8 @@
 
 import static org.jboss.netty.channel.Channels.write;
 
+// TODO: Remove this class and refactor the way we build Netty pipelines.
+
 /**
  * <p>A {@code TCPNetworkConnection} is used for connecting to a Bitcoin node over the standard TCP/IP protocol.<p>
  *

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -768,11 +768,13 @@ public void complete() {
     /**
      * Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
      * The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
+     * Once the pong is received the value returned by {@link com.google.bitcoin.core.Peer#getLastPingTime()} is
+     * updated.
      * @throws ProtocolException if the peer version is too low to support measurable pings.
      */
     public ListenableFuture<Long> ping() throws IOException, ProtocolException {
         int peerVersion = getPeerVersionMessage().clientVersion;
-        if (peerVersion < 60000)
+        if (peerVersion < Pong.MIN_PROTOCOL_VERSION)
             throw new ProtocolException("Peer version is too low for measurable pings: " + peerVersion);
         PendingPing pendingPing = new PendingPing();
         pendingPings.add(pendingPing);

File: core/src/main/java/com/google/bitcoin/core/TCPNetworkConnection.java
Patch:
@@ -189,6 +189,7 @@ public String toString() {
     public class NetworkHandler extends ReplayingDecoder<VoidEnum> implements ChannelDownstreamHandler {
         @Override
         public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
+            super.channelConnected(ctx, e);
             channel = e.getChannel();
             // The version message does not use checksumming, until Feb 2012 when it magically does.
             // Announce ourselves. This has to come first to connect to clients beyond v0.30.20.2 which wait to hear

File: core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -192,6 +192,7 @@ private static NetworkParameters createTestNet3(NetworkParameters n) {
         n.genesisBlock.setDifficultyTarget(0x1d00ffffL);
         n.genesisBlock.setNonce(414098458);
         n.setSpendableCoinbaseDepth(100);
+        n.setSubsidyDecreaseBlockCount(210000);
         n.id = ID_TESTNET;
         String genesisHash = n.genesisBlock.getHashAsString();
         checkState(genesisHash.equals("000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943"),

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -162,7 +162,7 @@ public PeerGroup(final NetworkParameters params, final AbstractBlockChain chain,
         //   - using connectTo() will increment it by one
         this.maxConnections = 0;
 
-        // Set up a default template version message that doesn't tell the other side what kind of BitCoinJ user
+        // Set up a default template version message that doesn't tell the other side what kind of bitcoinj user
         // this is.
         this.versionMessage = new VersionMessage(params, chain.getBestChainHeight());
 

File: core/src/main/java/com/google/bitcoin/discovery/IrcDiscovery.java
Patch:
@@ -98,7 +98,7 @@ public InetSocketAddress[] getPeers() throws PeerDiscoveryException {
             BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
 
             // Generate a random nick for the connection. This is chosen to be clearly identifiable as coming from
-            // BitCoinJ but not match the standard nick format, so full peers don't try and connect to us.
+            // bitcoinj but not match the standard nick format, so full peers don't try and connect to us.
             String nickRnd = String.format("bcj%d", new Random().nextInt(Integer.MAX_VALUE));
             String command = "NICK " + nickRnd;
             logAndSend(command);

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -42,7 +42,7 @@
  * a data interchange format developed by Google with an efficient binary representation, a type safe specification
  * language and compilers that generate code to work with those data structures for many languages. Protocol buffers
  * can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples. The
- * format is defined by the <tt>bitcoin.proto</tt> file in the BitCoinJ source distribution.<p>
+ * format is defined by the <tt>bitcoin.proto</tt> file in the bitcoinj source distribution.<p>
  *
  * This class is used through its static methods. The most common operations are writeWallet and readWallet, which do
  * the obvious operations on Output/InputStreams. You can use a {@link java.io.ByteArrayInputStream} and equivalent

File: core/src/test/java/com/google/bitcoin/core/FullBlockTestGenerator.java
Patch:
@@ -1077,7 +1077,7 @@ public List<BlockAndValidity> getBlocksToTest(boolean addExpensiveBlocks) throws
     }
     
     private Block createNextBlock(Block baseBlock, int nextBlockHeight, TransactionOutPointWithValue prevOut,
-            BigInteger additionalCoinbaseValue) {
+            BigInteger additionalCoinbaseValue) throws ScriptException {
         BigInteger coinbaseValue = Utils.toNanoCoins(50, 0).shiftRight(nextBlockHeight / params.getSubsidyDecreaseBlockCount())
                 .add((prevOut != null ? prevOut.value : BigInteger.valueOf(0))).subtract(BigInteger.valueOf(1))
                 .add(additionalCoinbaseValue == null ? BigInteger.valueOf(0) : additionalCoinbaseValue);
@@ -1096,11 +1096,11 @@ private Block createNextBlock(Block baseBlock, int nextBlockHeight, TransactionO
         return block;
     }
     
-    private void addOnlyInputToTransaction(Transaction t, TransactionOutPointWithValue prevOut) {
+    private void addOnlyInputToTransaction(Transaction t, TransactionOutPointWithValue prevOut) throws ScriptException {
         addOnlyInputToTransaction(t, prevOut, TransactionInput.NO_SEQUENCE);
     }
     
-    private void addOnlyInputToTransaction(Transaction t, TransactionOutPointWithValue prevOut, long sequence) {
+    private void addOnlyInputToTransaction(Transaction t, TransactionOutPointWithValue prevOut, long sequence) throws ScriptException {
         TransactionInput input = new TransactionInput(params, t, new byte[]{}, prevOut.outpoint);
         input.setSequence(sequence);
         t.addInput(input);

File: core/src/test/java/com/google/bitcoin/core/FullPrunedBlockChainTest.java
Patch:
@@ -139,7 +139,7 @@ public void testFinalizedBlocks() throws Exception {
         assertTrue(out.get() == null);
     }
     
-    private void addInputToTransaction(Transaction t, TransactionOutPoint prevOut, byte[] prevOutScriptPubKey, ECKey sigKey) {
+    private void addInputToTransaction(Transaction t, TransactionOutPoint prevOut, byte[] prevOutScriptPubKey, ECKey sigKey) throws ScriptException {
         TransactionInput input = new TransactionInput(unitTestParams, t, new byte[]{}, prevOut);
         t.addInput(input);
 
@@ -157,4 +157,4 @@ private void addInputToTransaction(Transaction t, TransactionOutPoint prevOut, b
             throw new RuntimeException(e);  // Cannot happen.
         }
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1997,7 +1997,7 @@ private void reprocessUnincludedTxAfterReorg(Map<Sha256Hash, Transaction> pool,
         boolean isDead = false;
         // The transactions that we connected inputs to, so we can go back later and move them into the right
         // bucket if all their outputs got spent.
-        Set<Transaction> connectedTransactions = new TreeSet<Transaction>();
+        Set<Transaction> connectedTransactions = new HashSet<Transaction>();
         for (TransactionInput input : tx.getInputs()) {
             TransactionInput.ConnectionResult result = input.connect(pool, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
             if (result == TransactionInput.ConnectionResult.SUCCESS) {

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -298,7 +298,8 @@ private void processHeaders(HeadersMessage m) throws IOException, ProtocolExcept
                     log.info("Passed the fast catchup time, discarding {} headers and requesting full blocks",
                             m.getBlockHeaders().size() - i);
                     downloadBlockBodies = true;
-                    blockChainDownload(header.getHash());
+                    lastGetBlocksBegin = Sha256Hash.ZERO_HASH;  // Prevent this request being seen as a duplicate.
+                    blockChainDownload(Sha256Hash.ZERO_HASH);
                     return;
                 }
             }

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -334,7 +334,7 @@ private synchronized void processGetData(GetDataMessage getdata) throws IOExcept
     }
 
     private synchronized void processTransaction(Transaction tx) {
-        log.info("{}: Received broadcast tx {}", address, tx.getHashAsString());
+        log.debug("{}: Received broadcast tx {}", address, tx.getHashAsString());
         if (memoryPool != null) {
             // We may get back a different transaction object.
             tx = memoryPool.seen(tx, getAddress());
@@ -451,7 +451,7 @@ private void processInv(InventoryMessage inv) throws IOException {
                     // Some other peer already announced this so don't download.
                     it.remove();
                 } else {
-                    log.info("{}: getdata on tx {}", address, item.hash);
+                    log.debug("{}: getdata on tx {}", address, item.hash);
                     getdata.addItem(item);
                 }
                 memoryPool.seen(item.hash, this.getAddress());

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -403,7 +403,7 @@ private void readConfidence(Transaction tx, Protos.TransactionConfidence confide
             confidence.setDepthInBlocks(confidenceProto.getDepth());
         } else {
             // TEMPORARY CODE FOR MIGRATING 0.5 WALLETS TO 0.6
-            if (chainHeight != 0) {
+            if (chainHeight != 0 && confidenceProto.hasAppearedAtHeight()) {
                 confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight() + 1);
             }
         }

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -404,7 +404,7 @@ private void readConfidence(Transaction tx, Protos.TransactionConfidence confide
         } else {
             // TEMPORARY CODE FOR MIGRATING 0.5 WALLETS TO 0.6
             if (chainHeight != 0) {
-                confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight());
+                confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight() + 1);
             }
         }
         if (confidenceProto.hasWorkDone()) {

File: core/src/main/java/com/google/bitcoin/core/TCPNetworkConnection.java
Patch:
@@ -168,7 +168,8 @@ private void onSecondMessage() throws IOException, ProtocolException {
         // Newer clients use checksumming.
         serializer.setUseChecksumming(peerVersion >= 209);
         // Handshake is done!
-        handshakeFuture.set(this);
+        if (handshakeFuture != null)
+            handshakeFuture.set(this);
     }
 
     public void ping() throws IOException {

File: core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -200,8 +200,9 @@ public static NetworkParameters unitTests() {
         NetworkParameters n = new NetworkParameters();
         n = createTestNet(n);
         n.proofOfWorkLimit = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
-        n.genesisBlock.setNonce(2); // Make this pass the difficulty test 
+        n.genesisBlock.setTime(System.currentTimeMillis() / 1000);
         n.genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
+        n.genesisBlock.solve();
         n.interval = 10;
         n.targetTimespan = 200000000;  // 6 years. Just a very big number.
         n.setSpendableCoinbaseDepth(5);

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -164,7 +164,7 @@ public void difficultyTransitions() throws Exception {
         }
         // Now add another block that has no difficulty adjustment, it should be rejected.
         try {
-            chain.add(prev.createNextBlock(coinbaseTo));
+            chain.add(prev.createNextBlock(coinbaseTo, Block.fakeClock));
             fail();
         } catch (VerificationException e) {
         }

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -339,9 +339,8 @@ public static void main(String[] args) throws Exception {
                 return;
             }
             saveWallet(walletFile);
-        } else {
-            shutdown();
         }
+        shutdown();
     }
 
     private static void send(List<String> outputs) {
@@ -538,6 +537,7 @@ private static void shutdown() {
             peers.stop();
             saveWallet(walletFile);
             store.close();
+            wallet = null;
         } catch (BlockStoreException e) {
             throw new RuntimeException(e);
         }

File: core/src/main/java/com/google/bitcoin/core/Script.java
Patch:
@@ -612,6 +612,7 @@ public Address getToAddress() throws ScriptException {
 
     /**
      * Writes out the given byte buffer to the output stream with the correct opcode prefix
+     * To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false)));
      */
     static void writeBytes(OutputStream os, byte[] buf) throws IOException {
         if (buf.length < OP_PUSHDATA1) {

File: core/src/main/java/com/google/bitcoin/core/Script.java
Patch:
@@ -512,7 +512,7 @@ private void parse(byte[] programBytes, int offset, int length) throws ScriptExc
         cursor = offset;
         while (cursor < offset + length) {
             int opcode = readByte();
-            if (opcode > 0 && opcode < OP_PUSHDATA1) {
+            if (opcode >= 0 && opcode < OP_PUSHDATA1) {
                 // Read some bytes of data, where how many is the opcode value itself.
                 chunks.add(new ScriptChunk(false, getData(opcode)));  // opcode == len here.
             } else if (opcode == OP_PUSHDATA1) {

File: core/src/main/java/com/google/bitcoin/core/GetBlocksMessage.java
Patch:
@@ -81,7 +81,7 @@ protected void bitcoinSerializeToStream(OutputStream stream) throws IOException
             stream.write(Utils.reverseBytes(hash.getBytes()));
         }
         // Next, a block ID to stop at.
-        stream.write(stopHash.getBytes());
+        stream.write(Utils.reverseBytes(stopHash.getBytes()));
     }
 
     @Override

File: core/src/main/java/com/google/bitcoin/core/TransactionConfidence.java
Patch:
@@ -364,7 +364,7 @@ public synchronized Transaction getOverridingTransaction() {
     /**
      * Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
      * in such a way that the double-spending transaction takes precedence over this one. It will not become valid now
-     * unless there is a re-org. Automatically sets the confidence type to OVERRIDDEN_BY_DOUBLE_SPEND.
+     * unless there is a re-org. Automatically sets the confidence type to DEAD.
      */
     public synchronized void setOverridingTransaction(Transaction overridingTransaction) {
         this.overridingTransaction = overridingTransaction;

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -700,6 +700,7 @@ public synchronized void signInputs(SigHash hashType, Wallet wallet) throws Scri
                 bos.write(key.sign(hash.getBytes()));
                 bos.write((hashType.ordinal() + 1) | (anyoneCanPay ? 0x80 : 0));
                 signatures[i] = bos.toByteArray();
+                bos.close();
             } catch (IOException e) {
                 throw new RuntimeException(e);  // Cannot happen.
             }
@@ -767,6 +768,7 @@ public synchronized Sha256Hash hashTransactionForSignature(int inputIndex, byte[
             // Note that this is NOT reversed to ensure it will be signed correctly. If it were to be printed out
             // however then we would expect that it is IS reversed.
             Sha256Hash hash = new Sha256Hash(doubleDigest(bos.toByteArray()));
+            bos.close();
 
             // Put the transaction back to how we found it.
             for (int i = 0; i < inputs.size(); i++) {

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -309,7 +309,7 @@ private void processHeaders(HeadersMessage m) throws IOException, ProtocolExcept
         }
     }
     
-    private void processGetData(GetDataMessage getdata) throws IOException {
+    private synchronized void processGetData(GetDataMessage getdata) throws IOException {
         log.info("Received getdata message: {}", getdata.toString());
         ArrayList<Message> items = new ArrayList<Message>();
         for (PeerEventListener listener : eventListeners) {
@@ -322,7 +322,7 @@ private void processGetData(GetDataMessage getdata) throws IOException {
         if (items.size() == 0) {
             return;
         }
-        log.info("Sending {} items gathered from listeners to peer", items.size());
+        log.info("{}: Sending {} items gathered from listeners to peer", this, items.size());
         for (Message item : items) {
             sendMessage(item);
         }

File: examples/src/main/java/com/google/bitcoin/examples/PingService.java
Patch:
@@ -180,7 +180,7 @@ public void onConfidenceChanged(Transaction tx2) {
     }
 
     private void bounceCoins(Transaction tx) {
-        // It's impossible to pick one specific identity that you receive coins from in BitCoin as there
+        // It's impossible to pick one specific identity that you receive coins from in Bitcoin as there
         // could be inputs from many addresses. So instead we just pick the first and assume they were all
         // owned by the same person.
         try {
@@ -189,7 +189,7 @@ private void bounceCoins(Transaction tx) {
             Address from = input.getFromAddress();
             System.out.println("Received " + Utils.bitcoinValueToFriendlyString(value) + " from " + from.toString());
             // Now send the coins back!
-            Transaction sendTx = w.sendCoins(peerGroup, from, value);
+            Transaction sendTx = w.sendCoins(peerGroup, from, value).tx;
             assert sendTx != null;  // We should never try to send more coins than we have!
             System.out.println("Sent coins back! Transaction hash is " + sendTx.getHashAsString());
             w.saveToFile(walletFile);

File: core/src/main/java/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -502,7 +502,7 @@ public void run() {
             synchronized (PeerGroup.this) {
                 running = false;
                 shutdownPeerDiscovery();
-                synchronized (channelFutures.values()) {
+                synchronized (channelFutures) {
                     for (ChannelFuture future : channelFutures.values()) {
                         future.getChannel().close();
                     }

File: core/src/test/java/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -71,7 +71,7 @@ public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline p = Channels.pipeline();
                 
                 Peer peer = new Peer(params, blockChain, ver);
-                peer.addEventListener(peerGroup.startupListener);
+                peer.addLifecycleListener(peerGroup.startupListener);
                 p.addLast("peer", peer.getHandler());
                 return p;
             }

File: core/src/main/java/com/google/bitcoin/core/Block.java
Patch:
@@ -870,6 +870,7 @@ Block createNextBlock(Address to, long time, byte[] pubKey) {
             // but it must be unique to avoid 'different' transactions looking the same.
             byte[] counter = new byte[32];
             counter[0] = (byte) txCounter++;
+            counter[1] = 1;
             input.getOutpoint().setHash(new Sha256Hash(counter));
             t.addInput(input);
             b.addTransaction(t);

File: core/src/test/java/com/google/bitcoin/core/ChainSplitTest.java
Patch:
@@ -219,6 +219,7 @@ public void testForking6() throws Exception {
         //         -> b2
         Block b3 = b1.createNextBlock(someOtherGuy);
         b3.addTransaction(b2.transactions.get(1));
+        b3.solve();
         chain.add(b3);
         assertEquals("50.00", Utils.bitcoinValueToFriendlyString(wallet.getBalance()));
     }

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.bitcoin.core;
 
-import com.google.bitcoin.core.Wallet.BalanceType;
 import com.google.bitcoin.core.WalletTransaction.Pool;
 import com.google.bitcoin.store.BlockStore;
 import com.google.bitcoin.store.MemoryBlockStore;
@@ -269,7 +268,8 @@ public void balances() throws Exception {
 
     @Test
     public void isConsistent_duplicates() throws Exception {
-        // This test ensures that isConsistent catches duplicate transactions.
+        // This test ensures that isConsistent catches duplicate transactions, eg, because we submitted the same block
+        // twice (this is not allowed).
         Transaction tx = createFakeTx(params, Utils.toNanoCoins(1, 0), myAddress);
         Address someOtherGuy = new ECKey().toAddress(params);
         TransactionOutput output = new TransactionOutput(params, tx, Utils.toNanoCoins(0, 5), someOtherGuy);
@@ -280,7 +280,7 @@ public void isConsistent_duplicates() throws Exception {
         
         Transaction txClone = new Transaction(params, tx.bitcoinSerialize());
         try {
-            wallet.receiveFromBlock(txClone, null, BlockChain.NewBlockType.SIDE_CHAIN);
+            wallet.receiveFromBlock(txClone, null, BlockChain.NewBlockType.BEST_CHAIN);
             fail();
         } catch (IllegalStateException ex) {
             // expected

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -196,6 +196,8 @@ public synchronized void saveToFile(File f) throws IOException {
             // to not write through to physical media for at least a few seconds, but this is the best we can do.
             stream.flush();
             stream.getFD().sync();
+            stream.close();
+            stream = null;
             if (!temp.renameTo(f)) {
                 // Work around an issue on Windows whereby you can't rename over existing files.
                 if (System.getProperty("os.name").toLowerCase().indexOf("win") >= 0) {

File: core/src/main/java/com/google/bitcoin/discovery/IrcDiscovery.java
Patch:
@@ -94,8 +94,8 @@ public InetSocketAddress[] getPeers() throws PeerDiscoveryException {
             InetAddress ip = InetAddress.getByName("irc.lfnet.org");
             log.info("Connecting to IRC with " + ip);
             connection = new Socket(server, port);
-            writer = new BufferedWriter(new OutputStreamWriter(connection.getOutputStream()));
-            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+            writer = new BufferedWriter(new OutputStreamWriter(connection.getOutputStream(), "UTF-8"));
+            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
 
             // Generate a random nick for the connection. This is chosen to be clearly identifiable as coming from
             // BitCoinJ but not match the standard nick format, so full peers don't try and connect to us.

File: core/src/test/java/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -402,9 +402,6 @@ public void onTransactionConfidenceChanged(Wallet wallet, Transaction tx) {
         assertEquals(TransactionConfidence.ConfidenceType.OVERRIDDEN_BY_DOUBLE_SPEND,
                      send1.getConfidence().getConfidenceType());
         
-        // Receive 10 BTC.
-        nanos = Utils.toNanoCoins(10, 0);
-
         TestUtils.DoubleSpends doubleSpends = TestUtils.createFakeDoubleSpendTxns(params, myAddress);
         // t1 spends to our wallet. t2 double spends somewhere else.
         wallet.receivePending(doubleSpends.t1);

File: core/src/main/java/com/google/bitcoin/core/AbstractPeerEventListener.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author miron@google.com (Miron Cuperman)
  */
-public class AbstractPeerEventListener extends Object implements PeerEventListener {
+public class AbstractPeerEventListener implements PeerEventListener {
     public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {
     }
 

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -253,7 +253,7 @@ private void processHeaders(HeadersMessage m) throws IOException, ProtocolExcept
         // likely when we've requested them as part of chain download using fast catchup. We need to add each block to
         // the chain if it pre-dates the fast catchup time. If we go past it, we can stop processing the headers and
         // request the full blocks from that point on instead.
-        Preconditions.checkState(!downloadBlockBodies);
+        Preconditions.checkState(!downloadBlockBodies, toString());
 
         try {
             for (int i = 0; i < m.getBlockHeaders().size(); i++) {
@@ -598,7 +598,6 @@ private void blockChainDownload(Sha256Hash toHash) throws IOException {
         // use the "getheaders" command. Once we find we've gone past the target date, we throw away the downloaded
         // headers and then request the blocks from that point onwards. "getheaders" does not send us an inv, it just
         // sends us the data we requested in a "headers" message.
-        log.info("blockChainDownload({})", toHash.toString());
 
         // TODO: Block locators should be abstracted out rather than special cased here.
         List<Sha256Hash> blockLocator = new ArrayList<Sha256Hash>(51);
@@ -611,6 +610,7 @@ private void blockChainDownload(Sha256Hash toHash) throws IOException {
         // must always put the genesis block as the first entry.
         BlockStore store = blockChain.getBlockStore();
         StoredBlock cursor = blockChain.getChainHead();
+        log.info("blockChainDownload({}) current head = ", toHash.toString(), cursor);
         for (int i = 50; cursor != null && i > 0; i--) {
             blockLocator.add(cursor.getHeader().getHash());
             try {

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -187,7 +187,7 @@ public synchronized void saveToFile(File f) throws IOException {
         FileOutputStream stream = null;
         File temp = null;
         try {
-            File directory = f.getParentFile();
+            File directory = f.getAbsoluteFile().getParentFile();
             temp = File.createTempFile("wallet", null, directory);
             stream = new FileOutputStream(temp);
             saveToFileStream(stream);

File: core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
+import org.spongycastle.util.encoders.Hex;
 
 import java.io.ByteArrayOutputStream;
 import java.io.Serializable;

File: core/src/main/java/com/google/bitcoin/core/Sha256Hash.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
+import org.spongycastle.util.encoders.Hex;
 
 import java.io.Serializable;
 import java.math.BigInteger;

File: core/src/main/java/com/google/bitcoin/core/Utils.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.crypto.digests.RIPEMD160Digest;
+import org.spongycastle.crypto.digests.RIPEMD160Digest;
 
 import java.io.IOException;
 import java.io.OutputStream;

File: core/src/test/java/com/google/bitcoin/core/AddressTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import java.util.Arrays;
 

File: core/src/test/java/com/google/bitcoin/core/AlertMessageTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Before;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;

File: core/src/test/java/com/google/bitcoin/core/BitcoinSerializerTest.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.bitcoin.core;
 
 
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;

File: core/src/test/java/com/google/bitcoin/core/BlockTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;

File: core/src/test/java/com/google/bitcoin/core/LazyParseByteCacheTest.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.bitcoin.store.BlockStore;
 import com.google.bitcoin.store.MemoryBlockStore;
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Before;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;

File: core/src/test/java/com/google/bitcoin/core/PeerAddressTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import java.net.InetAddress;
 

File: core/src/test/java/com/google/bitcoin/core/ScriptTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.bitcoin.core;
 
-import org.bouncycastle.util.encoders.Hex;
 import org.junit.Test;
+import org.spongycastle.util.encoders.Hex;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;

File: tools/src/main/java/com/google/bitcoin/tools/WalletTool.java
Patch:
@@ -27,9 +27,9 @@
 import joptsimple.OptionSet;
 import joptsimple.OptionSpec;
 import joptsimple.util.DateConverter;
-import org.bouncycastle.util.encoders.Hex;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.spongycastle.util.encoders.Hex;
 
 import java.io.File;
 import java.io.IOException;

File: core/src/main/java/com/google/bitcoin/core/ECKey.java
Patch:
@@ -49,6 +49,9 @@ public class ECKey implements Serializable {
     private static final SecureRandom secureRandom;
     private static final long serialVersionUID = -728224901792295832L;
 
+    /** How many bytes a Bitcoin public key is: 65, that is, two 32 byte co-ordinates plus a one byte header. */
+    public static final int PUBLIC_KEY_LENGTH = 65;
+
     static {
         // All clients must agree on the curve to use by agreement. Bitcoin uses secp256k1.
         X9ECParameters params = SECNamedCurves.getByName("secp256k1");

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -232,7 +232,7 @@ public boolean isConsistent() {
         int size2 = unspent.size() + spent.size() + pendingInactive.size() + dead.size();
         if (size1 != size2) {
             log.error("Inconsistent wallet sizes: {} {}", size1, size2);
-            success = true;
+            success = false;
         }
         
         for (Transaction tx : unspent.values()) {

File: core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -300,7 +300,8 @@ private WalletTransaction connectTransactionOutputs(org.bitcoinj.wallet.Protos.T
             if (transactionOutput.hasSpentByTransactionHash()) {
                 Transaction spendingTx = txMap.get(transactionOutput.getSpentByTransactionHash());
                 final int spendingIndex = transactionOutput.getSpentByTransactionIndex();
-                output.markAsSpent(spendingTx.getInputs().get(spendingIndex));
+                TransactionInput input = spendingTx.getInputs().get(spendingIndex);
+                input.connect(output);
             }
         }
         

File: core/src/main/java/com/google/bitcoin/core/HeadersMessage.java
Patch:
@@ -32,7 +32,7 @@ public class HeadersMessage extends Message {
     private static final Logger log = LoggerFactory.getLogger(HeadersMessage.class);
 
     // The main client will never send us more than this number of headers.
-    final static int MAX_HEADERS = 2000;
+    public static final int MAX_HEADERS = 2000;
 
     private List<Block> blockHeaders;
 

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -315,7 +315,7 @@ private void processTransaction(Transaction m) {
     }
 
     private void processBlock(Block m) throws IOException {
-        log.info("Received broadcast block {}", m.getHashAsString());
+        log.debug("Received broadcast block {}", m.getHashAsString());
         try {
             // Was this block requested by getBlock()?
             synchronized (pendingGetBlockFutures) {

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -64,7 +64,6 @@ public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBl
 
         coinbaseTo = wallet.keychain.get(0).toAddress(unitTestParams);
 
-        testNet.checkBlockDifficulty = true;
     }
 
     @Test

File: core/src/test/java/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -63,6 +63,8 @@ public void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBl
         chain = new BlockChain(unitTestParams, wallet, blockStore);
 
         coinbaseTo = wallet.keychain.get(0).toAddress(unitTestParams);
+
+        testNet.checkBlockDifficulty = true;
     }
 
     @Test

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -221,7 +221,7 @@ public void run() throws PeerException {
             disconnect();
             throw new PeerException(e);
         } catch (RuntimeException e) {
-            log.error("Unexpected exception in peer loop: ", e.getMessage());
+            log.error("Unexpected exception in peer loop", e);
             disconnect();
             throw e;
         }

File: core/src/main/java/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1554,7 +1554,7 @@ public synchronized long getEarliestKeyCreationTime() {
     private transient PeerEventListener peerEventListener;
 
     /**
-     * Use the returned object can be used to connect the wallet to a {@link Peer} or {@link PeerGroup} in order to
+     * The returned object can be used to connect the wallet to a {@link Peer} or {@link PeerGroup} in order to
      * receive and process blocks and transactions.
      */
     public synchronized PeerEventListener getPeerEventListener() {

File: core/src/main/java/com/google/bitcoin/core/Block.java
Patch:
@@ -194,15 +194,15 @@ protected void parseLite() throws ProtocolException {
      * there are some interdependencies. For example altering a tx requires invalidating the Merkle root and therefore
      * the cached header bytes.
      */
-    private synchronized void maybeParseHeader() {
+    private void maybeParseHeader() {
         if (headerParsed || bytes == null)
             return;
         parseHeader();
         if (!(headerBytesValid || transactionBytesValid))
             bytes = null;
     }
 
-    private synchronized void maybeParseTransactions() {
+    private void maybeParseTransactions() {
         if (transactionsParsed || bytes == null)
             return;
         try {
@@ -223,7 +223,7 @@ private synchronized void maybeParseTransactions() {
      * Ensure the object is parsed if needed. This should be called in every getter before returning a value. If the
      * lazy parse flag is not set this is a method returns immediately.
      */
-    protected synchronized void maybeParse() {
+    protected void maybeParse() {
         throw new LazyParseException(
                 "checkParse() should never be called on a Block.  Instead use checkParseHeader() and checkParseTransactions()");
     }

File: core/src/main/java/com/google/bitcoin/core/Message.java
Patch:
@@ -312,8 +312,6 @@ public byte[] unsafeBitcoinSerialize() {
             return buf;
         }
 
-        checkState(bytes == null, "Cached bytes present but failed to use them for serialization");
-
         // No cached array available so serialize parts by stream.
         ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length < 32 ? 32 : length + 32);
         try {

File: core/src/main/java/com/google/bitcoin/core/Transaction.java
Patch:
@@ -199,7 +199,6 @@ public Collection<Sha256Hash> getAppearsInHashes() {
             return appearsInHashes;
         
         if (appearsIn != null) {
-            Preconditions.checkState(appearsInHashes == null);
             log.info("Migrating a tx to appearsInHashes");
             appearsInHashes = new HashSet<Sha256Hash>(appearsIn.size());
             for (StoredBlock block : appearsIn) {
@@ -741,7 +740,7 @@ public synchronized TransactionConfidence getConfidence() {
     }
 
     /** Check if the transaction has a known confidence */
-    public boolean hasConfidence() {
+    public synchronized boolean hasConfidence() {
         return confidence != null && confidence.getConfidenceType() != TransactionConfidence.ConfidenceType.UNKNOWN;
     }
 

File: core/src/main/java/com/google/bitcoin/core/TransactionConfidence.java
Patch:
@@ -72,7 +72,7 @@ public class TransactionConfidence implements Serializable {
      * <p>Adds an event listener that will be run when this confidence object is updated. The listener will be locked and
      * is likely to be invoked on a peer thread.</p>
      * 
-     * <p>Note that this is NOT called when every block is arrived. Instead it is called when the transaction 
+     * <p>Note that this is NOT called when every block arrives. Instead it is called when the transaction
      * transitions between confidence states, ie, from not being seen in the chain to being seen (not necessarily in 
      * the best chain). If you want to know when the transaction gets buried under another block, listen for new block
      * events using {@link PeerEventListener#onBlocksDownloaded(Peer, Block, int)} and then use the getters on the
@@ -304,7 +304,7 @@ public synchronized int getDepthInBlocks(BlockChain chain) {
      * @throws IllegalStateException if confidence type is not BUILDING
      * @return estimated number of hashes needed to reverse the transaction.
      */
-    public BigInteger getWorkDone(BlockChain chain) throws BlockStoreException {
+    public synchronized BigInteger getWorkDone(BlockChain chain) throws BlockStoreException {
         int depth;
         synchronized (this) {
             if (getConfidenceType() != ConfidenceType.BUILDING)

File: core/src/main/java/com/google/bitcoin/core/Base58.java
Patch:
@@ -58,6 +58,9 @@ public static String encode(byte[] input) {
     }
 
     public static byte[] decode(String input) throws AddressFormatException {
+        if (input.length() == 0) {
+            throw new AddressFormatException("Attempt to parse an empty address.");
+        }
         byte[] bytes = decodeToBigInteger(input).toByteArray();
         // We may have got one more byte than we wanted, if the high bit of the next-to-last byte was not zero. This
         // is because BigIntegers are represented with twos-compliment notation, thus if the high bit of the last

File: core/src/main/java/com/google/bitcoin/uri/BitcoinURIParseException.java
Patch:
@@ -9,11 +9,9 @@
  * that reported in the exception message). Since this is in English, it may not be worth reporting directly
  * to the user other than as part of a "general failure to parse" response.</p>
  *
- * @since 0.3.0
- *        
+ * @since 0.4.0
  */
 public class BitcoinURIParseException extends RuntimeException {
-
     public BitcoinURIParseException(String s) {
         super(s);
     }

File: core/src/test/java/com/google/bitcoin/uri/BitcoinURITest.java
Patch:
@@ -43,7 +43,7 @@ public class BitcoinURITest {
      * @throws AddressFormatException 
      */
     @Test
-    public void testConvertToBitcoinURI() throws BitcoinURIParseException, AddressFormatException {
+    public void testConvertToBitcoinURI() throws Exception {
         Address goodAddress = new Address(NetworkParameters.prodNet(), PRODNET_GOOD_ADDRESS);
         
         // simple example

File: core/src/main/java/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -170,7 +170,8 @@ public Script getScriptSig() throws ScriptException {
      */
     public Address getFromAddress() throws ScriptException {
         if (isCoinBase()) {
-            throw new ScriptException("coinbase transaction");
+            throw new ScriptException(
+                    "This is a coinbase transaction which generates new coins. It does not have a from address.");
         }
         return getScriptSig().getFromAddress();
     }

File: core/src/main/java/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.google.bitcoin.core;
 
+import com.google.common.base.Preconditions;
+
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.io.OutputStream;
@@ -156,8 +158,7 @@ public Script getScriptSig() throws ScriptException {
         // parameter is overloaded to be something totally different.
         if (scriptSig == null) {
             maybeParse();
-            assert scriptBytes != null;
-            scriptSig = new Script(params, scriptBytes, 0, scriptBytes.length);
+            scriptSig = new Script(params, Preconditions.checkNotNull(scriptBytes), 0, scriptBytes.length);
         }
         return scriptSig;
     }

File: core/src/main/java/com/google/bitcoin/core/VersionedChecksummedBytes.java
Patch:
@@ -18,6 +18,8 @@
 
 import java.util.Arrays;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * <p>In Bitcoin the following format is often used to represent some type of key:</p>
  * <p/>
@@ -38,7 +40,7 @@ protected VersionedChecksummedBytes(String encoded) throws AddressFormatExceptio
     }
 
     protected VersionedChecksummedBytes(int version, byte[] bytes) {
-        assert version < 256 && version >= 0;
+        checkArgument(version < 256 && version >= 0);
         this.version = version;
         this.bytes = bytes;
     }

File: core/src/main/java/com/google/bitcoin/core/WalletTransaction.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.bitcoin.core;
 
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * A Transaction in a Wallet - includes the pool ID
  * 
@@ -68,9 +70,7 @@ public static Pool valueOf(int value) {
     private Pool pool;
     
     public WalletTransaction(Pool pool, Transaction transaction) {
-        assert pool != null;
-        
-        this.pool = pool;
+        this.pool = checkNotNull(pool);
         this.transaction = transaction;
     }
 

File: core/src/main/java/com/google/bitcoin/store/DiskBlockStore.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.bitcoin.core.*;
 import com.google.bitcoin.utils.NamedSemaphores;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -32,6 +31,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Stores the block chain to disk but still holds it in memory. This is intended for desktop apps and tests.
  * Constrained environments like mobile phones probably won't want to or be able to store all the block headers in RAM.
@@ -183,7 +184,7 @@ public synchronized void put(StoredBlock block) throws BlockStoreException {
         ensureOpen();
         try {
             Sha256Hash hash = block.getHeader().getHash();
-            assert blockMap.get(hash) == null : "Attempt to insert duplicate";
+            checkState(blockMap.get(hash) == null, "Attempt to insert duplicate");
             // Append to the end of the file. The other fields in StoredBlock will be recalculated when it's reloaded.
             byte[] bytes = block.getHeader().bitcoinSerialize();
             file.write(bytes);

File: core/src/test/java/com/google/bitcoin/core/BitcoinSerializerTest.java
Patch:
@@ -203,7 +203,6 @@ private void testCachedParsing(boolean lazy)  throws Exception {
      */
     @Test
     public void testHeaders1() throws Exception {
-
         BitcoinSerializer bs = new BitcoinSerializer(NetworkParameters.prodNet(), true,
                 null);
 

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -700,6 +700,7 @@ public int getPeerBlockHeightDifference() {
      * <p>This does not wait for the loop to terminate.
      */
     public synchronized void disconnect() {
+        log.debug("Disconnecting peer");
         running = false;
         try {
             // This is the correct way to stop an IO bound loop

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -154,7 +154,8 @@ public String toString() {
      */
     public synchronized void connect() throws PeerException {
         try {
-            conn = new TCPNetworkConnection(address, params, CONNECT_TIMEOUT_MSEC, false, versionMessage);
+            conn = new TCPNetworkConnection(params, false, versionMessage);
+            conn.connect(address, CONNECT_TIMEOUT_MSEC);
         } catch (IOException ex) {
             throw new PeerException(ex);
         } catch (ProtocolException ex) {

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -42,7 +42,7 @@ public class Peer {
     private final NetworkParameters params;
     // Whether the peer loop is supposed to be running or not. Set to false during shutdown so the peer loop
     // knows to quit when the socket goes away.
-    private boolean running;
+    private volatile boolean running;
     private final BlockChain blockChain;
     // When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
     // whilst waiting for the response. Synchronized on itself. Is not used for downloads Peer generates itself.
@@ -182,7 +182,7 @@ public void run() throws PeerException {
         running = true;
 
         try {
-            while (true) {
+            while (running) {
                 Message m = conn.readMessage();
 
                 // Allow event listeners to filter the message stream. Listeners are allowed to drop messages by

File: core/src/main/java/com/google/bitcoin/core/Peer.java
Patch:
@@ -729,7 +729,7 @@ public PeerAddress getAddress() {
      * @return various version numbers claimed by peer.
      */
     public VersionMessage getVersionMessage() {
-      return versionMessage;
+      return conn.getVersionMessage();
     }
 
     /**

File: core/src/main/java/com/google/bitcoin/store/BlockStore.java
Patch:
@@ -52,4 +52,7 @@ public interface BlockStore {
      * Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
      */
     void setChainHead(StoredBlock chainHead) throws BlockStoreException;
+    
+    /** Closes the store. */
+    void close() throws BlockStoreException;
 }

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -688,6 +688,8 @@ public int getPeerBlockHeightDifference() {
 
     /**
      * Terminates the network connection and stops the message handling loop.
+     * 
+     * <p>This does not wait for the loop to terminate.
      */
     public synchronized void disconnect() {
         running = false;

File: tests/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -115,8 +115,8 @@ public void receiveTxBroadcast() throws Exception {
         peerGroup.addPeer(p2);
         
         // Check the peer accessors.
-        assertEquals(2, peerGroup.numPeers());
-        Set<Peer> tmp = new HashSet<Peer>(peerGroup.getPeers());
+        assertEquals(2, peerGroup.numConnectedPeers());
+        Set<Peer> tmp = new HashSet<Peer>(peerGroup.getConnectedPeers());
         Set<Peer> expectedPeers = new HashSet<Peer>();
         expectedPeers.add(p1);
         expectedPeers.add(p2);
@@ -145,7 +145,7 @@ public void singleDownloadPeer1() throws Exception {
         peerGroup.start();
         peerGroup.addPeer(p1);
         peerGroup.addPeer(p2);
-        assertEquals(2, peerGroup.numPeers());
+        assertEquals(2, peerGroup.numConnectedPeers());
 
         // Set up a little block chain. We heard about b1 but not b2 (it is pending download). b3 is solved whilst we
         // are downloading the chain.

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -476,7 +476,7 @@ private void tryNextPeer() throws InterruptedException {
             PeerAddress address = inactives.take();
             while (true) {
                 try {
-                    VersionMessage ver = versionMessage.duplicate();
+                    VersionMessage ver = getVersionMessage().duplicate();
                     ver.bestHeight = chain.getBestChainHeight();
                     ver.time = Utils.now().getTime() / 1000;
                     Peer peer = new Peer(params, address, chain, ver);

File: src/com/google/bitcoin/core/Message.java
Patch:
@@ -456,7 +456,7 @@ String readStr() {
         }
     }
 
-    public class LazyParseException extends RuntimeException {
+    public static class LazyParseException extends RuntimeException {
         private static final long serialVersionUID = 6971943053112975594L;
 
         public LazyParseException(String message, Throwable cause) {

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -609,7 +609,7 @@ private void blockChainDownload(Sha256Hash toHash) throws IOException {
         blockLocator.add(params.genesisBlock.getHash());
         Block topBlock = blockChain.getChainHead().getHeader();
         if (!topBlock.equals(params.genesisBlock)) {
-            if (!topBlock.getPrevBlockHash().equals(params.genesisBlock)){
+            if (!topBlock.getPrevBlockHash().equals(params.genesisBlock.getHash())){
                 blockLocator.add(0, topBlock.getPrevBlockHash());
             }
             blockLocator.add(0, topBlock.getHash());

File: src/com/google/bitcoin/discovery/PeerDiscovery.java
Patch:
@@ -27,6 +27,7 @@ public interface PeerDiscovery {
 
     /** Returns an array of addresses. This method may block. */
     InetSocketAddress[] getPeers() throws PeerDiscoveryException;
+
     /** Stops any discovery in progress when we want to shut down quickly. */
     void shutdown();
 }

File: src/com/google/bitcoin/discovery/DnsDiscovery.java
Patch:
@@ -112,4 +112,7 @@ public static String[] getDefaultHostNames() {
         return defaultHosts;
     }
 
+    /** We don't have a way to abort a DNS lookup, so this does nothing */
+    public void shutdown() {
+    }
 }

File: src/com/google/bitcoin/discovery/PeerDiscovery.java
Patch:
@@ -27,4 +27,6 @@ public interface PeerDiscovery {
 
     /** Returns an array of addresses. This method may block. */
     InetSocketAddress[] getPeers() throws PeerDiscoveryException;
+    /** Stops any discovery in progress when we want to shut down quickly. */
+    void shutdown();
 }

File: src/com/google/bitcoin/discovery/SeedPeers.java
Patch:
@@ -126,4 +126,7 @@ private InetAddress convertAddress(int seed) throws UnknownHostException {
                     0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                     0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
             };
+    
+    public void shutdown() {
+    }
 }

File: tests/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -89,6 +89,8 @@ public InetSocketAddress[] getPeers() throws PeerDiscoveryException {
                     return new InetSocketAddress[]{new InetSocketAddress("localhost", 0)};
                 }
             }
+            public void shutdown() {
+            }
         });
         peerGroup.start();
         sem.acquire();

File: src/com/google/bitcoin/core/GetBlocksMessage.java
Patch:
@@ -86,7 +86,7 @@ protected void bitcoinSerializeToStream(OutputStream stream) throws IOException
 
     @Override
     public boolean equals(Object o) {
-        if (!(o instanceof GetBlocksMessage)) return false;
+        if (o == null || o.getClass() != getClass()) return false;
         GetBlocksMessage other = (GetBlocksMessage) o;
         return (other.version == version &&
                 locator.size() == other.locator.size() && locator.containsAll(other.locator) &&

File: src/com/google/bitcoin/core/GetHeadersMessage.java
Patch:
@@ -46,7 +46,7 @@ public String toString() {
      */
     @Override
     public boolean equals(Object o) {
-        if (!(o instanceof GetHeadersMessage)) return false;
+        if (o == null || o.getClass() != getClass()) return false;
         GetHeadersMessage other = (GetHeadersMessage) o;
         return (other.version == version &&
                 locator.size() == other.locator.size() && locator.containsAll(other.locator) &&

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -296,7 +296,7 @@ private void processTransaction(Transaction m) {
     }
 
     private void processBlock(Block m) throws IOException {
-        log.info("Received broadcast block {}", m.getHashAsString());
+        log.trace("Received broadcast block {}", m.getHashAsString());
         try {
             // Was this block requested by getBlock()?
             synchronized (pendingGetBlockFutures) {
@@ -352,7 +352,7 @@ private void processInv(InventoryMessage inv) throws IOException {
         if (!downloadData)
             return;
 
-        // The peer told us about some blocks or transactions they have. For now we only care about blocks.
+        // The peer told us about some blocks or transactions they have.
         Block topBlock = blockChain.getUnconnectedBlock();
         Sha256Hash topHash = (topBlock != null ? topBlock.getHash() : null);
         if (isNewBlockTickle(topHash, items)) {

File: src/com/google/bitcoin/core/NetworkConnection.java
Patch:
@@ -61,7 +61,9 @@ public interface NetworkConnection {
      */
     void writeMessage(Message message) throws IOException;
 
-    /** Returns the version message received from the other end of the connection during the handshake. */
+    /**
+     * Returns the version message received from the other end of the connection during the handshake.
+     */
     VersionMessage getVersionMessage();
 
     /**

File: src/com/google/bitcoin/examples/PingService.java
Patch:
@@ -98,7 +98,8 @@ public PingService(String[] args) throws Exception {
         chain = new BlockChain(params, wallet, blockStore);
 
         peerGroup = new PeerGroup(params, chain);
-
+        // Set some version info.
+        peerGroup.setUserAgent("PingService", "1.0");
         // Download headers only until a day ago.
         peerGroup.setFastCatchupTimeSecs((new Date().getTime() / 1000) - (60 * 60 * 24));
         if (peerHost != null) {

File: src/com/google/bitcoin/examples/toywallet/ToyWallet.java
Patch:
@@ -105,6 +105,7 @@ public ToyWallet(boolean testnet, String[] args) throws Exception {
         chain = new BlockChain(params, wallet, new BoundedOverheadBlockStore(params, blockChainFile));
 
         peerGroup = new PeerGroup(params, chain);
+        peerGroup.setUserAgent("ToyWallet", "1.0");
         if (testnet) {
             peerGroup.addAddress(new PeerAddress(InetAddress.getByName("plan99.net"), 18333));
             peerGroup.addAddress(new PeerAddress(InetAddress.getByName("localhost"), 18333));

File: tests/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -292,8 +292,7 @@ public void announce() throws Exception {
         assertTrue(n3.outbound() instanceof InventoryMessage);
         peerGroup.stop();
     }
-
-
+    
     private void disconnectAndWait(MockNetworkConnection conn) throws IOException, InterruptedException {
         conn.disconnect();
         disconnectedPeers.take();

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -770,7 +770,7 @@ public long getTimeSeconds() {
      * Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
      */
     public Date getTime() {
-        return new Date(getTimeSeconds());
+        return new Date(getTimeSeconds()*1000);
     }
 
     void setTime(long time) {

File: src/com/google/bitcoin/store/WalletProtobufSerializer.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.Map;
 
 import org.bitcoinj.wallet.Protos;
-import org.bitcoinj.wallet.Protos.TransactionInput.Builder;
 
 import com.google.bitcoin.core.AddressFormatException;
 import com.google.bitcoin.core.ECKey;
@@ -108,7 +107,7 @@ private static Protos.Transaction makeTxProto(WalletTransaction wtx) {
         
         // Handle inputs
         for (TransactionInput input : tx.getInputs()) {
-            Builder inputBuilder = Protos.TransactionInput.newBuilder()
+            Protos.TransactionInput.Builder inputBuilder = Protos.TransactionInput.newBuilder()
                 .setScriptBytes(ByteString.copyFrom(input.getScriptBytes()))
                 .setTransactionOutPointHash(ByteString.copyFrom(
                     input.getOutpoint().getHash().getBytes()))
@@ -203,7 +202,7 @@ private void readTransaction(Protos.Transaction txProto,
             tx.addOutput(output);
         }
 
-        if (txMap.containsKey(tx.getHash())) {
+        if (txMap.containsKey(ByteString.copyFrom(tx.getHash().getBytes()))) {
             throw new RuntimeException("Transaction " + tx.getHashAsString() + " appears twice");
         }
         

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -200,7 +200,7 @@ private boolean isConsistent() {
         // Pending and inactive can overlap, so merge them before counting
         HashSet<Transaction> pendingInactive = new HashSet<Transaction>();
         pendingInactive.addAll(pending.values());
-        pendingInactive.retainAll(inactive.values());
+        pendingInactive.addAll(inactive.values());
         
         return getTransactions(true, true).size() ==
                unspent.size() + spent.size() + pendingInactive.size() + dead.size();

File: src/com/google/bitcoin/core/Transaction.java
Patch:
@@ -87,9 +87,9 @@ public Transaction(NetworkParameters params) {
         length = 10; // 8 for std fields + 1 for each 0 varint
     }
 
-    public Transaction(int version, NetworkParameters params, Sha256Hash hash) {
+    public Transaction(NetworkParameters params, int version, Sha256Hash hash) {
         super(params);
-        this.version = version & ((1L<<32) - 1);
+        this.version = version & ((1L<<32) - 1); // this field is unsigned - remove any sign extension
         inputs = new ArrayList<TransactionInput>();
         outputs = new ArrayList<TransactionOutput>();
         this.hash = hash;

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -306,7 +306,7 @@ public boolean broadcastTransaction(Transaction tx) {
      *   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
      * </ol>
      */
-    public void addWallet(Wallet wallet) {
+    public synchronized void addWallet(Wallet wallet) {
         if (wallet == null)
             throw new IllegalArgumentException("wallet is null");
         wallets.add(wallet);
@@ -527,8 +527,8 @@ protected synchronized void handleNewPeer(Peer peer) {
         // Now tell the peers about any transactions we have which didn't appear in the chain yet. These are not
         // necessarily spends we created. They may also be transactions broadcast across the network that we saw,
         // which are relevant to us, and which we therefore wish to help propagate (ie they send us coins).
-        announcePendingWalletTransactions(wallets, Collections.singleton(peer));
         peer.addEventListener(getDataListener);
+        announcePendingWalletTransactions(wallets, Collections.singleton(peer));
         synchronized (peerEventListeners) {
             for (PeerEventListener listener : peerEventListeners) {
                 synchronized (listener) {

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -211,7 +211,7 @@ public void run() throws PeerException {
             throw new PeerException(e);
         } catch (RuntimeException e) {
             disconnect();
-            log.error("unexpected exception in peer loop", e);
+            log.error("unexpected exception in peer loop: ", e.getMessage());
             throw e;
         }
 

File: tests/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -312,7 +312,9 @@ public void onCoinsReceived(Wallet wallet, Transaction tx, BigInteger prevBalanc
         assertFalse(flags[0]);
         // Now check again when we receive it via a block.
         flags[1] = true;
-        wallet.receiveFromBlock(t1, createFakeBlock(params, blockStore, t1).storedBlock,
+        // Make a fresh copy of the tx to ensure we're testing realistically.
+        final Transaction t1Copy = new Transaction(params, t1.bitcoinSerialize());
+        wallet.receiveFromBlock(t1Copy, createFakeBlock(params, blockStore, t1Copy).storedBlock,
                                 BlockChain.NewBlockType.BEST_CHAIN);
         assertTrue(flags[0]);
         assertFalse(flags[1]);  // is not pending

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -356,7 +356,7 @@ public void setFastCatchupTime(long secondsSinceEpoch) {
             fastCatchupTimeSecs = secondsSinceEpoch;
             // If the given time is before the current chains head block time, then this has no effect (we already
             // downloaded everything we need).
-            if (fastCatchupTimeSecs >= blockChain.getChainHead().getHeader().getTimeSeconds()) {
+            if (fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds()) {
                 downloadBlockBodies = false;
             }
         }
@@ -483,7 +483,7 @@ private void blockChainDownload(Sha256Hash toHash) throws IOException {
             }
             blockLocator.add(0, topBlock.getHash());
         }
-        // The stopHash field is set to zero already by the constructor.
+        // The toHash field is set to zero already by the constructor.
         
         if (downloadBlockBodies) {
             GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -453,7 +453,7 @@ private synchronized void setDownloadPeer(Peer peer) {
 
     /**
      * Tells the PeerGroup to download only block headers before a certain time and bodies after that. See
-     * {@link Peer#setFastCatchupTime(long)} for further explanation.
+     * {@link Peer#setFastCatchupTime(long)} for further explanation. Call this before starting block chain download.
      */
     public synchronized void setFastCatchupTimeSecs(long secondsSinceEpoch) {
         fastCatchupTimeSecs = secondsSinceEpoch;

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -1030,13 +1030,13 @@ public Collection<Transaction> getPendingTransactions() {
      * This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
      * optimize chain download for new users of wallet apps. Backwards compatibility notice: if you get zero from this
      * method, you can instead use the time of the first release of your software, as it's guaranteed no users will
-     * have wallets pre-dating this time.
+     * have wallets pre-dating this time. <p>
      * 
-     * @throws IllegalStateException if there are no keys in the wallet.
+     * If there are no keys in the wallet, the current time is returned.
      */
     public long getEarliestKeyCreationTime() {
         if (keychain.size() == 0) {
-            throw new IllegalStateException("No keys in wallet");
+            return Utils.now().getTime() / 1000;
         }
         long earliestTime = Long.MAX_VALUE;
         for (ECKey key : keychain) {

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -390,7 +390,7 @@ private void updateForSpends(Transaction tx) throws VerificationException {
      * If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
      */
     private void maybeMoveTxToSpent(Transaction tx, String context) {
-        if (tx.isEveryOutputSpent()) {
+        if (tx.isEveryOwnedOutputSpent(this)) {
             // There's nothing left I can spend in this transaction.
             if (unspent.remove(tx.getHash()) != null) {
                 if (log.isInfoEnabled()) {

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -382,7 +382,7 @@ private void blockChainDownload(Sha256Hash toHash) throws IOException {
         // TODO: Block locators should be abstracted out rather than special cased here.
         List<Sha256Hash> blockLocator = new LinkedList<Sha256Hash>();
         // For now we don't do the exponential thinning as suggested here: 
-        //  https://en.bitcoin.it/wiki/Protocol_specification#getblocks
+        //   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
         // However, this should be taken seriously going forward. The old implementation only added the hash of the 
         // genesis block and the current chain head, which randomly led us to halt block fetching when ending on a
         // chain that turned out not to be the longest. This happened roughly once a week. 

File: src/com/google/bitcoin/core/BitcoinSerializer.java
Patch:
@@ -334,6 +334,9 @@ private Message makeMessage(String command, int length, byte[] payloadBytes, byt
             return new VersionAck(params, payloadBytes);
         } else if (command.equals("headers")) {
             return new HeadersMessage(params, payloadBytes);
+        } else if (command.equals("alert")) {
+            log.info("alert payload " + Utils.bytesToHexString(payloadBytes));
+            return new AlertMessage(params, payloadBytes);
         } else {
             log.warn("No support for deserializing message with name {}", command);
             return new UnknownMessage(params, command, payloadBytes);

File: src/com/google/bitcoin/core/BitcoinSerializer.java
Patch:
@@ -335,7 +335,8 @@ private Message makeMessage(String command, int length, byte[] payloadBytes, byt
         } else if (command.equals("headers")) {
             return new HeadersMessage(params, payloadBytes);
         } else {
-            throw new ProtocolException("No support for deserializing message with name " + command);
+            log.warn("No support for deserializing message with name {}", command);
+            return new UnknownMessage(params, command, payloadBytes);
         }
         if (checksum != null)
             message.setChecksum(checksum);

File: src/com/google/bitcoin/core/HeadersMessage.java
Patch:
@@ -42,7 +42,9 @@ public HeadersMessage(NetworkParameters params, byte[] payload) throws ProtocolE
     @Override
     protected void parseLite() throws ProtocolException {
         if (length == UNKNOWN_LENGTH) {
+            int saveCursor = cursor;
             long numHeaders = readVarInt();
+            cursor = saveCursor;
 
             // Each header has 80 bytes and one more byte for transactions number which is 00.
             length = 81 * (int)numHeaders;

File: src/com/google/bitcoin/core/Utils.java
Patch:
@@ -270,7 +270,7 @@ static BigInteger decodeMPI(byte[] mpi) {
 
     // The representation of nBits uses another home-brew encoding, as a way to represent a large
     // hash value in only 32 bits.
-    static BigInteger decodeCompactBits(long compact) {
+    public static BigInteger decodeCompactBits(long compact) {
         int size = ((int) (compact >> 24)) & 0xFF;
         byte[] bytes = new byte[4 + size];
         bytes[3] = (byte) size;

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -412,7 +412,7 @@ public void startBlockChainDownload() throws IOException {
         setDownloadData(true);
         // TODO: peer might still have blocks that we don't have, and even have a heavier
         // chain even if the chain block count is lower.
-        if (getPeerBlocksToGet() > 0) {
+        if (getPeerBlocksToGet() >= 0) {
             for (PeerEventListener listener : eventListeners) {
                 synchronized (listener) {
                     listener.onChainDownloadStarted(this, getPeerBlocksToGet());

File: src/com/google/bitcoin/examples/PrintPeers.java
Patch:
@@ -109,6 +109,6 @@ public void run() {
                 }
             });
         }
-        pool.awaitTermination(1, TimeUnit.DAYS);
+        pool.awaitTermination(3600 * 24, TimeUnit.SECONDS); // 1 Day
     }
 }

File: tests/com/google/bitcoin/core/MockNetworkConnection.java
Patch:
@@ -72,7 +72,7 @@ public Message readMessage() throws IOException, ProtocolException {
                 throw new RuntimeException("Unknown object in inbound queue.");
             }
         } catch (InterruptedException e) {
-            throw new IOException(e);
+            throw new IOException(e.getMessage());
         } finally {
             synchronized (this) {
                 waitingToRead = false;
@@ -84,7 +84,7 @@ public void writeMessage(Message message) throws IOException {
         try {
             outboundMessageQ.put(message);
         } catch (InterruptedException e) {
-            throw new IOException(e);
+            throw new IOException(e.getMessage());
         }
     }
 

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -151,6 +151,7 @@ public synchronized void addPeer(Peer peer) {
      * @param maxConnections the maximum number of peer connections that this group will try to make.
      */
     public synchronized void setMaxConnections(int maxConnections) {
+        peerPool.setCorePoolSize(Math.min(maxConnections, DEFAULT_CONNECTIONS));
         peerPool.setMaximumPoolSize(maxConnections);
     }
 

File: src/com/google/bitcoin/core/Utils.java
Patch:
@@ -288,7 +288,6 @@ public static Date now() {
     public static byte[] copyOf(byte[] in, int length) {
         byte[] out = new byte[length];
         System.arraycopy(in, 0, out, 0, Math.min(length, in.length));
-        Arrays.copyOf(in, 6);
         return out;
     }
 }

File: tests/com/google/bitcoin/core/PeerTest.java
Patch:
@@ -136,6 +136,7 @@ public void testRun_unconnected_block() throws Exception {
         
         List<Sha256Hash> expectedLocator = new ArrayList<Sha256Hash>();
         expectedLocator.add(b1.getHash());
+        expectedLocator.add(b1.getPrevBlockHash());
         expectedLocator.add(unitTestParams.genesisBlock.getHash());
         
         assertEquals(message.getValue().getLocator(), expectedLocator);
@@ -171,6 +172,7 @@ public void testRun_inv_tickle() throws Exception {
         
         List<Sha256Hash> expectedLocator = new ArrayList<Sha256Hash>();
         expectedLocator.add(b1.getHash());
+        expectedLocator.add(b1.getPrevBlockHash());
         expectedLocator.add(unitTestParams.genesisBlock.getHash());
         
         assertEquals(message.getValue().getLocator(), expectedLocator);
@@ -234,6 +236,7 @@ public void testStartBlockChainDownload() throws Exception {
         
         List<Sha256Hash> expectedLocator = new ArrayList<Sha256Hash>();
         expectedLocator.add(b1.getHash());
+        expectedLocator.add(b1.getPrevBlockHash());
         expectedLocator.add(unitTestParams.genesisBlock.getHash());
         
         assertEquals(message.getValue().getLocator(), expectedLocator);

File: src/com/google/bitcoin/core/Utils.java
Patch:
@@ -24,6 +24,7 @@
 import java.math.BigInteger;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
 import java.util.Date;
 
 /**
@@ -286,7 +287,8 @@ public static Date now() {
     
     public static byte[] copyOf(byte[] in, int length) {
         byte[] out = new byte[length];
-        System.arraycopy(in, 0, out, 0, length);
+        System.arraycopy(in, 0, out, 0, Math.min(length, in.length));
+        Arrays.copyOf(in, 6);
         return out;
     }
 }

File: src/com/google/bitcoin/core/ChildMessage.java
Patch:
@@ -7,6 +7,7 @@
  * @author git
  */
 public abstract class ChildMessage extends Message {
+    private static final long serialVersionUID = -7657113383624517931L;
 
     private Message parent;
 

File: src/com/google/bitcoin/core/EmptyMessage.java
Patch:
@@ -10,6 +10,7 @@
  * @author git
  */
 public abstract class EmptyMessage extends Message {
+    private static final long serialVersionUID = 8240801253854151802L;
 
     public EmptyMessage() {
         length = 0;

File: src/com/google/bitcoin/core/GetAddrMessage.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.bitcoin.core;
 
 public class GetAddrMessage extends EmptyMessage {
+    private static final long serialVersionUID = 6204437624599661503L;
 
     public GetAddrMessage(NetworkParameters params) {
         super(params);

File: src/com/google/bitcoin/core/ListMessage.java
Patch:
@@ -26,6 +26,8 @@
  * Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.
  */
 public abstract class ListMessage extends Message {
+    private static final long serialVersionUID = -4275896329391143643L;
+
     private long arrayLen;
     // For some reason the compiler complains if this is inside InventoryItem
     private List<InventoryItem> items;

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -179,7 +179,7 @@ protected void parseLite() throws ProtocolException {
         // provided we will have to
         // invoke a light parse of transactions to calculate the length.
         if (length == UNKNOWN_LENGTH) {
-            log.warn("Performing lite parse of block transaction as block was initialised from byte array without providing length.  This should never need to happen.");
+            assert !parseLazy : "Performing lite parse of block transaction as block was initialised from byte array without providing length.  This should never need to happen." + " parseLazy: " + parseLazy;
             parseTransactions();
             length = cursor - offset;
         } else {

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -367,7 +367,7 @@ public byte[] bitcoinSerialize() {
 
 		// At least one of the two cacheable components is invalid
 		// so fall back to stream write since we can't be sure of the length. 
-		ByteArrayOutputStream stream = new ByteArrayOutputStream(length == UNKNOWN_LENGTH ? 80 + guessTransactionsLength()	: length);
+		ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 80 + guessTransactionsLength()	: length);
 		try {
 			writeHeader(stream);
 			writeTransactions(stream);
@@ -442,7 +442,7 @@ private void unCacheTransactions() {
 	 */
 	private Sha256Hash calculateHash() {
 		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
+			ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(80);
 			writeHeader(bos);
 			return new Sha256Hash(Utils.reverseBytes(doubleDigest(bos.toByteArray())));
 		} catch (IOException e) {

File: src/com/google/bitcoin/core/ECKey.java
Patch:
@@ -170,7 +170,8 @@ public byte[] sign(byte[] input) {
         // of the type used by BitCoin we have to encode them using DER encoding, which is just a way to pack the two
         // components into a structure.
         try {
-            ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        	//usually 70-72 bytes.
+            ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(72);
             DERSequenceGenerator seq = new DERSequenceGenerator(bos);
             seq.addObject(new DERInteger(sigs[0]));
             seq.addObject(new DERInteger(sigs[1]));

File: src/com/google/bitcoin/core/Message.java
Patch:
@@ -270,7 +270,7 @@ public byte[] bitcoinSerialize() {
     	assert bytes == null : "cached bytes present but failed to use them for serialization";
     	
     	//no cached array available so serialize parts by stream.
-    	ByteArrayOutputStream stream = new ByteArrayOutputStream(length < 32 ? 32 : length + 32);
+    	ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length < 32 ? 32 : length + 32);
         try {
             bitcoinSerializeToStream(stream);
         } catch (IOException e) {

File: src/com/google/bitcoin/core/Script.java
Patch:
@@ -254,7 +254,7 @@ static void writeBytes(OutputStream os,  byte[] buf) throws IOException {
     static byte[] createOutputScript(Address to) {
         try {
             // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
-            ByteArrayOutputStream bits = new ByteArrayOutputStream();
+            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(24);
             bits.write(OP_DUP);
             bits.write(OP_HASH160);
             writeBytes(bits, to.getHash160());
@@ -270,7 +270,7 @@ static byte[] createOutputScript(Address to) {
     static byte[] createOutputScript(byte[] pubkey) {
         try {
             // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
-            ByteArrayOutputStream bits = new ByteArrayOutputStream();
+            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(pubkey.length + 1);
             writeBytes(bits, pubkey);
             bits.write(OP_CHECKSIG);
             return bits.toByteArray();
@@ -282,7 +282,7 @@ static byte[] createOutputScript(byte[] pubkey) {
     static byte[] createInputScript(byte[] signature,  byte[] pubkey) {
         try {
             // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
-            ByteArrayOutputStream bits = new ByteArrayOutputStream();
+            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + pubkey.length);
             writeBytes(bits, signature);
             writeBytes(bits, pubkey);
             return bits.toByteArray();

File: src/com/google/bitcoin/core/Transaction.java
Patch:
@@ -528,7 +528,8 @@ public void signInputs(SigHash hashType, Wallet wallet) throws ScriptException {
             // Now sign for the output so we can redeem it. We use the keypair to sign the hash,
             // and then put the resulting signature in the script along with the public key (below).
             try {
-                ByteArrayOutputStream bos = new ByteArrayOutputStream();
+            	//usually 71-73 bytes
+                ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(73);
                 bos.write(key.sign(hash));
                 bos.write((hashType.ordinal() + 1) | (anyoneCanPay ? 0x80 : 0)) ;
                 signatures[i] = bos.toByteArray();
@@ -552,7 +553,7 @@ public void signInputs(SigHash hashType, Wallet wallet) throws ScriptException {
 
     private byte[] hashTransactionForSignature(SigHash type, boolean anyoneCanPay) {
         try {
-            ByteArrayOutputStream bos = new ByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
+            ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
             bitcoinSerialize(bos);
             // We also have to write a hash type.
             int hashType = type.ordinal() + 1;

File: tests/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -292,7 +292,7 @@ public void transactionsList() throws Exception {
         assertEquals(tx1,  transactions.get(1));
         assertEquals(2, transactions.size());
         // Check we get only the last transaction if we request a subrage.
-        transactions = wallet.getRecentTransactions(1);
+        transactions = wallet.getRecentTransactions(1, false);
         assertEquals(1, transactions.size());
         assertEquals(tx2,  transactions.get(0));
 

File: src/com/google/bitcoin/core/PeerAddress.java
Patch:
@@ -71,7 +71,7 @@ public PeerAddress(InetSocketAddress addr) {
     @Override
     public void bitcoinSerializeToStream(OutputStream stream) throws IOException {
         if (protocolVersion >= 31402) {
-            int secs = (int)(new Date().getTime() / 1000);
+            int secs = (int)(Utils.now().getTime() / 1000);
             uint32ToByteStreamLE(secs, stream);
         }
         uint64ToByteStreamLE(services, stream);  // nServices.

File: src/com/google/bitcoin/core/Transaction.java
Patch:
@@ -149,7 +149,7 @@ Set<StoredBlock> getAppearsIn() {
      */
     void addBlockAppearance(StoredBlock block, boolean bestChain) {
         if (bestChain && updatedAt == null) {
-            updatedAt = new Date(block.getHeader().getTimeSeconds());
+            updatedAt = new Date(block.getHeader().getTimeSeconds() * 1000);
         }
         if (appearsIn == null) {
             appearsIn = new HashSet<StoredBlock>();
@@ -247,7 +247,7 @@ public Date getUpdateTime() {
             for (StoredBlock b : appearsIn) {
                 earliestTimeSecs = Math.min(b.getHeader().getTimeSeconds(), earliestTimeSecs);
             }
-            updatedAt = new Date(earliestTimeSecs);
+            updatedAt = new Date(earliestTimeSecs * 1000);
         }
         return updatedAt;
     }

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -431,8 +431,7 @@ synchronized void confirmSend(Transaction tx) {
             connectedOutput.markAsSpent(input);
             maybeMoveTxToSpent(connectedTx, "spent tx");
         }
-        // Refresh the timestamp.
-        tx.updatedAt = new Date();
+        tx.updatedAt = Utils.now();
         // Add to the pending pool. It'll be moved out once we receive this transaction on the best chain.
         pending.put(tx.getHash(), tx);
     }

File: tests/com/google/bitcoin/core/TestUtils.java
Patch:
@@ -65,7 +65,7 @@ public static BlockPair createFakeBlock(NetworkParameters params, BlockStore blo
 
     public static BlockPair createFakeBlock(NetworkParameters params, BlockStore blockStore,
                                             Transaction... transactions) {
-        return createFakeBlock(params, blockStore, System.currentTimeMillis() / 1000, transactions);
+        return createFakeBlock(params, blockStore, Utils.now().getTime() / 1000, transactions);
     }
 
     public static Block makeSolvedTestBlock(NetworkParameters params,

File: tests/com/google/bitcoin/core/ChainSplitTests.java
Patch:
@@ -51,7 +51,7 @@ public void testForking1() throws Exception {
         // TODO: Change this test to not use coinbase transactions as they are special (maturity rules).
         final boolean[] reorgHappened = new boolean[1];
         reorgHappened[0] = false;
-        wallet.addEventListener(new WalletEventListener() {
+        wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
             public void onReorganize() {
                 reorgHappened[0] = true;
@@ -185,7 +185,7 @@ public void testDoubleSpendOnFork() throws Exception {
         // double spend on the new best chain.
 
         final boolean[] eventCalled = new boolean[1];
-        wallet.addEventListener(new WalletEventListener() {
+        wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
             public void onDeadTransaction(Transaction deadTx, Transaction replacementTx) {
                 eventCalled[0] = true;
@@ -225,7 +225,7 @@ public void testDoubleSpendOnForkPending() throws Exception {
 
         final Transaction[] eventDead = new Transaction[1];
         final Transaction[] eventReplacement = new Transaction[1];
-        wallet.addEventListener(new WalletEventListener() {
+        wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
             public void onDeadTransaction(Transaction deadTx, Transaction replacementTx) {
                 eventDead[0] = deadTx;

File: tests/com/google/bitcoin/core/WalletTest.java
Patch:
@@ -101,7 +101,7 @@ public void sideChain() throws Exception {
     public void listeners() throws Exception {
         final Transaction fakeTx = createFakeTx(params, Utils.toNanoCoins(1, 0), myAddress);
         final boolean[] didRun = new boolean[1];
-        WalletEventListener listener = new WalletEventListener() {
+        WalletEventListener listener = new AbstractWalletEventListener() {
             public void onCoinsReceived(Wallet w, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {
                 assertTrue(prevBalance.equals(BigInteger.ZERO));
                 assertTrue(newBalance.equals(Utils.toNanoCoins(1, 0)));
@@ -249,7 +249,7 @@ public void finneyAttack() throws Exception {
         // isn't tested because today BitCoinJ only learns about such transactions when they appear in the chain.
         final Transaction[] eventDead = new Transaction[1];
         final Transaction[] eventReplacement = new Transaction[1];
-        wallet.addEventListener(new WalletEventListener() {
+        wallet.addEventListener(new AbstractWalletEventListener() {
             @Override
             public void onDeadTransaction(Transaction deadTx, Transaction replacementTx) {
                 eventDead[0] = deadTx;

File: src/com/google/bitcoin/core/Message.java
Patch:
@@ -153,9 +153,10 @@ String readStr() {
             cursor += 1;
             return "";
         }
+        cursor += varInt.getSizeInBytes();
         byte[] characters = new byte[(int)varInt.value];
         System.arraycopy(bytes, cursor, characters, 0, characters.length);
-        cursor += varInt.getSizeInBytes();
+        cursor += characters.length;
         try {
             return new String(characters, "UTF-8");
         } catch (UnsupportedEncodingException e) {

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -325,9 +325,9 @@ public synchronized void startBlockChainDownload(PeerEventListener listener) {
     }
     
     /**
-     * Download the blockchain from peers.
+     * Download the blockchain from peers.<p>
      * 
-     * <p>This method wait until the download is complete.  "Complete" is defined as downloading
+     * This method waits until the download is complete.  "Complete" is defined as downloading
      * from at least one peer all the blocks that are in that peer's inventory.
      */
     public void downloadBlockChain() {

File: src/com/google/bitcoin/core/Script.java
Patch:
@@ -245,6 +245,7 @@ static void writeBytes(OutputStream os,  byte[] buf) throws IOException {
             os.write(OP_PUSHDATA2);
             os.write(0xFF & (buf.length));
             os.write(0xFF & (buf.length >> 8));
+            os.write(buf);
         } else {
             throw new RuntimeException("Unimplemented");
         }

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -402,7 +402,7 @@ public Thread newThread(Runnable r) {
             // Lower the priority of the peer threads. This is to avoid competing with UI threads created by the API
             // user when doing lots of work, like downloading the block chain. We select a priority level one lower
             // than the parent thread, or the minimum.
-            t.setPriority(Math.max(Thread.MIN_PRIORITY, group.getMaxPriority() - 1));
+            t.setPriority(Math.max(Thread.MIN_PRIORITY, Thread.currentThread().getPriority() - 1));
             t.setDaemon(true);
             return t;
         }

File: src/com/google/bitcoin/core/Sha256Hash.java
Patch:
@@ -27,6 +27,8 @@
  * map. It also checks that the length is correct and provides a bit more type safety.
  */
 public class Sha256Hash implements Serializable {
+    private static final long serialVersionUID = 3778897922647016546L;
+
     private byte[] bytes;
 
     public static final Sha256Hash ZERO_HASH = new Sha256Hash(new byte[32]);

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -25,7 +25,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.xml.bind.annotation.XmlElementRef;
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.InetSocketAddress;

File: src/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -86,6 +86,7 @@ private static Block createGenesis(NetworkParameters n) {
             t.outputs.add(new TransactionOutput(n, t, scriptPubKeyBytes.toByteArray()));
         } catch (Exception e) {
             // Cannot happen.
+            throw new RuntimeException(e);
         }
         genesisBlock.addTransaction(t);
         return genesisBlock;

File: src/com/google/bitcoin/core/Sha256Hash.java
Patch:
@@ -74,8 +74,7 @@ public byte[] getBytes() {
         return bytes;
     }
 
-    @Override
-    public Sha256Hash clone() {
+    public Sha256Hash duplicate() {
         return new Sha256Hash(bytes);
     }
 }

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -258,7 +258,7 @@ public Future<Block> getBlock(Sha256Hash blockHash) throws IOException {
 
     // A GetDataFuture wraps the result of a getBlock or (in future) getTransaction so the owner of the object can
     // decide whether to wait forever, wait for a short while or check later after doing other work.
-    private class GetDataFuture<T extends Message> implements Future<T> {
+    private static class GetDataFuture<T extends Message> implements Future<T> {
         private boolean cancelled;
         private final InventoryItem item;
         private final CountDownLatch latch;

File: src/com/google/bitcoin/core/BlockChain.java
Patch:
@@ -308,11 +308,11 @@ enum NewBlockType {
 
     private void sendTransactionsToWallet(StoredBlock block, NewBlockType blockType,
                                           HashMap<Wallet, List<Transaction>> newTransactions) throws VerificationException {
-        for (Wallet wallet : newTransactions.keySet()) {
+        for (Map.Entry<Wallet, List<Transaction>> entry : newTransactions.entrySet()) {
             try {
-                List<Transaction> txns = newTransactions.get(wallet);
+                List<Transaction> txns = entry.getValue();
                 for (Transaction tx : txns) {
-                    wallet.receive(tx, block, blockType);
+                    entry.getKey().receive(tx, block, blockType);
                 }
             } catch (ScriptException e) {
                 // We don't want scripts we don't understand to break the block chain so just note that this tx was

File: src/com/google/bitcoin/core/BlockChain.java
Patch:
@@ -204,7 +204,7 @@ private void connectBlock(StoredBlock newStoredBlock, StoredBlock storedPrev,
         if (storedPrev.equals(chainHead)) {
             // This block connects to the best known block, it is a normal continuation of the system.
             setChainHead(newStoredBlock);
-            log.info("Chain is now {} blocks high", chainHead.getHeight());
+            log.debug("Chain is now {} blocks high", chainHead.getHeight());
             if (newTransactions != null)
                 sendTransactionsToWallet(newStoredBlock, NewBlockType.BEST_CHAIN, newTransactions);
         } else {
@@ -391,7 +391,7 @@ private void checkDifficultyTransitions(StoredBlock storedPrev, StoredBlock stor
             }
             cursor = blockStore.get(cursor.getHeader().getPrevBlockHash());
         }
-        log.info("Difficulty transition traversal took {}msec", System.currentTimeMillis() - now);
+        log.debug("Difficulty transition traversal took {}msec", System.currentTimeMillis() - now);
 
         Block blockIntervalAgo = cursor.getHeader();
         int timespan = (int) (prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
@@ -406,7 +406,7 @@ private void checkDifficultyTransitions(StoredBlock storedPrev, StoredBlock stor
         newDifficulty = newDifficulty.divide(BigInteger.valueOf(params.targetTimespan));
 
         if (newDifficulty.compareTo(params.proofOfWorkLimit) > 0) {
-            log.warn("Difficulty hit proof of work limit: {}", newDifficulty.toString(16));
+            log.debug("Difficulty hit proof of work limit: {}", newDifficulty.toString(16));
             newDifficulty = params.proofOfWorkLimit;
         }
 

File: src/com/google/bitcoin/core/DownloadListener.java
Patch:
@@ -59,7 +59,7 @@ public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {
 
         double pct = 100.0 - (100.0 * (blocksLeft / (double) originalBlocksLeft));
         if ((int)pct != lastPercent) {
-            progress(pct, new Date(block.getTime() * 1000));
+            progress(pct, new Date(block.getTimeSeconds() * 1000));
             lastPercent = (int)pct;
         }
     }

File: tests/com/google/bitcoin/core/BlockChainTest.java
Patch:
@@ -44,10 +44,8 @@ private void resetBlockStore() {
     }
 
     @Before
-    public void setUp() {
-
+    public void setUp() throws Exception {
         testNetChain = new BlockChain(testNet, new Wallet(testNet), new MemoryBlockStore(testNet));
-
         unitTestParams = NetworkParameters.unitTests();
         wallet = new Wallet(unitTestParams);
         wallet.addKey(new ECKey());

File: tests/com/google/bitcoin/core/ChainSplitTests.java
Patch:
@@ -34,7 +34,7 @@ public class ChainSplitTests {
     private Address someOtherGuy;
 
     @Before
-    public void setUp() {
+    public void setUp() throws Exception {
         unitTestParams = NetworkParameters.unitTests();
         wallet = new Wallet(unitTestParams);
         wallet.addKey(new ECKey());

File: tests/com/google/bitcoin/core/PeerGroupTest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -25,7 +25,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOError;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.util.Collections;
@@ -270,7 +269,7 @@ public void run() {
                     // Fatal error
                     log.error("Block store corrupt?", e);
                     running = false;
-                    throw new IOError(e);
+                    throw new RuntimeException(e);
                 }
                 
                 // If we got here, we should retry this address because an error unrelated

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -437,7 +437,7 @@ void setPrevBlockHash(Sha256Hash prevBlockHash) {
         this.hash = null;
     }
 
-    /** Returns the time at which the block was solved and broadcast, according to the clock of the solving node. */
+    /** Returns the time in seconds at which the block was solved and broadcast, according to the clock of the solving node. */
     public long getTime() {
         return time;
     }

File: src/com/google/bitcoin/core/DownloadListener.java
Patch:
@@ -59,7 +59,7 @@ public void onBlocksDownloaded(Peer peer, Block block, int blocksLeft) {
 
         double pct = 100.0 - (100.0 * (blocksLeft / (double) originalBlocksLeft));
         if ((int)pct != lastPercent) {
-            progress(pct, new Date(block.getTime()));
+            progress(pct, new Date(block.getTime() * 1000));
             lastPercent = (int)pct;
         }
     }

File: src/com/google/bitcoin/core/PeerGroup.java
Patch:
@@ -55,7 +55,7 @@
  *
  */
 public class PeerGroup {
-     private static final int DEFAULT_CONNECTIONS = 10;
+    private static final int DEFAULT_CONNECTIONS = 4;
 
     private static final Logger log = LoggerFactory.getLogger(PeerGroup.class);
     
@@ -103,9 +103,9 @@ public PeerGroup(BlockStore blockStore, NetworkParameters params, BlockChain cha
     }
 
     /**
-     * @param maxConnections the maximum number of peer connections that this group will try to make.
+     * Depending on the environment, this should normally be between 1 and 10, default is 4.
      * 
-     * Depending on the environment, this should normally be between 1 and 10, default is 10.
+     * @param maxConnections the maximum number of peer connections that this group will try to make.
      */
     public void setMaxConnections(int maxConnections) {
         this.maxConnections = maxConnections;

File: src/com/google/bitcoin/core/BlockChain.java
Patch:
@@ -207,7 +207,7 @@ private void connectBlock(StoredBlock newStoredBlock, StoredBlock storedPrev,
         if (storedPrev.equals(chainHead)) {
             // This block connects to the best known block, it is a normal continuation of the system.
             setChainHead(newStoredBlock);
-            log.trace("Chain is now {} blocks high", chainHead.getHeight());
+            log.info("Chain is now {} blocks high", chainHead.getHeight());
             if (newTransactions != null)
                 sendTransactionsToWallet(newStoredBlock, NewBlockType.BEST_CHAIN, newTransactions);
         } else {
@@ -437,10 +437,11 @@ private void scanTransactions(Block block, HashMap<Wallet, List<Transaction>> wa
                     boolean shouldReceive = false;
                     for (TransactionOutput output : tx.outputs) {
                         // TODO: Handle more types of outputs, not just regular to address outputs.
-                        if (output.getScriptPubKey().isSentToIP()) return;
+                        if (output.getScriptPubKey().isSentToIP()) continue;
                         // This is not thread safe as a key could be removed between the call to isMine and receive.
                         if (output.isMine(wallet)) {
                             shouldReceive = true;
+                            break;
                         }
                     }
 

File: src/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -83,7 +83,7 @@ private static Block createGenesis(NetworkParameters n) {
             Script.writeBytes(scriptPubKeyBytes, Hex.decode
                             ("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"));
             scriptPubKeyBytes.write(Script.OP_CHECKSIG);
-            t.outputs.add(new TransactionOutput(n, scriptPubKeyBytes.toByteArray()));
+            t.outputs.add(new TransactionOutput(n, t, scriptPubKeyBytes.toByteArray()));
         } catch (Exception e) {
             // Cannot happen.
         }

File: src/com/google/bitcoin/core/Sha256Hash.java
Patch:
@@ -29,7 +29,7 @@
 public class Sha256Hash implements Serializable {
     private byte[] bytes;
 
-    public static Sha256Hash ZERO_HASH = new Sha256Hash(new byte[32]);
+    public static final Sha256Hash ZERO_HASH = new Sha256Hash(new byte[32]);
 
     /** Creates a Sha256Hash by wrapping the given byte array. It must be 32 bytes long. */
     public Sha256Hash(byte[] bytes) {

File: src/com/google/bitcoin/core/TransactionInput.java
Patch:
@@ -124,7 +124,8 @@ public String toString() {
         if (isCoinBase())
             return "TxIn: COINBASE";
         try {
-            return "TxIn from " + Utils.bytesToHexString(getScriptSig().getPubKey()) + " script:" +
+            return "TxIn from tx " + outpoint + " (pubkey: " + Utils.bytesToHexString(getScriptSig().getPubKey()) +
+                    ") script:" +
                     getScriptSig().toString();
         } catch (ScriptException e) {
             throw new RuntimeException(e);

File: src/com/google/bitcoin/core/TransactionOutput.java
Patch:
@@ -67,10 +67,11 @@ public TransactionOutput(NetworkParameters params, Transaction parent, byte[] pa
     }
 
     /** Used only in creation of the genesis blocks and in unit tests. */
-    TransactionOutput(NetworkParameters params, byte[] scriptBytes) {
+    TransactionOutput(NetworkParameters params, Transaction parent, byte[] scriptBytes) {
         super(params);
         this.scriptBytes = scriptBytes;
         this.value = Utils.toNanoCoins(50, 0);
+        parentTransaction = parent;
         availableForSpending = true;
     }
 

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -743,7 +743,7 @@ synchronized void reorganize(List<StoredBlock> oldBlocks, List<StoredBlock> newB
             tx.disconnectInputs();
         // Reconnect the transactions in the common part of the chain.
         for (Transaction tx : commonChainTransactions.values()) {
-            TransactionInput badInput = tx.connectInputs(all, false);
+            TransactionInput badInput = tx.connectForReorganize(all);
             assert badInput == null : "Failed to connect " + tx.getHashAsString() + ", " + badInput.toString();
         }
         // Recalculate the unspent/spent buckets for the transactions the re-org did not affect.

File: src/com/google/bitcoin/examples/PingService.java
Patch:
@@ -69,13 +69,15 @@ public static void main(String[] args) throws Exception {
         // Fetch the first key in the wallet (should be the only key).
         ECKey key = wallet.keychain.get(0);
 
+        System.out.println(wallet);
+
         // Load the block chain, if there is one stored locally.
         System.out.println("Reading block store from disk");
         BlockStore blockStore = new BoundedOverheadBlockStore(params, new File(filePrefix + ".blockchain"));
 
         // Connect to the localhost node. One minute timeout since we won't try any other peers
         System.out.println("Connecting ...");
-        NetworkConnection conn = new NetworkConnection(InetAddress.getLocalHost(), params,
+        NetworkConnection conn = new NetworkConnection(InetAddress.getByName("plan99.net"), params,
                                                        blockStore.getChainHead().getHeight(), 60000);
         BlockChain chain = new BlockChain(params, wallet, blockStore);
         final Peer peer = new Peer(params, conn, chain);

File: tests/com/google/bitcoin/core/TestUtils.java
Patch:
@@ -22,7 +22,7 @@
 import java.math.BigInteger;
 
 public class TestUtils {
-    public static Transaction createFakeTx(NetworkParameters params, BigInteger nanocoins,  Address to) {
+    public static Transaction createFakeTx(NetworkParameters params, BigInteger nanocoins, Address to) {
         Transaction t = new Transaction(params);
         TransactionOutput o1 = new TransactionOutput(params, t, nanocoins, to);
         t.addOutput(o1);
@@ -46,6 +46,7 @@ public static BlockPair createFakeBlock(NetworkParameters params, BlockStore blo
                                             Transaction... transactions) {
         try {
             Block b = blockStore.getChainHead().getHeader().createNextBlock(new ECKey().toAddress(params));
+            // Coinbase tx was already added.
             for (Transaction tx : transactions)
                 b.addTransaction(tx);
             b.solve();

File: src/com/google/bitcoin/core/BitcoinSerializer.java
Patch:
@@ -121,7 +121,8 @@ public void serialize(Message message, OutputStream out) throws IOException {
         out.write(header);
         out.write(payload);
 
-        log.debug("Sending {} message: {}", name, bytesToHexString(header) + bytesToHexString(payload));
+        if (log.isDebugEnabled())
+            log.debug("Sending {} message: {}", name, bytesToHexString(header) + bytesToHexString(payload));
     }
 
     /**

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -197,7 +197,7 @@ private void processInv(InventoryMessage inv) throws IOException {
      * @throws IOException
      */
     public Future<Block> getBlock(Sha256Hash blockHash) throws IOException {
-        InventoryMessage getdata = new InventoryMessage(params);
+        GetDataMessage getdata = new GetDataMessage(params);
         InventoryItem inventoryItem = new InventoryItem(InventoryItem.Type.Block, blockHash);
         getdata.addItem(inventoryItem);
         GetDataFuture<Block> future = new GetDataFuture<Block>(inventoryItem);

File: tests/com/google/bitcoin/discovery/IrcDiscoveryTest.java
Patch:
@@ -42,8 +42,9 @@ public void testParseUserList() throws UnknownHostException {
         InetSocketAddress[] decoded = addresses.toArray(new InetSocketAddress[]{});
         
         for (int i = 0; i < decoded.length; i++) {
-            String formattedIP = decoded[0].getAddress().getHostAddress() + ":" + ((Integer)decoded[i].getPort()).toString();
-            assertEquals("IPs decoded improperly", ips[0], formattedIP);
+            String formattedIP = decoded[i].getAddress().getHostAddress() + ":" + ((Integer)decoded[i].getPort())
+                    .toString();
+            assertEquals("IPs decoded improperly", ips[i], formattedIP);
         }        
     }
 

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -311,7 +311,7 @@ private List<byte[]> buildMerkleTree() {
         //            /  \          /   \
         //          2     3       4      5
         //         / \   / \    /  \   /  \
-        //       t1 t2  t3 t4  t5 t5  t5 t5
+        //       t1 t2  t3 t4  t5 t5  t5  t5
         ArrayList<byte[]> tree = new ArrayList<byte[]>();
         // Start by adding all the hashes of the transactions as leaves of the tree.
         for (Transaction t : transactions) {

File: src/com/google/bitcoin/core/PeerAddress.java
Patch:
@@ -46,6 +46,7 @@ public PeerAddress(InetAddress addr, int port, int protocolVersion) {
         this.addr = addr;
         this.port = port;
         this.protocolVersion = protocolVersion;
+        this.services = BigInteger.ZERO;
     }
     
     public void bitcoinSerializeToStream(OutputStream stream) throws IOException {

File: src/com/google/bitcoin/core/PeerAddress.java
Patch:
@@ -53,7 +53,7 @@ public void bitcoinSerializeToStream(OutputStream stream) throws IOException {
             int secs = (int)(new Date().getTime() / 1000);
             uint32ToByteStreamLE(secs, stream);
         }
-        uint64ToByteStreamLE(BigInteger.ZERO, stream);  // nServices.
+        uint64ToByteStreamLE(services, stream);  // nServices.
         // Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
         byte[] ipBytes = addr.getAddress();
         if (ipBytes.length == 4) {
@@ -64,9 +64,9 @@ public void bitcoinSerializeToStream(OutputStream stream) throws IOException {
             ipBytes = v6addr;
         }
         stream.write(ipBytes);
-        // And write out the port.
+        // And write out the port. Unlike the rest of the protocol, address and port is in big endian byte order.
+        stream.write((byte) (0xFF & port >> 8));
         stream.write((byte) (0xFF & port));
-        stream.write((byte) (0xFF & (port >> 8)));
     }
 
     @Override

File: src/com/google/bitcoin/core/StoredBlock.java
Patch:
@@ -107,6 +107,7 @@ public StoredBlock getPrev(BlockStore store) throws BlockStoreException {
 
     @Override
     public String toString() {
-        return "Block at height " + getHeight() + ": " + getHeader().toString();
+        return String.format("Block %s at height %d: %s",
+                getHeader().getHashAsString(), getHeight(), getHeader().toString());
     }
 }

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -386,7 +386,7 @@ public synchronized void addEventListener(WalletEventListener listener) {
      * Call this when we have successfully transmitted the send tx to the network, to update the wallet.
      */
     synchronized void confirmSend(Transaction tx) {
-        assert !pending.containsKey(tx) : "confirmSend called on the same transaction twice";
+        assert !pending.containsKey(tx.getHash()) : "confirmSend called on the same transaction twice";
         log.info("confirmSend of {}", tx.getHashAsString());
         // Mark the outputs of the used transcations as spent, so we don't try and spend it again.
         for (TransactionInput input : tx.inputs) {

File: src/com/google/bitcoin/core/Address.java
Patch:
@@ -65,7 +65,7 @@ public byte[] getHash160() {
         return hash160;
     }
     
-
+    // TODO: Make this use Base58.decodeChecked
     private byte[] strToHash160(String address) throws AddressFormatException {
         byte[] bytes = Base58.decode(address);
         if (bytes.length != 25) {
@@ -75,10 +75,10 @@ private byte[] strToHash160(String address) throws AddressFormatException {
             bytes = tmp;
         }
         if (bytes[0] != params.addressHeader)
-            throw new AddressFormatException();
+            throw new AddressFormatException("Address header incorrect: from a different network?");
         byte[] check = Utils.doubleDigest(bytes, 0, 21);
         if (check[0] != bytes[21] || check[1] != bytes[22] || check[2] != bytes[23] || check[3] != bytes[24])
-            throw new AddressFormatException();
+            throw new AddressFormatException("Checksum failed: check the address for typos");
         byte[] hash160 = new byte[20];
         System.arraycopy(bytes, 1, hash160, 0, 20);
         return hash160;

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -456,7 +456,7 @@ void addCoinbaseTransaction(Address to) {
         // counter in the scriptSig so every transaction has a different hash. The output is also different.
         // Real coinbase transactions use <pubkey> OP_CHECKSIG rather than a send to an address though there's
         // nothing in the system that enforces that and both are just as valid.
-        coinbase.inputs.add(new TransactionInput(params, new byte[] { (byte) coinbaseCounter++ } ));
+        coinbase.inputs.add(new TransactionInput(params, coinbase, new byte[] { (byte) coinbaseCounter++ } ));
         coinbase.outputs.add(new TransactionOutput(params, coinbase, Utils.toNanoCoins(50, 0), to));
         transactions.add(coinbase);
     }

File: src/com/google/bitcoin/core/NetworkParameters.java
Patch:
@@ -76,7 +76,7 @@ private static Block createGenesis(NetworkParameters n) {
             //   "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"
             byte[] bytes = Hex.decode
                         ("04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73");
-            t.inputs.add(new TransactionInput(n, bytes));
+            t.inputs.add(new TransactionInput(n, t, bytes));
             ByteArrayOutputStream scriptPubKeyBytes = new ByteArrayOutputStream();
             Script.writeBytes(scriptPubKeyBytes, Hex.decode
                             ("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"));

File: src/com/google/bitcoin/core/Transaction.java
Patch:
@@ -219,7 +219,7 @@ void parse() throws ProtocolException {
         long numInputs = readVarInt();
         inputs = new ArrayList<TransactionInput>((int)numInputs);
         for (long i = 0; i < numInputs; i++) {
-            TransactionInput input = new TransactionInput(params, bytes, cursor);
+            TransactionInput input = new TransactionInput(params, this, bytes, cursor);
             inputs.add(input);
             cursor += input.getMessageSize();
         }
@@ -300,7 +300,7 @@ public String toString() {
      * accepted by the network.
      */
     public void addInput(TransactionOutput from) {
-        inputs.add(new TransactionInput(params, from));
+        inputs.add(new TransactionInput(params, this, from));
     }
 
     /**

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -457,7 +457,7 @@ void addCoinbaseTransaction(Address to) {
         // Real coinbase transactions use <pubkey> OP_CHECKSIG rather than a send to an address though there's
         // nothing in the system that enforces that and both are just as valid.
         coinbase.inputs.add(new TransactionInput(params, new byte[] { (byte) coinbaseCounter++ } ));
-        coinbase.outputs.add(new TransactionOutput(params, Utils.toNanoCoins(50, 0), to, coinbase));
+        coinbase.outputs.add(new TransactionOutput(params, coinbase, Utils.toNanoCoins(50, 0), to));
         transactions.add(coinbase);
     }
 

File: src/com/google/bitcoin/examples/PingService.java
Patch:
@@ -52,10 +52,10 @@ public static void main(String[] args) throws Exception {
         System.out.println("Reading block store from disk");
         BlockStore blockStore = new DiskBlockStore(params, new File(filePrefix + ".blockchain"));
 
-        // Connect to the localhost node.
+        // Connect to the localhost node. One minute timeout since we won't try any other peers
         System.out.println("Connecting ...");
         NetworkConnection conn = new NetworkConnection(InetAddress.getLocalHost(), params,
-                                                       blockStore.getChainHead().getHeight());
+                                                       blockStore.getChainHead().getHeight(), 60000);
         BlockChain chain = new BlockChain(params, wallet, blockStore);
         final Peer peer = new Peer(params, conn, chain);
         peer.start();

File: src/com/google/bitcoin/examples/PrivateKeys.java
Patch:
@@ -46,7 +46,7 @@ public static void main(String[] args) throws Exception {
             wallet.addKey(key);
 
             // Find the transactions that involve those coins.
-            NetworkConnection conn = new NetworkConnection(InetAddress.getLocalHost(), params, 0);
+            NetworkConnection conn = new NetworkConnection(InetAddress.getLocalHost(), params, 0, 60000);
             BlockChain chain = new BlockChain(params, wallet, new MemoryBlockStore(params));
             Peer peer = new Peer(params, conn, chain);
             peer.start();

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -294,7 +294,7 @@ private List<byte[]> buildMerkleTree() {
         ArrayList<byte[]> tree = new ArrayList<byte[]>();
         // Start by adding all the hashes of the transactions as leaves of the tree.
         for (Transaction t : transactions) {
-            tree.add(t.getHash());
+            tree.add(t.getHash().hash);
         }
         int j = 0;
         // Now step through each level ...
@@ -453,7 +453,7 @@ void addCoinbaseTransaction(Address to) {
         // Real coinbase transactions use <pubkey> OP_CHECKSIG rather than a send to an address though there's
         // nothing in the system that enforces that and both are just as valid.
         coinbase.inputs.add(new TransactionInput(params, new byte[] { (byte) coinbaseCounter++ } ));
-        coinbase.outputs.add(new TransactionOutput(params, Utils.toNanoCoins(50, 0), to));
+        coinbase.outputs.add(new TransactionOutput(params, Utils.toNanoCoins(50, 0), to, coinbase));
         transactions.add(coinbase);
     }
 

File: src/com/google/bitcoin/examples/PrivateKeys.java
Patch:
@@ -46,7 +46,7 @@ public static void main(String[] args) throws Exception {
             wallet.addKey(key);
 
             // Find the transactions that involve those coins.
-            NetworkConnection conn = new NetworkConnection(InetAddress.getLocalHost(), params);
+            NetworkConnection conn = new NetworkConnection(InetAddress.getLocalHost(), params, 0);
             BlockChain chain = new BlockChain(params, wallet, new MemoryBlockStore(params));
             Peer peer = new Peer(params, conn, chain);
             peer.start();

File: src/com/google/bitcoin/core/DiskBlockStore.java
Patch:
@@ -71,7 +71,7 @@ private void createNewStore(NetworkParameters params, File file) throws BlockSto
 
     private void load(File file) throws IOException, BlockStoreException {
         LOG("Reading block store from " + file.getAbsolutePath());
-        FileInputStream input = new FileInputStream(file);
+        InputStream input = new BufferedInputStream(new FileInputStream(file));
         // Read a version byte.
         int version = input.read();
         if (version == -1) {

File: src/com/google/bitcoin/core/NetworkConnection.java
Patch:
@@ -73,11 +73,13 @@ public NetworkConnection(InetAddress remoteIp, NetworkParameters params) throws
         out = socket.getOutputStream();
         in = socket.getInputStream();
 
+        // Announce ourselves. This has to come first to connect to clients beyond v0.30.20.2 which wait to hear
+        // from us until they send their version message back.
+        writeMessage(MSG_VERSION, new VersionMessage(params));
         // When connecting, the remote peer sends us a version message with various bits of
         // useful data in it. We need to know the peer protocol version before we can talk to it.
         versionMessage = (VersionMessage) readMessage();
         // Now it's our turn ...
-        writeMessage(MSG_VERSION, new VersionMessage(params));
         // Send an ACK message stating we accept the peers protocol version.
         writeMessage(MSG_VERACK, new byte[] {});
         // And get one back ...

File: src/com/google/bitcoin/core/AddressMessage.java
Patch:
@@ -24,7 +24,7 @@ void parse() throws ProtocolException {
             throw new ProtocolException("Address message too large.");
         addresses = new ArrayList<PeerAddress>((int)numAddresses);
         for (int i = 0; i < numAddresses; i++) {
-            PeerAddress addr = new PeerAddress(params, bytes, cursor);
+            PeerAddress addr = new PeerAddress(params, bytes, cursor, protocolVersion);
             addresses.add(addr);
             cursor += addr.getMessageSize();
         }

File: src/com/google/bitcoin/core/GetBlocksMessage.java
Patch:
@@ -48,7 +48,7 @@ public byte[] bitcoinSerialize() {
         try {
             ByteArrayOutputStream buf = new ByteArrayOutputStream();
             // Version, for some reason.
-            Utils.uint32ToByteStreamLE(VersionMessage.PROTOCOL_VERSION, buf);
+            Utils.uint32ToByteStreamLE(NetworkParameters.PROTOCOL_VERSION, buf);
             // Then a vector of block hashes. This is actually a "block locator", a set of block
             // identifiers that spans the entire chain with exponentially increasing gaps between
             // them, until we end up at the genesis block. See CBlockLocator::Set()

File: src/com/google/bitcoin/core/Address.java
Patch:
@@ -54,7 +54,7 @@ public Address(NetworkParameters params,  byte[] hash160) {
      *
      * <pre>new Address(NetworkParameters.prodNet(), "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL");</pre>
      */
-    public Address(NetworkParameters params,  String address) throws AddressFormatException {
+    public Address(NetworkParameters params, String address) throws AddressFormatException {
         this.params = params;
         this.hash160 = strToHash160(address);
     }

File: src/com/google/bitcoin/core/AddressMessage.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.List;
 
 public class AddressMessage extends Message {
+    private static final long serialVersionUID = 8058283864924679460L;
     private static final long MAX_ADDRESSES = 1024;
     List<PeerAddress> addresses;
 

File: src/com/google/bitcoin/core/Block.java
Patch:
@@ -33,8 +33,9 @@
  * you grab it from a downloaded {@link BlockChain}.
  */
 public class Block extends Message {
-    static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60;  // Same value as official client.
+    private static final long serialVersionUID = -2834162413473103042L;
 
+    static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60;  // Same value as official client.
     /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */
     static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL;
 

File: src/com/google/bitcoin/core/GetBlocksMessage.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.List;
 
 public class GetBlocksMessage extends Message {
+    private static final long serialVersionUID = 3479412877853645644L;
     private final List<byte[]> locator;
     private final byte[] stopHash;
 

File: src/com/google/bitcoin/core/GetDataMessage.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.bitcoin.core;
 
 public class GetDataMessage extends Message {
+    private static final long serialVersionUID = 2754681589501709887L;
+
     public GetDataMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
         super(params, payloadBytes, 0);
     }

File: src/com/google/bitcoin/core/InventoryMessage.java
Patch:
@@ -24,8 +24,9 @@
 import java.util.List;
 
 public class InventoryMessage extends Message {
+    private static final long serialVersionUID = -7050246551646107066L;
     private static final long MAX_INVENTORY_ITEMS = 50000;
-    
+
     // For some reason the compiler complains if this is inside InventoryItem
     public List<InventoryItem> items;
 

File: src/com/google/bitcoin/core/Message.java
Patch:
@@ -31,6 +31,8 @@
  * This class is not useful for library users. If you want to talk to the network see the {@link Peer} class.
  */
 public abstract class Message implements Serializable {
+    private static final long serialVersionUID = -3561053461717079135L;
+
     public static final int MAX_SIZE = 0x02000000;
 
     // Useful to ensure serialize/deserialize are consistent with each other.

File: src/com/google/bitcoin/core/UnknownMessage.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.bitcoin.core;
 
 public class UnknownMessage extends Message {
+    private static final long serialVersionUID = 3614705938207918775L;
     private String name;
 
     public UnknownMessage(NetworkParameters params, String name, byte[] payloadBytes) throws ProtocolException {

File: src/com/google/bitcoin/core/VersionMessage.java
Patch:
@@ -23,6 +23,8 @@
 import java.net.UnknownHostException;
 
 public class VersionMessage extends Message {
+    private static final long serialVersionUID = 7313594258967483180L;
+
     /**
      * The protocol version this library implements. A value of 31800 means 0.3.18.00.
      */

File: src/com/google/bitcoin/core/Wallet.java
Patch:
@@ -264,7 +264,6 @@ public synchronized Transaction sendCoins(Peer peer, Address to, BigInteger nano
      * our coins. This should be an address we own (is in the keychain).
      * @return a new {@link Transaction} or null if we cannot afford this send.
      */
-
     synchronized Transaction createSend(Address address,  BigInteger nanocoins, Address changeAddress) {
         Utils.LOG("Creating send tx to " + address.toString() + " for " +
                 Utils.bitcoinValueToFriendlyString(nanocoins));

File: src/com/google/bitcoin/core/TransactionOutPoint.java
Patch:
@@ -26,6 +26,8 @@
  * This message is a reference or pointer to an output of a different transaction.
  */
 public class TransactionOutPoint extends Message implements Serializable {
+    private static final long serialVersionUID = -6320880638344662579L;
+
     /** Hash of the transaction to which we refer. */
     byte[] hash;
     /** Which output of that transaction we are talking about. */

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -98,7 +98,6 @@ private void run() {
                 LOG("Shutting down peer thread");
             } else {
                 // We caught an unexpected exception.
-                System.err.println(e.toString());
                 e.printStackTrace();
             }
         }

File: src/com/google/bitcoin/core/ECKey.java
Patch:
@@ -34,7 +34,7 @@
 import java.security.SecureRandom;
 
 /**
- * Represents either an elliptic curve keypair that we own and can use for signing transactions. Currently,
+ * Represents an elliptic curve keypair that we own and can use for signing transactions. Currently,
  * Bouncy Castle is used. In future this may become an interface with multiple implementations using different crypto
  * libraries. The class also provides a static method that can verify a signature with just the public key.<p>
  */

File: src/com/google/bitcoin/core/Peer.java
Patch:
@@ -279,7 +279,7 @@ void setResult(T result) {
      * a {@link Wallet}. After the broadcast completes, confirm the send using the wallet confirmSend() method.
      * @throws IOException
      */
-    public void broadcastTransaction(Transaction tx) throws IOException {
+    void broadcastTransaction(Transaction tx) throws IOException {
         conn.writeMessage(NetworkConnection.MSG_TX, tx);
     }
 

