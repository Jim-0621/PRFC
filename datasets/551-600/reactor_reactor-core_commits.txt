File: benchmarks/src/main/java/reactor/core/publisher/MonoAllBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -49,8 +49,8 @@ public static void main(String[] args) throws Exception {
 
 	@SuppressWarnings("unused")
 	@Benchmark
-	public void measureThroughput() {
-		Flux.range(0, rangeSize)
+	public Boolean measureThroughput() {
+		return Flux.range(0, rangeSize)
 			.all(i -> i < Integer.MAX_VALUE)
 			.block();
 	}

File: benchmarks/src/main/java/reactor/core/publisher/MonoCallableBenchmark.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -49,8 +49,8 @@ public static void main(String[] args) throws Exception {
 
 	@SuppressWarnings("unused")
 	@Benchmark
-	public void measureThroughput() {
-		Flux.range(0, rangeSize)
+	public Boolean measureThroughput() {
+		return Flux.range(0, rangeSize)
 			.all(i -> i < Integer.MAX_VALUE)
 			.block();
 	}

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -449,7 +449,7 @@ default String name() {
 				.map(s -> s.scan(Attr.NAME))
 				.filter(Objects::nonNull)
 				.findFirst()
-				.orElse(stepName());
+				.orElseGet(this::stepName);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2018-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -716,7 +716,7 @@ public final void subscribe(CoreSubscriber<? super T> inboundSubscriber) {
 				return;
 			}
 
-			if (hasInboundClosedPrematurely(previousState)) {
+			if (hasInboundCancelled(previousState) ||hasInboundClosedPrematurely(previousState)) {
 				Operators.error(inboundSubscriber, new CancellationException("FluxSwitchOnFirst has already been cancelled"));
 				return;
 			}

File: reactor-core/src/main/java/reactor/util/retry/Retry.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -165,7 +165,7 @@ default RetrySignal copy() {
 	 * @see RetryBackoffSpec#minBackoff(Duration)
 	 */
 	public static RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {
-		return new RetryBackoffSpec(Context.empty(), maxAttempts, t -> true, false, minBackoff, MAX_BACKOFF, 0.5d, Schedulers::parallel,
+		return new RetryBackoffSpec(Context.empty(), maxAttempts, t -> true, false, minBackoff, MAX_BACKOFF, 2, 0.5d, Schedulers::parallel,
 				NO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,
 				RetryBackoffSpec.BACKOFF_EXCEPTION_GENERATOR);
 	}
@@ -187,7 +187,7 @@ public static RetryBackoffSpec backoff(long maxAttempts, Duration minBackoff) {
 	 * @see RetryBackoffSpec#maxBackoff(Duration)
 	 */
 	public static RetryBackoffSpec fixedDelay(long maxAttempts, Duration fixedDelay) {
-		return new RetryBackoffSpec(Context.empty(), maxAttempts, t -> true, false, fixedDelay, fixedDelay, 0d, Schedulers::parallel,
+		return new RetryBackoffSpec(Context.empty(), maxAttempts, t -> true, false, fixedDelay, fixedDelay, 2, 0d, Schedulers::parallel,
 				NO_OP_CONSUMER, NO_OP_CONSUMER, NO_OP_BIFUNCTION, NO_OP_BIFUNCTION,
 				RetryBackoffSpec.BACKOFF_EXCEPTION_GENERATOR);
 	}

File: reactor-core/src/test/java/reactor/util/retry/RetryBackoffSpecTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,6 +46,7 @@ public void builderMethodsProduceNewInstances() {
 		assertThat(init)
 				.isNotSameAs(init.minBackoff(Duration.ofSeconds(1)))
 				.isNotSameAs(init.maxBackoff(Duration.ZERO))
+				.isNotSameAs(init.multiplier(2))
 				.isNotSameAs(init.jitter(0.5d))
 				.isNotSameAs(init.scheduler(Schedulers.parallel()))
 				.isNotSameAs(init.maxAttempts(10))

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2035,7 +2035,7 @@ public static Flux<Integer> range(int start, int count) {
 	 * @param mergedPublishers The {@link Publisher} of {@link Publisher} to switch on and mirror.
 	 * @param <T> the produced type
 	 *
-	 * @return a {@link SinkManyAbstractBase} accepting publishers and producing T
+	 * @return a {@link Flux} accepting publishers and producing T
 	 */
 	public static <T> Flux<T> switchOnNext(Publisher<? extends Publisher<? extends T>> mergedPublishers) {
 		return onAssembly(new FluxSwitchMapNoPrefetch<>(from(mergedPublishers),
@@ -2056,7 +2056,7 @@ public static <T> Flux<T> switchOnNext(Publisher<? extends Publisher<? extends T
 	 * @param prefetch the inner source request size
 	 * @param <T> the produced type
 	 *
-	 * @return a {@link SinkManyAbstractBase} accepting publishers and producing T
+	 * @return a {@link Flux} accepting publishers and producing T
 	 *
 	 * @deprecated to be removed in 3.6.0 at the earliest. In 3.5.0, you should replace
 	 * calls with prefetch=0 with calls to switchOnNext(mergedPublishers), as the default

File: reactor-core/src/main/java21/reactor/core/scheduler/BoundedElasticThreadPerTaskScheduler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2023-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -882,7 +882,7 @@ static long retain(SequentialThreadPerTaskExecutor instance) {
 
 		static long incrementRefCnt(long state) {
 			long rawRefCnt = state & REF_CNT_MASK;
-			return (rawRefCnt) == REF_CNT_MASK ? state : (rawRefCnt >> 31 + 1) << 31 | (state &~ REF_CNT_MASK);
+			return (rawRefCnt) == REF_CNT_MASK ? state : ((rawRefCnt >> 31) + 1) << 31 | (state &~ REF_CNT_MASK);
 		}
 
 		static long release(SequentialThreadPerTaskExecutor instance) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1376,6 +1376,7 @@ public void onComplete() {
 
 		@Override
 		public void dispose() {
+			CONNECTION.compareAndSet(parent, this, null);
 			final long previousState = markDisposed(this);
 			if (isDisposed(previousState)) {
 				return;
@@ -1385,8 +1386,6 @@ public void dispose() {
 				s.cancel();
 			}
 
-			CONNECTION.lazySet(parent, null);
-
 			final CancellationException ex = new CancellationException("Disconnected");
 			final ReplayBuffer<T> buffer = this.buffer;
 			buffer.onError(ex);

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -68,8 +68,8 @@ public String stepName() {
 
 	@Override
 	public final CoreSubscriber<? super I> subscribeOrReturn(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input =
-				liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -70,8 +70,8 @@ public String stepName() {
 
 	@Override
 	public final CoreSubscriber<? super I> subscribeOrReturn(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input =
-				liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -50,7 +50,7 @@ final class FluxAutoConnect<T> extends Flux<T>
 		if (n <= 0) {
 			throw new IllegalArgumentException("n > required but it was " + n);
 		}
-		this.source = Objects.requireNonNull(source, "source");
+		this.source = ConnectableFlux.from(Objects.requireNonNull(source, "source"));
 		this.cancelSupport = Objects.requireNonNull(cancelSupport, "cancelSupport");
 		REMAINING.lazySet(this, n);
 	}
@@ -75,6 +75,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.CAPACITY) return remaining;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -51,7 +51,7 @@ final class FluxAutoConnectFuseable<T> extends Flux<T>
 		if (n <= 0) {
 			throw new IllegalArgumentException("n > required but it was " + n);
 		}
-		this.source = Objects.requireNonNull(source, "source");
+		this.source = ConnectableFlux.from(Objects.requireNonNull(source, "source"));
 		this.cancelSupport = Objects.requireNonNull(cancelSupport, "cancelSupport");
 		REMAINING.lazySet(this, n);
 	}
@@ -76,6 +76,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.CAPACITY) return remaining;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxLift.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -52,8 +52,8 @@ public Object scanUnsafe(Attr key) {
 
 	@Override
 	public CoreSubscriber<? super I> subscribeOrReturn(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input =
-				liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -75,7 +75,7 @@ final class FluxPublish<T> extends ConnectableFlux<T> implements Scannable {
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("bufferSize > 0 required but it was " + prefetch);
 		}
-		this.source = Objects.requireNonNull(source, "source");
+		this.source = Flux.from(Objects.requireNonNull(source, "source"));
 		this.prefetch = prefetch;
 		this.queueSupplier = Objects.requireNonNull(queueSupplier, "queueSupplier");
 		this.resetUponSourceTermination = resetUponSourceTermination;

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1072,7 +1072,7 @@ public int size() {
 			int history,
 			long ttl,
 			@Nullable Scheduler scheduler) {
-		this.source = Objects.requireNonNull(source, "source");
+		this.source = Operators.toFluxOrMono(Objects.requireNonNull(source, "source"));
 		if (source instanceof OptimizableOperator) {
 			@SuppressWarnings("unchecked")
 			OptimizableOperator<?, T> optimSource = (OptimizableOperator<?, T>) source;

File: reactor-core/src/main/java/reactor/core/publisher/GroupedLift.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,8 +79,8 @@ public String stepName() {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input =
-				liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/GroupedLiftFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -81,8 +81,8 @@ public String stepName() {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input =
-				liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoLift.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,8 +37,8 @@ final class MonoLift<I, O> extends InternalMonoOperator<I, O> {
 
 	@Override
 	public CoreSubscriber<? super I> subscribeOrReturn(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input =
-				liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoLiftFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -55,7 +55,8 @@ public Object scanUnsafe(Attr key) {
 
 	@Override
 	public CoreSubscriber<? super I> subscribeOrReturn(CoreSubscriber<? super O> actual) {
-		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual));
+		// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+		CoreSubscriber<? super I> input = liftFunction.lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -84,8 +84,8 @@ public void subscribe(CoreSubscriber<? super O>[] s) {
 		int i = 0;
 		while (i < subscribers.length) {
 			subscribers[i] =
-					Objects.requireNonNull(liftFunction.lifter.apply(source,
-									Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, s[i])),
+					// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+					Objects.requireNonNull(liftFunction.lifter.apply(source, s[i]),
 							"Lifted subscriber MUST NOT be null");
 			i++;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -88,8 +88,8 @@ public void subscribe(CoreSubscriber<? super O>[] s) {
 		while (i < subscribers.length) {
 			CoreSubscriber<? super O> actual = s[i];
 			CoreSubscriber<? super I> converted =
-					Objects.requireNonNull(liftFunction.lifter.apply(source, Operators.restoreContextOnSubscriberIfAutoCPEnabled(source, actual)),
-							"Lifted subscriber MUST NOT be null");
+					// No need to wrap actual for CP, the Operators$LiftFunction handles it.
+					Objects.requireNonNull(liftFunction.lifter.apply(source, actual), "Lifted subscriber MUST NOT be null");
 
 			Objects.requireNonNull(converted, "Lifted subscriber MUST NOT be null");
 

File: reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -103,6 +103,7 @@ public void subscribe(Subscriber<? super T> s) {
 		}
 
 		s.onSubscribe(p); // will trigger drain() via request()
+		p.drain(); // ensures that empty source terminal signal is propagated without waiting for a request from the subscriber
 	}
 
 	boolean add(ColdTestPublisherSubscription<T> s) {
@@ -315,7 +316,7 @@ private void drain() {
 		 * @return true if the TestPublisher was terminated, false otherwise
 		 */
 		private boolean emitTerminalSignalIfAny() {
-			if (parent.done) {
+			if (parent.done && this.parent.values.size() == index) {
 				parent.remove(this);
 
 				final Throwable t = parent.error;

File: reactor-core/src/jcstress/java/reactor/core/publisher/FluxSwitchMapStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021-2024 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -270,7 +270,8 @@ public void arbiter(II_Result r) {
 		}
 	}
 
-	@JCStressTest
+	// Ignore, flaky test (https://github.com/reactor/reactor-core/issues/3633)
+	//@JCStressTest
 	@Outcome(id = {"200, 0", "200, 1"}, expect = ACCEPTABLE, desc = "Should produced exactly what was requested")
 	@State
 	public static class RequestAndProduceStressTest2 extends FluxSwitchMapStressTest {

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -360,7 +360,8 @@ void open(OPEN token) {
 
 			BufferWhenCloseSubscriber<T, BUFFER> bc = new BufferWhenCloseSubscriber<>(this, idx);
 			subscribers.add(bc);
-			Operators.toFluxOrMono(p).subscribe(bc);
+			p = Operators.toFluxOrMono(p);
+			p.subscribe(bc);
 		}
 
 		void openComplete(BufferWhenOpenSubscriber<OPEN> os) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatIterable.java
Patch:
@@ -144,7 +144,8 @@ public void onComplete() {
 						produced(c);
 					}
 
-					Operators.toFluxOrMono(p).subscribe(this);
+					p = Operators.toFluxOrMono(p);
+					p.subscribe(this);
 
 					if (isCancelled()) {
 						return;

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java
Patch:
@@ -203,7 +203,8 @@ public void onNext(T t) {
 					return;
 				}
 
-				Operators.toFluxOrMono(p).subscribe(inner);
+				p = Operators.toFluxOrMono(p);
+				p.subscribe(inner);
 			}
 			catch (Throwable e) {
 				Context ctx = actual.currentContext();

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -279,7 +279,8 @@ void drain() {
 								FilterWhenInner inner = new FilterWhenInner(this, !(p instanceof Mono));
 								if (CURRENT.compareAndSet(this,null, inner)) {
 									state = STATE_RUNNING;
-									Operators.toFluxOrMono(p).subscribe(inner);
+									p = Operators.toFluxOrMono(p);
+									p.subscribe(inner);
 									break;
 								}
 							}

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstWithSignal.java
Patch:
@@ -127,7 +127,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 						new NullPointerException("The single source Publisher is null"));
 			}
 			else {
-				Operators.toFluxOrMono(p).subscribe(actual);
+				p = Operators.toFluxOrMono(p);
+				p.subscribe(actual);
 			}
 			return;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstWithValue.java
Patch:
@@ -227,6 +227,8 @@ void subscribe(Publisher<? extends T>[] sources,
 
 			actual.onSubscribe(this);
 
+			Operators.toFluxOrMono(sources);
+
 			for (int i = 0; i < n; i++) {
 				if (cancelled || winner != Integer.MIN_VALUE) {
 					return;
@@ -237,7 +239,7 @@ void subscribe(Publisher<? extends T>[] sources,
 					return;
 				}
 
-				Operators.toFluxOrMono(sources[i]).subscribe(subscribers[i]);
+				sources[i].subscribe(subscribers[i]);
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -76,7 +76,8 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 			return null;
 		}
 
-		Operators.toFluxOrMono(p).subscribe(other);
+		p = Operators.toFluxOrMono(p);
+		p.subscribe(other);
 
 		if (!main.cancelled) {
 			return main;

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -74,7 +74,8 @@ static <T> void subscribe(CoreSubscriber<? super T> s,
 			return;
 		}
 
-		Operators.toFluxOrMono(p).subscribe(other);
+		p = Operators.toFluxOrMono(p);
+		p.subscribe(other);
 
 		if (!main.cancelled) {
 			wrapped.subscribe(main);

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -191,7 +191,8 @@ public void onNext(T t) {
 				SampleFirstOther<U> other = new SampleFirstOther<>(this);
 
 				if (Operators.replace(OTHER, this, other)) {
-					Operators.toFluxOrMono(p).subscribe(other);
+					p = Operators.toFluxOrMono(p);
+					p.subscribe(other);
 				}
 			}
 			else {

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -207,7 +207,8 @@ public void onNext(T t) {
 			SampleTimeoutOther<T, U> os = new SampleTimeoutOther<>(this, t, idx);
 
 			if (Operators.replace(OTHER, this, os)) {
-				Operators.toFluxOrMono(p).subscribe(os);
+				p = Operators.toFluxOrMono(p);
+				p.subscribe(os);
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -233,7 +233,8 @@ public void onNext(T t) {
 
 			if (INNER.compareAndSet(this, si, innerSubscriber)) {
 				ACTIVE.getAndIncrement(this);
-				Operators.toFluxOrMono(p).subscribe(innerSubscriber);
+				p = Operators.toFluxOrMono(p);
+				p.subscribe(innerSubscriber);
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMapNoPrefetch.java
Patch:
@@ -215,7 +215,8 @@ void subscribeInner(T nextElement, SwitchMapInner<T, R> nextInner, int nextIndex
 				return;
 			}
 
-			Operators.toFluxOrMono(p).subscribe(nextInner);
+			p = Operators.toFluxOrMono(p);
+			p.subscribe(nextInner);
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -287,7 +287,7 @@ void subscribeNextTrigger() {
 			final Function<? super T, ? extends Publisher<?>> generator =
 					this.otherGenerators[this.index];
 
-			final Publisher<?> p;
+			Publisher<?> p;
 
 			try {
 				p = generator.apply(this.value);
@@ -304,7 +304,8 @@ void subscribeNextTrigger() {
 				this.triggerSubscriber = triggerSubscriber;
 			}
 
-			Operators.toFluxOrMono(p).subscribe(triggerSubscriber);
+			p = Operators.toFluxOrMono(p);
+			p.subscribe(triggerSubscriber);
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -143,7 +143,8 @@ public void onNext(T t) {
 			}
 			else {
 				FilterWhenInner<T> inner = new FilterWhenInner<>(this, !(p instanceof Mono), t);
-				Operators.toFluxOrMono(p).subscribe(inner);
+				p = Operators.toFluxOrMono(p);
+				p.subscribe(inner);
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirstWithSignal.java
Patch:
@@ -136,7 +136,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 								actual.currentContext()));
 			}
 			else {
-				Operators.toFluxOrMono(p).subscribe(actual);
+				p = Operators.toFluxOrMono(p);
+				p.subscribe(actual);
 			}
 			return;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -192,7 +192,8 @@ public void onNext(T t) {
 				return;
 			}
 
-			Operators.toFluxOrMono(p).subscribe(new FlatMapManyInner<>(this, actual));
+			p = Operators.toFluxOrMono(p);
+			p.subscribe(new FlatMapManyInner<>(this, actual));
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -4521,7 +4521,7 @@ public final void subscribe(Subscriber<? super T> actual) {
 	 * <img class="marble" src="doc-files/marbles/subscribeOnForMono.svg" alt="">
 	 *
 	 * <blockquote><pre>
-	 * {@code mono.subscribeOn(Schedulers.parallel()).subscribe()) }
+	 * {@code mono.subscribeOn(Schedulers.parallel()).subscribe() }
 	 * </pre></blockquote>
 	 *
 	 * @param scheduler a {@link Scheduler} providing the {@link Worker} where to subscribe
@@ -5324,7 +5324,7 @@ static <T> Mono<T> doOnTerminalSignal(Mono<T> source,
 	 * Note that this bypasses {@link Hooks#onEachOperator(String, Function) assembly hooks}.
 	 *
 	 * @param source the {@link Publisher} to wrap
-	 * @param enforceMonoContract {@code} true to wrap publishers without assumption about their cardinality
+	 * @param enforceMonoContract {@code true} to wrap publishers without assumption about their cardinality
 	 * (first {@link Subscriber#onNext(Object)} will cancel the source), {@code false} to behave like {@link #fromDirect(Publisher)}.
 	 * @param <T> input upstream type
 	 * @return a wrapped {@link Mono}

File: reactor-core/src/main/java/reactor/core/publisher/SinkManyUnicast.java
Patch:
@@ -414,7 +414,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		if (once == 0 && ONCE.compareAndSet(this, 0, 1)) {
 
 			this.hasDownstream = true;
-			this.actual = actual;
+			this.actual = wrapped;
 			wrapped.onSubscribe(this);
 			subscriptionDelivered = true;
 			if (cancelled) {

File: reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -71,7 +71,7 @@ enum Operation {
 
 	public final AtomicInteger onNextDiscarded = new AtomicInteger();
 
-	public final List<T> discardedValues = new CopyOnWriteArrayList<>();
+	public final List<Object> discardedValues = new CopyOnWriteArrayList<>();
 
 	public final AtomicInteger onErrorCalls = new AtomicInteger();
 
@@ -101,7 +101,7 @@ public StressSubscriber(long initRequest) {
 				}),
 				(value) -> {
 					onNextDiscarded.incrementAndGet();
-					discardedValues.add((T) value);
+					discardedValues.add(value);
 				});
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -316,11 +316,13 @@ public void onError(Throwable t) {
 				return;
 			}
 
-			done = true;
 			if (!Exceptions.addThrowable(ERROR, this, t)) {
 				Operators.onErrorDroppedMulticast(t, subscribers);
+				return;
 			}
 
+			done = true;
+
 			long previousState = markTerminated(this);
 			if (isTerminated(previousState) || isCancelled(previousState)) {
 				return;

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxHide.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -47,7 +47,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
-		return null;
+		return super.scanUnsafe(key);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,7 +72,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
-		return null;
+		return super.scanUnsafe(key);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -54,7 +54,8 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
 		if (key == Attr.LIFTER) return liftFunction.name;
-		return null;
+
+		return super.scanUnsafe(key);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,7 +56,8 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
 		if (key == Attr.LIFTER) return liftFunction.name;
-		return null;
+
+		return super.scanUnsafe(key);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,8 +64,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return array.length;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class ArraySubscription<T>

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -431,7 +431,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ERROR) return errors;
 			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
-			return null;
+			return InnerOperator.super.scanUnsafe(key);
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -49,6 +49,6 @@ public T call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatIterable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,7 +64,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class ConcatIterableSubscriber<T>
@@ -144,7 +144,7 @@ public void onComplete() {
 						produced(c);
 					}
 
-					p.subscribe(this);
+					Operators.toFluxOrMono(p).subscribe(this);
 
 					if (isCancelled()) {
 						return;

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -58,6 +58,6 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxDeferContextual.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -54,13 +54,13 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			return;
 		}
 
-		from(p).subscribe(actual);
+		Operators.toFluxOrMono(p).subscribe(actual);
 	}
 
 
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -45,7 +45,7 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -54,6 +54,6 @@ public Object call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorOnRequest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,7 +46,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class ErrorSubscription implements InnerProducer {

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorSupplied.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -57,6 +57,6 @@ public Object call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -30,6 +30,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
@@ -196,6 +197,7 @@ static <T, R> boolean trySubscribeScalarMap(Publisher<? extends T> source,
 				}
 			}
 			else {
+				p = Operators.toFluxOrMono(p);
 				if (!fuseableExpected || p instanceof Fuseable) {
 					p.subscribe(s);
 				}
@@ -424,6 +426,7 @@ else if (!delayError || !Exceptions.addThrowable(ERROR, this, e_)) {
 			else {
 				FlatMapInner<R> inner = new FlatMapInner<>(this, prefetch);
 				if (add(inner)) {
+					p = Operators.toFluxOrMono(p);
 					p.subscribe(inner);
 				} else {
 					Operators.onDiscard(t, actual.currentContext());

File: reactor-core/src/main/java/reactor/core/publisher/FluxFromMonoOperator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -63,6 +63,7 @@ protected FluxFromMonoOperator(Mono<? extends I> source) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return null;
 	}
 
@@ -80,6 +81,7 @@ public final void subscribe(CoreSubscriber<? super O> subscriber) {
 				}
 				OptimizableOperator newSource = operator.nextOptimizableSource();
 				if (newSource == null) {
+					subscriber = Operators.restoreContextOnSubscriberIfPublisherNonInternal(operator.source(), subscriber);
 					operator.source().subscribe(subscriber);
 					return;
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -80,8 +80,7 @@ public void subscribe(CoreSubscriber<? super Long> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timedScheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
-
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class IntervalRunnable implements Runnable, Subscription,

File: reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -92,7 +92,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) {
 		    return Attr.RunStyle.SYNC;
 		}
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,7 +72,7 @@ public void subscribe(final CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return 1;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,7 +43,7 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -159,6 +159,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,7 +72,7 @@ public void subscribe(CoreSubscriber<? super Integer> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class RangeSubscription implements InnerProducer<Integer>,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -225,6 +225,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return main.otherArbiter;
 			if (key == Attr.ACTUAL) return main;
 			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+			if (key == InternalProducerAttr.INSTANCE) return true;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1214,6 +1214,7 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_ON) return scheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -81,6 +81,6 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.PREFETCH) return getPrefetch();
 		if (key == Scannable.Attr.PARENT) return source;
 		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,6 +72,6 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -67,6 +67,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -73,6 +73,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxTapRestoringThreadLocals.java
Patch:
@@ -88,7 +88,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return super.scanUnsafe(key);
 	}
 
@@ -130,7 +130,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.TERMINATED) return done;
 			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-
+			if (key == InternalProducerAttr.INSTANCE) return true;
 			return InnerOperator.super.scanUnsafe(key);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -119,7 +119,7 @@ else if (actual instanceof ConditionalSubscriber) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class UsingSubscriber<T, S>

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -76,7 +76,7 @@ final class FluxWindowPredicate<T> extends InternalFluxOperator<T, Flux<T>>
 			int prefetch,
 			Predicate<? super T> predicate,
 			Mode mode) {
-		super(source);
+		super(Flux.from(source));
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeout.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -55,7 +55,7 @@ final class FluxWindowTimeout<T> extends InternalFluxOperator<T, Flux<T>> {
 			TimeUnit unit,
 			Scheduler timer,
 			boolean fairBackpressure) {
-		super(source);
+		super(Flux.from(source));
 		if (timespan <= 0) {
 			throw new IllegalArgumentException("Timeout period must be strictly positive");
 		}

File: reactor-core/src/main/java/reactor/core/publisher/InnerProducer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,6 +43,7 @@ default Object scanUnsafe(Attr key){
 		if (key == Attr.ACTUAL) {
 			return actual();
 		}
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return null;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/InternalConnectableFluxOperator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -90,6 +90,7 @@ public final CorePublisher<? extends I> source() {
 	public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.PREFETCH) return getPrefetch();
 		if (key == Scannable.Attr.PARENT) return source;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -75,7 +75,7 @@ public T call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static class MonoCallableSubscription<T>

File: reactor-core/src/main/java/reactor/core/publisher/MonoContextWriteRestoringThreadLocals.java
Patch:
@@ -48,6 +48,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return super.scanUnsafe(key);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCurrentContext.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,6 +39,7 @@ public void subscribe(CoreSubscriber<? super Context> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -50,12 +50,12 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			return;
 		}
 
-		p.subscribe(actual);
+		fromDirect(p).subscribe(actual);
 	}
 
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDeferContextual.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -52,12 +52,12 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			return;
 		}
 
-		p.subscribe(actual);
+		Operators.toFluxOrMono(p).subscribe(actual);
 	}
 
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null; //no particular key to be represented, still useful in hooks
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -71,8 +71,7 @@ public void subscribe(CoreSubscriber<? super Long> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timedScheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
-
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static final class MonoDelayRunnable implements Runnable, InnerProducer<Long> {

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -78,6 +78,6 @@ public Object block() {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,6 +64,6 @@ public Object call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -68,6 +68,6 @@ public T call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirstWithValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -147,7 +147,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			return;
 		}
 		if (n == 1) {
-			Publisher<? extends T> p = a[0];
+			Publisher<? extends T> p = Mono.from(a[0]);
 
 			if (p == null) {
 				Operators.error(actual,
@@ -169,6 +169,6 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromFluxOperator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -62,6 +62,7 @@ protected MonoFromFluxOperator(Flux<? extends I> source) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
 		if (key == Attr.PARENT) return source;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 		return null;
 	}
 
@@ -78,6 +79,7 @@ public final void subscribe(CoreSubscriber<? super O> subscriber) {
 				}
 				OptimizableOperator newSource = operator.nextOptimizableSource();
 				if (newSource == null) {
+					subscriber = Operators.restoreContextOnSubscriberIfPublisherNonInternal(operator.source(), subscriber);
 					operator.source().subscribe(subscriber);
 					return;
 				}

File: reactor-core/src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -59,6 +59,6 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return 1;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,7 +43,7 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/MonoRetryWhen.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,7 +37,7 @@ final class MonoRetryWhen<T> extends InternalMonoOperator<T, T> {
 	final Retry whenSourceFactory;
 
 	MonoRetryWhen(Mono<? extends T> source, Retry whenSourceFactory) {
-		super(source);
+		super(Mono.fromDirect(source));
 		this.whenSourceFactory = Objects.requireNonNull(whenSourceFactory, "whenSourceFactory");
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -77,7 +77,7 @@ public Void call() throws Exception {
     @Override
     public Object scanUnsafe(Attr key) {
         if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-        return null;
+        return SourceProducer.super.scanUnsafe(key);
     }
 
     static final class MonoRunnableEagerSubscription extends AtomicBoolean implements Subscription {

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingleCallable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -122,6 +122,6 @@ else if (v == null) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingleOptionalCallable.java
Patch:
@@ -93,6 +93,6 @@ public Optional<T> call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -62,6 +62,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.RUN_ON) return scheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -67,6 +67,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -70,7 +70,7 @@ public T call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
-		return null;
+		return SourceProducer.super.scanUnsafe(key);
 	}
 
 	static class MonoSupplierSubscription<T>

File: reactor-core/src/main/java/reactor/core/publisher/MonoTapRestoringThreadLocals.java
Patch:
@@ -83,6 +83,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return -1;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelArraySource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -48,7 +48,6 @@ public void subscribe(CoreSubscriber<? super T>[] subscribers) {
 		}
 		
 		int n = subscribers.length;
-		
 		for (int i = 0; i < n; i++) {
 			Flux.from(sources[i]).subscribe(subscribers[i]);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,7 +43,7 @@ final class ParallelCollect<T, C> extends ParallelFlux<C> implements Scannable,
 	ParallelCollect(ParallelFlux<? extends T> source,
 			Supplier<? extends C> initialCollection,
 			BiConsumer<? super C, ? super T> collector) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.initialCollection = initialCollection;
 		this.collector = collector;
 	}
@@ -54,6 +54,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -50,7 +50,7 @@ final class ParallelConcatMap<T, R> extends ParallelFlux<R> implements Scannable
 			Function<? super T, ? extends Publisher<? extends R>> mapper, 
 					Supplier<? extends Queue<T>> queueSupplier,
 					int prefetch, ErrorMode errorMode) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.mapper = Objects.requireNonNull(mapper, "mapper");
 		this.queueSupplier = Objects.requireNonNull(queueSupplier, "queueSupplier");
 		this.prefetch = prefetch;
@@ -64,6 +64,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.DELAY_ERROR) return errorMode != ErrorMode.IMMEDIATE;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelDoOnEach.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,7 +46,7 @@ final class ParallelDoOnEach<T> extends ParallelFlux<T> implements Scannable {
 			@Nullable BiConsumer<Context, ? super Throwable> onError,
 			@Nullable Consumer<Context> onComplete
 	) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 
 		this.onNext = onNext;
 		this.onError = onError;
@@ -98,6 +98,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFilter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,7 +35,7 @@ final class ParallelFilter<T> extends ParallelFlux<T> implements Scannable{
 	final Predicate<? super T> predicate;
 	
 	ParallelFilter(ParallelFlux<T> source, Predicate<? super T> predicate) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.predicate = predicate;
 	}
 
@@ -45,6 +45,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -53,7 +53,7 @@ final class ParallelFlatMap<T, R> extends ParallelFlux<R> implements Scannable{
 			boolean delayError, 
 			int maxConcurrency, Supplier<? extends Queue<R>> mainQueueSupplier, 
 			int prefetch, Supplier<? extends Queue<R>> innerQueueSupplier) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.mapper = mapper;
 		this.delayError = delayError;
 		this.maxConcurrency = maxConcurrency;
@@ -69,6 +69,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.DELAY_ERROR) return delayError;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +32,7 @@ final class ParallelFluxHide<T> extends ParallelFlux<T> implements Scannable{
 	final ParallelFlux<T> source;
 
 	ParallelFluxHide(ParallelFlux<T> source) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 	}
 
 	@Override
@@ -51,6 +51,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,7 +46,7 @@ final class ParallelFluxOnAssembly<T> extends ParallelFlux<T>
 	 * Create an assembly trace wrapping a {@link ParallelFlux}.
 	 */
 	ParallelFluxOnAssembly(ParallelFlux<T> source, AssemblySnapshot stacktrace) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.stacktrace = stacktrace;
 	}
 
@@ -97,6 +97,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -40,7 +40,7 @@ final class ParallelGroup<T> extends Flux<GroupedFlux<Integer, T>> implements
 	final ParallelFlux<? extends T> source;
 
 	ParallelGroup(ParallelFlux<? extends T> source) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 	}
 
 	@Override
@@ -65,6 +65,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,7 +36,7 @@ final class ParallelLog<T> extends ParallelFlux<T> implements Scannable {
 	ParallelLog(ParallelFlux<T> source,
 			SignalPeek<T> log
 	) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.log = log;
 	}
 
@@ -81,6 +81,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,7 +36,7 @@ final class ParallelMap<T, R> extends ParallelFlux<R> implements Scannable {
 	final Function<? super T, ? extends R> mapper;
 	
 	ParallelMap(ParallelFlux<T> source, Function<? super T, ? extends R> mapper) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.mapper = mapper;
 	}
 
@@ -46,6 +46,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeOrdered.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,7 +41,7 @@ final class ParallelMergeOrdered<T> extends Flux<T> implements Scannable {
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
 		}
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.prefetch = prefetch;
 		this.valueComparator = valueComparator;
 	}
@@ -57,6 +57,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return prefetch;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -42,7 +42,7 @@ final class ParallelMergeReduce<T> extends Mono<T> implements Scannable, Fuseabl
 
 	ParallelMergeReduce(ParallelFlux<? extends T> source,
 			BiFunction<T, T, T> reducer) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.reducer = reducer;
 	}
 
@@ -51,6 +51,7 @@ final class ParallelMergeReduce<T> extends Mono<T> implements Scannable, Fuseabl
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,7 +46,7 @@ final class ParallelMergeSequential<T> extends Flux<T> implements Scannable {
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
 		}
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.prefetch = prefetch;
 		this.queueSupplier = queueSupplier;
 	}
@@ -57,6 +57,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -47,7 +47,7 @@ final class ParallelMergeSort<T> extends Flux<T> implements Scannable {
 
 	ParallelMergeSort(ParallelFlux<List<T>> source,
 			Comparator<? super T> comparator) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.comparator = comparator;
 	}
 
@@ -71,6 +71,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -52,7 +52,7 @@ final class ParallelPeek<T> extends ParallelFlux<T> implements SignalPeek<T>{
 			@Nullable LongConsumer onRequest,
 			@Nullable Runnable onCancel
 	) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 
 		this.onNext = onNext;
 		this.onAfterNext = onAfterNext;
@@ -153,6 +153,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,7 +44,7 @@ final class ParallelReduceSeed<T, R> extends ParallelFlux<R> implements
 	ParallelReduceSeed(ParallelFlux<? extends T> source,
 			Supplier<R> initialSupplier,
 			BiFunction<R, ? super T, R> reducer) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 		this.initialSupplier = initialSupplier;
 		this.reducer = reducer;
 	}
@@ -55,6 +55,7 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -45,7 +45,7 @@ final class ParallelRunOn<T> extends ParallelFlux<T> implements Scannable{
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
 		}
-		this.source = parent;
+		this.source = ParallelFlux.from(parent);
 		this.scheduler = scheduler;
 		this.prefetch = prefetch;
 		this.queueSupplier = queueSupplier;
@@ -57,6 +57,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -54,7 +54,7 @@ final class ParallelSource<T> extends ParallelFlux<T> implements Scannable {
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
 		}
-		this.source = source;
+		this.source = Operators.toFluxOrMono(source);
 		this.parallelism = parallelism;
 		this.prefetch = prefetch;
 		this.queueSupplier = queueSupplier;
@@ -76,6 +76,7 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelThen.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2019-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,14 +34,15 @@ final class ParallelThen extends Mono<Void> implements Scannable, Fuseable {
 	final ParallelFlux<?> source;
 
 	ParallelThen(ParallelFlux<?> source) {
-		this.source = source;
+		this.source = ParallelFlux.from(source);
 	}
 
 	@Override
 	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		if (key == InternalProducerAttr.INSTANCE) return true;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -4745,7 +4745,7 @@ public SignalListener<T> createListener(Publisher<? extends T> ignored1, Context
 	 * in conjunction with the use of {@link #contextCapture()} operator down the chain.
 	 *
 	 * @param listenerFactory the {@link SignalListenerFactory} to create a new {@link SignalListener} on each subscription
-	 * @return a new {@link Flux} with side effects defined by generated {@link SignalListener}
+	 * @return a new {@link Mono} with side effects defined by generated {@link SignalListener}
 	 * @see #tap(Supplier)
 	 * @see #tap(Function)
 	 */

File: reactor-core/src/test/java/reactor/core/publisher/BlockingIterableTest.java
Patch:
@@ -240,6 +240,7 @@ public void scanSubscriberCancelled() {
 	public void hasNextInterrupt() throws InterruptedException {
 		BlockingIterable.SubscriberIterator<String> test = new BlockingIterable.SubscriberIterator<>(
 				Queues.<String>one().get(),
+				Context.empty(),
 				123
 		);
 		

File: reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -181,6 +181,7 @@ else if (empty) {
 					}
 					catch (InterruptedException ex) {
 						run();
+						Thread.currentThread().interrupt();
 						throw Exceptions.propagate(ex);
 					}
 					finally {

File: reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -88,6 +88,7 @@ final T blockingGet() {
 			}
 			catch (InterruptedException ex) {
 				dispose();
+				Thread.currentThread().interrupt();
 				throw Exceptions.propagate(ex);
 			}
 		}
@@ -128,6 +129,7 @@ final T blockingGet(long timeout, TimeUnit unit) {
 				RuntimeException re = Exceptions.propagate(ex);
 				//this is ok, as re is always a new non-singleton instance
 				re.addSuppressed(new Exception("#block has been interrupted"));
+				Thread.currentThread().interrupt();
 				throw re;
 			}
 		}

File: reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package reactor.core.publisher;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -156,6 +157,7 @@ public class OnDiscardShouldNotLeakTest {
 			DiscardScenario.fluxSource("monoFilterWhenFalse", main -> main.last().filterWhen(__ -> Mono.just(false).hide())),
 			DiscardScenario.fluxSource("last", main -> main.last(new Tracked("default")).flatMap(f -> Mono.just(f).hide())),
 			DiscardScenario.fluxSource("flatMapIterable", f -> f.flatMapIterable(Arrays::asList)),
+			DiscardScenario.fluxSource("bufferTimeout", f -> f.bufferTimeout(2, Duration.ofMillis(1), true).flatMapIterable(Function.identity())),
 			DiscardScenario.fluxSource("publishOnDelayErrors", f -> f.publishOn(Schedulers.immediate())),
 			DiscardScenario.fluxSource("publishOnImmediateErrors", f -> f.publishOn(Schedulers.immediate(), false, Queues.SMALL_BUFFER_SIZE)),
 			DiscardScenario.fluxSource("publishOnAndPublishOn", main -> main

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -311,11 +311,10 @@ void innerNext(MergeSequentialInner<R> inner, R value) {
 		}
 
 		void innerError(MergeSequentialInner<R> inner, Throwable e) {
-			inner.setDone();
-
 			e = Operators.onNextInnerError(e, currentContext(), s);
 			if (e != null) {
 				if (Exceptions.addThrowable(ERROR, this, e)) {
+					inner.setDone();
 					if (errorMode != ErrorMode.END) {
 						s.cancel();
 					}
@@ -326,6 +325,7 @@ void innerError(MergeSequentialInner<R> inner, Throwable e) {
 				}
 			}
 			else {
+				inner.setDone();
 				drain();
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -45,7 +45,8 @@ final class FluxHandle<T, R> extends InternalFluxOperator<T, R> {
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {
-		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext);
+		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagationSupport.shouldRestoreThreadLocalsInSomeOperators() ?
+				ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext) : this.handler;
 		if (actual instanceof Fuseable.ConditionalSubscriber) {
 			@SuppressWarnings("unchecked")
 			Fuseable.ConditionalSubscriber<? super R> cs = (Fuseable.ConditionalSubscriber<? super R>) actual;

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -58,7 +58,8 @@ final class FluxHandleFuseable<T, R> extends InternalFluxOperator<T, R> implemen
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {
-		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext);
+		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagationSupport.shouldRestoreThreadLocalsInSomeOperators() ?
+				ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext) : this.handler;
 		if (actual instanceof ConditionalSubscriber) {
 			@SuppressWarnings("unchecked")
 			ConditionalSubscriber<? super R> cs = (ConditionalSubscriber<? super R>) actual;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -68,7 +68,7 @@ final class FluxSource<I> extends Flux<I> implements SourceProducer<I>,
 	@Override
 	@SuppressWarnings("unchecked")
 	public void subscribe(CoreSubscriber<? super I> actual) {
-		if (ContextPropagation.shouldPropagateContextToThreadLocals()) {
+		if (ContextPropagationSupport.shouldPropagateContextToThreadLocals()) {
 			source.subscribe(new FluxSourceRestoringThreadLocalsSubscriber<>(actual));
 		} else {
 			source.subscribe(actual);

File: reactor-core/src/main/java/reactor/core/publisher/FluxTap.java
Patch:
@@ -58,7 +58,8 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 		}
 		// Attempt to wrap the SignalListener with one that restores ThreadLocals from Context on each listener methods
 		// (only if ContextPropagation.isContextPropagationAvailable() is true)
-		signalListener = ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext);
+		signalListener = ContextPropagationSupport.isContextPropagationAvailable() ?
+				ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext) : signalListener;
 
 		try {
 			signalListener.doFirst();

File: reactor-core/src/main/java/reactor/core/publisher/FluxTapFuseable.java
Patch:
@@ -59,7 +59,8 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 		}
 		// Attempt to wrap the SignalListener with one that restores ThreadLocals from Context on each listener methods
 		// (only if ContextPropagation.isContextPropagationAvailable() is true)
-		signalListener = ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext);
+		signalListener = ContextPropagationSupport.isContextPropagationAvailable() ?
+				ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext) : signalListener;
 
 		try {
 			signalListener.doFirst();

File: reactor-core/src/main/java/reactor/core/publisher/MonoCompletionStage.java
Patch:
@@ -52,7 +52,7 @@ final class MonoCompletionStage<T> extends Mono<T>
 
     @Override
     public void subscribe(CoreSubscriber<? super T> actual) {
-        if (ContextPropagation.shouldPropagateContextToThreadLocals()) {
+        if (ContextPropagationSupport.shouldPropagateContextToThreadLocals()) {
             actual.onSubscribe(
                     new MonoCompletionStageRestoringThreadLocalsSubscription<>(
                             actual, future, suppressCancellation));

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromPublisher.java
Patch:
@@ -55,7 +55,7 @@ final class MonoFromPublisher<T> extends Mono<T> implements Scannable,
 	@Override
 	@SuppressWarnings("unchecked")
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		if (ContextPropagation.shouldPropagateContextToThreadLocals()) {
+		if (ContextPropagationSupport.shouldPropagateContextToThreadLocals()) {
 			actual = new MonoSource.MonoSourceRestoringThreadLocalsSubscriber<>(actual);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoHandle.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,7 +41,8 @@ final class MonoHandle<T, R> extends InternalMonoOperator<T, R> {
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {
-		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext);
+		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagationSupport.shouldRestoreThreadLocalsInSomeOperators() ?
+				ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext) : this.handler;
 		return new FluxHandle.HandleSubscriber<>(actual, handler2);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoHandleFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,7 +43,8 @@ final class MonoHandleFuseable<T, R> extends InternalMonoOperator<T, R>
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {
-		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext);
+		BiConsumer<? super T, SynchronousSink<R>> handler2 = ContextPropagationSupport.shouldRestoreThreadLocalsInSomeOperators() ?
+				ContextPropagation.contextRestoreForHandle(this.handler, actual::currentContext) : this.handler;
 		return new FluxHandleFuseable.HandleFuseableSubscriber<>(actual, handler2);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -65,7 +65,7 @@ final class MonoSource<I> extends Mono<I> implements Scannable, SourceProducer<I
 	 */
 	@Override
 	public void subscribe(CoreSubscriber<? super I> actual) {
-		if (ContextPropagation.shouldPropagateContextToThreadLocals()) {
+		if (ContextPropagationSupport.shouldPropagateContextToThreadLocals()) {
 			source.subscribe(new MonoSourceRestoringThreadLocalsSubscriber<>(actual));
 		} else {
 			source.subscribe(actual);

File: reactor-core/src/main/java/reactor/core/publisher/MonoTap.java
Patch:
@@ -56,7 +56,8 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 		}
 		// Attempt to wrap the SignalListener with one that restores ThreadLocals from Context on each listener methods
 		// (only if ContextPropagation.isContextPropagationAvailable() is true)
-		signalListener = ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext);
+		signalListener = ContextPropagationSupport.isContextPropagationAvailable() ?
+				ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext) : signalListener;
 
 		try {
 			signalListener.doFirst();

File: reactor-core/src/main/java/reactor/core/publisher/MonoTapFuseable.java
Patch:
@@ -55,7 +55,8 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 		}
 		// Attempt to wrap the SignalListener with one that restores ThreadLocals from Context on each listener methods
 		// (only if ContextPropagation.isContextPropagationAvailable() is true)
-		signalListener = ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext);
+		signalListener = ContextPropagationSupport.isContextPropagationAvailable() ?
+				ContextPropagation.contextRestoreForTap(signalListener, actual::currentContext) : signalListener;
 
 		try {
 			signalListener.doFirst();

File: reactor-core/src/test/java/reactor/core/publisher/ContextPropagationNotThereSmokeTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -29,7 +29,7 @@ class ContextPropagationNotThereSmokeTest {
 
 	@Test
 	void contextPropagationIsNotAvailable() {
-		assertThat(ContextPropagation.isContextPropagationAvailable()).isFalse();
+		assertThat(ContextPropagationSupport.isContextPropagationAvailable()).isFalse();
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -9249,6 +9249,9 @@ public SignalListener<T> createListener(Publisher<? extends T> ignored1, Context
 	 * @see #tap(Function)
 	 */
 	public final Flux<T> tap(SignalListenerFactory<T, ?> listenerFactory) {
+		if (ContextPropagation.shouldPropagateContextToThreadLocals()) {
+			return onAssembly(new FluxTapRestoringThreadLocals<>(this, listenerFactory));
+		}
 		if (this instanceof Fuseable) {
 			return onAssembly(new FluxTapFuseable<>(this, listenerFactory));
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxTap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,7 +44,7 @@ final class FluxTap<T, STATE> extends InternalFluxOperator<T, T> {
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) throws Throwable {
-		//if the SequenceObserver cannot be created, all we can do is error the subscriber.
+		//if the SignalListener cannot be created, all we can do is error the subscriber.
 		//after it is created, in case doFirst fails we can additionally try to invoke doFinally.
 		//note that if the later handler also fails, then that exception is thrown.
 		SignalListener<T> signalListener;

File: reactor-core/src/main/java/reactor/core/publisher/FluxTapFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,7 +44,7 @@ final class FluxTapFuseable<T, STATE> extends InternalFluxOperator<T, T> impleme
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) throws Throwable {
-		//if the SequenceObserver cannot be created, all we can do is error the subscriber.
+		//if the SignalListener cannot be created, all we can do is error the subscriber.
 		//after it is created, in case doFirst fails we can additionally try to invoke doFinally.
 		//note that if the later handler also fails, then that exception is thrown.
 		SignalListener<T> signalListener;

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -4740,6 +4740,9 @@ public SignalListener<T> createListener(Publisher<? extends T> ignored1, Context
 	 * @see #tap(Function)
 	 */
 	public final Mono<T> tap(SignalListenerFactory<T, ?> listenerFactory) {
+		if (ContextPropagation.shouldPropagateContextToThreadLocals()) {
+			return onAssembly(new MonoTapRestoringThreadLocals<>(this, listenerFactory));
+		}
 		if (this instanceof Fuseable) {
 			return onAssembly(new MonoTapFuseable<>(this, listenerFactory));
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoTap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,7 +41,7 @@ final class MonoTap<T, STATE> extends InternalMonoOperator<T, T> {
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) throws Throwable {
-		//if the SequenceObserver cannot be created, all we can do is error the subscriber.
+		//if the SignalListener cannot be created, all we can do is error the subscriber.
 		//after it is created, in case doFirst fails we can additionally try to invoke doFinally.
 		//note that if the later handler also fails, then that exception is thrown.
 		SignalListener<T> signalListener;

File: reactor-core/src/main/java/reactor/core/publisher/MonoTapFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2022-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -40,7 +40,7 @@ final class MonoTapFuseable<T, STATE> extends InternalMonoOperator<T, T> impleme
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) throws Throwable {
-		//if the SequenceObserver cannot be created, all we can do is error the subscriber.
+		//if the SignalListener cannot be created, all we can do is error the subscriber.
 		//after it is created, in case doFirst fails we can additionally try to invoke doFinally.
 		//note that if the later handler also fails, then that exception is thrown.
 		SignalListener<T> signalListener;

File: reactor-core/src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -535,7 +535,7 @@ public static void disableContextLossTracking() {
 	 * a logical boundary for the context propagation mechanism.
 	 */
 	public static void enableAutomaticContextPropagation() {
-		if (ContextPropagation.isContextPropagationAvailable) {
+		if (ContextPropagation.isContextPropagationOnClasspath) {
 			Hooks.addQueueWrapper(
 					CONTEXT_IN_THREAD_LOCALS_KEY, ContextPropagation.ContextQueue::new
 			);
@@ -552,7 +552,7 @@ public static void enableAutomaticContextPropagation() {
 	 * @see #enableAutomaticContextPropagation()
 	 */
 	public static void disableAutomaticContextPropagation() {
-		if (ContextPropagation.isContextPropagationAvailable) {
+		if (ContextPropagation.isContextPropagationOnClasspath) {
 			Hooks.removeQueueWrapper(CONTEXT_IN_THREAD_LOCALS_KEY);
 			Schedulers.resetOnScheduleHook(CONTEXT_IN_THREAD_LOCALS_KEY);
 			ContextPropagation.propagateContextToThreadLocals = false;

File: reactor-core/src/main/java/reactor/util/retry/RetryBackoffSpec.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -605,7 +605,7 @@ public Flux<Long> generateCompanion(Flux<RetrySignal> t) {
 				return RetrySpec.applyHooks(copy, Mono.delay(effectiveBackoff, backoffSchedulerSupplier.get()),
 						syncPreRetry, syncPostRetry, asyncPreRetry, asyncPostRetry, cv);
 			})
-		    .contextWrite(c -> Context.empty())
+		    .onErrorStop()
 		);
 	}
 }

File: reactor-core/src/main/java/reactor/util/retry/RetrySpec.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -376,7 +376,7 @@ else if (iteration >= maxAttempts) {
 							return applyHooks(copy, Mono.just(iteration), doPreRetry, doPostRetry, asyncPreRetry, asyncPostRetry, cv);
 						}
 					})
-					.contextWrite(c -> Context.empty())
+					.onErrorStop()
 		);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2023 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -588,7 +588,7 @@ void drainSync() {
 							sp = iterable.spliterator();
 							itFinite = FluxIterable.checkFinite(sp);
 
-							isEmpty = itFinite && sp.estimateSize() == 0;
+							isEmpty = itFinite ? sp.estimateSize() == 0 : !hasNext(sp);
 						}
 						catch (Throwable exc) {
 							resetCurrent();

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -382,7 +382,7 @@ void drainAsync() {
 							sp = iterable.spliterator();
 							itFinite = FluxIterable.checkFinite(sp);
 
-							isEmpty = itFinite && sp.estimateSize() == 0;
+							isEmpty = itFinite ? sp.estimateSize() == 0 : !hasNext(sp);
 						}
 						catch (Throwable exc) {
 							sp = null;

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -16,10 +16,8 @@
 
 package reactor.core.publisher;
 
-import java.util.Iterator;
 import java.util.Objects;
 import java.util.Spliterator;
-import java.util.Spliterators;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 

File: benchmarks/src/main/java/reactor/core/scheduler/OldBoundedElasticScheduler.java
Patch:
@@ -148,6 +148,7 @@ public boolean isDisposed() {
 		return BOUNDED_SERVICES.get(this) == SHUTDOWN;
 	}
 
+	@SuppressWarnings("deprecation")
 	@Override
 	public void start() {
 		for (;;) {

File: benchmarks/src/main/java/reactor/core/scrabble/ShakespearePlaysScrabbleParallelOpt.java
Patch:
@@ -50,7 +50,7 @@ public static void main(String[] args) throws Exception {
 
 	@Setup
 	public void localSetup() {
-		scheduler = Schedulers.newElastic("RcParallel");
+		scheduler = Schedulers.newBoundedElastic(Schedulers.DEFAULT_BOUNDED_ELASTIC_SIZE, Schedulers.DEFAULT_BOUNDED_ELASTIC_QUEUESIZE, "RcParallel");
 	}
 
 	@TearDown

File: reactor-core/src/main/java/reactor/core/scheduler/BoundedElasticScheduler.java
Patch:
@@ -219,8 +219,7 @@ public void start() {
 	}
 
 	@Override
-	public boolean await(BoundedServices boundedServices, long timeout, TimeUnit timeUnit)
-			throws InterruptedException {
+	public boolean await(BoundedServices boundedServices, long timeout, TimeUnit timeUnit) throws InterruptedException {
 		if (!boundedServices.evictor.awaitTermination(timeout, timeUnit)) {
 			return false;
 		}
@@ -508,7 +507,7 @@ private BoundedServices() {
 			this.clock = parent.clock;
 			this.idleQueue = new ConcurrentLinkedDeque<>();
 			this.busyStates = ALL_IDLE;
-			this.evictor = Executors.newScheduledThreadPool(1, EVICTOR_FACTORY);
+			this.evictor = Executors.newSingleThreadScheduledExecutor(EVICTOR_FACTORY);
 		}
 
 		/**

File: reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java
Patch:
@@ -146,7 +146,7 @@ public boolean isDisposed() {
 
 	@Override
 	public boolean await(ScheduledExecutorService resource, long timeout, TimeUnit timeUnit)
-			throws InterruptedException {
+		throws InterruptedException {
 		return resource.awaitTermination(timeout, timeUnit);
 	}
 

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -111,7 +111,7 @@ public void init() {
 			);
 		}
 
-		this.evictor = Executors.newScheduledThreadPool(1, EVICTOR_FACTORY);
+		this.evictor = Executors.newSingleThreadScheduledExecutor(EVICTOR_FACTORY);
 		this.evictor.scheduleAtFixedRate(this::eviction,
 				ttlSeconds,
 				ttlSeconds,
@@ -124,7 +124,7 @@ public void start() {
 		if (!shutdown) {
 			return;
 		}
-		this.evictor = Executors.newScheduledThreadPool(1, EVICTOR_FACTORY);
+		this.evictor = Executors.newSingleThreadScheduledExecutor(EVICTOR_FACTORY);
 		this.evictor.scheduleAtFixedRate(this::eviction,
 				ttlSeconds,
 				ttlSeconds,

File: reactor-core/src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -132,8 +132,7 @@ public void start() {
 	}
 
 	@Override
-	public boolean await(ScheduledExecutorService resource, long timeout, TimeUnit timeUnit)
-			throws InterruptedException {
+	public boolean await(ScheduledExecutorService resource, long timeout, TimeUnit timeUnit) throws InterruptedException {
 		return resource.awaitTermination(timeout, timeUnit);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeOrdered.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,7 +64,7 @@ public Object scanUnsafe(Attr key) {
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
 		FluxMergeComparing.MergeOrderedMainProducer<T>
-				main = new FluxMergeComparing.MergeOrderedMainProducer<>(actual, valueComparator, prefetch, source.parallelism(), true);
+				main = new FluxMergeComparing.MergeOrderedMainProducer<>(actual, valueComparator, prefetch, source.parallelism(), true, true);
 		actual.onSubscribe(main);
 		source.subscribe(main.subscribers);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoCountTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ContextPropagationNotThereSmokeTest.java
Patch:
@@ -16,8 +16,6 @@
 
 package reactor.core.publisher;
 
-import java.util.function.Predicate;
-
 import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/main/java/reactor/core/publisher/ContextPropagation.java
Patch:
@@ -48,7 +48,7 @@ final class ContextPropagation {
 	static {
 		boolean contextPropagation;
 		try {
-			Class.forName("io.micrometer.context.ContextRegistry", false, ContextPropagation.class.getClassLoader());
+			Class.forName("io.micrometer.context.ContextRegistry");
 			contextPropagation = true;
 		}
 		catch (Throwable t) {

File: reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package reactor.test.publisher;
 
-import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.Objects;
 

File: reactor-core/src/main/java/reactor/core/scheduler/ReactorBlockHoundIntegration.java
Patch:
@@ -42,6 +42,7 @@ public void applyTo(BlockHound.Builder builder) {
 
         // Calls ScheduledFutureTask#cancel that may short park in DelayedWorkQueue#remove for getting a lock
         builder.allowBlockingCallsInside(SchedulerTask.class.getName(), "dispose");
+        builder.allowBlockingCallsInside(WorkerTask.class.getName(), "dispose");
 
         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), "processWorkerExit");
     }

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -1449,7 +1449,8 @@ final void onExpectation(Signal<T> actualSignal) {
 						return;
 					}
 					//possibly re-evaluate the current onNext
-					event = this.script.peek();
+					onExpectation(actualSignal);
+					return;
 				}
 
 				if (event instanceof CollectEvent) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeout.java
Patch:
@@ -36,6 +36,8 @@
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
 
+import static reactor.core.Exceptions.wrapSource;
+
 /**
  * @author David Karnok
  */
@@ -207,7 +209,7 @@ public void onError(Throwable t) {
 
 			final InnerWindow<T> window = this.window;
 			if (window != null) {
-				window.sendError(t);
+				window.sendError(wrapSource(t));
 
 				if (hasUnsentWindow(previousState)) {
 					return;

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -37,7 +37,6 @@
 import java.util.function.Supplier;
 
 import io.micrometer.core.instrument.MeterRegistry;
-
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
@@ -768,7 +767,7 @@ public static Snapshot setFactoryWithSnapshot(Factory newFactory) {
 	}
 
 	/**
-	 * Replace the current Factory and shared Schedulers with the ones saved in a 
+	 * Replace the current Factory and shared Schedulers with the ones saved in a
 	 * previously {@link #setFactoryWithSnapshot(Factory) captured} snapshot.
 	 * <p>
 	 * Passing {@code null} re-applies the default factory.
@@ -1552,5 +1551,4 @@ static final Object scanExecutor(Executor executor, Scannable.Attr key) {
 
 		return null;
 	}
-
 }

File: reactor-core/src/test/java/reactor/core/DisposableTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -223,5 +223,4 @@ public void neverImmutable() {
 	public void neverCreatesInstances() {
 		assertThat(Disposables.never()).isNotSameAs(Disposables.never());
 	}
-
 }

File: reactor-core/src/main/java/reactor/core/scheduler/SchedulerMetricDecorator.java
Patch:
@@ -34,7 +34,7 @@
 import reactor.core.Scannable.Attr;
 import reactor.util.Metrics;
 
-@Deprecated //this class is duplicated in reactor-core-micrometer
+@Deprecated
 final class SchedulerMetricDecorator
 			implements BiFunction<Scheduler, ScheduledExecutorService, ScheduledExecutorService>,
 			           Disposable {

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -606,7 +606,7 @@ public static boolean isNonBlockingThread(Thread t) {
 	 * </p>
 	 *
 	 * @implNote Note that this is added as a decorator via Schedulers when enabling metrics for schedulers, which doesn't change the Factory.
-	 * @deprecated prefer using the equivalent method in reactor-core-micrometer module. To be removed at the earliest in 3.6.0.
+	 * @deprecated prefer using Micrometer#timedScheduler from the reactor-core-micrometer module. To be removed at the earliest in 3.6.0.
 	 */
 	@Deprecated
 	public static void enableMetrics() {
@@ -619,7 +619,7 @@ public static void enableMetrics() {
 	 * If {@link #enableMetrics()} has been previously called, removes the decorator.
 	 * No-op if {@link #enableMetrics()} hasn't been called.
 	 *
-	 * @deprecated prefer using the equivalent method in reactor-core-micrometer module. To be removed at the earliest in 3.6.0.
+	 * @deprecated prefer using Micrometer#timedScheduler from the reactor-core-micrometer module. To be removed at the earliest in 3.6.0.
 	 */
  	@Deprecated
 	public static void disableMetrics() {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDetachTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -114,7 +114,7 @@ public void backpressured() throws Exception {
 		    .onTerminateDetach()
 		    .subscribe(ts);
 
-		ts.assertNoValues();
+ 		ts.assertNoValues();
 
 		ts.request(1);
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnTest.java
Patch:
@@ -174,9 +174,9 @@ public void classicWithTimeout() {
 					}
 					return 0;
 				})
+			    .subscribeOn(timeoutScheduler)
 				.timeout(Duration.ofMillis(100L))
-				.onErrorResume(t -> Mono.fromCallable(() -> 1))
-				.subscribeOn(timeoutScheduler),
+				.onErrorResume(t -> Mono.fromCallable(() -> 1)),
 			0)
 			.expectSubscription()
 			.thenRequest(1)

File: reactor-core/src/test/java/reactor/core/publisher/LambdaMonoSubscriberTest.java
Patch:
@@ -209,9 +209,9 @@ void onNextConsumerFatalDoesntTriggerCancellation(TestLogger testLogger) {
 		TestSubscription testSubscription = new TestSubscription();
 		tested.onSubscribe(testSubscription);
 
-		//the error is expected to be thrown as it is fatal, so it doesn't go through onErrorDropped
+		//the error is expected to be thrown as it is fatal, so it doesn't go through onErrorDropped. However, throwIfJvmFatal now logs it.
 		assertThatExceptionOfType(OutOfMemoryError.class).isThrownBy(() -> tested.onNext("foo"));
-		Assertions.assertThat(testLogger.getErrContent()).isEmpty();
+		Assertions.assertThat(testLogger.getErrContent()).startsWith("[ WARN] throwIfFatal detected a jvm fatal exception, which is thrown and logged below: - java.lang.OutOfMemoryError");
 
 		assertThat(testSubscription.isCancelled).as("subscription isCancelled")
 			.isFalse();

File: reactor-core-micrometer/src/main/java/reactor/core/observability/micrometer/Micrometer.java
Patch:
@@ -100,15 +100,16 @@ public final class Micrometer {
 	 * Set-up a decorator that will instrument any {@link ExecutorService} that backs a reactor-core {@link Scheduler}
 	 * (or scheduler implementations which use {@link Schedulers#decorateExecutorService(Scheduler, ScheduledExecutorService)}).
 	 * <p>
-	 * The {@link MeterRegistry} to use can be configured via {@link #useRegistry(MeterRegistry)}
+	 * The {@link MeterRegistry} to use can be configured via {@link reactor.util.Metrics.MicrometerConfiguration#useRegistry(MeterRegistry)}
 	 * prior to using this method, the default being {@link io.micrometer.core.instrument.Metrics#globalRegistry}.
 	 *
 	 * @implNote Note that this is added as a decorator via Schedulers when enabling metrics for schedulers,
 	 * which doesn't change the Factory.
 	 */
+	@Deprecated
 	public static void enableSchedulersMetricsDecorator() {
 		Schedulers.addExecutorServiceDecorator(SCHEDULERS_DECORATOR_KEY,
-			new MicrometerSchedulerMetricsDecorator(getRegistry()));
+			new MicrometerSchedulerMetricsDecorator(reactor.util.Metrics.MicrometerConfiguration.getRegistry()));
 	}
 
 	/**

File: reactor-core-micrometer/src/test/java/reactor/core/observability/micrometer/MicrometerObservationListenerFactoryTest.java
Patch:
@@ -46,7 +46,7 @@ void configurationFromMono() {
 
 		assertThat(configuration.registry).as("registry").isSameAs(CUSTOM_REGISTRY);
 		assertThat(configuration.isMono).as("isMono").isTrue();
-		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("tag(" + "reactor.type" + "=Mono)");
+		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("keyValue(" + "reactor.type" + "=Mono)");
 	}
 
 	@Test
@@ -55,7 +55,7 @@ void configurationFromFlux() {
 
 		assertThat(configuration.registry).as("registry").isSameAs(CUSTOM_REGISTRY);
 		assertThat(configuration.isMono).as("isMono").isFalse();
-		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("tag(" + "reactor.type" + "=Flux)");
+		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("keyValue(" + "reactor.type" + "=Flux)");
 	}
 
 	@Test

File: reactor-core-micrometer/src/main/java/reactor/core/observability/micrometer/MicrometerMeterListener.java
Patch:
@@ -126,7 +126,7 @@ public void doOnNext(T t) {
 		}
 		//record the delay since previous onNext/onSubscribe. This also records the count.
 		long last = this.lastNextEventNanos;
-		this.lastNextEventNanos = configuration.clock.monotonicTime();
+		this.lastNextEventNanos = configuration.registry.config().clock().monotonicTime();
 		this.onNextIntervalTimer.record(lastNextEventNanos - last, TimeUnit.NANOSECONDS);
 	}
 
@@ -138,8 +138,8 @@ public void doOnMalformedOnNext(T value) {
 	@Override
 	public void doOnSubscription() {
 		recordOnSubscribe(configuration.sequenceName, configuration.commonTags, configuration.registry);
-		this.subscribeToTerminateSample = Timer.start(configuration.clock);
-		this.lastNextEventNanos = configuration.clock.monotonicTime();
+		this.subscribeToTerminateSample = Timer.start(configuration.registry);
+		this.lastNextEventNanos = configuration.registry.config().clock().monotonicTime();
 	}
 
 	@Override

File: reactor-core-micrometer/src/main/java/reactor/core/observability/micrometer/MicrometerMeterListenerFactory.java
Patch:
@@ -37,6 +37,7 @@ protected Clock useClock() {
 		return Clock.SYSTEM;
 	}
 
+	@SuppressWarnings("deprecation")
 	protected MeterRegistry useRegistry() {
 		return Micrometer.getRegistry();
 	}

File: reactor-core-micrometer/src/test/java/reactor/core/observability/micrometer/MicrometerObservationListenerFactoryTest.java
Patch:
@@ -46,7 +46,7 @@ void configurationFromMono() {
 
 		assertThat(configuration.registry).as("registry").isSameAs(CUSTOM_REGISTRY);
 		assertThat(configuration.isMono).as("isMono").isTrue();
-		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("tag(type=Mono)");
+		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("tag(" + "reactor.type" + "=Mono)");
 	}
 
 	@Test
@@ -55,7 +55,7 @@ void configurationFromFlux() {
 
 		assertThat(configuration.registry).as("registry").isSameAs(CUSTOM_REGISTRY);
 		assertThat(configuration.isMono).as("isMono").isFalse();
-		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("tag(type=Flux)");
+		assertThat(configuration.commonKeyValues).map(Object::toString).containsExactly("tag(" + "reactor.type" + "=Flux)");
 	}
 
 	@Test

File: reactor-core-micrometer/src/test/java/reactor/core/observability/micrometer/MicrometerTest.java
Patch:
@@ -64,7 +64,7 @@ void defaultRegistryCanBeChanged() {
 	void metricsUsesCommonRegistry() {
 		SimpleMeterRegistry customCommonRegistry = new SimpleMeterRegistry();
 		Micrometer.useRegistry(customCommonRegistry);
-		MicrometerListenerFactory<?> factory = (MicrometerListenerFactory<?>) Micrometer.metrics();
+		MicrometerMeterListenerFactory<?> factory = (MicrometerMeterListenerFactory<?>) Micrometer.metrics();
 
 		assertThat(factory.useClock()).as("clock").isSameAs(Clock.SYSTEM);
 		assertThat(factory.useRegistry()).as("registry").isSameAs(customCommonRegistry);
@@ -87,7 +87,7 @@ public long monotonicTime() {
 			}
 		};
 
-		MicrometerListenerFactory<?> factory = (MicrometerListenerFactory<?>) Micrometer.metrics(customLocalRegistry, customLocalClock);
+		MicrometerMeterListenerFactory<?> factory = (MicrometerMeterListenerFactory<?>) Micrometer.metrics(customLocalRegistry, customLocalClock);
 
 		assertThat(factory.useClock()).as("clock").isSameAs(customLocalClock).isNotSameAs(Clock.SYSTEM);
 		assertThat(factory.useRegistry()).as("registry").isSameAs(customLocalRegistry).isNotSameAs(customCommonRegistry);

File: reactor-core/src/main/java/reactor/util/context/ContextView.java
Patch:
@@ -144,5 +144,7 @@ default boolean isEmpty() {
 	 * @param action The action to be performed for each entry
 	 * @throws NullPointerException if the specified action is null
 	 */
-	void forEach(BiConsumer<Object, Object> action);
+	default void forEach(BiConsumer<Object, Object> action) {
+		stream().forEach(entry -> action.accept(entry.getKey(), entry.getValue()));
+	}
 }

File: reactor-core/src/main/java/reactor/util/context/ContextView.java
Patch:
@@ -144,5 +144,7 @@ default boolean isEmpty() {
 	 * @param action The action to be performed for each entry
 	 * @throws NullPointerException if the specified action is null
 	 */
-	void forEach(BiConsumer<Object, Object> action);
+	default void forEach(BiConsumer<Object, Object> action) {
+		stream().forEach(entry -> action.accept(entry.getKey(), entry.getValue()));
+	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchMapTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -418,7 +418,7 @@ void scanInner() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		FluxSwitchMapNoPrefetch.SwitchMapMain<Integer, Integer> main =
 			new FluxSwitchMapNoPrefetch.SwitchMapMain<>(actual, i -> Mono.just(i));
-		FluxSwitchMapNoPrefetch.SwitchMapInner<Integer, Integer> test = new FluxSwitchMapNoPrefetch.SwitchMapInner<Integer, Integer>(main, actual, 0);
+		FluxSwitchMapNoPrefetch.SwitchMapInner<Integer, Integer> test = new FluxSwitchMapNoPrefetch.SwitchMapInner<Integer, Integer>(main, actual, 0, null);
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2018-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeoutTest.java
Patch:
@@ -248,7 +248,6 @@ public void noDelayMultipleOfSize() {
 		                        .concatMap(Flux::collectList))
 		            .assertNext(l -> assertThat(l).containsExactly(1, 2, 3, 4, 5))
 		            .assertNext(l -> assertThat(l).containsExactly(6, 7, 8, 9, 10))
-		            .assertNext(l -> assertThat(l).isEmpty())
 		            .verifyComplete();
 	}
 

File: reactor-test/src/main/java/reactor/test/util/RaceTestUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/blockHoundTest/java/reactor/core/scheduler/ReactorBlockHoundIntegrationTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2019-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoFinally.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,7 +44,7 @@ final class MonoDoFinally<T> extends InternalMonoOperator<T, T> {
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) {
-		return FluxDoFinally.createSubscriber(actual, onFinally, false);
+		return FluxDoFinally.createSubscriber(actual, onFinally);
 	}
 
 	@Override

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -1211,8 +1211,8 @@ void drainAsyncLoop(){
 					}
 					catch (Throwable e) {
 						Exceptions.throwIfFatal(e);
-						cancel();
 						onError(Exceptions.unwrap(e));
+						cancel();
 						return;
 					}
 					if (currentCollector != null) {

File: reactor-core/src/main/java/reactor/core/publisher/Sinks.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 
-import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/SinksTest.java
Patch:
@@ -623,7 +623,8 @@ DynamicContainer expectUnicast(Supplier<Sinks.Many<Integer>> sinkSupplier) {
 
 					assertThatCode(flux::subscribe).doesNotThrowAnyException();
 					StepVerifier.create(flux)
-								.verifyErrorSatisfies(e -> assertThat(e).hasMessageEndingWith("allows only a single Subscriber"));
+								.verifyErrorSatisfies(e -> assertThat(e)
+									.hasMessage("Sinks.many().unicast() sinks only allow a single Subscriber"));
 				}),
 
 				dynamicTest("honorsSubscriberBackpressure", () -> {

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -50,7 +50,7 @@ public void clear() {
 
 		ds.clear();
 
-		assertThat(ds.state).isEqualTo(MonoSubscriber.FUSED_CONSUMED);
+		assertThat(ds.state).isEqualTo(MonoSubscriber.FUSED_ASYNC_CONSUMED);
 		assertThat(ds.value).isNull();
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -616,8 +616,8 @@ final void remove(FluxPublish.PubSubInner<T> inner) {
 						q.clear();
 					}
 				}
+				return;
 			}
-			return;
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -83,7 +83,9 @@ public interface FluxSink<T> {
 	 *
 	 * @return the current subscriber {@link ContextView}.
 	 */
-	ContextView contextView();
+	default ContextView contextView() {
+		return currentContext();
+	}
 
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -83,7 +83,9 @@ public interface MonoSink<T> {
 	 *
 	 * @return the current subscriber {@link ContextView}.
 	 */
-	ContextView contextView();
+	default ContextView contextView() {
+		return this.currentContext();
+	}
 
 	/**
 	 * Attaches a {@link LongConsumer} to this {@link MonoSink} that will be notified of

File: reactor-core/src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -65,7 +65,9 @@ public interface SynchronousSink<T> {
 	 *
 	 * @return the current subscriber {@link ContextView}.
 	 */
-	ContextView contextView();
+	default ContextView contextView() {
+		return currentContext();
+	}
 
 	/**
 	 * @param e the exception to signal, not null

File: reactor-core/src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -83,7 +83,9 @@ public interface FluxSink<T> {
 	 *
 	 * @return the current subscriber {@link ContextView}.
 	 */
-	ContextView contextView();
+	default ContextView contextView() {
+		return currentContext();
+	}
 
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -83,7 +83,9 @@ public interface MonoSink<T> {
 	 *
 	 * @return the current subscriber {@link ContextView}.
 	 */
-	ContextView contextView();
+	default ContextView contextView() {
+		return this.currentContext();
+	}
 
 	/**
 	 * Attaches a {@link LongConsumer} to this {@link MonoSink} that will be notified of

File: reactor-core/src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -65,7 +65,9 @@ public interface SynchronousSink<T> {
 	 *
 	 * @return the current subscriber {@link ContextView}.
 	 */
-	ContextView contextView();
+	default ContextView contextView() {
+		return currentContext();
+	}
 
 	/**
 	 * @param e the exception to signal, not null

File: reactor-core/src/test/java/reactor/core/publisher/FluxGenerateTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -433,8 +433,8 @@ public void scanSubscriptionCancelled() {
     }
 
 	@Test
-	public void contextTest() {
-		StepVerifier.create(Flux.generate(s -> s.next(s.currentContext()
+	void contextIsReadable() {
+		StepVerifier.create(Flux.generate(s -> s.next(s.contextView()
 		                                               .get(AtomicInteger.class)
 		                                               .incrementAndGet()))
 		                        .take(10)

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -633,8 +633,8 @@ public void retryWhenContextTrigger_MergesOriginalContext() {
 					    }
 				    })
 				    .retryWhen(Retry.from(retrySignalFlux -> retrySignalFlux.handle((rs, sink) -> {
-	                    Context ctx = sink.currentContext();
-	                    int rl = ctx.getOrDefault("retriesLeft", 0);
+	                    ContextView ctxView = sink.contextView();
+	                    int rl = ctxView.getOrDefault("retriesLeft", 0);
 	                    if (rl > 0) {
 		                    sink.next(Context.of("retriesLeft", rl - 1));
 	                    }

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -381,8 +381,8 @@ public void ensuresElementsIsDiscarded() {
 	}
 
 	@Test
-	public void contextTest() {
-		StepVerifier.create(Mono.create(s -> s.success(s.currentContext()
+	void contextTest() {
+		StepVerifier.create(Mono.create(s -> s.success(s.contextView()
 		                                                .get(AtomicInteger.class)
 		                                                .incrementAndGet()))
 		                        .contextWrite(ctx -> ctx.put(AtomicInteger.class,

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -557,7 +557,7 @@ public void testHanging() {
 	public void testNPE() {
 		EmitterProcessor<String> processor = EmitterProcessor.create(8);
 		AssertSubscriber<String> first = AssertSubscriber.create(1);
-		processor.log().take(1).subscribe(first);
+		processor.log().take(1, false).subscribe(first);
 
 		AssertSubscriber<String> second = AssertSubscriber.create(3);
 		processor.log().subscribe(second);
@@ -879,7 +879,7 @@ public void syncFusionFromInfiniteStream() {
 	@Test
 	public void syncFusionFromInfiniteStreamAndTake() {
 		final Flux<Integer> flux = Flux.fromStream(Stream.iterate(0, i -> i + 1))
-				.take(10);
+				.take(10, false);
 		final EmitterProcessor<Integer> processor = EmitterProcessor.create();
 		flux.subscribe(processor);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -359,7 +359,7 @@ public void untilChangedDisposesStateOnCancel() {
 				    .map(retainedDetector::tracked)
 				    .concatWith(Mono.error(new Throwable("unexpected")))
 				    .bufferUntilChanged()
-				    .take(50);
+				    .take(50, false);
 
 
 		StepVerifier.create(test)

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -566,7 +566,7 @@ public void discardOnCancel() {
 	@Test
 	public void discardOnCancelSkip() {
 		StepVerifier.create(Flux.just(1, 2, 3, 4, 5)
-		                        .limitRequest(2)
+		                        .take(2)
 		                        .concatWith(Mono.never())
 		                        .buffer(3, 4))
 		            .thenAwait(Duration.ofMillis(10))
@@ -578,7 +578,7 @@ public void discardOnCancelSkip() {
 	@Test
 	public void discardOnCancelOverlap() {
 		StepVerifier.create(Flux.just(1, 2, 3, 4, 5, 6)
-		                        .limitRequest(2)
+		                        .take(2)
 		                        .concatWith(Mono.never())
 		                        .buffer(4, 2))
 		            .thenAwait(Duration.ofMillis(10))

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -163,7 +163,7 @@ public void errorManyDelayed() {
 	public void veryLongTake() {
 		Flux.range(1, 1_000_000_000)
 		    .concatWith(Flux.empty())
-		    .take(10)
+		    .take(10, false)
 		    .subscribeWith(AssertSubscriber.create())
 		    .assertComplete()
 		    .assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

File: reactor-core/src/test/java/reactor/core/publisher/FluxDematerializeTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -266,7 +266,7 @@ public void emissionTimingsAreGrouped() {
 		StepVerifier.withVirtualTime(() ->
 				Flux.interval(Duration.ofSeconds(1))
 				    .map(i -> "tick" + i)
-				    .take(5)
+				    .take(5, false)
 				    .timestamp()
 				    .materialize()
 				    .<Tuple2<Long, String>>dematerialize()

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -692,7 +692,7 @@ public void distinctDefaultCancelDoesntRetainObjects() throws InterruptedExcepti
 		                                 .map(i -> retainedDetector.tracked(new DistinctDefaultCancel(i)))
 		                                 .concatWith(Mono.error(new IllegalStateException("boom")))
 		                                 .distinct()
-		                                 .take(50);
+		                                 .take(50, false);
 
 		StepVerifier.create(test)
 		            .expectNextCount(50)

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -362,7 +362,7 @@ public void distinctUntilChangedDefaultCancelDoesntRetainObjects() throws Interr
 		                                                  .map(i -> retainedDetector.tracked(new DistinctDefaultCancel(i)))
 		                                                  .concatWith(Mono.error(new IllegalStateException("boom")))
 		                                                  .distinctUntilChanged()
-		                                                  .take(50);
+		                                                  .take(50, false);
 
 		StepVerifier.create(test)
 		            .expectNextCount(50)

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFinallyTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -92,7 +92,7 @@ public void normalError() {
 
 	@Test
 	public void normalCancel() {
-		StepVerifier.create(Flux.range(1, 10).hide().doFinally(this).take(5))
+		StepVerifier.create(Flux.range(1, 10).hide().doFinally(this).take(5, false))
 		            .expectNoFusionSupport()
 		            .expectNext(1, 2, 3, 4, 5)
 		            .expectComplete()
@@ -229,7 +229,7 @@ public void normalCancelConditional() {
 		                        .hide()
 		                        .doFinally(this)
 		                        .filter(i -> true)
-		                        .take(5))
+		                        .take(5, false))
 		            .expectNoFusionSupport()
 		            .expectNext(1, 2, 3, 4, 5)
 		            .expectComplete()

File: reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -143,7 +143,7 @@ public void recursiveCountdownLoopDepth() {
 	public void recursiveCountdownTake() {
 		StepVerifier.create(Flux.just(10)
 		                        .expand(countDown)
-		                        .take(5)
+		                        .take(5, false)
 		)
 		            .expectNext(10, 9, 8, 7, 6)
 		            .verifyComplete();
@@ -153,7 +153,7 @@ public void recursiveCountdownTake() {
 	public void recursiveCountdownTakeDepth() {
 		StepVerifier.create(Flux.just(10)
 		                        .expandDeep(countDown)
-		                        .take(5)
+		                        .take(5, false)
 		)
 		            .expectNext(10, 9, 8, 7, 6)
 		            .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -183,7 +183,7 @@ public void predicateErrorFused() {
 	public void take() {
 		StepVerifier.create(Flux.range(1, 10)
 		                        .filterWhen(v -> Mono.just(v % 2 == 0).hide())
-		                        .take(1))
+		                        .take(1, false))
 		            .expectNext(2)
 		            .verifyComplete();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxGenerateTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -437,7 +437,7 @@ public void contextTest() {
 		StepVerifier.create(Flux.generate(s -> s.next(s.currentContext()
 		                                               .get(AtomicInteger.class)
 		                                               .incrementAndGet()))
-		                        .take(10)
+		                        .take(10, false)
 		                        .contextWrite(ctx -> ctx.put(AtomicInteger.class,
 				                        new AtomicInteger())))
 		            .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

File: reactor-core/src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -58,7 +58,7 @@ public void normal() {
 			  .add(System.currentTimeMillis());
 
 			Flux.interval(Duration.ofMillis(100), Duration.ofMillis(100), exec)
-			    .take(5)
+			    .take(5, false)
 			    .map(v -> System.currentTimeMillis())
 			    .subscribe(ts);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxIterableTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -299,7 +299,7 @@ public Integer next() {
 
 		Flux.fromIterable(one)
 		    .publishOn(Schedulers.single())
-		    .take(10)
+		    .take(10, false)
 		    .doOnDiscard(Integer.class, i -> discardCount.incrementAndGet())
 		    .blockLast(Duration.ofSeconds(1));
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -173,7 +173,7 @@ void takeCancelsOperatorAndSource() {
 		                         .take(10, true)
 		                         .doOnCancel(() -> operatorCancelled.set(true))
 		                         .doOnRequest(operatorRequested::add)
-		                         .take(3);
+		                         .take(3, false);
 
 		StepVerifier.create(test)
 		            .expectNextCount(3)

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeComparingTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -564,7 +564,7 @@ void backpressure3() {
 	void take() {
 		new FluxMergeComparing<>(2, Comparator.naturalOrder(), false,
 				Flux.just(1, 3, 5, 7), Flux.just(2, 4, 6, 8))
-				.take(5)
+				.take(5, false)
 				.as(StepVerifier::create)
 				.expectNext(1, 2, 3, 4, 5)
 				.verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeOrderedTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2018-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -522,7 +522,7 @@ void backpressure3() {
 	void take() {
 		new FluxMergeComparing<>(2, Comparator.naturalOrder(), true,
 				Flux.just(1, 3, 5, 7), Flux.just(2, 4, 6, 8))
-				.take(5)
+				.take(5, false)
 				.as(StepVerifier::create)
 				.expectNext(1, 2, 3, 4, 5)
 				.verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -196,8 +196,8 @@ public void stepByStepRequesting() {
 		AtomicInteger sourceCancelledAt = new AtomicInteger(-1);
 
 		StepVerifier.withVirtualTime(() ->
-						Flux.interval(Duration.ofSeconds(1)) // lets emit 1 item per second; starting with zero
-						    .take(8)
+						Flux.interval(Duration.ofSeconds(1))
+						    .take(8, false)
 						    .doOnNext(v -> sourceProduced.incrementAndGet())
 						    .doOnCancel(() -> sourceCancelledAt.set(sourceProduced.get() - 1))
 						    .onBackpressureBuffer(2, discardedItems::add)

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -182,7 +182,7 @@ public void timeoutLimit() {
 	public void take() {
 		StepVerifier.create(Flux.range(1, 5)
 		                        .onBackpressureBuffer(Duration.ofMinutes(1), Integer.MAX_VALUE, v -> {})
-		                        .take(2))
+		                        .take(2, false))
 		            .expectNext(1, 2)
 		            .verifyComplete();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -404,7 +404,7 @@ public void gh870() throws Exception {
 //                    .doOnCancel(() -> System.out.println("cancel 2"))
 			    .publish(Function.identity())
 //                    .doOnCancel(() -> System.out.println("cancel 1"))
-			    .take(5))
+			    .take(5, false))
 	                .expectNextCount(5)
 	                .verifyComplete();
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -673,7 +673,7 @@ public void syncFusionFromInfiniteStreamAndTake() {
 				Flux.fromStream(Stream.iterate(0, i -> i + 1))
 				    .publish()
 				    .autoConnect()
-				    .take(10);
+				    .take(10, false);
 
 		StepVerifier.create(publish)
 		            .expectNextCount(10)

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -55,7 +55,7 @@ public void avoidUnexpectedDoubleCancel() {
 		test.subscribe(v -> {
 		}, e -> unexpectedCancellation.set(true));
 
-		StepVerifier.create(test.take(3))
+		StepVerifier.create(test.take(3, false))
 					.expectNextCount(3)
 					.verifyComplete();
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -120,7 +120,7 @@ public void repeatInfinite() {
 
 		Flux.range(1, 2)
 		    .repeat()
-		    .take(9)
+		    .take(9, false)
 		    .subscribe(ts);
 
 		ts.assertValues(1, 2, 1, 2, 1, 2, 1, 2, 1)

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -160,7 +160,7 @@ public void lateOtherEmptyCancelsSource() {
 		                           .doOnSubscribe(sub -> sourceSubscribed.set(true))
 		                           .doOnCancel(() -> sourceCancelled.set(true));
 
-		Flux<Integer> repeat = source.repeatWhen(other -> other.take(1));
+		Flux<Integer> repeat = source.repeatWhen(other -> other.take(1, false));
 
 		StepVerifier.create(repeat)
 		            .expectSubscription()
@@ -377,7 +377,7 @@ Flux<String> exponentialRepeatScenario2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRepeatWhen<Integer> test = new FluxRepeatWhen<>(parent, c -> c.take(3));
+		FluxRepeatWhen<Integer> test = new FluxRepeatWhen<>(parent, c -> c.take(3, false));
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -434,7 +434,7 @@ public void multipleEarlySubscribersPropagateTheirLateRequests() {
 				    .doOnRequest(requests::add)
 				    .replay(7);
 
-		replay.take(13).subscribe(fiveThenEightSubscriber);
+		replay.take(13, false).subscribe(fiveThenEightSubscriber);
 		replay.subscribe(sevenThenEightSubscriber);
 		replay.connect();
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -103,7 +103,7 @@ public void retryInfinite() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		source.retry()
-		      .take(10)
+		      .take(10, false)
 		      .subscribe(ts);
 
 		ts.assertValues(1, 2, 3, 1, 2, 3, 1, 2, 3, 1)

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -339,7 +339,7 @@ public void lateOtherEmptyCancelsSourceAndCompletes() {
 		                           .doOnSubscribe(sub -> sourceSubscribed.set(true))
 		                           .doOnCancel(() -> sourceCancelled.set(true));
 
-		Flux<Integer> retry = source.retryWhen(Retry.from(other -> other.take(1)));
+		Flux<Integer> retry = source.retryWhen(Retry.from(other -> other.take(1, false)));
 
 		StepVerifier.create(retry)
 		            .expectSubscription()
@@ -1027,7 +1027,7 @@ public void gh1978() {
 						.jitter(0d)
 						.transientErrors(true)
 				)
-				      .take(stopAfterCycles * elementPerCycle)
+				      .take(stopAfterCycles * elementPerCycle, false)
 				      .elapsed()
 				      .map(Tuple2::getT1)
 				      .doOnNext(pause -> { if (pause > 500) pauses.add(pause / 1000); })

File: reactor-core/src/test/java/reactor/core/publisher/FluxStreamTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -478,7 +478,7 @@ void infiniteStreamDoesntHangDiscardFused() {
 
 		Flux.fromStream(stream)
 		    .publishOn(Schedulers.single())
-		    .take(10)
+		    .take(10, false)
 		    .doOnDiscard(Integer.class, i -> {})
 		    .blockLast(Duration.ofSeconds(1));
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2018-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -823,7 +823,7 @@ public void shouldBeAbleToBeCancelledProperly2() {
                                                   .switchOnFirst((first, innerFlux) ->
                                                       innerFlux
                                                           .map(String::valueOf)
-                                                          .take(1)
+                                                          .take(1, false)
                                                   );
 
         publisher.next(1);
@@ -848,7 +848,7 @@ public void shouldBeAbleToBeCancelledProperly3() {
                                                           innerFlux
                                                                   .map(String::valueOf)
                                                   )
-                                                  .take(1);
+                                                  .take(1, false);
 
         publisher.next(1);
         publisher.next(2);

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectListTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -207,7 +207,7 @@ public void discardOnError() {
 	@Test
 	public void discardOnCancel() {
 		Mono<List<Long>> test = Flux.interval(Duration.ofMillis(100))
-		                            .take(10)
+		                            .take(10, false)
 		                            .collectList();
 
 		StepVerifier.create(test)

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -256,7 +256,7 @@ public void discardListElementsOnError() {
 	public void discardListElementsOnCancel() {
 		StepVerifier.withVirtualTime(() ->
 				Flux.interval(Duration.ofMillis(100))
-				    .take(10)
+				    .take(10, false)
 				    .collect(ArrayList::new, List::add)
 		)
 		            .expectSubscription()
@@ -300,7 +300,7 @@ public void discardWholeArrayOnCancel() {
 
 		StepVerifier.withVirtualTime(() ->
 				Flux.interval(Duration.ofMillis(100))
-				    .take(10)
+				    .take(10, false)
 				    .collect(() -> new Object[4], (container, element) -> container[index.getAndIncrement()] = element)
 				    .doOnDiscard(Object.class, discarded::add))
 		            .expectSubscription()

File: reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -139,7 +139,7 @@ public void recursiveCountdownLoopDepth() {
 	public void recursiveCountdownTake() {
 		StepVerifier.create(Mono.just(10)
 		                        .expand(countDown)
-		                        .take(5)
+		                        .take(5, false)
 		)
 		            .expectNext(10, 9, 8, 7, 6)
 		            .verifyComplete();
@@ -149,7 +149,7 @@ public void recursiveCountdownTake() {
 	public void recursiveCountdownTakeDepth() {
 		StepVerifier.create(Mono.just(10)
 		                        .expandDeep(countDown)
-		                        .take(5)
+		                        .take(5, false)
 		)
 		            .expectNext(10, 9, 8, 7, 6)
 		            .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/MonoRepeatTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -129,7 +129,7 @@ public void repeatInfinite() {
 		AtomicInteger i = new AtomicInteger();
 		Mono.fromCallable(i::incrementAndGet)
 		    .repeat()
-		    .take(9)
+		    .take(9, false)
 		    .subscribe(ts);
 
 		ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9)

File: reactor-core/src/test/java/reactor/core/publisher/MonoStreamCollectorTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -211,7 +211,7 @@ public void discardIntermediateListElementsOnCancel() {
 
 		StepVerifier.withVirtualTime(() ->
 				Flux.interval(Duration.ofMillis(100))
-				    .take(10)
+				    .take(10, false)
 				    .collect(collector)
 		)
 		            .expectSubscription()
@@ -273,7 +273,7 @@ public void discardIntermediateMapOnCancel() {
 
 		StepVerifier.withVirtualTime(() ->
 				Flux.interval(Duration.ofMillis(100))
-				    .take(10)
+				    .take(10, false)
 				    .collect(collector)
 				    .doOnDiscard(Object.class, discarded::add))
 		            .expectSubscription()

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -754,7 +754,7 @@ public void testPeekCancel() {
 	                .doOnError(e -> errorCount.increment())
 	                .doOnTerminate(terminateCount::increment)
 	                .doAfterTerminate(afterTerminateCount::increment)
-	                .sequential().take(4).subscribe();
+	                .sequential().take(4, false).subscribe();
 
 		assertThat(signals).as("signals").hasSize(4); //2x2 onNext (+ 2 non-represented cancels)
 		assertThat(subscribeCount.longValue()).as("subscribe").isEqualTo(2); //1 per rail

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -115,7 +115,7 @@ void testLeakWithRetryWhenImmediatelyCancelled() throws InterruptedException {
 			.doFinally(sig -> latch.countDown())
 			.publishOn(Schedulers.single())
 			.doFinally(sig -> latch.countDown())
-			.retryWhen(Retry.from(p -> p.take(3)))
+			.retryWhen(Retry.from(p -> p.take(3, false)))
 			.doFinally(sig -> latch.countDown())
 			.cancelOn(Schedulers.parallel())
 			.doOnDiscard(AtomicInteger.class, i -> {

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1469,7 +1469,7 @@ public void testThrowWithoutOnErrorShowsUpInSchedulerHandler() {
 
 		try {
 			Flux.interval(Duration.ofMillis(100))
-			    .take(1)
+			    .take(1, false)
 			    .publishOn(Schedulers.parallel())
 			    .doOnCancel(latch::countDown)
 			    .subscribe(i -> {

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -67,8 +67,8 @@ public void sampleTest() throws Exception {
 		         .flatMap(s -> s.groupBy(w -> w)
 		                       .flatMap(w -> w.count().map(c -> Tuples.of(w.key(), c)))
 		                       .collectSortedList((a, b) -> -a.getT2().compareTo(b.getT2()))
-		                        .flatMapMany(Flux::fromIterable)
-		                       .take(10)
+		                       .flatMapMany(Flux::fromIterable)
+		                       .take(10, false)
 		                       .doAfterTerminate(() -> LOG.info("------------------------ window terminated" +
 						      "----------------------"))
 			)

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/FluxMetricsFuseableTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2018-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -285,7 +285,7 @@ public void onNextTimerCountsFuseable() {
 
 		Flux<Integer> source2 = Flux.range(1, 10);
 		new FluxMetricsFuseable<>(source2)
-		    .take(3)
+		    .take(3, false)
 		    .blockLast();
 
 		assertThat(nextMeter.count()).isEqualTo(126L);

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/FluxMetricsTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2018-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -182,7 +182,7 @@ public void onNextTimerCounts() {
 		                            .hide();
 
 		new FluxMetrics<>(source2)
-				.take(3)
+				.take(3, false)
 				.blockLast();
 
 		assertThat(nextMeter.count()).isEqualTo(126L);
@@ -366,7 +366,7 @@ public void subscribeToCancel() {
 		                           .hide();
 
 		new FluxMetrics<>(source)
-				.take(1)
+				.take(1, false)
 				.blockLast();
 
 		Timer stcCompleteTimer = registry.find(REACTOR_DEFAULT_NAME + METER_FLOW_DURATION)

File: reactor-test/src/test/java/reactor/test/DefaultContextExpectationsTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -74,13 +74,13 @@ void tearDown() {
 
 	@Test
 	public void contextAccessibleLastInChain() {
-		assertContextExpectation(s -> s.take(3).contextWrite(Context.of("a", "b")),
+		assertContextExpectation(s -> s.take(3, false).contextWrite(Context.of("a", "b")),
 				e -> e, 3);
 	}
 
 	@Test
 	public void contextAccessibleFirstInChain() {
-		assertContextExpectation(s -> s.contextWrite(Context.of("a", "b")).take(3),
+		assertContextExpectation(s -> s.contextWrite(Context.of("a", "b")).take(3, false),
 				e -> e, 3);
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelayUntilTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -210,7 +210,7 @@ public void immediateCancel() {
 	@Test
 	public void isAlias() {
 		assertThat(Flux.range(1, 10).delayUntil(a -> Mono.empty()))
-				.isInstanceOf(FluxConcatMap.class);
+				.isInstanceOf(FluxConcatMapNoPrefetch.class);
 	}
 
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowWhenTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -306,7 +306,7 @@ Flux<List<Integer>> scenario_windowWillSubdivideAnInputFluxOverlapTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
 		           .delayElements(Duration.ofMillis(99))
 		           .window(Duration.ofMillis(300), Duration.ofMillis(200))
-		           .concatMap(Flux::buffer);
+		           .concatMap(Flux::buffer, 1);
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/scheduler/BoundedElasticScheduler.java
Patch:
@@ -70,6 +70,7 @@ final class BoundedElasticScheduler implements Scheduler, Scannable {
 
 	static final int DEFAULT_TTL_SECONDS = 60;
 
+	static final AtomicLong COUNTER = new AtomicLong();
 	static final AtomicLong EVICTOR_COUNTER = new AtomicLong();
 
 	static final ThreadFactory EVICTOR_FACTORY = r -> {

File: reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2017-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -431,7 +431,7 @@ void subscriberIncrementShouldBeVisibleBeforeCompletionPropagated() {
 		cold.next("value");
 		final int timeout = 2;
 
-		StepVerifier.create(cold.mono().subscribeOn(Schedulers.elastic()))
+		StepVerifier.create(cold.mono().subscribeOn(Schedulers.boundedElastic()))
 				.expectSubscription()
 				.expectNext("value")
 				.expectComplete()

File: reactor-core/src/main/java/reactor/core/scheduler/ReactorBlockHoundIntegration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2019-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,6 +38,7 @@ public void applyTo(BlockHound.Builder builder) {
 
         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName() + "$DelayedWorkQueue", "offer");
         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName() + "$DelayedWorkQueue", "take");
+        builder.allowBlockingCallsInside(BoundedElasticScheduler.class.getName() + "$BoundedScheduledExecutorService", "ensureQueueCapacity");
 
         // Calls ScheduledFutureTask#cancel that may short park in DelayedWorkQueue#remove for getting a lock
         builder.allowBlockingCallsInside(SchedulerTask.class.getName(), "dispose");

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2022 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -290,6 +290,7 @@ void slowPath(long n) {
 				if (n == e) {
 					state = s;
 					n = REQUESTED.addAndGet(this, -e);
+					e = 0L;
 					if (n == 0L) {
 						return;
 					}

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3339,7 +3339,7 @@ public final Flux<T> cancelOn(Scheduler scheduler) {
 	 * creation.
 	 * <p>
 	 * It should be placed towards the end of the reactive chain, as errors
-	 * triggered downstream of it cannot be observed and augmented with the backtrace.
+	 * triggered downstream of it cannot be observed and augmented with the traceback.
 	 * <p>
 	 * The traceback is attached to the error as a {@link Throwable#getSuppressed() suppressed exception}.
 	 * As such, if the error is a {@link Exceptions#isMultiple(Throwable) composite one}, the traceback

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -307,6 +307,7 @@ public void innerError(Throwable e) {
 						e = Exceptions.terminate(ERROR, this);
 						if (e != TERMINATED) {
 							actual.onError(e);
+							Operators.onDiscardQueueWithClear(queue, this.ctx, null);
 						}
 					}
 				}
@@ -413,6 +414,7 @@ void drain() {
 									if (e_ != null) {
 										actual.onError(Operators.onOperatorError(s, e, v,
 												this.ctx));
+										Operators.onDiscardQueueWithClear(queue, this.ctx, null);
 										return;
 									}
 									else {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3113,7 +3113,7 @@ public final <R> Mono<R> flatMap(Function<? super T, ? extends Mono<? extends R>
 	 * <img class="marble" src="doc-files/marbles/flatMapMany.svg" alt="">
 	 *
 	 * @param mapper the
-	 * {@link Function} to produce a sequence of R from the the eventual passed {@link Subscriber#onNext}
+	 * {@link Function} to produce a sequence of R from the eventual passed {@link Subscriber#onNext}
 	 * @param <R> the merged sequence type
 	 *
 	 * @return a new {@link Flux} as the sequence is not guaranteed to be single at most

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -16,6 +16,7 @@
 
 package reactor.core.publisher;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -257,7 +258,8 @@ String operatorAssemblyInformation() {
 		}
 	}
 
-	static final class ObservedAtInformationNode {
+	static final class ObservedAtInformationNode implements Serializable {
+		private static final long serialVersionUID = 1L;
 
 		final int id;
 		final String operator;

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java
Patch:
@@ -282,7 +282,7 @@ static String resolveName(Publisher<?> source) {
 			}
 		}
 		else {
-			log.warn("Attempting to activate metrics but the upstream is not Scannable. " + "You might want to use `name()` (and optionally `tags()`) right before `metrics()`");
+			log.warn("Attempting to activate metrics but the upstream is not Scannable. You might want to use `name()` (and optionally `tags()`) right before `metrics()`");
 			return REACTOR_DEFAULT_NAME;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -69,7 +69,7 @@ public void connect(Consumer<? super Disposable> cancelSupport) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
-		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -58,7 +58,7 @@ public T call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -93,7 +93,7 @@ public T call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -62,7 +62,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -20,7 +20,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.core.publisher.FluxOnAssembly.AssemblyLightSnapshot;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 import reactor.util.annotation.Nullable;
 
@@ -96,7 +95,7 @@ public void subscribe(CoreSubscriber<? super T>[] subscribers) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
-		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.ACTUAL_METADATA) return !stacktrace.isCheckpoint;
 		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;

File: reactor-tools/src/main/java/reactor/tools/agent/CallSiteInfoAddingMethodVisitor.java
Patch:
@@ -70,7 +70,7 @@ static boolean isCorePublisher(String className) {
             String currentSource,
             AtomicBoolean changed
     ) {
-        super(Opcodes.ASM7, visitor);
+        super(Opcodes.ASM9, visitor);
         this.currentMethod = currentMethod;
         this.currentClassName = currentClassName;
         this.currentSource = currentSource;

File: reactor-tools/src/main/java/reactor/tools/agent/ReactorDebugClassVisitor.java
Patch:
@@ -32,7 +32,7 @@ class ReactorDebugClassVisitor extends ClassVisitor {
 	private String currentSource;
 
 	ReactorDebugClassVisitor(ClassVisitor classVisitor, AtomicBoolean changed) {
-		super(Opcodes.ASM7, classVisitor);
+		super(Opcodes.ASM9, classVisitor);
 		this.changed = changed;
 	}
 

File: reactor-tools/src/main/java/reactor/tools/agent/ReturnHandlingMethodVisitor.java
Patch:
@@ -64,7 +64,7 @@ class ReturnHandlingMethodVisitor extends MethodVisitor {
             String currentSource,
             AtomicBoolean changed
     ) {
-        super(Opcodes.ASM7, visitor);
+        super(Opcodes.ASM9, visitor);
         this.changed = changed;
         this.currentClassName = currentClassName;
         this.currentMethod = currentMethod;

File: reactor-core/src/main/java/reactor/core/publisher/Signal.java
Patch:
@@ -261,7 +261,7 @@ default boolean isOnError() {
 	/**
 	 * Indicates whether this signal represents an {@code onComplete} event.
 	 *
-	 * @return a boolean indicating whether this signal represents an {@code onSubscribe}
+	 * @return a boolean indicating whether this signal represents an {@code onComplete}
 	 * event
 	 */
 	default boolean isOnComplete() {

File: reactor-core/src/test/java/reactor/guide/GuideDebuggingExtraTests.java
Patch:
@@ -44,7 +44,7 @@ public void debuggingActivatedWithDeepTraceback() {
 
 		String debugStack = sw.toString();
 
-		assertThat(debugStack.substring(0, debugStack.indexOf("Stack trace:")))
+		assertThat(debugStack.substring(0, debugStack.indexOf("Original Stack Trace:")))
 				.endsWith("Error has been observed at the following site(s):\n"
 						+ "\t*________Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)\n"
 						+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)\n"

File: reactor-core/src/main/java/reactor/core/scheduler/ReactorThreadFactory.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.function.BiConsumer;
 import java.util.function.Supplier;
 
-import org.jetbrains.annotations.NotNull;
+import reactor.util.annotation.NonNull;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -55,7 +55,7 @@ class ReactorThreadFactory implements ThreadFactory,
 	}
 
 	@Override
-	public final Thread newThread(@NotNull Runnable runnable) {
+	public final Thread newThread(@NonNull Runnable runnable) {
 		String newThreadName = name + "-" + counterReference.incrementAndGet();
 		Thread t = rejectBlocking
 				? new NonBlockingThread(runnable, newThreadName)

File: reactor-core/src/test/java/reactor/core/publisher/FluxIterableTest.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.assertj.core.api.InstanceOfAssertFactories;
-import org.jetbrains.annotations.NotNull;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import org.mockito.Mockito;
@@ -43,6 +42,7 @@
 import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.util.annotation.NonNull;
 import reactor.util.context.Context;
 import reactor.util.function.Tuples;
 
@@ -266,7 +266,7 @@ class Generator implements Iterable<Integer> {
 				this.seed = seed;
 			}
 
-			@NotNull
+			@NonNull
 			@Override
 			public Iterator<Integer> iterator() {
 				return new Iterator<Integer>() {

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -56,7 +56,7 @@ final class ConnectableFluxOnAssembly<T> extends InternalConnectableFluxOperator
 
 	@Override
 	public final CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) {
-		return FluxOnAssembly.wrapSubscriber(actual, source, stacktrace);
+		return FluxOnAssembly.wrapSubscriber(actual, source, this, stacktrace);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -47,7 +47,7 @@ final class FluxCallableOnAssembly<T> extends InternalFluxOperator<T, T>
 
 	@Override
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) {
-		return FluxOnAssembly.wrapSubscriber(actual, source, stacktrace);
+		return FluxOnAssembly.wrapSubscriber(actual, source, this, stacktrace);
 	}
 
 	@SuppressWarnings("unchecked")

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -76,10 +76,11 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 					cs = (Fuseable.ConditionalSubscriber<? super T>) actual;
 			return new FluxOnAssembly.OnAssemblyConditionalSubscriber<>(cs,
 					stacktrace,
-					source);
+					source,
+					this);
 		}
 		else {
-			return new FluxOnAssembly.OnAssemblySubscriber<>(actual, stacktrace, source);
+			return new FluxOnAssembly.OnAssemblySubscriber<>(actual, stacktrace, source, this);
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -53,10 +53,10 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 		if (actual instanceof ConditionalSubscriber) {
 			@SuppressWarnings("unchecked") ConditionalSubscriber<? super T> cs =
 					(ConditionalSubscriber<? super T>) actual;
-			return new FluxOnAssembly.OnAssemblyConditionalSubscriber<>(cs, stacktrace, source);
+			return new FluxOnAssembly.OnAssemblyConditionalSubscriber<>(cs, stacktrace, source, this);
 		}
 		else {
-			return new FluxOnAssembly.OnAssemblySubscriber<>(actual, stacktrace, source);
+			return new FluxOnAssembly.OnAssemblySubscriber<>(actual, stacktrace, source, this);
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -79,10 +79,11 @@ public void subscribe(CoreSubscriber<? super T>[] subscribers) {
 						super T>) s;
 				s = new FluxOnAssembly.OnAssemblyConditionalSubscriber<>(cs,
 						stacktrace,
-						source);
+						source,
+						this);
 			}
 			else {
-				s = new FluxOnAssembly.OnAssemblySubscriber<>(s, stacktrace, source);
+				s = new FluxOnAssembly.OnAssemblySubscriber<>(s, stacktrace, source, this);
 			}
 			parents[i] = s;
 		}

File: reactor-core/src/test/java/reactor/guide/GuideDebuggingExtraTests.java
Patch:
@@ -46,7 +46,7 @@ public void debuggingActivatedWithDeepTraceback() {
 
 		assertThat(debugStack.substring(0, debugStack.indexOf("Stack trace:")))
 				.endsWith("Error has been observed at the following site(s):\n"
-						+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)\n"
+						+ "\t*________Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)\n"
 						+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)\n"
 						+ "\t|_    Flux.filter ⇢ at reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)\n"
 						+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:39)\n"

File: reactor-tools/src/test/java/reactor/tools/agent/ReactorDebugAgentTest.java
Patch:
@@ -119,11 +119,11 @@ public void stackTrace() {
 		}
 
 		assertThat(lines.next())
-				.as("first backtrace line")
-				.endsWith("|_ Mono.map ⇢ at reactor.tools.agent.ReactorDebugAgentTest.stackTrace(ReactorDebugAgentTest.java:" + (baseline + 2) + ")");
+				.as("first traceback line")
+				.endsWith("*__Mono.map ⇢ at reactor.tools.agent.ReactorDebugAgentTest.stackTrace(ReactorDebugAgentTest.java:" + (baseline + 2) + ")");
 
 		assertThat(lines.next())
-				.as("second backtrace line")
+				.as("second traceback line")
 				.endsWith("|_          ⇢ at reactor.tools.agent.ReactorDebugAgentTest.methodReturningMono(ReactorDebugAgentTest.java:" + (methodReturningMonoBaseline + 2) + ")");
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3145,8 +3145,7 @@ public final <R> Flux<R> flatMapMany(Function<? super T, ? extends Publisher<? e
 
 	/**
 	 * Transform the item emitted by this {@link Mono} into {@link Iterable}, then forward
-	 * its elements into the returned {@link Flux}. The prefetch argument allows to
-	 * give an arbitrary prefetch size to the inner {@link Iterable}.
+	 * its elements into the returned {@link Flux}.
 	 * The {@link Iterable#iterator()} method will be called at least once and at most twice.
 	 *
 	 * <p>

File: reactor-core/src/jcstress/java/reactor/core/publisher/FluxSwitchOnFirstStressTest.java
Patch:
@@ -94,8 +94,6 @@ public void arbiter(LLLLL_Result result) {
 	}
 
 	@JCStressTest
-	//FIXME investigate this result, see https://github.com/reactor/reactor-core/issues/2789
-	@Outcome(id = { "0, 0, 1, 1, 1, 1, 0, 0, 1" }, expect = ACCEPTABLE_INTERESTING, desc = "MUST INVESTIGATE")
 	@Outcome(id = {
 			"0, 0, 1, 2, 2, 0, 1, 1, 0"}, expect = ACCEPTABLE, desc = "Inbound got second request, delivered onNext('value') and delivered onComplete() before cancellation")
 	@Outcome(id = {

File: buildSrc/src/main/java/io/reactor/gradle/JavaConventions.java
Patch:
@@ -74,7 +74,7 @@ private void applyJavaConvention(Project project) {
 
 		if (JavaVersion.current().isJava8Compatible()) {
 			project.getTasks().withType(JavaCompile.class, t -> {
-				if (t.getName().equalsIgnoreCase("testcompile")) {
+				if (t.getName().endsWith("TestJava")) {
 					List<String> args = new ArrayList<>(t.getOptions().getCompilerArgs());
 					args.add("-parameters");
 					t.getOptions().setCompilerArgs(args);

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferStrategyTest.java
Patch:
@@ -25,18 +25,17 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
 import org.reactivestreams.Subscription;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import reactor.test.ParameterizedTestWithName;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.test.publisher.TestPublisher;
 
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.*;
 import static reactor.core.publisher.BufferOverflowStrategy.*;
 import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
@@ -466,7 +465,7 @@ public void fluxOnBackpressureBufferStrategyNoCallback() {
 		assertThat(hookCapturedError).as("unexpected hookCapturedError").isNull();
 	}
 
-	@ParameterizedTest
+	@ParameterizedTestWithName
 	@ValueSource(ints = {-1, 0})
 	void fluxOnBackpressureBufferStrategyRequiresPositiveMaxSize(int maxSize) {
 		assertThatIllegalArgumentException()

File: reactor-core/src/test/java/reactor/core/publisher/FluxStreamTest.java
Patch:
@@ -32,13 +32,13 @@
 
 import org.assertj.core.api.InstanceOfAssertFactories;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
+import reactor.test.ParameterizedTestWithName;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -488,7 +488,7 @@ void infiniteStreamDoesntHangDiscardFused() {
 	}
 
 	//see https://github.com/reactor/reactor-core/issues/2761
-	@ParameterizedTest
+	@ParameterizedTestWithName
 	@ValueSource(booleans = { false, true })
 	void fromStreamWithFailingIteratorNextInFusion(boolean conditionalSubscriber) throws InterruptedException {
 		CountDownLatch thrown = new CountDownLatch(1);

File: reactor-core/src/test/java/reactor/core/publisher/FluxGroupByTest.java
Patch:
@@ -74,7 +74,7 @@ void performanceOfContinuouslyCancellingGroups() throws Exception {
 
 		latch.await();
 		assertThat(upstream).as("upstream and downstream consistent").hasValue(downstream.get());
-		assertThat(downstream).as("order of magnitude").hasValueGreaterThan(9_999);
+		assertThat(downstream).as("order of magnitude").hasValueGreaterThan(30_000);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java
Patch:
@@ -672,7 +672,7 @@ public final void subscribe(CoreSubscriber<? super T> inboundSubscriber) {
 			inboundSubscriber.onSubscribe(this);
 
 			previousState = markInboundSubscriberSet(this);
-			if (hasInboundCancelled(previousState) && hasInboundTerminated(previousState)) {
+			if (hasInboundCancelled(previousState) && hasOutboundTerminated(previousState) && !hasInboundTerminated(previousState)) {
 				inboundSubscriber.onError(new CancellationException("FluxSwitchOnFirst has already been cancelled"));
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/Sinks.java
Patch:
@@ -564,7 +564,7 @@ public interface MulticastReplaySpec {
 		 *     Older elements are discarded.</li>
 		 * </ul>
 		 *
-		 * @param historySize maximum number of elements able to replayed
+		 * @param historySize maximum number of elements able to replayed, strictly positive
 		 */
 		<T> Sinks.Many<T> limit(int historySize);
 
@@ -612,7 +612,7 @@ public interface MulticastReplaySpec {
 		 * </ul>
 		 * Note: Age is checked when a signal occurs, not using a background task.
 		 *
-		 * @param historySize maximum number of elements able to replayed
+		 * @param historySize maximum number of elements able to replayed, strictly positive
 		 * @param maxAge maximum retention time for elements to be retained
 		 */
 		<T> Sinks.Many<T> limit(int historySize, Duration maxAge);
@@ -629,7 +629,7 @@ public interface MulticastReplaySpec {
 		 * </ul>
 		 * Note: Age is checked when a signal occurs, not using a background task.
 		 *
-		 * @param historySize maximum number of elements able to replayed
+		 * @param historySize maximum number of elements able to replayed, strictly positive
 		 * @param maxAge maximum retention time for elements to be retained
 		 * @param scheduler a {@link Scheduler} to derive the time from
 		 */

File: reactor-core/src/main/java/reactor/core/publisher/InternalOneSink.java
Patch:
@@ -49,7 +49,7 @@ default void emitValue(@Nullable T value, Sinks.EmitFailureHandler failureHandle
 				case FAIL_OVERFLOW:
 					Operators.onDiscard(value, currentContext());
 					//the emitError will onErrorDropped if already terminated
-					emitError(Exceptions.failWithOverflow("Backpressure overflow during Sinks.Many#emitNext"),
+					emitError(Exceptions.failWithOverflow("Backpressure overflow during Sinks.One#emitValue"),
 							failureHandler);
 					return;
 				case FAIL_CANCELLED:

File: reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java
Patch:
@@ -108,8 +108,7 @@ public <T> Empty<T> empty() {
 
 		@Override
 		public <T> One<T> one() {
-			final NextProcessor<T> original = new NextProcessor<>(null);
-			return wrapOne(original);
+			return wrapOne(new SinkOneMulticast<>());
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/publisher/SinkEmptyMulticastTest.java
Patch:
@@ -137,6 +137,7 @@ void scanOperator() {
 		Sinks.Empty<Integer> sinkTerminated = new SinkEmptyMulticast<>();
 
 		assertThat(sinkTerminated.scan(Scannable.Attr.TERMINATED)).as("not yet terminated").isFalse();
+		assertThat(sinkTerminated.scan(Scannable.Attr.RUN_STYLE)).as("run_style").isSameAs(Scannable.Attr.RunStyle.SYNC);
 
 		sinkTerminated.tryEmitError(new IllegalStateException("boom")).orThrow();
 

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -932,6 +932,7 @@ public static <T, D> Mono<T> using(Callable<? extends D> resourceSupplier,
 	 * closure terminates (with onComplete, onError or cancel)
 	 * @param <T> the type of elements emitted by the resource closure, and thus the main sequence
 	 * @param <D> the type of the resource object
+	 *
 	 * @return a new {@link Mono} built around a "transactional" resource, with deferred emission until the
 	 * asynchronous cleanup sequence completes
 	 */
@@ -990,6 +991,7 @@ public static <T, D> Mono<T> usingWhen(Publisher<D> resourceSupplier,
 	 * When {@code null}, the {@code asyncComplete} path is used instead.
 	 * @param <T> the type of elements emitted by the resource closure, and thus the main sequence
 	 * @param <D> the type of the resource object
+	 *
 	 * @return a new {@link Mono} built around a "transactional" resource, with several
 	 * termination path triggering asynchronous cleanup sequences
 	 *
@@ -3024,6 +3026,7 @@ public final Mono<T> filter(final Predicate<? super T> tester) {
 	 *
 	 * @param asyncPredicate the function generating a {@link Publisher} of {@link Boolean}
 	 * to filter the Mono with
+	 *
 	 * @return a filtered {@link Mono}
 	 */
 	public final Mono<T> filterWhen(Function<? super T, ? extends Publisher<Boolean>> asyncPredicate) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -234,6 +234,7 @@ public void onNext(T t) {
 				}
 				g.onComplete();
 				newWindowDeferred();
+				s.request(1);
 			}
 			else if (mode == Mode.UNTIL_CUT_BEFORE && match) {
 				g.onComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxGroupByTest.java
Patch:
@@ -74,7 +74,7 @@ void performanceOfContinuouslyCancellingGroups() throws Exception {
 
 		latch.await();
 		assertThat(upstream).as("upstream and downstream consistent").hasValue(downstream.get());
-		assertThat(downstream).as("order of magnitude").hasValueGreaterThan(49_999);
+		assertThat(downstream).as("order of magnitude").hasValueGreaterThan(9_999);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -313,7 +313,7 @@ void groupTerminated(K key) {
 			else if (groupRemaining == 1) {
 				//there is an "extra" group count for the global cancellation, so the operator as a whole is still active
 				//we want at least one more group
-				s.request(1);
+				s.request(Operators.unboundedOrPrefetch(prefetch));
 			}
 		}
 

File: reactor-core/src/jcstress/java/reactor/core/publisher/ConditionalStressSubscriber.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.function.Predicate;

File: reactor-core/src/jcstress/java/reactor/core/publisher/FluxConcatMapNoPrefetchStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import org.openjdk.jcstress.annotations.Actor;

File: reactor-core/src/jcstress/java/reactor/core/publisher/FluxSwitchMapStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import org.openjdk.jcstress.annotations.Actor;

File: reactor-core/src/jcstress/java/reactor/core/publisher/SinkEmptySerializedStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import org.openjdk.jcstress.annotations.Actor;

File: reactor-core/src/jcstress/java/reactor/core/publisher/SinkManySerializedStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.concurrent.atomic.AtomicInteger;

File: reactor-core/src/jcstress/java/reactor/core/publisher/SinkOneSerializedStressTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/ContextHolder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2015-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import reactor.util.context.Context;

File: reactor-core/src/main/java/reactor/core/publisher/DirectInnerContainer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.time.Duration;

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.Objects;

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstWithSignal.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.Iterator;

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstWithValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import org.reactivestreams.Publisher;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMapNoPrefetch.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/FluxTimed.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/InternalEmptySink.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/InternalManySink.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/InternalOneSink.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.time.Duration;

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirstWithSignal.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.Iterator;

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirstWithValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import org.reactivestreams.Publisher;

File: reactor-core/src/main/java/reactor/core/publisher/SinkEmptyMulticast.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/SinkEmptySerialized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/SinkManySerialized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/SinkOneSerialized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/Sinks.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/Timed.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/UnicastManySinkNoBackpressure.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.Objects;

File: reactor-core/src/main/java/reactor/util/context/ContextView.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/FuseableTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/AbstractFluxConcatMapTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapNoPrefetchTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/FluxFirstWithValueTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.time.Duration;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMapNotNullTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2016-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimedTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/InternalManySinkTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/InternalOneSinkTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/MonoFirstWithSignalTest.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.time.Duration;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFirstWithValueTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.time.Duration;

File: reactor-core/src/test/java/reactor/core/publisher/MonoMapNotNullTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimedTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/SinkEmptyMulticastTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/SinkManySerializedTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/SinksTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/test/java/reactor/core/publisher/UnicastManySinkNoBackpressureTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.time.Duration;

File: reactor-core/src/test/java/reactor/util/context/ContextViewTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 VMware Inc. or its affiliates, All Rights Reserved.
+ * Copyright (c) 2020-2021 VMware Inc. or its affiliates, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.test.util;
 
 import java.util.ArrayList;

File: reactor-core/src/blockHoundTest/java/reactor/core/scheduler/ReactorBlockHoundIntegrationTest.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.scheduler;
 
 import java.time.Duration;

File: reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.List;

File: reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscription.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.concurrent.atomic.AtomicBoolean;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelDoOnEach.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.publisher;
 
 import java.util.function.BiConsumer;

File: reactor-core/src/main/java/reactor/core/scheduler/ReactorBlockHoundIntegration.java
Patch:
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package reactor.core.scheduler;
 
 import reactor.blockhound.BlockHound;

File: reactor-core/src/main/java/reactor/util/context/ContextView.java
Patch:
@@ -32,6 +32,7 @@
  * a write API that returns new instances on each write.
  *
  * @author Simon Baslé
+ * @since 3.4.0
  */
 public interface ContextView {
 

File: reactor-core/src/test/java/reactor/core/publisher/HooksTest.java
Patch:
@@ -767,7 +767,7 @@ public void onNextDroppedFailReplaces() {
 			Hooks.onNextDroppedFail();
 
 			assertThatExceptionOfType(RuntimeException.class)
-					.isThrownBy(() -> Flux.from(p).take(2).subscribe(seen::add))
+					.isThrownBy(() -> Flux.from(p).take(2, false).subscribe(seen::add))
 					.isInstanceOf(RuntimeException.class)
 					.matches(Exceptions::isCancel);
 

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -396,7 +396,7 @@ final void drain() {
 					//for the benefit of tasks that call `now()`
 					// if scheduled time is 0 (immediate) use current virtual time
 					nanoTime = current.time == 0 ? nanoTime : current.time;
-					queue.remove();
+					queue.poll();
 
 					// Only execute if not unsubscribed
 					if (!current.scheduler.shutdown) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetry.java
Patch:
@@ -36,7 +36,7 @@ final class FluxRetry<T> extends InternalFluxOperator<T, T> {
 	FluxRetry(Flux<? extends T> source, long times) {
 		super(source);
 		if (times < 0L) {
-			throw new IllegalArgumentException("times >= 0 required");
+			throw new IllegalArgumentException("times >= 0 required but it was " + times);
 		}
 		this.times = times;
 	}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLiftTest.java
Patch:
@@ -26,7 +26,7 @@ public class ParallelLiftTest {
 	@Test
 	public void parallelism() {
 		ParallelFlux<Integer> source = Flux.range(1, 4).parallel(3);
-		ParallelLift<Integer, Integer> test = new ParallelLift<>(source, (sc, su) -> su);
+		ParallelLift<Integer, Integer> test = new ParallelLift<>(source, Operators.LiftFunction.liftPublisher(null, (sc, su) -> su));
 
 		assertThat(test.parallelism())
 				.isEqualTo(3)
@@ -36,7 +36,7 @@ public void parallelism() {
 	@Test
 	public void scanOperator() throws Exception {
 		ParallelFlux<Integer> source = Flux.range(1, 4).parallel(3);
-		ParallelLift<Integer, Integer> test = new ParallelLift<>(source, (sc, su) -> su);
+		ParallelLift<Integer, Integer> test = new ParallelLift<>(source, Operators.LiftFunction.liftPublisher(null, (sc, su) -> su));
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH))

File: reactor-core/src/main/java/reactor/core/publisher/MonoMaterialize.java
Patch:
@@ -139,8 +139,8 @@ boolean drain() {
 
 		@Override
 		public void request(long l) {
-			if (Operators.validate(l)) {
-				this.requested = true;
+			if (!this.requested && Operators.validate(l)) {
+				this.requested = true; //ignore further requests
 				if (drain()) {
 					return; //there was an early completion
 				}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingleCallable.java
Patch:
@@ -23,7 +23,6 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
-import reactor.core.Fuseable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -34,7 +33,7 @@
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoSingleCallable<T> extends Mono<T>
-		implements Callable<T>, Fuseable, SourceProducer<T> {
+		implements Callable<T>, SourceProducer<T> {
 
 	final Callable<? extends T> callable;
 	@Nullable

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingleMono.java
Patch:
@@ -42,8 +42,7 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoSingleMono<T> extends InternalMonoOperator<T, T>
-		implements Fuseable {
+final class MonoSingleMono<T> extends InternalMonoOperator<T, T> {
 
 	MonoSingleMono(Mono<? extends T> source) {
 		super(source);

File: reactor-core/src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -59,7 +59,7 @@ final class FluxBuffer<T, C extends Collection<? super T>> extends InternalFluxO
 		}
 
 		if (skip <= 0) {
-			throw new IllegalArgumentException("skip > 0 required but it was " + size);
+			throw new IllegalArgumentException("skip > 0 required but it was " + skip);
 		}
 
 		this.size = size;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.core.Fuseable;
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
 
@@ -33,8 +32,7 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoSingle<T> extends MonoFromFluxOperator<T, T>
-		implements Fuseable {
+final class MonoSingle<T> extends MonoFromFluxOperator<T, T> {
 
 	final T       defaultValue;
 	final boolean completeOnEmpty;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberTest.java
Patch:
@@ -193,4 +193,4 @@ public void issue1719() {
 			assertThat(sum).as("Iteration %s", i).isEqualTo(6);
 		}
 	}
-}
+}
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java
Patch:
@@ -78,8 +78,7 @@ public class OnDiscardShouldNotLeakTest {
 			DiscardScenario.fluxSource("unicastProcessorAndPublishOn", f -> f
 					.subscribeWith(UnicastProcessor.create())
 					.publishOn(Schedulers.immediate())),
-			//FIXME known issue in 3.3.14.RELEASE and 3.4.3
-//			DiscardScenario.fluxSource("singleOrEmpty", f -> f.singleOrEmpty().onErrorReturn(Tracked.RELEASED)),
+			DiscardScenario.fluxSource("singleOrEmpty", f -> f.singleOrEmpty().onErrorReturn(Tracked.RELEASED)),
 			DiscardScenario.fluxSource("collect", f -> f.collect(ArrayList::new, ArrayList::add)
 			                                               .doOnSuccess(l -> l.forEach(Tracked::safeRelease))
 			                                               .thenReturn(Tracked.RELEASED)),

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1449,7 +1449,7 @@ public static <T> Flux<T> mergeOrdered(int prefetch, Comparator<? super T> compa
 		if (sources.length == 1) {
 			return from(sources[0]);
 		}
-		return onAssembly(new FluxMergeOrdered<>(prefetch, Queues.get(prefetch), comparator, sources));
+		return onAssembly(new FluxMergeOrdered<>(prefetch, comparator, sources));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -797,7 +797,7 @@ public final Flux<T> ordered(Comparator<? super T> comparator) {
 	 * @see ParallelFlux#ordered(Comparator)
 	 */
 	public final Flux<T> ordered(Comparator<? super T> comparator, int prefetch) {
-		return new ParallelMergeOrdered<>(this, prefetch, Queues.get(prefetch), comparator);
+		return new ParallelMergeOrdered<>(this, prefetch, comparator);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeOrdered.java
Patch:
@@ -36,17 +36,15 @@ final class ParallelMergeOrdered<T> extends Flux<T> implements Scannable {
 
 	final ParallelFlux<? extends T> source;
 	final int                       prefetch;
-	final Supplier<Queue<T>>        queueSupplier;
 	final Comparator<? super T>     valueComparator;
 
 	ParallelMergeOrdered(ParallelFlux<? extends T> source, int prefetch,
-			Supplier<Queue<T>> queueSupplier, Comparator<? super T> valueComparator) {
+			Comparator<? super T> valueComparator) {
 		if (prefetch <= 0) {
 			throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
 		}
 		this.source = source;
 		this.prefetch = prefetch;
-		this.queueSupplier = queueSupplier;
 		this.valueComparator = valueComparator;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/Sinks.java
Patch:
@@ -572,7 +572,7 @@ public interface MulticastReplaySpec {
 		 * A {@link Sinks.Many} with the following characteristics:
 		 * <ul>
 		 *     <li>Multicast</li>
-		 *     <li>Without {@link Subscriber}: up to {@code historySize} elements pushed to this sink are remembered,
+		 *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered until their {@code maxAge} is reached,
 		 *     even when there is no subscriber. Older elements are discarded</li>
 		 *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>
 		 *     <li>Replaying:  up to {@code historySize} elements pushed to this sink are replayed to new subscribers.

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -105,7 +105,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r);
 		}
 	}
 
@@ -120,7 +120,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r);
 		}
 	}
 
@@ -134,7 +134,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r);
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/ListCompositeDisposableTest.java
Patch:
@@ -226,7 +226,7 @@ public void disposeConcurrent() {
 			final Disposable d1 = new FakeDisposable();
 			final Disposable.Composite cd = new ListCompositeDisposable(d1);
 
-			RaceTestUtils.race(cd::dispose, cd::dispose, Schedulers.elastic());
+			RaceTestUtils.race(cd::dispose, cd::dispose);
 		}
 	}
 
@@ -236,7 +236,7 @@ public void removeConcurrent() {
 			final Disposable d1 = new FakeDisposable();
 			final Disposable.Composite cd = new ListCompositeDisposable(d1);
 
-			RaceTestUtils.race(() -> cd.remove(d1), cd::dispose, Schedulers.elastic());
+			RaceTestUtils.race(() -> cd.remove(d1), cd::dispose);
 		}
 	}
 
@@ -246,7 +246,7 @@ public void sizeConcurrent() {
 			final Disposable d1 = new FakeDisposable();
 			final Disposable.Composite cd = new ListCompositeDisposable(d1);
 
-			RaceTestUtils.race(cd::size, cd::dispose, Schedulers.elastic());
+			RaceTestUtils.race(cd::size, cd::dispose);
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -296,8 +296,7 @@ public void flushShouldNotRaceWithNext() {
 		for (int i = 0; i < 500; i++) {
 			RaceTestUtils.race(
 					() -> test.onNext(counter.getAndIncrement()),
-					() -> test.flushCallback(null),
-					Schedulers.elastic()
+					() -> test.flushCallback(null)
 			);
 		}
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java
Patch:
@@ -424,7 +424,7 @@ public void depthCancelRace() {
 			Runnable r1 = () -> ts.request(1);
 			Runnable r2 = ts::cancel;
 
-			RaceTestUtils.race(r1, r2, Schedulers.single());
+			RaceTestUtils.race(r1, r2);
 		}
 	}
 
@@ -443,7 +443,7 @@ public void depthEmitCancelRace() {
 			Runnable r1 = () -> pp.next(1);
 			Runnable r2 = ts::cancel;
 
-			RaceTestUtils.race(r1, r2, Schedulers.single());
+			RaceTestUtils.race(r1, r2);
 		}
 	}
 
@@ -461,7 +461,7 @@ public void depthCompleteCancelRace() {
 			Runnable r1 = pp::complete;
 			Runnable r2 = ts::cancel;
 
-			RaceTestUtils.race(r1, r2, Schedulers.single());
+			RaceTestUtils.race(r1, r2);
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java
Patch:
@@ -403,7 +403,7 @@ public void depthCancelRace() {
 			Runnable r1 = () -> ts.request(1);
 			Runnable r2 = ts::cancel;
 
-			RaceTestUtils.race(r1, r2, Schedulers.single());
+			RaceTestUtils.race(r1, r2);
 		}
 	}
 
@@ -422,7 +422,7 @@ public void depthEmitCancelRace() {
 			Runnable r1 = () -> pp.next(1);
 			Runnable r2 = ts::cancel;
 
-			RaceTestUtils.race(r1, r2, Schedulers.single());
+			RaceTestUtils.race(r1, r2);
 		}
 	}
 
@@ -440,7 +440,7 @@ public void depthCompleteCancelRace() {
 			Runnable r1 = pp::complete;
 			Runnable r2 = ts::cancel;
 
-			RaceTestUtils.race(r1, r2, Schedulers.single());
+			RaceTestUtils.race(r1, r2);
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -76,7 +76,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(Schedulers.elastic(), r, r);
 		}
 	}
 
@@ -91,7 +91,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(Schedulers.elastic(), r, r);
 		}
 	}
 
@@ -105,7 +105,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(Schedulers.elastic(), r, r);
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java
Patch:
@@ -81,7 +81,8 @@ public class OnDiscardShouldNotLeakTest {
 			DiscardScenario.sinkSource("unicastSink", 1, Sinks.unsafe().many().unicast()::onBackpressureBuffer, null),
 			DiscardScenario.sinkSource("unicastSinkAndPublishOn", 1, Sinks.unsafe().many().unicast()::onBackpressureBuffer,
 					f -> f.publishOn(Schedulers.immediate())),
-			DiscardScenario.fluxSource("singleOrEmpty", 1, f -> f.singleOrEmpty().onErrorReturn(Tracked.RELEASED)),
+			//FIXME known issue in 3.3.14.RELEASE and 3.4.3
+//			DiscardScenario.fluxSource("singleOrEmpty", 1, f -> f.singleOrEmpty().onErrorReturn(Tracked.RELEASED)),
 			DiscardScenario.fluxSource("collect", 1, f -> f.collect(ArrayList::new, ArrayList::add)
 			                                               .doOnSuccess(l -> l.forEach(Tracked::safeRelease))
 			                                               .thenReturn(Tracked.RELEASED)),

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package reactor.core.publisher;
 
-import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -52,7 +51,6 @@
 import reactor.core.publisher.Operators.MonoSubscriber;
 import reactor.core.publisher.Operators.MultiSubscriptionSubscriber;
 import reactor.core.publisher.Operators.ScalarSubscription;
-import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
@@ -293,6 +291,9 @@ public void scanScalarSubscription() {
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
 		test.poll();
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
+		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
+		test.cancel();
+		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -159,8 +159,9 @@ public void onComplete() {
 				produced(p);
 			}
 
-			otherArbiter.request(1);
 			signaller.emitNext(p, Sinks.EmitFailureHandler.FAIL_FAST);
+			// request after signalling, otherwise it may race
+			otherArbiter.request(1);
 		}
 
 		void setWhen(Subscription w) {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -971,7 +971,7 @@ public static <T, D> Mono<T> usingWhen(Publisher<D> resourceSupplier,
 	 * When {@code null}, the {@code asyncComplete} path is used instead.
 	 * @param <T> the type of elements emitted by the resource closure, and thus the main sequence
 	 * @param <D> the type of the resource object
-	 * @return a new {@link Flux} built around a "transactional" resource, with several
+	 * @return a new {@link Mono} built around a "transactional" resource, with several
 	 * termination path triggering asynchronous cleanup sequences
 	 * @see #usingWhen(Publisher, Function, Function, Function)
 	 */
@@ -2191,7 +2191,7 @@ public final Mono<T> doAfterSuccessOrError(BiConsumer<? super T, Throwable> afte
 	 *
 	 * @param afterTerminate the callback to call after {@link Subscriber#onComplete} or {@link Subscriber#onError}
 	 *
-	 * @return an observed  {@link Flux}
+	 * @return an observed  {@link Mono}
 	 */
 	public final Mono<T> doAfterTerminate(Runnable afterTerminate) {
 		Objects.requireNonNull(afterTerminate, "afterTerminate");
@@ -4328,7 +4328,7 @@ public final Mono<T> subscriberContext(Function<Context, Context> doOnContext) {
 	 *
 	 * @param scheduler a {@link Scheduler} providing the {@link Worker} where to subscribe
 	 *
-	 * @return a {@link Flux} requesting asynchronously
+	 * @return a {@link Mono} requesting asynchronously
 	 * @see #publishOn(Scheduler)
 	 */
 	public final Mono<T> subscribeOn(Scheduler scheduler) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -128,11 +128,11 @@ public boolean tryOnNext(T t) {
 			if (b) {
 				doneSkipping = true;
 				actual.onNext(t);
-				return false;
+				return true;
 			}
 
 			Operators.onDiscard(t, ctx);
-			return true;
+			return false;
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirstWithValue.java
Patch:
@@ -162,7 +162,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		FluxFirstWithValue.RaceValuesCoordinator<T> coordinator =
 				new FluxFirstWithValue.RaceValuesCoordinator<>(n);
 
-		coordinator.subscribe(a, actual);
+		coordinator.subscribe(a, n, actual);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -175,7 +175,7 @@ public void cancel() {
 				}
 				if (state <= HAS_REQUEST_NO_VALUE) {
 					c = container;
-					value = null;
+					this.value = null;
 					container = null;
 				}
 				else {

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -138,7 +138,7 @@ public void cancel() {
 				}
 				if (state <= HAS_REQUEST_NO_VALUE) {
 					l = list;
-					value = null;
+					this.value = null;
 					list = null;
 				}
 				else {

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -190,11 +190,11 @@ void cancelInner() {
 		void innerResult(@Nullable Boolean item) {
 			if (item != null && item) {
 				//will reset the value with itself, but using parent's `value` saves a field
-				complete(value);
+				complete(this.value);
 			}
 			else {
 				super.onComplete();
-				Operators.onDiscard(value, actual.currentContext());
+				discard(this.value);
 			}
 		}
 
@@ -203,7 +203,7 @@ void innerError(Throwable ex) {
 			//always propagate that error directly, as it means that the source Mono
 			//was at least valued rather than in error.
 			super.onError(ex);
-			Operators.onDiscard(value, actual.currentContext());
+			discard(this.value);
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -170,6 +170,9 @@ public void cancel() {
 			R c;
 			synchronized (this) {
 				state = STATE.getAndSet(this, CANCELLED);
+				if (state != CANCELLED) {
+					s.cancel();
+				}
 				if (state <= HAS_REQUEST_NO_VALUE) {
 					c = container;
 					value = null;
@@ -180,7 +183,6 @@ public void cancel() {
 				}
 			}
 			if (c != null) {
-				s.cancel();
 				discard(c);
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -133,6 +133,9 @@ public void cancel() {
 			List<T> l;
 			synchronized (this) {
 				state = STATE.getAndSet(this, CANCELLED);
+				if (state != CANCELLED) {
+					s.cancel();
+				}
 				if (state <= HAS_REQUEST_NO_VALUE) {
 					l = list;
 					value = null;
@@ -143,7 +146,6 @@ public void cancel() {
 				}
 			}
 			if (l != null) {
-				s.cancel();
 				discard(l);
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -93,7 +93,7 @@ public interface MonoSink<T> {
 	 *
 	 * @param d the {@link Disposable} to use as a callback
 	 * @return the {@link MonoSink} with a cancellation callback
-	 * @see #onCancel(Disposable) onDispose(Disposable) for a callback that covers cancellation AND terminal signals
+	 * @see #onDispose(Disposable) onDispose(Disposable) for a callback that covers cancellation AND terminal signals
 	 */
 	MonoSink<T> onCancel(Disposable d);
 

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -302,7 +302,7 @@ public static <T> ReplayProcessor<T> createSizeAndTimeout(int size,
 			throw new IllegalArgumentException("size > 0 required but it was " + size);
 		}
 		return new ReplayProcessor<>(new FluxReplay.SizeAndTimeBoundReplayBuffer<>(size,
-				maxAge.toMillis(),
+				maxAge.toNanos(),
 				scheduler));
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -701,7 +701,7 @@ public void backpressureDrawbackOnConditionalInTransformTest() {
 
     @Test
     public void shouldErrorOnOverflowTest() {
-        TestPublisher<Long> publisher = TestPublisher.createCold();
+        TestPublisher<Long> publisher = TestPublisher.createColdNonBuffering();
 
         Flux<String> switchTransformed = publisher.flux()
                                                   .switchOnFirst((first, innerFlux) -> innerFlux.map(String::valueOf));

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingWhenTest.java
Patch:
@@ -155,7 +155,7 @@ public void errorResourcePublisherAfterEmitIsDropped() {
 		AtomicBoolean commitDone = new AtomicBoolean();
 		AtomicBoolean rollbackDone = new AtomicBoolean();
 
-		TestPublisher<String> testPublisher = TestPublisher.createCold();
+		TestPublisher<String> testPublisher = TestPublisher.createColdNonCompliant(false, TestPublisher.Violation.DEFER_CANCELLATION);
 		testPublisher.next("Resource").error(new IllegalStateException("boom"));
 
 		Flux<String> test = Flux.usingWhen(testPublisher,
@@ -182,7 +182,7 @@ public void secondResourceInPublisherIsDropped() {
 		AtomicBoolean commitDone = new AtomicBoolean();
 		AtomicBoolean rollbackDone = new AtomicBoolean();
 
-		TestPublisher<String> testPublisher = TestPublisher.createCold();
+		TestPublisher<String> testPublisher = TestPublisher.createColdNonCompliant(false, TestPublisher.Violation.DEFER_CANCELLATION);
 		testPublisher.emit("Resource", "boom");
 
 		Flux<String> test = Flux.usingWhen(testPublisher,

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingWhenTest.java
Patch:
@@ -136,7 +136,7 @@ public void errorResourcePublisherAfterEmitIsDropped() {
 		AtomicBoolean commitDone = new AtomicBoolean();
 		AtomicBoolean rollbackDone = new AtomicBoolean();
 
-		TestPublisher<String> testPublisher = TestPublisher.createCold();
+		TestPublisher<String> testPublisher = TestPublisher.createColdNonCompliant(false, TestPublisher.Violation.DEFER_CANCELLATION);
 		testPublisher.next("Resource").error(new IllegalStateException("boom"));
 
 		Mono<String> test = Mono.usingWhen(testPublisher,
@@ -163,7 +163,7 @@ public void secondResourceInPublisherIsDropped() {
 		AtomicBoolean commitDone = new AtomicBoolean();
 		AtomicBoolean rollbackDone = new AtomicBoolean();
 
-		TestPublisher<String> testPublisher = TestPublisher.createCold();
+		TestPublisher<String> testPublisher = TestPublisher.createColdNonCompliant(false, TestPublisher.Violation.DEFER_CANCELLATION);
 		testPublisher.emit("Resource", "boom");
 
 		Mono<String> test = Mono.usingWhen(testPublisher,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -186,9 +186,9 @@ public void onError(Throwable t) {
 				produced(p);
 			}
 
-			otherArbiter.request(1);
-
 			signaller.emitNext(this, Sinks.EmitFailureHandler.FAIL_FAST);
+			// request after signalling, otherwise it may race
+			otherArbiter.request(1);
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFinallyTest.java
Patch:
@@ -30,7 +30,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.test.LoggerUtils;
+import reactor.test.util.LoggerUtils;
 import reactor.test.StepVerifier;
 import reactor.test.util.TestLogger;
 
@@ -499,7 +499,7 @@ public void gh951_withConsumerInSubscribe() {
 	//see https://github.com/reactor/reactor-core/issues/951
 	public void gh951_withoutDoOnError() {
 		TestLogger testLogger = new TestLogger();
-		LoggerUtils.addAppender(testLogger, Operators.class);
+		LoggerUtils.enableCaptureWith(testLogger);
 		try {
 			List<String> events = new ArrayList<>();
 
@@ -516,7 +516,7 @@ public void gh951_withoutDoOnError() {
 			          .contains("reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException: boom");
 		}
 		finally {
-			LoggerUtils.resetAppender(Operators.class);
+			LoggerUtils.disableCapture();
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.reactivestreams.Subscription;
 
 import reactor.core.Scannable;
-import reactor.test.LoggerUtils;
+import reactor.test.util.LoggerUtils;
 import reactor.test.StepVerifier;
 import reactor.test.util.TestLogger;
 
@@ -166,7 +166,7 @@ public void onMonoSuccessNullDoOnSuccess() {
 	@Test
 	public void testErrorWithDoOnSuccess() {
 		TestLogger testLogger = new TestLogger();
-		LoggerUtils.addAppender(testLogger, Operators.class);
+		LoggerUtils.enableCaptureWith(testLogger);
 		try {
 			Mono.error(new NullPointerException("boom"))
 			    .doOnSuccess(aValue -> {
@@ -178,7 +178,7 @@ public void testErrorWithDoOnSuccess() {
 			          .contains("reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.NullPointerException: boom");
 		}
 		finally {
-			LoggerUtils.resetAppender(Operators.class);
+			LoggerUtils.disableCapture();
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/ReplayProcessorTest.java
Patch:
@@ -27,7 +27,7 @@
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.test.LoggerUtils;
+import reactor.test.util.LoggerUtils;
 import reactor.test.StepVerifier;
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.test.subscriber.AssertSubscriber;
@@ -599,7 +599,7 @@ public void boundedOnSubscribeAndState() {
 	@SuppressWarnings("unchecked")
 	void testReplayProcessorState(ReplayProcessor<String> rp) {
 		TestLogger testLogger = new TestLogger();
-		LoggerUtils.addAppender(testLogger, Operators.class);
+		LoggerUtils.enableCaptureWith(testLogger);
 		try {
 			Disposable d1 = rp.subscribe();
 
@@ -632,7 +632,7 @@ void testReplayProcessorState(ReplayProcessor<String> rp) {
 			          .contains(e.getMessage());
 		}
 		finally {
-			LoggerUtils.resetAppender(Operators.class);
+			LoggerUtils.disableCapture();
 		}
 	}
 

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -468,9 +468,6 @@ final <S extends OperatorScenario<I, PI, O, PO>> void forEachScenario(List<S> sc
 				}
 				throw Exceptions.bubble(e);
 			}
-			finally {
-				ReactorTestExecutionListener.reset();
-			}
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -105,7 +105,7 @@ public boolean tryOnNext(T t) {
 				handler.accept(t, this);
 			}
 			catch (Throwable e) {
-				Throwable e_ = Operators.onNextError(t, error, actual.currentContext(), s);
+				Throwable e_ = Operators.onNextError(t, e, actual.currentContext(), s);
 				if (e_ != null) {
 					onError(e_);
 					return true;

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7599,7 +7599,6 @@ public final Flux<T> share() {
 	 * @return a new {@link Mono}
 	 */
 	public final Mono<T> shareNext() {
-		@SuppressWarnings("deprecation") //TODO NextProcessor will be turned into an internal class only in 3.5
 		final NextProcessor<T> nextProcessor = new NextProcessor<>(this);
 		return Mono.onAssembly(nextProcessor);
 	}

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -51,6 +51,7 @@
  * @author Stephane Maldini
  * @author Simon Baslé
  */
+// To be removed in 3.5
 final class ElasticScheduler implements Scheduler, Scannable {
 
 	static final AtomicLong COUNTER = new AtomicLong();

File: reactor-core/src/test/java/reactor/core/CurrentContextArchTest.java
Patch:
@@ -36,6 +36,7 @@ public class CurrentContextArchTest {
 			.withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_JARS)
 			.importPackagesOf(CoreSubscriber.class);
 
+	// This is ok as this class tests the deprecated FluxProcessor. Will be removed with it in 3.5.
 	@SuppressWarnings("deprecation")
 	static JavaClasses FLUXPROCESSOR_CLASSES = new ClassFileImporter()
 			.withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS)
@@ -69,6 +70,7 @@ public void check(JavaClass item, ConditionEvents events) {
 	}
 
 	@Test
+	// This is ok as this class tests the deprecated FluxProcessor. Will be removed with it in 3.5.
 	@SuppressWarnings("deprecation")
 	public void fluxProcessorsShouldNotUseDefaultCurrentContext() {
 		classes()

File: reactor-core/src/test/java/reactor/core/publisher/AbstractFluxConcatMapTest.java
Patch:
@@ -268,7 +268,6 @@ public void boundaryFusionDelayError() {
 		    .verify(Duration.ofSeconds(5));
 	}
 
-	@SuppressWarnings("deprecation")
 	@Test
 	public void singleSubscriberOnlyBoundary() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -24,6 +24,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.when;
 
+// This is ok as this class tests the deprecated DelegateProcessor. Will be removed with it in 3.5.
 @SuppressWarnings("deprecation")
 public class DelegateProcessorTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/DirectProcessorTest.java
Patch:
@@ -27,6 +27,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 
+// This is ok as this class tests the deprecated DirectProcessor. Will be removed with it in 3.5.
 @SuppressWarnings("deprecation")
 public class DirectProcessorTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -60,6 +60,7 @@
 /**
  * @author Stephane Maldini
  */
+// This is ok as this class tests the deprecated EmitterProcessor. Will be removed with it in 3.5.
 @SuppressWarnings("deprecation")
 public class EmitterProcessorTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxProcessorTest.java
Patch:
@@ -33,6 +33,7 @@
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.fail;
 
+// This is ok as this class tests the deprecated FluxProcessor. Will be removed with it in 3.5.
 @SuppressWarnings("deprecation")
 public class FluxProcessorTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -1071,7 +1071,6 @@ public static Flux<Integer> transientErrorSource() {
 		});
 	}
 
-	@SuppressWarnings("deprecation")
 	@Test
 	public void retryWhenThrowableCompanionIsComparableToRetryWhenRetryFromFunction() {
 		AtomicInteger sourceHelper = new AtomicInteger();

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -28,7 +28,6 @@ public class FluxSourceTest {
 
 	@Test
 	public void monoProcessor() {
-		@SuppressWarnings("deprecation")
 		NextProcessor<String> mp = new NextProcessor<>(null);
 		mp.onNext("test");
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterTest.java
Patch:
@@ -130,7 +130,7 @@ public void syncFusion() {
 	public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
-		@SuppressWarnings("deprecation") //TODO find a suitable source that can be async fused (MonoProcessor was never fuseable)
+		//TODO find a suitable source that can be async fused (MonoProcessor was never fuseable)
 		NextProcessor<Integer> up = new NextProcessor<>(null);
 
 		up.filter(v -> (v & 1) == 0)
@@ -147,7 +147,7 @@ public void asyncFusion() {
 	public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
-		@SuppressWarnings("deprecation") //TODO find a suitable source that can be async fused (MonoProcessor was never fuseable)
+		//TODO find a suitable source that can be async fused (MonoProcessor was never fuseable)
 		NextProcessor<Integer> up = new NextProcessor<>(null);
 
 		Mono.just(1)

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTest.java
Patch:
@@ -37,7 +37,7 @@ public void onMonoRejectedDoOnSuccessOrError() {
 		Mono<String> mp = Mono.error(new Exception("test"));
 		AtomicReference<Throwable> ref = new AtomicReference<>();
 
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // Because of doOnSuccessOrError, which will be removed in 3.5.0
 		Mono<String> mono = mp.doOnSuccessOrError((s, f) -> ref.set(f));
 
 		mono.subscribe();
@@ -50,7 +50,7 @@ public void onMonoSuccessDoOnSuccessOrError() {
 		Mono<String> mp = Mono.just("test");
 		AtomicReference<String> ref = new AtomicReference<>();
 
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // Because of doOnSuccessOrError, which will be removed in 3.5.0
 		Mono<String> mono = mp.doOnSuccessOrError((s, f) -> ref.set(s));
 
 		mono.subscribe();

File: reactor-core/src/test/java/reactor/core/publisher/ReplayProcessorTest.java
Patch:
@@ -36,6 +36,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 
+// This is ok as this class tests the deprecated ReplayProcessor. Will be removed with it in 3.5.
 @SuppressWarnings("deprecation")
 public class ReplayProcessorTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java
Patch:
@@ -46,6 +46,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
 
+// This is ok as this class tests the deprecated UnicastProcessor. Will be removed with it in 3.5.
 @SuppressWarnings("deprecation")
 public class UnicastProcessorTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -27,7 +27,7 @@
 public class EmitterProcessorVerification extends AbstractProcessorVerification {
 
 	@Override
-	@SuppressWarnings("deprecation")
+	@SuppressWarnings("deprecation") // This is ok because this uses FluxProcessor and EmitterProcessor, to be removed in 3.5
 	public Processor<Long, Long> createIdentityProcessor(int bufferSize) {
 		reactor.core.publisher.FluxProcessor<Long, Long> p = reactor.core.publisher.EmitterProcessor.create(bufferSize);
 		return reactor.core.publisher.FluxProcessor.wrap(p, p.log("EmitterProcessorVerification", Level.FINE));

File: reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java
Patch:
@@ -42,7 +42,7 @@
  * @author Stephane Maldini
  * @author Simon Baslé
  */
-@SuppressWarnings("deprecation")
+@SuppressWarnings("deprecation") // This is because of #newElastic() calls, to be removed in 3.5. ElasticScheduler class would then also be removed.
 public class ElasticSchedulerTest extends AbstractSchedulerTest {
 
 	private static final Logger LOGGER = Loggers.getLogger(ElasticSchedulerTest.class);

File: reactor-core/src/test/java/reactor/util/context/ContextTest.java
Patch:
@@ -535,7 +535,7 @@ public void putAllContextViewNoAmbiguity() {
 		ContextView contextView = context;
 		Context receiver = Context.of("foo", "bar");
 
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // because of putAll(Context). This test method shall be removed in 3.5 alongside putAll(Context)
 		Context resultFromContext = receiver.putAll(context);
 		Context resultFromContextView = receiver.putAll(contextView);
 

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -598,7 +598,6 @@ else if (!predicate.test(signal.getSubscription())) {
 	}
 
 	@Override
-	@SuppressWarnings("deprecation") //the API-level is deprecated to discourage direct use as first step
 	public DefaultStepVerifierBuilder<T> expectNoEvent(Duration duration) {
 		Objects.requireNonNull(duration, "duration");
 		if(this.script.size() == 1 && this.script.get(0) == defaultFirstStep){

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -449,7 +449,7 @@ static final class AllFactory implements Schedulers.Factory {
 		}
 
 		@Override
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // To be removed in 3.5.0
 		public Scheduler newElastic(int ttlSeconds, ThreadFactory threadFactory) {
 			return s;
 		}

File: reactor-test/src/test/java/reactor/test/scheduler/VirtualTimeSchedulerTests.java
Patch:
@@ -51,7 +51,7 @@ public void cancelledAndEmptyConstantsAreNotSame() {
 	@Test
 	public void allEnabled() {
 		assertThat(Schedulers.newParallel("")).isNotInstanceOf(VirtualTimeScheduler.class);
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // To be removed in 3.5 alongside Schedulers.newElastic
 		Scheduler elastic1 = Schedulers.newElastic("");
 		assertThat(elastic1).isNotInstanceOf(VirtualTimeScheduler.class);
 		assertThat(Schedulers.newBoundedElastic(4, Integer.MAX_VALUE, "")).isNotInstanceOf(VirtualTimeScheduler.class);
@@ -60,7 +60,7 @@ public void allEnabled() {
 		VirtualTimeScheduler.getOrSet();
 
 		assertThat(Schedulers.newParallel("")).isInstanceOf(VirtualTimeScheduler.class);
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // To be removed in 3.5 alongside Schedulers.newElastic
 		Scheduler elastic2 = Schedulers.newElastic("");
 		assertThat(elastic2).isInstanceOf(VirtualTimeScheduler.class);
 		assertThat(Schedulers.newBoundedElastic(4, Integer.MAX_VALUE, "")).isInstanceOf(VirtualTimeScheduler.class);
@@ -69,7 +69,7 @@ public void allEnabled() {
 		VirtualTimeScheduler t = VirtualTimeScheduler.get();
 
 		assertThat(Schedulers.newParallel("")).isSameAs(t);
-		@SuppressWarnings("deprecation")
+		@SuppressWarnings("deprecation") // To be removed in 3.5 alongside Schedulers.newElastic
 		Scheduler elastic3 = Schedulers.newElastic("");
 		assertThat(elastic3).isSameAs(t);
 		assertThat(Schedulers.newBoundedElastic(5, Integer.MAX_VALUE, "")).isSameAs(t); //same even though different parameter

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1021,9 +1021,8 @@ public static Mono<Void> when(final Iterable<? extends Publisher<?>> sources) {
 
 	/**
 	 * Aggregate given publishers into a new {@literal Mono} that will be
-	 * fulfilled when all of the given {@literal sources} have completed. If any Publisher
-	 * terminates without value, the returned sequence will be terminated immediately and
-	 * pending results cancelled. Errors from the sources are delayed.
+	 * fulfilled when all of the given {@literal sources} have completed. Errors from
+	 * the sources are delayed.
 	 * If several Publishers error, the exceptions are combined (as suppressed exceptions on a root exception).
 	 *
 	 * <p>

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -49,7 +49,6 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
 import static org.awaitility.Awaitility.await;
-import static org.hamcrest.Matchers.is;
 
 public class FluxWindowPredicateTest extends
                                      FluxOperatorTest<String, Flux<String>> {

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -493,7 +493,7 @@ public void syncFusionAvailable() {
 		    .subscribe(ts);
 
 		Subscription s = ts.upstream();
-		assertThat(s).withFailMessage("Non-fuseable upstream: %s", s.getClass()).isInstanceOf(QueueSubscription.class);
+		assertThat(s).as("check QueueSubscription").isInstanceOf(QueueSubscription.class);
 	}
 
 	@Test
@@ -506,7 +506,7 @@ public void asyncFusionAvailable() {
 		                .subscribe(ts);
 
 		Subscription s = ts.upstream();
-		assertThat(s).withFailMessage("Non-fuseable upstream: %s", s.getClass()).isInstanceOf(QueueSubscription.class);
+		assertThat(s).as("check QueueSubscription").isInstanceOf(QueueSubscription.class);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -716,7 +716,7 @@ public void syncFusionAvailable() {
 		    .subscribe(ts);
 
 		Subscription s = ts.upstream();
-		assertThat(s).withFailMessage("Non-fuseable upstream: %s", s.getClass()).isInstanceOf(QueueSubscription.class);
+		assertThat(s).as("check QueueSubscription").isInstanceOf(QueueSubscription.class);
 	}
 
 	@Test
@@ -729,7 +729,7 @@ public void asyncFusionAvailable() {
 		                .subscribe(ts);
 
 		Subscription s = ts.upstream();
-		assertThat(s).withFailMessage("Non-fuseable upstream: %s", s.getClass()).isInstanceOf(QueueSubscription.class);
+		assertThat(s).as("check QueueSubscription").isInstanceOf(QueueSubscription.class);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/test/MemoryUtils.java
Patch:
@@ -97,8 +97,8 @@ public static final class OffHeapDetector {
 
 
 		public OffHeapDetector() {
+			//note: AssertJ representation of Tracked is installed in ReactorTestExecutionListener
 			tracker = new ConcurrentLinkedQueue<>();
-			AssertionsUtils.installAssertJTestRepresentation();
 		}
 
 		/**

File: reactor-core/src/test/java/reactor/core/DisposableTest.java
Patch:
@@ -224,4 +224,4 @@ public void neverCreatesInstances() {
 		assertThat(Disposables.never()).isNotSameAs(Disposables.never());
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -158,4 +158,4 @@ public void dispose() {
 		assertThat(u.isDisposed()).isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/ListCompositeDisposableTest.java
Patch:
@@ -278,4 +278,4 @@ public void scan() {
 		assertThat(composite.scanUnsafe(Scannable.Attr.TERMINATED)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/SwapDisposableTest.java
Patch:
@@ -203,4 +203,4 @@ public void concurrentSetDisposableShouldNotInterleave()
 			t.join();
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/BaseSubscriberTest.java
Patch:
@@ -50,7 +50,7 @@ protected void hookOnSubscribe(Subscription subscription) {
 
 			@Override
 			public void hookOnNext(Integer integer) {
-				assertThat(lastValue.compareAndSet(integer - 1, integer)).as("compareAndSet of " + integer).isTrue();
+				assertThat(lastValue.compareAndSet(integer - 1, integer)).as("compareAndSet of %d", integer).isTrue();
 				if (integer < 10) {
 					request(1);
 				}
@@ -77,7 +77,7 @@ protected void hookFinally(SignalType type) {
 		});
 
 		latch.await(500, TimeUnit.MILLISECONDS);
-		assertThat(lastValue.get()).isEqualTo(10);
+		assertThat(lastValue).hasValue(10);
 	}
 
 	@Test
@@ -375,4 +375,4 @@ protected void hookFinally(SignalType type) {
 		assertThat(latch.await(1500, TimeUnit.MILLISECONDS)).as("delay should be skipped by cancel").isTrue();
 		assertThat(onFinally).hasValue(SignalType.CANCEL);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/BlockingSingleSubscriberTest.java
Patch:
@@ -70,4 +70,4 @@ public void scanMainCancelled() {
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isFalse();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ConnectableFluxHideTest.java
Patch:
@@ -48,4 +48,4 @@ public void scanOperator() throws Exception {
 				.isEqualTo(256)
 				.isEqualTo(source.getPrefetch());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ConnectableFluxOnAssemblyTest.java
Patch:
@@ -55,4 +55,4 @@ public void stepNameAndToString() {
 				.startsWith("reactor.core.publisher.ConnectableFluxOnAssemblyTest.stepNameAndToString(ConnectableFluxOnAssemblyTest.java:");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ContextTests.java
Patch:
@@ -87,7 +87,7 @@ public void contextPassing2() throws InterruptedException {
 		    .log()
 		    .subscribe();
 
-		assertThat(innerC.get()).isEqualTo("foobar");
+		assertThat(innerC).hasValue("foobar");
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -45,4 +45,4 @@ public void scanReturnsDownStreamForParentElseDelegates() {
 		assertThat(processor.scan(Scannable.Attr.ERROR)).isSameAs(boom);
 		assertThat(processor.scan(Scannable.Attr.DELAY_ERROR)).isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectFuseableTest.java
Patch:
@@ -37,4 +37,4 @@ public void scanMain() {
 		assertThat(test.scan(Scannable.Attr.CAPACITY)).isEqualTo(123);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableOnAssemblyTest.java
Patch:
@@ -57,4 +57,4 @@ public void stepNameAndToString() {
 				.isEqualTo(test.stepName())
 				.startsWith("reactor.core.publisher.FluxCallableOnAssemblyTest.stepNameAndToString(FluxCallableOnAssemblyTest.java:");
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableTest.java
Patch:
@@ -81,4 +81,4 @@ public void callableThrows() {
 		  .assertError(IOException.class)
 		  .assertErrorMessage("forced failure");
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxCancelOnTest.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import org.reactivestreams.Subscription;
@@ -52,7 +51,7 @@ public void cancelOnDedicatedScheduler() throws Exception {
 		    .cancel();
 
 		latch.await();
-		Assert.assertNull(threadHash.get());
+		assertThat(threadHash).hasValue(null);
 	}
 
 	@Test
@@ -78,4 +77,4 @@ public void scanSubscriber() {
 		test.cancel();
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatWithTest.java
Patch:
@@ -106,4 +106,4 @@ public void concatWithValues() {
           .expectNext(1, 2, 4, 5, 6)
           .verifyComplete();
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelaySequenceTest.java
Patch:
@@ -299,4 +299,4 @@ public void scanSubscriber() {
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDematerializeTest.java
Patch:
@@ -303,4 +303,4 @@ public void scanSubscriber() {
 		test.cancel();
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFirstTest.java
Patch:
@@ -174,4 +174,4 @@ public void performsDirectSubscriberToSource_Fused() {
 		assertThat(subRef.get().getClass()).isEqualTo(FluxMapFuseable.MapFuseableSubscriber.class);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxElapsedTest.java
Patch:
@@ -62,4 +62,4 @@ public void scanSubscriber() {
         assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);
         assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.single());
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxEmptyTest.java
Patch:
@@ -25,4 +25,4 @@ public void normal() {
 		StepVerifier.create(Flux.empty())
 	                .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorTest.java
Patch:
@@ -62,4 +62,4 @@ public void scanSubscriptionCancelled() {
         test.cancel();
         assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java
Patch:
@@ -110,7 +110,7 @@ public void recursiveCountdownLoop() {
 
 			for (int j = 0; j <= i; j++) {
 				assertThat(list.get(j).intValue())
-						.as(tag + ", " + list)
+						.as("%s, %s", tag, list)
 						.isEqualTo(i - j);
 			}
 		}
@@ -133,7 +133,7 @@ public void recursiveCountdownLoopDepth() {
 
 			for (int j = 0; j <= i; j++) {
 				assertThat(list.get(j).intValue())
-						.as(tag + ", " + list)
+						.as("%s, %s", tag, list)
 						.isEqualTo(i - j);
 			}
 		}

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -485,4 +485,4 @@ public void discardConditionalTryOnNextPredicateMiss() {
 
 		assertThat(discarded).containsExactly(1);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxGenerateTest.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
@@ -280,7 +279,7 @@ public void stateConsumerCalled() {
 		  .assertComplete()
 		  .assertNoError();
 
-		Assert.assertEquals(1, stateConsumer.get());
+		assertThat(stateConsumer).hasValue(1);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.List;
 
 import org.junit.jupiter.api.AfterEach;
-import org.junit.Assert;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
@@ -32,6 +31,7 @@
 import reactor.test.subscriber.AssertSubscriber;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
 
 public class FluxIntervalTest {
 
@@ -71,7 +71,7 @@ public void normal() {
 				long diff = list.get(i + 1) - list.get(i);
 
 				if (diff < 50 || diff > 150) {
-					Assert.fail("Period failure: " + diff);
+					fail("Period failure: " + diff);
 				}
 			}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxJustTest.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
@@ -40,7 +39,7 @@ public void nullValue() {
     @Test
     @SuppressWarnings("unchecked")
     public void valueSame() throws Exception {
-        Assert.assertSame(1, ((Callable<Integer>)Flux.just(1)).call());
+        assertThat(((Callable<Integer>)Flux.just(1)).call()).isEqualTo(1);
     }
 
     @Test
@@ -88,7 +87,7 @@ public void fluxInitialValueAvailableImmediately() {
         Flux<String> stream = Flux.just("test");
         AtomicReference<String> value = new AtomicReference<>();
         stream.subscribe(value::set);
-        assertThat(value.get()).isEqualTo("test");
+        assertThat(value).hasValue("test");
     }
 
     @Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java
Patch:
@@ -310,4 +310,4 @@ protected void hookOnSubscribe(Subscription subscription) {
 				.hasSize(1);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeOrderedTest.java
Patch:
@@ -659,4 +659,4 @@ public void naturalOrder() {
 				.verifyComplete();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeTest.java
Patch:
@@ -26,7 +26,7 @@
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.concurrent.Queues;
 
-import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class FluxMergeTest {
 
@@ -91,7 +91,7 @@ public void mergePublisherPublisher(){
 		AtomicLong request = new AtomicLong();
 		StepVerifier.create(Flux.merge(Flux.just(Flux.just(1, 2), Flux.just(3, 4)).doOnRequest(request::set)))
 	                .expectNext(1, 2, 3, 4)
-	                .then(() -> assertThat(request.get()).isEqualTo(1) )
+	                .then(() -> assertThat(request).hasValue(1L) )
 	                .verifyComplete();
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeWithTest.java
Patch:
@@ -99,4 +99,4 @@ public void dontBreakFluxArrayFlatmap() {
 		.assertNoError()
 		.assertComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameFuseableTest.java
Patch:
@@ -59,4 +59,4 @@ public void scanOperatorNullTags() throws Exception {
 		assertThat(test.scan(Scannable.Attr.TAGS)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameTest.java
Patch:
@@ -58,4 +58,4 @@ public void scanOperatorNullTags() throws Exception {
 		assertThat(test.scan(Scannable.Attr.TAGS)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxNeverTest.java
Patch:
@@ -15,15 +15,16 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class FluxNeverTest {
 
 	@Test
 	public void singleInstance() {
-		Assert.assertSame(Flux.never(), Flux.never());
+		assertThat(Flux.never()).isSameAs(Flux.never());
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTest.java
Patch:
@@ -327,4 +327,4 @@ public void scanCapacityBoundedQueueWithExtraCapacity() {
 
 	    assertThat(test.scan(Scannable.Attr.CAPACITY)).isEqualTo(desiredCapacity);
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java
Patch:
@@ -345,4 +345,4 @@ public void scanSubscriber() {
 		assertThat(test.scan(Scannable.Attr.DELAY_ERROR)).isFalse();
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.immediate());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureDropTest.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.Arrays;
 import java.util.List;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
@@ -122,7 +121,7 @@ public void someDrops() {
 		  .assertComplete()
 		  .assertNoError();
 
-		Assert.assertEquals(Arrays.asList(1, 4), drops);
+		assertThat(drops).containsExactly(1, 4);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -89,7 +89,7 @@ protected void hookOnSubscribe(Subscription subscription) {
 			    }
 		    });
 
-		assertThat(cancelled.get()).isEqualTo(1);
+		assertThat(cancelled).hasValue(1);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -574,4 +574,4 @@ protected void hookOnNext(Integer value) {
 		}
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -109,7 +109,7 @@ protected void hookOnSubscribe(Subscription subscription) {
 			         }
 		         });
 
-		assertThat(cancelled.get()).isEqualTo(1);
+		assertThat(cancelled).hasValue(1);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxScanSeedTest.java
Patch:
@@ -190,7 +190,7 @@ public void onNextAndCancelRaceDontPassNullToAccumulator() {
 			RaceTestUtils.race(sub::cancel, () -> sub.onNext(1));
 
 			testSubscriber.assertNoError();
-			assertThat(accumulatorCheck).as("no NPE due to onNext/cancel race in round " + i).isTrue();
+			assertThat(accumulatorCheck).as("no NPE due to onNext/cancel race in round %d", i).isTrue();
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxScanTest.java
Patch:
@@ -160,7 +160,7 @@ public void onNextAndCancelRaceDontPassNullToAccumulator() {
 			RaceTestUtils.race(sub::cancel, () -> sub.onNext(1));
 
 			testSubscriber.assertNoError();
-			assertThat(accumulatorCheck).as("no NPE due to onNext/cancel race in round " + i).isTrue();
+			assertThat(accumulatorCheck).as("no NPE due to onNext/cancel race in round %d", i).isTrue();
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipUntilTest.java
Patch:
@@ -81,4 +81,4 @@ public void scanSubscriber() {
         test.onComplete();
         Assertions.assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxStartWithTest.java
Patch:
@@ -99,4 +99,4 @@ public void dontBreakFluxArrayConcatMap() {
 		.assertNoError()
 		.assertComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnCallableTest.java
Patch:
@@ -199,4 +199,4 @@ public void scanMainSubscriber() {
         test.cancel();
         Assertions.assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeLastOneTest.java
Patch:
@@ -67,4 +67,4 @@ public void normalHide() {
 	                .expectNext(100)
 	                .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimestampTest.java
Patch:
@@ -36,4 +36,4 @@ public void aFluxCanBeTimestamped(){
 		            .expectNextMatches(t -> t.getT1() == 2000 && t.getT2().equals("test"))
 		            .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeoutTest.java
Patch:
@@ -288,4 +288,4 @@ public void scanMainSubscriber() {
 		test.cancel();
 		Assertions.assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
     }
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/FluxWithLatestFromTest.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
@@ -25,8 +24,8 @@
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.context.Context;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.junit.jupiter.api.Assertions.assertThrows;
 
 public class FluxWithLatestFromTest {
 
@@ -151,7 +150,7 @@ public void combinerThrows() {
 		ts.assertNoValues()
 		  .assertNotComplete()
 		  .assertError(RuntimeException.class)
-		  .assertErrorWith( e -> Assert.assertTrue(e.getMessage().contains("forced failure")));
+		  .assertErrorWith( e -> assertThat(e).hasMessageContaining("forced failure"));
 	}
 
 

File: reactor-core/src/test/java/reactor/core/publisher/InnerProducerTest.java
Patch:
@@ -42,4 +42,4 @@ public void cancel() { }
 
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/LambdaSubscriberTest.java
Patch:
@@ -26,7 +26,7 @@
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import static org.assertj.core.api.Assertions.fail;
 
 public class LambdaSubscriberTest {
 
@@ -223,4 +223,4 @@ public void cancel() {
 		}
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoAllTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package reactor.core.publisher;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
@@ -109,8 +108,7 @@ public void predicateThrows() {
 		ts.assertNoValues()
 		  .assertNotComplete()
 		  .assertError(RuntimeException.class)
-		  .assertErrorWith(e -> Assert.assertTrue(e.getMessage()
-		                                           .contains("forced failure")));
+		  .assertErrorWith(e -> assertThat(e).hasMessageContaining("forced failure"));
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoAnyTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package reactor.core.publisher;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
@@ -161,7 +160,7 @@ public void predicateThrows() {
 		  .assertError(RuntimeException.class)
 		  .assertErrorWith( e -> {
 			  e.printStackTrace();
-			  Assert.assertTrue(e.getMessage().contains("forced failure"));
+			  assertThat(e.getMessage().contains("forced failure")).isTrue();
 		  });
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoCallableOnAssemblyTest.java
Patch:
@@ -58,4 +58,4 @@ public void stepNameAndToString() {
 				.startsWith("reactor.core.publisher.MonoCallableOnAssemblyTest.stepNameAndToString(MonoCallableOnAssemblyTest.java:");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoCancelOnTest.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import reactor.core.Scannable;
@@ -50,7 +49,7 @@ public void cancelOnDedicatedScheduler() throws Exception {
 		    .cancel();
 
 		latch.await();
-		Assert.assertNull(threadHash.get());
+		assertThat(threadHash.get()).isNull();
 	}
 
 	@Test
@@ -59,4 +58,4 @@ public void scanOperator() {
 
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.immediate());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectListTest.java
Patch:
@@ -226,7 +226,7 @@ public void discardCancelNextRace() {
 			if (!extraneous.get()) {
 				LOGGER.info(""+subscriber.list);
 			}
-			assertThat(extraneous).as("released " + i).isTrue();
+			assertThat(extraneous).as("released %d", i).isTrue();
 		}
 		LOGGER.info("discarded twice or more: {}", doubleDiscardCounter.get());
 	}
@@ -252,7 +252,7 @@ public void discardCancelCompleteRace() {
 			RaceTestUtils.race(subscriber::cancel, subscriber::onComplete);
 
 			if (testSubscriber.values().isEmpty()) {
-				assertThat(resource).as("not completed and released " + i).isTrue();
+				assertThat(resource).as("not completed and released %d", i).isTrue();
 			}
 		}
 		LOGGER.info("discarded twice or more: {}", doubleDiscardCounter.get());
@@ -276,4 +276,4 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 		assertThat(result).isEmpty();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectMapTest.java
Patch:
@@ -124,4 +124,4 @@ public void collectMultiMapCallable() {
 		            .verifyComplete();
 
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoCompletionStageTest.java
Patch:
@@ -168,4 +168,4 @@ public void actionFailureCompletionExceptionIsUnwrapped() {
 		    .then(() -> future.complete("Success"))
 		    .verifyError(IllegalStateException.class);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayTest.java
Patch:
@@ -105,4 +105,4 @@ public void scanDelayRunnableCancelled() {
 		test.cancel();
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java
Patch:
@@ -210,4 +210,4 @@ public void materializeDematerializeMonoError() {
 		StepVerifier.create(Mono.error(new IllegalStateException("boom")).materialize().dematerialize())
 		            .verifyErrorMessage("boom");
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoFirstTest.java
Patch:
@@ -174,4 +174,4 @@ public void performsDirectSubscriberToSource_Fused() {
 		assertThat(subRef.get().getClass()).isEqualTo(FluxMapFuseable.MapFuseableSubscriber.class);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoOnEachTest.java
Patch:
@@ -119,7 +119,7 @@ else if (s.isOnComplete()) {
 		    })
 		    .subscribe(ts);
 
-		assertThat(onNext.get()).isEqualTo(1);
+		assertThat(onNext).hasValue(1);
 		assertThat(onError.get()).isNull();
 		assertThat(onComplete.get()).isTrue();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoElapsedTest.java
Patch:
@@ -48,4 +48,4 @@ public void scanOperator() {
 
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.immediate());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoEmptyTest.java
Patch:
@@ -25,4 +25,4 @@ public void normal() {
 		StepVerifier.create(Mono.empty())
 		            .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoErrorTest.java
Patch:
@@ -35,4 +35,4 @@ public void onMonoRejectedThrowOnBlock() {
 					.block();
 		});
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java
Patch:
@@ -105,7 +105,7 @@ public void recursiveCountdownLoop() {
 
 			for (int j = 0; j <= i; j++) {
 				assertThat(list.get(j).intValue())
-						.as(tag + ", " + list)
+						.as("%s, %s", tag, list)
 						.isEqualTo(i - j);
 			}
 		}
@@ -128,7 +128,7 @@ public void recursiveCountdownLoopDepth() {
 
 			for (int j = 0; j <= i; j++) {
 				assertThat(list.get(j).intValue())
-						.as(tag + ", " + list)
+						.as("%s, %s", tag, list)
 						.isEqualTo(i - j);
 			}
 		}
@@ -524,4 +524,4 @@ public void javadocExampleDepthFirst() {
 		            .expectNextSequence(depthFirstExpected)
 		            .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterTest.java
Patch:
@@ -163,7 +163,7 @@ public void asyncFusionBackpressured() {
 			up.onNext(3);
 		}
 		catch(Exception e){
-			Assert.assertTrue(Exceptions.isCancel(e));
+			assertThat(Exceptions.isCancel(e)).isTrue();
 		}
 
 		ts.assertValues(2)

File: reactor-core/src/test/java/reactor/core/publisher/MonoHasElementsTest.java
Patch:
@@ -116,7 +116,7 @@ public void fluxSourceIsCancelled() {
 	                .expectNext(true)
 	                .verifyComplete();
 
-		assertThat(cancelCount.get()).isEqualTo(1);
+		assertThat(cancelCount).hasValue(1);
 	}
 
 	@Test
@@ -129,7 +129,7 @@ public void monoSourceIsNotCancelled() {
 		            .expectNext(true)
 		            .verifyComplete();
 
-		assertThat(cancelCount.get()).isEqualTo(0);
+		assertThat(cancelCount).hasValue(0);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnoreEmptyTest.java
Patch:
@@ -52,4 +52,4 @@ public void scanSubscriber() {
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoJustTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.Optional;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
@@ -39,7 +38,7 @@ public void nullValue() {
     @Test
     public void valueSame() {
 	    try {
-		    Assert.assertSame(1, new MonoJust<>(1).call());
+		    assertThat(new MonoJust<>(1).call()).isEqualTo(1);
 	    }
 	    catch (Exception e) {
 		    e.printStackTrace();

File: reactor-core/src/test/java/reactor/core/publisher/MonoMapTest.java
Patch:
@@ -200,4 +200,4 @@ public void hiddenMapHiddenFilterBackpressured() {
 		  .assertNoError()
 		  .assertComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameFuseableTest.java
Patch:
@@ -58,4 +58,4 @@ public void scanOperatorNullTags() throws Exception {
 		assertThat(test.scan(Scannable.Attr.TAGS)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameTest.java
Patch:
@@ -58,4 +58,4 @@ public void scanOperatorNullTags() throws Exception {
 		assertThat(test.scan(Scannable.Attr.TAGS)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoNeverTest.java
Patch:
@@ -28,4 +28,4 @@ public void normal() {
 		    .assertNoError()
 		    .assertNotComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoNextTest.java
Patch:
@@ -76,4 +76,4 @@ public void scanSubscriber() {
 		test.onError(new IllegalStateException("boom"));
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnAssemblyTest.java
Patch:
@@ -58,4 +58,4 @@ public void stepNameAndToString() {
 				.startsWith("reactor.core.publisher.MonoOnAssemblyTest.stepNameAndToString(MonoOnAssemblyTest.java:");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnErrorResumeTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package reactor.core.publisher;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
@@ -176,8 +175,7 @@ public void nextFactoryThrows() {
 		ts.assertNoValues()
 		  .assertNotComplete()
 		  .assertError(RuntimeException.class)
-		  .assertErrorWith(e -> Assert.assertTrue(e.getMessage()
-		                                           .contains("forced failure 2")));
+		  .assertErrorWith(e -> assertThat(e).hasMessageContaining("forced failure 2"));
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTerminalTest.java
Patch:
@@ -42,4 +42,4 @@ public void scanSubscriber() {
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRepeatPredicateTest.java
Patch:
@@ -69,4 +69,4 @@ public void nTwo() {
 		            .verifyComplete();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryPredicateTest.java
Patch:
@@ -63,4 +63,4 @@ public void twoRetryErrorSupplier() {
 		                        .retry(3, e -> bool.get()))
 		            .verifyErrorMessage("test");
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryTest.java
Patch:
@@ -122,4 +122,4 @@ public void accept(Integer t) {
 		    .subscribeWith(AssertSubscriber.create())
 		    .assertValues(1);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryWhenTest.java
Patch:
@@ -332,4 +332,4 @@ public void monoRetryBackoffRetriesOnGivenScheduler() {
 		}
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRunnableTest.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.data.Offset;
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Schedulers;
@@ -127,7 +126,7 @@ public void test() {
 		    .ignoreElements()
 		    .block();
 
-		Assert.assertEquals(1000, c[0]);
+		assertThat(c[0]).isEqualTo(1000);
 	}
 
 	//see https://github.com/reactor/reactor-core/issues/1503

File: reactor-core/src/test/java/reactor/core/publisher/MonoSingleMonoTest.java
Patch:
@@ -38,4 +38,4 @@ public void normalValued() {
 		            .expectNext("foo")
 		            .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnCallableTest.java
Patch:
@@ -80,4 +80,4 @@ public void scanOperator() {
 
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.immediate());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnValueTest.java
Patch:
@@ -54,4 +54,4 @@ public void scanOperator() {
 
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.immediate());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSupplierTest.java
Patch:
@@ -98,4 +98,4 @@ public void onMonoErrorSupplierOnBlock() {
 			}).block();
 		});
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenIgnoreTest.java
Patch:
@@ -142,4 +142,4 @@ public void monoThenMonoAndShift() {
 		            .expectNext("Bye")
 		            .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -167,4 +167,4 @@ public void timeoutNotDurationMessage() {
 				            "(and no fallback has been configured)")
 		            .verify();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimestampTest.java
Patch:
@@ -36,4 +36,4 @@ public void aMonoCanBeTimestamped(){
 		            .expectNextMatches(t -> t.getT1() == 2000 && t.getT2().equals("test"))
 		            .verifyComplete();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoToCompletableFutureTest.java
Patch:
@@ -78,4 +78,4 @@ public void sourceCanBeCancelledExplicitlyByOnNext() {
 
 		assertThat(flag).as("cancelled").isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingWhenTest.java
Patch:
@@ -458,4 +458,4 @@ public void scanResourceSubscriber() {
 		assertThat(op.scanUnsafe(Attr.CANCELLED)).as("CANCELLED not supported").isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java
Patch:
@@ -605,4 +605,4 @@ public String toString() {
 			return scenarioDescription;
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -153,4 +153,4 @@ public void trySet() {
 
 		assertThat(d3.isDisposed()).isTrue();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -354,7 +354,7 @@ public void onNextDroppedLocal() {
 
 		Operators.onNextDropped("foo", c);
 
-		assertThat(hookState.get()).isEqualTo("foo");
+		assertThat(hookState).hasValue("foo");
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/ParallelArraySourceTest.java
Patch:
@@ -34,4 +34,4 @@ public void parallelism() {
 		assertThat(test.parallelism()).isEqualTo(2);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelConcatMapTest.java
Patch:
@@ -102,4 +102,4 @@ public void concatDelayErrorWithMonoError() {
 		            .verifyErrorMessage("test");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFilterTest.java
Patch:
@@ -60,4 +60,4 @@ public void conditional() {
 		}
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFlatMapTest.java
Patch:
@@ -50,4 +50,4 @@ public void scanOperator() throws Exception {
 		assertThat(test.scan(Scannable.Attr.DELAY_ERROR)).isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxHideTest.java
Patch:
@@ -44,4 +44,4 @@ public void scanOperator() throws Exception {
 				.isEqualTo(source.getPrefetch());
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxNameTest.java
Patch:
@@ -70,4 +70,4 @@ public void scanOperatorNullTags() throws Exception {
 		assertThat(test.scan(Scannable.Attr.TAGS)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxOnAssemblyTest.java
Patch:
@@ -68,4 +68,4 @@ public void scanOperator() {
 		assertThat(test.scan(Scannable.Attr.ACTUAL_METADATA)).as("ACTUAL_METADATA").isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelGroupTest.java
Patch:
@@ -85,4 +85,4 @@ public void scanInnerGroupRequestTrackedWhenNoParent() {
 		assertThat(test.scan(Scannable.Attr.REQUESTED_FROM_DOWNSTREAM)).isEqualTo(5);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLiftTest.java
Patch:
@@ -44,4 +44,4 @@ public void scanOperator() throws Exception {
 				.isEqualTo(source.getPrefetch());
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLogTest.java
Patch:
@@ -59,4 +59,4 @@ public void conditional() {
 			            .verifyComplete();
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMapTest.java
Patch:
@@ -56,4 +56,4 @@ public void conditional() {
 			            .verifyComplete();
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeOrderedTest.java
Patch:
@@ -119,4 +119,4 @@ public void scanUnsafe() {
 
 		assertThat(test.scan(Scannable.Attr.NAME)).isNull();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeSequentialTest.java
Patch:
@@ -70,7 +70,7 @@ public void scanMainSubscriberDoneAfterNComplete() {
 		subscriber.onSubscribe(test);
 
 		for (int i = 0; i < n; i++) {
-			assertThat(test.scan(Scannable.Attr.TERMINATED)).as("complete " + i)
+			assertThat(test.scan(Scannable.Attr.TERMINATED)).as("complete %d", i)
 			                                                .isFalse();
 			test.onComplete();
 		}
@@ -106,4 +106,4 @@ public void scanInnerSubscriber() {
 		test.onSubscribe(subscription);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeSortTest.java
Patch:
@@ -80,4 +80,4 @@ public void scanInnerSubscriber() {
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelPeekTest.java
Patch:
@@ -61,4 +61,4 @@ public void conditional() {
 			            .verifyComplete();
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelRunOnTest.java
Patch:
@@ -57,4 +57,4 @@ public void conditional() {
 			            .verifyComplete();
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelSourceTest.java
Patch:
@@ -91,4 +91,4 @@ public void scanInnerSubscriber() {
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(subs[test.index]);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/QueueDrainSubscriberTest.java
Patch:
@@ -74,4 +74,4 @@ public void objectPadding() {
 		System.out.println(fieldAfterRequested);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -167,4 +167,4 @@ public void scanSerializedSubscriberMaxBuffered() {
 		assertThat(test.scan(Scannable.Attr.LARGE_BUFFERED)).isNull();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FizzBuzzTests.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.TimerTask;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Assert;
 import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;

File: reactor-core/src/test/java/reactor/core/scheduler/BoundedElasticSchedulerTest.java
Patch:
@@ -484,7 +484,7 @@ public void lifoEvictionNoThreadRegrowth() throws InterruptedException {
 					.withFailMessage("worker thread count after shutdown is not zero. threads: %s", Thread.getAllStackTraces().keySet())
 					.isNotPositive();
 			assertThat(dumpThreadNames())
-					.as("current evictor " + newEvictor + " shutdown")
+					.as("current evictor %s shutdown", newEvictor)
 					.doesNotContain(newEvictor);
 		}
 	}
@@ -1353,4 +1353,4 @@ public void toStringOfExecutorReflectsIdleVsActive() throws InterruptedException
 			unbounded.shutdownNow();
 		}
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java
Patch:
@@ -124,7 +124,7 @@ public void failingPlainExecutorIsNotTerminated() {
 				.as("third-no rejection")
 				.doesNotThrowAnyException();
 
-		assertThat(count.get()).isEqualTo(3);
+		assertThat(count).hasValue(3);
 	}
 
 	@Test
@@ -183,7 +183,7 @@ public void execute(@NotNull Runnable command) {
 				.as("third-no rejection")
 				.doesNotThrowAnyException();
 
-		assertThat(count.get()).isEqualTo(3);
+		assertThat(count).hasValue(3);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.scheduler;
 
+import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.lang.management.ManagementFactory;
@@ -113,14 +114,14 @@ public void lotsOfTasks() throws Exception {
     	            w.schedule(r);
     	        }
     	        
-    	        Assert.assertTrue(cdl.await(5, TimeUnit.SECONDS));
+    	        assertThat(cdl.await(5, TimeUnit.SECONDS)).isTrue();
 
     	        System.gc();
     	        Thread.sleep(200);
 
                 long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();
 
-    	        Assert.assertTrue(String.format("%,d -> %,d", before, after), before + 20_000_000 > after);
+    	        assertThat(before + 20_000_000).as("%,d -> %,d", before, after).isGreaterThan(after);
 	        } finally {
 	            w.dispose();
 	        }

File: reactor-core/src/test/java/reactor/core/scheduler/WorkerTaskTest.java
Patch:
@@ -354,4 +354,4 @@ public void withParentIsDisposed() {
 		assertThat(set.remove(run)).isFalse();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -24,10 +24,10 @@
 import java.util.function.Function;
 import java.util.stream.Stream;
 
-import org.junit.function.ThrowingRunnable;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.api.function.ThrowingConsumer;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -1102,12 +1102,12 @@ private Stream<DynamicTest> toDynamicTests(
 		});
 	}
 
-	private DynamicTest toDynamicTest(OperatorScenario<I, PI, O, PO> scenario, ThrowingRunnable runnable) {
+	private DynamicTest toDynamicTest(OperatorScenario<I, PI, O, PO> scenario, Executable runnable) {
 		return DynamicTest.dynamicTest(scenario.description(), () -> {
 			if (scenario.stack != null) {
 				System.out.println("\tat " + scenario.stack.getStackTrace()[2]);
 			}
-			runnable.run();
+			runnable.execute();
 		});
 	}
 

File: reactor-core/src/test/java/reactor/util/ConsoleLoggerTest.java
Patch:
@@ -296,4 +296,4 @@ public void formatNull() {
 				.isEqualTo("[ INFO] (" + Thread.currentThread().getName() + ") null\n");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/JdkLoggerTest.java
Patch:
@@ -81,4 +81,4 @@ public void formatNullParamInVararg() {
 				.isEqualTo("test null is null");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/LoggersTest.java
Patch:
@@ -102,4 +102,4 @@ public void useSl4jLoggers() throws Exception {
 		}
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/concurrent/QueuesOneQueueTest.java
Patch:
@@ -102,4 +102,4 @@ private Queue<Integer> oneQueueWithTestElement(int element) {
 		q.add(element);
 		return q;
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/concurrent/QueuesTest.java
Patch:
@@ -150,4 +150,4 @@ public void toArrayOnZeroQueueShouldNotFailAlsoOnJava9() {
 		assertThat(emptyQueue.toArray(new Integer[0])).as("toArray(empty)").isEmpty();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/Context0Test.java
Patch:
@@ -158,4 +158,4 @@ public void unsafePutAllIntoIsNoOp() {
 				.containsEntry(1, "SHOULD NOT BE REPLACED")
 				.hasSize(1);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/Context1Test.java
Patch:
@@ -213,4 +213,4 @@ public void unsafePutAllIntoShouldReplace() {
 				.hasSize(2);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/Context2Test.java
Patch:
@@ -225,4 +225,4 @@ public void unsafePutAllIntoShouldReplace() {
 				.hasSize(3);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/Context3Test.java
Patch:
@@ -252,4 +252,4 @@ public void unsafePutAllIntoShouldReplace() {
 				.containsEntry("extra", "value")
 				.hasSize(4);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/Context4Test.java
Patch:
@@ -413,4 +413,4 @@ public void unsafePutAllIntoShouldReplace() {
 				.hasSize(5);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/Context5Test.java
Patch:
@@ -314,4 +314,4 @@ public void unsafePutAllIntoShouldReplace() {
 				.containsEntry("extra", "value")
 				.hasSize(6);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/ContextNTest.java
Patch:
@@ -425,4 +425,4 @@ public void shouldNotMutateOriginalMap() {
 		assertThat(contextN).containsEntry("A", -1);
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/ContextTest.java
Patch:
@@ -599,4 +599,4 @@ public String toString() {
 		}
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/context/CoreContextTest.java
Patch:
@@ -82,4 +82,4 @@ public void mergeTwoSmallContextResultInContext4() {
 		assertThat(context4.value4).as("value4").isEqualTo("value4");
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple2Test.java
Patch:
@@ -92,7 +92,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i).isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -133,4 +133,4 @@ public void sanityTestHashcode() {
 				.isNotEqualTo(different.hashCode());
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple3Test.java
Patch:
@@ -89,7 +89,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i).isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -120,4 +120,4 @@ public void sanityTestHashcode() {
 				.isEqualTo(same.hashCode())
 				.isNotEqualTo(different.hashCode());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple4Test.java
Patch:
@@ -100,7 +100,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i).isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -131,4 +131,4 @@ public void sanityTestHashcode() {
 				.isEqualTo(same.hashCode())
 				.isNotEqualTo(different.hashCode());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple5Test.java
Patch:
@@ -121,7 +121,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i).isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -152,4 +152,4 @@ public void sanityTestHashcode() {
 				.isEqualTo(same.hashCode())
 				.isNotEqualTo(different.hashCode());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple6Test.java
Patch:
@@ -133,8 +133,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i)
-			                       .isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -165,4 +164,4 @@ public void sanityTestHashcode() {
 				.isEqualTo(same.hashCode())
 				.isNotEqualTo(different.hashCode());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple7Test.java
Patch:
@@ -148,7 +148,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i).isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -179,4 +179,4 @@ public void sanityTestHashcode() {
 				.isEqualTo(same.hashCode())
 				.isNotEqualTo(different.hashCode());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/function/Tuple8Test.java
Patch:
@@ -161,7 +161,7 @@ public void getAllValuesCorrespondToArray() {
 		Object[] array = full.toArray();
 
 		for (int i = 0; i < array.length; i++) {
-			assertThat(full.get(i)).as("element " + i).isEqualTo(array[i]);
+			assertThat(full.get(i)).as("element at %d", i).isEqualTo(array[i]);
 		}
 	}
 
@@ -194,4 +194,4 @@ public void sanityTestHashcode() {
 				.isEqualTo(same.hashCode())
 				.isNotEqualTo(different.hashCode());
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/retry/RetryBackoffSpecTest.java
Patch:
@@ -419,4 +419,4 @@ public void backoffSchedulerNullResetToDefaultSupplier() {
 		assertThat(spec.backoffSchedulerSupplier.get()).isSameAs(Schedulers.parallel());
 	}
 
-}
\ No newline at end of file
+}

File: reactor-core/src/test/java/reactor/util/retry/RetrySpecTest.java
Patch:
@@ -375,4 +375,4 @@ public void cumulatedRetryHooksWithTransient() {
 				"AsyncAfter D"
 		);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/FluxMetricsFuseableTest.java
Patch:
@@ -472,4 +472,4 @@ protected void hookOnSubscribe(Subscription subscription) {
 		assertThat(meter.totalAmount()).isEqualTo(108);
 		assertThat(meter.max()).isEqualTo(100);
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/FluxMetricsTest.java
Patch:
@@ -495,4 +495,4 @@ public void ensureOnNextInAsyncModeIsCapableToPropagateNulls() {
 		    .expectComplete()
 		    .verify(Duration.ofMillis(500));
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/MonoMetricsFuseableTest.java
Patch:
@@ -442,4 +442,4 @@ public void noRequestTrackingEvenForNamedSequence() {
 
 		assertThat(meter).as("tagged find").isNull();
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/MonoMetricsTest.java
Patch:
@@ -427,4 +427,4 @@ public void ensureOnNextInAsyncModeIsCapableToPropagateNulls() {
 		    .expectComplete()
 		    .verify(Duration.ofMillis(500));
 	}
-}
\ No newline at end of file
+}

File: reactor-core/src/withMicrometerTest/java/reactor/util/MetricsTest.java
Patch:
@@ -46,4 +46,4 @@ public void smokeTestMicrometerActiveInTests() {
 		assertThat(Metrics.isInstrumentationAvailable()).isTrue();
 	}
 
-}
\ No newline at end of file
+}

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -835,7 +835,7 @@ public void verifyConsumeSubscription() {
 		Mono<String> flux = Mono.just("foo");
 
 		StepVerifier.create(flux)
-		            .consumeSubscriptionWith(s -> assertThat(s).isInstanceOf(Fuseable.QueueSubscription.class))
+		            .consumeSubscriptionWith(s -> assertThat(s).withFailMessage("Non-fuseable: %s", s.getClass()).isInstanceOf(Fuseable.QueueSubscription.class))
 		            .expectNext("foo")
 		            .expectComplete()
 		            .verify();
@@ -847,7 +847,7 @@ public void verifyConsumeSubscriptionAfterFirst() {
 
 		StepVerifier.create(flux)
 		            .expectNext("foo")
-		            .consumeSubscriptionWith(s -> assertThat(s).isInstanceOf(Fuseable.QueueSubscription.class))
+		            .consumeSubscriptionWith(s -> assertThat(s).withFailMessage("Non-fuseable: %s", s.getClass()).isInstanceOf(Fuseable.QueueSubscription.class))
 		            .expectComplete()
 		            .verify();
 	}

File: reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java
Patch:
@@ -153,7 +153,7 @@ public void onComplete() {
 	             .emit("A", "B", "C")
 	             .error(new IllegalStateException("boom"));
 
-		assertThat(count.get()).isEqualTo(1);
+		assertThat(count).hasValue(1);
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstWithValue.java
Patch:
@@ -360,7 +360,7 @@ void recordTerminalSignals(Throwable t) {
 
 			if (nb == parent.subscribers.length) {
 				NoSuchElementException e = new NoSuchElementException("All sources completed with error or without values");
-				e.addSuppressed(Exceptions.multiple(parent.errorsOrCompleteEmpty));
+				e.initCause(Exceptions.multiple(parent.errorsOrCompleteEmpty));
 				actual.onError(e);
 			}
 		}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java
Patch:
@@ -180,7 +180,7 @@ public void sourceWithSignalButNeverCompletes() {
 		            .expectNext("foo")
 		            .verifyComplete();
 
-		testPublisher.assertWasCancelled();
+		testPublisher.assertWasNotCancelled(); //new behavior as of 3.4.0 for MonoMaterialize
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java
Patch:
@@ -137,6 +137,9 @@ else if (sub.isCancelled()) {
 		else if (cancelledCount + emittedCount == expectedEmitted) {
 			return EmitResult.OK;
 		}
+		else if (emittedCount > 0 && !allOrNothing) {
+			return EmitResult.OK;
+		}
 		else {
 			return EmitResult.FAIL_OVERFLOW;
 		}

File: reactor-core/src/test/java/reactor/test/AutoDisposingExtension.java
Patch:
@@ -36,7 +36,6 @@ public class AutoDisposingExtension implements BeforeTestExecutionCallback, Afte
 
 	@Override
 	public void beforeTestExecution(ExtensionContext context) throws Exception {
-		System.out.println("HELLO  " + context.getRequiredTestClass());
 		toDispose = Disposables.composite();
 	}
 

File: buildSrc/src/main/java/io/reactor/gradle/JavaConventions.java
Patch:
@@ -59,8 +59,8 @@ private void applyJavaConvention(Project project) {
 					       "-Xlint:processing",
 					       "-Xlint:static",
 					       "-Xlint:try",
-						   "-Xmaxerrs", "1000",
-						   "-Xmaxwarns", "1",
+						   "-Xmaxerrs", "500",
+						   "-Xmaxwarns", "500",
 					       "-Xlint:deprecation",
 					       "-Xlint:unchecked",
 					       "-Xlint:-serial",      // intentionally disabled

File: buildSrc/src/main/java/io/reactor/gradle/JavaConventions.java
Patch:
@@ -59,6 +59,8 @@ private void applyJavaConvention(Project project) {
 					       "-Xlint:processing",
 					       "-Xlint:static",
 					       "-Xlint:try",
+						   "-Xmaxerrs", "1000",
+						   "-Xmaxwarns", "1",
 					       "-Xlint:deprecation",
 					       "-Xlint:unchecked",
 					       "-Xlint:-serial",      // intentionally disabled

File: reactor-core/src/test/java/reactor/HooksTraceTest.java
Patch:
@@ -19,9 +19,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.junit.After;
+import org.junit.jupiter.api.AfterEach;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 
 import reactor.core.Scannable;
@@ -38,7 +38,7 @@
  */
 public class HooksTraceTest {
 
-	@After
+	@AfterEach
 	public void resetHooks() {
 		Hooks.resetOnEachOperator();
 		Hooks.resetOnLastOperator();

File: reactor-core/src/test/java/reactor/core/CoreTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Collections;
 
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.util.annotation.Nullable;
 
 import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

File: reactor-core/src/test/java/reactor/core/DisposableTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.Arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.FakeDisposable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
 import reactor.test.util.RaceTestUtils;

File: reactor-core/src/test/java/reactor/core/ListCompositeDisposableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposables.ListCompositeDisposable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;

File: reactor-core/src/test/java/reactor/core/ScannableTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Hooks;

File: reactor-core/src/test/java/reactor/core/publisher/BlockingOptionalMonoSubscriberTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/BlockingSingleSubscriberTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/ConnectableFluxOnAssemblyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/ContextTests.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.util.context.Context;

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/EventLoopProcessorTest.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.concurrent.TimeUnit;
 
 import org.assertj.core.api.Condition;
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -41,7 +41,7 @@ public class EventLoopProcessorTest {
 
 	EventLoopProcessor<String> test;
 
-	@Before
+	@BeforeEach
 	public void initProcessor() {
 		test = initProcessor(Executors.newSingleThreadExecutor());
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import reactor.core.Disposable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.function.Supplier;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java
Patch:
@@ -33,7 +33,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 
-import org.junit.After;
-import org.junit.Test;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
@@ -42,7 +42,7 @@
 
 public class FluxBufferTimeoutTest {
 
-	@After
+	@AfterEach
 	public void tearDown() {
 		VirtualTimeScheduler.reset();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxCacheTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.util.function.Tuple2;

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableOnAssemblyTest.java
Patch:
@@ -32,7 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.io.IOException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxCallableTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Iterator;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.function.Consumer;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatWithTest.java
Patch:
@@ -15,8 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
-
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.stream.IntStream;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferComposeTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxDeferComposeTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelaySequenceTest.java
Patch:
@@ -21,8 +21,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -103,7 +103,7 @@ public void delayFirstAsymmetricDelays() {
 		            .verifyComplete();
 	}
 
-	@Ignore("delayElements test for local comparison run")
+	@Disabled("delayElements test for local comparison run")
 	@Test
 	public void delayElements() {
 		Flux<Tuple2<Long, Long>> test = Flux.interval(Duration.ofMillis(50))

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelayUntilTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDematerializeTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.List;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDetachTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.awaitility.Awaitility;
 import org.awaitility.Duration;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFirstTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxElapsedTest.java
Patch:
@@ -17,8 +17,7 @@
 
 import java.time.Duration;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxEmptyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 public class FluxEmptyTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorSuppliedTest.java
Patch:
@@ -34,7 +34,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterFuseableTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxFirstEmittingWithTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Arrays;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxGroupJoinTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxHandleTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxHideTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxIndexTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Fuseable;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;

File: reactor-core/src/test/java/reactor/core/publisher/FluxIndexedFuseableTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.mockito.stubbing.Answer;
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxJoinTest.java
Patch:
@@ -19,11 +19,10 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMaterializeTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeOrderedTest.java
Patch:
@@ -18,14 +18,13 @@
 
 import java.io.IOException;
 import java.time.Duration;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeWithTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameFuseableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/FluxNeverTest.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxNeverTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.Objects;
 import java.util.stream.Stream;
 
-import org.junit.After;
-import org.junit.Test;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -35,7 +35,7 @@
 
 public class FluxOnAssemblyTest {
 
-	@After
+	@AfterEach
 	public void tearDown() {
 		Hooks.resetOnOperatorDebug();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnErrorResumeTest.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleFirstTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleTimeoutTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipUntilTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.List;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -15,9 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
-import org.reactivestreams.Subscription;
-import reactor.core.CoreSubscriber;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxStartWithTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnCallableTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.function.Function;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnValueTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.logging.Level;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchMapTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Disposables;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnNextTest.java
Patch:
@@ -16,10 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
-import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxSwitchOnNextTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxThenManyTest.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimestampTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.util.function.Tuple2;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -29,7 +29,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeoutTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/InnerProducerTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/LambdaMonoSubscriberTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/LambdaSubscriberTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.awaitility.Awaitility;
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import reactor.core.Fuseable;
 
@@ -143,7 +143,7 @@ public void liftConnectableLiftFuseableWithCancelSupport() {
 				.untilAsserted(() -> assertThat(cancelSupportInvoked).isTrue());
 	}
 
-	@Ignore("GroupedFlux is always fuseable for now")
+	@Disabled("GroupedFlux is always fuseable for now")
 	@Test
 	public void liftGroupedFlux() {
 		Flux<GroupedFlux<String, Integer>> sourceGroups = Flux

File: reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.Disposable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCallableOnAssemblyTest.java
Patch:
@@ -32,7 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectListTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectMapTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.Arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCompletionStageTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferComposeTest.java
Patch:
@@ -17,8 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
-
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class MonoDeferComposeTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class MonoDeferTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java
Patch:
@@ -19,14 +19,12 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class MonoDematerializeTest {
@@ -114,7 +114,7 @@ public void errorAfterSingleSignal() {
 	}
 
 	@Test
-	@Ignore("use virtual time?")
+	@Disabled("use virtual time?")
 	public void neverEnding() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDetachTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.awaitility.Awaitility;
 import org.awaitility.Duration;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoFirstTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoElapsedTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoEmptyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 public class MonoEmptyTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoErrorSuppliedTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapManyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoHandleTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 import static java.util.Collections.singleton;

File: reactor-core/src/test/java/reactor/core/publisher/MonoHideTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Fuseable;
 
 import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnoreEmptyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoMaterializeTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameFuseableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/MonoNeverTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class MonoNeverTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoNextTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnAssemblyTest.java
Patch:
@@ -32,7 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnErrorResumeTest.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekAfterTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.LongAdder;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTerminalTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java
Patch:
@@ -22,8 +22,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Assert;
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryPredicateTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 public class MonoRetryPredicateTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryWhenTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.assertj.core.data.Percentage;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java
Patch:
@@ -16,15 +16,14 @@
 package reactor.core.publisher;
 
 import java.time.Duration;
-import java.util.Comparator;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.LongAdder;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -144,7 +143,7 @@ public void largeSequence() {
 		            .verify(Duration.ofSeconds(5));
 	}
 
-		@Test
+	@Test
 	public void syncFusedCrash() {
 		Flux<Integer> source = Flux.range(1, 10).map(i -> { throw new IllegalArgumentException("boom"); });
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoSingleMonoTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.NoSuchElementException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoStreamCollectorTest.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnCallableTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnValueTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Operators.MonoSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoTakeLastOneTest.java
Patch:
@@ -16,14 +16,12 @@
 package reactor.core.publisher;
 
 import java.util.NoSuchElementException;
-import java.util.function.Predicate;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
-import reactor.util.function.Tuple3;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoTakeUntilOtherTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.scheduler.VirtualTimeScheduler;

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenIgnoreTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenManyTest.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.time.Duration;
 import java.util.concurrent.TimeoutException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimestampTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.util.function.Tuple2;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoToCompletableFutureTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingWhenTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Arrays;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/OnNextFailureStrategyTest.java
Patch:
@@ -20,8 +20,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.assertj.core.util.Arrays;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.Exceptions;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -37,7 +37,7 @@
 import javax.annotation.Nullable;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelArraySourceTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelCollectTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.function.Supplier;
 import java.util.logging.Level;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelConcatMapTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.util.concurrent.Queues;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFilterTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFlatMapTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.concurrent.Queues;
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxHideTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxNameTest.java
Patch:
@@ -17,11 +17,10 @@
 package reactor.core.publisher;
 
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxOnAssemblyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelGroupTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLiftTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLogTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMapTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeOrderedTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Comparator;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeReduceTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeSequentialTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeSortTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelPeekTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.util.concurrent.Queues;
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelReduceSeedTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.function.Supplier;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelRunOnTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelSourceTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/QueueDrainSubscriberTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.openjdk.jol.info.ClassLayout;
 import org.openjdk.jol.info.FieldLayout;
 

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -21,8 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.awaitility.Awaitility;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/SignalLoggerTests.java
Patch:
@@ -21,11 +21,10 @@
 import java.util.logging.Level;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
 
-import reactor.core.CoreTest;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.SynchronousSubscription;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/SignalTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.test.StepVerifier;
 import reactor.util.context.Context;

File: reactor-core/src/test/java/reactor/core/publisher/StrictSubscriberTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/TracesTest.java
Patch:
@@ -32,8 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
-import reactor.core.publisher.Traces;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/loop/FluxGroupByLoop.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher.loop;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.FluxGroupByTest;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FizzBuzzTests.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.TopicProcessor;

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxWindowConsistencyTest.java
Patch:
@@ -24,8 +24,8 @@
 
 import static org.junit.Assert.assertEquals;
 
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.publisher.DirectProcessor;
 import reactor.core.publisher.Flux;
@@ -56,7 +56,7 @@ public class FluxWindowConsistencyTest {
 
 	private AtomicInteger mainTerminated = new AtomicInteger();
 
-	@Before
+	@BeforeEach
 	public void setUp() {
 		source = sourceProcessor.doOnNext(i -> sourceCount.incrementAndGet());
 	}

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.util.Loggers;
 import reactor.core.publisher.Flux;

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -21,12 +21,10 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.subscriber.AssertSubscriber;
 
 public class ScatterGatherTests {
 

File: reactor-core/src/test/java/reactor/core/scheduler/DelegateServiceSchedulerTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.jetbrains.annotations.NotNull;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTrampolineTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.Executor;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/scheduler/ImmediateSchedulerTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler.Worker;

File: reactor-core/src/test/java/reactor/core/scheduler/InstantPeriodicWorkerTaskTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.test.util.RaceTestUtils;

File: reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.junit.*;
 
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.*;
 import reactor.core.scheduler.Scheduler.Worker;

File: reactor-core/src/test/java/reactor/core/scheduler/SingleWorkerSchedulerTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.scheduler;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: buildSrc/src/main/java/io/reactor/gradle/JavaConventions.java
Patch:
@@ -59,6 +59,8 @@ private void applyJavaConvention(Project project) {
 					       "-Xlint:processing",
 					       "-Xlint:static",
 					       "-Xlint:try",
+						   "-Xmaxerrs", "1000",
+						   "-Xmaxwarns", "1",
 					       "-Xlint:deprecation",
 					       "-Xlint:unchecked",
 					       "-Xlint:-serial",      // intentionally disabled

File: reactor-core/src/test/java/reactor/HooksTraceTest.java
Patch:
@@ -19,9 +19,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.junit.After;
+import org.junit.jupiter.api.AfterEach;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 
 import reactor.core.Scannable;
@@ -38,7 +38,7 @@
  */
 public class HooksTraceTest {
 
-	@After
+	@AfterEach
 	public void resetHooks() {
 		Hooks.resetOnEachOperator();
 		Hooks.resetOnLastOperator();

File: reactor-core/src/test/java/reactor/core/CoreTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Collections;
 
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.util.annotation.Nullable;
 
 import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

File: reactor-core/src/test/java/reactor/core/DisposableTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.Arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.FakeDisposable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
 import reactor.test.util.RaceTestUtils;

File: reactor-core/src/test/java/reactor/core/ListCompositeDisposableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposables.ListCompositeDisposable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;

File: reactor-core/src/test/java/reactor/core/ScannableTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Hooks;

File: reactor-core/src/test/java/reactor/core/publisher/BlockingOptionalMonoSubscriberTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/BlockingSingleSubscriberTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/ConnectableFluxOnAssemblyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/ContextTests.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.util.context.Context;

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/EventLoopProcessorTest.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.concurrent.TimeUnit;
 
 import org.assertj.core.api.Condition;
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -41,7 +41,7 @@ public class EventLoopProcessorTest {
 
 	EventLoopProcessor<String> test;
 
-	@Before
+	@BeforeEach
 	public void initProcessor() {
 		test = initProcessor(Executors.newSingleThreadExecutor());
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import reactor.core.Disposable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.function.Supplier;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java
Patch:
@@ -33,7 +33,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 
-import org.junit.After;
-import org.junit.Test;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
@@ -42,7 +42,7 @@
 
 public class FluxBufferTimeoutTest {
 
-	@After
+	@AfterEach
 	public void tearDown() {
 		VirtualTimeScheduler.reset();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxCacheTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.util.function.Tuple2;

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableOnAssemblyTest.java
Patch:
@@ -32,7 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.io.IOException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxCallableTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Iterator;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.function.Consumer;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatWithTest.java
Patch:
@@ -15,8 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
-
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.stream.IntStream;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferComposeTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxDeferComposeTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelaySequenceTest.java
Patch:
@@ -21,8 +21,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -103,7 +103,7 @@ public void delayFirstAsymmetricDelays() {
 		            .verifyComplete();
 	}
 
-	@Ignore("delayElements test for local comparison run")
+	@Disabled("delayElements test for local comparison run")
 	@Test
 	public void delayElements() {
 		Flux<Tuple2<Long, Long>> test = Flux.interval(Duration.ofMillis(50))

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelayUntilTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDematerializeTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.List;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDetachTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.awaitility.Awaitility;
 import org.awaitility.Duration;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFirstTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxElapsedTest.java
Patch:
@@ -17,8 +17,7 @@
 
 import java.time.Duration;
 
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxEmptyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 public class FluxEmptyTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorSuppliedTest.java
Patch:
@@ -34,7 +34,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterFuseableTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxFirstEmittingWithTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Arrays;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxGroupJoinTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxHandleTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxHideTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxIndexTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Fuseable;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;

File: reactor-core/src/test/java/reactor/core/publisher/FluxIndexedFuseableTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.mockito.stubbing.Answer;
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxJoinTest.java
Patch:
@@ -19,11 +19,10 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMaterializeTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeOrderedTest.java
Patch:
@@ -18,14 +18,13 @@
 
 import java.io.IOException;
 import java.time.Duration;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeWithTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameFuseableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/FluxNeverTest.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxNeverTest {

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.Objects;
 import java.util.stream.Stream;
 
-import org.junit.After;
-import org.junit.Test;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -35,7 +35,7 @@
 
 public class FluxOnAssemblyTest {
 
-	@After
+	@AfterEach
 	public void tearDown() {
 		Hooks.resetOnOperatorDebug();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnErrorResumeTest.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleFirstTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleTimeoutTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipUntilTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.List;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -15,9 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
-import org.reactivestreams.Subscription;
-import reactor.core.CoreSubscriber;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxStartWithTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnCallableTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.function.Function;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnValueTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.logging.Level;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchMapTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Disposables;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnNextTest.java
Patch:
@@ -16,10 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
-import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxSwitchOnNextTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxThenManyTest.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimestampTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.util.function.Tuple2;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -29,7 +29,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeoutTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/InnerProducerTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/LambdaMonoSubscriberTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/LambdaSubscriberTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.awaitility.Awaitility;
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import reactor.core.Fuseable;
 
@@ -143,7 +143,7 @@ public void liftConnectableLiftFuseableWithCancelSupport() {
 				.untilAsserted(() -> assertThat(cancelSupportInvoked).isTrue());
 	}
 
-	@Ignore("GroupedFlux is always fuseable for now")
+	@Disabled("GroupedFlux is always fuseable for now")
 	@Test
 	public void liftGroupedFlux() {
 		Flux<GroupedFlux<String, Integer>> sourceGroups = Flux

File: reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.Disposable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCallableOnAssemblyTest.java
Patch:
@@ -32,7 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectListTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectMapTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.Arrays;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCompletionStageTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferComposeTest.java
Patch:
@@ -17,8 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
-
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class MonoDeferComposeTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class MonoDeferTest {
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java
Patch:
@@ -19,14 +19,12 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class MonoDematerializeTest {
@@ -114,7 +114,7 @@ public void errorAfterSingleSignal() {
 	}
 
 	@Test
-	@Ignore("use virtual time?")
+	@Disabled("use virtual time?")
 	public void neverEnding() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDetachTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.awaitility.Awaitility;
 import org.awaitility.Duration;
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoFirstTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Fuseable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoElapsedTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoEmptyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 public class MonoEmptyTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoErrorSuppliedTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapManyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoHandleTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 import static java.util.Collections.singleton;

File: reactor-core/src/test/java/reactor/core/publisher/MonoHideTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Fuseable;
 
 import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnoreEmptyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoMaterializeTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameFuseableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/MonoNeverTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class MonoNeverTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoNextTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnAssemblyTest.java
Patch:
@@ -32,7 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnErrorResumeTest.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekAfterTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.LongAdder;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTerminalTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java
Patch:
@@ -22,8 +22,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Assert;
-import org.junit.Ignore;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryPredicateTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 public class MonoRetryPredicateTest {

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryWhenTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.assertj.core.data.Percentage;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java
Patch:
@@ -16,15 +16,14 @@
 package reactor.core.publisher;
 
 import java.time.Duration;
-import java.util.Comparator;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.LongAdder;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -144,7 +143,7 @@ public void largeSequence() {
 		            .verify(Duration.ofSeconds(5));
 	}
 
-		@Test
+	@Test
 	public void syncFusedCrash() {
 		Flux<Integer> source = Flux.range(1, 10).map(i -> { throw new IllegalArgumentException("boom"); });
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoSingleMonoTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.NoSuchElementException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoStreamCollectorTest.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnCallableTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.io.IOException;
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscribeOnValueTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Operators.MonoSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoTakeLastOneTest.java
Patch:
@@ -16,14 +16,12 @@
 package reactor.core.publisher;
 
 import java.util.NoSuchElementException;
-import java.util.function.Predicate;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
-import reactor.util.function.Tuple3;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoTakeUntilOtherTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.time.Duration;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.scheduler.VirtualTimeScheduler;

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenIgnoreTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenManyTest.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.time.Duration;
 import java.util.concurrent.TimeoutException;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimestampTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.test.StepVerifier;
 import reactor.util.function.Tuple2;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoToCompletableFutureTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingWhenTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Arrays;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/OnNextFailureStrategyTest.java
Patch:
@@ -20,8 +20,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.assertj.core.util.Arrays;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.Exceptions;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -37,7 +37,7 @@
 import javax.annotation.Nullable;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelArraySourceTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelCollectTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.function.Supplier;
 import java.util.logging.Level;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelConcatMapTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.util.concurrent.Queues;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFilterTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFlatMapTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.concurrent.Queues;
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxHideTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxNameTest.java
Patch:
@@ -17,11 +17,10 @@
 package reactor.core.publisher;
 
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.Set;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxOnAssemblyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelGroupTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLiftTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelLogTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMapTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeOrderedTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Comparator;
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeReduceTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeSequentialTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelMergeSortTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.List;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelPeekTest.java
Patch:
@@ -16,9 +16,8 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
-import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.util.concurrent.Queues;
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelReduceSeedTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.function.Supplier;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelRunOnTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelSourceTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/QueueDrainSubscriberTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.openjdk.jol.info.ClassLayout;
 import org.openjdk.jol.info.FieldLayout;
 

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -21,8 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.awaitility.Awaitility;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/SignalLoggerTests.java
Patch:
@@ -21,11 +21,10 @@
 import java.util.logging.Level;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
 
-import reactor.core.CoreTest;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.SynchronousSubscription;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/SignalTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.test.StepVerifier;
 import reactor.util.context.Context;

File: reactor-core/src/test/java/reactor/core/publisher/StrictSubscriberTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/core/publisher/TracesTest.java
Patch:
@@ -32,8 +32,7 @@
 
 package reactor.core.publisher;
 
-import org.junit.Test;
-import reactor.core.publisher.Traces;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/loop/FluxGroupByLoop.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher.loop;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.FluxGroupByTest;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FizzBuzzTests.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.junit.Assert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.TopicProcessor;

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxWindowConsistencyTest.java
Patch:
@@ -24,8 +24,8 @@
 
 import static org.junit.Assert.assertEquals;
 
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.publisher.DirectProcessor;
 import reactor.core.publisher.Flux;
@@ -56,7 +56,7 @@ public class FluxWindowConsistencyTest {
 
 	private AtomicInteger mainTerminated = new AtomicInteger();
 
-	@Before
+	@BeforeEach
 	public void setUp() {
 		source = sourceProcessor.doOnNext(i -> sourceCount.incrementAndGet());
 	}

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.util.Loggers;
 import reactor.core.publisher.Flux;

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -21,12 +21,10 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.subscriber.AssertSubscriber;
 
 public class ScatterGatherTests {
 

File: reactor-core/src/test/java/reactor/core/scheduler/DelegateServiceSchedulerTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTest.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.jetbrains.annotations.NotNull;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 

File: reactor-core/src/test/java/reactor/core/scheduler/ExecutorSchedulerTrampolineTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.Executor;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/scheduler/ImmediateSchedulerTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler.Worker;

File: reactor-core/src/test/java/reactor/core/scheduler/InstantPeriodicWorkerTaskTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.test.util.RaceTestUtils;

File: reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.junit.*;
 
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 import reactor.core.publisher.*;
 import reactor.core.scheduler.Scheduler.Worker;

File: reactor-core/src/test/java/reactor/core/scheduler/SingleWorkerSchedulerTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.scheduler;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.Scannable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -54,8 +54,9 @@
  * @author Stephane Maldini
  * @deprecated To be removed in 3.5. Prefer clear cut usage of {@link Sinks} through
  * variations of {@link Sinks.MulticastSpec#onBackpressureBuffer() Sinks.many().multicast().onBackpressureBuffer()}.
- * This processor is blocking on {@link EmitterProcessor#emitNext(T)}. This behaviour can be implemented
- * with the {@link Sinks} API by calling {@link Sinks#many()#tryEmitNext(T)} and retrying, e.g.:
+ * This processor was blocking in {@link EmitterProcessor#onNext(Object)}.
+ * This behaviour can be implemented with the {@link Sinks} API by calling
+ * {@link Sinks.Many#tryEmitNext(Object)} and retrying, e.g.:
  * <pre>{@code while (sink.tryEmitNext(v).hasFailed()) {
  *     LockSupport.parkNanos(10);
  * }

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -61,9 +61,9 @@
  * <p>
  * Use {@link #runOn} to introduce where each 'rail' should run on thread-wise.
  * <p>
- * Use {@link #sequential)} to merge the sources back into a single {@link Flux}.
+ * Use {@link #sequential} to merge the sources back into a single {@link Flux}.
  * <p>
- * Use {@link #then)} to listen for all rails termination in the produced {@link Mono}
+ * Use {@link #then} to listen for all rails termination in the produced {@link Mono}
  * <p>
  * {@link #subscribe(Subscriber)} if you simply want to subscribe to the merged sequence.
  * Note that other variants like {@link #subscribe(Consumer)} instead do multiple

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -220,7 +220,8 @@ public static boolean isFactoryEnabled() {
 	}
 
 	/**
-	 * Re-activate the global {@link Schedulers} and potentially customized {@link Schedulers.Factory} that were
+	 * Re-activate the global {@link Schedulers} and potentially customized
+	 * {@link reactor.core.scheduler.Schedulers.Factory} that were
 	 * active prior to last activation of {@link VirtualTimeScheduler} factories. (ie the
 	 * last {@link #set(VirtualTimeScheduler) set} or {@link #getOrSet() getOrSet}).
 	 * <p>

File: reactor-core/src/main/java/reactor/core/publisher/DelegateProcessor.java
Patch:
@@ -30,6 +30,7 @@
 /**
  * @author Stephane Maldini
  */
+@Deprecated
 final class DelegateProcessor<IN, OUT> extends FluxProcessor<IN, OUT> {
 
 	final Publisher<OUT> downstream;

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7575,7 +7575,9 @@ public final Flux<T> share() {
 	 * @return a new {@link Mono}
 	 */
 	public final Mono<T> shareNext() {
-		return Mono.onAssembly(new NextProcessor<>(this));
+		@SuppressWarnings("deprecation") //TODO NextProcessor will be turned into an internal class only in 3.5
+		final NextProcessor<T> nextProcessor = new NextProcessor<>(this);
+		return Mono.onAssembly(nextProcessor);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/NextProcessor.java
Patch:
@@ -18,6 +18,7 @@
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
 
+@Deprecated
 class NextProcessor<O> extends MonoProcessor<O> implements InternalOneSink<O> {
 
 	volatile NextInner<O>[] subscribers;

File: reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java
Patch:
@@ -92,7 +92,9 @@ public <T> Empty<T> empty() {
 
 		@Override
 		public <T> One<T> one() {
-			return wrapOne(new NextProcessor<>(null));
+			@SuppressWarnings("deprecation") //TODO NextProcessor will be turned into an internal class only in 3.5
+			final NextProcessor<T> original = new NextProcessor<>(null);
+			return wrapOne(original);
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -24,6 +24,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.when;
 
+@SuppressWarnings("deprecation")
 public class DelegateProcessorTest {
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -213,14 +213,14 @@ public void subscriberCancels() {
 
 		AtomicInteger cleanup = new AtomicInteger();
 
-		NextProcessor<Integer> tp = new NextProcessor<>(null);
+		Sinks.One<Integer> tp = Sinks.unsafe().one();
 
-		Mono.using(() -> 1, r -> tp, cleanup::set, true)
+		Mono.using(() -> 1, r -> tp.asMono(), cleanup::set, true)
 		    .subscribe(ts);
 
 		assertThat(tp.currentSubscriberCount()).as("tp has subscriber").isPositive();
 
-		tp.onNext(1);
+		tp.tryEmitValue(1).orThrow();
 
 		ts.assertValues(1)
 		  .assertComplete()

File: reactor-core/src/test/java/reactor/core/publisher/NextProcessorTest.java
Patch:
@@ -41,6 +41,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 
+@SuppressWarnings("deprecation")
 public class NextProcessorTest {
 
 	@Test

File: reactor-core/src/jcstress/java/reactor/core/publisher/SinkOneSerializedStressTest.java
Patch:
@@ -60,15 +60,15 @@ static class TargetSink<T> extends SinkEmptySerializedStressTest.TargetSink<T> i
 		final AtomicInteger onValueCall = new AtomicInteger();
 
 		@Override
-		public Sinks.Emission tryEmitValue(T value) {
+		public Sinks.EmitResult tryEmitValue(T value) {
 			if (!guard.compareAndSet(null, StressSubscriber.Operation.ON_COMPLETE)) {
 				throw new IllegalStateException("SinkOneSerialized should protect from non-serialized access");
 			}
 
 			LockSupport.parkNanos(10);
 			onValueCall.incrementAndGet();
 			guard.compareAndSet(StressSubscriber.Operation.ON_COMPLETE, null);
-			return done.compareAndSet(false, true) ? Sinks.Emission.OK : Sinks.Emission.FAIL_TERMINATED;
+			return done.compareAndSet(false, true) ? Sinks.EmitResult.OK : Sinks.EmitResult.FAIL_TERMINATED;
 		}
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/SinkOneSerialized.java
Patch:
@@ -25,10 +25,10 @@ public SinkOneSerialized(One<T> sinkOne, ContextHolder contextHolder) {
 	}
 
 	@Override
-	public Sinks.Emission tryEmitValue(T t) {
+	public Sinks.EmitResult tryEmitValue(T t) {
 		Thread currentThread = Thread.currentThread();
 		if (!tryAcquire(currentThread)) {
-			return Sinks.Emission.FAIL_NON_SERIALIZED;
+			return Sinks.EmitResult.FAIL_NON_SERIALIZED;
 		}
 
 		try {

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -134,7 +134,7 @@ public void singleSubscriberOnly() {
 		//using an emit below would terminate the sink with an error
 		assertThat(source2.tryEmitNext(10))
 				.as("early emit in source2")
-				.isEqualTo(Sinks.Emission.FAIL_ZERO_SUBSCRIBER);
+				.isEqualTo(Sinks.EmitResult.FAIL_ZERO_SUBSCRIBER);
 
 		source1.tryEmitComplete().orThrow();
 		source.emitComplete(FAIL_FAST);
@@ -173,7 +173,7 @@ public void singleSubscriberOnlyBoundary() {
 		//using an emit below would terminate the sink with an error
 		assertThat(source2.tryEmitNext(10))
 				.as("early emit in source2")
-				.isEqualTo(Sinks.Emission.FAIL_ZERO_SUBSCRIBER);
+				.isEqualTo(Sinks.EmitResult.FAIL_ZERO_SUBSCRIBER);
 
 		source1.tryEmitComplete().orThrow();
 		source.emitNext(2, FAIL_FAST);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1189,7 +1189,7 @@ public void mapNotifiesOnce() throws InterruptedException {
 		final long start = System.currentTimeMillis();
 		for (int i = 0; i < COUNT; i++) {
 			long busyLoops = 0;
-			while (s.tryEmitNext(i).hasFailed()) {
+			while (s.tryEmitNext(i).isFailure()) {
 				busyLoops++;
 				if (busyLoops % 5000 == 0 && System.currentTimeMillis() - start >= 10_0000) {
 					throw new RuntimeException("Busy loop timed out");
@@ -1236,7 +1236,7 @@ public void mapManyFlushesAllValuesThoroughly() throws InterruptedException {
 		final long start = System.currentTimeMillis();
 		for (int i = 1; i <= items; i++) {
 			long busyLoops = 0;
-			while (s.tryEmitNext(String.valueOf(i)).hasFailed()) {
+			while (s.tryEmitNext(String.valueOf(i)).isFailure()) {
 				busyLoops++;
 				if (busyLoops % 5000 == 0 && System.currentTimeMillis() - start >= 10_0000) {
 					throw new RuntimeException("Busy loop timed out");

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxSpecTests.java
Patch:
@@ -1107,7 +1107,7 @@ public void collectFromMultipleThread1() throws Exception {
 		final long start = System.currentTimeMillis();
 		Flux.range(1, 1000).subscribe(data -> {
 			long busyLoops = 0;
-			while(head.tryEmitNext(data).hasFailed()) {
+			while(head.tryEmitNext(data).isFailure()) {
 				busyLoops++;
 				if (busyLoops % 5000 == 0 && System.currentTimeMillis() - start >= 10_0000) {
 					throw new RuntimeException("Busy loop timed out");

File: reactor-core/src/main/java/reactor/core/publisher/DelegateSinkFluxProcessor.java
Patch:
@@ -74,7 +74,7 @@ public void subscribe(CoreSubscriber<? super IN> actual) {
 
 	@Override
 	public boolean isSerialized() {
-		return sink instanceof SerializedManySink;
+		return sink instanceof SinkManySerialized;
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/DelegateSinkFluxProcessor.java
Patch:
@@ -48,17 +48,17 @@ public Context currentContext() {
 
 	@Override
 	public void onComplete() {
-		sink.emitComplete();
+		sink.emitComplete(Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
 	public void onError(Throwable t) {
-		sink.emitError(t);
+		sink.emitError(t, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
 	public void onNext(IN in) {
-		sink.emitNext(in);
+		sink.emitNext(in, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/DelegateSinkOneMonoProcessor.java
Patch:
@@ -49,17 +49,17 @@ public Context currentContext() {
 
 	@Override
 	public void onComplete() {
-		sink.emitEmpty();
+		sink.emitEmpty(Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
 	public void onError(Throwable t) {
-		sink.emitError(t);
+		sink.emitError(t, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
 	public void onNext(@Nullable IN in) {
-		sink.emitValue(in);
+		sink.emitValue(in, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -224,7 +224,7 @@ public Emission tryEmitComplete() {
 
 	@Override
 	public void onError(Throwable throwable) {
-		emitError(throwable);
+		emitError(throwable, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
@@ -249,7 +249,7 @@ public void onNext(T t) {
 			drain();
 			return;
 		}
-		emitNext(t);
+		emitNext(t, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -160,7 +160,7 @@ public void onComplete() {
 			}
 
 			otherArbiter.request(1);
-			signaller.emitNext(p);
+			signaller.emitNext(p, Sinks.EmitFailureHandler.FAIL_FAST);
 		}
 
 		void setWhen(Subscription w) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -188,7 +188,7 @@ public void onError(Throwable t) {
 
 			otherArbiter.request(1);
 
-			signaller.emitNext(this);
+			signaller.emitNext(this, Sinks.EmitFailureHandler.FAIL_FAST);
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/NextProcessor.java
Patch:
@@ -14,6 +14,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.core.publisher.Sinks.Emission;
+import reactor.core.publisher.Sinks.EmitFailureHandler;
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
 
@@ -137,7 +138,7 @@ public Emission tryEmitEmpty() {
 
 	@Override
 	public final void onError(Throwable cause) {
-		emitError(cause);
+		emitError(cause, EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
@@ -162,7 +163,7 @@ public Emission tryEmitError(Throwable cause) {
 
 	@Override
 	public final void onNext(@Nullable O value) {
-		emitValue(value);
+		emitValue(value, EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -463,7 +463,7 @@ public Emission tryEmitComplete() {
 
 	@Override
 	public void onError(Throwable throwable) {
-		emitError(throwable);
+		emitError(throwable, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
@@ -486,7 +486,7 @@ public Emission tryEmitError(Throwable t) {
 
 	@Override
 	public void onNext(T t) {
-		emitNext(t);
+		emitNext(t, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -256,7 +256,7 @@ public Emission tryEmitComplete() {
 
 	@Override
 	public void onError(Throwable throwable) {
-		emitError(throwable);
+		emitError(throwable, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
@@ -279,7 +279,7 @@ public Emission tryEmitError(Throwable t) {
 
 	@Override
 	public void onNext(T t) {
-		emitNext(t);
+		emitNext(t, Sinks.EmitFailureHandler.FAIL_FAST);
 	}
 
 	@Override
@@ -302,7 +302,7 @@ public void emitNext(T value, Sinks.EmitFailureHandler failureHandler) {
 								}
 								catch (Throwable e) {
 									Exceptions.throwIfFatal(e);
-									emitError(e);
+									emitError(e, Sinks.EmitFailureHandler.FAIL_FAST);
 								}
 								break;
 						}

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -44,6 +44,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static reactor.core.Scannable.from;
+import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
 
 public class FluxBufferTimeoutTest {
 
@@ -227,7 +228,7 @@ public void requestedFromUpstreamShouldNotExceedDownstreamDemand() {
 		            .then(() -> assertThat(requestedOutstanding.get()).isEqualTo(0))
 		            .thenRequest(2)
 		            .then(() -> assertThat(requestedOutstanding.get()).isEqualTo(10))
-		            .then(() -> sink.emitNext("a"))
+		            .then(() -> sink.emitNext("a", FAIL_FAST))
 		            .thenAwait(Duration.ofMillis(100))
 		            .assertNext(s -> assertThat(s).containsExactly("a"))
 		            .then(() -> assertThat(requestedOutstanding.get()).isEqualTo(9))

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -37,6 +37,7 @@
 import reactor.test.subscriber.AssertSubscriber;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
 
 public class FluxUsingTest extends FluxOperatorTest<String, String> {
 
@@ -270,15 +271,15 @@ public void subscriberCancels() {
 
 		assertThat(tp.currentSubscriberCount()).as("tp has subscriber").isPositive();
 
-		tp.emitNext(1);
+		tp.emitNext(1, FAIL_FAST);
 
 		ts.assertValues(1)
 		  .assertNotComplete()
 		  .assertNoError();
 
 		ts.cancel();
 
-		tp.emitNext(2);
+		tp.emitNext(2, FAIL_FAST);
 
 		ts.assertValues(1)
 		  .assertNotComplete()

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -26,6 +26,7 @@
 import reactor.test.subscriber.AssertSubscriber;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
 
 public class MonoTimeoutTest {
 
@@ -90,7 +91,7 @@ public void timeoutRequested() {
 		source.timeout(tp.asFlux())
 		      .subscribe(ts);
 
-		tp.emitNext(1);
+		tp.emitNext(1, FAIL_FAST);
 
 		source.onNext(2);
 		source.onComplete();

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -46,6 +46,7 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.assertTrue;
+import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
 
 /**
  * @author Stephane Maldini
@@ -215,7 +216,7 @@ public void promiseDelays() throws Exception {
 	@Test
 	public void testMono() throws Exception {
 		Sinks.One<String> promise = Sinks.one();
-		promise.emitValue("test");
+		promise.emitValue("test", FAIL_FAST);
 		final CountDownLatch successCountDownLatch = new CountDownLatch(1);
 		promise.asMono().subscribe(v -> successCountDownLatch.countDown());
 		assertThat("Failed", successCountDownLatch.await(10, TimeUnit.SECONDS));

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -54,6 +54,7 @@
 import static org.assertj.core.api.Assertions.*;
 import static org.awaitility.Awaitility.await;
 import static org.junit.Assert.fail;
+import static reactor.core.publisher.Sinks.EmitFailureHandler.FAIL_FAST;
 
 public class SchedulersTest {
 
@@ -674,7 +675,7 @@ public void assertRejectingScheduler(Scheduler scheduler) {
 
 			scheduler.dispose();
 
-			p.emitNext("reject me");
+			p.emitNext("reject me", FAIL_FAST);
 			l.await(3, TimeUnit.SECONDS);
 		}
 		catch (Exception ree) {

File: reactor-core/src/main/java/reactor/core/publisher/Sinks.java
Patch:
@@ -55,7 +55,7 @@ private Sinks() {
 	 * Use {@link Sinks.Empty#asMono()} to expose the {@link Mono} view of the sink to downstream consumers.
 	 */
 	public static <T> Sinks.Empty<T> empty() {
-		return new VoidProcessor<T>();
+		return new SinkEmptyMulticast<T>();
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/GroupedFlux.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.publisher;
 
 
-import reactor.util.annotation.Nullable;
+import reactor.util.annotation.NonNull;
 
 /**
  * Represents a sequence of events which has an associated key.
@@ -30,6 +30,6 @@ public abstract class GroupedFlux<K, V> extends Flux<V> {
 	 * Return the key of the {@link GroupedFlux}.
 	 * @return the key
 	 */
-	@Nullable
+	@NonNull
 	public abstract K key();
 }

File: reactor-core/src/main/java/reactor/core/publisher/Sinks.java
Patch:
@@ -23,6 +23,7 @@
 
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
+import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
@@ -504,7 +505,7 @@ public interface MulticastReplaySpec {
 	 * @author Simon Baslé
 	 * @author Stephane Maldini
 	 */
-	public interface Many<T> {
+	public interface Many<T> extends Scannable {
 
 		/**
 		 * Try emitting a non-null element, generating an {@link Subscriber#onNext(Object) onNext} signal.
@@ -629,7 +630,7 @@ public interface Many<T> {
 	 * @author Simon Baslé
 	 * @author Stephane Maldini
 	 */
-	public interface Empty<T> {
+	public interface Empty<T> extends Scannable {
 
 		/**
 		 * Try to complete the {@link Mono} without a value, generating only an {@link Subscriber#onComplete() onComplete} signal.

File: reactor-core/src/main/java/reactor/core/scheduler/BoundedElasticScheduler.java
Patch:
@@ -148,7 +148,7 @@ public String toString() {
 	 * @param ttlSeconds the time-to-live (TTL) of idle threads, in seconds
 	 */
 	BoundedElasticScheduler(int maxThreads, int maxTaskQueuedPerThread, ThreadFactory factory, int ttlSeconds) {
-		this(maxThreads, maxTaskQueuedPerThread, factory, ttlSeconds * 1000,
+		this(maxThreads, maxTaskQueuedPerThread, factory, ttlSeconds * 1000L,
 				Clock.tickSeconds(BoundedServices.ZONE_UTC));
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeSequentialTest.java
Patch:
@@ -185,7 +185,7 @@ public void mainErrorsImmediate() {
 
 		main.emitError(new RuntimeException("Forced failure"));
 
-		assertFalse("inner has subscribers?", Scannable.from(inner).inners().count() != 0);
+		assertThat(inner.currentSubscriberCount()).as("inner has subscriber").isZero();
 
 		inner.emitNext(3);
 		inner.emitComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -429,7 +429,7 @@ public void disconnect() {
 		.assertError(CancellationException.class)
 		.assertNotComplete();
 
-		Assert.assertFalse("sp has subscribers?", Scannable.from(e).inners().count() != 0);
+		assertThat(e.currentSubscriberCount()).as("still connected").isZero();
 	}
 
 	@Test
@@ -450,7 +450,7 @@ public void disconnectBackpressured() {
 		.assertError(CancellationException.class)
 		.assertNotComplete();
 
-		Assert.assertFalse("sp has subscribers?", Scannable.from(e).inners().count() != 0);
+		assertThat(e.currentSubscriberCount()).as("still connected").isZero();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -126,7 +126,7 @@ public void oldTimeoutHasNoEffect() {
 
 		source.emitComplete();
 
-		Assert.assertFalse("Timeout has subscribers?", Scannable.from(tp).inners().count() != 0);
+		assertThat(tp.currentSubscriberCount()).as("timeout has subscriber").isZero();
 
 		ts.assertValues(0)
 		  .assertComplete()
@@ -176,7 +176,7 @@ public void oldTimeoutErrorHasNoEffect() {
 
 		source.emitComplete();
 
-		Assert.assertFalse("Timeout has subscribers?", Scannable.from(tp).inners().count() != 0);
+		assertThat(tp.currentSubscriberCount()).as("timeout has subscriber").isZero();
 
 		ts.assertValues(0)
 		  .assertComplete()

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -268,7 +268,7 @@ public void subscriberCancels() {
 		Flux.using(() -> 1, r -> tp.asFlux(), cleanup::set, true)
 		    .subscribe(ts);
 
-		Assert.assertTrue("No subscriber?", Scannable.from(tp).inners().count() != 0);
+		assertThat(tp.currentSubscriberCount()).as("tp has subscriber").isPositive();
 
 		tp.emitNext(1);
 
@@ -284,7 +284,7 @@ public void subscriberCancels() {
 		  .assertNotComplete()
 		  .assertNoError();
 
-		Assert.assertFalse("Has subscriber?", Scannable.from(tp).inners().count() != 0);
+		assertThat(tp.currentSubscriberCount()).as("tp has subscriber").isZero();
 
 		Assert.assertEquals(1, cleanup.get());
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -254,7 +254,7 @@ public void cancel() {
 		                        .filterWhen(v -> pp.asFlux()))
 		            .thenCancel();
 
-		assertThat(Scannable.from(pp).inners().count() != 0).isFalse();
+		assertThat(pp.currentSubscriberCount()).as("pp has subscriber").isZero();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -218,7 +218,7 @@ public void subscriberCancels() {
 		Mono.using(() -> 1, r -> tp, cleanup::set, true)
 		    .subscribe(ts);
 
-		Assert.assertTrue("No subscriber?", Scannable.from(tp).inners().count() != 0);
+		assertThat(tp.currentSubscriberCount()).as("tp has subscriber").isPositive();
 
 		tp.onNext(1);
 

File: reactor-core/src/test/java/reactor/core/publisher/StrictSubscriberTest.java
Patch:
@@ -101,7 +101,7 @@ public void onComplete() {
 		Assert.assertNull("Error: " + e.get(), e.get());
 
 		Assert.assertTrue("Cancel executed before onSubscribe finished", state2.get());
-		Assert.assertFalse("Has subscribers?!", Scannable.from(sp).inners().count() != 0);
+		assertThat(sp.currentSubscriberCount()).as("sp has subscriber").isZero();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -159,8 +159,8 @@ public void iterableSingleSourceIsMapped() {
 
 	@Test
 	public void fused() {
-		Sinks.Many<Integer> dp1 = Sinks.many().unsafe().multicast().onBackpressureError();
-		Sinks.Many<Integer> dp2 = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> dp1 = DirectProcessor.create();
+		Sinks.Many<Integer> dp2 = DirectProcessor.create();
 
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 		ts.requestedFusionMode(Fuseable.ANY);

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -228,7 +228,7 @@ public void keyComparatorThrows() {
 
 	@Test
 	public void allDistinctConditional() {
-		Sinks.Many<Integer> dp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> dp = DirectProcessor.create();
 
 		AssertSubscriber<Integer> ts = dp.asFlux()
 										 .distinctUntilChanged()

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureDropTest.java
Patch:
@@ -90,7 +90,7 @@ public void normalBackpressured() {
 
 	@Test
 	public void someDrops() {
-		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> tp = DirectProcessor.create();
 
 		AssertSubscriber<Integer> ts = AssertSubscriber.create(0);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureLatestTest.java
Patch:
@@ -68,7 +68,7 @@ public void backpressuredComplex() {
 
 	@Test
 	public void backpressured() {
-		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> tp = DirectProcessor.create();
 
 		AssertSubscriber<Integer> ts = AssertSubscriber.create(0);
 
@@ -107,7 +107,7 @@ public void backpressured() {
 
 	@Test
 	public void error() {
-		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> tp = DirectProcessor.create();
 
 		AssertSubscriber<Integer> ts = AssertSubscriber.create(0);
 
@@ -123,7 +123,7 @@ public void error() {
 
 	@Test
 	public void backpressureWithDrop() {
-		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> tp = DirectProcessor.create();
 
 		AssertSubscriber<Integer> ts = new AssertSubscriber<Integer>(0) {
 			@Override

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -493,7 +493,7 @@ public void fusedMapInvalid() {
 
 	@Test
 	public void retry() {
-		Sinks.Many<Integer> dp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> dp = DirectProcessor.create();
 		StepVerifier.create(
 				dp.asFlux()
 				  .publish()
@@ -520,7 +520,7 @@ public void retry() {
 
 	@Test
 	public void retryWithPublishOn() {
-		Sinks.Many<Integer> dp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> dp = DirectProcessor.create();
 		StepVerifier.create(
 				dp.asFlux()
 				  .publishOn(Schedulers.parallel()).publish()

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -400,9 +400,7 @@ public void reconnectsAfterRefCountZero() {
 
 	@Test
 	public void delayElementShouldNotCancelTwice() throws Exception {
-		Sinks.Many<Long> p = Sinks.many().unsafe()
-		                          .multicast()
-		                          .onBackpressureError();
+		Sinks.Many<Long> p = DirectProcessor.create();
 		AtomicInteger cancellations = new AtomicInteger();
 
 		Flux<Long> publishedFlux = p.asFlux()

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -415,7 +415,7 @@ public void scanOtherSubscriber() {
 	@Test
 	public void inners() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		Sinks.Many<Long> signaller = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Long> signaller = DirectProcessor.create();
 		Flux<Integer> when = Flux.empty();
 		FluxRepeatWhen.RepeatWhenMainSubscriber<Integer> main = new FluxRepeatWhen.RepeatWhenMainSubscriber<>(actual, signaller, when);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -574,7 +574,7 @@ public void scanOtherSubscriber() {
 	@Test
 	public void inners() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		Sinks.Many<Retry.RetrySignal> signaller = Sinks.many().multicast().onBackpressureError();
+		Sinks.Many<Retry.RetrySignal> signaller = DirectProcessor.create();
 		Flux<Integer> when = Flux.empty();
 		FluxRetryWhen.RetryWhenMainSubscriber<Integer> main = new FluxRetryWhen
 				.RetryWhenMainSubscriber<>(actual, signaller, when, Context.empty());

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -263,7 +263,7 @@ public void subscriberCancels() {
 
 		AtomicInteger cleanup = new AtomicInteger();
 
-		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> tp = DirectProcessor.create();
 
 		Flux.using(() -> 1, r -> tp.asFlux(), cleanup::set, true)
 		    .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxZipTest.java
Patch:
@@ -791,7 +791,7 @@ public void failDoubleErrorHide() {
 
 	@Test
 	public void failDoubleTerminalPublisher() {
-		Sinks.Many<Integer> d1 = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> d1 = DirectProcessor.create();
 		Hooks.onErrorDropped(e -> {
 		});
 		StepVerifier.create(Flux.zip(obj -> 0, Flux.just(1), d1.asFlux(), s -> {
@@ -1083,7 +1083,7 @@ public void prematureCompleteSourceEmpty() {
 
 	@Test
 	public void prematureCompleteSourceEmptyDouble() {
-		Sinks.Many<Integer> d = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> d = DirectProcessor.create();
 		StepVerifier.create(Flux.zip(obj -> 0, d.asFlux(), s -> {
 			Scannable directInner = Scannable.from(d).inners().findFirst().get();
 			CoreSubscriber<?> directInnerDownstream = (CoreSubscriber<?>) directInner.scan(Scannable.Attr.ACTUAL);

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -85,7 +85,7 @@ public void timeoutRequested() {
 
 		NextProcessor<Integer> source = new NextProcessor<>(null);
 
-		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> tp = DirectProcessor.create();
 
 		source.timeout(tp.asFlux())
 		      .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/SerializedManySinkTest.java
Patch:
@@ -105,7 +105,7 @@ public void sameThreadRecursion() throws Exception {
 
 	static class EmptyMany<T> implements Sinks.Many<T> {
 
-		final Sinks.Many<T> delegate = Sinks.many().multicast().onBackpressureError();
+		final Sinks.Many<T> delegate = DirectProcessor.create();
 
 		@Override
 		public Emission tryEmitNext(T o) {

File: reactor-core/src/test/java/reactor/core/publisher/StrictSubscriberTest.java
Patch:
@@ -73,7 +73,7 @@ public void cancelDelayed() {
 		AtomicBoolean state2 = new AtomicBoolean();
 		AtomicReference<Throwable> e = new AtomicReference<>();
 
-		Sinks.Many<Integer> sp = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> sp = DirectProcessor.create();
 
 		sp.asFlux().doOnCancel(() -> state2.set(state1.get()))
 		  .subscribe(new Subscriber<Integer>() {

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -46,6 +46,7 @@
 import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import reactor.core.publisher.DirectProcessor;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Sinks;
@@ -662,7 +663,7 @@ public void testRejectingExecutorServiceScheduler() {
 
 	public void assertRejectingScheduler(Scheduler scheduler) {
 		try {
-			Sinks.Many<String> p = Sinks.many().unsafe().multicast().onBackpressureError();
+			Sinks.Many<String> p = DirectProcessor.create();
 
 			AtomicReference<String> r = new AtomicReference<>();
 			CountDownLatch l = new CountDownLatch(1);

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -48,6 +48,7 @@
 import reactor.core.Exceptions;
 import reactor.core.publisher.BaseSubscriber;
 import reactor.core.publisher.ConnectableFlux;
+import reactor.core.publisher.DirectProcessor;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Hooks;
 import reactor.core.publisher.Mono;
@@ -201,7 +202,7 @@ public void advancedCold() {
 
 	@Test
 	public void advancedHot() {
-		Sinks.Many<String> hotSource = Sinks.many().multicast().onBackpressureError();
+		Sinks.Many<String> hotSource = DirectProcessor.create();
 
 		Flux<String> hotFlux = hotSource.asFlux().map(String::toUpperCase);
 

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -40,6 +40,7 @@
 import org.junit.jupiter.api.Timeout;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.core.publisher.DirectProcessor;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Operators;
@@ -2085,7 +2086,7 @@ public void withInitialContextAndContextAssertionsParents() {
 	@Test
 	public void assertNextWithSubscribeOnDirectProcessor() {
 		Scheduler scheduler = Schedulers.newBoundedElastic(1, 100, "test");
-		Sinks.Many<Integer> processor = Sinks.many().unsafe().multicast().onBackpressureError();
+		Sinks.Many<Integer> processor = DirectProcessor.create();
 		Mono<Integer> doAction = Mono.fromSupplier(() -> 22)
 		                             .doOnNext(processor::emitNext)
 		                             .subscribeOn(scheduler);

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -518,6 +518,8 @@ public void emitNext(T value) {
 			case FAIL_TERMINATED:
 				Operators.onNextDroppedMulticast(value, subscribers);
 				break;
+			case FAIL_ZERO_SUBSCRIBER: //cannot happen in ReplayProcessor
+				throw new IllegalStateException("FAIL_ZERO_SUBSCRIBER shouldn't happen in ReplayProcessor");
 			case OK:
 				break;
 		}
@@ -530,6 +532,7 @@ public Emission tryEmitNext(T t) {
 			return Emission.FAIL_TERMINATED;
 		}
 
+		//note: ReplayProcessor can so far ALWAYS buffer the element, no FAIL_ZERO_SUBSCRIBER here
 		b.add(t);
 		for (FluxReplay.ReplaySubscription<T> rs : subscribers) {
 			b.replay(rs);

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -211,7 +211,7 @@ static final class RepeatWhenOtherSubscriber extends Flux<Long>
 
 		RepeatWhenMainSubscriber<?> main;
 
-		final Sinks.Many<Long> completionSignal = Sinks.many().multicast().onBackpressureError();
+		final Sinks.Many<Long> completionSignal = Sinks.many().multicast().onBackpressureBuffer();
 
 		@Override
 		public Context currentContext() {

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -241,7 +241,7 @@ static final class RetryWhenOtherSubscriber extends Flux<Retry.RetrySignal>
 	implements InnerConsumer<Object>, OptimizableOperator<Retry.RetrySignal, Retry.RetrySignal> {
 		RetryWhenMainSubscriber<?> main;
 
-		final Sinks.Many<Retry.RetrySignal> completionSignal = Sinks.many().multicast().onBackpressureError();
+		final Sinks.Many<Retry.RetrySignal> completionSignal = Sinks.many().multicast().onBackpressureBuffer();
 
 		@Override
 		public Context currentContext() {

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -181,7 +181,7 @@ public void cancel() {
 			synchronized (this) {
 				b = buffer;
 				buffer = null;
-				Operators.onDiscardMultiple(buffer, actual.currentContext());
+				Operators.onDiscardMultiple(b, actual.currentContext());
 			}
 			cleanup();
 			Operators.terminate(S, this);

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -175,7 +175,7 @@ public void cancel() {
 			synchronized (this) {
 				b = buffer;
 				buffer = null;
-				Operators.onDiscardMultiple(buffer, actual.currentContext());
+				Operators.onDiscardMultiple(b, actual.currentContext());
 			}
 			cleanup();
 			Operators.terminate(S, this);

File: reactor-test/src/test/java/reactor/test/DefaultContextExpectationsTest.java
Patch:
@@ -24,7 +24,7 @@
 
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssertAlternative;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;

File: reactor-test/src/test/java/reactor/test/ErrorFormatterTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-test/src/test/java/reactor/test/StepVerifierAssertionsTests.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Map;
 import java.util.stream.Collectors;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Operators;

File: reactor-test/src/test/java/reactor/test/StepVerifierTimeoutTests.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.time.Duration;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import reactor.core.publisher.Mono;
 
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

File: reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-test/src/test/java/reactor/test/publisher/PublisherProbeTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.publisher.Flux;

File: reactor-core/src/main/java/reactor/util/function/Tuple2.java
Patch:
@@ -49,7 +49,7 @@ public class Tuple2<T1, T2> implements Iterable<Object>, Serializable {
 	}
 
 	/**
-	 * Type-safe way to get the fist object of this {@link Tuples}.
+	 * Type-safe way to get the first object of this {@link Tuples}.
 	 *
 	 * @return The first object
 	 */

File: reactor-core/src/main/java/reactor/util/function/Tuple2.java
Patch:
@@ -49,7 +49,7 @@ public class Tuple2<T1, T2> implements Iterable<Object>, Serializable {
 	}
 
 	/**
-	 * Type-safe way to get the fist object of this {@link Tuples}.
+	 * Type-safe way to get the first object of this {@link Tuples}.
 	 *
 	 * @return The first object
 	 */

File: reactor-core/src/main/java/reactor/util/function/Tuple2.java
Patch:
@@ -49,7 +49,7 @@ public class Tuple2<T1, T2> implements Iterable<Object>, Serializable {
 	}
 
 	/**
-	 * Type-safe way to get the fist object of this {@link Tuples}.
+	 * Type-safe way to get the first object of this {@link Tuples}.
 	 *
 	 * @return The first object
 	 */

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -951,7 +951,7 @@ public final Flux<T> sorted(Comparator<? super T> comparator, int capacityHint)
 	 * @param subscribers the subscribers array to run in parallel, the number of items
 	 * must be equal to the parallelism level of this ParallelFlux
 	 */
-	protected abstract void subscribe(CoreSubscriber<? super T>[] subscribers);
+	public abstract void subscribe(CoreSubscriber<? super T>[] subscribers);
 
 	/**
 	 * Subscribes to this {@link ParallelFlux} and triggers the execution chain for all

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java
Patch:
@@ -74,7 +74,7 @@ public String stepName() {
 	}
 
 	@Override
-	protected void subscribe(CoreSubscriber<? super O>[] s) {
+	public void subscribe(CoreSubscriber<? super O>[] s) {
 		@SuppressWarnings("unchecked") CoreSubscriber<? super I>[] subscribers =
 				new CoreSubscriber[parallelism()];
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java
Patch:
@@ -77,7 +77,7 @@ public String stepName() {
 	}
 
 	@Override
-	protected void subscribe(CoreSubscriber<? super O>[] s) {
+	public void subscribe(CoreSubscriber<? super O>[] s) {
 		@SuppressWarnings("unchecked") CoreSubscriber<? super I>[] subscribers =
 				new CoreSubscriber[parallelism()];
 

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -79,7 +79,8 @@
  * </p>
  *
  * @param <T> the input and output value type
- * @deprecated Prefer clear cut usage of {@link Sinks}, to be removed in 3.5
+ * @deprecated To be removed in 3.5, prefer clear cut usage of {@link Sinks} with
+ * {@link Sinks.MulticastSpec#onBackpressureError() Sinks.many().multicast().onBackpressureError()}.
  */
 @Deprecated
 public final class DirectProcessor<T> extends FluxProcessor<T, T> implements Sinks.Many<T> {

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -48,7 +48,8 @@
  * <p>
  *
  * @param <T> the value type
- * @deprecated Prefer clear cut usage of {@link Sinks}, to be removed in 3.5
+ * @deprecated To be removed in 3.5, prefer clear cut usage of {@link Sinks} through
+ * variations under {@link reactor.core.publisher.Sinks.MulticastReplaySpec Sinks.many().replay()}.
  */
 @Deprecated
 public final class ReplayProcessor<T> extends FluxProcessor<T, T>

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -84,7 +84,8 @@
  * </p>
  *
  * @param <T> the input and output type
- * @deprecated Prefer clear cut usage of {@link Sinks}, to be removed in 3.5
+ * @deprecated to be removed in 3.5, prefer clear cut usage of {@link Sinks} through
+ * variations under {@link reactor.core.publisher.Sinks.UnicastSpec Sinks.many().unicast()}.
  */
 @Deprecated
 public final class UnicastProcessor<T> extends FluxProcessor<T, T>

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -202,7 +202,7 @@ public Context currentContext() {
 	 * Create a {@link FluxProcessor} that safely gates multi-threaded producer
 	 * {@link Subscriber#onNext(Object)}.
 	 *
-	 * @reactor.discard The resulting processor discards elements received from the source
+	 * <p><strong>Discard Support:</strong> The resulting processor discards elements received from the source
 	 * {@link Publisher} (if any) when it cancels subscription to said source.
 	 *
 	 * @return a serializing {@link FluxProcessor}

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -43,7 +43,7 @@
  * @param <OUT> the output value type
  */
 public abstract class FluxProcessor<IN, OUT> extends Flux<OUT>
-		implements Processor<IN, OUT>, CoreSubscriber<IN>, Scannable, Disposable {
+		implements Processor<IN, OUT>, CoreSubscriber<IN>, Scannable, Disposable, ContextHolder {
 
 	/**
 	 * Convert a {@link Sinks.Many} to a {@link FluxProcessor} : subscribing to the processor

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -49,7 +49,7 @@ public abstract class FluxProcessor<IN, OUT> extends Flux<OUT>
 	 * Convert a {@link Sinks.Many} to a {@link FluxProcessor} : subscribing to the processor
 	 * will be akin to subscribing to the {@link Many#asFlux()}, and having the processor
 	 * subscribed to an upstream {@link org.reactivestreams.Publisher} will pass signals from
-	 * said {@link org.reactivestreams.Publisher} as calls to the sink's {@link Sinks.Many#emitNext(Object) emit methods}.
+	 * said {@link org.reactivestreams.Publisher} as calls to the sink's {@link Sinks.Many#tryEmitNext(Object) emit methods}.
 	 *
 	 * @param sink the {@link Sinks.Many} to convert
 	 * @param <IN> the type of values that can be emitted by the sink

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -56,7 +56,8 @@ public abstract class MonoProcessor<O> extends Mono<O>
 	 * Convert a {@link Sinks.One} to a {@link MonoProcessor} : subscribing to the processor
 	 * will be akin to subscribing to the {@link Sinks.One#asMono()}, and having the processor
 	 * subscribed to an upstream {@link org.reactivestreams.Publisher} will pass signals from
-	 * said {@link org.reactivestreams.Publisher} as calls to the sink's {@link Sinks.One#emitValue(Object) emit methods}.
+	 * said {@link org.reactivestreams.Publisher} as calls to the sink's
+	 * {@link Sinks.One#tryEmitValue(Object) emit methods}.
 	 *
 	 * @param sink the {@link Sinks.One} to convert
 	 * @param <IN> the type of values that can be emitted by the sink

File: reactor-core/src/test/java/reactor/core/publisher/AbstractFluxConcatMapTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 import org.reactivestreams.Publisher;
+
 import reactor.core.CorePublisher;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java
Patch:
@@ -31,8 +31,8 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Supplier;
-
 import java.util.stream.Collectors;
+
 import org.junit.Assert;
 import org.junit.Test;
 import org.reactivestreams.Subscriber;

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -22,8 +22,8 @@
 
 import org.junit.Assert;
 import org.junit.Test;
-
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import java.time.Duration;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import org.assertj.core.api.Assertions;

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.TimeoutException;
 
 import org.junit.Test;
+
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;

File: reactor-core/src/test/java/reactor/core/publisher/VoidProcessorTest.java
Patch:
@@ -148,15 +148,15 @@ public void VoidProcessorDoubleError() {
 		VoidProcessor<Void> mp = new VoidProcessor<>();
 
 		mp.onError(new Exception("test"));
-		assertThat(mp.emitError(new Exception("test")).hasFailed()).isTrue();
+		assertThat(mp.tryEmitError(new Exception("test")).hasFailed()).isTrue();
 	}
 
 	@Test
 	public void VoidProcessorDoubleSignal() {
 		VoidProcessor<Void> mp = new VoidProcessor<>();
 
 		mp.onComplete();
-		assertThat(mp.emitError(new Exception("test")).hasFailed()).isTrue();
+		assertThat(mp.tryEmitError(new Exception("test")).hasFailed()).isTrue();
 	}
 
 }
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxSpecTests.java
Patch:
@@ -1104,8 +1104,8 @@ public void collectFromMultipleThread1() throws Exception {
 				});
 
 		Flux.range(1, 1000).subscribe(data -> {
-			while(head.emitNext(data).hasFailed());
-		}, head::emitError, head::emitComplete);
+			while(head.tryEmitNext(data).hasFailed());
+		}, head::tryEmitError, head::tryEmitComplete);
 		latch.await();
 		Assert.assertTrue(sum.get() == length);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -1015,6 +1015,9 @@ public void onComplete() {
 
 		@Override
 		public void request(long n) {
+			if (sourceMode == Fuseable.SYNC) {
+				return;
+			}
 			long p = produced + n;
 			if (p >= limit) {
 				produced = 0L;

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/MonoMetricsTest.java
Patch:
@@ -446,7 +446,7 @@ public void ensureFuseablePropagateOnComplete_inCaseOfAsyncFusion() {
 		assertThat(source.metrics()).isInstanceOf(MonoMetricsFuseable.class);
 
 		//now use the test version with local registry
-		new MonoMetricsFuseable<List<Integer>>(source, registry)
+		new MonoMetricsFuseable<List<Integer>>(source)
 		    .flatMapIterable(Function.identity())
 		    .as(StepVerifier::create)
 		    .expectNext(1, 2, 3)
@@ -464,7 +464,7 @@ public void ensureOnNextInAsyncModeIsCapableToPropagateNulls() {
 		assertThat(source.metrics()).isInstanceOf(MonoMetricsFuseable.class);
 
 		//now use the test version with local registry
-		new MonoMetricsFuseable<List<Integer>>(source, registry)
+		new MonoMetricsFuseable<List<Integer>>(source)
 		    .flatMapIterable(Function.identity())
 		    .as(StepVerifier::create)
 		    .expectNext(1, 2, 3)

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -62,7 +62,7 @@ public abstract class MonoProcessor<O> extends Mono<O>
 	 * @param <IN> the type of values that can be emitted by the sink
 	 * @return a {@link MonoProcessor} with the same semantics as the {@link Sinks.One}
 	 */
-	public static <IN> Processor<IN, IN> fromSink(Sinks.One<IN> sink) {
+	public static <IN> MonoProcessor<IN> fromSink(Sinks.One<IN> sink) {
 		if (sink instanceof MonoProcessor) {
 			@SuppressWarnings("unchecked")
 			final MonoProcessor<IN> processor = (MonoProcessor<IN>) sink;

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import org.assertj.core.api.Assertions;

File: reactor-core/src/withMicrometerTest/java/reactor/core/publisher/MonoMetricsTest.java
Patch:
@@ -230,7 +230,7 @@ public void malformedOnError() {
 	public void completeEmpty() {
 		Mono<Integer> source = Mono.empty();
 
-		new MonoMetrics<>(source, registry).block();
+		new MonoMetrics<>(source).block();
 
 		Timer stcCompleteCounter = registry.find(REACTOR_DEFAULT_NAME + METER_FLOW_DURATION)
 											.tags(Tags.of(TAG_ON_COMPLETE))
@@ -253,7 +253,7 @@ public void completeEmpty() {
 	public void completeWithElement() {
 		Mono<Integer> source = Mono.just(1);
 
-		new MonoMetrics<>(source, registry).block();
+		new MonoMetrics<>(source).block();
 
 		Timer stcCompleteCounter = registry.find(REACTOR_DEFAULT_NAME + METER_FLOW_DURATION)
 				.tags(Tags.of(TAG_ON_COMPLETE))

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -45,7 +45,7 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoErrorSupplied<T> extends Mono<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
+final class MonoErrorSupplied<T> extends Mono<T> implements Fuseable.ScalarCallable<T>, SourceProducer<T> {
 
 	final Supplier<? extends Throwable> errorSupplier;
 
@@ -72,7 +72,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	}
 
 	@Override
-	public Object call() throws Exception {
+	public T call() throws Exception {
 		Throwable error = Objects.requireNonNull(errorSupplier.get(), "the errorSupplier returned null");
 		if(error instanceof Exception){
 			throw ((Exception) error);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -29,7 +29,7 @@ public class FluxSourceTest {
 
 	@Test
 	public void wrapToFlux(){
-		MonoProcessor<String> mp = MonoProcessor.create();
+		NextProcessor<String> mp = new NextProcessor<>(null);
 
 		mp.onNext("test");
 		StepVerifier.create(Flux.from(mp))

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
+
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/MonoFirstTest.java
Patch:
@@ -107,7 +107,7 @@ public void pairWiseIterable() {
 
 	@Test
 	public void firstMonoJust() {
-		MonoProcessor<Integer> mp = MonoProcessor.create();
+		NextProcessor<Integer> mp = new NextProcessor<>(null);
 		StepVerifier.create(Mono.first(Mono.just(1), Mono.just(2))
 		                        .subscribeWith(mp))
 		            .then(() -> assertThat(mp.isError()).isFalse())

File: reactor-core/src/test/java/reactor/core/publisher/MonoPublishMulticastTest.java
Patch:
@@ -73,7 +73,7 @@ public void normalHide() {
 	public void cancelComposes() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		MonoProcessor<Integer> sp = MonoProcessor.create();
+		NextProcessor<Integer> sp = new NextProcessor<>(null);
 
 		sp.publish(o -> Mono.<Integer>never())
 		  .subscribe(ts);
@@ -89,7 +89,7 @@ public void cancelComposes() {
 	public void cancelComposes2() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		MonoProcessor<Integer> sp = MonoProcessor.create();
+		NextProcessor<Integer> sp = new NextProcessor<>(null);
 
 		sp.publish(o -> Mono.<Integer>empty())
 		  .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -82,7 +82,7 @@ public void firstTimeoutError() {
 	public void timeoutRequested() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		MonoProcessor<Integer> source = MonoProcessor.create();
+		NextProcessor<Integer> source = new NextProcessor<>(null);
 
 		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -213,7 +213,7 @@ public void subscriberCancels() {
 
 		AtomicInteger cleanup = new AtomicInteger();
 
-		MonoProcessor<Integer> tp = MonoProcessor.create();
+		NextProcessor<Integer> tp = new NextProcessor<>(null);
 
 		Mono.using(() -> 1, r -> tp, cleanup::set, true)
 		    .subscribe(ts);

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import java.util.concurrent.locks.LockSupport;
 import java.util.stream.Stream;
 
 import org.reactivestreams.Subscriber;
@@ -255,8 +254,8 @@ public Emission emitNext(T t) {
 			}
 		}
 
-		while (!q.offer(t)) {
-			LockSupport.parkNanos(10);
+		if (!q.offer(t)) {
+			return Emission.FAIL_OVERFLOW;
 		}
 		drain();
 		return Emission.OK;

File: reactor-core/src/main/java/reactor/core/Disposables.java
Patch:
@@ -286,7 +286,7 @@ void dispose(@Nullable List<Disposable> set) {
 		public Stream<? extends Scannable> inners() {
 			return this.asStream()
 			           .filter(Scannable.class::isInstance)
-			           .map(Scannable.class::cast);
+			           .map(Scannable::from);
 		}
 
 		@Nullable

File: reactor-core/src/main/java/reactor/core/publisher/DelegateProcessor.java
Patch:
@@ -44,7 +44,7 @@ final class DelegateProcessor<IN, OUT> extends FluxProcessor<IN, OUT> {
 	@Override
 	public Context currentContext() {
 		if(upstream instanceof CoreSubscriber){
-			return ((CoreSubscriber)upstream).currentContext();
+			return ((CoreSubscriber<?>)upstream).currentContext();
 		}
 		return Context.empty();
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySequence.java
Patch:
@@ -72,7 +72,7 @@ static final class DelaySubscriber<T> implements InnerOperator<T, T> {
 
 		DelaySubscriber(CoreSubscriber<? super T> actual, Duration delay, Scheduler.Worker w) {
 			super();
-			this.actual = new SerializedSubscriber<>(actual);
+			this.actual = Operators.serialize(actual);
 			this.w = w;
 			this.delay = delay.toNanos();
 			this.timeUnit = TimeUnit.NANOSECONDS;

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -211,7 +211,7 @@ public void downstreamDemandShouldBeAbleToDecreaseOnTimeSpan() {
 
 	@Test
 	public void requestedFromUpstreamShouldNotExceedDownstreamDemand() {
-		Sinks.StandaloneFluxSink<String> sink = Sinks.multicast();
+		Sinks.Many<String> sink = Sinks.many().multicast().onBackpressureBuffer();
 		Flux<String> emitter = sink.asFlux();
 
 		AtomicLong requestedOutstanding = new AtomicLong(0);
@@ -227,7 +227,7 @@ public void requestedFromUpstreamShouldNotExceedDownstreamDemand() {
 		            .then(() -> assertThat(requestedOutstanding.get()).isEqualTo(0))
 		            .thenRequest(2)
 		            .then(() -> assertThat(requestedOutstanding.get()).isEqualTo(10))
-		            .then(() -> sink.next("a"))
+		            .then(() -> sink.emitNext("a"))
 		            .thenAwait(Duration.ofMillis(100))
 		            .assertNext(s -> assertThat(s).containsExactly("a"))
 		            .then(() -> assertThat(requestedOutstanding.get()).isEqualTo(9))

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -415,7 +415,7 @@ public void scanOtherSubscriber() {
 	@Test
 	public void inners() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		CoreSubscriber<Long> signaller = new LambdaSubscriber<>(null, e -> {}, null, null);
+		Sinks.Many<Long> signaller = Sinks.many().unsafe().multicast().onBackpressureError();
 		Flux<Integer> when = Flux.empty();
 		FluxRepeatWhen.RepeatWhenMainSubscriber<Integer> main = new FluxRepeatWhen.RepeatWhenMainSubscriber<>(actual, signaller, when);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -422,7 +422,7 @@ public void onlyInitialRequestWithLateUnboundedSubscriber() {
 
 	@Test
 	public void cancel() {
-		ConnectableFlux<Integer> replay = Processors.<Integer>unicast().replay(2);
+		ConnectableFlux<Integer> replay = Sinks.many().unicast().<Integer>onBackpressureBuffer().asFlux().replay(2);
 
 		replay.subscribe(v -> {}, e -> { throw Exceptions.propagate(e); });
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -24,14 +24,12 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.LongAssert;
 import org.assertj.core.data.Percentage;
 import org.junit.Test;
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 
 import reactor.core.CoreSubscriber;
@@ -575,7 +573,7 @@ public void scanOtherSubscriber() {
 	@Test
 	public void inners() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		CoreSubscriber<Retry.RetrySignal> signaller = new LambdaSubscriber<>(null, e -> {}, null, null);
+		Sinks.Many<Retry.RetrySignal> signaller = Sinks.many().multicast().onBackpressureError();
 		Flux<Integer> when = Flux.empty();
 		FluxRetryWhen.RetryWhenMainSubscriber<Integer> main = new FluxRetryWhen
 				.RetryWhenMainSubscriber<>(actual, signaller, when);

File: reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java
Patch:
@@ -335,7 +335,7 @@ public void liftGroupedFluxFuseable() {
 			Operators.LiftFunction<Integer, Integer> liftFunction =
 					Operators.LiftFunction.liftScannable(null, (s, actual) -> actual);
 
-			sourceGroups.map(g -> liftFunction.apply(g))
+			sourceGroups.map(liftFunction)
 					.doOnNext(liftOperator -> assertThat(liftOperator)
 							.isInstanceOf(GroupedFlux.class)
 							.isInstanceOf(Fuseable.class)

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -248,13 +248,13 @@ protected void hookFinally(SignalType type) {
 
 	@Test
 	public void cancel() {
-		final FluxIdentityProcessor<Boolean> pp = Processors.multicast();
+		final Sinks.Many<Boolean> pp = Sinks.many().multicast().onBackpressureBuffer();
 
 		StepVerifier.create(Mono.just(1)
-		                        .filterWhen(v -> pp))
+		                        .filterWhen(v -> pp.asFlux()))
 		            .thenCancel();
 
-		assertThat(pp.hasDownstreams()).isFalse();
+		assertThat(Scannable.from(pp).inners().count() != 0).isFalse();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoPublishMulticastTest.java
Patch:
@@ -78,7 +78,7 @@ public void cancelComposes() {
 		sp.publish(o -> Mono.<Integer>never())
 		  .subscribe(ts);
 
-		Assert.assertTrue("Not subscribed?", sp.downstreamCount() != 0);
+		Assert.assertTrue("Not subscribed?", Scannable.from(sp).inners().count() != 0);
 
 		ts.cancel();
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -84,12 +84,12 @@ public void timeoutRequested() {
 
 		MonoProcessor<Integer> source = MonoProcessor.create();
 
-		FluxIdentityProcessor<Integer> tp = Processors.more().multicastNoBackpressure();
+		Sinks.Many<Integer> tp = Sinks.many().unsafe().multicast().onBackpressureError();
 
-		source.timeout(tp)
+		source.timeout(tp.asFlux())
 		      .subscribe(ts);
 
-		tp.onNext(1);
+		tp.emitNext(1);
 
 		source.onNext(2);
 		source.onComplete();

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -218,7 +218,7 @@ public void subscriberCancels() {
 		Mono.using(() -> 1, r -> tp, cleanup::set, true)
 		    .subscribe(ts);
 
-		Assert.assertTrue("No subscriber?", tp.hasDownstreams());
+		Assert.assertTrue("No subscriber?", Scannable.from(tp).inners().count() != 0);
 
 		tp.onNext(1);
 

File: reactor-core/src/test/java/reactor/core/publisher/StrictSubscriberTest.java
Patch:
@@ -73,9 +73,9 @@ public void cancelDelayed() {
 		AtomicBoolean state2 = new AtomicBoolean();
 		AtomicReference<Throwable> e = new AtomicReference<>();
 
-		FluxIdentityProcessor<Integer> sp = Processors.more().multicastNoBackpressure();
+		Sinks.Many<Integer> sp = Sinks.many().unsafe().multicast().onBackpressureError();
 
-		sp.doOnCancel(() -> state2.set(state1.get()))
+		sp.asFlux().doOnCancel(() -> state2.set(state1.get()))
 		  .subscribe(new Subscriber<Integer>() {
 			  @Override
 			  public void onSubscribe(Subscription s) {
@@ -101,7 +101,7 @@ public void onComplete() {
 		Assert.assertNull("Error: " + e.get(), e.get());
 
 		Assert.assertTrue("Cancel executed before onSubscribe finished", state2.get());
-		Assert.assertFalse("Has subscribers?!", sp.hasDownstreams());
+		Assert.assertFalse("Has subscribers?!", Scannable.from(sp).inners().count() != 0);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -19,8 +19,6 @@
 
 import org.reactivestreams.Processor;
 import org.testng.SkipException;
-
-import reactor.core.publisher.FluxIdentityProcessor;
 import reactor.core.publisher.FluxProcessor;
 
 /**
@@ -31,7 +29,7 @@ public class EmitterProcessorVerification extends AbstractProcessorVerification
 
 	@Override
 	public Processor<Long, Long> createIdentityProcessor(int bufferSize) {
-		@SuppressWarnings("deprecation") FluxIdentityProcessor<Long>
+		@SuppressWarnings("deprecation") FluxProcessor<Long, Long>
 				p = reactor.core.publisher.EmitterProcessor.create(bufferSize);
 		return FluxProcessor.wrap(p, p.log("EmitterProcessorVerification", Level.FINE));
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java
Patch:
@@ -110,7 +110,6 @@ static class MetricsSubscriber<T> implements InnerOperator<T, T> {
 				                                           .tags(commonTags)
 				                                           .description(
 						                                           "Counts the amount requested to a named Flux by all subscribers, until at least one requests an unbounded amount")
-				                                           .baseUnit("requested amount")
 				                                           .register(registry);
 			}
 			else {
@@ -375,7 +374,6 @@ static void recordOnComplete(Tags commonTags, MeterRegistry registry, Timer.Samp
 	static void recordOnSubscribe(Tags commonTags, MeterRegistry registry) {
 		Counter.builder(METER_SUBSCRIBED)
 		       .tags(commonTags)
-		       .baseUnit("subscribers")
 		       .description("Counts how many Reactor sequences have been subscribed to")
 		       .register(registry)
 		       .increment();

File: reactor-core/src/main/java/reactor/core/publisher/ContextTrackingFunctionWrapper.java
Patch:
@@ -22,7 +22,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
-import reactor.core.publisher.FluxContextStart.ContextStartSubscriber;
+import reactor.core.publisher.FluxContextWrite.ContextWriteSubscriber;
 import reactor.util.context.Context;
 
 /**
@@ -63,7 +63,7 @@ public CorePublisher<V> apply(Publisher<T> source) {
 			}
 
 			Context newContext = ctx.delete(key);
-			return new ContextStartSubscriber<>(actual, newContext);
+			return new ContextWriteSubscriber<>(actual, newContext);
 		}).apply(source);
 
 		Publisher<V> result = transformer.apply(source);
@@ -73,7 +73,7 @@ public CorePublisher<V> apply(Publisher<T> source) {
 			@Override
 			public void subscribe(CoreSubscriber<? super V> actual) {
 				Context ctx = actual.currentContext().put(key, true);
-				CoreSubscriber<V> subscriber = new ContextStartSubscriber<>(actual, ctx);
+				CoreSubscriber<V> subscriber = new ContextWriteSubscriber<>(actual, ctx);
 
 				if (result instanceof CorePublisher) {
 					((CorePublisher<V>) result).subscribe(subscriber);

File: reactor-core/src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -39,7 +39,7 @@ public interface FluxSink<T> extends SequenceSink<T> {
 	/**
 	 * Return the current subscriber {@link Context}.
 	 * <p>
-	 *   {@link Context} can be enriched via {@link Flux#subscriberContext(Function)}
+	 *   {@link Context} can be enriched via {@link Flux#contextWrite(Function)}
 	 *   operator or directly by a child subscriber overriding
 	 *   {@link CoreSubscriber#currentContext()}
 	 *

File: reactor-core/src/main/java/reactor/core/publisher/MonoContextWrite.java
Patch:
@@ -23,11 +23,11 @@
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
 
-final class MonoSubscriberContext<T> extends InternalMonoOperator<T, T> implements Fuseable {
+final class MonoContextWrite<T> extends InternalMonoOperator<T, T> implements Fuseable {
 
 	final Function<Context, Context> doOnContext;
 
-	MonoSubscriberContext(Mono<? extends T> source,
+	MonoContextWrite(Mono<? extends T> source,
 			Function<Context, Context> doOnContext) {
 		super(source);
 		this.doOnContext = Objects.requireNonNull(doOnContext, "doOnContext");
@@ -37,7 +37,7 @@ final class MonoSubscriberContext<T> extends InternalMonoOperator<T, T> implemen
 	public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> actual) {
 		Context c = doOnContext.apply(actual.currentContext());
 
-		return new FluxContextStart.ContextStartSubscriber<>(actual, c);
+		return new FluxContextWrite.ContextWriteSubscriber<>(actual, c);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoCurrentContext.java
Patch:
@@ -24,6 +24,7 @@
 /**
  * Materialize current {@link Context} from the subscribing flow
  */
+@Deprecated
 final class MonoCurrentContext extends Mono<Context>
 		implements Fuseable, Scannable {
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -36,7 +36,7 @@ public interface MonoSink<T> extends ScalarSink<T> {
 	/**
 	 * Return the current subscriber {@link Context}.
 	 * <p>
-	 *   {@link Context} can be enriched via {@link Mono#subscriberContext(Function)}
+	 *   {@link Context} can be enriched via {@link Mono#contextWrite(Function)}
 	 *   operator or directly by a child subscriber overriding
 	 *   {@link CoreSubscriber#currentContext()}
 	 *

File: reactor-core/src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -44,8 +44,8 @@ public interface SynchronousSink<T> {
 	/**
 	 * Return the current subscriber {@link Context}.
 	 * <p>
-	 *   {@link Context} can be enriched via {@link Mono#subscriberContext(Function)}
-	 *   or {@link Flux#subscriberContext(Function)}
+	 *   {@link Context} can be enriched via {@link Mono#contextWrite(Function)}
+	 *   or {@link Flux#contextWrite(Function)}
 	 *   operator or directly by a child subscriber overriding
 	 *   {@link CoreSubscriber#currentContext()}
 	 *

File: reactor-core/src/test/java/reactor/core/publisher/ContextLossDetectionTest.java
Patch:
@@ -237,7 +237,7 @@ static abstract class ContextTestCase implements Function<LossyTransformer, Core
 		Flux<ContextView> assembleWithDownstreamContext(LossyTransformer lossyTransformer,
 				Context downstreamContext) {
 			return Flux.from(apply(lossyTransformer))
-			           .subscriberContext(downstreamContext);
+			           .contextWrite(downstreamContext);
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -1272,7 +1272,7 @@ void contextTest() {
 		                                                       .get(AtomicInteger.class)
 		                                                       .incrementAndGet())))
 		                        .take(10)
-		                        .subscriberContext(ctx -> ctx.put(AtomicInteger.class,
+		                        .contextWrite(ctx -> ctx.put(AtomicInteger.class,
 				                        new AtomicInteger())))
 		            .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
 		            .verifyComplete();
@@ -1285,7 +1285,7 @@ void contextTestPush() {
 		                                                       .get(AtomicInteger.class)
 		                                                       .incrementAndGet())))
 		                        .take(10)
-		                        .subscriberContext(ctx -> ctx.put(AtomicInteger.class,
+		                        .contextWrite(ctx -> ctx.put(AtomicInteger.class,
 				                        new AtomicInteger())))
 		            .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
 		            .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferContextualTest.java
Patch:
@@ -15,14 +15,14 @@ void transformDeferredWithContext() {
 		final Flux<String> flux = Flux
 				.just("foo")
 				.transformDeferredContextual((s, ctx) -> s.map(v -> v + " for " + ctx.getOrDefault("requestId", "NO ID")))
-				.subscriberContext(Context.of("unrelatedKey", true));
+				.contextWrite(Context.of("unrelatedKey", true));
 
-		flux.subscriberContext(Context.of("requestId", "aA1"))
+		flux.contextWrite(Context.of("requestId", "aA1"))
 		    .as(StepVerifier::create)
 		    .expectNext("foo for aA1")
 		    .verifyComplete();
 
-		flux.subscriberContext(Context.of("requestId", "bB2"))
+		flux.contextWrite(Context.of("requestId", "bB2"))
 		    .as(StepVerifier::create)
 		    .expectNext("foo for bB2")
 		    .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferTest.java
Patch:
@@ -89,7 +89,7 @@ public void deferFluxWithContext() {
 					AtomicInteger i = ctx.get("i");
 					return Mono.just(i.incrementAndGet());
 				})
-				.subscriberContext(Context.of(
+				.contextWrite(Context.of(
 						"i", new AtomicInteger()
 				));
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxGenerateTest.java
Patch:
@@ -432,7 +432,7 @@ public void contextTest() {
 		                                               .get(AtomicInteger.class)
 		                                               .incrementAndGet()))
 		                        .take(10)
-		                        .subscriberContext(ctx -> ctx.put(AtomicInteger.class,
+		                        .contextWrite(ctx -> ctx.put(AtomicInteger.class,
 				                        new AtomicInteger())))
 		            .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
 		            .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -452,8 +452,8 @@ public void repeatWhenContextTrigger_MergesOriginalContext() {
 					        sink.error(new IllegalStateException("repeats exhausted"));
 					    }
 				    }))
-				    .subscriberContext(Context.of("repeatsLeft", REPEAT_COUNT, "emitted", 0))
-				    .subscriberContext(Context.of("thirdPartyContext", "present"));
+				    .contextWrite(Context.of("repeatsLeft", REPEAT_COUNT, "emitted", 0))
+				    .contextWrite(Context.of("thirdPartyContext", "present"));
 
 		StepVerifier.create(retryWithContext)
 		            .expectNext("A", "B")

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -609,8 +609,8 @@ public void retryWhenContextTrigger_MergesOriginalContext() {
 		                    sink.error(Exceptions.retryExhausted("retries exhausted", rs.failure()));
 	                    }
                     })))
-				    .subscriberContext(Context.of("retriesLeft", RETRY_COUNT))
-					.subscriberContext(Context.of("thirdPartyContext", "present"));
+				    .contextWrite(Context.of("retriesLeft", RETRY_COUNT))
+					.contextWrite(Context.of("thirdPartyContext", "present"));
 
 		StepVerifier.create(retryWithContext)
 		            .expectErrorSatisfies(e -> assertThat(e).matches(Exceptions::isRetryExhausted, "isRetryExhausted")

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -1044,9 +1044,9 @@ public void discardOnWindowCancel() {
 		StepVerifier.create(Flux.just(1, 2, 3, 0, 4, 5, 0, 0, 6)
 		                        .windowWhile(i -> i > 0)
 		                        .flatMap(w -> w.take(1)
-		                                       .subscriberContext(Context.of(Hooks.KEY_ON_DISCARD, (Consumer<Object>) discardWindow::add))
+		                                       .contextWrite(Context.of(Hooks.KEY_ON_DISCARD, (Consumer<Object>) discardWindow::add))
 		                        )
-		                        .subscriberContext(Context.of(Hooks.KEY_ON_DISCARD, (Consumer<Object>) discardMain::add)))
+		                        .contextWrite(Context.of(Hooks.KEY_ON_DISCARD, (Consumer<Object>) discardMain::add)))
 		            .expectNext(1, 4, 6)
 		            .expectComplete()
 		            .verifyThenAssertThat()

File: reactor-core/src/test/java/reactor/core/publisher/LambdaMonoSubscriberTest.java
Patch:
@@ -29,6 +29,7 @@
 import reactor.test.LoggerUtils;
 import reactor.test.util.TestLogger;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 import static org.assertj.core.api.Assertions.*;
 import static org.junit.Assert.*;
@@ -39,9 +40,9 @@ public class LambdaMonoSubscriberTest {
 
 	@Test
 	public void initialContextIsVisibleToUpstream() {
-		AtomicReference<Context> contextRef = new AtomicReference<>();
+		AtomicReference<ContextView> contextRef = new AtomicReference<>();
 
-		Mono.subscriberContext()
+		Mono.deferContextual(Mono::just)
 		    .doOnNext(contextRef::set)
 		    .subscribe(null, null, null, Context.of("subscriber", "context"));
 

File: reactor-core/src/test/java/reactor/core/publisher/LambdaSubscriberTest.java
Patch:
@@ -24,6 +24,7 @@
 
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -32,10 +33,10 @@ public class LambdaSubscriberTest {
 
 	@Test
 	public void initialContextIsVisibleToUpstream() {
-		AtomicReference<Context> contextRef = new AtomicReference<>();
+		AtomicReference<ContextView> contextRef = new AtomicReference<>();
 
 		Flux.just("foo")
-		    .flatMap(c -> Mono.subscriberContext())
+		    .flatMap(c -> Mono.deferContextual(Mono::just))
 		    .doOnNext(contextRef::set)
 		    .subscribe(null, null, null, Context.of("subscriber", "context"));
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoContextWriteTest.java
Patch:
@@ -6,11 +6,11 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class MonoSubscriberContextTest {
+public class MonoContextWriteTest {
 
     @Test
     public void scanOperator(){
-        MonoSubscriberContext<Integer> test = new MonoSubscriberContext<>(Mono.just(1), c -> c);
+        MonoContextWrite<Integer> test = new MonoContextWrite<>(Mono.just(1), c -> c);
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
     }

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -381,7 +381,7 @@ public void contextTest() {
 		StepVerifier.create(Mono.create(s -> s.success(s.currentContext()
 		                                                .get(AtomicInteger.class)
 		                                                .incrementAndGet()))
-		                        .subscriberContext(ctx -> ctx.put(AtomicInteger.class,
+		                        .contextWrite(ctx -> ctx.put(AtomicInteger.class,
 				                        new AtomicInteger())))
 		            .expectNext(1)
 		            .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/MonoCurrentContextTest.java
Patch:
@@ -5,6 +5,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@Deprecated
 public class MonoCurrentContextTest {
 
     @Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferTest.java
Patch:
@@ -45,7 +45,7 @@ public void deferMonoWithContext() {
 					AtomicInteger i = ctx.get("i");
 					return Mono.just(i.incrementAndGet());
 				})
-				.subscriberContext(Context.of(
+				.contextWrite(Context.of(
 						"i", new AtomicInteger()
 				));
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoOnEachTest.java
Patch:
@@ -254,7 +254,7 @@ public void nextComplete() {
 		Mono.just(1)
 		    .hide()
 		    .doOnEach(s -> signalsAndContext.add(Tuples.of(s, s.getContextView())))
-		    .subscriberContext(Context.of("foo", "bar"))
+		    .contextWrite(Context.of("foo", "bar"))
 		    .subscribe();
 
 		assertThat(signalsAndContext)
@@ -276,7 +276,7 @@ public void nextError() {
 		Mono.just(0)
 		    .map(i -> 10 / i)
 		    .doOnEach(s -> signalsAndContext.add(Tuples.of(s,s.getContextView())))
-		    .subscriberContext(Context.of("foo", "bar"))
+		    .contextWrite(Context.of("foo", "bar"))
 		    .subscribe();
 
 		assertThat(signalsAndContext)

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingWhenTest.java
Patch:
@@ -358,13 +358,13 @@ public void nullClosureAppliesRollback() {
 
 	@Test
 	public void resourceSupplierCanAccessContext() {
-		Mono.usingWhen(Mono.subscriberContext()
+		Mono.usingWhen(Mono.deferContextual(Mono::just)
 		                   .map(ctx -> ctx.get(String.class)),
 				Mono::just,
 				Mono::just,
 				(res, err) -> Mono.just(res),
 				Mono::just)
-		    .subscriberContext(Context.of(String.class, "contextual"))
+		    .contextWrite(Context.of(String.class, "contextual"))
 		    .as(StepVerifier::create)
 		    .expectNext("contextual")
 		    .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -1054,7 +1054,7 @@ public void doOnEachContext() {
 			    results.add(s + " " + valueFromContext);
 		    })
 		    .reduce(Integer::sum)
-		    .subscriberContext(Context.of("test", "Hello!"))
+		    .contextWrite(Context.of("test", "Hello!"))
 		    .block();
 
 		assertThat(results).containsExactlyInAnyOrder(

File: reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java
Patch:
@@ -183,7 +183,7 @@ public void bufferSizeOtherQueue() {
 	@Test
 	public void contextTest() {
     	UnicastProcessor<Integer> p = UnicastProcessor.create();
-    	p.subscriberContext(ctx -> ctx.put("foo", "bar")).subscribe();
+    	p.contextWrite(ctx -> ctx.put("foo", "bar")).subscribe();
 
     	assertThat(p.sink().currentContext().get("foo").toString()).isEqualTo("bar");
 	}

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -289,10 +289,10 @@ public void fromCompletionStageSupplier() {
 	@Test
 	public void monoCacheContextHistory() {
 		AtomicInteger contextFillCount = new AtomicInteger();
-		Mono<String> cached = Mono.subscriberContext()
+		Mono<String> cached = Mono.deferContextual(Mono::just)
 		                          .map(ctx -> ctx.getOrDefault("a", "BAD"))
 		                          .cache()
-		                          .subscriberContext(ctx -> ctx.put("a", "GOOD" + contextFillCount.incrementAndGet()));
+		                          .contextWrite(ctx -> ctx.put("a", "GOOD" + contextFillCount.incrementAndGet()));
 
 		//at first pass, the context is captured
 		String cacheMiss = cached.block();

File: reactor-test/src/test/java/reactor/test/StepVerifierAssertionsTests.java
Patch:
@@ -709,7 +709,7 @@ public void assertOperationErrorShortcutTestTupleContainsError() {
 
 	@Test
 	public void contextDiscardCaptureWithNoInitialContext() {
-		StepVerifier.create(Mono.subscriberContext()
+		StepVerifier.create(Mono.deferContextual(Mono::just)
 		                        .flatMapIterable(ctx -> ctx.stream()
 		                                                   .map(Map.Entry::getKey)
 		                                                   .map(String::valueOf)
@@ -726,7 +726,7 @@ public void contextDiscardCaptureWithNoInitialContext() {
 	@Test
 	public void contextDiscardCaptureWithInitialContext() {
 		Context initial = Context.of("foo", "bar");
-		StepVerifier.create(Mono.subscriberContext()
+		StepVerifier.create(Mono.deferContextual(Mono::just)
 				.flatMapIterable(ctx -> ctx.stream()
 				                           .map(Map.Entry::getKey)
 				                           .map(String::valueOf)

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -2043,7 +2043,7 @@ public void virtualTimeSchedulerVeryLong() {
 
 	@Test
 	public void withInitialContext() {
-		StepVerifier.create(Mono.subscriberContext(),
+		StepVerifier.create(Mono.deferContextual(Mono::just),
 				StepVerifierOptions.create().withInitialContext(Context.of("foo", "bar")))
 		            .assertNext(c -> Assertions.assertThat(c.getOrDefault("foo", "baz"))
 		                                       .isEqualTo("bar"))

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -247,7 +247,7 @@ public T get() {
 		}
 
 		@Override
-		public ContextView getContext() {
+		public ContextView getContextView() {
 			return cachedContext;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/ImmutableSignal.java
Patch:
@@ -79,7 +79,7 @@ public SignalType getType() {
 	}
 
 	@Override
-	public ContextView getContext() {
+	public ContextView getContextView() {
 		return contextView;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java
Patch:
@@ -218,8 +218,8 @@ public SignalType getType() {
 		 * implemented for use in the main's STATE compareAndSet.
 		 */
 		@Override
-		public ContextView getContext() {
-			throw new UnsupportedOperationException("illegal signal use: getContext");
+		public ContextView getContextView() {
+			throw new UnsupportedOperationException("illegal signal use: getContextView");
 		}
 
 		final boolean add(Operators.MonoSubscriber<T, T> toAdd) {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferTest.java
Patch:
@@ -85,7 +85,7 @@ public void deferStream(){
 	@Test
 	public void deferFluxWithContext() {
 		Flux<Integer> source = Flux
-				.deferWithContext(ctx -> {
+				.deferContextual(ctx -> {
 					AtomicInteger i = ctx.get("i");
 					return Mono.just(i.incrementAndGet());
 				})

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferTest.java
Patch:
@@ -41,7 +41,7 @@ public void deferMono(){
 	@Test
 	public void deferMonoWithContext() {
 		Mono<Integer> source = Mono
-				.deferWithContext(ctx -> {
+				.deferContextual(ctx -> {
 					AtomicInteger i = ctx.get("i");
 					return Mono.just(i.incrementAndGet());
 				})
@@ -68,7 +68,7 @@ public void scanOperator() {
 	public void scanOperatorWithContext() {
 		AtomicInteger i = new AtomicInteger();
 
-		MonoDeferWithContext<Integer> test = new MonoDeferWithContext<>(c -> Mono.just(i.incrementAndGet()));
+		MonoDeferContextual<Integer> test = new MonoDeferContextual<>(c -> Mono.just(i.incrementAndGet()));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();

File: reactor-core/src/test/java/reactor/core/publisher/SignalTest.java
Patch:
@@ -346,7 +346,7 @@ public Object get() {
 			}
 
 			@Override
-			public ContextView getContext() {
+			public ContextView getContextView() {
 				return Context.empty();
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -171,8 +171,9 @@ public final void onNext(T x) {
 				consumer.accept(x);
 			}
 			catch (Throwable t) {
-				Operators.onErrorDropped(t, this.initialContext);
-				return;
+				Exceptions.throwIfFatal(t);
+				s.cancel();
+				doError(t);
 			}
 		}
 		if (completeConsumer != null) {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3863,7 +3863,7 @@ public final Mono<T> subscriberContext(Function<Context, Context> doOnContext) {
 	 *
 	 * @param scheduler a {@link Scheduler} providing the {@link Worker} where to subscribe
 	 *
-	 * @return a {@link Flux} requesting asynchronously
+	 * @return a {@link Mono} requesting asynchronously
 	 * @see #publishOn(Scheduler)
 	 */
 	public final Mono<T> subscribeOn(Scheduler scheduler) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -20,12 +20,14 @@
 import java.util.function.Consumer;
 
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 import static reactor.core.Scannable.Attr.RUN_STYLE;
 import static reactor.core.Scannable.Attr.RunStyle.SYNC;
@@ -245,7 +247,7 @@ public T get() {
 		}
 
 		@Override
-		public Context getContext() {
+		public ContextView getContext() {
 			return cachedContext;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.function.Supplier;
 
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
@@ -31,6 +32,7 @@
 import reactor.util.Loggers;
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 /**
  * An operator that caches the value from a source Mono with a TTL, after which the value
@@ -216,7 +218,7 @@ public SignalType getType() {
 		 * implemented for use in the main's STATE compareAndSet.
 		 */
 		@Override
-		public Context getContext() {
+		public ContextView getContext() {
 			throw new UnsupportedOperationException("illegal signal use: getContext");
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDeferWithContext.java
Patch:
@@ -21,6 +21,7 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 /**
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
@@ -31,9 +32,9 @@
  */
 final class MonoDeferWithContext<T> extends Mono<T> implements SourceProducer<T> {
 
-	final Function<Context, ? extends Mono<? extends T>> supplier;
+	final Function<ContextView, ? extends Mono<? extends T>> supplier;
 
-	MonoDeferWithContext(Function<Context, ? extends Mono<? extends T>> supplier) {
+	MonoDeferWithContext(Function<ContextView, ? extends Mono<? extends T>> supplier) {
 		this.supplier = Objects.requireNonNull(supplier, "supplier");
 	}
 

File: reactor-core/src/main/java/reactor/util/context/ContextN.java
Patch:
@@ -165,7 +165,7 @@ public void unsafePutAllInto(ContextN other) {
 	}
 
 	@Override
-	public Context putAll(Context other) {
+	public Context putAll(ContextView other) {
 		if (other.isEmpty()) return this;
 
 		// slightly less wasteful implementation for non-core context:

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -43,6 +43,7 @@
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 import reactor.util.function.Tuple2;
 import reactor.util.retry.Retry;
 import reactor.util.retry.RetryBackoffSpec;
@@ -588,7 +589,7 @@ public void inners() {
 	public void retryWhenContextTrigger_MergesOriginalContext() {
 		final int RETRY_COUNT = 3;
 		List<Integer> retriesLeft = Collections.synchronizedList(new ArrayList<>(4));
-		List<Context> contextPerRetry = Collections.synchronizedList(new ArrayList<>(4));
+		List<ContextView> contextPerRetry = Collections.synchronizedList(new ArrayList<>(4));
 
 		Flux<Object> retryWithContext =
 				Flux.error(new IllegalStateException("boom"))

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoOnEachTest.java
Patch:
@@ -37,6 +37,7 @@
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
 
@@ -249,7 +250,7 @@ public void consumerBubbleError() {
 
 	@Test
 	public void nextComplete() {
-		List<Tuple2<Signal, Context>> signalsAndContext = new ArrayList<>();
+		List<Tuple2<Signal, ContextView>> signalsAndContext = new ArrayList<>();
 		Mono.just(1)
 		    .hide()
 		    .doOnEach(s -> signalsAndContext.add(Tuples.of(s, s.getContext())))
@@ -271,7 +272,7 @@ public void nextComplete() {
 
 	@Test
 	public void nextError() {
-		List<Tuple2<Signal, Context>> signalsAndContext = new ArrayList<>();
+		List<Tuple2<Signal, ContextView>> signalsAndContext = new ArrayList<>();
 		Mono.just(0)
 		    .map(i -> 10 / i)
 		    .doOnEach(s -> signalsAndContext.add(Tuples.of(s,s.getContext())))

File: reactor-core/src/test/java/reactor/core/publisher/SignalTest.java
Patch:
@@ -17,8 +17,10 @@
 
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.test.StepVerifier;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -344,7 +346,7 @@ public Object get() {
 			}
 
 			@Override
-			public Context getContext() {
+			public ContextView getContext() {
 				return Context.empty();
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5174,7 +5174,7 @@ public final <R> Flux<R> flatMapIterable(Function<? super T, ? extends Iterable<
 	 * signal is then propagated as normal.
 	 *
 	 * @param mapper the {@link Function} to transform input sequence into N {@link Iterable}
-	 * @param prefetch the maximum in-flight elements from each inner {@link Iterable} sequence
+	 * @param prefetch the number of values to request from the source upon subscription, to be transformed to {@link Iterable}
 	 * @param <R> the merged output sequence type
 	 * @return a concatenation of the values from the Iterables obtained from each element in this {@link Flux}
 	 */

File: buildSrc/src/main/java/io/reactor/gradle/JavaConventions.java
Patch:
@@ -64,7 +64,9 @@ private void applyJavaConvention(Project project) {
 					       "-Xlint:-serial",      // intentionally disabled
 					       "-Xlint:-options",     // intentionally disabled
 					       "-Xlint:-fallthrough", // intentionally disabled
-					       "-Xlint:-rawtypes"     // TODO enable and fix warnings
+					       "-Xlint:-rawtypes",     // TODO enable and fix warnings
+						   "-Xmaxwarns",
+						   "1000"
 			       ));
 		       });
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java
Patch:
@@ -183,6 +183,7 @@ public void onNext(T t) {
 				Objects.requireNonNull(p, "The mapper returned a null Publisher");
 
 				if (p instanceof Callable) {
+					@SuppressWarnings("unchecked")
 					Callable<R> callable = (Callable<R>) p;
 
 					R result = callable.call();

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferPredicateTest.java
Patch:
@@ -979,7 +979,7 @@ public void testBufferPredicateWhileDoesntIncludeBoundary() {
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
 		FluxBufferPredicate<Integer, ArrayList<Integer>> test =
-				new FluxBufferPredicate<>(parent, v -> (Integer) v != 0, ArrayList::new, FluxBufferPredicate.Mode.UNTIL);
+				new FluxBufferPredicate<>(parent, v -> v != 0, ArrayList::new, FluxBufferPredicate.Mode.UNTIL);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTest.java
Patch:
@@ -442,7 +442,7 @@ public void bufferWillRerouteAsManyElementAsSpecified() {
 
 	@Test
 	public void scanOperator(){
-	    FluxBuffer<Integer, List<Integer>> test = new FluxBuffer(Flux.just(1, 2, 3), 2, 1, ArrayList::new);
+	    FluxBuffer<Integer, List<Integer>> test = new FluxBuffer<>(Flux.just(1, 2, 3), 2, 1, ArrayList::new);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferWhenTest.java
Patch:
@@ -360,7 +360,7 @@ public void bufferWillSubdivideAnInputFluxGapTime() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> source = Flux.just(1);
-		FluxBufferWhen test = new FluxBufferWhen(source,
+		FluxBufferWhen<Integer, ?, ?, List<Integer>> test = new FluxBufferWhen<>(source,
 				Flux.interval(Duration.ZERO, Duration.ofMillis(200)),
 				open -> Mono.delay(Duration.ofMillis(100)),
 				ArrayList::new,

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -270,8 +270,9 @@ public void scanOperator() {
 	@Test
 	public void scanSubscriber() {
 		CoreSubscriber<String> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
+		@SuppressWarnings("unchecked")
 		Publisher<String>[] publishers = (Publisher<String>[]) new Publisher[0];
-		FluxConcatArray.ConcatArraySubscriber<String> test = new FluxConcatArray.ConcatArraySubscriber(actual, publishers);
+		FluxConcatArray.ConcatArraySubscriber<String> test = new FluxConcatArray.ConcatArraySubscriber<>(actual, publishers);
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatIterableTest.java
Patch:
@@ -101,7 +101,7 @@ public void singleSourceIsNull() {
 
 	@Test
 	public void scanOperator(){
-	    FluxConcatIterable<Integer> test = new FluxConcatIterable(Arrays.asList(source, source, source));
+	    FluxConcatIterable<Integer> test = new FluxConcatIterable<>(Arrays.asList(source, source, source));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
@@ -110,7 +110,7 @@ public void scanOperator(){
 	public void scanSubscriber(){
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		List<Publisher<Integer>> publishers = Arrays.asList(source, source, source);
-		FluxConcatIterable.ConcatIterableSubscriber<Integer> test = new FluxConcatIterable.ConcatIterableSubscriber(actual, publishers.iterator());
+		FluxConcatIterable.ConcatIterableSubscriber<Integer> test = new FluxConcatIterable.ConcatIterableSubscriber<>(actual, publishers.iterator());
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapNoPrefetchTest.java
Patch:
@@ -79,7 +79,7 @@ public void noRequestBeforeOnCompleteWithZeroPrefetch() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1, 2);
-		FluxConcatMapNoPrefetch<Integer, String> test = new FluxConcatMapNoPrefetch(parent, Flux.IDENTITY_FUNCTION , FluxConcatMap.ErrorMode.END);
+		FluxConcatMapNoPrefetch<Integer, String> test = new FluxConcatMapNoPrefetch<>(parent, i -> Flux.just(i.toString()) , FluxConcatMap.ErrorMode.END);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isZero();
@@ -89,8 +89,8 @@ public void scanOperator(){
 	@Test
 	public void scanConcatMapNoPrefetchDelayError() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		FluxConcatMapNoPrefetch.FluxConcatMapNoPrefetchSubscriber test =
-				new FluxConcatMapNoPrefetch.FluxConcatMapNoPrefetchSubscriber(actual, Flux.IDENTITY_FUNCTION, FluxConcatMap.ErrorMode.END);
+		FluxConcatMapNoPrefetch.FluxConcatMapNoPrefetchSubscriber<Integer, Integer> test =
+				new FluxConcatMapNoPrefetch.FluxConcatMapNoPrefetchSubscriber<>(actual, Flux::just, FluxConcatMap.ErrorMode.END);
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -207,7 +207,7 @@ public void prefetchMaxTranslatesToUnboundedRequest2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1, 2);
-		FluxConcatMap<Integer, String> test = new FluxConcatMap(parent, Flux.IDENTITY_FUNCTION , Queues.one(), Integer.MAX_VALUE, FluxConcatMap.ErrorMode.END);
+		FluxConcatMap<Integer, Integer> test = new FluxConcatMap<>(parent, Flux::just, Queues.one(), Integer.MAX_VALUE, FluxConcatMap.ErrorMode.END);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -295,7 +295,7 @@ public void scanConcatMapInner(){
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		FluxConcatMap.ConcatMapImmediate<String, Integer> parent = new FluxConcatMap.ConcatMapImmediate<>(
 				actual, s -> Mono.just(s.length()), Queues.one(), 123);
-		FluxConcatMap.ConcatMapInner test = new FluxConcatMap.ConcatMapInner(parent);
+		FluxConcatMap.ConcatMapInner<Integer> test = new FluxConcatMap.ConcatMapInner<>(parent);
 
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxContextStartTest.java
Patch:
@@ -13,7 +13,7 @@ public class FluxContextStartTest {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxContextStart test = new FluxContextStart(parent, c -> c);
+		FluxContextStart<Integer> test = new FluxContextStart<>(parent, c -> c);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -22,7 +22,7 @@ public void scanOperator(){
 	@Test
 	public void scanSubscriber(){
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		FluxContextStart.ContextStartSubscriber test = new FluxContextStart.ContextStartSubscriber(actual, Context.empty());
+		FluxContextStart.ContextStartSubscriber<Integer> test = new FluxContextStart.ContextStartSubscriber<>(actual, Context.empty());
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -1164,7 +1164,7 @@ public void pushToSink() {
 
 	@Test
 	public void scanOperator(){
-		FluxCreate test = new FluxCreate(v -> Arrays.asList(1, 2, 3), OverflowStrategy.BUFFER, FluxCreate.CreateMode.PUSH_ONLY);
+		FluxCreate<?> test = new FluxCreate<>(v -> {}, OverflowStrategy.BUFFER, FluxCreate.CreateMode.PUSH_ONLY);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.ASYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferTest.java
Patch:
@@ -100,7 +100,7 @@ public void deferFluxWithContext() {
 
 	@Test
 	public void scanOperator(){
-	    FluxDefer<Integer> test = new FluxDefer(() -> Flux.just(1));
+	    FluxDefer<Integer> test = new FluxDefer<>(() -> Flux.just(1));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDeferWithContextTest.java
Patch:
@@ -9,7 +9,7 @@ public class FluxDeferWithContextTest {
 
 	@Test
 	public void scanOperator(){
-		FluxDeferWithContext test = new FluxDeferWithContext(context -> Flux.just(1));
+		FluxDeferWithContext<Integer> test = new FluxDeferWithContext<>(context -> Flux.just(1));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDematerializeTest.java
Patch:
@@ -284,8 +284,8 @@ public void emissionTimingsAreGrouped() {
 
 	@Test
 	public void scanOperator(){
-		Flux<Integer> parent = Flux.just(1);
-		FluxDematerialize<Integer> test = new FluxDematerialize(parent);
+		Flux<Signal<Integer>> parent = Flux.just(Signal.next(1));
+		FluxDematerialize<Integer> test = new FluxDematerialize<>(parent);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxDetachTest.java
Patch:
@@ -184,7 +184,7 @@ public void deferredUpstreamProducer() {
 	
 	@Test
 	public void scanOperator(){
-	    FluxDetach<String> test = new FluxDetach(Flux.just(1));
+	    FluxDetach<Integer> test = new FluxDetach<>(Flux.just(1));
 	    
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFinallyTest.java
Patch:
@@ -391,7 +391,7 @@ public void scanOperator(){
 	@Test
 	public void scanFuseableOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxDoFinallyFuseable test = new FluxDoFinallyFuseable(parent, s -> {});
+		FluxDoFinallyFuseable<Integer> test = new FluxDoFinallyFuseable<>(parent, s -> {});
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorSuppliedTest.java
Patch:
@@ -98,7 +98,7 @@ private Supplier<IllegalStateException> illegalStateExceptionSupplier() {
 
 	@Test
 	public void scanOperator(){
-	    FluxErrorSupplied test = new FluxErrorSupplied(() -> new IllegalStateException());
+	    FluxErrorSupplied<?> test = new FluxErrorSupplied<>(() -> new IllegalStateException());
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterFuseableTest.java
Patch:
@@ -36,7 +36,7 @@ public class FluxFilterFuseableTest extends FluxOperatorTest<String, String> {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxFilterFuseable<Integer> test = new FluxFilterFuseable(parent, e -> true);
+		FluxFilterFuseable<Integer> test = new FluxFilterFuseable<>(parent, e -> true);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -258,7 +258,7 @@ public void asyncFusionBackpressured2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxFilter test = new FluxFilter(parent, e -> true);
+		FluxFilter<Integer> test = new FluxFilter<>(parent, e -> true);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -402,7 +402,7 @@ public void introspectionCancel() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxFilterWhen test = new FluxFilterWhen(parent, v -> true, 123);
+		FluxFilterWhen<Integer> test = new FluxFilterWhen<>(parent, v -> Flux.just(true), 123);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxFirstEmittingTest.java
Patch:
@@ -143,7 +143,8 @@ public void iterableOneIsNullSource() {
 
 	@Test
 	public void scanOperator(){
-	    FluxFirstEmitting test = new FluxFirstEmitting(Flux.range(1, 10), Flux.range(11, 10));
+		@SuppressWarnings("unchecked")
+	    FluxFirstEmitting<Integer> test = new FluxFirstEmitting<>(Flux.range(1, 10), Flux.range(11, 10));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxHandleTest.java
Patch:
@@ -388,7 +388,7 @@ public void dropHandleFusedSync() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxHandle test = new FluxHandle(parent, (t, s) -> { });
+		FluxHandle<Integer, ?> test = new FluxHandle<>(parent, (t, s) -> { });
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -397,7 +397,7 @@ public void scanOperator(){
 	@Test
 	public void scanFuseableOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxHandleFuseable test = new FluxHandleFuseable(parent, (t, s) -> { });
+		FluxHandleFuseable<Integer, ?> test = new FluxHandleFuseable<>(parent, (t, s) -> { });
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxHideTest.java
Patch:
@@ -120,7 +120,7 @@ public void onComplete() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxHide test = new FluxHide(parent);
+		FluxHide<Integer> test = new FluxHide<>(parent);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxJoinTest.java
Patch:
@@ -257,7 +257,7 @@ public void resultSelectorThrows() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxJoin test = new FluxJoin(parent, Flux.just(2), just(Flux.just(3)), just(Flux.just(4)), add);
+		FluxJoin<Integer, Integer, Integer, Integer, Integer> test = new FluxJoin<>(parent, Flux.just(2), just(Flux.just(3)), just(Flux.just(4)), add);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(-1);

File: reactor-core/src/test/java/reactor/core/publisher/FluxMapSignalTest.java
Patch:
@@ -134,7 +134,7 @@ public void flatMapSignal2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxMapSignal test = new FluxMapSignal(parent, v -> v, v -> v, () -> Flux.just(10));
+		FluxMapSignal<Integer, Integer> test = new FluxMapSignal<>(parent, v -> v, e -> 1, () -> 10);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxMapTest.java
Patch:
@@ -301,7 +301,7 @@ public void hiddenMapHiddenFilterBackpressured() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxMap<String, String> test = new FluxMap(parent, v -> v.toString());
+		FluxMap<Integer, String> test = new FluxMap<>(parent, v -> v.toString());
 
 	    assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -342,7 +342,7 @@ public void scanConditionalSubscriber() {
 
 	@Test
 	public void scanFuseableOperator(){
-		FluxMapFuseable<String, String> test = new FluxMapFuseable(Flux.just(1), v -> v.toString());
+		FluxMapFuseable<Integer, String> test = new FluxMapFuseable<>(Flux.just(1), v -> v.toString());
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxMaterializeTest.java
Patch:
@@ -165,7 +165,7 @@ public void materialize2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxMaterialize test = new FluxMaterialize(parent);
+		FluxMaterialize<Integer> test = new FluxMaterialize<>(parent);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeSequentialTest.java
Patch:
@@ -800,7 +800,7 @@ public void cancellingSequentiallyFlatMappedMonos() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.range(1, 5);
-		FluxMergeSequential test = new FluxMergeSequential(parent, t -> Flux.just(t), 3, 123, ErrorMode.END);
+		FluxMergeSequential<Integer, Integer> test = new FluxMergeSequential<>(parent, t -> Flux.just(t), 3, 123, ErrorMode.END);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -810,7 +810,7 @@ public void scanOperator(){
     public void scanMain() {
         CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxMergeSequential.MergeSequentialMain<Integer, Integer> test =
-        		new FluxMergeSequential.MergeSequentialMain<Integer, Integer>(actual, i -> Mono.just(i),
+        		new FluxMergeSequential.MergeSequentialMain<>(actual, i -> Mono.just(i),
         				5, 123, ErrorMode.BOUNDARY, Queues.unbounded());
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxMetricsFuseableTest.java
Patch:
@@ -477,7 +477,7 @@ protected void hookOnSubscribe(Subscription subscription) {
 	@Test
 	public void scanOperator(){
 	    Flux<Integer> parent = Flux.just(1);
-		FluxMetricsFuseable test = new FluxMetricsFuseable(parent);
+		FluxMetricsFuseable<Integer> test = new FluxMetricsFuseable<>(parent);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferStrategyTest.java
Patch:
@@ -492,7 +492,7 @@ public void fluxOnBackpressureBufferStrategyRequiresStrategy() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxOnBackpressureBufferStrategy test = new FluxOnBackpressureBufferStrategy(parent, 3, t -> {}, ERROR);
+		FluxOnBackpressureBufferStrategy<Integer> test = new FluxOnBackpressureBufferStrategy<>(parent, 3, t -> {}, ERROR);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureDropTest.java
Patch:
@@ -147,7 +147,7 @@ public void onBackpressureDrop() {
 
 	@Test
 	public void scanOperator(){
-	    FluxOnBackpressureDrop test = new FluxOnBackpressureDrop(Flux.just(1));
+	    FluxOnBackpressureDrop<Integer> test = new FluxOnBackpressureDrop<>(Flux.just(1));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -285,7 +285,7 @@ public void normalCancelBeforeComplete() {
     @Test
     public void scanOperator(){
     	Flux<Integer> parent = Flux.just(1);
-		FluxPublishMulticast test = new FluxPublishMulticast(parent, v -> v, 123, Queues::one);
+		FluxPublishMulticast<Integer, Integer> test = new FluxPublishMulticast<>(parent, v -> v, 123, Queues.one());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
     	assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1263,7 +1263,7 @@ public void callablePath() {
 	public void scanOperator(){
 		Flux<Integer> source = Flux.just(1);
 		Scheduler scheduler = Schedulers.immediate();
-		FluxPublishOn test = new FluxPublishOn(source, scheduler, false, 3, 4, Queues::one);
+		FluxPublishOn<Integer> test = new FluxPublishOn<>(source, scheduler, false, 3, 4, Queues.one());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(PREFETCH)).isEqualTo(3);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountGraceTest.java
Patch:
@@ -376,9 +376,9 @@ public void scanOperator() {
 	@Test
 	public void scanInner(){
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, sub -> sub.request(100));
-		FluxRefCountGrace<Integer> parent = new FluxRefCountGrace(Flux.just(10).publish(), 17, Duration.ofSeconds(1), Schedulers.single());
+		FluxRefCountGrace<Integer> parent = new FluxRefCountGrace<>(Flux.just(10).publish(), 17, Duration.ofSeconds(1), Schedulers.single());
 
-		FluxRefCountGrace.RefCountInner test = new FluxRefCountGrace.RefCountInner(actual, parent, new FluxRefCountGrace.RefConnection(parent));
+		FluxRefCountGrace.RefCountInner<Integer> test = new FluxRefCountGrace.RefCountInner<>(actual, parent, new FluxRefCountGrace.RefConnection(parent));
 
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatPredicateTest.java
Patch:
@@ -169,7 +169,7 @@ public void alwaysFalseWithNSimilarToSimpleZero() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRepeatPredicate test = new FluxRepeatPredicate(parent, () -> true);
+		FluxRepeatPredicate<Integer> test = new FluxRepeatPredicate<>(parent, () -> true);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -180,7 +180,7 @@ public void scanSubscriber(){
 		Flux<Integer> source = Flux.just(1);
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		FluxRepeatPredicate.RepeatPredicateSubscriber<Integer> test =
-				new FluxRepeatPredicate.RepeatPredicateSubscriber(source, actual,  () -> true);
+				new FluxRepeatPredicate.RepeatPredicateSubscriber<>(source, actual,  () -> true);
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatTest.java
Patch:
@@ -195,7 +195,7 @@ public void onLastAssemblyOnce() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRepeat test = new FluxRepeat(parent, 4);
+		FluxRepeat<Integer> test = new FluxRepeat<>(parent, 4);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -373,7 +373,7 @@ Flux<String> exponentialRepeatScenario2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRepeatWhen<Integer> test = new FluxRepeatWhen(parent, v -> (Integer) v != 10);
+		FluxRepeatWhen<Integer> test = new FluxRepeatWhen<>(parent, c -> c.take(3));
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryPredicateTest.java
Patch:
@@ -238,7 +238,7 @@ public void twoRetryErrorSupplier2() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRetryPredicate test = new FluxRetryPredicate(parent, p -> true);
+		FluxRetryPredicate<Integer> test = new FluxRetryPredicate<>(parent, p -> true);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -249,7 +249,7 @@ public void scanSubscriber(){
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		Flux<Integer> source = Flux.just(1);
 		FluxRetryPredicate.RetryPredicateSubscriber<Integer> test =
-				new FluxRetryPredicate.RetryPredicateSubscriber(source, actual, p -> true);
+				new FluxRetryPredicate.RetryPredicateSubscriber<>(source, actual, p -> true);
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryTest.java
Patch:
@@ -168,7 +168,7 @@ public void onLastAssemblyOnce() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRetry<Integer> test = new FluxRetry(parent, 3L);
+		FluxRetry<Integer> test = new FluxRetry<>(parent, 3L);
 
 	    assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 	    assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(-1);
@@ -178,8 +178,8 @@ public void scanOperator(){
 	@Test
 	public void scanSubscriber(){
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
-		FluxRetry<Integer> source = new FluxRetry(Flux.just(1), 3L);
-		FluxRetry.RetrySubscriber<Integer> test = new FluxRetry.RetrySubscriber(source, ts, 1L);
+		FluxRetry<Integer> source = new FluxRetry<>(Flux.just(1), 3L);
+		FluxRetry.RetrySubscriber<Integer> test = new FluxRetry.RetrySubscriber<>(source, ts, 1L);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -370,7 +370,7 @@ public void fixedDelaysRetry() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxRetryWhen test = new FluxRetryWhen(parent, Retry.from(other -> Flux.just(2)));
+		FluxRetryWhen<Integer> test = new FluxRetryWhen<>(parent, Retry.from(other -> Flux.just(2)));
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(-1);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleFirstTest.java
Patch:
@@ -179,7 +179,7 @@ public void sampleFirstTime(){
 
 	@Test
 	public void scanOperator(){
-	    FluxSampleFirst<Integer, Integer> test = new FluxSampleFirst(Flux.just(1), i -> i);
+	    FluxSampleFirst<Integer, Integer> test = new FluxSampleFirst<>(Flux.just(1), i -> Flux.just(i));
 
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleTimeoutTest.java
Patch:
@@ -205,7 +205,7 @@ public void sampleTimeoutTime2(){
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxSampleTimeout test = new FluxSampleTimeout(parent, v -> Flux.just(2), Queues::empty);
+		FluxSampleTimeout<Integer, Integer> test = new FluxSampleTimeout<>(parent, v -> Flux.just(2), Queues.empty());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxScanSeedTest.java
Patch:
@@ -232,7 +232,7 @@ public void noRetainValueOnError() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxScanSeed test = new FluxScanSeed(parent, () -> Flux.empty(), (v1, v2) -> Flux.just(1));
+		FluxScanSeed<Integer, Integer> test = new FluxScanSeed<>(parent, () -> 0, (v1, v2) -> 1);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -241,8 +241,8 @@ public void scanOperator(){
 	@Test
 	public void scanCoordinator(){
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		FluxScanSeed.ScanSeedCoordinator test =
-				new FluxScanSeed.ScanSeedCoordinator(actual, Flux.just(1), (v1, v2) -> Flux.just(1), () -> Flux.empty());
+		FluxScanSeed.ScanSeedCoordinator<Integer, Integer> test =
+				new FluxScanSeed.ScanSeedCoordinator<>(actual, Flux.just(1), (v1, v2) -> v1, () -> 0);
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxScanTest.java
Patch:
@@ -200,7 +200,7 @@ public void noRetainValueOnError() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxScan test = new FluxScan(parent, (v1, v2) -> Flux.just(v1));
+		FluxScan<Integer> test = new FluxScan<>(parent, (v1, v2) -> v1);
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipLastTest.java
Patch:
@@ -178,7 +178,7 @@ public void skipAllBackpressured() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxSkipLast test = new FluxSkipLast(parent, 3);
+		FluxSkipLast<Integer> test = new FluxSkipLast<>(parent, 3);
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipUntilOtherTest.java
Patch:
@@ -256,7 +256,7 @@ public void aFluxCanBeSkippedByTimeZero(){
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxSkipUntilOther test = new FluxSkipUntilOther(parent, Flux.just(2));
+		FluxSkipUntilOther<Integer, Integer> test = new FluxSkipUntilOther<>(parent, Flux.just(2));
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipWhileTest.java
Patch:
@@ -201,7 +201,7 @@ public void aFluxCanBeSkippedWhile(){
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxSkipWhile test = new FluxSkipWhile(parent, p -> true);
+		FluxSkipWhile<Integer> test = new FluxSkipWhile<>(parent, p -> true);
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxStreamTest.java
Patch:
@@ -452,7 +452,7 @@ public void intermediateCloseIdempotent() {
 
 	@Test
 	public void scanOperator(){
-		FluxStream test = new FluxStream(() -> source.stream());
+		FluxStream<Integer> test = new FluxStream<>(() -> source.stream());
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchIfEmptyTest.java
Patch:
@@ -109,7 +109,7 @@ public void emptyBackpressured() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxSwitchIfEmpty test = new FluxSwitchIfEmpty(parent, Flux.just(2));
+		FluxSwitchIfEmpty<Integer> test = new FluxSwitchIfEmpty<>(parent, Flux.just(2));
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeLastTest.java
Patch:
@@ -169,7 +169,7 @@ public void takeAllBackpressured() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1, 2, 3, 4, 5);
-		FluxTakeLast<Integer> test = new FluxTakeLast(parent, 3);
+		FluxTakeLast<Integer> test = new FluxTakeLast<>(parent, 3);
 
 	    Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 	    Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeUntilPredicateTest.java
Patch:
@@ -162,7 +162,7 @@ public void predicateThrows() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxTakeUntil test = new FluxTakeUntil(parent, v -> true);
+		FluxTakeUntil<Integer> test = new FluxTakeUntil<>(parent, v -> true);
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeWhileTest.java
Patch:
@@ -174,7 +174,7 @@ public void aFluxCanBeLimitedWhile(){
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxTakeWhile test = new FluxTakeWhile(parent, v -> true);
+		FluxTakeWhile<Integer> test = new FluxTakeWhile<>(parent, v -> true);
 
 		Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		Assertions.assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -251,7 +251,7 @@ public void windowWillAccumulateMultipleListsOfValues() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxWindowBoundary test = new FluxWindowBoundary(parent, Flux.just(2), Queues::empty);
+		FluxWindowBoundary<Integer, Integer> test = new FluxWindowBoundary<>(parent, Flux.just(2), Queues.empty());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -1059,7 +1059,7 @@ public void discardOnWindowCancel() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxWindowPredicate test = new FluxWindowPredicate(parent, Queues::empty, Queues::empty, 35, v -> true, Mode.UNTIL);
+		FluxWindowPredicate<Integer> test = new FluxWindowPredicate<>(parent, Queues.empty(), Queues.empty(), 35, v -> true, Mode.UNTIL);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTest.java
Patch:
@@ -582,7 +582,7 @@ public void windowWillRerouteAsManyElementAsSpecified(){
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxWindow test = new FluxWindow(parent, 3, Queues::empty);
+		FluxWindow<Integer> test = new FluxWindow<>(parent, 3, Queues.empty());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowWhenTest.java
Patch:
@@ -578,7 +578,7 @@ public void mainDoneThenComplete() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> parent = Flux.just(1);
-		FluxWindowWhen test = new FluxWindowWhen(parent, Flux.just(2), v -> Flux.empty(), Queues::empty);
+		FluxWindowWhen<Integer, Integer, Object> test = new FluxWindowWhen<>(parent, Flux.just(2), v -> Flux.empty(), Queues.empty());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/MonoAllTest.java
Patch:
@@ -110,7 +110,7 @@ public void predicateThrows() {
 
 	@Test
 	public void scanOperator(){
-	    MonoAll<Integer> test = new MonoAll(Flux.just(1, 2, 3), v -> true);
+	    MonoAll<Integer> test = new MonoAll<>(Flux.just(1, 2, 3), v -> true);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoAnyTest.java
Patch:
@@ -174,7 +174,7 @@ public void cancel() {
 	@Test
 	public void scanOperator() {
 		Flux<Integer> parent = Flux.just(1);
-		MonoAny test = new MonoAny(parent, v -> true);
+		MonoAny<Integer> test = new MonoAny<>(parent, v -> true);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectListTest.java
Patch:
@@ -152,7 +152,7 @@ public void protocolErrorsOnError() {
 	@Test
 	public void scanOperator(){
 	    Flux<Integer> source = Flux.just(1);
-		MonoCollectList test = new MonoCollectList(source);
+		MonoCollectList<Integer> test = new MonoCollectList<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);

File: reactor-core/src/test/java/reactor/core/publisher/MonoCollectTest.java
Patch:
@@ -134,7 +134,7 @@ public void actionThrows() {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> source = Flux.just(1, 2, 3);
-		MonoCollect test = new MonoCollect(source, () -> 1, (a, b) -> {});
+		MonoCollect<Integer, List<Integer>> test = new MonoCollect<>(source, ArrayList::new, (a, b) -> {});
 
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/MonoCompletionStageTest.java
Patch:
@@ -151,7 +151,7 @@ public void stackOverflowGoesToOnErrorDropped() {
 	@Test
 	public void scanOperator(){
 		CompletionStage<String> completionStage = CompletableFuture.supplyAsync(() -> "helloFuture");
-		MonoCompletionStage<String> test = new MonoCompletionStage(completionStage);
+		MonoCompletionStage<String> test = new MonoCompletionStage<>(completionStage);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.ASYNC);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();

File: reactor-core/src/test/java/reactor/core/publisher/MonoCountTest.java
Patch:
@@ -59,7 +59,7 @@ public void normalBackpressured() {
 
 	@Test
 	public void scanOperator(){
-	    MonoCount test = new MonoCount(Flux.just(1, 2, 3));
+	    MonoCount<Integer> test = new MonoCount<>(Flux.just(1, 2, 3));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -318,7 +318,7 @@ public void delayUntilTriggerProviderThrows() {
 
 	@Test
 	public void scanOperator() {
-		MonoCreate<String> test = new MonoCreate(null);
+		MonoCreate<String> test = new MonoCreate<>(null);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.ASYNC);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();

File: reactor-core/src/test/java/reactor/core/publisher/MonoDeferTest.java
Patch:
@@ -58,7 +58,7 @@ public void deferMonoWithContext() {
 	public void scanOperator() {
 		AtomicInteger i = new AtomicInteger();
 
-		MonoDefer<Integer> test = new MonoDefer(() -> Mono.just(i.incrementAndGet()));
+		MonoDefer<Integer> test = new MonoDefer<>(() -> Mono.just(i.incrementAndGet()));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();
@@ -68,7 +68,7 @@ public void scanOperator() {
 	public void scanOperatorWithContext() {
 		AtomicInteger i = new AtomicInteger();
 
-		MonoDeferWithContext<Integer> test = new MonoDeferWithContext(c -> Mono.just(i.incrementAndGet()));
+		MonoDeferWithContext<Integer> test = new MonoDeferWithContext<>(c -> Mono.just(i.incrementAndGet()));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelaySubscriptionTest.java
Patch:
@@ -175,7 +175,7 @@ public void neverTriggered() {
 
 	@Test
 	public void scanOperator(){
-		MonoDelaySubscription<Integer, Integer> test = new MonoDelaySubscription(Mono.just(1), Mono.just(2));
+		MonoDelaySubscription<Integer, Integer> test = new MonoDelaySubscription<>(Mono.just(1), Mono.just(2));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java
Patch:
@@ -205,7 +205,7 @@ public void testAPIchainingCumulatesDelaysAfterValueGenerated() {
 	@Test
 	public void scanOperator(){
 	    Mono<Integer> source = Mono.just(1);
-		MonoDelayUntil test = new MonoDelayUntil(source, i -> Mono.just(1));
+		MonoDelayUntil<Integer> test = new MonoDelayUntil<>(source, i -> Mono.just(1));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoDematerializeTest.java
Patch:
@@ -216,7 +216,7 @@ public void materializeDematerializeMonoError() {
 
 	@Test
 	public void scanOperator(){
-	    MonoDematerialize test = new MonoDematerialize(Mono.just(Signal.next(1)));
+	    MonoDematerialize<Integer> test = new MonoDematerialize<>(Mono.just(Signal.next(1)));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoElementAtTest.java
Patch:
@@ -218,7 +218,7 @@ public void cancel() {
 
 	@Test
 	public void scanOperator(){
-	    MonoElementAt<String> test = new MonoElementAt(Flux.just(1, 2, 3), 1);
+	    MonoElementAt<Integer> test = new MonoElementAt<>(Flux.just(1, 2, 3), 1);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoErrorSuppliedTest.java
Patch:
@@ -128,7 +128,7 @@ private Supplier<IllegalStateException> illegalStateExceptionSupplier() {
 
 	@Test
 	public void scanOperator(){
-		MonoErrorSupplied test = new MonoErrorSupplied(() -> new NullPointerException());
+		MonoErrorSupplied<?> test = new MonoErrorSupplied<>(() -> new NullPointerException());
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -318,7 +318,7 @@ public void subscribe(CoreSubscriber<? super Integer> actual) {
 
 	@Test
 	public void scanOperator(){
-	    MonoFilterWhen<Integer> test = new MonoFilterWhen(Mono.just(1), null);
+	    MonoFilterWhen<Integer> test = new MonoFilterWhen<>(Mono.just(1), null);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFirstTest.java
Patch:
@@ -134,6 +134,7 @@ public void fastestSource() {
 
 	@Test
 	public void scanOperator(){
+		@SuppressWarnings("unchecked")
 		MonoFirst<Integer> test = new MonoFirst<>(Mono.just(1), Mono.just(2));
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapManyTest.java
Patch:
@@ -63,7 +63,7 @@ public void normalInnerEmpty() {
 
 	@Test
 	public void scanOperator(){
-	    MonoFlatMapMany<String, Integer> test = new MonoFlatMapMany(Mono.just("foo"), s -> Mono.just(1));
+	    MonoFlatMapMany<String, Integer> test = new MonoFlatMapMany<>(Mono.just("foo"), s -> Mono.just(1));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlatMapTest.java
Patch:
@@ -53,7 +53,7 @@ public void cancel() {
 
 	@Test
 	public void scanOperator(){
-	    MonoFlatMap<String, Integer> test = new MonoFlatMap(Mono.just("foo"), s -> Mono.just(1));
+	    MonoFlatMap<String, Integer> test = new MonoFlatMap<>(Mono.just("foo"), s -> Mono.just(1));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFlattenIterableTest.java
Patch:
@@ -13,8 +13,8 @@ public class MonoFlattenIterableTest {
 
 	@Test
 	public void scanOperator() {
-		MonoFlattenIterable<Integer, ArrayList<Integer>> test =
-                new MonoFlattenIterable(Mono.just(1), i -> Arrays.asList(i), Integer.MAX_VALUE, Queues.one());
+		MonoFlattenIterable<Integer, Integer> test =
+                new MonoFlattenIterable<>(Mono.just(1), i -> Arrays.asList(i), Integer.MAX_VALUE, Queues.one());
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoFromPublisherTest.java
Patch:
@@ -9,7 +9,7 @@ public class MonoFromPublisherTest {
 
 	@Test
 	public void scanOperator(){
-		MonoFromPublisher test = new MonoFromPublisher(Flux.just("foo", "bar"));
+		MonoFromPublisher<String> test = new MonoFromPublisher<>(Flux.just("foo", "bar"));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoHandleTest.java
Patch:
@@ -56,14 +56,14 @@ public void filterNullMapResult() {
 
 	@Test
 	public void scanOperator(){
-	    MonoHandle<Integer, Integer> test = new MonoHandle(Mono.just(1), (v, s) -> {});
+	    MonoHandle<Integer, Integer> test = new MonoHandle<>(Mono.just(1), (v, s) -> {});
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test
 	public void scanFuseableOperator(){
-		MonoHandleFuseable<Integer, Integer> test = new MonoHandleFuseable(Mono.just(1), (v, s) -> {});
+		MonoHandleFuseable<Integer, Integer> test = new MonoHandleFuseable<>(Mono.just(1), (v, s) -> {});
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoHideTest.java
Patch:
@@ -35,7 +35,7 @@ public void normal() {
 	@Test
 	public void scanOperator(){
 		Mono<Integer> parent = Mono.just(1);
-		MonoHide<Integer> test = new MonoHide(parent);
+		MonoHide<Integer> test = new MonoHide<>(parent);
 
 	    assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 	    assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnoreElementTest.java
Patch:
@@ -9,7 +9,7 @@ public class MonoIgnoreElementTest {
 
     @Test
     public void scanOperator(){
-        MonoIgnoreElement<Integer> test = new MonoIgnoreElement(Mono.just(1));
+        MonoIgnoreElement<Integer> test = new MonoIgnoreElement<>(Mono.just(1));
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
     }

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnoreElementsTest.java
Patch:
@@ -12,7 +12,7 @@ public class MonoIgnoreElementsTest {
 	@Test
 	public void scanOperator(){
 		Flux<Integer> source = Flux.just(1);
-		MonoIgnoreElements<Integer> test = new MonoIgnoreElements(source);
+		MonoIgnoreElements<Integer> test = new MonoIgnoreElements<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);
@@ -22,7 +22,7 @@ public void scanOperator(){
 	@Test
 	public void scanSubscriber() {
 		CoreSubscriber<Boolean> actual = new LambdaMonoSubscriber<>(null, e -> {}, null, null);
-		MonoIgnoreElements.IgnoreElementsSubscriber test = new MonoIgnoreElements.IgnoreElementsSubscriber(actual);
+		MonoIgnoreElements.IgnoreElementsSubscriber<Boolean> test = new MonoIgnoreElements.IgnoreElementsSubscriber<>(actual);
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnorePublisherTest.java
Patch:
@@ -17,7 +17,7 @@ public void normal() {
 
     @Test
     public void scanOperator(){
-        MonoIgnoreElement<String> test = new MonoIgnoreElement(Mono.just("foo"));
+        MonoIgnoreElement<String> test = new MonoIgnoreElement<>(Mono.just("foo"));
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
     }

File: reactor-core/src/test/java/reactor/core/publisher/MonoLogTest.java
Patch:
@@ -12,7 +12,7 @@ public class MonoLogTest {
     @Test
     public void scanOperator(){
         Mono<Integer> source = Mono.just(1);
-        MonoLog<Integer> test = new MonoLog(source,
+        MonoLog<Integer> test = new MonoLog<>(source,
                 new SignalLogger<>(source, "category", Level.INFO, false, SignalType.ON_COMPLETE));
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -21,7 +21,7 @@ public void scanOperator(){
     @Test
     public void scanFuseableOperator(){
         Mono<Integer> source = Mono.just(1);
-        MonoLogFuseable<Integer> test = new MonoLogFuseable(source,
+        MonoLogFuseable<Integer> test = new MonoLogFuseable<>(source,
                 new SignalLogger<>(source, "category", Level.INFO, false, SignalType.ON_COMPLETE));
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/MonoMetricsFuseableTest.java
Patch:
@@ -72,7 +72,7 @@ public void scanOperator(){
 	@Test
 	public void scanSubscriber(){
 		CoreSubscriber<Integer> actual = new LambdaMonoSubscriber<>(null, e -> {}, null, null);
-		MetricsFuseableSubscriber<Integer> test = new MetricsFuseableSubscriber(actual, registry, Clock.SYSTEM, Tags.empty());
+		MetricsFuseableSubscriber<Integer> test = new MetricsFuseableSubscriber<>(actual, registry, Clock.SYSTEM, Tags.empty());
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoNextTest.java
Patch:
@@ -65,7 +65,7 @@ public void cancel() {
 	@Test
 	public void scanOperator(){
 		Flux<String> source = Flux.just("foo", "bar");
-		MonoNext test = new MonoNext(source);
+		MonoNext<String> test = new MonoNext<>(source);
 
 	    assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 	    assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnErrorResumeTest.java
Patch:
@@ -285,7 +285,7 @@ public void otherwiseReturnErrorUnfilter2() {
 
 	@Test
 	public void scanOperator(){
-	    MonoOnErrorResume<String> test = new MonoOnErrorResume(Mono.just("foo"), e -> Mono.just("bar"));
+	    MonoOnErrorResume<String> test = new MonoOnErrorResume<>(Mono.just("foo"), e -> Mono.just("bar"));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTerminalTest.java
Patch:
@@ -27,7 +27,7 @@ public class MonoPeekTerminalTest {
 
 	@Test
 	public void scanOperator(){
-		MonoPeekTerminal test = new MonoPeekTerminal(Mono.just("foo"), null, null, null);
+		MonoPeekTerminal<String> test = new MonoPeekTerminal<>(Mono.just("foo"), null, null, null);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekTest.java
Patch:
@@ -183,14 +183,14 @@ public void testErrorWithDoOnSuccess() {
 
 	@Test
 	public void scanOperator(){
-	    MonoPeek test = new MonoPeek(Mono.just(1), null, null, null, null);
+	    MonoPeek<Integer> test = new MonoPeek<>(Mono.just(1), null, null, null, null);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test
 	public void scanFuseableOperator(){
-		MonoPeekFuseable test = new MonoPeekFuseable(Mono.just(1), null, null, null, null);
+		MonoPeekFuseable<Integer> test = new MonoPeekFuseable<>(Mono.just(1), null, null, null, null);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java
Patch:
@@ -704,7 +704,7 @@ public void scanSubscriber(){
 		MonoProcessor<String> processor = MonoProcessor.create();
 		AssertSubscriber<String> subscriber = new AssertSubscriber<>();
 
-		MonoProcessor.NextInner test = new MonoProcessor.NextInner(subscriber, processor);
+		MonoProcessor.NextInner<String> test = new MonoProcessor.NextInner<>(subscriber, processor);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java
Patch:
@@ -306,7 +306,7 @@ public void noRetainValueOnError() {
 
 	@Test
 	public void scanOperator(){
-	    MonoReduce<Integer> test = new MonoReduce(Flux.just(1, 2, 3), (a, b) -> (Integer) a + (Integer) b);
+	    MonoReduce<Integer> test = new MonoReduce<>(Flux.just(1, 2, 3), (a, b) -> a + b);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRepeatPredicateTest.java
Patch:
@@ -70,7 +70,7 @@ public void nTwo() {
 
 	@Test
 	public void scanOperator(){
-	    MonoRepeatPredicate<Integer> test = new MonoRepeatPredicate(Mono.just(1), () -> true);
+	    MonoRepeatPredicate<Integer> test = new MonoRepeatPredicate<>(Mono.just(1), () -> true);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRepeatTest.java
Patch:
@@ -136,7 +136,7 @@ public void repeatInfinite() {
 
 	@Test
 	public void scanOperator(){
-	    MonoRepeat<Integer> test = new MonoRepeat(Mono.just(1), 5L);
+	    MonoRepeat<Integer> test = new MonoRepeat<>(Mono.just(1), 5L);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRepeatWhenEmptyTest.java
Patch:
@@ -107,7 +107,7 @@ public void gh2196_discardHandlerHang() {
 
     @Test
     public void scanOperator(){
-        MonoRepeatWhen<Integer> test = new MonoRepeatWhen(Mono.just(1), o -> Mono.empty());
+        MonoRepeatWhen<Integer> test = new MonoRepeatWhen<>(Mono.just(1), o -> Mono.empty());
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
     }

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryPredicateTest.java
Patch:
@@ -68,7 +68,7 @@ public void twoRetryErrorSupplier() {
 
 	@Test
 	public void scanOperator(){
-		MonoRetryPredicate<String> test = new MonoRetryPredicate(Mono.just("foo"), e -> true);
+		MonoRetryPredicate<String> test = new MonoRetryPredicate<>(Mono.just("foo"), e -> true);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryTest.java
Patch:
@@ -123,7 +123,7 @@ public void accept(Integer t) {
 
 	@Test
 	public void scanOperator(){
-	    MonoRetry test = new MonoRetry(Mono.just(1), 3L);
+	    MonoRetry<Integer> test = new MonoRetry<>(Mono.just(1), 3L);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryWhenTest.java
Patch:
@@ -336,7 +336,7 @@ public void monoRetryBackoffRetriesOnGivenScheduler() {
 	@Test
 	public void scanOperator(){
 		Mono<String> parent = Mono.just("foo");
-		MonoRetryWhen<String> test = new MonoRetryWhen(parent, Retry.backoff(5, Duration.ofMinutes(30)));
+		MonoRetryWhen<String> test = new MonoRetryWhen<>(parent, Retry.backoff(5, Duration.ofMinutes(30)));
 
 	    assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);

File: reactor-core/src/test/java/reactor/core/publisher/MonoRunnableTest.java
Patch:
@@ -169,7 +169,7 @@ public void runnableSubscribeToCompleteMeasurement() {
 
 	@Test
 	public void scanOperator(){
-		MonoRunnable<String> test = new MonoRunnable(() -> {});
+		MonoRunnable<String> test = new MonoRunnable<>(() -> {});
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSingleMonoTest.java
Patch:
@@ -42,7 +42,7 @@ public void normalValued() {
 
 	@Test
 	public void scanOperator(){
-	    MonoSingleMono<String> test = new MonoSingleMono(Mono.just("foo"));
+	    MonoSingleMono<String> test = new MonoSingleMono<>(Mono.just("foo"));
 	    
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSingleTest.java
Patch:
@@ -246,7 +246,7 @@ public void singleEmptyFallbackJustHideError() {
 
 	@Test
 	public void scanOperator(){
-	    MonoSingle<String> test = new MonoSingle(Flux.just("foo"));
+	    MonoSingle<String> test = new MonoSingle<>(Flux.just("foo"));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceFluxTest.java
Patch:
@@ -10,7 +10,7 @@ public class MonoSourceFluxTest {
 	@Test
 	public void scanOperator(){
 		Flux<String> source = Flux.just("foo", "bar");
-		MonoSourceFlux<String> test = new MonoSourceFlux(source);
+		MonoSourceFlux<String> test = new MonoSourceFlux<>(source);
 
 	    assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);
@@ -20,7 +20,7 @@ public void scanOperator(){
 	@Test
 	public void scanFuseableOperator(){
 		Flux<String> source = Flux.just("foo", "bar");
-		MonoSourceFluxFuseable<String> test = new MonoSourceFluxFuseable(source);
+		MonoSourceFluxFuseable<String> test = new MonoSourceFluxFuseable<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -264,7 +264,7 @@ public void onAssemblyDescription() {
 	@Test
 	public void scanSubscriber() {
 		Flux<String> source = Flux.just("foo").map(i -> i);
-		MonoSource<String> test = new MonoSource(source);
+		MonoSource<String> test = new MonoSource<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();
@@ -274,7 +274,7 @@ public void scanSubscriber() {
 	@Test
 	public void scanFuseableSubscriber(){
 		Mono<String> source = Mono.just("foo");
-		MonoSourceFuseable<String> test = new MonoSourceFuseable(source);
+		MonoSourceFuseable<String> test = new MonoSourceFuseable<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
@@ -283,7 +283,7 @@ public void scanFuseableSubscriber(){
 	@Test
 	public void scanSubscriberHide() {
 		Flux<String> source = Flux.just("foo").hide();
-		MonoSource<String> test = new MonoSource(source);
+		MonoSource<String> test = new MonoSource<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();

File: reactor-core/src/test/java/reactor/core/publisher/MonoStreamCollectorTest.java
Patch:
@@ -115,7 +115,7 @@ public void collectToSet() {
 	@Test
 	public void scanOperator(){
 	    Flux<Integer> source = Flux.just(1);
-		MonoStreamCollector test = new MonoStreamCollector(source, Collectors.toSet());
+		MonoStreamCollector<Integer, ?, Set<Integer>> test = new MonoStreamCollector<>(source, Collectors.toSet());
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberContextTest.java
Patch:
@@ -10,7 +10,7 @@ public class MonoSubscriberContextTest {
 
     @Test
     public void scanOperator(){
-        MonoSubscriberContext<String> test = new MonoSubscriberContext(Mono.just(1), c -> c);
+        MonoSubscriberContext<Integer> test = new MonoSubscriberContext<>(Mono.just(1), c -> c);
 
         assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
     }

File: reactor-core/src/test/java/reactor/core/publisher/MonoSupplierTest.java
Patch:
@@ -100,7 +100,7 @@ public void onMonoErrorSupplierOnBlock() {
 
 	@Test
 	public void scanOperator(){
-		MonoSupplier<String> test = new MonoSupplier(() -> "test");
+		MonoSupplier<String> test = new MonoSupplier<>(() -> "test");
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoSwitchIfEmptyTest.java
Patch:
@@ -100,7 +100,7 @@ public void emptyBackpressured() {
 
 	@Test
 	public void scanOperator(){
-	    MonoSwitchIfEmpty<String> test = new MonoSwitchIfEmpty(Mono.just(1), Mono.empty());
+	    MonoSwitchIfEmpty<Integer> test = new MonoSwitchIfEmpty<>(Mono.just(1), Mono.empty());
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoTakeLastOneTest.java
Patch:
@@ -155,7 +155,7 @@ public void defaultUsingZip() {
 
 	@Test
 	public void scanOperator(){
-	    MonoTakeLastOne<Integer> test = new MonoTakeLastOne(Flux.just(1, 2, 3));
+	    MonoTakeLastOne<Integer> test = new MonoTakeLastOne<>(Flux.just(1, 2, 3));
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoTakeUntilOtherTest.java
Patch:
@@ -196,7 +196,7 @@ public void apiTakeUntilOtherCompleteBeforeOther() {
 	@Test
 	public void scanOperator(){
 		TestPublisher<String> other = TestPublisher.create();
-	    MonoTakeUntilOther<Integer, String> test = new MonoTakeUntilOther(Mono.just(1), other);
+	    MonoTakeUntilOther<Integer, String> test = new MonoTakeUntilOther<>(Mono.just(1), other);
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -173,7 +173,7 @@ public void timeoutNotDurationMessage() {
 
 	@Test
 	public void scanOperator(){
-	    MonoTimeout test = new MonoTimeout(Mono.just(1), Mono.just("foo"), "timeout");
+	    MonoTimeout<Integer, String, String> test = new MonoTimeout<>(Mono.just(1), Mono.just("foo"), "timeout");
 
 	    assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -397,7 +397,7 @@ public void smokeTestMapReduceGuardedByCleanup_fusedNotEager() {
 
 	@Test
 	public void scanOperator(){
-		MonoUsing<Integer, Integer> test = new MonoUsing(() -> 1, r -> Mono.just(1), c -> {}, false);
+		MonoUsing<Integer, Integer> test = new MonoUsing<>(() -> 1, r -> Mono.just(1), c -> {}, false);
 
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isNull();
@@ -407,7 +407,7 @@ public void scanOperator(){
 	@Test
 	public void scanSubscriber() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		MonoUsing.MonoUsingSubscriber test = new MonoUsing.MonoUsingSubscriber(actual, rc -> {}, "foo", false, false);
+		MonoUsing.MonoUsingSubscriber<Integer, ?> test = new MonoUsing.MonoUsingSubscriber<>(actual, rc -> {}, "foo", false, false);
 
 		final Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/ParallelArraySourceTest.java
Patch:
@@ -38,6 +38,7 @@ public void parallelism() {
 
 	@Test
 	public void scanOperator(){
+		@SuppressWarnings("unchecked")
 		Publisher<Integer>[] sources = new Publisher[2];
 		sources[0] = Flux.range(1, 4);
 		sources[1] = just(10);

File: reactor-core/src/test/java/reactor/core/publisher/ParallelDoOnEachTest.java
Patch:
@@ -11,7 +11,7 @@ public class ParallelDoOnEachTest {
 	@Test
 	public void scanOperator(){
 		ParallelFlux<Integer> parent = Flux.just(1).parallel(2);
-		ParallelDoOnEach test = new ParallelDoOnEach(parent, (k, v) -> {}, (k, v) -> {}, v -> {});
+		ParallelDoOnEach<Integer> test = new ParallelDoOnEach<>(parent, (k, v) -> {}, (k, v) -> {}, v -> {});
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(Queues.SMALL_BUFFER_SIZE);

File: reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java
Patch:
@@ -307,7 +307,7 @@ public void nextVarargNull() {
 		TestPublisher<String> publisher = TestPublisher.createCold();
 
 		assertThatExceptionOfType(NullPointerException.class)
-				.isThrownBy(() -> publisher.next(null, null)) //this causes a compiler warning, on purpose
+				.isThrownBy(() -> publisher.next(null, (String[]) null)) //end users forgetting to cast would see compiler warning as well
 				.withMessage("rest array is null, please cast to T if null T required");
 	}
 
@@ -316,7 +316,7 @@ public void emitVarargNull() {
 		TestPublisher<String> publisher = TestPublisher.createCold();
 
 		assertThatExceptionOfType(NullPointerException.class)
-				.isThrownBy(() -> publisher.emit(null)) //this causes a compiler warning, on purpose
+				.isThrownBy(() -> publisher.emit((String[])null)) //end users forgetting to cast would see compiler warning as well
 				.withMessage("values array is null, please cast to T if null T required");
 	}
 

File: reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java
Patch:
@@ -378,7 +378,7 @@ public void nextVarargNull() {
 		TestPublisher<String> publisher = TestPublisher.create();
 
 		assertThatExceptionOfType(NullPointerException.class)
-				.isThrownBy(() -> publisher.next(null, null)) //this causes a compiler warning, on purpose
+				.isThrownBy(() -> publisher.next(null, (String[]) null)) //end users forgetting to cast would see compiler warning as well
 				.withMessage("rest array is null, please cast to T if null T required");
 	}
 
@@ -387,7 +387,7 @@ public void emitVarargNull() {
 		TestPublisher<String> publisher = TestPublisher.create();
 
 		assertThatExceptionOfType(NullPointerException.class)
-				.isThrownBy(() -> publisher.emit(null)) //this causes a compiler warning, on purpose
+				.isThrownBy(() -> publisher.emit((String[]) null)) //end users forgetting to cast would see compiler warning as well
 				.withMessage("values array is null, please cast to T if null T required");
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -444,16 +444,17 @@ public void scanOperator(){
 
 	@Test
 	public void scanMainSubscriber(){
-		CoreSubscriber<List<String>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
+		CoreSubscriber<List<String>> actual = new LambdaSubscriber<>(null, e -> {}, null, s -> s.request(1));
 		TimeoutMainSubscriber test = new TimeoutMainSubscriber(actual, Flux.empty(), v -> Flux.just(2), Flux.empty(), "desc");
 
 		Subscription subscription = Operators.emptySubscription();
 		test.onSubscribe(subscription);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(subscription);
 		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
+		assertThat(test.scan(Scannable.Attr.REQUESTED_FROM_DOWNSTREAM)).isEqualTo(1L);
 		test.request(2);
-		assertThat(test.scan(Scannable.Attr.REQUESTED_FROM_DOWNSTREAM)).isEqualTo(2L);
+		assertThat(test.scan(Scannable.Attr.REQUESTED_FROM_DOWNSTREAM)).isEqualTo(1L + 2L);
 
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
 		test.cancel();

File: reactor-core/src/main/java/reactor/core/Exceptions.java
Patch:
@@ -16,7 +16,6 @@
 
 package reactor.core;
 
-import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -155,7 +155,7 @@ void doError(Throwable t) {
 			errorConsumer.accept(t);
 		}
 		else {
-			throw Exceptions.errorCallbackNotImplemented(t);
+			Operators.onErrorDropped(Exceptions.errorCallbackNotImplemented(t), this.initialContext);
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -149,7 +149,7 @@ public final void onError(Throwable t) {
 			errorConsumer.accept(t);
 		}
 		else {
-			throw Exceptions.errorCallbackNotImplemented(t);
+			Operators.onErrorDropped(Exceptions.errorCallbackNotImplemented(t), this.initialContext);
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -632,7 +632,7 @@ public static void onErrorDropped(Throwable e, Context context) {
 		}
 		if (hook == null) {
 			log.error("Operator called default onErrorDropped", e);
-			throw Exceptions.bubble(e);
+			return;
 		}
 		hook.accept(e);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxMetricsFuseableTest.java
Patch:
@@ -99,7 +99,6 @@ public void queuePollTracksOnNext() {
 		MockClock clock = new MockClock();
 		removeRegistry();
 		registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
-		Metrics.globalRegistry.add(registry);
 
 		AssertSubscriber<Integer> testSubscriber = AssertSubscriber.create();
 		FluxMetricsFuseable.MetricsFuseableSubscriber<Integer> fuseableSubscriber =
@@ -132,7 +131,6 @@ public void queuePollSyncTracksOnComplete() {
 		MockClock clock = new MockClock();
 		removeRegistry();
 		registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
-		Metrics.globalRegistry.add(registry);
 
 		AssertSubscriber<Integer> testSubscriber = AssertSubscriber.create();
 		FluxMetricsFuseable.MetricsFuseableSubscriber<Integer> fuseableSubscriber =
@@ -168,7 +166,6 @@ public void queuePollError() {
 		MockClock clock = new MockClock();
 		removeRegistry();
 		registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
-		Metrics.globalRegistry.add(registry);
 
 		AssertSubscriber<Integer> testSubscriber = AssertSubscriber.create();
 		FluxMetricsFuseable.MetricsFuseableSubscriber<Integer> fuseableSubscriber =

File: reactor-core/src/test/java/reactor/core/publisher/MonoMetricsFuseableTest.java
Patch:
@@ -100,7 +100,6 @@ public void queuePollDoesntTrackOnNext() {
 		MockClock clock = new MockClock();
 		removeRegistry();
 		registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
-		Metrics.globalRegistry.add(registry);
 
 		AssertSubscriber<Integer> testSubscriber = AssertSubscriber.create();
 		MetricsFuseableSubscriber<Integer> fuseableSubscriber =
@@ -132,7 +131,6 @@ public void queuePollSyncTracksOnComplete() {
 		MockClock clock = new MockClock();
 		removeRegistry();
 		registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
-		Metrics.globalRegistry.add(registry);
 
 		AssertSubscriber<Integer> testSubscriber = AssertSubscriber.create();
 		MetricsFuseableSubscriber<Integer> fuseableSubscriber =
@@ -168,7 +166,6 @@ public void queuePollError() {
 		MockClock clock = new MockClock();
 		removeRegistry();
 		registry = new SimpleMeterRegistry(SimpleConfig.DEFAULT, clock);
-		Metrics.globalRegistry.add(registry);
 
 		AssertSubscriber<Integer> testSubscriber = AssertSubscriber.create();
 		MetricsFuseableSubscriber<Integer> fuseableSubscriber =

File: reactor-core/src/test/java/reactor/core/publisher/LiftFunctionTest.java
Patch:
@@ -356,7 +356,9 @@ public void scanOperator() {
 
 				assertThat(from(liftOperator).scan(Attr.PARENT)).isSameAs(g);
 				assertThat(from(liftOperator).scan(Attr.PREFETCH)).isSameAs(g.getPrefetch());
-				assertThat(from(liftOperator).scan(Attr.RUN_STYLE)).isSameAs(Attr.RUN_STYLE);
+				assertThat(from(liftOperator).scan(Attr.RUN_STYLE))
+						.isSameAs(Attr.RunStyle.SYNC)
+						.isSameAs(from(g).scan(Attr.RUN_STYLE));
 
 				return liftOperator;
 			})

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -208,6 +208,7 @@ void subscribeNextTrigger(T value, int triggerIndex) {
 
 			try {
 				p = generator.apply(value);
+				Objects.requireNonNull(p, "mapper returned null value");
 			}
 			catch (Throwable t) {
 				onError(t);

File: reactor-core/src/main/java/reactor/util/context/Context5.java
Patch:
@@ -154,7 +154,7 @@ public Stream<Map.Entry<Object, Object>> stream() {
 	public Context putAllInto(Context base) {
 		return base
 				.put(this.key1, this.value1)
-		        .put(this.key2, this.value2)
+				.put(this.key2, this.value2)
 				.put(this.key3, this.value3)
 				.put(this.key4, this.value4)
 				.put(this.key5, this.value5);

File: reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -70,6 +70,7 @@ final class BlockingIterable<T> implements Iterable<T>, Scannable {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return Math.min(Integer.MAX_VALUE, batchSize); //FIXME should batchSize be forced to int?
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -276,6 +277,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.CANCELLED) return s == Operators.cancelledSubscription();
 			if (key == Attr.PREFETCH) return batchSize;
 			if (key == Attr.ERROR) return error;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/BlockingOptionalMonoSubscriber.java
Patch:
@@ -189,6 +189,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.CANCELLED) return cancelled;
 		if (key == Attr.ERROR) return error;
 		if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java
Patch:
@@ -152,6 +152,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.CANCELLED) return cancelled;
 		if (key == Attr.ERROR) return error;
 		if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -69,6 +69,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java
Patch:
@@ -55,6 +55,7 @@ public void connect(Consumer<? super Disposable> cancelSupport) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return source.getPrefetch();
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
 		return null;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java
Patch:
@@ -57,6 +57,7 @@ public void connect(Consumer<? super Disposable> cancelSupport) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return source.getPrefetch();
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
 		return null;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -63,6 +63,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return array.length;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -73,6 +73,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.CAPACITY) return remaining;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -74,6 +74,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.CAPACITY) return remaining;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java
Patch:
@@ -79,6 +79,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super C> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timer;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -239,6 +240,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.CAPACITY) return batchSize;
 			if (key == Attr.BUFFERED) return batchSize - index;
 			if (key == Attr.RUN_ON) return timer;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -62,6 +62,7 @@ public T call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -59,6 +59,7 @@ public T call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxCancelOn.java
Patch:
@@ -42,6 +42,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -77,6 +78,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.CANCELLED) return cancelled == 1;
 			if (key == Attr.RUN_ON) return scheduler;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -179,6 +179,7 @@ else if (!(actual instanceof QueueSubscription)) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return prefetch;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 		return null;
 	}
 
@@ -637,6 +638,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ACTUAL) return parent;
 			if (key == Attr.CANCELLED) return s == Operators.cancelledSubscription();
 			if (key == Attr.PREFETCH) return prefetch;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -57,6 +57,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxDeferWithContext.java
Patch:
@@ -58,6 +58,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySequence.java
Patch:
@@ -49,6 +49,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -159,6 +160,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.RUN_ON) return w;
 			if (key == Attr.TERMINATED) return done;
 			if (key == Attr.CANCELLED) return w.isDisposed() && !done;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxElapsed.java
Patch:
@@ -46,6 +46,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Tuple2
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -73,6 +74,7 @@ static final class ElapsedSubscriber<T>
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.RUN_ON) return scheduler;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -43,7 +43,8 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -53,6 +53,7 @@ public Object call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorOnRequest.java
Patch:
@@ -45,7 +45,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	static final class ErrorSubscription implements InnerProducer {
@@ -88,6 +89,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ERROR) return error;
 			if (key == Attr.CANCELLED || key == Attr.TERMINATED)
 				return once == 1;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorSupplied.java
Patch:
@@ -72,6 +72,7 @@ public Object call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -163,7 +163,8 @@ FluxFirstEmitting<T> ambAdditionalSource(Publisher<? extends T> source) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	static final class RaceCoordinator<T>
@@ -304,6 +305,7 @@ static final class FirstEmittingSubscriber<T> extends Operators.DeferredSubscrip
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.CANCELLED) return parent.cancelled;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -85,7 +85,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	static final class GenerateSubscription<T, S>
@@ -138,6 +139,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return requested;
 			if (key == Attr.CANCELLED) return cancelled;
 			if (key == Attr.ERROR) return generatedError;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
-import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
 import reactor.util.annotation.Nullable;
@@ -79,6 +78,7 @@ public void subscribe(CoreSubscriber<? super Long> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timedScheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}
@@ -112,6 +112,7 @@ public CoreSubscriber<? super Long> actual() {
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.CANCELLED) return cancelled;
 			if (key == Attr.RUN_ON) return worker;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -73,6 +73,7 @@ public void subscribe(final CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return 1;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 		return null;
 	}
 
@@ -148,6 +149,7 @@ public CoreSubscriber<? super T> actual() {
 		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.TERMINATED || key == Attr.CANCELLED) return terminado;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxLimitRequest.java
Patch:
@@ -47,6 +47,7 @@ public int getPrefetch() {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return cap;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		//FluxOperator defines PREFETCH and PARENT
 		return super.scanUnsafe(key);
@@ -140,6 +141,7 @@ public void cancel() {
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return parent;
 			if (key == Attr.TERMINATED) return toProduce == 0L;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			//InnerOperator defines ACTUAL
 			return InnerOperator.super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/FluxMerge.java
Patch:
@@ -103,6 +103,7 @@ FluxMerge<T> mergeAdditionalSource(Publisher<? extends T> source, IntFunction<Su
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.DELAY_ERROR) return delayError;
 		if (key == Attr.PREFETCH) return prefetch;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeOrdered.java
Patch:
@@ -111,6 +111,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return sources.length > 0 ? sources[0] : null;
 		if (key == Attr.PREFETCH) return prefetch;
 		if (key == Attr.DELAY_ERROR) return true;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -330,6 +331,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ERROR) return this.error;
 			if (key == Attr.DELAY_ERROR) return true;
 			if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return requested - emitted;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}
@@ -421,6 +423,7 @@ public Object scanUnsafe(Attr key){
 			if (key == Attr.PREFETCH) return prefetch;
 			if (key == Attr.TERMINATED) return done;
 			if (key == Attr.BUFFERED) return queue.size();
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -41,7 +41,8 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -69,6 +69,7 @@ public String stepName() {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.ACTUAL_METADATA) return !snapshotStack.checkpointed;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -366,6 +367,7 @@ public final CoreSubscriber<? super T> actual() {
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.ACTUAL_METADATA) return !snapshotStack.checkpointed;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -71,6 +71,7 @@ final class FluxPublishOn<T> extends InternalFluxOperator<T, T> implements Fusea
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -590,6 +591,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.DELAY_ERROR) return delayError;
 			if (key == Attr.PREFETCH) return prefetch;
 			if (key == Attr.RUN_ON) return worker;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}
@@ -1083,6 +1085,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.DELAY_ERROR) return delayError;
 			if (key == Attr.PREFETCH) return prefetch;
 			if (key == Attr.RUN_ON) return worker;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -120,6 +120,7 @@ void terminated(RefCountMonitor rc) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -180,6 +181,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr. PARENT) return s;
 			if (key == Attr.TERMINATED) return parentDone == 1;
 			if (key == Attr.CANCELLED) return parentDone == 2;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -1146,6 +1146,7 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -1391,6 +1392,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.BUFFERED) return buffer.size();
 			if (key == Attr.TERMINATED) return isTerminated();
 			if (key == Attr.CANCELLED) return cancelled;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -21,6 +21,7 @@
 
 import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
+import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -85,6 +86,7 @@ public CoreSubscriber<? super I> subscribeOrReturn(CoreSubscriber<? super I> act
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
 		return null;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceFuseable.java
Patch:
@@ -79,6 +79,7 @@ public final CorePublisher<? extends I> source() {
 	public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.PREFETCH) return getPrefetch();
 		if (key == Scannable.Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Scannable.from(source).scanUnsafe(key);
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -73,6 +73,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -66,6 +66,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}
@@ -132,6 +133,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.CANCELLED) return state == HAS_CANCELLED;
 			if (key == Attr.BUFFERED) return value != null ? 1 : 0;
 			if (key == Attr.RUN_ON) return scheduler;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -72,6 +72,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}
@@ -129,6 +130,7 @@ public Object scanUnsafe(Scannable.Attr key) {
 				return 1;
 			}
 			if (key == Attr.RUN_ON) return scheduler;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeout.java
Patch:
@@ -69,6 +69,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Flux<T
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timer;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -147,6 +148,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.CAPACITY) return maxSize;
 			if (key == Attr.BUFFERED) return queue.size();
 			if (key == Attr.RUN_ON) return worker;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 			return InnerOperator.super.scanUnsafe(key);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/GroupedLift.java
Patch:
@@ -59,6 +59,9 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) {
 			return getPrefetch();
 		}
+		if (key == Attr.RUN_STYLE) {
+			return Scannable.from(source).scanUnsafe(key);
+		}
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/GroupedLiftFuseable.java
Patch:
@@ -61,6 +61,9 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) {
 			return getPrefetch();
 		}
+		if (key == Attr.RUN_STYLE) {
+			return Scannable.from(source).scanUnsafe(key);
+		}
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -173,6 +173,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return subscription;
 		if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
 		if (key == Attr.TERMINATED || key == Attr.CANCELLED) return isDisposed();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -93,6 +93,7 @@ public T call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -93,6 +93,7 @@ public T call() throws Exception {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoCancelOn.java
Patch:
@@ -36,6 +36,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoCurrentContext.java
Patch:
@@ -37,6 +37,7 @@ public void subscribe(CoreSubscriber<? super Context> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -54,6 +54,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDeferWithContext.java
Patch:
@@ -56,6 +56,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 		return null; //no particular key to be represented, still useful in hooks
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -68,6 +68,7 @@ public void subscribe(CoreSubscriber<? super Long> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timedScheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}
@@ -105,6 +106,7 @@ public CoreSubscriber<? super Long> actual() {
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.TERMINATED) return cancel == FINISHED;
 			if (key == Attr.CANCELLED) return cancel == OperatorDisposables.DISPOSED;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -58,6 +58,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return timedScheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -87,6 +88,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.TERMINATED) return done;
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.RUN_ON) return scheduler;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -122,6 +122,7 @@ public final CorePublisher<? extends T> source() {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 		return null; //no particular key to be represented, still useful in hooks
 	}
 
@@ -186,6 +187,7 @@ public void onComplete() {
 		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.TERMINATED) return done == n;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return super.scanUnsafe(key);
 		}
@@ -303,6 +305,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ACTUAL) return parent;
 			if (key == Attr.ERROR) return error;
 			if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoElapsed.java
Patch:
@@ -41,6 +41,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super Tuple2
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -76,6 +76,7 @@ public Object block() {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -62,6 +62,7 @@ public Object call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -82,6 +82,7 @@ public Object call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -150,7 +150,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 }
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromPublisher.java
Patch:
@@ -89,6 +89,9 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.PARENT) {
 			return source;
 		}
+		if (key == Scannable.Attr.RUN_STYLE) {
+		    return Attr.RunStyle.SYNC;
+		}
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnorePublisher.java
Patch:
@@ -82,6 +82,9 @@ public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.PARENT) {
 			return source;
 		}
+		if (key == Attr.RUN_STYLE) {
+			return Attr.RunStyle.SYNC;
+		}
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -57,6 +57,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return 1;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -41,7 +41,8 @@ public void subscribe(CoreSubscriber<? super Object> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -63,6 +63,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
+import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.annotation.Nullable;
 
@@ -48,6 +49,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -93,6 +95,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.ERROR) return error;
 			if (key == Attr.RUN_ON) return scheduler;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -76,7 +76,8 @@ public Void call() throws Exception {
 
     @Override
     public Object scanUnsafe(Attr key) {
-        return null; //no particular key to be represented, still useful in hooks
+        if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+        return null;
     }
 
     static final class MonoRunnableEagerSubscription extends AtomicBoolean implements Subscription {

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -62,6 +62,7 @@ public void subscribe(CoreSubscriber<? super Boolean> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) return prefetch;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 		return null;
 	}
 
@@ -109,6 +110,7 @@ public CoreSubscriber<? super Boolean> actual() {
 		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.CANCELLED) return cancelled;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}
@@ -320,6 +322,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return subscription;
 			if (key == Attr.PREFETCH) return prefetch;
 			if (key == Attr.BUFFERED) return queue.size();
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSourceFuseable.java
Patch:
@@ -79,6 +79,9 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) {
 			return source;
 		}
+		if (key == Attr.RUN_STYLE) {
+			return Scannable.from(source).scanUnsafe(key);
+		}
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java
Patch:
@@ -66,6 +66,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return super.scanUnsafe(key);
 	}
@@ -114,6 +115,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return requested;
 			if (key == Attr.RUN_ON) return worker;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -61,6 +61,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Scannable.Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -66,6 +66,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.RUN_ON) return scheduler;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -87,6 +87,7 @@ public T call() throws Exception {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -116,7 +116,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	static final class MonoUsingSubscriber<T, S>
@@ -161,6 +162,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.TERMINATED || key == Attr.CANCELLED)
 				return wip == 1;
 			if (key == Attr.PARENT) return s;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsingWhen.java
Patch:
@@ -100,7 +100,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	@Override
 	public Object scanUnsafe(Attr key) {
-		return null; //no particular key to be represented, still useful in hooks
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
+		return null;
 	}
 
 	private static <RESOURCE, T> Mono<? extends T> deriveMonoFromResource(
@@ -246,6 +247,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ACTUAL) return actual;
 			if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
 			if (key == Attr.TERMINATED) return resourceProvided;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -62,6 +62,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.DELAY_ERROR) return errorMode != ErrorMode.IMMEDIATE;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelDoOnEach.java
Patch:
@@ -96,6 +96,7 @@ public int getPrefetch() {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFilter.java
Patch:
@@ -43,6 +43,7 @@ final class ParallelFilter<T> extends ParallelFlux<T> implements Scannable{
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -67,6 +67,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.DELAY_ERROR) return delayError;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -50,6 +50,7 @@ public int parallelism() {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -96,6 +96,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
 		if (key == Attr.ACTUAL_METADATA) return !stacktrace.checkpointed;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -63,6 +63,7 @@ public void subscribe(CoreSubscriber<? super GroupedFlux<Integer, T>> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -118,6 +119,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return requested;
 			if (key == Attr.CANCELLED) return s == Operators.cancelledSubscription();
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerOperator.super.scanUnsafe(key);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java
Patch:
@@ -58,6 +58,9 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) {
 			return getPrefetch();
 		}
+		if (key == Attr.RUN_STYLE) {
+			return Scannable.from(source).scanUnsafe(key);
+		}
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java
Patch:
@@ -61,6 +61,9 @@ public Object scanUnsafe(Attr key) {
 		if (key == Attr.PREFETCH) {
 			return getPrefetch();
 		}
+		if (key == Attr.RUN_STYLE) {
+			return Scannable.from(source).scanUnsafe(key);
+		}
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -79,6 +79,7 @@ public int getPrefetch() {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMap.java
Patch:
@@ -44,6 +44,7 @@ final class ParallelMap<T, R> extends ParallelFlux<R> implements Scannable {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeOrdered.java
Patch:
@@ -60,6 +60,7 @@ public int getPrefetch() {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return prefetch;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -50,6 +50,7 @@ final class ParallelMergeReduce<T> extends Mono<T> implements Scannable, Fuseabl
 	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -112,6 +113,7 @@ static final class MergeReduceMain<T>
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.ERROR) return error;
 			if (key == Attr.TERMINATED) return REMAINING.get(this) == 0;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return super.scanUnsafe(key);
 		}
@@ -241,6 +243,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.ACTUAL) return parent;
 			if (key == Attr.BUFFERED) return value != null ? 1 : 0;
 			if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -55,6 +55,7 @@ final class ParallelMergeSequential<T> extends Flux<T> implements Scannable {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -130,6 +131,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return requested;
 			if (key == Attr.TERMINATED) return done == 0 ;
 			if (key == Attr.ERROR) return error;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}
@@ -376,6 +378,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PREFETCH) return prefetch;
 			if (key == Attr.BUFFERED) return queue != null ? queue.size() : 0;
 			if (key == Attr.TERMINATED) return done;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -70,6 +70,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -142,6 +143,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.REQUESTED_FROM_DOWNSTREAM) return requested;
 			if (key == Attr.CANCELLED) return cancelled;
 			if (key == Attr.BUFFERED) return subscribers.length - remaining;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return InnerProducer.super.scanUnsafe(key);
 		}
@@ -339,6 +341,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.ACTUAL) return parent;
 			if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -151,6 +151,7 @@ public Consumer<? super T> onAfterNextCall() {
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -55,6 +55,7 @@ final class ParallelRunOn<T> extends ParallelFlux<T> implements Scannable{
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.ASYNC;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -74,6 +74,7 @@ public int parallelism() {
 	public Object scanUnsafe(Scannable.Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -150,6 +151,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.CANCELLED) return cancelled;
 			if (key == Attr.ERROR) return error;
 			if (key == Attr.BUFFERED) return queue != null ? queue.size() : 0;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}
@@ -484,6 +486,7 @@ public CoreSubscriber<? super T> actual() {
 			@Nullable
 			public Object scanUnsafe(Attr key) {
 				if (key == Attr.PARENT) return parent;
+				if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 				return InnerProducer.super.scanUnsafe(key);
 			}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelThen.java
Patch:
@@ -41,6 +41,7 @@ final class ParallelThen extends Mono<Void> implements Scannable, Fuseable {
 	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
+		if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 		return null;
 	}
@@ -88,6 +89,7 @@ static final class ThenMain
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.ERROR) return error;
 			if (key == Attr.TERMINATED) return REMAINING.get(this) == 0;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return super.scanUnsafe(key);
 		}
@@ -145,6 +147,7 @@ public Object scanUnsafe(Attr key) {
 			if (key == Attr.PARENT) return s;
 			if (key == Attr.ACTUAL) return parent;
 			if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
+			if (key == Attr.RUN_STYLE) return Attr.RunStyle.SYNC;
 
 			return null;
 		}

File: reactor-core/src/test/java/reactor/core/publisher/BlockingIterableTest.java
Patch:
@@ -139,6 +139,7 @@ public void scanOperator() {
 		BlockingIterable<Integer> test = new BlockingIterable<>(source, 35, Queues.one());
 
 		assertThat(test.scanUnsafe(Scannable.Attr.PARENT)).describedAs("PARENT").isSameAs(source);
+		assertThat(test.scan(Attr.RUN_STYLE)).isSameAs(Attr.RunStyle.SYNC);
 
 		//type safe attributes
 		assertThat(test.scanUnsafe(Attr.PREFETCH)).describedAs("PREFETCH unsafe").isEqualTo(35);
@@ -167,6 +168,7 @@ public void scanSubscriber() {
 		assertThat(subscriberIterator.scan(Scannable.Attr.TERMINATED)).describedAs("TERMINATED").isFalse();
 		assertThat(subscriberIterator.scan(Scannable.Attr.CANCELLED)).describedAs("CANCELLED").isFalse();
 		assertThat(subscriberIterator.scan(Scannable.Attr.ERROR)).describedAs("ERROR").isNull();
+		assertThat(subscriberIterator.scan(Attr.RUN_STYLE)).isSameAs(Attr.RunStyle.SYNC);
 
 		assertThat(subscriberIterator.scan(Attr.PREFETCH)).describedAs("PREFETCH").isEqualTo(123); //FIXME
 	}

File: reactor-core/src/test/java/reactor/core/publisher/BlockingOptionalMonoSubscriberTest.java
Patch:
@@ -160,7 +160,7 @@ public void scanOperator() {
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).as("PARENT").isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).as("PREFETCH").isEqualTo(Integer.MAX_VALUE);
-
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).as("RUN_STYLE").isSameAs(Scannable.Attr.RunStyle.SYNC);
 
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).as("TERMINATED").isFalse();
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).as("CANCELLED").isFalse();

File: reactor-core/src/test/java/reactor/core/publisher/BlockingSingleSubscriberTest.java
Patch:
@@ -46,6 +46,7 @@ public void scanMain() {
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).describedAs("CANCELLED").isFalse();
 		assertThat(test.scan(Scannable.Attr.ERROR)).describedAs("ERROR").isNull();
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).describedAs("PREFETCH").isEqualTo(Integer.MAX_VALUE);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).describedAs("RUN_STYLE").isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/ConnectableFluxHideTest.java
Patch:
@@ -47,5 +47,6 @@ public void scanOperator() throws Exception {
 		assertThat(test.scan(Scannable.Attr.PREFETCH))
 				.isEqualTo(256)
 				.isEqualTo(source.getPrefetch());
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 }
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/ConnectableFluxOnAssemblyTest.java
Patch:
@@ -25,13 +25,14 @@
 public class ConnectableFluxOnAssemblyTest {
 
 	@Test
-	public void scanMain() throws Exception {
+	public void scanMain() {
 		ConnectableFlux<String> source = Flux.just("foo").publish();
 		AssemblySnapshot stacktrace = new AssemblySnapshot(null, Traces.callSiteSupplierFactory.get());
 		ConnectableFluxOnAssembly<String> test = new ConnectableFluxOnAssembly<>(source, stacktrace);
 
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(-1);
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test
@@ -43,6 +44,7 @@ public void scanOperator() {
 		assertThat(test.scan(Scannable.Attr.ACTUAL_METADATA)).as("ACTUAL_METADATA").isTrue();
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).as("PREFETCH").isEqualTo(-1);
 		assertThat(test.scan(Scannable.Attr.PARENT)).as("PARENT").isSameAs(source);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).as("RUN_STYLE").isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxArrayTest.java
Patch:
@@ -99,6 +99,7 @@ public void arrayContainsNull() {
 	public void scanOperator() {
 		FluxArray s = new FluxArray<>("A", "B", "C");
 		assertThat(s.scan(Scannable.Attr.BUFFERED)).isEqualTo(3);
+		assertThat(s.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectFuseableTest.java
Patch:
@@ -16,11 +16,8 @@
 
 package reactor.core.publisher;
 
-import java.util.function.Consumer;
-
 import org.junit.Test;
 import org.mockito.Mockito;
-import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.test.MockUtils;
 
@@ -38,6 +35,7 @@ public void scanMain() {
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(888);
 		assertThat(test.scan(Scannable.Attr.CAPACITY)).isEqualTo(123);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 }
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -91,5 +91,6 @@ public void scanMain() {
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(888);
 		assertThat(test.scan(Scannable.Attr.CAPACITY)).isEqualTo(123);
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableOnAssemblyTest.java
Patch:
@@ -46,6 +46,7 @@ public void scanOperator() {
 		FluxCallableOnAssembly<?> test = new FluxCallableOnAssembly<>(Flux.empty(), stacktrace);
 
 		assertThat(test.scan(Scannable.Attr.ACTUAL_METADATA)).as("ACTUAL_METADATA").isTrue();
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -264,6 +264,7 @@ public void combineLatest6() {
 	public void scanOperator() {
 		FluxCombineLatest s = new FluxCombineLatest<>(Collections.emptyList(), v -> v, Queues.small(), 123);
 		assertThat(s.scan(Scannable.Attr.PREFETCH)).isEqualTo(123);
+		assertThat(s.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 	}
 
 	@Test
@@ -300,6 +301,7 @@ public void scanInner() {
 		assertThat(test.scan(Scannable.Attr.PREFETCH)).isEqualTo(789);
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(main);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.SYNC);
 
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
 		test.cancel();

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelaySequenceTest.java
Patch:
@@ -256,6 +256,7 @@ public void scanOperator() {
 		FluxDelaySequence<String> test = new FluxDelaySequence<>(Flux.empty(), Duration.ofSeconds(1), Schedulers.immediate());
 
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.immediate());
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.ASYNC);
 	}
 
 	@Test
@@ -276,6 +277,7 @@ public void scanSubscriber() {
 				.satisfies(ser -> assertThat(ser.actual).isSameAs(actual));
 
 		assertThat(test.scan(Scannable.Attr.RUN_ON)).isEqualTo(worker);
+		assertThat(test.scan(Scannable.Attr.RUN_STYLE)).isSameAs(Scannable.Attr.RunStyle.ASYNC);
 
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isFalse();
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -4930,9 +4930,8 @@ static <T> Mono<T> wrap(Publisher<T> source, boolean enforceMonoContract) {
 		}
 		if (source instanceof FluxSourceMono
 				|| source instanceof FluxSourceMonoFuseable) {
-			FluxFromMonoOperator<T, T> wrapper = (FluxFromMonoOperator<T,T>) source;
 			@SuppressWarnings("unchecked")
-			Mono<T> extracted = (Mono<T>) wrapper.source;
+			Mono<T> extracted = (Mono<T>) ((FluxFromMonoOperator<T,T>) source).source;
 			return extracted;
 		}
 

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -30,6 +30,7 @@
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
+import reactor.util.retry.Retry;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.awaitility.Awaitility.with;
@@ -103,7 +104,7 @@ public void testLeakWithRetryWhenImmediatelyCancelled() throws InterruptedExcept
 			.doFinally(sig -> latch.countDown())
 		    .publishOn(Schedulers.single())
 			.doFinally(sig -> latch.countDown())
-		    .retryWhen(p -> p.take(3))
+		    .retryWhen(Retry.from(p -> p.take(3)))
 			.doFinally(sig -> latch.countDown())
 		    .cancelOn(Schedulers.parallel())
 		    .doOnDiscard(Integer.class, i -> discarded.incrementAndGet())

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java
Patch:
@@ -224,12 +224,12 @@ public void onNext(T t) {
 					this.poll();
 					evicted = (T) this.poll();
 				}
-				this.offer(ttlScheduler.now(TimeUnit.MILLISECONDS));
+				this.offer(ttlScheduler.now(TimeUnit.NANOSECONDS));
 				this.offer(t);
 			}
 			evict(evicted);
 			try {
-				worker.schedule(this, ttl.toMillis(), TimeUnit.MILLISECONDS);
+				worker.schedule(this, ttl.toNanos(), TimeUnit.NANOSECONDS);
 			}
 			catch (RejectedExecutionException re) {
 				done = true;
@@ -268,7 +268,7 @@ public void run() {
 					Long ts = (Long) this.peek();
 					empty = ts == null;
 					if (!empty) {
-						if (ts <= ttlScheduler.now(TimeUnit.MILLISECONDS) - ttl.toMillis()) {
+						if (ts <= ttlScheduler.now(TimeUnit.NANOSECONDS) - ttl.toNanos()) {
 							this.poll();
 							evicted = (T) this.poll();
 						}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java
Patch:
@@ -124,7 +124,7 @@ else if (rc == connection) {
 		}
 
 		if (replaceTimer) {
-			sd.replace(scheduler.schedule(rc, gracePeriod.toMillis(), TimeUnit.MILLISECONDS));
+			sd.replace(scheduler.schedule(rc, gracePeriod.toNanos(), TimeUnit.NANOSECONDS));
 		} else if (dispose != null) {
 			dispose.dispose();
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java
Patch:
@@ -300,7 +300,7 @@ private void signalCached(Signal<T> signal) {
 						main.run();
 					}
 					else if (!ttl.equals(DURATION_INFINITE)) {
-						main.clock.schedule(main, ttl.toMillis(), TimeUnit.MILLISECONDS);
+						main.clock.schedule(main, ttl.toNanos(), TimeUnit.NANOSECONDS);
 					}
 					//else TTL is Long.MAX_VALUE, schedule nothing but still cache
 				}

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -105,7 +105,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r, Schedulers.boundedElastic());
 		}
 	}
 
@@ -120,7 +120,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r, Schedulers.boundedElastic());
 		}
 	}
 
@@ -134,7 +134,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r, Schedulers.boundedElastic());
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/ListCompositeDisposableTest.java
Patch:
@@ -226,7 +226,7 @@ public void disposeConcurrent() {
 			final Disposable d1 = new FakeDisposable();
 			final Disposable.Composite cd = new ListCompositeDisposable(d1);
 
-			RaceTestUtils.race(cd::dispose, cd::dispose, Schedulers.elastic());
+			RaceTestUtils.race(cd::dispose, cd::dispose, Schedulers.boundedElastic());
 		}
 	}
 
@@ -236,7 +236,7 @@ public void removeConcurrent() {
 			final Disposable d1 = new FakeDisposable();
 			final Disposable.Composite cd = new ListCompositeDisposable(d1);
 
-			RaceTestUtils.race(() -> cd.remove(d1), cd::dispose, Schedulers.elastic());
+			RaceTestUtils.race(() -> cd.remove(d1), cd::dispose, Schedulers.boundedElastic());
 		}
 	}
 
@@ -246,7 +246,7 @@ public void sizeConcurrent() {
 			final Disposable d1 = new FakeDisposable();
 			final Disposable.Composite cd = new ListCompositeDisposable(d1);
 
-			RaceTestUtils.race(cd::size, cd::dispose, Schedulers.elastic());
+			RaceTestUtils.race(cd::size, cd::dispose, Schedulers.boundedElastic());
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -103,7 +103,7 @@ public void subscribeWithAsyncFusion() {
 		Processor<Integer, Integer> processor = EmitterProcessor.create(16);
 
 		StepVerifier.create(processor)
-		            .then(() -> Flux.range(1, 5).publishOn(Schedulers.elastic()).subscribe(processor))
+		            .then(() -> Flux.range(1, 5).publishOn(Schedulers.boundedElastic()).subscribe(processor))
 		            .expectNext(1, 2, 3, 4, 5)
 		            .expectComplete()
 		            .verify(Duration.ofSeconds(1));

File: reactor-core/src/test/java/reactor/core/publisher/FluxCancelOnTest.java
Patch:
@@ -55,10 +55,10 @@ public void cancelOnDedicatedScheduler() throws Exception {
 
 	@Test
 	public void scanOperator() {
-		final Flux<Integer> flux = Flux.just(1).cancelOn(Schedulers.elastic());
+		final Flux<Integer> flux = Flux.just(1).cancelOn(Schedulers.boundedElastic());
 
 		assertThat(flux).isInstanceOf(Scannable.class);
-		assertThat(((Scannable) flux).scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.elastic());
+		assertThat(((Scannable) flux).scan(Scannable.Attr.RUN_ON)).isSameAs(Schedulers.boundedElastic());
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -285,7 +285,7 @@ public void boundaryFusion() {
 		    .publishOn(Schedulers.single())
 		    .map(t -> Thread.currentThread().getName().contains("single-") ? "single" : ("BAD-" + t + Thread.currentThread().getName()))
 		    .concatMap(Flux::just)
-		    .publishOn(Schedulers.elastic())
+		    .publishOn(Schedulers.boundedElastic())
 		    .distinct()
 		    .as(StepVerifier::create)
 		    .expectFusion()
@@ -301,7 +301,7 @@ public void boundaryFusionDelayError() {
 		    .publishOn(Schedulers.single())
 		    .map(t -> Thread.currentThread().getName().contains("single-") ? "single" : ("BAD-" + t + Thread.currentThread().getName()))
 		    .concatMapDelayError(Flux::just)
-		    .publishOn(Schedulers.elastic())
+		    .publishOn(Schedulers.boundedElastic())
 		    .distinct()
 		    .as(StepVerifier::create)
 		    .expectFusion()

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -459,8 +459,8 @@ void fluxCreateSerializedBackpressured() {
 
 	@Test
 	void fluxCreateSerializedConcurrent() {
-		Scheduler.Worker w1 = Schedulers.elastic().createWorker();
-		Scheduler.Worker w2 = Schedulers.elastic().createWorker();
+		Scheduler.Worker w1 = Schedulers.boundedElastic().createWorker();
+		Scheduler.Worker w2 = Schedulers.boundedElastic().createWorker();
 		CountDownLatch latch = new CountDownLatch(1);
 		CountDownLatch latch2 = new CountDownLatch(1);
 		AtomicReference<Thread> ref = new AtomicReference<>();

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java
Patch:
@@ -135,7 +135,7 @@ public void fusion() {
 		AtomicInteger invocationCount = new AtomicInteger();
 
 		Flux<String> sourceWithFusionAsync = Flux.just("foo")
-		                                         .publishOn(Schedulers.elastic())
+		                                         .publishOn(Schedulers.boundedElastic())
 		                                         .flatMap(v -> Flux.just("flatMap_" + v)
 		                                                           .doOnEach(sig -> invocationCount.incrementAndGet())
 		                                         );

File: reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java
Patch:
@@ -318,7 +318,7 @@ public void depthFirstAsync() {
 
 		StepVerifier.create(Flux.just(root)
 		                        .expandDeep(v -> Flux.fromIterable(v.children)
-		                                             .subscribeOn(Schedulers.elastic()))
+		                                             .subscribeOn(Schedulers.boundedElastic()))
 		                        .map(v -> v.name))
 		            .expectNext(
 				            "root",
@@ -354,7 +354,7 @@ public void breadthFirstAsync() {
 		Node root = createTest();
 
 		StepVerifier.create(Flux.just(root)
-		                        .expand(v -> Flux.fromIterable(v.children).subscribeOn(Schedulers.elastic()))
+		                        .expand(v -> Flux.fromIterable(v.children).subscribeOn(Schedulers.boundedElastic()))
 		                        .map(v -> v.name))
 		            .expectNext(
 				            "root",

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeSequentialTest.java
Patch:
@@ -452,7 +452,7 @@ public void testBackpressure() {
 	public void testAsynchronousRun() {
 		Flux.range(1, 2).flatMapSequential(t -> Flux.range(1, 1000)
 		                                            .subscribeOn(Schedulers.single())
-		).publishOn(Schedulers.elastic()).subscribe(ts);
+		).publishOn(Schedulers.boundedElastic()).subscribe(ts);
 
 		ts.await(Duration.ofSeconds(5));
 		ts.assertNoError();
@@ -656,7 +656,7 @@ public void mergeSequentialTwoDelayPublisherError() {
 
 	@Test
 	public void mergeSequentialLargeUnorderedEach100() {
-		Scheduler scheduler = Schedulers.elastic();
+		Scheduler scheduler = Schedulers.boundedElastic();
 		AtomicBoolean comparisonFailure = new AtomicBoolean();
 		long count = Flux.range(0, 500)
 		                 .flatMapSequential(i -> {

File: reactor-core/src/test/java/reactor/core/publisher/FluxProcessorTest.java
Patch:
@@ -196,8 +196,8 @@ public void testEmitter2() throws Throwable {
 
 	@Test
 	public void serializedConcurrent() {
-		Scheduler.Worker w1 = Schedulers.elastic().createWorker();
-		Scheduler.Worker w2 = Schedulers.elastic().createWorker();
+		Scheduler.Worker w1 = Schedulers.boundedElastic().createWorker();
+		Scheduler.Worker w2 = Schedulers.boundedElastic().createWorker();
 		CountDownLatch latch = new CountDownLatch(1);
 		CountDownLatch latch2 = new CountDownLatch(1);
 		AtomicReference<Thread> ref = new AtomicReference<>();

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1055,7 +1055,7 @@ public void rejectedExecutionExceptionOnDataSignalExecutorService()
 			ExecutorService executor = newCachedThreadPool();
 			StepVerifier.create(Flux.range(0, 5)
 			                        .log()
-			                        .publishOn(Schedulers.elastic())
+			                        .publishOn(Schedulers.boundedElastic())
 			                        .doOnRequest(n -> executor.shutdownNow())
 			                        .publishOn(fromExecutorService(executor))
 			                        .doOnNext(this::infiniteBlock))
@@ -1455,7 +1455,7 @@ public Worker createWorker() {
 	public void scanRunOn() {
 		Scannable publishOnScannable = Scannable.from(
 				Flux.just(1).hide()
-				    .publishOn(Schedulers.elastic())
+				    .publishOn(Schedulers.boundedElastic())
 		);
 		Scannable runOnScannable = publishOnScannable.scan(Scannable.Attr.RUN_ON);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -397,7 +397,7 @@ public void boundaryFused() {
 		    .publishOn(Schedulers.single())
 		    .map(v -> Thread.currentThread().getName().contains("single-") ? "single" : ("BAD-" + v + Thread.currentThread().getName()))
 		    .share()
-		    .publishOn(Schedulers.elastic())
+		    .publishOn(Schedulers.boundedElastic())
 		    .distinct()
 		    .as(StepVerifier::create)
 		    .expectFusion()

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnTest.java
Patch:
@@ -202,7 +202,7 @@ public void scheduleRequestsByDefault() {
 		}, DROP)
 		        .map(Flux.identityFunction()) //note the create is away from subscribeOn
 				.subscribeOn(Schedulers.newSingle("test")) //note there's no explicit parameter
-				.publishOn(Schedulers.elastic());
+				.publishOn(Schedulers.boundedElastic());
 
 		StepVerifier.create(test)
 		            .expectNextCount(Queues.SMALL_BUFFER_SIZE)
@@ -226,7 +226,7 @@ public void forceNoScheduledRequests() {
 		}, DROP)
 				.map(Function.identity())
 				.subscribeOn(Schedulers.single(), false)
-				.publishOn(Schedulers.elastic());
+				.publishOn(Schedulers.boundedElastic());
 
 		AtomicInteger count = new AtomicInteger();
 		StepVerifier.create(test)
@@ -253,7 +253,7 @@ public void forceScheduledRequests() {
 		}, DROP)
 				.map(Function.identity())
 				.subscribeOn(Schedulers.single(), true)
-				.publishOn(Schedulers.elastic());
+				.publishOn(Schedulers.boundedElastic());
 
 		AtomicInteger count = new AtomicInteger();
 		StepVerifier.create(test)

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeoutTest.java
Patch:
@@ -187,7 +187,7 @@ public Disposable schedule(Runnable task) {
 			public Worker createWorker() {
 				return new Worker() {
 
-					Worker delegate = Schedulers.elastic().createWorker();
+					Worker delegate = Schedulers.boundedElastic().createWorker();
 
 					@Override
 					public Disposable schedule(Runnable task) {

File: reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java
Patch:
@@ -297,7 +297,7 @@ public void depthFirstAsync() {
 
 		StepVerifier.create(Mono.just(root)
 		                        .expandDeep(v -> Flux.fromIterable(v.children)
-		                                         .subscribeOn(Schedulers.elastic()))
+		                                         .subscribeOn(Schedulers.boundedElastic()))
 		                        .map(v -> v.name))
 		            .expectNext(
 				            "root",
@@ -333,7 +333,7 @@ public void breadthFirstAsync() {
 		FluxExpandTest.Node root = createTest();
 
 		StepVerifier.create(Mono.just(root)
-		                        .expand(v -> Flux.fromIterable(v.children).subscribeOn(Schedulers.elastic()))
+		                        .expand(v -> Flux.fromIterable(v.children).subscribeOn(Schedulers.boundedElastic()))
 		                        .map(v -> v.name))
 		            .expectNext(
 				            "root",

File: reactor-core/src/test/java/reactor/core/publisher/MonoReduceTest.java
Patch:
@@ -181,7 +181,7 @@ public void should_reduce_to_10_events() {
 		Flux.range(0, 10).flatMap(x ->
 				Flux.range(0, 2)
 				    .map(y -> blockingOp(x, y))
-				    .subscribeOn(Schedulers.elastic())
+				    .subscribeOn(Schedulers.boundedElastic())
 				    .reduce((l, r) -> l + "_" + r)
 //				    .log("reduced."+x)
 				    .doOnSuccess(s -> {

File: reactor-core/src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java
Patch:
@@ -136,7 +136,7 @@ public void equalPredicateFailure() {
 
 	@Test
 	public void largeSequence() {
-		Flux<Integer> source = Flux.range(1, Queues.SMALL_BUFFER_SIZE * 4).subscribeOn(Schedulers.elastic());
+		Flux<Integer> source = Flux.range(1, Queues.SMALL_BUFFER_SIZE * 4).subscribeOn(Schedulers.boundedElastic());
 
 		StepVerifier.create(Mono.sequenceEqual(source, source))
 		            .expectNext(Boolean.TRUE)

File: reactor-core/src/test/java/reactor/core/publisher/MonoSubscriberTest.java
Patch:
@@ -183,7 +183,7 @@ public void issue1719() {
 			Map<String, Mono<Integer>> input = new HashMap<>();
 			input.put("one", Mono.just(1));
 			input.put("two", Mono.create(
-					(sink) -> Schedulers.elastic().schedule(() -> sink.success(2))));
+					(sink) -> Schedulers.boundedElastic().schedule(() -> sink.success(2))));
 			input.put("three", Mono.just(3));
 			int sum = Flux.fromIterable(input.entrySet())
 			              .flatMap((entry) -> Mono.zip(Mono.just(entry.getKey()), entry.getValue()))

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -76,7 +76,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r, Schedulers.boundedElastic());
 		}
 	}
 
@@ -91,7 +91,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r, Schedulers.boundedElastic());
 		}
 	}
 
@@ -105,7 +105,7 @@ public void run() {
 				}
 			};
 
-			RaceTestUtils.race(r, r, Schedulers.elastic());
+			RaceTestUtils.race(r, r, Schedulers.boundedElastic());
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -507,7 +507,7 @@ public void fromFuseableUsesThreadBarrier() {
 		                         .doOnNext(v -> between.add(Thread.currentThread()
 		                                                          .getName()))
 		                         .parallel(2, 1)
-		                         .runOn(Schedulers.elastic(), 1)
+		                         .runOn(Schedulers.boundedElastic(), 1)
 		                         .map(v -> {
 			                         processing.putIfAbsent(Thread.currentThread()
 			                                                      .getName(), "");
@@ -529,7 +529,7 @@ public void fromFuseableUsesThreadBarrier() {
 		                   .startsWith("single-");
 
 		assertThat(processing.keySet())
-				.allSatisfy(k -> assertThat(k).startsWith("elastic-"));
+				.allSatisfy(k -> assertThat(k).startsWith("boundedElastic-"));
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1150,7 +1150,7 @@ public void fluxCreateDemoElasticScheduler() throws Exception {
 					sink.complete();
 				}).
 				    subscribeOn(Schedulers.newSingle("production")).
-				    publishOn(Schedulers.elastic()).
+				    publishOn(Schedulers.boundedElastic()).
 				    subscribe(i -> {
 					    LockSupport.parkNanos(100L);
 					    latch.countDown();

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -38,7 +38,7 @@ public void test() throws Exception {
 		    .flatMap(value -> Mono.fromCallable(() -> {
 								    Thread.sleep(1000);
 								    return value;
-							    }).subscribeOn(Schedulers.elastic()))
+							    }).subscribeOn(Schedulers.boundedElastic()))
 		    .log("merged")
 		    .collect(Result::new, Result::add)
 		    .doOnNext(Result::stop)

File: reactor-core/src/main/java/reactor/core/scheduler/Scheduler.java
Patch:
@@ -61,7 +61,7 @@ public interface Scheduler extends Disposable {
 	 * @param delay the delay amount, non-positive values indicate non-delayed scheduling
 	 * @param unit the unit of measure of the delay amount
 	 * @return the {@link Disposable} that let's one cancel this particular delayed task,
-	 * or throw a {@link RejectedExecutionException} if the Scheduler is not capable of scheduling periodically.
+	 * or throw a {@link RejectedExecutionException} if the Scheduler is not capable of scheduling with delay.
 	 */
 	default Disposable schedule(Runnable task, long delay, TimeUnit unit) {
 		throw Exceptions.failWithRejectedNotTimeCapable();

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
@@ -203,7 +204,7 @@ static final class RepeatWhenOtherSubscriber extends Flux<Long>
 
 		RepeatWhenMainSubscriber<?> main;
 
-		final DirectProcessor<Long> completionSignal = new DirectProcessor<>();
+		final FluxIdentityProcessor<Long> completionSignal = Processors.more().multicastNoBackpressure();
 
 		@Override
 		public Context currentContext() {
@@ -250,7 +251,7 @@ public CoreSubscriber<? super Long> subscribeOrReturn(CoreSubscriber<? super Lon
 		}
 
 		@Override
-		public DirectProcessor<Long> source() {
+		public FluxIdentityProcessor<Long> source() {
 			return completionSignal;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -224,7 +224,7 @@ static final class RetryWhenOtherSubscriber extends Flux<Retry.RetrySignal>
 	implements InnerConsumer<Object>, OptimizableOperator<Retry.RetrySignal, Retry.RetrySignal> {
 		RetryWhenMainSubscriber<?> main;
 
-		final DirectProcessor<Retry.RetrySignal> completionSignal = new DirectProcessor<>();
+		final FluxIdentityProcessor<Retry.RetrySignal> completionSignal = Processors.more().multicastNoBackpressure();
 
 		@Override
 		public Context currentContext() {
@@ -271,7 +271,7 @@ public CoreSubscriber<? super Retry.RetrySignal> subscribeOrReturn(CoreSubscribe
 		}
 
 		@Override
-		public DirectProcessor<Retry.RetrySignal> source() {
+		public CorePublisher<Retry.RetrySignal> source() {
 			return completionSignal;
 		}
 

File: reactor-core/src/test/java/reactor/core/publisher/DirectProcessorTest.java
Patch:
@@ -25,6 +25,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
+@SuppressWarnings("deprecation")
 public class DirectProcessorTest {
 
     @Test(expected = NullPointerException.class)

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -20,6 +20,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 import org.mockito.Mockito;
+
 import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.test.MockUtils;
@@ -42,7 +43,7 @@ public void constructors() {
 	
 	@Test
 	public void connectImmediately() {
-		EmitterProcessor<Integer> e = EmitterProcessor.create();
+		FluxIdentityProcessor<Integer> e = Processors.multicast();
 
 		AtomicReference<Disposable> cancel = new AtomicReference<>();
 		
@@ -57,7 +58,7 @@ public void connectImmediately() {
 
 	@Test
 	public void connectAfterMany() {
-		EmitterProcessor<Integer> e = EmitterProcessor.create();
+		FluxIdentityProcessor<Integer> e = Processors.multicast();
 
 		AtomicReference<Disposable> cancel = new AtomicReference<>();
 		

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -29,6 +29,7 @@
 import org.junit.After;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
@@ -206,8 +207,8 @@ public void downstreamDemandShouldBeAbleToDecreaseOnTimeSpan() {
 
 	@Test
 	public void requestedFromUpstreamShouldNotExceedDownstreamDemand() {
-		EmitterProcessor<String> emitter = EmitterProcessor.create(1);
-		FluxSink<String> sink = emitter.sink();
+		Sinks.StandaloneFluxSink<String> sink = Sinks.multicast();
+		Flux<String> emitter = sink.asFlux();
 
 		AtomicLong requestedOutstanding = new AtomicLong(0);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -229,7 +229,7 @@ public void keyComparatorThrows() {
 
 	@Test
 	public void allDistinctConditional() {
-		DirectProcessor<Integer> dp = new DirectProcessor<>();
+		FluxIdentityProcessor<Integer> dp = Processors.more().multicastNoBackpressure();
 
 		AssertSubscriber<Integer> ts = dp.distinctUntilChanged()
 		                                 .filter(v -> true)

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
@@ -253,7 +254,7 @@ protected void hookFinally(SignalType type) {
 
 	@Test
 	public void cancel() {
-		final EmitterProcessor<Boolean> pp = EmitterProcessor.create();
+		final FluxIdentityProcessor<Boolean> pp = Processors.multicast();
 
 		StepVerifier.create(Flux.range(1, 5)
 		                        .filterWhen(v -> pp, 16))

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureDropTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
@@ -89,7 +90,7 @@ public void normalBackpressured() {
 
 	@Test
 	public void someDrops() {
-		DirectProcessor<Integer> tp = DirectProcessor.create();
+		FluxIdentityProcessor<Integer> tp = Processors.more().multicastNoBackpressure();
 
 		AssertSubscriber<Integer> ts = AssertSubscriber.create(0);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.junit.Assert;
 import org.junit.Test;
@@ -44,6 +43,7 @@
 import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
 
@@ -497,7 +497,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.create(Queues.<Integer>get(2).get())
+		Processors.more().unicast(Queues.<Integer>get(2).get())
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -735,7 +735,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.create(Queues.<Integer>get(2).get())
+		Processors.more().unicast(Queues.<Integer>get(2).get())
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -398,8 +398,7 @@ public void onlyInitialRequestWithLateUnboundedSubscriber() {
 
 	@Test
 	public void cancel() {
-		ConnectableFlux<Integer> replay = UnicastProcessor.<Integer>create()
-		                                             .replay(2);
+		ConnectableFlux<Integer> replay = Processors.<Integer>unicast().replay(2);
 
 		replay.subscribe(v -> {}, e -> { throw Exceptions.propagate(e); });
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
@@ -262,7 +263,7 @@ public void subscriberCancels() {
 
 		AtomicInteger cleanup = new AtomicInteger();
 
-		DirectProcessor<Integer> tp = DirectProcessor.create();
+		FluxIdentityProcessor<Integer> tp = Processors.more().multicastNoBackpressure();
 
 		Flux.using(() -> 1, r -> tp, cleanup::set, true)
 		    .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
@@ -347,6 +348,7 @@ public void ensuresElementsIsDiscarded() {
 			Hooks.onNextDropped(collector::add);
 			AssertSubscriber<Object> assertSubscriber = new AssertSubscriber<>(Operators.enableOnDiscard(null, collector::add), 1);
 
+			@SuppressWarnings("unchecked")
 			MonoSink<Object>[] sinks = new MonoSink[1];
 
 			Mono.create(sink -> sinks[0] = sink)

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
@@ -247,7 +248,7 @@ protected void hookFinally(SignalType type) {
 
 	@Test
 	public void cancel() {
-		final EmitterProcessor<Boolean> pp = EmitterProcessor.create();
+		final FluxIdentityProcessor<Boolean> pp = Processors.multicast();
 
 		StepVerifier.create(Mono.just(1)
 		                        .filterWhen(v -> pp))

File: reactor-core/src/test/java/reactor/core/publisher/MonoTimeoutTest.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.TimeoutException;
 
 import org.junit.Test;
+
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -70,7 +71,7 @@ public void timeoutRequested() {
 
 		MonoProcessor<Integer> source = MonoProcessor.create();
 
-		DirectProcessor<Integer> tp = DirectProcessor.create();
+		FluxIdentityProcessor<Integer> tp = Processors.more().multicastNoBackpressure();
 
 		source.timeout(tp)
 		      .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/OnDiscardShouldNotLeakTest.java
Patch:
@@ -72,9 +72,9 @@ public class OnDiscardShouldNotLeakTest {
 					.map(Function.identity())
 					.map(Function.identity())
 					.publishOn(Schedulers.immediate())),
-			DiscardScenario.fluxSource("unicastProcessor", 1, f -> f.subscribeWith(UnicastProcessor.create())),
+			DiscardScenario.fluxSource("unicastProcessor", 1, f -> f.subscribeWith(Processors.unicast())),
 			DiscardScenario.fluxSource("unicastProcessorAndPublishOn", 1, f -> f
-					.subscribeWith(UnicastProcessor.create())
+					.subscribeWith(Processors.unicast())
 					.publishOn(Schedulers.immediate())),
 	};
 

File: reactor-core/src/test/java/reactor/core/publisher/ReplayProcessorTest.java
Patch:
@@ -32,6 +32,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@SuppressWarnings("deprecation")
 public class ReplayProcessorTest {
 
     @Test

File: reactor-core/src/test/java/reactor/core/publisher/StrictSubscriberTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 
@@ -72,7 +73,7 @@ public void cancelDelayed() {
 		AtomicBoolean state2 = new AtomicBoolean();
 		AtomicReference<Throwable> e = new AtomicReference<>();
 
-		DirectProcessor<Integer> sp = DirectProcessor.create();
+		FluxIdentityProcessor<Integer> sp = Processors.more().multicastNoBackpressure();
 
 		sp.doOnCancel(() -> state2.set(state1.get()))
 		  .subscribe(new Subscriber<Integer>() {

File: reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java
Patch:
@@ -43,6 +43,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 
+@SuppressWarnings("deprecation")
 public class UnicastProcessorTest {
 
     @Test

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -46,9 +46,10 @@
 import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.core.publisher.DirectProcessor;
 import reactor.core.publisher.Flux;
+import reactor.core.publisher.FluxIdentityProcessor;
 import reactor.core.publisher.Mono;
+import reactor.core.publisher.Processors;
 import reactor.test.StepVerifier;
 
 import static org.assertj.core.api.Assertions.*;
@@ -656,7 +657,7 @@ public void testRejectingExecutorServiceScheduler() {
 
 	public void assertRejectingScheduler(Scheduler scheduler) {
 		try {
-			DirectProcessor<String> p = DirectProcessor.create();
+			FluxIdentityProcessor<String> p = Processors.more().multicastNoBackpressure();
 
 			AtomicReference<String> r = new AtomicReference<>();
 			CountDownLatch l = new CountDownLatch(1);

File: reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
 import com.pivovarit.function.ThrowingRunnable;
@@ -40,6 +39,7 @@
  * @author Stephane Maldini
  * @author Simon Baslé
  */
+@SuppressWarnings("deprecation")
 public class ElasticSchedulerTest extends AbstractSchedulerTest {
 
 	private static final Logger LOGGER = Loggers.getLogger(ElasticSchedulerTest.class);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -847,8 +847,8 @@ public final <R> ParallelFlux<R> reduce(Supplier<R> initialSupplier,
 	}
 
 	/**
-	 * Specifies where each 'rail' will observe its incoming values with no work-stealing
-	 * and default prefetch amount.
+	 * Specifies where each 'rail' will observe its incoming values with possible
+	 * work-stealing and default prefetch amount.
 	 * <p>
 	 * This operator uses the default prefetch size returned by {@code
 	 * Queues.SMALL_BUFFER_SIZE}.
@@ -872,7 +872,7 @@ public final ParallelFlux<T> runOn(Scheduler scheduler) {
 	}
 
 	/**
-	 * Specifies where each 'rail' will observe its incoming values with possibly
+	 * Specifies where each 'rail' will observe its incoming values with possible
 	 * work-stealing and a given prefetch amount.
 	 * <p>
 	 * This operator uses the default prefetch size returned by {@code

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java
Patch:
@@ -102,7 +102,7 @@ final public void cancel() {
 		}
 
 		@Override
-		final public void onComplete() {
+		public void onComplete() {
 			if (done) {
 				return;
 			}
@@ -124,7 +124,7 @@ final public void onError(Throwable e) {
 		}
 
 		@Override
-		final public void onNext(T t) {
+		public void onNext(T t) {
 			if (done) {
 				FluxMetrics.recordMalformed(commonTags, registry);
 				Operators.onNextDropped(t, actual.currentContext());

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7340,7 +7340,7 @@ public final Flux<T> retryWhen(Function<Flux<Throwable>, ? extends Publisher<?>>
 	 * the previous Context:
 	 * <blockquote><pre>
 	 * {@code
-	 * Retry customStrategy = Retry.fromFunction(companion -> companion.handle((retrySignal, sink) -> {
+	 * Retry customStrategy = Retry.from(companion -> companion.handle((retrySignal, sink) -> {
 	 * 	    Context ctx = sink.currentContext();
 	 * 	    int rl = ctx.getOrDefault("retriesLeft", 0);
 	 * 	    if (rl > 0) {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3763,7 +3763,7 @@ public final Mono<T> retryWhen(Function<Flux<Throwable>, ? extends Publisher<?>>
 	 * <blockquote>
 	 * <pre>
 	 * {@code
-	 * Retry customStrategy = Retry.fromFunction(companion -> companion.handle((retrySignal, sink) -> {
+	 * Retry customStrategy = Retry.from(companion -> companion.handle((retrySignal, sink) -> {
 	 * 	    Context ctx = sink.currentContext();
 	 * 	    int rl = ctx.getOrDefault("retriesLeft", 0);
 	 * 	    if (rl > 0) {

File: reactor-core/src/main/java/reactor/util/retry/RetryBackoffSpec.java
Patch:
@@ -204,7 +204,7 @@ public RetryBackoffSpec filter(Predicate<? super Throwable> errorFilter) {
 	 * <pre><code>
 	 * //given
 	 * RetrySpec retryTwiceIllegalArgument = Retry.max(2)
-	 *     .throwablePredicate(e -> e instanceof IllegalArgumentException);
+	 *     .filter(e -> e instanceof IllegalArgumentException);
 	 *
 	 * RetrySpec retryTwiceIllegalArgWithCause = retryTwiceIllegalArgument.modifyErrorFilter(old ->
 	 *     old.and(e -> e.getCause() != null));

File: reactor-core/src/main/java/reactor/util/retry/RetrySpec.java
Patch:
@@ -160,7 +160,7 @@ public RetrySpec filter(Predicate<? super Throwable> errorFilter) {
 	 * <pre><code>
 	 * //given
 	 * RetrySpec retryTwiceIllegalArgument = Retry.max(2)
-	 *     .throwablePredicate(e -> e instanceof IllegalArgumentException);
+	 *     .filter(e -> e instanceof IllegalArgumentException);
 	 *
 	 * RetrySpec retryTwiceIllegalArgWithCause = retryTwiceIllegalArgument.modifyErrorFilter(old ->
 	 *     old.and(e -> e.getCause() != null));

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1253,7 +1253,7 @@ public void callablePath() {
 	}
 
 	@Test
-    public void scanSubscriber() {
+    public void scanSubscriber() throws InterruptedException {
         CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxPublishOn.PublishOnSubscriber<Integer> test = new FluxPublishOn.PublishOnSubscriber<>(actual,
         		Schedulers.single(), Schedulers.single().createWorker(), true, 123, 123, Queues.unbounded());
@@ -1278,6 +1278,7 @@ public void scanSubscriber() {
 
         //once cancelled, there shouldn't be any draining left
         // => better place to test that BUFFERED reflects the size of the queue
+		Thread.sleep(50); //"hiccup" to ensure cancellation / draining is done
         test.queue.add(1);
         test.queue.add(1);
         assertThat(test.scan(Scannable.Attr.BUFFERED)).isEqualTo(2);

File: reactor-core/src/test/java/reactor/core/scheduler/BoundedElasticSchedulerTest.java
Patch:
@@ -27,7 +27,6 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -98,6 +97,8 @@ public static void dumpThreads() {
 		LOGGER.debug(dumpThreadNames().collect(Collectors.joining(", ")));
 	}
 
+	//note: blocking behavior is also tested in BoundedElasticSchedulerBlockhoundTest (separate sourceset)
+
 	@Override
 	protected BoundedElasticScheduler scheduler() {
 		return afterTest.autoDispose(

File: reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java
Patch:
@@ -1040,7 +1040,7 @@ public void noInnerReordering() {
 
 		ps.onNext(2);
 
-		fmm.drain();
+		fmm.drain(null);
 
 		ts.assertValues(1, 2);
 	}
@@ -1065,7 +1065,7 @@ public void noOuterScalarReordering() {
 
 		fmm.onNext(Flux.just(2));
 
-		fmm.drain();
+		fmm.drain(null);
 
 		ts.assertValues(1, 2);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -172,6 +172,9 @@ public Object scanUnsafe(Attr key) {
 	 * Create a {@link FluxProcessor} that safely gates multi-threaded producer
 	 * {@link Subscriber#onNext(Object)}.
 	 *
+	 * @reactor.discard The resulting processor discards elements received from the source
+	 * {@link Publisher} (if any) when it cancels subscription to said source.
+	 *
 	 * @return a serializing {@link FluxProcessor}
 	 */
 	public final FluxProcessor<IN, OUT> serialize() {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFirstTest.java
Patch:
@@ -133,7 +133,7 @@ public void runnableFailure_NotFuseable() {
 
 		assertThat(test).as("doFirst not fuseable").isNotInstanceOf(Fuseable.class);
 		StepVerifier.create(test)
-		            .expectSubscriptionMatches(sub -> sub instanceof Operators.EmptySubscription)
+		            .expectSubscription()
 		            .verifyErrorMessage("expected");
 	}
 
@@ -146,7 +146,7 @@ public void runnableFailure_Fuseable() {
 
 		assertThat(test).as("doFirst is fuseable").isInstanceOf(Fuseable.class);
 		StepVerifier.create(test)
-		            .expectSubscriptionMatches(sub -> sub instanceof Operators.EmptySubscription)
+		            .expectSubscription()
 		            .verifyErrorMessage("expected");
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoDoFirstTest.java
Patch:
@@ -133,7 +133,7 @@ public void runnableFailure_NotFuseable() {
 
 		assertThat(test).as("doFirst not fuseable").isNotInstanceOf(Fuseable.class);
 		StepVerifier.create(test)
-		            .expectSubscriptionMatches(sub -> sub instanceof Operators.EmptySubscription)
+		            .expectSubscription()
 		            .verifyErrorMessage("expected");
 	}
 
@@ -146,7 +146,7 @@ public void runnableFailure_Fuseable() {
 
 		assertThat(test).as("doFirst is fuseable").isInstanceOf(Fuseable.class);
 		StepVerifier.create(test)
-		            .expectSubscriptionMatches(sub -> sub instanceof Operators.EmptySubscription)
+		            .expectSubscription()
 		            .verifyErrorMessage("expected");
 	}
 

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -1130,7 +1130,8 @@ else if (initialRequest != 0L) {
 					setFailure(null, "an unexpected Subscription has been received: %s; actual: cancelled",
 							subscription);
 				}
-				else {
+				// subscribeOrReturn may throw an exception after calling onSubscribe.
+				else if (!Operators.canAppearAfterOnSubscribe(subscription)) {
 					setFailure(null, "an unexpected Subscription has been received: %s; actual: %s",
 							subscription,
 							this.get());

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -230,18 +230,17 @@ public final Stream<DynamicTest> sequenceOfNextWithCallbackError() {
 	@TestFactory
 	public final Stream<DynamicTest> errorOnSubscribe() {
 		defaultEmpty = true;
-		defaultScenario.producerError(new RuntimeException("test"));
+		String exceptionMessage = "test";
 
 		Consumer<OperatorScenario<I, PI, O, PO>> prepareVerifier = scenario -> {
 			if (scenario.verifier() != null) {
 				return;
 			}
 
-			String m = exception().getMessage();
 			scenario.verifier = step -> {
 				StepVerifier.Assertions assertions =
 						scenario.applySteps(step)
-						        .expectErrorMessage(m)
+						        .expectErrorMessage(exceptionMessage)
 						        .verifyThenAssertThat();
 
 				if (scenario.shouldHitDropErrorHookAfterTerminate()) {
@@ -309,6 +308,7 @@ public final Stream<DynamicTest> errorOnSubscribe() {
 				prepareVerifier.accept(subScenario);
 
 				return toDynamicTest(subScenario, () -> {
+					defaultScenario.producerError(new RuntimeException(exceptionMessage));
 					StepVerifier.Step<O> step = stepFunction.apply(subScenario);
 					subScenario.verifier().accept(step);
 				});

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java
Patch:
@@ -63,7 +63,7 @@ public String stepName() {
 		if (source instanceof Scannable) {
 			return Scannable.from(source).stepName();
 		}
-		return Scannable.super.stepName();
+		return super.stepName();
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java
Patch:
@@ -65,7 +65,7 @@ public String stepName() {
 		if (source instanceof Scannable) {
 			return Scannable.from(source).stepName();
 		}
-		return Scannable.super.stepName();
+		return super.stepName();
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/ScannableTest.java
Patch:
@@ -557,14 +557,15 @@ public void operatorChainWithDebugMode() {
 		}
 
 		assertThat(downstream).containsExactly(
+				"Flux.from ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:537)",
 				"Flux.map ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:542)",
 				"Flux.delayElements ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:543)",
 				"Flux.filter ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:544)",
 				"Flux.reduce ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:545)",
 				"lambda");
 
 		assertThat(upstream).containsExactly(
-				"source(FluxSource)",
+				"Flux.from ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:537)",
 				"Flux.map ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:542)",
 				"Flux.delayElements ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:543)",
 				"Flux.filter ⇢ reactor.core.ScannableTest.operatorChainWithDebugMode(ScannableTest.java:544)",
@@ -617,7 +618,7 @@ public void operatorChainWithCheckpoint() {
 		assertThat(Scannable.from(flux).steps())
 				.containsExactly(
 						"source(FluxJust)",
-						"Flux.checkpoint ⇢ reactor.core.ScannableTest.operatorChainWithCheckpoint(ScannableTest.java:614)",
+						"Flux.checkpoint ⇢ reactor.core.ScannableTest.operatorChainWithCheckpoint(ScannableTest.java:615)",
 						"map"
 				);
 	}

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -1069,9 +1069,9 @@ else if (initialRequest != 0L) {
 							subscription);
 				}
 				else {
-					setFailure(null, "an unexpected Subscription has been received: %s; actual: ",
+					setFailure(null, "an unexpected Subscription has been received: %s; actual: %s",
 							subscription,
-							this);
+							this.get());
 				}
 			}
 		}

File: reactor-tools/src/jarFileTest/java/reactor/tools/JarFileShadingTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.nio.file.Path;
 
 import org.assertj.core.api.ListAssert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-tools/src/jarFileTest/java/reactor/tools/JarFileShadingTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.nio.file.Path;
 
 import org.assertj.core.api.ListAssert;
-import org.junit.jupiter.api.Test;
+import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-tools/src/jarFileTest/java/reactor/tools/JarFileShadingTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.nio.file.Path;
 
 import org.assertj.core.api.ListAssert;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/main/java/reactor/core/publisher/OptimizableOperator.java
Patch:
@@ -41,7 +41,7 @@ interface OptimizableOperator<IN, OUT> extends CorePublisher<IN> {
 	 * @return next {@link CoreSubscriber} or "null" if the subscription was already done inside the method
 	 */
 	@Nullable
-	CoreSubscriber<? super OUT> subscribeOrReturn(CoreSubscriber<? super IN> actual);
+	CoreSubscriber<? super OUT> subscribeOrReturn(CoreSubscriber<? super IN> actual) throws Throwable;
 
 	/**
 	 * @return {@link CorePublisher} to call {@link CorePublisher#subscribe(CoreSubscriber)} on

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -123,8 +123,9 @@ public void onNext(T t) {
 				this.task = scheduler.schedule(() -> complete(t), delay, unit);
 			}
 			catch (RejectedExecutionException ree) {
-				throw Operators.onRejectedExecution(ree, this, null, t,
-						actual.currentContext());
+				actual.onError(Operators.onRejectedExecution(ree, this, null, t,
+						actual.currentContext()));
+				return;
 			}
 		}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -353,9 +353,8 @@ public void distinctUntilChangedDefaultCancelDoesntRetainObjects() throws Interr
 
 		System.gc();
 		await().untilAsserted(() -> {
-			assertThat(retainedDetector.finalizedCount())
-					.as("none retained after cancel")
-					.isEqualTo(50);
+			System.gc();
+			retainedDetector.assertAllFinalized();
 		});
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingWhenTest.java
Patch:
@@ -1160,8 +1160,8 @@ public void onComplete() {}
 		});
 
 		Thread.sleep(300);
-		assertThat(cleanupCount.sum()).isEqualTo(1000);
-		assertThat(cancelled).as("source cancelled").isTrue();
+			          assertThat(cleanupCount.sum()).isEqualTo(1000);
+			          assertThat(cancelled).as("source cancelled").isTrue();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersMetricsTest.java
Patch:
@@ -253,7 +253,7 @@ public void shouldReportExecutionTimes(Supplier<Scheduler> schedulerSupplier, St
 			assertThat(timers.stream()
 			                 .reduce(0d, (time, timer) -> time + timer.totalTime(TimeUnit.MILLISECONDS), Double::sum))
 					.as("total durations")
-					.isEqualTo(600 + 400 + 200, offset(30.0d));
+					.isEqualTo(600 + 400 + 200, offset(50d));
 			assertThat(timers.stream().mapToLong(Timer::count).sum())
 					.as("count")
 					.isEqualTo(taskCount);

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -9117,9 +9117,9 @@ public final Stream<T> toStream(int batchSize) {
 	 * @see #transformDeferred(Function) for deferred composition of {@link Flux} for each {@link Subscriber}
 	 * @see #as for a loose conversion to an arbitrary type
 	 */
+	@SuppressWarnings({"unchecked", "rawtypes"})
 	public final <V> Flux<V> transform(Function<? super Flux<T>, ? extends Publisher<V>> transformer) {
 		if (Hooks.DETECT_CONTEXT_LOSS) {
-			//noinspection unchecked,rawtypes
 			transformer = new ContextTrackingFunctionWrapper(transformer);
 		}
 		return onAssembly(from(transformer.apply(this)));
@@ -9142,10 +9142,10 @@ public final <V> Flux<V> transform(Function<? super Flux<T>, ? extends Publisher
 	 * @see #transform(Function) transform() for immmediate transformation of {@link Flux}
 	 * @see #as as() for a loose conversion to an arbitrary type
 	 */
+	@SuppressWarnings({"rawtypes", "unchecked"})
 	public final <V> Flux<V> transformDeferred(Function<? super Flux<T>, ? extends Publisher<V>> transformer) {
 		return defer(() -> {
 			if (Hooks.DETECT_CONTEXT_LOSS) {
-				//noinspection unchecked,rawtypes
 				return new ContextTrackingFunctionWrapper<T, V>((Function) transformer).apply(this);
 			}
 			return transformer.apply(this);

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -4689,9 +4689,9 @@ public final MonoProcessor<T> toProcessor() {
 	 * @see #transformDeferred(Function) transformDeferred(Function) for deferred composition of {@link Mono} for each {@link Subscriber}
 	 * @see #as(Function) as(Function) for a loose conversion to an arbitrary type
 	 */
+	@SuppressWarnings({"unchecked", "rawtypes"})
 	public final <V> Mono<V> transform(Function<? super Mono<T>, ? extends Publisher<V>> transformer) {
 		if (Hooks.DETECT_CONTEXT_LOSS) {
-			//noinspection unchecked,rawtypes
 			transformer = new ContextTrackingFunctionWrapper(transformer);
 		}
 		return onAssembly(from(transformer.apply(this)));
@@ -4716,10 +4716,10 @@ public final <V> Mono<V> transform(Function<? super Mono<T>, ? extends Publisher
 	 * @see #as as() for a loose conversion to an arbitrary type
 	 * @see #transform(Function)
 	 */
+	@SuppressWarnings({"unchecked", "rawtypes"})
 	public final <V> Mono<V> transformDeferred(Function<? super Mono<T>, ? extends Publisher<V>> transformer) {
 		return defer(() -> {
 			if (Hooks.DETECT_CONTEXT_LOSS) {
-				//noinspection unchecked,rawtypes
 				return from(new ContextTrackingFunctionWrapper<T, V>((Function) transformer).apply(this));
 			}
 			return from(transformer.apply(this));

File: reactor-core/src/main/java/reactor/util/context/Context.java
Patch:
@@ -185,8 +185,9 @@ static Context of(Map<?, ?> map) {
 				throw new NullPointerException("null value for key " + key);
 			}
 		});
-		//noinspection unchecked
-		return new ContextN((Map) map);
+		@SuppressWarnings("unchecked")
+		final Map<Object, Object> generifiedMap = (Map<Object, Object>) map;
+		return new ContextN(generifiedMap);
 	}
 
 	/**

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryPredicateTest.java
Patch:
@@ -21,9 +21,11 @@
 import java.util.function.Predicate;
 
 import org.junit.Test;
+
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
+@SuppressWarnings("deprecation") //retry with Predicate are deprecated, the underlying implementation is going to be removed ultimately
 public class FluxRetryPredicateTest {
 
 	final Flux<Integer> source = Flux.concat(Flux.range(1, 5),

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -61,13 +61,14 @@ public void sourceNull() {
 		new FluxRetryWhen<>(null, Retry.from(v -> v));
 	}
 
-	@SuppressWarnings("deprecation")
+	@SuppressWarnings({"deprecation", "unchecked", "rawtypes", "ConstantConditions"})
 	@Test(expected = NullPointerException.class)
 	public void whenThrowableFactoryNull() {
 		Flux.never()
 		    .retryWhen((Function) null);
 	}
 
+	@SuppressWarnings("ConstantConditions")
 	@Test(expected = NullPointerException.class)
 	public void whenRetrySignalFactoryNull() {
 		Flux.never()
@@ -863,6 +864,7 @@ public static Flux<Integer> transientErrorSource() {
 		});
 	}
 
+	@SuppressWarnings("deprecation")
 	@Test
 	public void retryWhenThrowableCompanionIsComparableToRetryWhenRetryFromFunction() {
 		AtomicInteger sourceHelper = new AtomicInteger();
@@ -875,7 +877,6 @@ public void retryWhenThrowableCompanionIsComparableToRetryWhenRetryFromFunction(
 			}
 		});
 
-		//noinspection deprecation
 		StepVerifier.withVirtualTime(() -> source.retryWhen(companion -> companion.delayElements(Duration.ofSeconds(3))))
 		            .expectSubscription()
 		            .expectNoEvent(Duration.ofSeconds(3 * 3))

File: reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java
Patch:
@@ -28,6 +28,7 @@
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
@@ -131,6 +132,7 @@ public void MonoProcessorResultNotAvailable() {
 		mp.block(Duration.ofMillis(1));
 	}
 
+	@SuppressWarnings("deprecation")
 	@Test
 	public void MonoProcessorRejectedDoOnSuccessOrError() {
 		MonoProcessor<String> mp = MonoProcessor.create();
@@ -170,6 +172,7 @@ public void MonoProcessorRejectedSubscribeCallback() {
 		assertThat(mp.isError()).isTrue();
 	}
 
+	@SuppressWarnings("deprecation")
 	@Test
 	public void MonoProcessorSuccessDoOnSuccessOrError() {
 		MonoProcessor<String> mp = MonoProcessor.create();

File: reactor-core/src/test/java/reactor/core/publisher/MonoRetryPredicateTest.java
Patch:
@@ -19,10 +19,12 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
+
 import reactor.test.StepVerifier;
 
 public class MonoRetryPredicateTest {
 
+	@SuppressWarnings("deprecation")
 	@Test
 	public void twoRetryNormalSupplier() {
 		AtomicInteger i = new AtomicInteger();
@@ -43,6 +45,7 @@ public void twoRetryNormalSupplier() {
 		            .verify();
 	}
 
+	@SuppressWarnings("deprecation")
 	@Test
 	public void twoRetryErrorSupplier() {
 		AtomicInteger i = new AtomicInteger();

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.assertj.core.api.Condition;
 import org.junit.Assert;
 import org.junit.Test;
+
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -73,7 +74,7 @@ public void normalEager() {
 		AtomicInteger cleanup = new AtomicInteger();
 
 		Mono.using(() -> 1, r -> Mono.just(1)
-		                             .doOnSuccessOrError((value, error) ->  Assert.assertEquals(0, cleanup.get())),
+		                             .doOnTerminate(() ->  assertThat(cleanup).hasValue(0)),
 				cleanup::set,
 				true)
 		    .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -33,14 +33,14 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
-
 import javax.annotation.Nullable;
 
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
@@ -861,6 +861,7 @@ public Integer next() {
 				return n;
 			}
 		};
+		@SuppressWarnings("unchecked")
 		List<Integer> mock = Mockito.mock(List.class);
 		Mockito.when(mock.iterator()).thenReturn(failingIterator);
 

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -52,6 +52,7 @@
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
@@ -71,6 +72,7 @@
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -1425,7 +1427,7 @@ public void testThrowWithoutOnErrorShowsUpInSchedulerHandler() {
 			Thread.setDefaultUncaughtExceptionHandler(null);
 			Schedulers.resetOnHandleError();
 		}
-		Assert.assertThat("Uncaught error not handled", handled.get(), is(true));
+		assertThat(handled).as("Uncaught error handler").isTrue();
 		if (failure.get() != null) {
 			fail(failure.get());
 		}

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -49,6 +49,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
@@ -59,7 +60,6 @@
 import reactor.core.publisher.Hooks;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Operators;
-import reactor.core.publisher.ParallelFlux;
 import reactor.core.publisher.Signal;
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.util.Logger;
@@ -598,6 +598,7 @@ else if (!predicate.test(signal.getSubscription())) {
 	}
 
 	@Override
+	@SuppressWarnings("deprecation") //the API-level is deprecated to discourage direct use as first step
 	public DefaultStepVerifierBuilder<T> expectNoEvent(Duration duration) {
 		Objects.requireNonNull(duration, "duration");
 		if(this.script.size() == 1 && this.script.get(0) == defaultFirstStep){

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryPredicateTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Predicate;
 
 import org.junit.Test;
 import reactor.test.StepVerifier;
@@ -36,7 +37,7 @@ public void sourceNull() {
 	@Test(expected = NullPointerException.class)
 	public void predicateNull() {
 		Flux.never()
-		    .retry(null);
+		    .retry((Predicate<? super Throwable>) null);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/guide/GuideDebuggingExtraTests.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.StringWriter;
 
 import org.junit.Test;
+
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Hooks;
 
@@ -50,9 +51,9 @@ public void debuggingActivatedWithDeepTraceback() {
 							+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)\n"
 							+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)\n"
 							+ "\t|_    Flux.filter ⇢ at reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)\n"
-							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)\n"
+							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)\n"
 							+ "\t|_   Flux.elapsed ⇢ at reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)\n"
-							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)\n");
+							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:42)\n");
 		}
 		finally {
 			Hooks.resetOnOperatorDebug();

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -4319,7 +4319,7 @@ public final Mono<Tuple2<Long, T>> timestamp(Scheduler scheduler) {
 	 * @return a {@link CompletableFuture}
 	 */
 	public final CompletableFuture<T> toFuture() {
-		return subscribeWith(new MonoToCompletableFuture<>());
+		return subscribeWith(new MonoToCompletableFuture<>(false));
 	}
 
 	/**

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -219,7 +219,7 @@ static <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T
 	 */
 	static <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T>> scenarioSupplier,
 			long n) {
-		return withVirtualTime(scenarioSupplier, () -> VirtualTimeScheduler.create(true), n);
+		return withVirtualTime(scenarioSupplier, () -> VirtualTimeScheduler.getOrSet(true), n);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -174,7 +174,7 @@ void resubscribe(Object trigger) {
 					//flow that emit a Context as a trigger for the re-subscription are
 					//used to REPLACE the currentContext()
 					if (trigger instanceof Context) {
-						this.context = (Context) trigger;
+						this.context = this.context.putAll((Context) trigger);
 					}
 
 					source.subscribe(this);

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -180,7 +180,7 @@ void resubscribe(Object trigger) {
 					//flow that emit a Context as a trigger for the re-subscription are
 					//used to REPLACE the currentContext()
 					if (trigger instanceof Context) {
-						this.context = (Context) trigger;
+						this.context = this.context.putAll((Context) trigger);
 					}
 
 					source.subscribe(this);

File: reactor-core/src/main/java/reactor/util/context/Context.java
Patch:
@@ -348,8 +348,8 @@ default Context putAll(Context other) {
 		}
 
 		ContextN newContext = new ContextN(this.size() + other.size());
-		this.stream().forEach(newContext);
-		other.stream().forEach(newContext);
+		this.stream().sequential().forEach(newContext);
+		other.stream().sequential().forEach(newContext);
 		if (newContext.size() <= 5) {
 			// make it return Context{1-5}
 			return Context.of(newContext);

File: reactor-core/src/main/java/reactor/util/context/ContextN.java
Patch:
@@ -177,7 +177,7 @@ public Context putAll(Context other) {
 		}
 		else {
 			// avoid Collector to reduce the allocations
-			other.stream().forEach(newContext);
+			other.stream().sequential().forEach(newContext);
 		}
 
 		return newContext;

File: reactor-core/src/main/java/reactor/util/context/CoreContext.java
Patch:
@@ -40,7 +40,7 @@ default Context putAll(Context other) {
 
 		ContextN newContext = new ContextN(this.size() + other.size());
 		this.unsafePutAllInto(newContext);
-		other.stream().forEach(newContext);
+		other.stream().sequential().forEach(newContext);
 		if (newContext.size() <= 5) {
 			// make it return Context{1-5}
 			return Context.of(newContext);

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -1702,7 +1702,6 @@ public void consumeWhileErrorIsSuppressed() {
 	}
 
 	@Test
-	@SuppressWarnings("unchecked")
 	public void requestBufferDoesntOverflow() {
 		LongAdder requestCallCount = new LongAdder();
 		LongAdder totalRequest = new LongAdder();
@@ -1723,8 +1722,9 @@ public void requestBufferDoesntOverflow() {
 		            .expectComplete()
 		            .verify();
 
-		assertThat(requestCallCount.intValue()).isEqualTo(11); //10 elements then the completion
-		assertThat(totalRequest.longValue()).isEqualTo(11L); //ignores the main requests
+		//see same pattern in reactor.core.publisher.FluxBufferPredicateTest.requestBounded
+		assertThat(requestCallCount.intValue()).isEqualTo(9L);
+		assertThat(totalRequest.longValue()).isEqualTo(12L);
 	}
 
 	@Test(timeout = 1000L)

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -1566,10 +1566,9 @@ public MonoSubscriber(CoreSubscriber<? super O> actual) {
 		@Override
 		public void cancel() {
 			O v = value;
-			if (STATE.getAndSet(this, CANCELLED) <= HAS_REQUEST_NO_VALUE) {
-				discard(v);
-			}
 			value = null;
+			STATE.set(this, CANCELLED);
+			discard(v);
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/scheduler/BoundedElasticScheduler.java
Patch:
@@ -773,7 +773,8 @@ else if (this.period != 0) {
 		@Override
 		public void dispose() {
 			if (DISPOSED.compareAndSet(this, 0, 1)) {
-				if (parent.deferredFacades.remove(this) && parent.deferredTaskCap != Integer.MAX_VALUE) {
+				parent.deferredFacades.remove(this);
+				if (parent.deferredTaskCap != Integer.MAX_VALUE) {
 					REMAINING_DEFERRED_TASKS.incrementAndGet(parent);
 				}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java
Patch:
@@ -204,9 +204,8 @@ void trySchedule(long n, Subscription s) {
 
 		@Override
 		public void cancel() {
-			if (Operators.terminate(S, this)) {
-				worker.dispose();
-			}
+			Operators.terminate(S, this);
+			worker.dispose();
 		}
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxFlattenIterableTest.java
Patch:
@@ -670,4 +670,5 @@ public int getRefCount() {
 		public void release() {
 			this.refCount = 0;
 		}
+	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlattenIterable.java
Patch:
@@ -82,19 +82,19 @@ public void subscribe(CoreSubscriber<? super R> actual) {
 			}
 
 			Iterator<? extends R> it;
-
+			boolean itFinite;
 			try {
 				Iterable<? extends R> iter = mapper.apply(v);
-
 				it = iter.iterator();
+				itFinite = FluxIterable.checkFinite(iter);
 			}
 			catch (Throwable ex) {
 				Operators.error(actual, Operators.onOperatorError(ex,
 						actual.currentContext()));
 				return;
 			}
 
-			FluxIterable.subscribe(actual, it);
+			FluxIterable.subscribe(actual, it, itFinite);
 
 			return;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java
Patch:
@@ -51,7 +51,7 @@ public int getPrefetch() {
 
 	@Override
 	public void connect(Consumer<? super Disposable> cancelSupport) {
-		this.source.connect();
+		this.source.connect(cancelSupport);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6033,6 +6033,7 @@ public final Flux<T> name(String name) {
 
 	/**
 	 * Emit only the first item emitted by this {@link Flux}, into a new {@link Mono}.
+	 * If called on an empty {@link Flux}, emits an empty {@link Mono}.
 	 * <p>
 	 * <img class="marble" src="doc-files/marbles/next.svg" alt="">
 	 *

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -403,10 +403,10 @@ public void onNext(T t) {
 					//does the strategy apply? if so, short-circuit the delayError. In any case, don't cancel
 					Throwable e_ = Operators.onNextError(t, e, ctx);
 					if (e_ == null) {
-						return;
+						tryEmitScalar(null);
 					}
+					else if (!delayError || !Exceptions.addThrowable(ERROR, this, e_)) {
 					//now if error mode strategy doesn't apply, let delayError play
-					if (!delayError || !Exceptions.addThrowable(ERROR, this, e_)) {
 						onError(Operators.onOperatorError(s, e_, t, ctx));
 					}
 					Operators.onDiscard(t, ctx);

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -120,7 +120,7 @@ public void cancel() {
 
 		@Override
 		public void setValue(T value) {
-			// value is always in a field
+			this.value = value;
 		}
 	}
 }

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -219,7 +219,7 @@ static <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T
 	 */
 	static <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T>> scenarioSupplier,
 			long n) {
-		return withVirtualTime(scenarioSupplier, VirtualTimeScheduler::getOrSet, n);
+		return withVirtualTime(scenarioSupplier, () -> VirtualTimeScheduler.create(true), n);
 	}
 
 	/**

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -2131,7 +2131,7 @@ public void parallelVerifyWithVtsMutuallyExclusive() {
 		}
 	}
 
-	@Test
+	@Test(timeout = 5000)
 	public void gh783() {
 		int size = 1;
 		Scheduler parallel = Schedulers.newParallel("gh-783");
@@ -2150,7 +2150,7 @@ public void gh783() {
 		            .verifyComplete();
 	}
 
-	@Test
+	@Test(timeout = 5000)
 	public void gh783_deferredAdvanceTime() {
 		int size = 61;
 		Scheduler parallel = Schedulers.newParallel("gh-783");

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1758,7 +1758,7 @@ public final <E> Mono<E> cast(Class<E> clazz) {
 	 * @return a replaying {@link Mono}
 	 */
 	public final Mono<T> cache() {
-		return onAssembly(new MonoProcessor<>(this));
+		return onAssembly(new MonoCacheTime<>(this));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2597,7 +2597,7 @@ public final Flux<T> expandDeep(Function<? super T, ? extends Publisher<? extend
 	 * Recursively expand elements into a graph and emit all the resulting element using
 	 * a breadth-first traversal strategy.
 	 * <p>
-	 * That is: emit the value from this {@link Mono} first, then it each at a first level of
+	 * That is: emit the value from this {@link Mono} first, then expand it at a first level of
 	 * recursion and emit all of the resulting values, then expand all of these at a
 	 * second level and so on...
 	 * <p>
@@ -2637,7 +2637,7 @@ public final Flux<T> expand(Function<? super T, ? extends Publisher<? extends T>
 	 * Recursively expand elements into a graph and emit all the resulting element using
 	 * a breadth-first traversal strategy.
 	 * <p>
-	 * That is: emit the value from this {@link Mono} first, then it each at a first level of
+	 * That is: emit the value from this {@link Mono} first, then expand it at a first level of
 	 * recursion and emit all of the resulting values, then expand all of these at a
 	 * second level and so on...
 	 * <p>

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -144,7 +144,7 @@ public void cancel() {
 			}
 			if (l != null) {
 				s.cancel();
-				Operators.onDiscardMultiple(l, actual.currentContext());
+				discard(l);
 			}
 		}
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -247,7 +247,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		String debugStack = sw.toString();
 
 		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
-				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:228)\n"
+				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:244)\n"
 				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n");
 
 		Iterator<String> lines = seekToBacktrace(debugStack);

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -238,7 +238,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		String debugStack = sw.toString();
 
 		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
-				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:223)\n"
+				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:239)\n"
 				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n");
 		assertThat(debugStack).endsWith("Error has been observed by the following operator(s):\n"
 				+ "\t|_\tParallelFlux.checkpoint ⇢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n\n");

File: reactor-core/src/main/java/reactor/core/Exceptions.java
Patch:
@@ -129,7 +129,7 @@ public static RuntimeException multiple(Throwable... throwables) {
 	 * @see #addThrowable(AtomicReferenceFieldUpdater, Object, Throwable)
 	 */
 	public static RuntimeException multiple(Iterable<Throwable> throwables) {
-		RuntimeException multiple = new RuntimeException("Multiple exceptions");
+		CompositeException multiple = new CompositeException();
 		//noinspection ConstantConditions
 		if (throwables != null) {
 			for (Throwable t : throwables) {
@@ -285,7 +285,7 @@ public static boolean isCancel(@Nullable Throwable t) {
 	 * @return true if given {@link Throwable} is a callback not implemented exception.
 	 */
 	public static boolean isErrorCallbackNotImplemented(@Nullable Throwable t) {
-		return t != null && t.getClass().equals(ErrorCallbackNotImplemented.class);
+		return t instanceof ErrorCallbackNotImplemented;
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1797,6 +1797,9 @@ public final Mono<T> cache(Duration ttl, Scheduler timer) {
 	/**
 	 * Turn this {@link Mono} into a hot source and cache last emitted signal for further
 	 * {@link Subscriber}, with an expiry timeout (TTL) that depends on said signal.
+	 * An TTL of {@link Long#MAX_VALUE} milliseconds is interpreted as indefinite caching of
+	 * the signal (no cache cleanup is scheduled, so the signal is retained as long as this
+	 * {@link Mono} is not garbage collected).
 	 * <p>
 	 * Empty completion and Error will also be replayed according to their respective TTL,
 	 * so transient errors can be "retried" by letting the {@link Function} return

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -761,17 +761,17 @@ void drain() {
 								}
 								catch (Throwable e) {
 									//does the strategy apply? if so, short-circuit the delayError. In any case, don't cancel
-									Throwable e_ = Operators.onNextPollError(v, e,
+									Throwable e_ = Operators.onNextError(v, e,
 											this.ctx);
 									if (e_ == null) {
 										continue;
 									}
 									//now if error mode strategy doesn't apply, let delayError play
-									if (veryEnd && Exceptions.addThrowable(ERROR, this, e)) {
+									if (veryEnd && Exceptions.addThrowable(ERROR, this, e_)) {
 										continue;
 									}
 									else {
-										actual.onError(Operators.onOperatorError(s, e, v,
+										actual.onError(Operators.onOperatorError(s, e_, v,
 												this.ctx));
 										return;
 									}

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6161,7 +6161,7 @@ public final Flux<T> onBackpressureBuffer(int maxSize, Consumer<? super T> onBuf
 	 * Request an unbounded demand and push to the returned {@link Flux}, or park the observed
 	 * elements if not enough demand is requested downstream, within a {@code maxSize}
 	 * limit and for a maximum {@link Duration} of {@code ttl} (as measured on the
-	 * {@link Schedulers#elastic() elastic Scheduler}). Over that limit, oldest
+	 * {@link Schedulers#parallel() parallel Scheduler}). Over that limit, oldest
 	 * elements from the source are dropped.
 	 * <p>
 	 * Elements evicted based on the TTL are passed to a cleanup {@link Consumer}, which
@@ -8920,10 +8920,10 @@ public final Stream<T> toStream(int batchSize) {
 	}
 
 	/**
-	 * Transform this {@link Flux} in order to generate a target {@link Flux}. Unlike {@link #compose(Function)}, the
+	 * Transform this {@link Flux} in order to generate a target {@link Flux}. Unlike {@link #transformDeferred(Function)}, the
 	 * provided function is executed as part of assembly.
 	 * <blockquote><pre>
-	 * Function<Flux, Flux> applySchedulers = flux -> flux.subscribeOn(Schedulers.elastic())
+	 * Function<Flux, Flux> applySchedulers = flux -> flux.subscribeOn(Schedulers.boundedElastic())
 	 *                                                    .publishOn(Schedulers.parallel());
 	 * flux.transform(applySchedulers).map(v -> v * v).subscribe();
 	 * </pre></blockquote>

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayElementTest.java
Patch:
@@ -26,6 +26,7 @@
 
 import org.junit.Test;
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/AbstractReactorTest.java
Patch:
@@ -37,7 +37,7 @@ public abstract class AbstractReactorTest {
 
 	@BeforeClass
 	public static void loadEnv() {
-		ioGroup = Schedulers.newElastic("work");
+		ioGroup = Schedulers.newBoundedElastic(4, Integer.MAX_VALUE, "work");
 		asyncGroup = Schedulers.newParallel("parallel", 4);
 	}
 

File: reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
 import com.pivovarit.function.ThrowingRunnable;

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -33,6 +33,7 @@
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import reactor.core.Fuseable;
 import reactor.core.publisher.DirectProcessor;
@@ -2014,7 +2015,7 @@ public void withInitialContextAndContextAssertionsParents() {
 	//see https://github.com/reactor/reactor-core/issues/959
 	@Test
 	public void assertNextWithSubscribeOnDirectProcessor() {
-		Scheduler scheduler = Schedulers.newElastic("test");
+		Scheduler scheduler = Schedulers.newBoundedElastic(1, 100, "test");
 		DirectProcessor<Integer> processor = DirectProcessor.create();
 		Mono<Integer> doAction = Mono.fromSupplier(() -> 22)
 		                             .doOnNext(processor::onNext)

File: reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -30,8 +30,8 @@
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
+import reactor.core.CorePublisher;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
@@ -47,13 +47,13 @@
  */
 final class BlockingIterable<T> implements Iterable<T>, Scannable {
 
-	final Publisher<? extends T> source;
+	final CorePublisher<? extends T> source;
 
 	final int batchSize;
 
 	final Supplier<Queue<T>> queueSupplier;
 
-	BlockingIterable(Publisher<? extends T> source,
+	BlockingIterable(CorePublisher<? extends T> source,
 			int batchSize,
 			Supplier<Queue<T>> queueSupplier) {
 		if (batchSize <= 0) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeat.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
-import org.reactivestreams.Publisher;
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 
 /**
@@ -59,7 +59,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	static final class RepeatSubscriber<T>
 			extends Operators.MultiSubscriptionSubscriber<T, T> {
 
-		final Publisher<? extends T> source;
+		final CorePublisher<? extends T> source;
 
 		long remaining;
 
@@ -70,7 +70,7 @@ static final class RepeatSubscriber<T>
 
 		long produced;
 
-		RepeatSubscriber(Publisher<? extends T> source, CoreSubscriber<? super T> actual, long remaining) {
+		RepeatSubscriber(CorePublisher<? extends T> source, CoreSubscriber<? super T> actual, long remaining) {
 			super(actual);
 			this.source = source;
 			this.remaining = remaining;

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.BooleanSupplier;
 
-import org.reactivestreams.Publisher;
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 
 /**
@@ -54,7 +54,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	static final class RepeatPredicateSubscriber<T>
 			extends Operators.MultiSubscriptionSubscriber<T, T> {
 
-		final Publisher<? extends T> source;
+		final CorePublisher<? extends T> source;
 
 		final BooleanSupplier predicate;
 
@@ -65,7 +65,7 @@ static final class RepeatPredicateSubscriber<T>
 
 		long produced;
 
-		RepeatPredicateSubscriber(Publisher<? extends T> source,
+		RepeatPredicateSubscriber(CorePublisher<? extends T> source,
 				CoreSubscriber<? super T> actual, BooleanSupplier predicate) {
 			super(actual);
 			this.source = source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
@@ -95,7 +96,7 @@ static final class RepeatWhenMainSubscriber<T>
 
 		final Subscriber<Long> signaller;
 
-		final Publisher<? extends T> source;
+		final CorePublisher<? extends T> source;
 
 		volatile int wip;
 		static final AtomicIntegerFieldUpdater<RepeatWhenMainSubscriber> WIP =
@@ -107,7 +108,7 @@ static final class RepeatWhenMainSubscriber<T>
 
 		RepeatWhenMainSubscriber(CoreSubscriber<? super T> actual,
 				Subscriber<Long> signaller,
-				Publisher<? extends T> source) {
+				CorePublisher<? extends T> source) {
 			super(actual);
 			this.signaller = signaller;
 			this.source = source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetry.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
-import org.reactivestreams.Publisher;
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 
 /**
@@ -56,7 +56,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	static final class RetrySubscriber<T>
 			extends Operators.MultiSubscriptionSubscriber<T, T> {
 
-		final Publisher<? extends T> source;
+		final CorePublisher<? extends T> source;
 
 		long remaining;
 
@@ -67,7 +67,7 @@ static final class RetrySubscriber<T>
 
 		long produced;
 
-		RetrySubscriber(Publisher<? extends T> source, CoreSubscriber<? super T> actual, long remaining) {
+		RetrySubscriber(CorePublisher<? extends T> source, CoreSubscriber<? super T> actual, long remaining) {
 			super(actual);
 			this.source = source;
 			this.remaining = remaining;

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Predicate;
 
-import org.reactivestreams.Publisher;
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 
@@ -57,7 +57,7 @@ public CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super T> act
 	static final class RetryPredicateSubscriber<T>
 			extends Operators.MultiSubscriptionSubscriber<T, T> {
 
-		final Publisher<? extends T> source;
+		final CorePublisher<? extends T> source;
 
 		final Predicate<? super Throwable> predicate;
 
@@ -68,7 +68,7 @@ static final class RetryPredicateSubscriber<T>
 
 		long produced;
 
-		RetryPredicateSubscriber(Publisher<? extends T> source,
+		RetryPredicateSubscriber(CorePublisher<? extends T> source,
 				CoreSubscriber<? super T> actual, Predicate<? super Throwable> predicate) {
 			super(actual);
 			this.source = source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -20,8 +20,8 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
+import reactor.core.CorePublisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
@@ -81,7 +81,7 @@ static final class SubscribeOnSubscriber<T>
 
 		final CoreSubscriber<? super T> actual;
 
-		final Publisher<? extends T> source;
+		final CorePublisher<? extends T> source;
 
 		final Worker  worker;
 		final boolean requestOnSeparateThread;
@@ -108,7 +108,7 @@ static final class SubscribeOnSubscriber<T>
 						Thread.class,
 						"thread");
 
-		SubscribeOnSubscriber(Publisher<? extends T> source, CoreSubscriber<? super T> actual,
+		SubscribeOnSubscriber(CorePublisher<? extends T> source, CoreSubscriber<? super T> actual,
 				Worker worker, boolean requestOnSeparateThread) {
 			this.actual = actual;
 			this.worker = worker;

File: reactor-core/src/test/java/reactor/core/publisher/TailCallSubscribeTest.java
Patch:
@@ -204,7 +204,7 @@ public void repeat() throws Exception {
 						tuple(Thread.class.getName(), "getStackTrace"),
 						tuple(stackCapturingPublisher.getClass().getName(), "subscribe"),
 						tuple(FluxSource.class.getName(), "subscribe"),
-						tuple(Flux.class.getName(), "subscribe"),
+						tuple(InternalFluxOperator.class.getName(), "subscribe"),
 						tuple(FluxRepeat.RepeatSubscriber.class.getName(), "resubscribe"),
 						tuple(FluxRepeat.RepeatSubscriber.class.getName(), "onComplete"),
 						tuple(FluxRepeat.class.getName(), "subscribeOrReturn"),
@@ -229,7 +229,7 @@ public void retry() throws Exception {
 						tuple(Thread.class.getName(), "getStackTrace"),
 						tuple(stackCapturingPublisher.getClass().getName(), "subscribe"),
 						tuple(FluxSource.class.getName(), "subscribe"),
-						tuple(Flux.class.getName(), "subscribe"),
+						tuple(InternalFluxOperator.class.getName(), "subscribe"),
 						tuple(FluxRetry.RetrySubscriber.class.getName(), "resubscribe"),
 						tuple(FluxRetry.class.getName(), "subscribeOrReturn"),
 						tuple(Flux.class.getName(), "subscribe"),

File: reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java
Patch:
@@ -193,7 +193,7 @@ public void scanName() {
 					.is(SchedulersTest.CACHED_SCHEDULER);
 			assertThat(Scannable.from(cached).scan(Scannable.Attr.NAME))
 					.as("default elastic()")
-					.isEqualTo("elastic(\"elastic\")");
+					.isEqualTo("Schedulers.elastic()");
 
 			assertThat(Scannable.from(workerWithNamedFactory).scan(Scannable.Attr.NAME))
 					.as("workerWithNamedFactory")

File: reactor-core/src/test/java/reactor/core/scheduler/ParallelSchedulerTest.java
Patch:
@@ -166,7 +166,7 @@ public void scanName() {
 					.is(SchedulersTest.CACHED_SCHEDULER);
 			assertThat(Scannable.from(cached).scan(Scannable.Attr.NAME))
 					.as("default parallel()")
-					.isEqualTo("parallel(" + Schedulers.DEFAULT_POOL_SIZE + ",\"parallel\")");
+					.isEqualTo("Schedulers.parallel()");
 
 			assertThat(Scannable.from(workerWithNamedFactory).scan(Scannable.Attr.NAME))
 					.as("workerWithNamedFactory")

File: reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java
Patch:
@@ -152,7 +152,7 @@ public void scanName() {
 					.is(SchedulersTest.CACHED_SCHEDULER);
 			assertThat(Scannable.from(cached).scan(Scannable.Attr.NAME))
 					.as("default single()")
-					.isEqualTo("single(\"single\")");
+					.isEqualTo("Schedulers.single()");
 
 			assertThat(Scannable.from(workerWithNamedFactory).scan(Scannable.Attr.NAME))
 					.as("workerWithNamedFactory")

File: reactor-core/src/test/java/reactor/core/ExceptionsTest.java
Patch:
@@ -296,7 +296,7 @@ public void failWithRejectedNormalWraps() {
 	}
 
 	@Test
-	public void failWithRejectedSingletonReeWraps() {
+	public void failWithRejectedSingletonREEWraps() {
 		Throwable test = REJECTED_EXECUTION;
 		assertThat(Exceptions.failWithRejected(test))
 				.isInstanceOf(Exceptions.ReactorRejectedExecutionException.class)
@@ -305,7 +305,7 @@ public void failWithRejectedSingletonReeWraps() {
 	}
 
 	@Test
-	public void failWithRejectedNormalReeWraps() {
+	public void failWithRejectedNormalREEWraps() {
 		Throwable test = new RejectedExecutionException("boom");
 		assertThat(Exceptions.failWithRejected(test))
 				.isInstanceOf(Exceptions.ReactorRejectedExecutionException.class)
@@ -314,7 +314,7 @@ public void failWithRejectedNormalReeWraps() {
 	}
 
 	@Test
-	public void failWithRejectedReactorReeNoOp() {
+	public void failWithRejectedReactorREENoOp() {
 		Throwable test = new Exceptions.ReactorRejectedExecutionException("boom", REJECTED_EXECUTION);
 		assertThat(Exceptions.failWithRejected(test))
 				.isSameAs(test)

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java
Patch:
@@ -49,7 +49,7 @@ public int getPrefetch() {
 
 	@Override
 	public void connect(Consumer<? super Disposable> cancelSupport) {
-		this.source.connect();
+		this.source.connect(cancelSupport);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsingWhen.java
Patch:
@@ -386,7 +386,8 @@ public void onComplete() {
 				}
 				catch (Throwable e) {
 					Throwable _e = Operators.onOperatorError(e, actual.currentContext());
-					actual.onError(_e);
+					//give a chance for the Mono implementation to discard the recorded value
+					deferredError(_e);
 					return;
 				}
 
@@ -419,7 +420,6 @@ public void onSubscribe(Subscription s) {
 				}
 			}
 		}
-
 	}
 
 	static final class UsingWhenConditionalSubscriber<T, S>

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingWhenTest.java
Patch:
@@ -1183,7 +1183,6 @@ public Flux<String> data() {
 		}
 
 		public Flux<Integer> commit() {
-			System.out.println("commit");
 			this.commitProbe = PublisherProbe.of(
 					Flux.just(3, 2, 1)
 					    .log("commit method used", level, SignalType.ON_NEXT, SignalType.ON_COMPLETE));

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2865,9 +2865,8 @@ public final <V> Flux<List<T>> bufferUntilChanged(Function<? super T, ? extends
 	 */
 	public final <V> Flux<List<T>> bufferUntilChanged(Function<? super T, ? extends V> keySelector,
 			BiPredicate<? super V, ? super V> keyComparator) {
-		Predicate<? super T> changed = new FluxBufferPredicate.ChangedPredicate<T, V>(keySelector,
-				keyComparator);
-		return bufferUntil(changed, true);
+		return Flux.defer(() -> bufferUntil(new FluxBufferPredicate.ChangedPredicate<T, V>(keySelector,
+				keyComparator), true));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/BlockingOptionalMonoSubscriber.java
Patch:
@@ -45,7 +45,7 @@
 /**
  * Blocks assuming the upstream is a Mono, until it signals its value or completes.
  * Similar to {@link BlockingSingleSubscriber}, except blockGet methods return an {@link Optional}
- * and thus aren't nullable..
+ * and thus aren't nullable.
  *
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFlux.java
Patch:
@@ -104,8 +104,9 @@ public final Disposable connect() {
 	 * can be used for disconnecting.
 	 *
 	 * <p>The call should be idempotent in respect of connecting the first
-	 * and subsequent times. In addition the disconnection should be also tied
-	 * to a particular connection (so two different connection can't disconnect the other).
+	 * and subsequent times. In addition, the disconnection should be tied
+	 * to a particular connection (so two different connections can't disconnect the
+	 * other).
 	 *
 	 * @param cancelSupport the callback is called with a Disposable instance that can
 	 * be called to disconnect the source, even synchronously.

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -355,7 +355,8 @@ public Stream<? extends Scannable> inners() {
 
 	/**
 	 * Drain is a hot replication of the current buffer delivered if supported. Since it is hot there might be no
-	 * guarantee to see a end if the buffer keeps replenishing due to concurrent producing.
+	 * guarantee to see an end if the buffer keeps replenishing due to concurrent
+	 * producing.
 	 *
 	 * @return a {@link Flux} sequence possibly unbounded of incoming buffered values or empty if not supported.
 	 */

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -38,7 +38,7 @@
 import reactor.util.context.Context;
 
 /**
- * buffers elements into possibly overlapping buffers whose boundaries are determined
+ * Buffers elements into possibly overlapping buffers whose boundaries are determined
  * by a start Publisher's element and a signal of a derived Publisher
  *
  * @param <T> the source value type

File: reactor-core/src/main/java/reactor/core/publisher/FluxDetach.java
Patch:
@@ -26,7 +26,7 @@
  * Detaches the both the child Subscriber and the Subscription on
  * termination or cancellation.
  * <p>This should help with odd retention scenarios when running
- * wit non Rx mentality based Publishers.
+ * with non Rx mentality based Publishers.
  * 
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFirst.java
Patch:
@@ -27,7 +27,7 @@
  * {@link CoreSubscriber}.
  *
  * <p>
- * Note that any exception thrown by the hook short circuit the subscription process and
+ * Note that any exceptions thrown by the hook short circuit the subscription process and
  * are forwarded to the {@link Subscriber}'s {@link Subscriber#onError(Throwable)} method.
  *
  * @param <T> the value type

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFirstFuseable.java
Patch:
@@ -28,7 +28,7 @@
  * {@link CoreSubscriber}.
  *
  * <p>
- * Note that any exception thrown by the hook short circuit the subscription process and
+ * Note that any exceptions thrown by the hook short circuit the subscription process and
  * are forwarded to the {@link Subscriber}'s {@link Subscriber#onError(Throwable)} method.
  *
  * @param <T> the value type

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Represents an empty publisher which only calls onSubscribe and onComplete.
  * <p>
- * This Publisher is effectively stateless and only a single instance any.
+ * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */

File: reactor-core/src/main/java/reactor/core/publisher/FluxFromMonoOperator.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * A decorating {@link Flux} {@link Publisher} that exposes {@link Flux} API over an
- * arbitrary {@link Publisher} Useful to create operators which return a {@link Flux}.
+ * arbitrary {@link Publisher}. Useful to create operators which return a {@link Flux}.
  *
  * @param <I> delegate {@link Publisher} type
  * @param <O> produced type

File: reactor-core/src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -19,7 +19,7 @@
 import reactor.core.CoreSubscriber;
 
 /**
- * Represents an never publisher which only calls onSubscribe.
+ * Represents a never publisher which only calls onSubscribe.
  * <p>
  * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.

File: reactor-core/src/main/java/reactor/core/publisher/FluxOperator.java
Patch:
@@ -27,7 +27,7 @@
 
 /**
  * A decorating {@link Flux} {@link Publisher} that exposes {@link Flux} API over an
- * arbitrary {@link Publisher} Useful to create operators which return a {@link Flux}.
+ * arbitrary {@link Publisher}. Useful to create operators which return a {@link Flux}.
  *
  * @param <I> delegate {@link Publisher} type
  * @param <O> produced type

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -32,8 +32,8 @@
 import reactor.util.context.Context;
 
 /**
- * retries a source when a companion sequence signals
- * an item in response to the main's error signal
+ * Retries a source when a companion sequence signals
+ * an item in response to the main's error signal.
  * <p>
  * <p>If the companion sequence signals when the main source is active, the repeat
  * attempt is suppressed and any terminal signal will terminate the main source with the same signal immediately.

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Represents an empty publisher which only calls onSubscribe and onComplete.
  * <p>
- * This Publisher is effectively stateless and only a single instance any.
+ * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -45,7 +45,7 @@
 import static reactor.core.Fuseable.NONE;
 
 /**
- * An helper to support "Operator" writing, handle noop subscriptions, validate request
+ * A helper to support "Operator" writing, handle noop subscriptions, validate request
  * size and to cap concurrent additive operations to Long.MAX_VALUE,
  * which is generic to {@link Subscription#request(long)} handling.
  *

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -114,7 +114,7 @@ public int getPrefetch() {
 	@Override
 	public void subscribe(CoreSubscriber<? super R> actual) {
 
-		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false)) {
+		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -86,7 +86,8 @@ final class FluxMergeSequential<T, R> extends FluxOperator<T, R> {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super R> actual) {
-		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false)) {
+		//for now mergeSequential doesn't support onErrorContinue, so the scalar version shouldn't either
+		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, false)) {
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -77,7 +77,8 @@ public int getPrefetch() {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super R> actual) {
-		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false)) {
+		//for now switchMap doesn't support onErrorContinue, so the scalar version shouldn't either
+		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, false)) {
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -49,8 +49,8 @@ final class MonoFlatMap<T, R> extends MonoOperator<T, R> implements Fuseable {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super R> actual) {
-
-		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, true)) {
+		//for now Mono in general doesn't support onErrorContinue, so the scalar version shouldn't either
+		if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, true, false)) {
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -759,7 +759,7 @@ public static <T> Throwable onNextInnerError(Throwable error, Context context, S
 	 * terminal and cancelled the subscription, null if not.
 	 */
 	@Nullable
-	public static <T> RuntimeException onNextPollError(T value, Throwable error, Context context) {
+	public static <T> RuntimeException onNextPollError(@Nullable T value, Throwable error, Context context) {
 		error = unwrapOnNextError(error);
 		OnNextFailureStrategy strategy = onNextErrorStrategy(context);
 		if (strategy.test(error, value)) {

File: reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java
Patch:
@@ -24,13 +24,15 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
+import reactor.util.context.Context;
 
 /**
  * A simple base class for a {@link Subscriber} implementation that lets the user
  * perform a {@link #request(long)} and {@link #cancel()} on it directly. As the targeted
  * use case is to manually handle requests, the {@link #hookOnSubscribe(Subscription)} and
  * {@link #hookOnNext(Object)} hooks are expected to be implemented, but they nonetheless
- * default to an unbounded request at subscription time.
+ * default to an unbounded request at subscription time. If you need to define a {@link Context}
+ * for this {@link BaseSubscriber}, simply override its {@link #currentContext()} method.
  * <p>
  * Override the other optional hooks {@link #hookOnComplete()},
  * {@link #hookOnError(Throwable)} and {@link #hookOnCancel()}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelayUntilTest.java
Patch:
@@ -201,7 +201,7 @@ public void immediateCancel() {
 
 		Disposable s = Flux.just("foo", "bar")
 		                   .delayUntil(v -> Mono.just(1))
-		                   .subscribe(value::set, error::set, () -> {}, Subscription::cancel);
+		                   .subscribeWith(new LambdaSubscriber<>(value::set, error::set, () -> {}, Subscription::cancel));
 
 		assertThat(value.get()).isNull();
 		assertThat(error.get()).isNull(); //would be a NPE if trigger array wasn't pre-initialized

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -247,7 +247,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		String debugStack = sw.toString();
 
 		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
-				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:227)\n"
+				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:228)\n"
 				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n");
 
 		Iterator<String> lines = seekToBacktrace(debugStack);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -57,7 +57,7 @@
  * cover a subset of the original Publisher's data. {@link Flux#parallel()} is a
  * convenient shortcut to achieve that on a {@link Flux}.
  * <p>
- * Use {@link #runOn} to introduce where each 'rail' should run on thread-vise.
+ * Use {@link #runOn} to introduce where each 'rail' should run on thread-wise.
  * <p>
  * Use {@link #sequential)} to merge the sources back into a single {@link Flux}.
  * <p>

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -44,6 +44,7 @@
  *
  * @author Stephane Maldini
  */
+@SuppressWarnings("deprecation")
 abstract class EventLoopProcessor<IN> extends FluxProcessor<IN, IN>
 		implements Runnable {
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -305,6 +305,7 @@ public void dispose() {
 		}
 
 		void disconnectAction() {
+			@SuppressWarnings("unchecked")
 			PubSubInner<T>[] inners = SUBSCRIBERS.getAndSet(this, CANCELLED);
 			if (inners.length > 0) {
 				queue.clear();

File: reactor-core/src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -70,6 +70,7 @@
  * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
  */
 @Deprecated
+@SuppressWarnings("deprecation")
 public final class TopicProcessor<E> extends EventLoopProcessor<E>  {
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/WorkQueueProcessor.java
Patch:
@@ -67,6 +67,7 @@
  * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
  */
 @Deprecated
+@SuppressWarnings("deprecation")
 public final class WorkQueueProcessor<E> extends EventLoopProcessor<E> {
 
 	/**

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java
Patch:
@@ -551,7 +551,7 @@ public boolean tryOnNext(Boolean v) {
 		                          .matches(s -> s.get() == Boolean.TRUE);
 		assertThat(signals.get(1)).matches(Signal::isOnComplete);
 
-		List<Boolean> actualTryNext = ((FluxPeekFuseableTest.ConditionalAssertSubscriber<Boolean>) actual).next;
+		List<Boolean> actualTryNext = actual.next;
 		assertThat(actualTryNext).hasSize(2);
 		assertThat(actualTryNext.get(0)).isTrue();
 		assertThat(actualTryNext.get(1)).isFalse();

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -217,7 +217,7 @@ public void parallelFluxCheckpointEmpty() {
 		StringWriter sw = new StringWriter();
 		Flux<Integer> tested = Flux.range(1, 10)
 		                         .parallel(2)
-		                         .composeGroup(g -> g.map(i -> (Integer) null))
+		                         .transformGroups(g -> g.map(i -> (Integer) null))
 		                         .checkpoint()
 		                         .sequential()
 		                         .doOnError(t -> t.printStackTrace(new PrintWriter(sw)));
@@ -236,7 +236,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		int baseline = getBaseline();
 		Flux<Integer> tested = Flux.range(1, 10)
 		                           .parallel(2)
-		                           .composeGroup(g -> g.map(i -> (Integer) null))
+		                           .transformGroups(g -> g.map(i -> (Integer) null))
 		                           .checkpoint("descriptionCorrelation1234", true)
 		                           .sequential()
 		                           .doOnError(t -> t.printStackTrace(new PrintWriter(sw)));
@@ -264,7 +264,7 @@ public void parallelFluxCheckpointDescriptionIsLight() {
 		StringWriter sw = new StringWriter();
 		Flux<Integer> tested = Flux.range(1, 10)
 		                           .parallel(2)
-		                           .composeGroup(g -> g.map(i -> (Integer) null))
+		                           .transformGroups(g -> g.map(i -> (Integer) null))
 		                           .checkpoint("light checkpoint identifier")
 		                           .sequential()
 		                           .doOnError(t -> t.printStackTrace(new PrintWriter(sw)));

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingWhenTest.java
Patch:
@@ -785,7 +785,7 @@ public void contextPropagationOnRollback(Mono<String> source) {
 		    .as(StepVerifier::create)
 		    .expectAccessibleContext().contains(String.class, "contextual")
 		    .then()
-		    .verifyError(ArithmeticException.class);
+		    .verifyErrorMessage("boom");
 
 		testResource.commitProbe.assertWasNotSubscribed();
 		testResource.rollbackProbe.assertWasNotSubscribed();
@@ -1280,12 +1280,12 @@ private Object[] sourcesContextError() {
 						.subscriberContext()
 						.map(it -> it.get(String.class))
 						.hide()
-						.map(it -> { if (it.length() / 0 == 1) return it; return it + "foo"; })
+						.map(it -> { throw new IllegalStateException("boom"); })
 				},
 				new Object[] { Mono
 						.subscriberContext()
 						.map(it -> it.get(String.class))
-						.map(it -> { if (it.length() / 0 == 1) return it; return it + "foo"; })
+						.map(it -> { throw new IllegalStateException("boom"); })
 				}
 		};
 	}

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -725,9 +725,10 @@ protected void hookOnNext(Object value) {
 
 	@Test
 	public void convertConditionalToConditionalShouldReturnTheSameInstance() {
-		Fuseable.ConditionalSubscriber original = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		@SuppressWarnings("unchecked")
+		Fuseable.ConditionalSubscriber<String> original = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 
 		Assertions.assertThat(Operators.toConditionalSubscriber(original))
-		          .isEqualTo(original);
+		          .isSameAs(original);
 	}
 }

File: reactor-test/src/main/java/reactor/test/ValueFormatters.java
Patch:
@@ -315,7 +315,7 @@ else if (extractors == null) {
 			}
 			else {
 				converted = null;
-				for (Extractor extractor : extractors) {
+				for (Extractor<?> extractor : extractors) {
 					if (extractor.test(arg)) {
 						converted = extractor.apply(arg, toStringConverter);
 						break;

File: reactor-test/src/test/java/reactor/test/ValueFormattersTest.java
Patch:
@@ -293,6 +293,7 @@ public void arrayConvertsContentMatching() {
 				.isEqualTo("[1, 2.0, foo, bar]");
 	}
 
+	@SuppressWarnings("unchecked")
 	@Test
 	public void arrayOnNonArrayTypeFails() {
 		Class fakeArrayClass = String.class;

File: reactor-core/src/main/java/reactor/core/publisher/MonoDematerialize.java
Patch:
@@ -28,6 +28,6 @@ final class MonoDematerialize<T> extends MonoOperator<Signal<T>, T> {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		source.subscribe(new FluxDematerialize.DematerializeSubscriber<>(actual));
+		source.subscribe(new FluxDematerialize.DematerializeSubscriber<>(actual, true));
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java
Patch:
@@ -62,7 +62,7 @@ public Publisher<Integer> createPublisher(long elements) {
 
 	@Override
 	public Publisher<Integer> createFailedPublisher() {
-		return Flux.<Integer>error(new Exception("oops"))
+		return Flux.<Integer>error(new Exception("boom"))
 				.transform(this::transformFlux);
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -205,7 +205,7 @@ public void cancelComposes2() {
 	public void pairWise() {
 		AssertSubscriber<Tuple2<Integer, Integer>> ts = AssertSubscriber.create();
 
-		range(1, 9).composeNow(o -> zip(o, o.skip(1)))
+		range(1, 9).transform(o -> zip(o, o.skip(1)))
 		           .subscribe(ts);
 
 		ts.assertValues(Tuples.of(1, 2),

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -674,7 +674,7 @@ public void shouldPropagateOnCompleteWithMergedElementsCorrectly() {
     @Test
     public void shouldPropagateErrorCorrectly() {
         Flux<String> switchTransformed = Flux.error(new RuntimeException("hello"))
-                                             .composeNow(flux -> new FluxSwitchOnFirst<>(
+                                             .transform(flux -> new FluxSwitchOnFirst<>(
                                                      flux,
                                                      (first, innerFlux) -> innerFlux.map(
                                                              String::valueOf)));

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -248,8 +248,8 @@ public void subscribe(Subscriber<? super Integer> s) {
 	}
 
 	@Test
-	public void composeNow() {
-		StepVerifier.create(Mono.just(1).composeNow(m -> Flux.just(1, 2, 3)))
+	public void transform() {
+		StepVerifier.create(Mono.just(1).transform(m -> Flux.just(1, 2, 3)))
 	                .expectNext(1)
 	                .verifyComplete();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -651,7 +651,7 @@ public void asChangesParallelism() {
 	@Test
 	public void transformChangesPrefetch() {
 		assertThat(ParallelFlux.from(Flux.range(1, 10), 3, 12, Queues.small())
-		                       .composeNow(pf -> pf.runOn(Schedulers.parallel(), 3)
+		                       .transform(pf -> pf.runOn(Schedulers.parallel(), 3)
 		                                          .log()
 		                                          .hide())
 		                       .getPrefetch())

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -894,7 +894,7 @@ public void testParallelAsyncStream2() throws InterruptedException {
 			final String source = "ASYNC_TEST " + i;
 
 			Flux.just(source)
-			    .composeNow(operationStream -> operationStream.publishOn(asyncGroup)
+			    .transform(operationStream -> operationStream.publishOn(asyncGroup)
 			                                          .delayElements(Duration.ofMillis(100))
 			                                          .map(s -> s + " MODIFIED")
 			                                          .map(s -> {

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java
Patch:
@@ -48,22 +48,22 @@ public Publisher<Integer> createPublisher(long elements) {
 			return Flux.range(1, (int) elements)
 			           .filter(integer -> true)
 			           .map(integer -> integer)
-			           .composeNow(this::transformFlux);
+			           .transform(this::transformFlux);
 		}
 		else {
 			final Random random = new Random();
 
 			return Mono.fromCallable(random::nextInt)
 			           .repeat()
 			           .map(Math::abs)
-			           .composeNow(this::transformFlux);
+			           .transform(this::transformFlux);
 		}
 	}
 
 	@Override
 	public Publisher<Integer> createFailedPublisher() {
 		return Flux.<Integer>error(new Exception("oops"))
-				.composeNow(this::transformFlux);
+				.transform(this::transformFlux);
 	}
 
 	protected void monitorThreadUse(Object val) {

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -163,7 +163,7 @@ public void advancedComposedNow() {
 
 		Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
 		    .doOnNext(System.out::println)
-		    .composeNow(filterAndMap)
+		    .transform(filterAndMap)
 		    .subscribe(d -> System.out.println("Subscriber to Transformed MapAndFilter: "+d));
 	}
 
@@ -182,7 +182,7 @@ public void advancedComposedDefer() {
 		Flux<String> composedFlux =
 				Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
 				    .doOnNext(System.out::println)
-				    .composeLater(filterAndMap);
+				    .transformDeferred(filterAndMap);
 
 		composedFlux.subscribe(d -> System.out.println("Subscriber 1 to Composed MapAndFilter :"+d));
 		composedFlux.subscribe(d -> System.out.println("Subscriber 2 to Composed MapAndFilter: "+d));

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -156,6 +156,9 @@ public void success(@Nullable T value) {
 							actual.onNext(value);
 							actual.onComplete();
 						}
+						catch (Throwable t) {
+							actual.onError(t);
+						}
 						finally {
 							disposeResource(false);
 						}

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java
Patch:
@@ -223,8 +223,8 @@ final public void request(long l) {
 	 */
 	static final String METER_SUBSCRIBED     = "reactor.subscribed";
 	/**
-	 * Meter that times the duration between the subscription and the sequence's terminal event. The timer is also using
-	 * the "status" tag to determine which kind of event terminated the sequence.
+	 * Meter that times the duration elapsed between a subscription and the termination or cancellation of the sequence.
+	 * A status tag is added to specify what event caused the timer to end (onComplete, onError, cancel).
 	 */
 	static final String METER_FLOW_DURATION  = "reactor.flow.duration";
 	/**

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -205,7 +205,7 @@ public void cancelComposes2() {
 	public void pairWise() {
 		AssertSubscriber<Tuple2<Integer, Integer>> ts = AssertSubscriber.create();
 
-		range(1, 9).transform(o -> zip(o, o.skip(1)))
+		range(1, 9).composeNow(o -> zip(o, o.skip(1)))
 		           .subscribe(ts);
 
 		ts.assertValues(Tuples.of(1, 2),

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -674,7 +674,7 @@ public void shouldPropagateOnCompleteWithMergedElementsCorrectly() {
     @Test
     public void shouldPropagateErrorCorrectly() {
         Flux<String> switchTransformed = Flux.error(new RuntimeException("hello"))
-                                             .transform(flux -> new FluxSwitchOnFirst<>(
+                                             .composeNow(flux -> new FluxSwitchOnFirst<>(
                                                      flux,
                                                      (first, innerFlux) -> innerFlux.map(
                                                              String::valueOf)));

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -248,8 +248,8 @@ public void subscribe(Subscriber<? super Integer> s) {
 	}
 
 	@Test
-	public void transform() {
-		StepVerifier.create(Mono.just(1).transform(m -> Flux.just(1, 2, 3)))
+	public void composeNow() {
+		StepVerifier.create(Mono.just(1).composeNow(m -> Flux.just(1, 2, 3)))
 	                .expectNext(1)
 	                .verifyComplete();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -651,7 +651,7 @@ public void asChangesParallelism() {
 	@Test
 	public void transformChangesPrefetch() {
 		assertThat(ParallelFlux.from(Flux.range(1, 10), 3, 12, Queues.small())
-		                       .transform(pf -> pf.runOn(Schedulers.parallel(), 3)
+		                       .composeNow(pf -> pf.runOn(Schedulers.parallel(), 3)
 		                                          .log()
 		                                          .hide())
 		                       .getPrefetch())

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -894,7 +894,7 @@ public void testParallelAsyncStream2() throws InterruptedException {
 			final String source = "ASYNC_TEST " + i;
 
 			Flux.just(source)
-			    .transform(operationStream -> operationStream.publishOn(asyncGroup)
+			    .composeNow(operationStream -> operationStream.publishOn(asyncGroup)
 			                                          .delayElements(Duration.ofMillis(100))
 			                                          .map(s -> s + " MODIFIED")
 			                                          .map(s -> {

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java
Patch:
@@ -48,22 +48,22 @@ public Publisher<Integer> createPublisher(long elements) {
 			return Flux.range(1, (int) elements)
 			           .filter(integer -> true)
 			           .map(integer -> integer)
-			           .transform(this::transformFlux);
+			           .composeNow(this::transformFlux);
 		}
 		else {
 			final Random random = new Random();
 
 			return Mono.fromCallable(random::nextInt)
 			           .repeat()
 			           .map(Math::abs)
-			           .transform(this::transformFlux);
+			           .composeNow(this::transformFlux);
 		}
 	}
 
 	@Override
 	public Publisher<Integer> createFailedPublisher() {
 		return Flux.<Integer>error(new Exception("oops"))
-				.transform(this::transformFlux);
+				.composeNow(this::transformFlux);
 	}
 
 	protected void monitorThreadUse(Object val) {

File: reactor-core/src/test/java/reactor/guide/GuideDebuggingExtraTests.java
Patch:
@@ -45,14 +45,14 @@ public void debuggingActivatedWithDeepTraceback() {
 
 			String debugStack = sw.toString();
 
-			assertThat(debugStack)
+			assertThat(debugStack.substring(0, debugStack.indexOf("Stack trace:")))
 					.endsWith("Error has been observed at the following site(s):\n"
 							+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)\n"
 							+ "\t|_       Flux.map ⇢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)\n"
 							+ "\t|_    Flux.filter ⇢ at reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)\n"
 							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)\n"
 							+ "\t|_   Flux.elapsed ⇢ at reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)\n"
-							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)\n\n");
+							+ "\t|_ Flux.transform ⇢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)\n");
 		}
 		finally {
 			Hooks.resetOnOperatorDebug();

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -980,7 +980,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single ⇢ at reactor.guide.GuideTests.scatterAndGather(GuideTests.java:944)\n");
+						.hasMessageContaining("Flux.single ⇢ at reactor.guide.GuideTests.scatterAndGather(GuideTests.java:944)\n");
 			});
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java
Patch:
@@ -144,7 +144,6 @@ final public void cancel() {
 		@Override
 		final public void onComplete() {
 			if (done) {
-				recordMalformed(commonTags, registry);
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java
Patch:
@@ -105,7 +105,6 @@ final public void cancel() {
 		@Override
 		final public void onComplete() {
 			if (done) {
-				FluxMetrics.recordMalformed(commonTags, registry);
 				return;
 			}
 			done = true;
@@ -132,7 +131,10 @@ final public void onNext(T t) {
 				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
+			done = true;
+			FluxMetrics.recordOnComplete(commonTags, registry, subscribeToTerminateSample);
 			actual.onNext(t);
+			actual.onComplete();
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java
Patch:
@@ -127,11 +127,10 @@ public T poll() {
 			}
 			try {
 				T v = qs.poll();
-
-				if (v == null && this.mode == SYNC) {
-					//this is also a complete event
+				if (!done && (v != null || mode == SYNC)) {
 					FluxMetrics.recordOnComplete(commonTags, registry, subscribeToTerminateSample);
 				}
+				done = true;
 				return v;
 			}
 			catch (Throwable e) {

File: reactor-core/src/test/java/reactor/core/publisher/MonoMetricsFuseableTest.java
Patch:
@@ -159,7 +159,7 @@ public void queuePollSyncTracksOnComplete() {
 		                          .timer();
 
 		assertThat(terminationTimer).isNotNull();
-		assertThat(terminationTimer.max(TimeUnit.MILLISECONDS)).as("terminate max delay").isEqualTo(323);
+		assertThat(terminationTimer.max(TimeUnit.MILLISECONDS)).as("terminate max delay").isEqualTo(200);
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/util/context/Context5.java
Patch:
@@ -39,6 +39,8 @@ final class Context5 implements Context {
 			Object key3, Object value3,
 			Object key4, Object value4,
 			Object key5, Object value5) {
+		//TODO merge null check and duplicate check in the util method
+		Context4.checkKeys(key1, key2, key3, key4, key5);
 		this.key1 = Objects.requireNonNull(key1, "key1");
 		this.value1 = Objects.requireNonNull(value1, "value1");
 		this.key2 = Objects.requireNonNull(key2, "key2");

File: reactor-core/src/main/java/reactor/util/context/Context1.java
Patch:
@@ -26,8 +26,8 @@ final class Context1 implements Context, Map.Entry<Object, Object> {
 	final Object value;
 
 	Context1(Object key, Object value) {
-		this.key = key;
-		this.value = value;
+		this.key = Objects.requireNonNull(key, "key");
+		this.value = Objects.requireNonNull(value, "value");
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -846,7 +846,7 @@ public static <T> Flux<T> error(Throwable error) {
 	 *
 	 * @return a new failing {@link Flux}
 	 */
-	public static <T> Flux<T> error(Supplier<Throwable> errorSupplier) {
+	public static <T> Flux<T> error(Supplier<? extends Throwable> errorSupplier) {
 		return onAssembly(new FluxErrorSupplied<>(errorSupplier));
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorSupplied.java
Patch:
@@ -49,9 +49,9 @@
  */
 final class FluxErrorSupplied<T> extends Flux<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
 
-	final Supplier<Throwable> errorSupplier;
+	final Supplier<? extends Throwable> errorSupplier;
 
-	FluxErrorSupplied(Supplier<Throwable> errorSupplier) {
+	FluxErrorSupplied(Supplier<? extends Throwable> errorSupplier) {
 		this.errorSupplier = Objects.requireNonNull(errorSupplier, "errorSupplier");
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -275,7 +275,7 @@ public static <T> Mono<T> error(Throwable error) {
 	 *
 	 * @return a failing {@link Mono}
 	 */
-	public static <T> Mono<T> error(Supplier<Throwable> errorSupplier) {
+	public static <T> Mono<T> error(Supplier<? extends Throwable> errorSupplier) {
 		return onAssembly(new MonoErrorSupplied<>(errorSupplier));
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -47,9 +47,9 @@
  */
 final class MonoErrorSupplied<T> extends Mono<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
 
-	final Supplier<Throwable> errorSupplier;
+	final Supplier<? extends Throwable> errorSupplier;
 
-	MonoErrorSupplied(Supplier<Throwable> errorSupplier) {
+	MonoErrorSupplied(Supplier<? extends Throwable> errorSupplier) {
 		this.errorSupplier = Objects.requireNonNull(errorSupplier, "errorSupplier");
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferStrategy.java
Patch:
@@ -51,7 +51,7 @@ final class FluxOnBackpressureBufferStrategy<O> extends FluxOperator<O, O> {
 		this.bufferSize = bufferSize;
 		this.onBufferOverflow = onBufferOverflow;
 		this.bufferOverflowStrategy = bufferOverflowStrategy;
-		this.delayError = onBufferOverflow != null;
+		this.delayError = onBufferOverflow != null || bufferOverflowStrategy == BufferOverflowStrategy.ERROR;
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java
Patch:
@@ -57,12 +57,12 @@ public Worker createWorker() {
 
 	@Override
 	public Disposable schedule(Runnable task) {
-		return Schedulers.directSchedule(executor, task, 0L, TimeUnit.MILLISECONDS);
+		return Schedulers.directSchedule(executor, task, null, 0L, TimeUnit.MILLISECONDS);
 	}
 
 	@Override
 	public Disposable schedule(Runnable task, long delay, TimeUnit unit) {
-		return Schedulers.directSchedule(executor, task, delay, unit);
+		return Schedulers.directSchedule(executor, task, null, delay, unit);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -151,12 +151,12 @@ ScheduledExecutorService pick() {
 
     @Override
     public Disposable schedule(Runnable task) {
-	    return Schedulers.directSchedule(pick(), task, 0L, TimeUnit.MILLISECONDS);
+	    return Schedulers.directSchedule(pick(), task, null, 0L, TimeUnit.MILLISECONDS);
     }
 
     @Override
     public Disposable schedule(Runnable task, long delay, TimeUnit unit) {
-	    return Schedulers.directSchedule(pick(), task, delay, unit);
+	    return Schedulers.directSchedule(pick(), task, null, delay, unit);
     }
 
     @Override

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -876,10 +876,11 @@ void _dispose() {
 
 	static Disposable directSchedule(ScheduledExecutorService exec,
 			Runnable task,
+			@Nullable Disposable parent,
 			long delay,
 			TimeUnit unit) {
 		task = onSchedule(task);
-		SchedulerTask sr = new SchedulerTask(task);
+		SchedulerTask sr = new SchedulerTask(task, parent);
 		Future<?> f;
 		if (delay <= 0L) {
 			f = exec.submit((Callable<?>) sr);

File: reactor-core/src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -115,12 +115,12 @@ public void dispose() {
 
 	@Override
 	public Disposable schedule(Runnable task) {
-		return Schedulers.directSchedule(executor, task, 0L, TimeUnit.MILLISECONDS);
+		return Schedulers.directSchedule(executor, task, null, 0L, TimeUnit.MILLISECONDS);
 	}
 
 	@Override
 	public Disposable schedule(Runnable task, long delay, TimeUnit unit) {
-		return Schedulers.directSchedule(executor, task, delay, unit);
+		return Schedulers.directSchedule(executor, task, null, delay, unit);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -227,7 +227,7 @@ public Context currentContext() {
         @Override
         public void onNext(Object t) {
             // ignored
-            Operators.onDiscard(t, currentContext()); //FIXME cache Context
+            Operators.onDiscard(t, parent.currentContext()); //FIXME cache Context
         }
         
         @Override

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -111,6 +111,7 @@ static final class MergeReduceMain<T>
 		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == Attr.ERROR) return error;
+			if (key == Attr.TERMINATED) return REMAINING.get(this) == 0;
 
 			return super.scanUnsafe(key);
 		}

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -247,7 +247,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		String debugStack = sw.toString();
 
 		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
-				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:223)\n"
+				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:227)\n"
 				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n");
 		assertThat(debugStack).endsWith("Error has been observed at the following site(s):\n"
 				+ "\t|_ ParallelFlux.checkpoint ⇢ at reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n\n");

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6418,8 +6418,7 @@ public final Flux<T> or(Publisher<? extends T> other) {
 	 * @return a new {@link ParallelFlux} instance
 	 */
 	public final ParallelFlux<T> parallel() {
-		return parallel(Runtime.getRuntime()
-		                       .availableProcessors());
+		return parallel(Schedulers.DEFAULT_POOL_SIZE);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -44,6 +44,7 @@
 import reactor.core.publisher.FluxOnAssembly.AssemblyLightSnapshot;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshot;
 import reactor.core.scheduler.Scheduler;
+import reactor.core.scheduler.Schedulers;
 import reactor.util.Logger;
 import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
@@ -78,9 +79,7 @@ public abstract class ParallelFlux<T> implements CorePublisher<T> {
 	 * @return the {@link ParallelFlux} instance
 	 */
 	public static <T> ParallelFlux<T> from(Publisher<? extends T> source) {
-		return from(source,
-				Runtime.getRuntime()
-				       .availableProcessors(), Queues.SMALL_BUFFER_SIZE,
+		return from(source, Schedulers.DEFAULT_POOL_SIZE, Queues.SMALL_BUFFER_SIZE,
 				Queues.small());
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -247,7 +247,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		String debugStack = sw.toString();
 
 		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
-				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:224)\n"
+				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:223)\n"
 				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n");
 		assertThat(debugStack).endsWith("Error has been observed at the following site(s):\n"
 				+ "\t|_ ParallelFlux.checkpoint ⇢ at reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:" + (baseline + 4) + ")\n\n");

File: reactor-core/src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -67,7 +67,7 @@
  * @param <E> Type of dispatched signal
  * @author Stephane Maldini
  * @author Anatoly Kadyshev
- * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+
+ * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
  */
 @Deprecated
 public final class TopicProcessor<E> extends EventLoopProcessor<E>  {
@@ -80,7 +80,9 @@ public final class TopicProcessor<E> extends EventLoopProcessor<E>  {
 	 * {@code TopicProcessor<String> processor = TopicProcessor.<String>builder().build()}
 	 *
 	 * @param <T> Type of dispatched signal
+	 * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
 	 */
+	@Deprecated
 	public final static class Builder<T> {
 
 		String          name;

File: reactor-core/src/main/java/reactor/core/publisher/WorkQueueProcessor.java
Patch:
@@ -64,7 +64,7 @@
  *
  * @param <E> Type of dispatched signal
  * @author Stephane Maldini
- * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+
+ * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
  */
 @Deprecated
 public final class WorkQueueProcessor<E> extends EventLoopProcessor<E> {
@@ -77,7 +77,9 @@ public final class WorkQueueProcessor<E> extends EventLoopProcessor<E> {
 	 * {@code WorkQueueProcessor<String> processor = WorkQueueProcessor.<String>builder().build()}
 	 *
 	 * @param <T> Type of dispatched signal
+	 * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
 	 */
+	@Deprecated
 	public final static class Builder<T> {
 
 		String          name;

File: reactor-core/src/main/java/reactor/util/concurrent/WaitStrategy.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Strategy employed to wait for specific {@link LongSupplier} values with various spinning strategies.
- * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+
+ * @deprecated Has been moved to io.projectreactor.addons:reactor-extra:3.3.0+ and will be removed in 3.4.0
  */
 @Deprecated
 public abstract class WaitStrategy {

File: reactor-core/src/main/java/reactor/core/publisher/Traces.java
Patch:
@@ -315,7 +315,7 @@ static boolean shouldSanitize(String stackTraceRow) {
 	 * from the assembly stack trace.
 	 */
 	static String extractOperatorAssemblyInformation(String source) {
-		String[] parts = extractOperatorAssemblyInformationParts(source, false);
+		String[] parts = extractOperatorAssemblyInformationParts(source);
 		switch (parts.length) {
 			case 0:
 				return "[no operator assembly information]";
@@ -350,12 +350,11 @@ static boolean isUserCode(String line) {
 	 * @return a {@link String} representing operator and operator assembly site extracted
 	 * from the assembly stack trace.
 	 */
-	static String[] extractOperatorAssemblyInformationParts(String source, boolean skipFirst) {
+	static String[] extractOperatorAssemblyInformationParts(String source) {
 		String[] uncleanTraces = source.split("\n");
 		final List<String> traces = Stream.of(uncleanTraces)
 		                                  .map(String::trim)
 		                                  .filter(s -> !s.isEmpty())
-		                                  .skip(skipFirst ? 1 : 0)
 		                                  .collect(Collectors.toList());
 
 		if (traces.isEmpty()) {

File: reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java
Patch:
@@ -266,7 +266,7 @@ public ColdTestPublisher<T> assertMinRequested(long n) {
 		                        .min()
 		                        .orElse(0);
 		if (minRequest < n) {
-			throw new AssertionError("Expected minimum request of " + n + "; got " + minRequest);
+			throw new AssertionError("Expected smallest requested amount to be >= " + n + "; got " + minRequest);
 		}
 		return this;
 	}
@@ -278,8 +278,8 @@ public ColdTestPublisher<T> assertMaxRequested(long n) {
 		                        .mapToLong(s -> s.requested)
 		                        .max()
 		                        .orElse(0);
-		if (maxRequest < n) {
-			throw new AssertionError("Expected maximum request of " + n + "; got " + maxRequest);
+		if (maxRequest > n) {
+			throw new AssertionError("Expected largest requested amount to be <= " + n + "; got " + maxRequest);
 		}
 		return this;
 	}

File: reactor-test/src/main/java/reactor/test/publisher/DefaultTestPublisher.java
Patch:
@@ -304,7 +304,7 @@ public DefaultTestPublisher<T> assertMinRequested(long n) {
 		                        .min()
 		                        .orElse(0);
 		if (minRequest < n) {
-			throw new AssertionError("Expected minimum request of " + n + "; got " + minRequest);
+			throw new AssertionError("Expected smallest requested amount to be >= " + n + "; got " + minRequest);
 		}
 		return this;
 	}
@@ -316,8 +316,8 @@ public DefaultTestPublisher<T> assertMaxRequested(long n) {
 		                        .mapToLong(s -> s.requested)
 		                        .max()
 		                        .orElse(0);
-		if (maxRequest < n) {
-			throw new AssertionError("Expected maximum request of " + n + "; got " + maxRequest);
+		if (maxRequest > n) {
+			throw new AssertionError("Expected largest requested amount to be <= " + n + "; got " + maxRequest);
 		}
 		return this;
 	}

File: reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java
Patch:
@@ -102,7 +102,7 @@ public static <T> TestPublisher<T> createCold() {
 
 	/**
 	 * Assert that the current maximum request of all this publisher's subscribers
-	 * is &gt;= {@code n}. Can be {@link Long#MAX_VALUE} in case a subscriber has made
+	 * is &lt;= {@code n}. Can be {@link Long#MAX_VALUE} in case a subscriber has made
 	 * an unbounded request.
 	 *
 	 * @param n the expected maximum request including {@link Long#MAX_VALUE}

File: reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java
Patch:
@@ -250,7 +250,7 @@ public void expectMinRequestedFailure() {
 		                                 .emit("foo"))
 		            .expectNext("foo").expectComplete() // N/A
 		            .verify())
-		        .withMessageContaining("Expected minimum request of 6; got 5");
+		        .withMessageContaining("Expected smallest requested amount to be >= 6; got 5");
 
 		publisher.assertCancelled();
 		publisher.assertNoSubscribers();
@@ -285,11 +285,11 @@ public void expectMaxRequestedWithUnbounded() {
 	public void expectMaxRequestedFailure() {
 		TestPublisher<String> publisher = TestPublisher.createCold();
 
-		Flux.from(publisher).limitRequest(5).subscribe();
+		Flux.from(publisher).limitRequest(7).subscribe();
 
 		assertThatExceptionOfType(AssertionError.class)
 				.isThrownBy(() -> publisher.assertMaxRequested(6))
-				.withMessage("Expected maximum request of 6; got 5");
+				.withMessage("Expected largest requested amount to be <= 6; got 7");
 	}
 
 	@Test

File: reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java
Patch:
@@ -305,7 +305,7 @@ public void expectMinRequestedFailure() {
 		                                 .emit("foo"))
 		            .expectNext("foo").expectComplete() // N/A
 		            .verify())
-		        .withMessageContaining("Expected minimum request of 6; got 5");
+		        .withMessageContaining("Expected smallest requested amount to be >= 6; got 5");
 
 		publisher.assertCancelled();
 		publisher.assertNoSubscribers();
@@ -340,11 +340,11 @@ public void expectMaxRequestedWithUnbounded() {
 	public void expectMaxRequestedFailure() {
 		TestPublisher<String> publisher = TestPublisher.create();
 
-		Flux.from(publisher).limitRequest(5).subscribe();
+		Flux.from(publisher).limitRequest(7).subscribe();
 
 		assertThatExceptionOfType(AssertionError.class)
 				.isThrownBy(() -> publisher.assertMaxRequested(6))
-				.withMessage("Expected maximum request of 6; got 5");
+				.withMessage("Expected largest requested amount to be <= 6; got 7");
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2213,7 +2213,7 @@ public final Mono<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {
 	 * </ul>
 	 *
 	 * <p>
-	 * <img class="marble" src="doc-files/marbles/doOnTerminateForMono.svg" alt="">
+	 * <img class="marble" src="doc-files/marbles/doOnSuccessOrError.svg" alt="">
 	 *
 	 * @param onSuccessOrError the callback to call {@link Subscriber#onNext}, {@link Subscriber#onComplete} without preceding {@link Subscriber#onNext} or {@link Subscriber#onError}
 	 *

File: reactor-core/src/blockHoundTest/java/reactor/core/scheduler/ReactorBlockHoundIntegrationTest.java
Patch:
@@ -26,8 +26,6 @@
 import org.junit.rules.Timeout;
 import reactor.blockhound.BlockHound;
 import reactor.core.publisher.Mono;
-import reactor.core.scheduler.ReactorBlockHoundIntegration;
-import reactor.core.scheduler.Schedulers;
 
 public class ReactorBlockHoundIntegrationTest {
 

File: reactor-core/src/main/java/reactor/core/scheduler/ReactorBlockHoundIntegration.java
Patch:
@@ -37,6 +37,7 @@ public void applyTo(BlockHound.Builder builder) {
         builder.nonBlockingThreadPredicate(current -> current.or(NonBlocking.class::isInstance));
 
         builder.allowBlockingCallsInside("java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue", "offer");
+        builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName() + "$DelayedWorkQueue", "take");
 
         Schedulers.onScheduleHook("BlockHound", Wrapper::new);
         builder.disallowBlockingCallsInside(Wrapper.class.getName(), "run");

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -335,15 +335,16 @@ public void remove(PubSubInner<T> inner) {
 					return;
 				}
 				int n = a.length;
-				int j = 0;
+				int j = -1;
 				for (int i = 0; i < n; i++) {
 					if (a[i] == inner) {
 						j = i;
 						break;
 					}
 				}
 
-				if (j < 0) { //TODO investigate condition always false
+				if (j < 0) {
+					//inner was not found
 					return;
 				}
 

File: reactor-test/src/test/java/reactor/test/StepVerifierAssertionsTests.java
Patch:
@@ -526,7 +526,7 @@ public void assertOperatorErrorFailureWrongMatch() {
 		}
 		catch (AssertionError ae) {
 			assertThat(ae).hasMessage("Expected operator error matching the given predicate, " +
-					"did not match: <[Optional[java.lang.IllegalStateException: boom1],Optional[test]>.");
+					"did not match: <[Optional[java.lang.IllegalStateException: boom1],Optional[test]]>.");
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -40,7 +40,7 @@ final class FluxError<T> extends Flux<T> implements Fuseable.ScalarCallable, Sou
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		Operators.error(actual, Operators.onOperatorError(error, actual.currentContext()));
+		Operators.error(actual, error);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorSupplied.java
Patch:
@@ -58,7 +58,7 @@ final class FluxErrorSupplied<T> extends Flux<T> implements Fuseable.ScalarCalla
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
 		Throwable error = Objects.requireNonNull(errorSupplier.get(), "errorSupplier produced a null Throwable");
-		Operators.error(actual, Operators.onOperatorError(error, actual.currentContext()));
+		Operators.error(actual, error);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -49,7 +49,7 @@ public T block() {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		Operators.error(actual, Operators.onOperatorError(error, actual.currentContext()));
+		Operators.error(actual, error);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -68,7 +68,7 @@ public T block() {
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
 		Throwable error = Objects.requireNonNull(errorSupplier.get(), "the errorSupplier returned null");
-		Operators.error(actual, Operators.onOperatorError(error, actual.currentContext()));
+		Operators.error(actual, error);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/util/concurrent/package-info.java
Patch:
@@ -15,8 +15,7 @@
  */
 
 /**
- * Queue {@link reactor.util.concurrent.Queues suppliers and utilities}, busy spin utils
- * {@link reactor.util.concurrent.WaitStrategy}.
+ * Queue {@link reactor.util.concurrent.Queues suppliers and utilities}
  * Used for operational serialization (serializing threads) or buffering (asynchronous boundary).
  *
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -146,7 +146,7 @@ class Attr<T> {
 		 * {@literal Integer.MIN_VALUE}, which serves as a signal that this attribute
 		 * should be used instead. Defaults to {@literal null}.
 		 * <p>
-		 * {@code Flux.flatMap}, {@code Flux.filterWhen}, {@link reactor.core.publisher.TopicProcessor},
+		 * {@code Flux.flatMap}, {@code Flux.filterWhen}
 		 * and {@code Flux.window} (with overlap) are known to use this attribute.
 		 */
 		public static final Attr<Long> LARGE_BUFFERED = new Attr<>(null);

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7950,7 +7950,7 @@ public final Flux<T> subscribeOn(Scheduler scheduler, boolean requestOnSeparateT
 	 * {@link Subscriber} (eg. a {@link FluxProcessor}).
 	 *
 	 * <blockquote><pre>
-	 * {@code flux.subscribeWith(WorkQueueProcessor.create()).subscribe() }
+	 * {@code flux.subscribeWith(EmitterProcessor.create()).subscribe() }
 	 * </pre></blockquote>
 	 *
 	 * If you need more control over backpressure and the request, use a {@link BaseSubscriber}.

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -31,8 +31,7 @@
 /**
  * A base processor that exposes {@link Flux} API for {@link Processor}.
  *
- * Implementors include {@link UnicastProcessor}, {@link EmitterProcessor},
- * {@link ReplayProcessor}, {@link WorkQueueProcessor} and {@link TopicProcessor}.
+ * Implementors include {@link UnicastProcessor}, {@link EmitterProcessor}, {@link ReplayProcessor}.
  *
  * @author Stephane Maldini
  *

File: reactor-core/src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -497,8 +497,8 @@ static Function<Publisher, Publisher> createOrUpdateOpHook(Collection<Function<?
 	}
 
 	//Hooks that are transformative
-	static volatile Function<Publisher, Publisher>                             onEachOperatorHook;
-	static volatile Function<Publisher, Publisher>                             onLastOperatorHook;
+	static Function<Publisher, Publisher> onEachOperatorHook;
+	static volatile Function<Publisher, Publisher> onLastOperatorHook;
 	static volatile BiFunction<? super Throwable, Object, ? extends Throwable> onOperatorErrorHook;
 
 	//Hooks that are just callbacks

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -336,7 +336,7 @@ public T poll() {
 				if (e != null) {
 
 					generatedError = null;
-					Exceptions.bubble(e);
+					throw Exceptions.propagate(e);
 				}
 
 				return null;
@@ -361,7 +361,7 @@ public T poll() {
 				if (e != null) {
 
 					generatedError = null;
-					throw Exceptions.bubble(e);
+					throw Exceptions.propagate(e);
 				}
 
 				return null;

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -354,7 +354,7 @@ public T poll() {
 				cleanup(s);
 				
 				if (!terminate) {
-					throw new IllegalStateException("The generator didn't call any of the " + "FluxGenerateOutput method");
+					throw new IllegalStateException("The generator didn't call any of the SynchronousSink method");
 				}
 
 				Throwable e = generatedError;

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -336,7 +336,7 @@ public T poll() {
 				if (e != null) {
 
 					generatedError = null;
-					Exceptions.bubble(e);
+					throw Exceptions.propagate(e);
 				}
 
 				return null;
@@ -361,7 +361,7 @@ public T poll() {
 				if (e != null) {
 
 					generatedError = null;
-					throw Exceptions.bubble(e);
+					throw Exceptions.propagate(e);
 				}
 
 				return null;

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -354,7 +354,7 @@ public T poll() {
 				cleanup(s);
 				
 				if (!terminate) {
-					throw new IllegalStateException("The generator didn't call any of the " + "FluxGenerateOutput method");
+					throw new IllegalStateException("The generator didn't call any of the SynchronousSink method");
 				}
 
 				Throwable e = generatedError;

File: reactor-core/src/test/java/reactor/core/publisher/HooksTest.java
Patch:
@@ -747,10 +747,10 @@ public void testMultiReceiver() throws Exception {
 			    })).flux().publish();
 
 			t.map(d -> d).subscribe(null,
-					e -> assertThat(e.getSuppressed()[0]).hasMessageContaining("\t|_\tFlux.publish"));
+					e -> assertThat(e.getSuppressed()[0]).hasMessageContaining("\t|_ Flux.publish"));
 
-			t.filter(d -> true).subscribe(null, e -> assertThat(e.getSuppressed()[0]).hasMessageContaining("\t\t|_\tFlux.publish"));
-			t.distinct().subscribe(null, e -> assertThat(e.getSuppressed()[0]).hasMessageContaining("\t\t\t|_\tFlux.publish"));
+			t.filter(d -> true).subscribe(null, e -> assertThat(e.getSuppressed()[0]).hasMessageContaining("|_____ Flux.publish"));
+			t.distinct().subscribe(null, e -> assertThat(e.getSuppressed()[0]).hasMessageContaining("_________  Flux.publish"));
 
 			t.connect();
 		}

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -980,7 +980,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:944)\n");
+						.hasMessageEndingWith("Flux.single ⇢ at reactor.guide.GuideTests.scatterAndGather(GuideTests.java:944)\n");
 			});
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3174,7 +3174,7 @@ public final Mono<List<T>> collectList() {
 				return list;
 			}));
 		}
-		return Mono.onAssembly(new MonoCollectList<>(this, listSupplier()));
+		return Mono.onAssembly(new MonoCollectList<>(this));
 	}
 
 	/**

File: reactor-core/src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -365,7 +365,8 @@ public void delayElementShouldNotCancelTwice() throws Exception {
 		Flux<Long> publishedFlux = p
 			.publish()
 			.refCount(2)
-			.doOnCancel(() -> cancellations.incrementAndGet());
+			.doOnCancel(() -> cancellations.incrementAndGet())
+				.log();
 
 		publishedFlux.any(x -> x > 5)
 			.delayElement(Duration.ofMillis(2))
@@ -380,7 +381,7 @@ public void delayElementShouldNotCancelTwice() throws Exception {
 		p.onComplete();
 
 		assertThat(result.get(10, TimeUnit.MILLISECONDS).size()).isEqualTo(10);
-		assertThat(cancellations.get()).isEqualTo(2);
+		assertThat(cancellations.get()).isEqualTo(1);
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3032,7 +3032,7 @@ public final <E extends Throwable> Mono<T> onErrorMap(Class<E> type,
 	 * choose the fallback depending on the error.
 	 *
 	 * <p>
-	 * <img class="marble" src="doc-files/marbles/onErrorReturnForMono.svg" alt="">
+	 * <img class="marble" src="doc-files/marbles/onErrorResumeForMono.svg" alt="">
 	 *
 	 * @param fallback the function to choose the fallback to an alternative {@link Mono}
 	 *

File: reactor-test/src/test/java/reactor/test/DefaultContextExpectationsTest.java
Patch:
@@ -43,7 +43,7 @@ private void assertContextExpectation(
 			long count) {
 		Flux<Integer> source = sourceTransformer.apply(Flux.range(1, 10));
 		Step<Integer> step = StepVerifier.create(source);
-		final DefaultContextExpectations<Integer> base = new DefaultContextExpectations<>(step, new ErrorFormatter(null));
+		final DefaultContextExpectations<Integer> base = new DefaultContextExpectations<>(step, new MessageFormatter(null, null, null));
 
 		expectations
 				.apply(base)
@@ -97,7 +97,7 @@ public void cancel() {
 		});
 
 		Step<Integer> step = StepVerifier.create(publisher);
-		DefaultContextExpectations<Integer> expectations = new DefaultContextExpectations<>(step, new ErrorFormatter(null));
+		DefaultContextExpectations<Integer> expectations = new DefaultContextExpectations<>(step, new MessageFormatter(null, null, null));
 
 		assertThatExceptionOfType(AssertionError.class)
 				.isThrownBy(() -> expectations.then().verifyComplete())
@@ -285,7 +285,7 @@ public void notMatchesWithDescriptionAndScenarioName() {
 		                           .subscriberContext(Context.of("foo", "bar"));
 
 		Step<Integer> step = StepVerifier.create(source);
-		final DefaultContextExpectations<Integer> base = new DefaultContextExpectations<>(step, new ErrorFormatter("scenario"));
+		final DefaultContextExpectations<Integer> base = new DefaultContextExpectations<>(step, new MessageFormatter("scenario", null, null));
 
 		assertThatExceptionOfType(AssertionError.class)
 				.isThrownBy(

File: reactor-test/src/test/java/reactor/test/StepVerifierAssertionsTests.java
Patch:
@@ -622,7 +622,7 @@ public void assertDurationLessThanFailure() {
 	public void assertDurationConsidersEqualsASuccess() {
 		new DefaultStepVerifierBuilder.DefaultStepVerifierAssertions(null,
 				Duration.ofSeconds(3),
-				new ErrorFormatter(null))
+				new MessageFormatter(null, null, null))
 				.tookLessThan(Duration.ofMillis(3000L))
 				.tookMoreThan(Duration.ofSeconds(3));
 	}
@@ -633,7 +633,7 @@ public void assertDurationFailureWithScenarioName() {
 				.isThrownBy(() ->
 						new DefaultStepVerifierBuilder.DefaultStepVerifierAssertions(null
 								, Duration.ofSeconds(3),
-								new ErrorFormatter("fooScenario"))
+								new MessageFormatter("fooScenario", null, null))
 								.tookLessThan(Duration.ofMillis(200))
 				)
 				.withMessage("[fooScenario] Expected scenario to be verified in less than 200ms, took 3000ms.");

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2019 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1307,7 +1307,7 @@ boolean onCollect(Signal<T> actualSignal) {
 				this.completeLatch.countDown();
 				return true;
 			}
-			return true;
+			return false;
 		}
 
 		@SuppressWarnings("unchecked")

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -308,7 +308,7 @@ public void scanDefaultMonoSink() {
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isFalse();
 		test.success();
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
-		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
+		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -308,7 +308,7 @@ public void scanDefaultMonoSink() {
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isFalse();
 		test.success();
 		assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
-		assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
+		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -32,7 +32,7 @@
  * Please note, that along with multiple consumers, current implementation of
  * DirectProcessor supports multiple producers. However, all producers must produce
  * messages on the same Thread, otherwise
- * <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a> contract is
+ * <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a> contract is
  * violated.
  * <p>
  *      <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/directprocessornormal.png" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -80,7 +80,7 @@
  * <p>
  * The recommended way to learn about the {@link Flux} API and discover new operators is
  * through the reference documentation, rather than through this javadoc (as opposed to
- * learning more about individual operators). See the <a href="http://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
+ * learning more about individual operators). See the <a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
  * "which operator do I need?" appendix</a>.
  *
  * <p>

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -71,7 +71,7 @@
  * <p>
  * The recommended way to learn about the {@link Mono} API and discover new operators is
  * through the reference documentation, rather than through this javadoc (as opposed to
- * learning more about individual operators). See the <a href="http://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
+ * learning more about individual operators). See the <a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
  * "which operator do I need?" appendix</a>.
  *
  * <p><img class="marble" src="doc-files/marbles/mono.svg" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -40,7 +40,7 @@
  * However, it should be noticed that multi-producer case is only valid if appropriate
  * Queue
  * is provided. Otherwise, it could break
- * <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a> if Publishers
+ * <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a> if Publishers
  * publish on different threads.
  *
  * <p>
@@ -53,14 +53,14 @@
  * <p>
  *      <b>Note: </b> UnicastProcessor does not respect the actual subscriber's
  *      demand as it is described in
- *      <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a>. However,
+ *      <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a>. However,
  *      UnicastProcessor embraces configurable Queue internally which allows enabling
  *      backpressure support and preventing of consumer's overwhelming.
  *
  *      Hence, interaction model between producers and UnicastProcessor will be PUSH
  *      only. In opposite, interaction model between UnicastProcessor and consumer will be
  *      PUSH-PULL as defined in
- *      <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a>.
+ *      <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a>.
  *
  *      In the case when upstream's signals overflow the bound of internal Queue,
  *      UnicastProcessor will fail with signaling onError(

File: reactor-core/src/main/java/reactor/adapter/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * Adapt
  * {@link org.reactivestreams.Publisher} to Java 9+
  * {@link reactor.adapter.JdkFlowAdapter Flow.Publisher}. More adapter can be found
- * under http://github.com/reactor/reactor-addons/reactor-adapter including RxJava1 and
+ * under https://github.com/reactor/reactor-addons/reactor-adapter including RxJava1 and
  * RxJava2.
  *
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeOrdered.java
Patch:
@@ -43,7 +43,7 @@
  * @author David Karnok
  * @author Simon Baslé
  */
-//source: http://akarnokd.blogspot.fr/2017/09/java-9-flow-api-ordered-merge.html
+//source: https://akarnokd.blogspot.fr/2017/09/java-9-flow-api-ordered-merge.html
 final class FluxMergeOrdered<T> extends Flux<T> implements Scannable {
 
 	final int                      prefetch;

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -45,7 +45,7 @@
  * size and to cap concurrent additive operations to Long.MAX_VALUE,
  * which is generic to {@link Subscription#request(long)} handling.
  *
- * Combine utils available to operator implementations, @see http://github.com/reactor/reactive-streams-commons
+ * Combine utils available to operator implementations, @see https://github.com/reactor/reactive-streams-commons
  *
  */
 public abstract class Operators {

File: reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -549,7 +549,7 @@ enum  UnsafeSupport {
 
 		// ensure the unsafe supports all necessary methods to work around the mistake in the latest OpenJDK
 		// https://github.com/netty/netty/issues/1061
-		// http://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
+		// https://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
 		if (unsafe != null) {
 			final Unsafe finalUnsafe = unsafe;
 			Object maybeException;

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -936,7 +936,7 @@ public void testCommandEmptyPathIsUsed() {
 
 	private Flux<String> urls() {
 		return Flux.range(1, 5)
-		           .map(i -> "http://mysite.io/quote/" + i);
+		           .map(i -> "https://www.mysite.io/quote" + i);
 	}
 
 	private Flux<String> doRequest(String url) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-Present Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -78,7 +78,7 @@ public interface MonoSink<T> {
 	 * Attaches a {@link LongConsumer} to this {@link MonoSink} that will be notified of
 	 * any request to this sink.
 	 *
-	 * @param consumer the consumer to invoke on each request
+	 * @param consumer the consumer to invoke on request
 	 *
 	 * @return {@link MonoSink} with a consumer that is notified of requests
 	 */

File: reactor-core/src/main/java/reactor/core/CorePublisher.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/jmh/java/reactor/AssemblyTraceBenchmark.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/jmh/java/reactor/core/CompositeDisposableHashcodeBenchmark.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEachFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorSupplied.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetrics.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetricsFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchOnFirst.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsingWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEachFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetrics.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsingWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/OnNextFailureStrategy.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/SourceProducer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/Traces.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/scheduler/SchedulerMetricDecorator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/util/Metrics.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableOnAssemblyTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorSuppliedTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/FluxMetricsFuseableTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/FluxMetricsTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchOnFirstTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingWhenTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoCallableOnAssemblyTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoErrorSuppliedTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoMetricsFuseableTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoMetricsTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoOnAssemblyTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoRepeatPredicateTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/MonoUsingWhenTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/OnNextFailureStrategyTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/core/publisher/TracesTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/test/MemoryUtils.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/util/MetricsNoMicrometerTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/util/MetricsTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/test/java/reactor/util/concurrent/QueuesOneQueueTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-test/src/main/java/reactor/test/ErrorFormatter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-test/src/main/java/reactor/test/util/TestLogger.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-test/src/test/java/reactor/test/ErrorFormatterTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-test/src/test/java/reactor/test/StepVerifierTimeoutTests.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/jmh/java/reactor/CheckpointBenchmark.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/adapter/JdkFlowAdapter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/adapter/package-info.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/CoreSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/Disposable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/Disposables.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/Exceptions.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/Fuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/package-info.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BlockingFirstSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BlockingLastSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BlockingMonoSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BlockingOptionalMonoSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/BufferOverflowStrategy.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFlux.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLift.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableLiftFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/DelegateProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/DrainUtils.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxCancelOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatIterable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxContextStart.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefaultIfEmpty.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySequence.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDematerialize.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDetach.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinct.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFinally.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFinallyFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxElapsed.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorOnRequest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxExpand.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxFromMonoOperator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxHide.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxIndex.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxIndexFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxJoin.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxLift.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxLiftFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxLimitRequest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxLog.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxLogFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMaterialize.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMerge.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeOrdered.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxName.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxNameFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferStrategy.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnErrorResume.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxOperator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeat.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetry.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkip.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipLast.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceMono.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceMonoFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchIfEmpty.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTake.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindow.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeout.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/FluxZipIterable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/GroupedFlux.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/GroupedLift.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/GroupedLiftFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ImmutableSignal.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/InnerConsumer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/InnerOperator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/InnerProducer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoBridges.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCancelOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCompletionStage.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCount.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoCurrentContext.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDefaultIfEmpty.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelaySubscription.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDematerialize.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDetach.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoFinally.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoFinallyFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEach.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoElapsed.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoExpand.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlattenIterable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromFluxOperator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromPublisher.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoHandle.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoHandleFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoHasElement.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoHasElements.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoHide.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreElement.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreElements.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnorePublisher.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoLift.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoLiftFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoLog.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoLogFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoMapFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoMaterialize.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoName.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoNameFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnErrorResume.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoOperator.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoPeek.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoPeekTerminal.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishMulticast.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduce.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRepeat.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRepeatPredicate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRepeatWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRetry.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRetryPredicate.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRetryWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingleMono.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -21,7 +21,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSourceFlux.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSourceFluxFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSourceFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscriberContext.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoSwitchIfEmpty.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeUntilOther.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoTimeout.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/MonoZip.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/OperatorDisposables.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelArraySource.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFilter.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxName.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMap.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeOrdered.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/QueueDrainSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *        https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -503,7 +503,7 @@ void clearAlert() {
  * version 2.0 (the "License"); you may not use this file except in compliance
  * with the License. You may obtain a copy of the License at:
  *
- *   http://www.apache.org/licenses/LICENSE-2.0
+ *   https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

File: reactor-core/src/main/java/reactor/core/publisher/SerializedSubscriber.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/Signal.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ *       https://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: reactor-core/src/main/java/reactor/adapter/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * Adapt
  * {@link org.reactivestreams.Publisher} to Java 9+
  * {@link reactor.adapter.JdkFlowAdapter Flow.Publisher}. More adapter can be found
- * under http://github.com/reactor/reactor-addons/reactor-adapter including RxJava1 and
+ * in reactor-adapter under https://github.com/reactor/reactor-addons/ including RxJava1 and
  * RxJava2.
  *
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -32,7 +32,7 @@
  * Please note, that along with multiple consumers, current implementation of
  * DirectProcessor supports multiple producers. However, all producers must produce
  * messages on the same Thread, otherwise
- * <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a> contract is
+ * <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a> contract is
  * violated.
  * <p>
  *      <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/directprocessornormal.png" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -81,7 +81,7 @@
  * <p>
  * The recommended way to learn about the {@link Flux} API and discover new operators is
  * through the reference documentation, rather than through this javadoc (as opposed to
- * learning more about individual operators). See the <a href="http://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
+ * learning more about individual operators). See the <a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
  * "which operator do I need?" appendix</a>.
  *
  * <p>

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeOrdered.java
Patch:
@@ -43,7 +43,7 @@
  * @author David Karnok
  * @author Simon Baslé
  */
-//source: http://akarnokd.blogspot.fr/2017/09/java-9-flow-api-ordered-merge.html
+//source: https://akarnokd.blogspot.fr/2017/09/java-9-flow-api-ordered-merge.html
 final class FluxMergeOrdered<T> extends Flux<T> implements SourceProducer<T> {
 
 	final int                      prefetch;

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -72,7 +72,7 @@
  * <p>
  * The recommended way to learn about the {@link Mono} API and discover new operators is
  * through the reference documentation, rather than through this javadoc (as opposed to
- * learning more about individual operators). See the <a href="http://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
+ * learning more about individual operators). See the <a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
  * "which operator do I need?" appendix</a>.
  *
  * <p><img class="marble" src="doc-files/marbles/mono.svg" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -49,7 +49,7 @@
  * size and to cap concurrent additive operations to Long.MAX_VALUE,
  * which is generic to {@link Subscription#request(long)} handling.
  *
- * Combine utils available to operator implementations, @see http://github.com/reactor/reactive-streams-commons
+ * Combine utils available to operator implementations, @see https://github.com/reactor/reactive-streams-commons
  *
  */
 public abstract class Operators {

File: reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -549,7 +549,7 @@ enum  UnsafeSupport {
 
 		// ensure the unsafe supports all necessary methods to work around the mistake in the latest OpenJDK
 		// https://github.com/netty/netty/issues/1061
-		// http://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
+		// https://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
 		if (unsafe != null) {
 			final Unsafe finalUnsafe = unsafe;
 			Object maybeException;

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -40,7 +40,7 @@
  * However, it should be noticed that multi-producer case is only valid if appropriate
  * Queue
  * is provided. Otherwise, it could break
- * <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a> if Publishers
+ * <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a> if Publishers
  * publish on different threads.
  *
  * <p>
@@ -53,14 +53,14 @@
  * <p>
  *      <b>Note: </b> UnicastProcessor does not respect the actual subscriber's
  *      demand as it is described in
- *      <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a>. However,
+ *      <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a>. However,
  *      UnicastProcessor embraces configurable Queue internally which allows enabling
  *      backpressure support and preventing of consumer's overwhelming.
  *
  *      Hence, interaction model between producers and UnicastProcessor will be PUSH
  *      only. In opposite, interaction model between UnicastProcessor and consumer will be
  *      PUSH-PULL as defined in
- *      <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a>.
+ *      <a href="https://www.reactive-streams.org/">Reactive Streams Spec</a>.
  *
  *      In the case when upstream's signals overflow the bound of internal Queue,
  *      UnicastProcessor will fail with signaling onError(

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -932,7 +932,7 @@ public void testCommandEmptyPathIsUsed() {
 
 	private Flux<String> urls() {
 		return Flux.range(1, 5)
-		           .map(i -> "http://mysite.io/quote/" + i);
+		           .map(i -> "https://www.mysite.io/quote" + i);
 	}
 
 	private Flux<String> doRequest(String url) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEachFuseable.java
Patch:
@@ -41,6 +41,6 @@ final class FluxDoOnEachFuseable<T> extends FluxOperator<T, T> implements Fuseab
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		this.source.subscribe(FluxDoOnEach.createSubscriber(actual, this.onSignal, true));
+		this.source.subscribe(FluxDoOnEach.createSubscriber(actual, this.onSignal, true, false));
 	}
 }
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEach.java
Patch:
@@ -39,6 +39,6 @@ final class MonoDoOnEach<T> extends MonoOperator<T, T> {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		source.subscribe(FluxDoOnEach.createSubscriber(actual, onSignal, false));
+		source.subscribe(FluxDoOnEach.createSubscriber(actual, onSignal, false, true));
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEachFuseable.java
Patch:
@@ -41,6 +41,6 @@ final class MonoDoOnEachFuseable<T> extends MonoOperator<T, T> implements Fuseab
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		source.subscribe(FluxDoOnEach.createSubscriber(actual, onSignal, true));
+		source.subscribe(FluxDoOnEach.createSubscriber(actual, onSignal, true, true));
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -86,7 +86,7 @@ public void testDoOnEachSignal() {
 		            .expectSubscription()
 		            .expectNext(1)
 		            .expectComplete()
-		            .verify();
+		            .verify(Duration.ofSeconds(5));
 
 		assertThat(signals.size(), is(2));
 		assertThat("onNext", signals.get(0).get(), is(1));

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEach.java
Patch:
@@ -41,6 +41,6 @@ final class MonoDoOnEach<T> extends MonoOperator<T, T> {
 	public void subscribe(CoreSubscriber<? super T> actual) {
 		//TODO fuseable version?
 		//TODO conditional version?
-		source.subscribe(new FluxDoOnEach.DoOnEachSubscriber<>(actual, onSignal));
+		source.subscribe(new FluxDoOnEach.DoOnEachSubscriber<>(actual, onSignal, true));
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoOnEachTest.java
Patch:
@@ -302,7 +302,7 @@ public void scanSubscriber() {
 		FluxDoOnEach<Integer> peek =
 				new FluxDoOnEach<>(Flux.just(1), s -> { });
 		FluxDoOnEach.DoOnEachSubscriber<Integer> test =
-				new FluxDoOnEach.DoOnEachSubscriber<>(actual, peek.onSignal);
+				new FluxDoOnEach.DoOnEachSubscriber<>(actual, peek.onSignal, false);
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -51,7 +51,7 @@ public void testDoOnEachSignal() {
 		            .expectSubscription()
 		            .expectNext(1)
 		            .expectComplete()
-		            .verify();
+		            .verify(Duration.ofSeconds(5));
 
 		assertThat(signals.size(), is(2));
 		assertThat("onNext", signals.get(0).get(), is(1));

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -232,7 +232,7 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 		String debugStack = sw.toString();
 
 		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
-				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:223)\n"
+				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:224)\n"
 				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)\n");
 		assertThat(debugStack).endsWith("Error has been observed by the following operator(s):\n"
 				+ "\t|_\tParallelFlux.checkpoint ⇢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)\n\n");

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java
Patch:
@@ -164,9 +164,10 @@ void nextCallback(T value) {
 		}
 
 		void flushCallback(@Nullable T ev) { //TODO investigate ev not used
-			C v = values;
+			final C v;
 			boolean flush = false;
 			synchronized (this) {
+				v = values;
 				if (v != null && !v.isEmpty()) {
 					values = bufferSupplier.get();
 					flush = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoBridges.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,7 +35,7 @@ static <R> Mono<R> zip(Function<? super Object[], ? extends R> combinator, Mono<
         return Mono.zip(combinator, monos);
     }
 
-    static Mono<Void> when(Publisher<Void>[] sources) {
+    static Mono<Void> when(Publisher<?>[] sources) {
         return Mono.when(sources);
     }
 }

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6046,7 +6046,6 @@ public final Flux<T> onBackpressureLatest() {
 	/**
 	 * Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 	 * incriminating element from the sequence and continuing with subsequent elements.
-	 * Only errors matching the {@link Predicate} are recovered from.
 	 * The recovered error and associated value are notified via the provided {@link BiConsumer}.
 	 * <p>
 	 * Note that this error handling mode is not necessarily implemented by all operators

File: reactor-test/src/main/java/reactor/test/ErrorFormatter.java
Patch:
@@ -114,8 +114,8 @@ AssertionError assertionError(String msg) {
 	 * @return an {@link AssertionError} with a cause and a standardized message
 	 * potentially prefixed with the associated scenario name
 	 */
-	AssertionError assertionError(String msg, Throwable cause) {
-		return new AssertionError(scenarioPrefix + msg, cause);
+	AssertionError assertionError(String msg, @Nullable Throwable cause) {
+		return new AssertionError(scenarioPrefix + msg, cause); //null cause is ok
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/scheduler/DelegateServiceScheduler.java
Patch:
@@ -47,7 +47,7 @@ final class DelegateServiceScheduler implements Scheduler, Scannable {
 
 	DelegateServiceScheduler(ExecutorService executorService) {
 			ScheduledExecutorService exec = convert(executorService);
-			this.executor = Schedulers.decorateExecutorService("ExecutorService", () -> exec);
+			this.executor = Schedulers.decorateExecutorService(this, exec);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -236,8 +236,7 @@ static final class CachedService implements Disposable, Scannable {
 		CachedService(@Nullable ElasticScheduler parent) {
 			this.parent = parent;
 			if (parent != null) {
-				this.exec =
-						Schedulers.decorateExecutorService(Schedulers.ELASTIC, parent);
+				this.exec = Schedulers.decorateExecutorService(parent, parent.get());
 			}
 			else {
 				this.exec = Executors.newSingleThreadScheduledExecutor();

File: reactor-core/src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -82,7 +82,7 @@ public ScheduledExecutorService get() {
     void init(int n) {
         ScheduledExecutorService[] a = new ScheduledExecutorService[n];
         for (int i = 0; i < n; i++) {
-            a[i] = Schedulers.decorateExecutorService(Schedulers.PARALLEL, this);
+            a[i] = Schedulers.decorateExecutorService(this, this.get());
         }
         EXECUTORS.lazySet(this, a);
     }
@@ -109,7 +109,7 @@ public void start() {
             if (b == null) {
                 b = new ScheduledExecutorService[n];
                 for (int i = 0; i < n; i++) {
-                    b[i] = Schedulers.decorateExecutorService(Schedulers.PARALLEL, this);
+                    b[i] = Schedulers.decorateExecutorService(this, this.get());
                 }
             }
             

File: reactor-core/src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -71,8 +71,7 @@ public ScheduledExecutorService get() {
 	}
 
 	private void init() {
-		EXECUTORS.lazySet(this,
-				Schedulers.decorateExecutorService(Schedulers.SINGLE, this));
+		EXECUTORS.lazySet(this, Schedulers.decorateExecutorService(this, this.get()));
 	}
 
 	@Override
@@ -94,7 +93,7 @@ public void start() {
 			}
 
 			if (b == null) {
-				b = Schedulers.decorateExecutorService(Schedulers.SINGLE, this);
+				b = Schedulers.decorateExecutorService(this, this.get());
 			}
 
 			if (EXECUTORS.compareAndSet(this, a, b)) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -174,7 +174,7 @@ void drain() {
 				}
 
 				if (e != 0L && r != Long.MAX_VALUE) {
-					Operators.produced(REQUESTED, this, 1);
+					Operators.produced(REQUESTED, this, e);
 				}
 
 				missed = WIP.addAndGet(this, -missed);

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -738,6 +738,9 @@ static Disposable workerSchedulePeriodically(ScheduledExecutorService exec,
 		if (period <= 0L) {
 			InstantPeriodicWorkerTask isr =
 					new InstantPeriodicWorkerTask(task, exec, tasks);
+			if (!tasks.add(isr)) {
+			  throw Exceptions.failWithRejected();
+			}
 			try {
 				Future<?> f;
 				if (initialDelay <= 0L) {

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6551,7 +6551,7 @@ final Flux<T> publishOn(Scheduler scheduler, boolean delayError, int prefetch, i
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/aggregate.png" alt="">
 	 *
-	 * @reactor.discard This operator discards the internally accumulated value upon error, but NOT cancellation.
+	 * @reactor.discard This operator discards the internally accumulated value upon cancellation or error.
 	 *
 	 * @param aggregator the reducing {@link BiFunction}
 	 *

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -140,7 +140,7 @@ public void onError(Throwable t) {
 
 		@Override
 		public void onComplete() {
-			if (value == null) {
+			if (value == null && state < HAS_REQUEST_HAS_VALUE) {
 				actual.onComplete();
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -1440,7 +1440,7 @@ public Object scanUnsafe(Attr key) {
 		@Override
 		public final void clear() {
 			STATE.lazySet(this, FUSED_CONSUMED);
-			value = null;
+			this.value = null;
 		}
 
 		/**
@@ -1474,6 +1474,7 @@ public final void complete(O v) {
 					STATE.lazySet(this, HAS_REQUEST_HAS_VALUE);
 					Subscriber<? super O> a = actual;
 					a.onNext(v);
+					this.value = null;
 					if (this.state != CANCELLED) {
 						a.onComplete();
 					}
@@ -1486,7 +1487,7 @@ public final void complete(O v) {
 				state = this.state;
 				if (state == CANCELLED) {
 					Operators.onDiscard(value, actual.currentContext());
-					value = null;
+					this.value = null;
 					return;
 				}
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.function.Supplier;
 
 import org.reactivestreams.Subscription;
+
 import reactor.core.CoreSubscriber;
 import reactor.util.annotation.Nullable;
 
@@ -183,6 +184,7 @@ public void onComplete() {
 				return;
 			}
 			done = true;
+			value = null;
 			actual.onComplete();
 		}
 
@@ -193,6 +195,7 @@ public void onError(Throwable t) {
 				return;
 			}
 			done = true;
+			value = null;
 			actual.onError(t);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -1420,7 +1420,7 @@ public MonoSubscriber(CoreSubscriber<? super O> actual) {
 
 		@Override
 		public void cancel() {
-			if (this.state == NO_REQUEST_HAS_VALUE) {
+			if (this.state <= HAS_REQUEST_NO_VALUE) {
 				Operators.onDiscard(value, currentContext());
 			}
 			this.state = CANCELLED;

File: reactor-core/src/main/java/reactor/core/Disposable.java
Patch:
@@ -151,7 +151,7 @@ default boolean addAll(Collection<? extends Disposable> ds) {
 		 * <p>
 		 * It becomes the responsibility of the caller to dispose the value themselves,
 		 * which they can do by a simple call to {@link Disposable#dispose()} on said
-		 * value (probaby guarded by a check that this method returned true, meaning the
+		 * value (probably guarded by a check that this method returned true, meaning the
 		 * disposable was actually in the container).
 		 *
 		 * @param d the {@link Disposable} to remove.

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -162,7 +162,7 @@ static void addCap(RingBuffer.Sequence sequence, long toAdd) {
 	}
 
 	/**
-	 * Concurrent substraction bound to 0 and Long.MAX_VALUE. Any concurrent write will
+	 * Concurrent subtraction bound to 0 and Long.MAX_VALUE. Any concurrent write will
 	 * "happen" before this operation.
 	 *
 	 * @param sequence current sequence to update

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7328,7 +7328,7 @@ public final Mono<T> single() {
 	 * @param defaultValue  a single fallback item if this {@link Flux} is empty
 	 *
 	 * @return a {@link Mono} with the expected single item, the supplied default value or
-	 * and error signal
+	 * an error signal
 	 */
     public final Mono<T> single(T defaultValue) {
         if (this instanceof Callable) {

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -27,7 +27,7 @@
 import reactor.util.context.Context;
 
 /**
- * An unbounded Java Lambda adapter to {@link Subscriber}, targetted at {@link Mono}.
+ * An unbounded Java Lambda adapter to {@link Subscriber}, targeted at {@link Mono}.
  *
  * @param <T> the value type
  */

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -119,7 +119,7 @@ public abstract class Mono<T> implements Publisher<T> {
 	 * Mono.&lt;String&gt;create(sink -&gt; {
 	 *     HttpListener listener = event -&gt; {
 	 *         if (event.getResponseCode() >= 400) {
-	 *             sink.error(new RuntimeExeption("Failed"));
+	 *             sink.error(new RuntimeException("Failed"));
 	 *         } else {
 	 *             String body = event.getBody();
 	 *             if (body.isEmpty()) {

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -1118,7 +1118,7 @@ final <R> ParallelFlux<R> concatMap(Function<? super T, ? extends Publisher<? ex
 	 *
 	 * @param <R> the result type
 	 * @param mapper the function to map each rail's value into a Publisher
-	 * @param delayUntilEnd true if delayed until all sources are concated
+	 * @param delayUntilEnd true if delayed until all sources are concatenated
 	 * @param prefetch the number of items to prefetch from each inner Publisher
 	 * source and the inner Publishers (immediate, boundary, end)
 	 *

File: reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -282,7 +282,7 @@ public long getAsLong() {
 	}
 
 	/**
-	 * Get the current cursor value for the ring buffer.  The actual value recieved will depend on the type of {@code
+	 * Get the current cursor value for the ring buffer.  The actual value received will depend on the type of {@code
 	 * RingBufferProducer} that is being used.
 	 * <p>
      * See {@code MultiProducerRingBuffer}.
@@ -371,7 +371,7 @@ Sequence[] getSequenceReceivers() {
 
 
 	/**
-	 * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for acclerated
+	 * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for accelerated
 	 * direct memory access.
 	 * @return true if unsafe is present
 	 */

File: reactor-core/src/test/java/reactor/core/ListCompositeDisposableTest.java
Patch:
@@ -111,7 +111,7 @@ public void disposeDisposesAndDisallowReuse() throws Exception {
 	}
 
 	@Test
-	public void removeInexistant() throws Exception {
+	public void removeNonexistant() throws Exception {
 		FakeDisposable d = new FakeDisposable();
 		Disposable.Composite cd = new ListCompositeDisposable();
 		boolean deleted = cd.remove(d);

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -783,7 +783,7 @@ public void assertProcessor(EmitterProcessor<Integer> processor,
 	}
 
 	/**
-	 * Concurrent substraction bound to 0 and Long.MAX_VALUE.
+	 * Concurrent subtraction bound to 0 and Long.MAX_VALUE.
 	 * Any concurrent write will "happen" before this operation.
 	 *
 	 * @param sequence current atomic to update

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -320,7 +320,7 @@ public void bufferWillSubdivideAnInputFluxTime2() {
 	}
 
 	@Test
-	public void bufferWillAcumulateMultipleListsOfValues() {
+	public void bufferWillAccumulateMultipleListsOfValues() {
 		//given: "a source and a collected flux"
 		EmitterProcessor<Integer> numbers = EmitterProcessor.create();
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -1018,18 +1018,18 @@ private void testFluxCreateOnRequestSingleThread(OverflowStrategy overflowStrate
 	@Test
 	public void fluxCreateOnRequestMultipleThreadsSlowProducer() {
 		for (OverflowStrategy overflowStrategy : OverflowStrategy.values()) {
-			testFluxCreateOnRequesMultipleThreads(overflowStrategy, true);
+			testFluxCreateOnRequestMultipleThreads(overflowStrategy, true);
 		}
 	}
 
 	@Test
 	public void fluxCreateOnRequestMultipleThreadsFastProducer() {
 		for (OverflowStrategy overflowStrategy : OverflowStrategy.values()) {
-			testFluxCreateOnRequesMultipleThreads(overflowStrategy, false);
+			testFluxCreateOnRequestMultipleThreads(overflowStrategy, false);
 		}
 	}
 
-	private void testFluxCreateOnRequesMultipleThreads(OverflowStrategy overflowStrategy, boolean slowProducer) {
+	private void testFluxCreateOnRequestMultipleThreads(OverflowStrategy overflowStrategy, boolean slowProducer) {
 		int count = 10_000;
 		TestQueue queue;
 		if (overflowStrategy == OverflowStrategy.ERROR || overflowStrategy == OverflowStrategy.IGNORE)

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java
Patch:
@@ -580,7 +580,7 @@ public void scanFuseableSubscriber() {
 	}
 
 	@Test
-	public void distinctDefaulWithHashcodeCollisions() {
+	public void distinctDefaultWithHashcodeCollisions() {
 		Object foo = new Object() {
 			@Override
 			public int hashCode() {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -118,7 +118,7 @@ public void allDistinctBackpressured() {
 	}
 
 	@Test
-	public void someRepetiton() {
+	public void someRepetition() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		Flux.just(1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 3, 3)
@@ -269,7 +269,7 @@ public void scanConditionalSubscriber() {
 	}
 
 	@Test
-	public void distinctUntilChangedDefaulWithHashcodeCollisions() {
+	public void distinctUntilChangedDefaultWithHashcodeCollisions() {
 		Object foo = new Object() {
 			@Override
 			public int hashCode() {

File: reactor-core/src/test/java/reactor/core/publisher/FluxDoFinallyTest.java
Patch:
@@ -472,7 +472,7 @@ public void gh951_withConsumerInSubscribe() {
 
 	@Test
 	//see https://github.com/reactor/reactor-core/issues/951
-	public void gh951_whithoutDoOnError() {
+	public void gh951_withoutDoOnError() {
 		List<String> events = new ArrayList<>();
 
 		Assertions.assertThatExceptionOfType(UnsupportedOperationException.class)
@@ -483,7 +483,7 @@ public void gh951_whithoutDoOnError() {
 		          .withMessage("java.lang.IllegalStateException: boom");
 
 		Assertions.assertThat(events)
-		          .as("whithoutDoOnError")
+		          .as("withoutDoOnError")
 		          .containsExactly("doFinally onError");
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -376,7 +376,7 @@ public void introspectionNormal() {
 		assertThat(scannable.get().scan(Scannable.Attr.TERMINATED)).isEqualTo(true);
 	}
 
-	//TODO introspect errors (but is difficult due to Expections.terminate)
+	//TODO introspect errors (but is difficult due to Exceptions.terminate)
 	@Test
 	public void introspectionCancel() {
 		AtomicReference<Scannable> scannable = new AtomicReference<>();

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1137,7 +1137,7 @@ public void mapNotifiesOnce() throws InterruptedException {
 		final Object consumerLock = new Object();
 
 		final CountDownLatch internalLatch = new CountDownLatch(COUNT);
-		final CountDownLatch counsumerLatch = new CountDownLatch(COUNT);
+		final CountDownLatch consumerLatch = new CountDownLatch(COUNT);
 
 		final AtomicInteger internalCounter = new AtomicInteger(0);
 		final AtomicInteger consumerCounter = new AtomicInteger(0);
@@ -1191,7 +1191,7 @@ public void mapNotifiesOnce() throws InterruptedException {
 					                            fail();
 				                            }
 
-				                            counsumerLatch.countDown();
+				                            consumerLatch.countDown();
 			                            }
 		                            }));
 
@@ -1201,7 +1201,7 @@ public void mapNotifiesOnce() throws InterruptedException {
 
 		internalLatch.await(5, TimeUnit.SECONDS);
 		assertEquals(COUNT, internalCounter.get());
-		counsumerLatch.await(5, TimeUnit.SECONDS);
+		consumerLatch.await(5, TimeUnit.SECONDS);
 		assertEquals(COUNT, consumerCounter.get());
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -275,7 +275,7 @@ public void cancel() {
 		Disposable connected = replay.connect();
 
 		//the lambda subscriber itself is cancelled so it will bubble the exception
-		//propagated by connect().dipose()
+		//propagated by connect().dispose()
 		assertThatExceptionOfType(RuntimeException.class)
 				.isThrownBy(connected::dispose)
 	            .withMessage("Disconnected");

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -221,7 +221,7 @@ public void windowWillSubdivideAnInputFluxTime() {
 	}
 
 	@Test
-	public void windowWillAcumulateMultipleListsOfValues() {
+	public void windowWillAccumulateMultipleListsOfValues() {
 		//given: "a source and a collected flux"
 		EmitterProcessor<Integer> numbers = EmitterProcessor.create();
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowWhenTest.java
Patch:
@@ -260,7 +260,7 @@ public void oneWindowOnly() {
 
 
 	@Test
-	public void windowWillAcumulateMultipleListsOfValuesOverlap() {
+	public void windowWillAccumulateMultipleListsOfValuesOverlap() {
 		//given: "a source and a collected flux"
 		EmitterProcessor<Integer> numbers = EmitterProcessor.create();
 		EmitterProcessor<Integer> bucketOpening = EmitterProcessor.create();

File: reactor-core/src/test/java/reactor/core/publisher/MonoProcessorTest.java
Patch:
@@ -310,7 +310,7 @@ public void MonoProcessorMapFulfill() {
 	}
 
 	@Test
-	public void MonoProcessoThenFulfill() {
+	public void MonoProcessorThenFulfill() {
 		MonoProcessor<Integer> mp = MonoProcessor.create();
 
 		mp.onNext(1);

File: reactor-core/src/test/java/reactor/core/publisher/TopicProcessorTest.java
Patch:
@@ -56,7 +56,7 @@ public void createSmokeTest() {
 
 
 	@Test
-	public void testShutdownSuccessfullAfterAllDataIsRequested() throws InterruptedException {
+	public void testShutdownSuccessfulAfterAllDataIsRequested() throws InterruptedException {
 		TopicProcessor<String> processor = TopicProcessor.<String>builder().name("processor").bufferSize(4).build();
 		Publisher<String>
 				publisher = Flux.fromArray(new String[] { "1", "2", "3", "4", "5" });

File: reactor-core/src/test/java/reactor/core/scheduler/InstantPeriodicWorkerTaskTest.java
Patch:
@@ -38,11 +38,11 @@ public class InstantPeriodicWorkerTaskTest {
     @Test
     public void taskCrash() {
         ExecutorService exec = Executors.newSingleThreadExecutor();
-        Disposable.Composite composit = Disposables.composite();
+        Disposable.Composite composite = Disposables.composite();
         List<Throwable> throwables = prepareErrorHook();
 
         try {
-            InstantPeriodicWorkerTask task = new InstantPeriodicWorkerTask(errorRunnable, exec, composit);
+            InstantPeriodicWorkerTask task = new InstantPeriodicWorkerTask(errorRunnable, exec, composite);
 
             assertThat(task.call()).isNull();
             assertThat(throwables).containsOnly(exception);

File: reactor-core/src/test/java/reactor/core/scheduler/RejectedExecutionTest.java
Patch:
@@ -92,7 +92,7 @@ public void tearDown() {
 	}
 
 	/**
-	 * Test: onNext cannot be delivered due to RejectedExecutionExceptiob
+	 * Test: onNext cannot be delivered due to RejectedExecutionException
 	 * Current behaviour:
 	 *   No onNext, onError, onNextDropped, onErrorDropped generated
 	 *   Exception:
@@ -135,7 +135,7 @@ public void publishOnFilter() throws Exception {
 	}
 
 	/**
-	 * Test: onNext cannot be delivered due to RejectedExecutionExceptiob
+	 * Test: onNext cannot be delivered due to RejectedExecutionException
 	 * Current behaviour:
 	 *   No onNext, onError, onNextDropped, onErrorDropped generated
 	 *   Exception:

File: reactor-core/src/test/java/reactor/core/scheduler/TimedSchedulerTest.java
Patch:
@@ -50,7 +50,7 @@ public void independentWorkers() throws InterruptedException {
                 w1.schedule(() -> { });
                 Assert.fail("Failed to reject task");
             } catch (Throwable ex) {
-                // ingoring
+                // ignoring
             }
             
             w2.schedule(cdl::countDown);

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -53,6 +53,7 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.util.Metrics;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxSink.OverflowStrategy;
 import reactor.core.scheduler.Scheduler;
@@ -5738,7 +5739,7 @@ public final Flux<T> mergeWith(Publisher<? extends T> other) {
 	 * @return an instrumented {@link Flux}
 	 */
 	public final Flux<T> metrics() {
-		if (!FluxMetrics.isMicrometerAvailable()) {
+		if (!Metrics.isInstrumentationAvailable()) {
 			return this;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetricsFuseable.java
Patch:
@@ -33,7 +33,7 @@
  * Activate metrics gathering on a {@link Flux} (Fuseable version), assumes Micrometer is
  * on the classpath.
  *
- * @implNote Metrics.isMicrometerAvailable() test should be performed BEFORE instantiating
+ * @implNote Metrics.isInstrumentationAvailable() test should be performed BEFORE instantiating
  * or referencing this class, otherwise a {@link NoClassDefFoundError} will be thrown if
  * Micrometer is not there.
  *

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -44,6 +44,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
+import reactor.util.Metrics;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
@@ -2803,7 +2804,7 @@ public final Flux<T> mergeWith(Publisher<? extends T> other) {
 	 * @return an instrumented {@link Mono}
 	 */
 	public final Mono<T> metrics() {
-		if (!FluxMetrics.isMicrometerAvailable()) {
+		if (!Metrics.isInstrumentationAvailable()) {
 			return this;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java
Patch:
@@ -32,7 +32,7 @@
  * Activate metrics gathering on a {@link Mono} (Fuseable version), assumes Micrometer is
  * on the classpath.
  *
- * @implNote Metrics.isMicrometerAvailable() test should be performed BEFORE instantiating
+ * @implNote Metrics.isInstrumentationAvailable() test should be performed BEFORE instantiating
  * or referencing this class, otherwise a {@link NoClassDefFoundError} will be thrown if
  * Micrometer is not there.
  *

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -18,17 +18,15 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import jdk.nashorn.internal.codegen.CompilerConstants;
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
+
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
-import reactor.test.publisher.PublisherProbe;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatIllegalStateException;
 import static org.junit.Assert.assertTrue;
 
 public class MonoSourceTest {

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -190,14 +190,14 @@ public void onNext(T t) {
 
 		@Override
 		public void onError(Throwable t) {
-			actual.onError(t);
 			connection.upstreamFinished();
+			actual.onError(t);
 		}
 
 		@Override
 		public void onComplete() {
-			actual.onComplete();
 			connection.upstreamFinished();
+			actual.onComplete();
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java
Patch:
@@ -209,18 +209,18 @@ public void onNext(T t) {
 
 		@Override
 		public void onError(Throwable t) {
-			actual.onError(t);
 			if (PARENT_DONE.compareAndSet(this, 0, 1)) {
 				parent.terminated(connection);
 			}
+			actual.onError(t);
 		}
 
 		@Override
 		public void onComplete() {
-			actual.onComplete();
 			if (PARENT_DONE.compareAndSet(this, 0, 1)) {
 				parent.terminated(connection);
 			}
+			actual.onComplete();
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -980,7 +980,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single(GuideTests.java:944)\n");
+						.hasMessageEndingWith("Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:944)\n");
 			});
 		}
 	}

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -980,7 +980,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:945)\n");
+						.hasMessageEndingWith("Flux.single(GuideTests.java:944)\n");
 			});
 		}
 	}

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -984,7 +984,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single(GuideTests.java:949)\n");
+						.hasMessageEndingWith("Flux.single(GuideTests.java:948)\n");
 			});
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * A Processor implementation that takes a custom queue and allows
- * only a single subscriber. UnicastProcessor allows demultiplexing of the events which
+ * only a single subscriber. UnicastProcessor allows multiplexing of the events which
  * means that it supports multiple producers and only one consumer.
  * However, it should be noticed that multi-producer case is only valid if appropriate
  * Queue

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -159,11 +159,12 @@ public void subscribe(CoreSubscriber<? super R> actual) {
 			Function<T, R> f = t -> combiner.apply(new Object[]{t});
 			if (a[0] instanceof Fuseable) {
 				new FluxMapFuseable<>(from(a[0]), f).subscribe(actual);
+				return;
 			}
-			else {
+			else if (!(actual instanceof QueueSubscription)) {
 				new FluxMap<>(from(a[0]), f).subscribe(actual);
+				return;
 			}
-			return;
 		}
 
 		Queue<SourceAndArray> queue = queueSupplier.get();

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6540,7 +6540,7 @@ final Flux<T> publishOn(Scheduler scheduler, boolean delayError, int prefetch, i
 	}
 
 	/**
-	 * Reduce the values from this {@link Flux} sequence into an single object of the same
+	 * Reduce the values from this {@link Flux} sequence into a single object of the same
 	 * type than the emitted items. Reduction is performed using a {@link BiFunction} that
 	 * takes the intermediate result of the reduction and the current value and returns
 	 * the next intermediate value of the reduction. Note, {@link BiFunction} will not
@@ -6564,7 +6564,7 @@ public final Mono<T> reduce(BiFunction<T, T, T> aggregator) {
 	}
 
 	/**
-	 * Reduce the values from this {@link Flux} sequence into an single object matching the
+	 * Reduce the values from this {@link Flux} sequence into a single object matching the
 	 * type of a seed value. Reduction is performed using a {@link BiFunction} that
 	 * takes the intermediate result of the reduction and the current value and returns
 	 * the next intermediate value of the reduction. First element is paired with the seed
@@ -6585,7 +6585,7 @@ public final <A> Mono<A> reduce(A initial, BiFunction<A, ? super T, A> accumulat
 	}
 
 	/**
-	 * Reduce the values from this {@link Flux} sequence into an single object matching the
+	 * Reduce the values from this {@link Flux} sequence into a single object matching the
 	 * type of a lazily supplied seed value. Reduction is performed using a
 	 * {@link BiFunction} that takes the intermediate result of the reduction and the
 	 * current value and returns the next intermediate value of the reduction. First

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -694,7 +694,7 @@ public static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter) {
 	 * available backpressure modes
 	 * @param emitter Consume the {@link FluxSink} provided per-subscriber by Reactor to generate signals.
 	 * @return a {@link Flux}
-	 * @see #push(Consumer, OverflowStrategy)
+	 * @see #push(Consumer, reactor.core.publisher.FluxSink.OverflowStrategy)
 	 */
 	public static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter, OverflowStrategy backpressure) {
 		return onAssembly(new FluxCreate<>(emitter, backpressure, FluxCreate.CreateMode.PUSH_PULL));
@@ -745,7 +745,7 @@ public static <T> Flux<T> push(Consumer<? super FluxSink<T>> emitter) {
 	/**
 	 * Programmatically create a {@link Flux} with the capability of emitting multiple
 	 * elements from a single-threaded producer through the {@link FluxSink} API. For
-	 * a multi-threaded capable alternative, see {@link #create(Consumer, OverflowStrategy)}.
+	 * a multi-threaded capable alternative, see {@link #create(Consumer, reactor.core.publisher.FluxSink.OverflowStrategy)}.
 	 * <p>
 	 * This Flux factory is useful if one wants to adapt some other single-threaded
 	 * multi-valued async API and not worry about cancellation and backpressure (which is
@@ -782,7 +782,7 @@ public static <T> Flux<T> push(Consumer<? super FluxSink<T>> emitter) {
 	 * available backpressure modes
 	 * @param emitter Consume the {@link FluxSink} provided per-subscriber by Reactor to generate signals.
 	 * @return a {@link Flux}
-	 * @see #create(Consumer, OverflowStrategy)
+	 * @see #create(Consumer, reactor.core.publisher.FluxSink.OverflowStrategy)
 	 */
 	public static <T> Flux<T> push(Consumer<? super FluxSink<T>> emitter, OverflowStrategy backpressure) {
 		return onAssembly(new FluxCreate<>(emitter, backpressure, FluxCreate.CreateMode.PUSH_ONLY));

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1624,7 +1624,7 @@ public final Mono<T> cache(Duration ttl, Scheduler timer) {
 	 * @param ttlForValue the TTL-generating {@link Function} invoked when source is valued
 	 * @param ttlForError the TTL-generating {@link Function} invoked when source is erroring
 	 * @param ttlForEmpty the TTL-generating {@link Supplier} invoked when source is empty
-	 * @return
+	 * @return a replaying {@link Mono}
 	 */
 	public final Mono<T> cache(Function<? super T, Duration> ttlForValue,
 			Function<Throwable, Duration> ttlForError,

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -356,8 +356,8 @@ static final <R> Function<Context, Context> discardLocalAdapter(Class<R> type, C
 	 * testing purposes.
 	 *
 	 * @param target the original {@link Context}
-	 * @param discardConsumer
-	 * @return
+	 * @param discardConsumer the consumer that will be used to cleanup discarded elements
+	 * @return a new {@link Context} that holds (potentially combined) cleanup {@link Consumer}
 	 */
 	public static final Context enableOnDiscard(@Nullable Context target, Consumer<?> discardConsumer) {
 		Objects.requireNonNull(discardConsumer, "discardConsumer must be provided");

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4108,7 +4108,7 @@ public final Flux<T> doOnComplete(Runnable onComplete) {
 	 * @return a {@link Flux} that cleans up matching elements that get discarded upstream of it.
 	 */
 	public final <R> Flux<T> doOnDiscard(final Class<R> type, final Consumer<? super R> discardHook) {
-		return subscriberContext(Hooks.discardLocalAdapter(type, discardHook));
+		return subscriberContext(Operators.discardLocalAdapter(type, discardHook));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2011,7 +2011,7 @@ public final Mono<T> doOnCancel(Runnable onCancel) {
 	 * @return a {@link Mono} that cleans up matching elements that get discarded upstream of it.
 	 */
 	public final <R> Mono<T> doOnDiscard(final Class<R> type, final Consumer<? super R> discardHook) {
-		return subscriberContext(Hooks.discardLocalAdapter(type, discardHook));
+		return subscriberContext(Operators.discardLocalAdapter(type, discardHook));
 	}
 
 	/**

File: reactor-core/src/test/java/reactor/core/publisher/HooksTestStaticInit.java
Patch:
@@ -51,7 +51,6 @@ public void resetAllHooks() {
 //		Hooks.resetOnOperatorDebug(); //superseded by resetOnEachOperator
 		Hooks.resetOnEachOperator();
 		Hooks.resetOnLastOperator();
-		Hooks.resetOnDiscard();
 	}
 
 	@Test

File: reactor-test/src/test/java/reactor/test/DefaultStepVerifierBuilderTests.java
Patch:
@@ -41,7 +41,6 @@
  */
 public class DefaultStepVerifierBuilderTests {
 
-
 	@Test
 	public void subscribedTwice() {
 		Flux<String> flux = Flux.just("foo", "bar");

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -103,6 +103,7 @@ public void onError(Throwable t) {
 				return;
 			}
 			collection = null;
+			Operators.onDiscardMultiple(c, currentContext());
 			actual.onError(t);
 		}
 
@@ -119,6 +120,8 @@ public void onComplete() {
 
 		@Override
 		public void cancel() {
+			//specific discard of the collection
+			Operators.onDiscardMultiple(collection, currentContext());
 			super.cancel();
 			s.cancel();
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -195,7 +195,7 @@ public void onComplete() {
 					Publisher<? extends T> p = a[i];
 
 					if (p == null) {
-						actual.onError(new NullPointerException("The " + i + "th source Publisher is null"));
+						actual.onError(new NullPointerException("Source Publisher at index " + i + " is null"));
 						return;
 					}
 
@@ -291,7 +291,7 @@ public void onComplete() {
 					Publisher<? extends T> p = a[i];
 
 					if (p == null) {
-						actual.onError(new NullPointerException("The " + i + "th source Publisher is null"));
+						actual.onError(new NullPointerException("Source Publisher at index " + i + " is null"));
 						return;
 					}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -231,10 +231,10 @@ public void parallelFluxCheckpointDescriptionAndForceStack() {
 
 		String debugStack = sw.toString();
 
-		assertThat(debugStack).endsWith("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
+		assertThat(debugStack).contains("Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] :\n"
 				+ "\treactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:215)\n"
-				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)\n"
-				+ "Error has been observed by the following operator(s):\n"
+				+ "\treactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)\n");
+		assertThat(debugStack).endsWith("Error has been observed by the following operator(s):\n"
 				+ "\t|_\tParallelFlux.checkpoint ⇢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)\n\n");
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -1136,6 +1136,9 @@ static int unboundedOrLimit(int prefetch) {
 	}
 
 	static int unboundedOrLimit(int prefetch, int lowTide) {
+		if (lowTide <= 0) {
+			return prefetch;
+		}
 		if (lowTide >= prefetch) {
 			return unboundedOrLimit(prefetch);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -199,7 +199,7 @@ public void onSubscribe(Subscription s) {
 				if (s instanceof Fuseable.QueueSubscription) {
 					@SuppressWarnings("unchecked") Fuseable.QueueSubscription<T> f =
 							(Fuseable.QueueSubscription<T>) s;
-					int m = f.requestFusion(Fuseable.ANY);
+					int m = f.requestFusion(Fuseable.ANY | Fuseable.THREAD_BARRIER);
 					if (m == Fuseable.SYNC) {
 						sourceMode = Fuseable.SYNC;
 						queue = f;
@@ -538,7 +538,7 @@ public void onSubscribe(Subscription s) {
 					@SuppressWarnings("unchecked") Fuseable.QueueSubscription<T> f =
 							(Fuseable.QueueSubscription<T>) s;
 
-					int m = f.requestFusion(Fuseable.ANY);
+					int m = f.requestFusion(Fuseable.ANY | Fuseable.THREAD_BARRIER);
 
 					if (m == Fuseable.SYNC) {
 						sourceMode = Fuseable.SYNC;

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -216,7 +216,7 @@ public void onSubscribe(Subscription s) {
 					@SuppressWarnings("unchecked") Fuseable.QueueSubscription<T> f =
 							(Fuseable.QueueSubscription<T>) s;
 
-					int m = f.requestFusion(Fuseable.ANY);
+					int m = f.requestFusion(Fuseable.ANY | Fuseable.THREAD_BARRIER);
 					if (m == Fuseable.SYNC) {
 						sourceMode = m;
 						queue = f;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java
Patch:
@@ -68,9 +68,10 @@ protected void subscribe(CoreSubscriber<? super O>[] s) {
 
 		int i = 0;
 		while (i < subscribers.length) {
-			subscribers[i++] =
-					Objects.requireNonNull(lifter.apply(Scannable.from(source), s[i-1]),
+			subscribers[i] =
+					Objects.requireNonNull(lifter.apply(Scannable.from(source), s[i]),
 							"Lifted subscriber MUST NOT be null");
+			i++;
 		}
 
 		source.subscribe(subscribers);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLiftFuseable.java
Patch:
@@ -71,7 +71,7 @@ protected void subscribe(CoreSubscriber<? super O>[] s) {
 
 		int i = 0;
 		while (i < subscribers.length) {
-			CoreSubscriber<? super O> actual = s[i - 1];
+			CoreSubscriber<? super O> actual = s[i];
 			CoreSubscriber<? super I> converted =
 					Objects.requireNonNull(lifter.apply(Scannable.from(source), actual),
 							"Lifted subscriber MUST NOT be null");
@@ -84,7 +84,8 @@ protected void subscribe(CoreSubscriber<? super O>[] s) {
 				converted = new FluxHide.SuppressFuseableSubscriber<>(converted);
 			}
 			//otherwise QS is not required or user already made a compatible conversion
-			subscribers[i++] = converted;
+			subscribers[i] = converted;
+			i++;
 		}
 
 		source.subscribe(subscribers);

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -124,6 +124,7 @@ static final class SkipUntilMainSubscriber<T>
 			implements InnerOperator<T, T> {
 
 		final CoreSubscriber<? super T> actual;
+		final Context ctx;
 
 		volatile Subscription       main;
 
@@ -146,6 +147,7 @@ static final class SkipUntilMainSubscriber<T>
 
 		SkipUntilMainSubscriber(CoreSubscriber<? super T> actual) {
 			this.actual = Operators.serialize(actual);
+			this.ctx = actual.currentContext();
 		}
 
 		@Override
@@ -206,6 +208,7 @@ public void onNext(T t) {
 				actual.onNext(t);
 			}
 			else {
+				Operators.onDiscard(t, ctx);
 				main.request(1);
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -125,6 +125,7 @@ public void onNext(T t) {
 				return;
 			}
 			index = i - 1;
+			Operators.onDiscard(t, actual.currentContext()); //FIXME cache currentcontext
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreElements.java
Patch:
@@ -68,6 +68,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			// deliberately ignored
+			Operators.onDiscard(t, actual.currentContext()); //FIXME cache context
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -227,6 +227,7 @@ public Context currentContext() {
         @Override
         public void onNext(Object t) {
             // ignored
+            Operators.onDiscard(t, currentContext()); //FIXME cache Context
         }
         
         @Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -85,7 +85,9 @@ public Object scanUnsafe(Attr key) {
 
 		@Override
 		public void onNext(T t) {
+			T old = value;
 			value = t;
+			Operators.onDiscard(old, actual.currentContext()); //FIXME cache context
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/publisher/HooksTest.java
Patch:
@@ -59,6 +59,7 @@ public void resetAllHooks() {
 //		Hooks.resetOnOperatorDebug(); //superseded by resetOnEachOperator
 		Hooks.resetOnEachOperator();
 		Hooks.resetOnLastOperator();
+		Hooks.resetOnDiscard();
 	}
 
 	void simpleFlux(){

File: reactor-core/src/test/java/reactor/core/publisher/HooksTestStaticInit.java
Patch:
@@ -50,6 +50,7 @@ public void resetAllHooks() {
 //		Hooks.resetOnOperatorDebug(); //superseded by resetOnEachOperator
 		Hooks.resetOnEachOperator();
 		Hooks.resetOnLastOperator();
+		Hooks.resetOnDiscard();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -987,7 +987,7 @@ public void errorStrategyResumeDropsNext() {
 			    v -> { throw nextError; },
 			    null, null, null, null, null)
 			    .hide()
-			    .errorStrategyContinue((t, s) -> {
+			    .onErrorContinue((t, s) -> {
 					resumedErrors.add(t);
 					resumedValues.add(s);
 				});

File: reactor-core/src/test/java/reactor/util/concurrent/MpscLinkedQueueTest.java
Patch:
@@ -26,7 +26,7 @@ public void shouldRejectNullableValuesForTest() {
 	}
 
 	@Test
-	public void shouldNormallyOffersTwoValues() {
+	public void shouldNormallyOfferTwoValues() {
 		MpscLinkedQueue<Object> q = new MpscLinkedQueue<Object>();
 		q.test(1, 2);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -569,7 +569,7 @@ public void mainErrorWhileIsPropagatedToBothWindowAndMain() {
 	@Test
 	public void whileStartingSeveralSeparatorsEachCreateEmptyWindow() {
 		StepVerifier.create(Flux.just("#")
-		                        .repeat(10)
+		                        .repeat(9)
 		                        .concatWith(Flux.just("other", "value"))
 		                        .windowWhile(s -> !s.equals("#"))
 		                        .flatMap(Flux::count)
@@ -582,7 +582,7 @@ public void whileStartingSeveralSeparatorsEachCreateEmptyWindow() {
 	@Test
 	public void whileOnlySeparatorsGivesSequenceOfWindows() {
 		StepVerifier.create(Flux.just("#")
-		                        .repeat(10)
+		                        .repeat(9)
 		                        .windowWhile(s -> !s.equals("#"))
 		                        .flatMap(w -> w.count()))
 		            .expectNext(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L)

File: reactor-core/src/test/java/reactor/core/publisher/HooksTest.java
Patch:
@@ -655,7 +655,7 @@ public void parallelModeFused() {
 
 		Flux<Integer> source = Mono.just(1)
 		                           .flux()
-		                           .repeat(1000)
+		                           .repeat(999)
 		                           .publish()
 		                           .autoConnect();
 		int ncpu = Math.max(8,

File: reactor-core/src/main/java/reactor/core/publisher/FluxMetricsFuseable.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.List;
 
 import io.micrometer.core.instrument.Clock;
-import io.micrometer.core.instrument.Meter;
 import io.micrometer.core.instrument.MeterRegistry;
 import io.micrometer.core.instrument.Metrics;
 import io.micrometer.core.instrument.Tag;
@@ -72,8 +71,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		if (registryCandidate != null) {
 			registry = registryCandidate;
 		}
-		source.subscribe(new FluxMetrics.MicrometerMetricsFuseableSubscriber<>(actual, registry,
-				Clock.SYSTEM, this.name, this.tags, false));
+		source.subscribe(new FluxMetrics.MicrometerFluxMetricsFuseableSubscriber<>(actual, registry,
+				Clock.SYSTEM, this.name, this.tags));
 	}
 
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoMetricsFuseable.java
Patch:
@@ -24,7 +24,7 @@
 import io.micrometer.core.instrument.Tag;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.publisher.FluxMetrics.MicrometerMetricsFuseableSubscriber;
+import reactor.core.publisher.MonoMetrics.MicrometerMonoMetricsFuseableSubscriber;
 import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 
@@ -71,8 +71,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		if (registryCandidate != null) {
 			registry = registryCandidate;
 		}
-		source.subscribe(new MicrometerMetricsFuseableSubscriber<>(actual, registry,
-				Clock.SYSTEM, this.name, this.tags, true));
+		source.subscribe(new MicrometerMonoMetricsFuseableSubscriber<>(actual, registry,
+				Clock.SYSTEM, this.name, this.tags));
 	}
 
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java
Patch:
@@ -231,7 +231,7 @@ public void onNext(final T value) {
 					timespanRegistration = timer.schedule(flushTask, timespan, TimeUnit.MILLISECONDS);
 				}
 				catch (RejectedExecutionException ree) {
-					onError(Operators.onRejectedExecution(ree, this, null, value,
+					onError(Operators.onRejectedExecution(ree, subscription, null, value,
 							actual.currentContext()));
 					return;
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -84,8 +84,8 @@ public void subscribe(CoreSubscriber<? super BUFFER> actual) {
 
 		BufferWhenOpenSubscriber<OPEN> bos = new BufferWhenOpenSubscriber<>(main);
 		if (main.subscribers.add(bos)) {
-			source.subscribe(main);
 			start.subscribe(bos);
+			source.subscribe(main);
 		}
 	}
 
@@ -207,7 +207,7 @@ public void cancel() {
 				synchronized (this) {
 					buffers = null;
 				}
-				if (WINDOWS.getAndIncrement(this) != 0) {
+				if (WINDOWS.getAndIncrement(this) == 0) {
 					queue.clear();
 				}
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java
Patch:
@@ -231,7 +231,7 @@ public void onNext(final T value) {
 					timespanRegistration = timer.schedule(flushTask, timespan, TimeUnit.MILLISECONDS);
 				}
 				catch (RejectedExecutionException ree) {
-					onError(Operators.onRejectedExecution(ree, this, null, value,
+					onError(Operators.onRejectedExecution(ree, subscription, null, value,
 							actual.currentContext()));
 					return;
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -84,8 +84,8 @@ public void subscribe(CoreSubscriber<? super BUFFER> actual) {
 
 		BufferWhenOpenSubscriber<OPEN> bos = new BufferWhenOpenSubscriber<>(main);
 		if (main.subscribers.add(bos)) {
-			source.subscribe(main);
 			start.subscribe(bos);
+			source.subscribe(main);
 		}
 	}
 
@@ -207,7 +207,7 @@ public void cancel() {
 				synchronized (this) {
 					buffers = null;
 				}
-				if (WINDOWS.getAndIncrement(this) != 0) {
+				if (WINDOWS.getAndIncrement(this) == 0) {
 					queue.clear();
 				}
 			}

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
-import java.util.stream.Stream;
 
 import org.junit.Assert;
 import org.junit.Ignore;
@@ -105,7 +104,8 @@ public void onComplete() {
 		latch.await(8, TimeUnit.SECONDS);
 
 		long count = latch.getCount();
-		org.junit.Assert.assertTrue("Count > 0 : " + count + " (" + list + ")  , Running on " + Schedulers.DEFAULT_POOL_SIZE + " CPU",
+		org.junit.Assert.assertTrue("Count > 0 : " + count + " (" + list + ")  , Running on " +
+						Schedulers.DEFAULT_POOL_SIZE + " CPU",
 				latch.getCount() == 0);
 
 	}

File: reactor-core/src/test/java/reactor/core/scheduler/ParallelSchedulerTest.java
Patch:
@@ -166,7 +166,7 @@ public void scanName() {
 					.is(SchedulersTest.CACHED_SCHEDULER);
 			assertThat(Scannable.from(cached).scan(Scannable.Attr.NAME))
 					.as("default parallel()")
-					.isEqualTo("parallel(" + Runtime.getRuntime().availableProcessors() + ",\"parallel\")");
+					.isEqualTo("parallel(" + Schedulers.DEFAULT_POOL_SIZE + ",\"parallel\")");
 
 			assertThat(Scannable.from(workerWithNamedFactory).scan(Scannable.Attr.NAME))
 					.as("workerWithNamedFactory")

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -35,7 +35,7 @@
  * <a href="http://www.reactive-streams.org/">Reactive Streams Spec</a> contract is
  * violated.
  * <p>
- *      <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/master/src/docs/marble/directprocessornormal.png" alt="">
+ *      <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/directprocessornormal.png" alt="">
  * </p>
  *
  * </br>
@@ -52,7 +52,7 @@
  *     source through the processor to the Subscribers.
  *
  *     <p>
- *        <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/master/src/docs/marble/directprocessorerror.png" alt="">
+ *        <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/directprocessorerror.png" alt="">
  *     </p>
  * </p>
  *
@@ -65,7 +65,7 @@
  *      terminal signal to late subscribers.
  *
  *      <p>
- *         <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/master/src/docs/marble/directprocessorterminal.png" alt="">
+ *         <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/directprocessorterminal.png" alt="">
  *      </p>
  * </p>
  *

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -44,7 +44,7 @@
  * publish on different threads.
  *
  * <p>
- *      <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/master/src/docs/marble/unicastprocessornormal.png" alt="">
+ *      <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/unicastprocessornormal.png" alt="">
  * </p>
  *
  * </br>
@@ -67,7 +67,7 @@
  *      {@link reactor.core.Exceptions.OverflowException}).
  *
  *      <p>
- *         <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/master/src/docs/marble/unicastprocessoroverflow.png" alt="">
+ *         <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/unicastprocessoroverflow.png" alt="">
  *      </p>
  * </p>
  *
@@ -79,7 +79,7 @@
  *      case of terminal signal (completion or error signals) it will be postponed
  *      until all of the previous signals has been consumed.
  *      <p>
- *         <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/master/src/docs/marble/unicastprocessorterminal.png" alt="">
+ *         <img width="640" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.2.0.M2/src/docs/marble/unicastprocessorterminal.png" alt="">
  *      </p>
  * </p>
  *

File: reactor-core/src/main/java/reactor/core/publisher/FluxLift.java
Patch:
@@ -27,19 +27,19 @@
  */
 final class FluxLift<I, O> extends FluxOperator<I, O> {
 
-	final BiFunction<Scannable, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>>
+	final BiFunction<Publisher, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>>
 			lifter;
 
 	FluxLift(Publisher<I> p,
-			BiFunction<Scannable, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>> lifter) {
+			BiFunction<Publisher, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>> lifter) {
 		super(Flux.from(p));
 		this.lifter = lifter;
 	}
 
 	@Override
 	public void subscribe(CoreSubscriber<? super O> actual) {
 		CoreSubscriber<? super I> input =
-				lifter.apply(Scannable.from(source), actual);
+				lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxLiftFuseable.java
Patch:
@@ -45,19 +45,19 @@
 final class FluxLiftFuseable<I, O> extends FluxOperator<I, O>
 		implements Fuseable {
 
-	final BiFunction<Scannable, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>>
+	final BiFunction<Publisher, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>>
 			lifter;
 
 	FluxLiftFuseable(Publisher<I> p,
-			BiFunction<Scannable, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>> lifter) {
+			BiFunction<Publisher, ? super CoreSubscriber<? super O>, ? extends CoreSubscriber<? super I>> lifter) {
 		super(Flux.from(p));
 		this.lifter = lifter;
 	}
 
 	@Override
 	public void subscribe(CoreSubscriber<? super O> actual) {
 		CoreSubscriber<? super I> input =
-				lifter.apply(Scannable.from(source), actual);
+				lifter.apply(source, actual);
 
 		Objects.requireNonNull(input, "Lifted subscriber MUST NOT be null");
 

File: reactor-core/src/test/java/reactor/core/publisher/EventLoopProcessorTest.java
Patch:
@@ -143,6 +143,7 @@ public void awaitTerminationNanosLong() {
 				e.printStackTrace();
 			}
 		});
+		@SuppressWarnings("deprecation")
 		boolean shutResult = test.awaitAndShutdown(1000, TimeUnit.NANOSECONDS);
 		assertThat(test.executor)
 				.isNotNull()
@@ -172,6 +173,7 @@ public void awaitAndShutdownLongInterrupt() throws InterruptedException {
 				.when(executor).awaitTermination(anyLong(), any());
 		EventLoopProcessor<String> interruptingProcessor = initProcessor(executor);
 
+		@SuppressWarnings("deprecation")
 		boolean result = interruptingProcessor.awaitAndShutdown(100, TimeUnit.MILLISECONDS);
 
 		assertThat(Thread.currentThread().isInterrupted()).as("interrupted").isTrue();

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -261,7 +261,8 @@ public void concatArrayDelayErrorWithMonoError() {
 
 	@Test
 	public void scanOperator() {
-		FluxConcatArray s = new FluxConcatArray<>(true);
+		@SuppressWarnings("unchecked") //vararg of Publisher<String>
+		FluxConcatArray<String> s = new FluxConcatArray<>(true, Flux.empty());
 		assertThat(s.scan(Scannable.Attr.DELAY_ERROR)).as("delayError").isTrue();
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxJustTest.java
Patch:
@@ -90,7 +90,7 @@ public void fluxInitialValueAvailableImmediately() {
 
     @Test
     public void scanOperator() {
-    	FluxJust s = new FluxJust("foo");
+    	FluxJust<String> s = new FluxJust<>("foo");
     	assertThat(s.scan(Scannable.Attr.BUFFERED)).isEqualTo(1);
     }
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java
Patch:
@@ -323,7 +323,7 @@ public void scanOperator() {
 	@Test
 	public void scanSubscriber() {
 		CoreSubscriber<String> actual = new LambdaSubscriber<>(null, null, null, null);
-		BackpressureBufferTimeoutSubscriber test = new BackpressureBufferTimeoutSubscriber<>(actual, Duration.ofSeconds(1), Schedulers.immediate(), 123, v -> {});
+		BackpressureBufferTimeoutSubscriber<String> test = new BackpressureBufferTimeoutSubscriber<>(actual, Duration.ofSeconds(1), Schedulers.immediate(), 123, v -> {});
 		Subscription s = Operators.emptySubscription();
 		test.onSubscribe(s);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxStreamTest.java
Patch:
@@ -36,7 +36,7 @@ public class FluxStreamTest {
 	@SuppressWarnings("ConstantConditions")
 	@Test(expected = NullPointerException.class)
 	public void nullStream() {
-		Flux.fromStream((Stream) null);
+		Flux.fromStream((Stream<?>) null);
 	}
 
 	@SuppressWarnings("ConstantConditions")

File: reactor-core/src/test/java/reactor/core/publisher/ParallelSourceTest.java
Patch:
@@ -45,6 +45,7 @@ public void scanOperator() throws Exception {
 
 	@Test
 	public void scanMainSubscriber() {
+		@SuppressWarnings("unchecked")
 		CoreSubscriber<String>[] subs = new CoreSubscriber[1];
 		subs[0] = new LambdaSubscriber<>(null, e -> {}, null, null);
 		ParallelSource.ParallelSourceMain<String> test = new ParallelSource.ParallelSourceMain<>(
@@ -75,6 +76,7 @@ public void scanMainSubscriber() {
 
 	@Test
 	public void scanInnerSubscriber() {
+		@SuppressWarnings("unchecked")
 		CoreSubscriber<String>[] subs = new CoreSubscriber[2];
 		subs[0] = new LambdaSubscriber<>(null, e -> {}, null, null);
 		subs[1] = new LambdaSubscriber<>(null, e -> {}, null, null);

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -1145,7 +1145,7 @@ boolean isAllTasksCancelled() {
 		}
 
 		@Override
-		public void close() throws Exception {
+		public void close() {
 			shutdown();
 		}
 	}

File: reactor-core/src/test/java/reactor/util/context/Context1Test.java
Patch:
@@ -72,8 +72,8 @@ public void removeKeys() {
 	}
 
 	@Test
-	public void get() throws Exception {
-		assertThat((Object) c.get(1)).isEqualTo("A"); //TODO meh, necessary cast to Object
+	public void get() {
+		assertThat((String) c.get(1)).isEqualTo("A");
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -263,7 +263,7 @@ public Object scanUnsafe(Attr key) {
 		@Override
 		public void onSubscribe(Subscription s) {
 			if (Operators.setOnce(S, this, s)) {
-				s.request(Integer.MAX_VALUE);
+				s.request(Long.MAX_VALUE);
 			} else {
 				s.cancel();
 			}

File: reactor-core/src/test/java/reactor/core/publisher/TopicProcessorTest.java
Patch:
@@ -360,7 +360,7 @@ public void testDefaultRequestTaskThreadName() {
 
 
 		Condition<Thread> defaultRequestTaskThread = new Condition<>(
-				thread -> expectedName.equals(thread.getName()),
+				thread -> thread != null && expectedName.equals(thread.getName()),
 				"a thread named \"%s\"", expectedName);
 
 		Assertions.assertThat(threads)
@@ -390,7 +390,7 @@ public void testCustomRequestTaskThreadName() {
 		processor.forceShutdown();
 
 		Condition<Thread> customRequestTaskThread = new Condition<>(
-				thread -> expectedName.equals(thread.getName()),
+				thread -> thread != null && expectedName.equals(thread.getName()),
 				"a thread named \"%s\"", expectedName);
 
 		Assertions.assertThat(threads)
@@ -421,7 +421,7 @@ public void testCustomRequestTaskThreadShare() {
 		processor.forceShutdown();
 
 		Condition<Thread> customRequestTaskThread = new Condition<>(
-				thread -> expectedName.equals(thread.getName()),
+				thread -> thread != null && expectedName.equals(thread.getName()),
 				"a thread named \"%s\"", expectedName);
 
 		Assertions.assertThat(threads)

File: reactor-core/src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java
Patch:
@@ -967,7 +967,7 @@ public void testDefaultRequestTaskThreadName() {
 		processor.forceShutdown();
 
 		Condition<Thread> defaultRequestTaskThread = new Condition<>(
-				thread -> expectedName.equals(thread.getName()),
+				thread -> thread != null && expectedName.equals(thread.getName()),
 				"a thread named \"%s\"", expectedName);
 
 		Assertions.assertThat(threads)
@@ -998,7 +998,7 @@ public void testCustomRequestTaskThreadNameCreate() {
 		processor.forceShutdown();
 
 		Condition<Thread> customRequestTaskThread = new Condition<>(
-				thread -> expectedName.equals(thread.getName()),
+				thread -> thread != null && expectedName.equals(thread.getName()),
 				"a thread named \"%s\"", expectedName);
 
 		Assertions.assertThat(threads)
@@ -1029,7 +1029,7 @@ public void testCustomRequestTaskThreadNameShare() {
 		processor.forceShutdown();
 
 		Condition<Thread> customRequestTaskThread = new Condition<>(
-				thread -> expectedName.equals(thread.getName()),
+				thread -> thread != null && expectedName.equals(thread.getName()),
 				"a thread named \"%s\"", expectedName);
 
 		Assertions.assertThat(threads)

File: reactor-core/src/main/java/reactor/core/Disposables.java
Patch:
@@ -521,11 +521,11 @@ public boolean isDisposed() {
 	static final Disposable DISPOSED = disposed();
 
 	/**
-	 * Atomically push the field to a {@link Disposable} and dispose the old content.
+	 * Atomically set the field to a {@link Disposable} and dispose the old content.
 	 *
 	 * @param updater the target field updater
 	 * @param holder the target instance holding the field
-	 * @param newValue the new Disposable to push
+	 * @param newValue the new Disposable to set
 	 * @return true if successful, false if the field contains the {@link #DISPOSED} instance.
 	 */
 	static <T> boolean set(AtomicReferenceFieldUpdater<T, Disposable> updater, T holder, @Nullable Disposable newValue) {
@@ -552,7 +552,7 @@ static <T> boolean set(AtomicReferenceFieldUpdater<T, Disposable> updater, T hol
 	 *
 	 * @param updater the target field updater
 	 * @param holder the target instance holding the field
-	 * @param newValue the new Disposable to push, null allowed
+	 * @param newValue the new Disposable to set, null allowed
 	 * @return true if the operation succeeded, false if the target field contained
 	 * the common {@link #DISPOSED} instance and the given disposable is not null but is disposed.
 	 */

File: reactor-core/src/main/java/reactor/core/Exceptions.java
Patch:
@@ -347,7 +347,7 @@ public static <T> Throwable terminate(AtomicReferenceFieldUpdater<T, Throwable>
 	}
 
 	/**
-	 * Throws a particular {@code Throwable} only if it belongs to a push of "fatal" error
+	 * Throws a particular {@code Throwable} only if it belongs to a set of "fatal" error
 	 * varieties. These varieties are as follows: <ul>
 	 *     <li>{@code BubblingException} (as detectable by {@link #isBubbling(Throwable)})</li>
 	 *     <li>{@code ErrorCallbackNotImplemented} (as detectable by {@link #isErrorCallbackNotImplemented(Throwable)})</li>
@@ -366,7 +366,7 @@ public static void throwIfFatal(@Nullable Throwable t) {
 	}
 
 	/**
-	 * Throws a particular {@code Throwable} only if it belongs to a push of "fatal" error
+	 * Throws a particular {@code Throwable} only if it belongs to a set of "fatal" error
 	 * varieties native to the JVM. These varieties are as follows:
 	 * <ul> <li>{@link VirtualMachineError}</li> <li>{@link ThreadDeath}</li>
 	 * <li>{@link LinkageError}</li> </ul>

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -174,7 +174,7 @@ class Attr<T> {
 		 * Prefetch is an {@link Integer} attribute defining the rate of processing in a
 		 * component which has capacity to request and hold a backlog of data. It
 		 * usually maps to a component capacity when no arbitrary {@link #CAPACITY} is
-		 * push. {@link Integer#MAX_VALUE} signal unlimited capacity and therefore
+		 * set. {@link Integer#MAX_VALUE} signal unlimited capacity and therefore
 		 * unbounded demand.
 		 * <p>
 		 * Note: This attribute usually resolves to a constant value.

File: reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java
Patch:
@@ -195,7 +195,7 @@ public final void onComplete() {
 				hookOnComplete();
 			}
 			catch (Throwable throwable) {
-				//onError itself will short-circuit due to the CancelledSubscription being push above
+				//onError itself will short-circuit due to the CancelledSubscription being set above
 				hookOnError(Operators.onOperatorError(throwable, currentContext()));
 			}
 			finally {

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -73,7 +73,7 @@
  * </br>
  *
  * <p>
- *      <b>Note: </b> The implementation ignores Subscriptions push via onSubscribe.
+ *      <b>Note: </b> The implementation ignores Subscriptions set via onSubscribe.
  * </p>
  *
  * @param <T> the input and output value type

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -28,7 +28,7 @@
 import reactor.util.annotation.Nullable;
 
 /**
- * Given a push of source Publishers the values of that Publisher is forwarded to the
+ * Given a set of source Publishers the values of that Publisher is forwarded to the
  * subscriber which responds first with any signal.
  *
  * @param <T> the value type

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -252,7 +252,7 @@ public Stream<? extends Scannable> inners() {
 		void signalAsyncError() {
 			Throwable e = Exceptions.terminate(ERROR, this); //TODO investigate if e == null
 			if (e == null) {
-				e = new IllegalStateException("FluxGroupBy.signalAsyncError called without error push");
+				e = new IllegalStateException("FluxGroupBy.signalAsyncError called without error set");
 			}
 			groupCount = 0;
 			for (UnicastGroupedFlux<K, V> g : groupMap.values()) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -52,7 +52,7 @@ final class FluxOnAssembly<T> extends FluxOperator<T, T> implements Fuseable,
 	final AssemblySnapshotException snapshotStack;
 
 	/**
-	 * If push to true, the creation of FluxOnAssembly will capture the raw stacktrace
+	 * If set to true, the creation of FluxOnAssembly will capture the raw stacktrace
 	 * instead of the sanitized version.
 	 */
 	static final boolean fullStackTrace = Boolean.parseBoolean(System.getProperty(

File: reactor-core/src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -35,7 +35,7 @@
 import reactor.util.context.Context;
 
 /**
- * A push of overridable lifecycle hooks that can be used for cross-cutting
+ * A set of overridable lifecycle hooks that can be used for cross-cutting
  * added behavior on {@link Flux}/{@link Mono} operators.
  */
 public abstract class Hooks {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -649,7 +649,7 @@ public static  Mono<Context> subscriberContext() {
 	 * @param resourceSupplier a {@link Callable} that is called on subscribe to create the resource
 	 * @param sourceSupplier a {@link Mono} factory to create the Mono depending on the created resource
 	 * @param resourceCleanup invoked on completion to clean-up the resource
-	 * @param eager push to true to clean before terminating downstream subscribers
+	 * @param eager set to true to clean before terminating downstream subscribers
 	 * @param <T> emitted type
 	 * @param <D> resource type
 	 *
@@ -1597,7 +1597,7 @@ public final Mono<T> checkpoint(String description) {
 	 * It should be placed towards the end of the reactive chain, as errors
 	 * triggered downstream of it cannot be observed and augmented with assembly marker.
 	 *
-	 * @param description a description (must be unique enough if forceStackTrace is push
+	 * @param description a description (must be unique enough if forceStackTrace is set
 	 * to false).
 	 * @param forceStackTrace false to make a light checkpoint without a stacktrace, true
 	 * to use a stack trace.

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -24,7 +24,7 @@
 import reactor.util.annotation.Nullable;
 
 /**
- * Given a push of source Publishers the values of that Publisher is forwarded to the
+ * Given a set of source Publishers the values of that Publisher is forwarded to the
  * actual which responds first with any signal.
  *
  * @param <T> the value type

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -32,7 +32,7 @@
 
 /**
  * Concatenates a several Mono sources with a final Mono source by
- * ignoring values from the first push of sources and emitting the value
+ * ignoring values from the first set of sources and emitting the value
  * the last Mono source generates.
  *
  * @param <T> the final value type
@@ -60,7 +60,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
      * Shifts the current last Mono into the ignore array and sets up a new last Mono instance.
      * @param <U> the new last value type
      * @param newLast the new last Mono instance
-     * @return the new operator push up
+     * @return the new operator set up
      */
     <U> MonoIgnoreThen<U> shift(Mono<U> newLast) {
         Objects.requireNonNull(newLast, "newLast");

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -205,7 +205,7 @@ public final ParallelFlux<T> checkpoint(String description) {
 	 * It should be placed towards the end of the reactive chain, as errors
 	 * triggered downstream of it cannot be observed and augmented with assembly marker.
 	 *
-	 * @param description a description (must be unique enough if forceStackTrace is push
+	 * @param description a description (must be unique enough if forceStackTrace is set
 	 * to false).
 	 * @param forceStackTrace false to make a light checkpoint without a stacktrace, true
 	 * to use a stack trace.

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -145,7 +145,7 @@ public static <E> ReplayProcessor<E> create(int historySize, boolean unbounded)
 	 * In this setting, the {@code ReplayProcessor} internally tags each observed item
 	 * with a timestamp value supplied by the {@link Schedulers#parallel()} and keeps only
 	 * those whose age is less than the supplied time value converted to milliseconds. For
-	 * example, an item arrives at T=0 and the max age is push to 5; at T&gt;=5 this first
+	 * example, an item arrives at T=0 and the max age is set to 5; at T&gt;=5 this first
 	 * item is then evicted by any subsequent item or termination signal, leaving the
 	 * buffer empty.
 	 * <p>
@@ -180,7 +180,7 @@ public static <T> ReplayProcessor<T> createTimeout(Duration maxAge) {
 	 * In this setting, the {@code ReplayProcessor} internally tags each observed item
 	 * with a timestamp value supplied by the {@link Scheduler} and keeps only
 	 * those whose age is less than the supplied time value converted to milliseconds. For
-	 * example, an item arrives at T=0 and the max age is push to 5; at T&gt;=5 this first
+	 * example, an item arrives at T=0 and the max age is set to 5; at T&gt;=5 this first
 	 * item is then evicted by any subsequent item or termination signal, leaving the
 	 * buffer empty.
 	 * <p>

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -43,7 +43,7 @@
  * The maximum number of created thread pools is unbounded.
  * <p>
  * The default time-to-live for unused thread pools is 60 seconds, use the
- * appropriate constructor to push a different value.
+ * appropriate constructor to set a different value.
  * <p>
  * This scheduler is not restartable (may be later).
  *

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -271,7 +271,7 @@ public void scanMain() {
 		FluxCombineLatest.CombineLatestCoordinator<String, Integer> test = new FluxCombineLatest.CombineLatestCoordinator<>(
 				actual, arr -> { throw new IllegalStateException("boomArray");}, 123, Queues.<FluxCombineLatest.SourceAndArray>one().get(), 456);
 		test.request(2L);
-		test.error = new IllegalStateException("boom"); //most straightforward way to push it as otherwise it is drained
+		test.error = new IllegalStateException("boom"); //most straightforward way to set it as otherwise it is drained
 
 		assertThat(test.scan(Scannable.Attr.REQUESTED_FROM_DOWNSTREAM)).isEqualTo(2L);
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -307,7 +307,7 @@ public final void sequenceOfNextAndError() {
 	//common n unused item or dropped
 	protected final I item(int i) {
 		if (defaultScenario.producingMapper == null) {
-			throw Exceptions.bubble(new Exception("No producer push in " + "defaultScenario"));
+			throw Exceptions.bubble(new Exception("No producer set in " + "defaultScenario"));
 		}
 		return defaultScenario.producingMapper
 		                      .apply(i);
@@ -316,14 +316,14 @@ protected final I item(int i) {
 	//unprocessable exception (dropped)
 	protected final RuntimeException droppedException() {
 		if (defaultScenario.droppedError == null) {
-			throw Exceptions.bubble(new Exception("No dropped exception push in " + "defaultScenario"));
+			throw Exceptions.bubble(new Exception("No dropped exception set in " + "defaultScenario"));
 		}
 		return defaultScenario.droppedError;
 	}
 
 	protected final RuntimeException exception() {
 		if (defaultScenario.producerError == null) {
-			throw Exceptions.bubble(new Exception("No exception push in " + "defaultScenario"));
+			throw Exceptions.bubble(new Exception("No exception set in " + "defaultScenario"));
 		}
 		return defaultScenario.producerError;
 	}

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -304,7 +304,7 @@ static <T> FirstStep<T> withVirtualTime(
 
 	/**
 	 * Verify the signals received by this subscriber. Unless a default timeout has been
-	 * push before construction of the {@link StepVerifier} via {@link StepVerifier#setDefaultTimeout(Duration)},
+	 * set before construction of the {@link StepVerifier} via {@link StepVerifier#setDefaultTimeout(Duration)},
 	 * this method will <strong>block</strong> until the stream has been terminated
 	 * (either through {@link Subscriber#onComplete()}, {@link Subscriber#onError(Throwable)} or
 	 * {@link Subscription#cancel()}). Depending on the declared expectations and actions,

File: reactor-test/src/main/java/reactor/test/StepVerifierOptions.java
Patch:
@@ -38,7 +38,7 @@ public class StepVerifierOptions {
 	private Context initialContext;
 
 	/**
-	 * Create a new default push of options for a {@link StepVerifier} that can be tuned
+	 * Create a new default set of options for a {@link StepVerifier} that can be tuned
 	 * using the various available non-getter methods (which can be chained).
 	 */
 	public static StepVerifierOptions create() {

File: reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java
Patch:
@@ -52,7 +52,7 @@ public static <T> TestPublisher<T> create() {
 
 	/**
 	 * Create a {@link Violation noncompliant} {@link TestPublisher}
-	 * with a given push of reactive streams spec violations that will be overlooked.
+	 * with a given set of reactive streams spec violations that will be overlooked.
 	 *
 	 * @param first the first allowed {@link Violation}
 	 * @param rest additional optional violations
@@ -147,7 +147,7 @@ public static <T> TestPublisher<T> createNoncompliant(Violation first, Violation
 	/**
 	 * Send 1 {@link Subscriber#onNext(Object) onNext} signal to the subscribers.
 	 *
-	 * @param value the item to emit (can be null if the relevant {@link Violation} is push)
+	 * @param value the item to emit (can be null if the relevant {@link Violation} is set)
 	 * @return this {@link TestPublisher} for chaining.
 	 */
 	public abstract TestPublisher<T> next(@Nullable T value);

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -62,7 +62,7 @@ public static VirtualTimeScheduler create() {
 	 * factories. While the method is thread safe, its usually advised to execute such
 	 * wide-impact BEFORE all tested code runs (setup etc). The created scheduler is returned.
 	 *
-	 * @return the VirtualTimeScheduler that was created and push through the factory
+	 * @return the VirtualTimeScheduler that was created and set through the factory
 	 */
 	public static VirtualTimeScheduler getOrSet() {
 		return enable(VirtualTimeScheduler::new, false);
@@ -132,7 +132,7 @@ static VirtualTimeScheduler enable(Supplier<VirtualTimeScheduler>
 			}
 			VirtualTimeScheduler newS = schedulerSupplier.get();
 			if (newS == CURRENT.get()) {
-				return newS; //nothing to do, it has already been push in the past
+				return newS; //nothing to do, it has already been set in the past
 			}
 
 			if (CURRENT.compareAndSet(s, newS)) {

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -1373,7 +1373,7 @@ public void noCancelOnErrorWhenCollectUnexpected() {
 	}
 
 	//TODO records: find a way to test the case where supplied collection is null, and signal is complete/error
-	//TODO records: find a way to test the case where there hasn't been a recorder push, and signal is complete/error
+	//TODO records: find a way to test the case where there hasn't been a recorder set, and signal is complete/error
 
 	@Test
 	public void cancelOnUnexpectedNextWithMoreData() {

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -289,7 +289,7 @@ public void advancedBatchingWindowing() {
 		            .expectNext(-1, -1, -1) //respectively triggered by odd 1 3 5
 	                .expectNext(2, 4, 6) // triggered by 11
 	                .expectNext(12) // triggered by 13
-	                .expectNext(-1) // empty completion window, would have been omitted if all matched before onComplete
+	                // however, no empty completion window is emitted (would contain extra matching elements)
 	                .verifyComplete();
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3684,9 +3684,8 @@ public final CompletableFuture<T> toFuture() {
 
 	/**
 	 * Wrap this {@link Mono} into a {@link MonoProcessor} (turning it hot and allowing to block,
-	 * cancel, as well as many other operations). Note that the {@link MonoProcessor} is
-	 * {@link MonoProcessor#connect() connected to} (which is equivalent to calling subscribe
-	 * on it).
+	 * cancel, as well as many other operations). Note that the {@link MonoProcessor}
+	 * is subscribed to its parent source if any.
 	 *
 	 * <p>
 	 * <img width="500" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/unbounded1.png" alt="">

File: reactor-core/src/test/java/reactor/core/CompositeDisposableTest.java
Patch:
@@ -23,7 +23,7 @@
 import reactor.core.Disposables.CompositeDisposable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.Test;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/ExceptionsTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import org.junit.Before;
 import org.junit.Test;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;

File: reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java
Patch:
@@ -34,11 +34,11 @@
 import reactor.core.publisher.FluxExpand.ExpandDepthSubscriber;
 import reactor.core.publisher.FluxExpand.ExpandDepthSubscription;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java
Patch:
@@ -28,9 +28,9 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java
Patch:
@@ -25,10 +25,10 @@
 import org.junit.Test;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.MonoOperatorTest;
 import reactor.test.publisher.TestPublisher;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java
Patch:
@@ -30,11 +30,11 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -22,7 +22,7 @@
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -36,7 +36,7 @@
 import reactor.core.publisher.Operators.MonoSubscriber;
 import reactor.core.publisher.Operators.MultiSubscriptionSubscriber;
 import reactor.core.publisher.Operators.ScalarSubscription;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/scheduler/WorkerTaskTest.java
Patch:
@@ -26,8 +26,7 @@
 import org.junit.Test;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
-import reactor.core.publisher.Hooks;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Fail.fail;

File: reactor-core/src/test/java/reactor/core/CompositeDisposableTest.java
Patch:
@@ -23,7 +23,7 @@
 import reactor.core.Disposables.CompositeDisposable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

File: reactor-core/src/test/java/reactor/core/DisposablesTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.Test;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/ExceptionsTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import org.junit.Before;
 import org.junit.Test;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;

File: reactor-core/src/test/java/reactor/core/publisher/FluxExpandTest.java
Patch:
@@ -34,11 +34,11 @@
 import reactor.core.publisher.FluxExpand.ExpandDepthSubscriber;
 import reactor.core.publisher.FluxExpand.ExpandDepthSubscription;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/FluxLimitRequestTest.java
Patch:
@@ -28,9 +28,9 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoCacheTimeTest.java
Patch:
@@ -25,10 +25,10 @@
 import org.junit.Test;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.MonoOperatorTest;
 import reactor.test.publisher.TestPublisher;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

File: reactor-core/src/test/java/reactor/core/publisher/MonoExpandTest.java
Patch:
@@ -30,11 +30,11 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
 import reactor.test.StepVerifier;
 import reactor.test.StepVerifierOptions;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/OperatorDisposablesTest.java
Patch:
@@ -22,7 +22,7 @@
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.core.scheduler.Schedulers;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -39,7 +39,7 @@
 import reactor.core.publisher.Operators.MonoSubscriber;
 import reactor.core.publisher.Operators.MultiSubscriptionSubscriber;
 import reactor.core.publisher.Operators.ScalarSubscription;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: reactor-core/src/test/java/reactor/core/scheduler/WorkerTaskTest.java
Patch:
@@ -27,8 +27,7 @@
 import org.junit.Test;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
-import reactor.core.publisher.Hooks;
-import reactor.test.RaceTestUtils;
+import reactor.test.util.RaceTestUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Fail.fail;

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3675,6 +3675,9 @@ public final Flux<T> doOnComplete(Runnable onComplete) {
 	 * @see Signal
 	 */
 	public final Flux<T> doOnEach(Consumer<? super Signal<T>> signalConsumer) {
+		if (this instanceof Fuseable) {
+			return onAssembly(new FluxDoOnEachFuseable<>(this, signalConsumer));
+		}
 		return onAssembly(new FluxDoOnEach<>(this, signalConsumer));
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1774,6 +1774,9 @@ public final Mono<T> doOnSuccess(Consumer<? super T> onSuccess) {
 	 */
 	public final Mono<T> doOnEach(Consumer<? super Signal<T>> signalConsumer) {
 		Objects.requireNonNull(signalConsumer, "signalConsumer");
+		if (this instanceof Fuseable) {
+			return onAssembly(new MonoDoOnEachFuseable<>(this, signalConsumer));
+		}
 		return onAssembly(new MonoDoOnEach<>(this, signalConsumer));
 
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoOnEach.java
Patch:
@@ -39,8 +39,6 @@ final class MonoDoOnEach<T> extends MonoOperator<T, T> {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		//TODO fuseable version?
-		//TODO conditional version?
-		source.subscribe(new FluxDoOnEach.DoOnEachSubscriber<>(actual, onSignal));
+		source.subscribe(FluxDoOnEach.createSubscriber(actual, onSignal, false));
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -32,7 +31,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxArray<T> extends Flux<T> implements Fuseable, Scannable {
+final class FluxArray<T> extends Flux<T> implements Fuseable, SourceProducer<T> {
 
 	final T[] array;
 
@@ -64,6 +63,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 	@Override
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.BUFFERED) return array.length;
+
 		return null;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -20,16 +20,14 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
  * For each subscriber, a Supplier is invoked and the returned value emitted.
  *
  * @param <T> the value type;
  */
-final class FluxCallable<T> extends Flux<T>
-		implements Callable<T>, Fuseable, Scannable {
+final class FluxCallable<T> extends Flux<T> implements Callable<T>, Fuseable, SourceProducer<T> {
 
 	final Callable<T> callable;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -44,7 +44,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxCombineLatest<T, R> extends Flux<R> implements Fuseable, Scannable {
+final class FluxCombineLatest<T, R> extends Flux<R> implements Fuseable, SourceProducer<R> {
 
 	final Publisher<? extends T>[] array;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -31,7 +30,7 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxConcatArray<T> extends Flux<T> implements Scannable {
+final class FluxConcatArray<T> extends Flux<T> implements SourceProducer<T> {
 
 	final Publisher<? extends T>[] array;
 	

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatIterable.java
Patch:
@@ -22,7 +22,6 @@
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Concatenates a fixed array of Publishers' values.
@@ -31,7 +30,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxConcatIterable<T> extends Flux<T> implements Scannable {
+final class FluxConcatIterable<T> extends Flux<T> implements SourceProducer<T> {
 
 	final Iterable<? extends Publisher<? extends T>> iterable;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -42,7 +42,7 @@
  *
  * @param <T> the value type
  */
-final class FluxCreate<T> extends Flux<T> implements Scannable {
+final class FluxCreate<T> extends Flux<T> implements SourceProducer<T> {
 
 	enum CreateMode {
 		PUSH_ONLY, PUSH_PULL

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
@@ -30,7 +29,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxDefer<T> extends Flux<T> implements Scannable {
+final class FluxDefer<T> extends Flux<T> implements SourceProducer<T> {
 
 	final Supplier<? extends Publisher<? extends T>> supplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -18,7 +18,6 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -29,7 +28,7 @@
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxEmpty extends Flux<Object>
-		implements Fuseable.ScalarCallable<Object>, Scannable {
+		implements Fuseable.ScalarCallable<Object>, SourceProducer<Object> {
 
 	private static final Flux<Object> INSTANCE = new FluxEmpty();
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -22,7 +22,6 @@
 import reactor.core.Fuseable;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Emits a constant or generated Throwable instance to Subscribers.
@@ -31,8 +30,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxError<T> extends Flux<T>
-		implements Fuseable.ScalarCallable, Scannable {
+final class FluxError<T> extends Flux<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
 
 	final Throwable error;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorOnRequest.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -31,7 +30,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxErrorOnRequest<T> extends Flux<T> implements Scannable {
+final class FluxErrorOnRequest<T> extends Flux<T> implements SourceProducer<T> {
 
 	final Throwable error;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorSupplied.java
Patch:
@@ -38,7 +38,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 
 /**
  * Emits a generated {@link Throwable} instance to Subscribers, lazily generated via a
@@ -48,8 +47,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxErrorSupplied<T> extends Flux<T>
-		implements Fuseable.ScalarCallable, Scannable {
+final class FluxErrorSupplied<T> extends Flux<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
 
 	final Supplier<Throwable> errorSupplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -35,7 +35,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxFirstEmitting<T> extends Flux<T> implements Scannable {
+final class FluxFirstEmitting<T> extends Flux<T> implements SourceProducer<T> {
 
 	final Publisher<? extends T>[] array;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -24,7 +24,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
 
@@ -39,7 +38,8 @@
  * @param <S> the custom state per subscriber
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
-final class FluxGenerate<T, S> extends Flux<T> implements Fuseable, Scannable {
+final class FluxGenerate<T, S>
+extends Flux<T> implements Fuseable, SourceProducer<T> {
 
 
 	static final Callable EMPTY_CALLABLE = () -> null;

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -33,7 +33,7 @@
  * or a custom async callback function
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxInterval extends Flux<Long> implements Scannable {
+final class FluxInterval extends Flux<Long> implements SourceProducer<Long> {
 
 	final Scheduler timedScheduler;
 	

File: reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -24,7 +24,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 
@@ -35,7 +34,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxIterable<T> extends Flux<T> implements Fuseable, Scannable {
+final class FluxIterable<T> extends Flux<T> implements Fuseable, SourceProducer<T> {
 
 	final Iterable<? extends T> iterable;
 	private final Runnable      onClose;

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -21,7 +21,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -52,7 +51,8 @@
  * @author Stephane Maldini
  */
 final class FluxJust<T> extends Flux<T>
-		implements Fuseable.ScalarCallable<T>, Fuseable, Scannable {
+		implements Fuseable.ScalarCallable<T>, Fuseable,
+		           SourceProducer<T> {
 
 	final T value;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMerge.java
Patch:
@@ -22,14 +22,13 @@
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Merges a fixed array of Publishers.
  * @param <T> the element type of the publishers
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxMerge<T> extends Flux<T> implements Scannable {
+final class FluxMerge<T> extends Flux<T> implements SourceProducer<T> {
 
 	final Publisher<? extends T>[] sources;
 	

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeOrdered.java
Patch:
@@ -44,7 +44,7 @@
  * @author Simon Baslé
  */
 //source: http://akarnokd.blogspot.fr/2017/09/java-9-flow-api-ordered-merge.html
-final class FluxMergeOrdered<T> extends Flux<T> implements Scannable {
+final class FluxMergeOrdered<T> extends Flux<T> implements SourceProducer<T> {
 
 	final int                      prefetch;
 	final Supplier<Queue<T>>       queueSupplier;

File: reactor-core/src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -17,7 +17,6 @@
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Represents an never publisher which only calls onSubscribe.
@@ -27,7 +26,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxNever extends Flux<Object> implements Scannable {
+final class FluxNever extends Flux<Object> implements SourceProducer<Object> {
 
 	static final Publisher<Object> INSTANCE = new FluxNever();
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -20,15 +20,15 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
  * Emits a range of integer values.
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxRange extends Flux<Integer> implements Fuseable, Scannable {
+final class FluxRange extends Flux<Integer>
+		implements Fuseable, SourceProducer<Integer> {
 
 	final long start;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -27,7 +27,7 @@
  *
  * @param <I> Upstream type
  */
-final class FluxSource<I> extends Flux<I> implements Scannable {
+final class FluxSource<I> extends Flux<I> implements SourceProducer<I> {
 
 
 	final Publisher<? extends I> source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceFuseable.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * @author Stephane Maldini
  */
-final class FluxSourceFuseable<I> extends Flux<I> implements Fuseable, Scannable {
+final class FluxSourceFuseable<I> extends Flux<I> implements Fuseable, SourceProducer<I> {
 
 	final Publisher<? extends I> source;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -23,7 +23,6 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 
 /**
  * Emits the contents of a Stream source.
@@ -32,7 +31,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxStream<T> extends Flux<T> implements Fuseable, Scannable {
+final class FluxStream<T> extends Flux<T> implements Fuseable, SourceProducer<T> {
 
 	final Supplier<? extends Stream<? extends T>> streamSupplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -27,7 +27,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -46,7 +45,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxUsing<T, S> extends Flux<T> implements Fuseable, Scannable {
+final class FluxUsing<T, S> extends Flux<T> implements Fuseable, SourceProducer<T> {
 
 	final Callable<S> resourceSupplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -50,7 +50,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxZip<T, R> extends Flux<R> implements Scannable {
+final class FluxZip<T, R> extends Flux<R> implements SourceProducer<R> {
 
 	final Publisher<? extends T>[] sources;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -22,7 +22,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -34,7 +33,7 @@
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoCallable<T> extends Mono<T>
-		implements Callable<T>, Fuseable, Scannable {
+		implements Callable<T>, Fuseable, SourceProducer<T> {
 
 	final Callable<? extends T> callable;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -25,7 +25,6 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
-import reactor.core.Scannable;
 import reactor.core.publisher.FluxCreate.SinkDisposable;
 import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
@@ -36,7 +35,7 @@
  *
  * @param <T> the value type
  */
-final class MonoCreate<T> extends Mono<T> implements Scannable {
+final class MonoCreate<T> extends Mono<T> implements SourceProducer<T> {
 
 	final Consumer<MonoSink<T>> callback;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.function.Supplier;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
@@ -29,7 +28,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoDefer<T> extends Mono<T> implements Scannable {
+final class MonoDefer<T> extends Mono<T> implements SourceProducer<T> {
 
 	final Supplier<? extends Mono<? extends T>> supplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -34,7 +34,7 @@
  * wraps other form of async-delayed execution of tasks.
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoDelay extends Mono<Long> implements Scannable {
+final class MonoDelay extends Mono<Long> implements Scannable,  SourceProducer<Long>  {
 
 	final Scheduler timedScheduler;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -20,7 +20,6 @@
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -31,8 +30,9 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoEmpty extends Mono<Object>
-		implements Fuseable.ScalarCallable<Object>, Scannable {
+final class MonoEmpty 
+extends Mono<Object>
+		implements Fuseable.ScalarCallable<Object>, SourceProducer<Object>  {
 
 	static final Publisher<Object> INSTANCE = new MonoEmpty();
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -21,16 +21,15 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
+
 
 /**
  * Emits a constant or generated Throwable instance to Subscribers.
  *
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoError<T> extends Mono<T>
-		implements Fuseable.ScalarCallable, Scannable {
+final class MonoError<T> extends Mono<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
 
 	final Throwable error;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoErrorSupplied.java
Patch:
@@ -38,16 +38,14 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 
 /**
  * Emits a lazily generated {@link Throwable} instance to Subscribers, via a {@link Supplier}.
  *
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoErrorSupplied<T> extends Mono<T>
-		implements Fuseable.ScalarCallable, Scannable {
+final class MonoErrorSupplied<T> extends Mono<T> implements Fuseable.ScalarCallable, SourceProducer<T> {
 
 	final Supplier<Throwable> errorSupplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -32,7 +31,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoFirst<T> extends Mono<T> implements Scannable {
+final class MonoFirst<T> extends Mono<T> implements SourceProducer<T>  {
 
 	final Mono<? extends T>[] array;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -20,13 +20,13 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoJust<T> extends Mono<T>
-		implements Fuseable.ScalarCallable<T>, Fuseable, Scannable {
+final class MonoJust<T> 
+extends Mono<T>
+		implements Fuseable.ScalarCallable<T>, Fuseable, SourceProducer<T>  {
 
 	final T value;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 
 /**
  * Represents an never publisher which only calls onSubscribe.
@@ -26,7 +25,8 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoNever extends Mono<Object> implements Scannable {
+final class MonoNever
+extends Mono<Object> implements SourceProducer<Object>  {
 
 	static final Mono<Object> INSTANCE = new MonoNever();
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -21,14 +21,12 @@
 import java.util.concurrent.Callable;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
  * Executes the runnable whenever a Subscriber subscribes to this Mono.
  */
-final class MonoRunnable<T> extends Mono<T>
-        implements Callable<Void>, Scannable {
+final class MonoRunnable<T> extends Mono<T> implements Callable<Void>, SourceProducer<T>  {
 
     final Runnable run;
     

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -33,7 +33,7 @@
 
 import static reactor.core.publisher.Operators.cancelledSubscription;
 
-final class MonoSequenceEqual<T> extends Mono<Boolean> implements Scannable {
+final class MonoSequenceEqual<T> extends Mono<Boolean> implements SourceProducer<Boolean>  {
 	final Publisher<? extends T>            first;
 	final Publisher<? extends T>            second;
 	final BiPredicate<? super T, ? super T> comparer;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -32,7 +32,7 @@
  * }
  * @param <I> delegate {@link Publisher} type
  */
-final class MonoSource<I> extends Mono<I> implements Scannable {
+final class MonoSource<I> extends Mono<I> implements Scannable, SourceProducer<I>  {
 
 	final Publisher<? extends I> source;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -23,7 +23,6 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -32,8 +31,9 @@
  * @param <T> the returned value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoSupplier<T> extends Mono<T>
-		implements Callable<T>, Fuseable, Scannable {
+final class MonoSupplier<T> 
+extends Mono<T>
+		implements Callable<T>, Fuseable, SourceProducer<T>  {
 
 	final Supplier<? extends T> supplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -24,7 +24,6 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.core.Scannable;
 
 /**
  * Uses a resource, generated by a supplier for each individual Subscriber,
@@ -42,7 +41,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoUsing<T, S> extends Mono<T> implements Fuseable, Scannable {
+final class MonoUsing<T, S> extends Mono<T> implements Fuseable, SourceProducer<T>  {
 
 	final Callable<S> resourceSupplier;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -33,7 +33,7 @@
  * Waits for all Mono sources to produce a value or terminate, and if all of them produced
  * a value, emit a Tuples of those values; otherwise terminate.
  */
-final class MonoWhen extends Mono<Void> implements Scannable {
+final class MonoWhen extends Mono<Void> implements SourceProducer<Void>  {
 
 	final boolean delayError;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoZip.java
Patch:
@@ -37,7 +37,7 @@
  *
  * @param <R> the source value types
  */
-final class MonoZip<T, R> extends Mono<R> implements Scannable {
+final class MonoZip<T, R> extends Mono<R> implements SourceProducer<R>  {
 
 	final boolean delayError;
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelArraySource.java
Patch:
@@ -24,7 +24,7 @@
  * 
  * @param <T> the value type
  */
-final class ParallelArraySource<T> extends ParallelFlux<T> {
+final class ParallelArraySource<T> extends ParallelFlux<T> implements SourceProducer<T>  {
 	final Publisher<T>[] sources;
 	
 	ParallelArraySource(Publisher<T>[] sources) {

File: reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java
Patch:
@@ -87,7 +87,7 @@ final class SignalLogger<IN> implements SignalPeek<IN> {
 		this.fuseable = source instanceof Fuseable;
 
 		if (correlateStack) {
-			operatorLine = FluxOnAssembly.extract(new AssemblySnapshotException().toString(), false);
+			operatorLine = Traces.extractOperatorAssemblyInformation(new AssemblySnapshotException().toString());
 		}
 		else {
 			operatorLine = null;

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -153,7 +153,7 @@ public void transform() {
 	public void onAssemblyDescription() {
 		String monoOnAssemblyStr = Mono.just(1).checkpoint("onAssemblyDescription").toString();
 		System.out.println(Mono.just(1).checkpoint("onAssemblyDescription"));
-		assertTrue("Description not included: " + monoOnAssemblyStr, monoOnAssemblyStr.contains("\"description\" : \"onAssemblyDescription\""));
+		assertTrue("Description not included: " + monoOnAssemblyStr, monoOnAssemblyStr.contains("checkpoint(\"onAssemblyDescription\")"));
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -985,7 +985,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single(GuideTests.java:949)\n");
+						.hasMessageEndingWith("Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949)\n");
 			});
 		}
 	}

File: reactor-core/src/test/java/reactor/core/publisher/EventLoopProcessorTest.java
Patch:
@@ -143,6 +143,7 @@ public void awaitTerminationNanosLong() {
 				e.printStackTrace();
 			}
 		});
+		@SuppressWarnings("deprecation")
 		boolean shutResult = test.awaitAndShutdown(1000, TimeUnit.NANOSECONDS);
 		assertThat(test.executor)
 				.isNotNull()
@@ -172,6 +173,7 @@ public void awaitAndShutdownLongInterrupt() throws InterruptedException {
 				.when(executor).awaitTermination(anyLong(), any());
 		EventLoopProcessor<String> interruptingProcessor = initProcessor(executor);
 
+		@SuppressWarnings("deprecation")
 		boolean result = interruptingProcessor.awaitAndShutdown(100, TimeUnit.MILLISECONDS);
 
 		assertThat(Thread.currentThread().isInterrupted()).as("interrupted").isTrue();

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -261,7 +261,8 @@ public void concatArrayDelayErrorWithMonoError() {
 
 	@Test
 	public void scanOperator() {
-		FluxConcatArray s = new FluxConcatArray<>(true);
+		@SuppressWarnings("unchecked") //vararg of Publisher<String>
+		FluxConcatArray<String> s = new FluxConcatArray<>(true, Flux.empty());
 		assertThat(s.scan(Scannable.Attr.DELAY_ERROR)).as("delayError").isTrue();
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxJustTest.java
Patch:
@@ -90,7 +90,7 @@ public void fluxInitialValueAvailableImmediately() {
 
     @Test
     public void scanOperator() {
-    	FluxJust s = new FluxJust("foo");
+    	FluxJust<String> s = new FluxJust<>("foo");
     	assertThat(s.scan(Scannable.Attr.BUFFERED)).isEqualTo(1);
     }
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnBackpressureBufferTimeoutTest.java
Patch:
@@ -311,7 +311,7 @@ public void scanOperator() {
 	@Test
 	public void scanSubscriber() {
 		CoreSubscriber<String> actual = new LambdaSubscriber<>(null, null, null, null);
-		BackpressureBufferTimeoutSubscriber test = new BackpressureBufferTimeoutSubscriber<>(actual, Duration.ofSeconds(1), Schedulers.immediate(), 123, v -> {});
+		BackpressureBufferTimeoutSubscriber<String> test = new BackpressureBufferTimeoutSubscriber<>(actual, Duration.ofSeconds(1), Schedulers.immediate(), 123, v -> {});
 		Subscription s = Operators.emptySubscription();
 		test.onSubscribe(s);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxStreamTest.java
Patch:
@@ -36,7 +36,7 @@ public class FluxStreamTest {
 	@SuppressWarnings("ConstantConditions")
 	@Test(expected = NullPointerException.class)
 	public void nullStream() {
-		Flux.fromStream((Stream) null);
+		Flux.fromStream((Stream<?>) null);
 	}
 
 	@SuppressWarnings("ConstantConditions")

File: reactor-core/src/test/java/reactor/core/publisher/OnNextFailureStrategyTest.java
Patch:
@@ -771,6 +771,7 @@ public void overrideInheritedErrorStrategyInFlatMap() {
 
 	@Test
 	public void errorStrategyConfiguredInFlatMapDoesNotLeak() {
+		@SuppressWarnings("divzero")
 		Flux<Integer> test = Flux.just(0, 1, 2)
 				.map(i -> i / 0)
 				.flatMap(i -> Flux.just(i).errorStrategyContinue());

File: reactor-core/src/test/java/reactor/core/publisher/ParallelSourceTest.java
Patch:
@@ -45,6 +45,7 @@ public void scanOperator() throws Exception {
 
 	@Test
 	public void scanMainSubscriber() {
+		@SuppressWarnings("unchecked")
 		CoreSubscriber<String>[] subs = new CoreSubscriber[1];
 		subs[0] = new LambdaSubscriber<>(null, e -> {}, null, null);
 		ParallelSource.ParallelSourceMain<String> test = new ParallelSource.ParallelSourceMain<>(
@@ -75,6 +76,7 @@ public void scanMainSubscriber() {
 
 	@Test
 	public void scanInnerSubscriber() {
+		@SuppressWarnings("unchecked")
 		CoreSubscriber<String>[] subs = new CoreSubscriber[2];
 		subs[0] = new LambdaSubscriber<>(null, e -> {}, null, null);
 		subs[1] = new LambdaSubscriber<>(null, e -> {}, null, null);

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -1108,7 +1108,7 @@ boolean isAllTasksCancelled() {
 		}
 
 		@Override
-		public void close() throws Exception {
+		public void close() {
 			shutdown();
 		}
 	}

File: reactor-core/src/test/java/reactor/util/context/Context1Test.java
Patch:
@@ -72,8 +72,8 @@ public void removeKeys() {
 	}
 
 	@Test
-	public void get() throws Exception {
-		assertThat((Object) c.get(1)).isEqualTo("A"); //TODO meh, necessary cast to Object
+	public void get() {
+		assertThat((String) c.get(1)).isEqualTo("A");
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -226,8 +226,8 @@ T tryConvert(@Nullable Object o) {
 				return null;
 			}
 			if (safeConverter == null) {
-				//noinspection unchecked
-				return (T) o;
+				@SuppressWarnings("unchecked") T t = (T) o;
+				return t;
 			}
 			return safeConverter.apply(o);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4905,8 +4905,7 @@ public final Flux<T> hide() {
 	 * @return an indexed {@link Flux} with each source value combined with its 0-based index.
 	 */
 	public final Flux<Tuple2<Long, T>> index() {
-		//noinspection unchecked
-		return index(TUPLE2_BIFUNCTION);
+		return index(tuple2Function());
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -301,8 +301,9 @@ void drainLoop() {
 					}
 
 					for (UnicastProcessor<T> w : ws) {
-						//noinspection unchecked
-						w.onNext((T) o);
+						@SuppressWarnings("unchecked")
+						T t = (T) o;
+						w.onNext(t);
 					}
 				}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -556,7 +556,7 @@ FluxProcessor<O, O> getOrStart(){
 		return out;
 	}
 
-	@SuppressWarnings("rawtypes")
+	@SuppressWarnings({"rawtypes", "unchecked"})
     final static class NoopProcessor extends FluxProcessor {
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/OnNextFailureStrategy.java
Patch:
@@ -240,11 +240,11 @@ final class LambdaOnNextErrorStrategy implements OnNextFailureStrategy {
 		private final BiFunction<? super Throwable, Object, ? extends Throwable> delegateProcessor;
 		private final BiPredicate<? super Throwable, Object> delegatePredicate;
 
+		@SuppressWarnings("unchecked")
 		public LambdaOnNextErrorStrategy(
 				BiFunction<? super Throwable, Object, ? extends Throwable> delegateProcessor) {
 			this.delegateProcessor = delegateProcessor;
 			if (delegateProcessor instanceof BiPredicate) {
-				//noinspection unchecked
 				this.delegatePredicate = (BiPredicate<? super Throwable, Object>) delegateProcessor;
 			}
 			else {

File: reactor-core/src/main/java/reactor/core/publisher/Signal.java
Patch:
@@ -44,7 +44,7 @@ public interface Signal<T> extends Supplier<T>, Consumer<Subscriber<? super T>>
 	 *
 	 * @return an {@code OnCompleted} variety of {@code Signal}
 	 */
-	@SuppressWarnings("unchecked")
+	@SuppressWarnings({"deprecation", "unchecked"})
 	static <T> Signal<T> complete() {
 		return (Signal<T>) ImmutableSignal.ON_COMPLETE;
 	}
@@ -58,9 +58,9 @@ static <T> Signal<T> complete() {
 	 *
 	 * @return an {@code OnCompleted} variety of {@code Signal}
 	 */
+	@SuppressWarnings({"deprecation", "unchecked"})
 	static <T> Signal<T> complete(Context context) {
 		if (context.isEmpty()) {
-			//noinspection unchecked
 			return (Signal<T>) ImmutableSignal.ON_COMPLETE;
 		}
 		return new ImmutableSignal<>(context, SignalType.ON_COMPLETE, null, null, null);
@@ -158,6 +158,7 @@ static <T> Signal<T> subscribe(Subscription subscription, Context context) {
 	 * @param o the object to check
 	 * @return true if object represents the completion signal
 	 */
+	@SuppressWarnings("deprecation")
 	static boolean isComplete(Object o) {
 		return o == ImmutableSignal.ON_COMPLETE ||
 				(o instanceof Signal && ((Signal) o).getType() == SignalType.ON_COMPLETE);

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java
Patch:
@@ -415,6 +415,7 @@ public void distinctPredicateThrows() {
 	public void distinctPredicateThrowsConditional() {
 		IllegalStateException error = new IllegalStateException("forced failure");
 
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<Integer> actualConditional = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		when(actualConditional.currentContext()).thenReturn(Context.empty());
 		when(actualConditional.tryOnNext(anyInt())).thenReturn(false);
@@ -436,6 +437,7 @@ public void distinctPredicateThrowsConditional() {
 	public void distinctPredicateThrowsConditionalOnNext() {
 		IllegalStateException error = new IllegalStateException("forced failure");
 
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<Integer> actualConditional = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		when(actualConditional.currentContext()).thenReturn(Context.empty());
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeOrderedTest.java
Patch:
@@ -264,6 +264,7 @@ public void nullSources() {
 	@Test
 	public void mergeAdditionalSource() {
 		Comparator<Integer> originalComparator = Comparator.naturalOrder();
+		@SuppressWarnings("unchecked")
 		FluxMergeOrdered<Integer> fmo = new FluxMergeOrdered<>(2,
 				Queues.small(),
 				originalComparator,

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowWhenTest.java
Patch:
@@ -128,9 +128,9 @@ protected void finalize() {
 		System.gc();
 		Thread.sleep(500);
 
-		assertThat(windows.get())
+		assertThat(windows.get().size())
 				.as("no window retained")
-				.isEmpty();
+				.isZero();
 		assertThat(finalized.longValue())
 				.as("final GC collects all")
 				.isEqualTo(created.longValue());

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -694,6 +694,7 @@ default Step<T> assertNext(Consumer<? super T> assertionConsumer) {
 		 *
 		 * @see Subscriber#onNext(Object)
 		 */
+		@SuppressWarnings("unchecked")
 		Step<T> expectNext(T... ts);
 
 		/**

File: reactor-test/src/test/java/reactor/test/StepVerifierAssertionsTests.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -516,7 +516,7 @@ public void assertDurationLessThanFailure() {
 
 	@Test
 	public void assertDurationConsidersEqualsASuccess() {
-		new DefaultStepVerifierBuilder.DefaultStepVerifierAssertions(null, null, null,
+		new DefaultStepVerifierBuilder.DefaultStepVerifierAssertions(null,
 				Duration.ofSeconds(3),
 				new ErrorFormatter(null))
 				.tookLessThan(Duration.ofMillis(3000L))
@@ -527,7 +527,7 @@ public void assertDurationConsidersEqualsASuccess() {
 	public void assertDurationFailureWithScenarioName() {
 		assertThatExceptionOfType(AssertionError.class)
 				.isThrownBy(() ->
-						new DefaultStepVerifierBuilder.DefaultStepVerifierAssertions(null, null, null
+						new DefaultStepVerifierBuilder.DefaultStepVerifierAssertions(null
 								, Duration.ofSeconds(3),
 								new ErrorFormatter("fooScenario"))
 								.tookLessThan(Duration.ofMillis(200))

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -466,7 +466,8 @@ public void innerErrorsBoundary() {
 		DirectProcessor<Integer> source1 = DirectProcessor.create();
 		DirectProcessor<Integer> source2 = DirectProcessor.create();
 
-		source.concatMapDelayError(v -> v == 1 ? source1 : source2)
+		//gh-1101: default changed from BOUNDARY to END
+		source.concatMapDelayError(v -> v == 1 ? source1 : source2, false, Queues.XS_BUFFER_SIZE)
 		      .subscribe(ts);
 
 		ts.assertNoValues()

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2043,7 +2043,7 @@ public final T blockFirst(Duration timeout) {
 	 * Note that each blockLast() will trigger a new subscription: in other words,
 	 * the result might miss signal from hot publishers.
 	 *
-	 * @return the first value or null
+	 * @return the last value or null
 	 */
 	@Nullable
 	public final T blockLast() {
@@ -2064,7 +2064,7 @@ public final T blockLast() {
 	 * the result might miss signal from hot publishers.
 	 *
 	 * @param timeout maximum time period to wait for before raising a {@link RuntimeException}
-	 * @return the first value or null
+	 * @return the last value or null
 	 */
 	@Nullable
 	public final T blockLast(Duration timeout) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -131,6 +131,7 @@ public void success(@Nullable T value) {
 			for (; ; ) {
 				int s = state;
 				if (s == HAS_REQUEST_HAS_VALUE || s == NO_REQUEST_HAS_VALUE) {
+					Operators.onNextDropped(value, actual.currentContext());
 					return;
 				}
 				if (s == HAS_REQUEST_NO_VALUE) {
@@ -163,7 +164,7 @@ public void error(Throwable e) {
 				}
 			}
 			else {
-				Operators.onErrorDropped(e, actual.currentContext());
+				Operators.onOperatorError(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -131,6 +131,7 @@ public void success(@Nullable T value) {
 			for (; ; ) {
 				int s = state;
 				if (s == HAS_REQUEST_HAS_VALUE || s == NO_REQUEST_HAS_VALUE) {
+					Operators.onNextDropped(value, actual.currentContext());
 					return;
 				}
 				if (s == HAS_REQUEST_NO_VALUE) {
@@ -163,7 +164,7 @@ public void error(Throwable e) {
 				}
 			}
 			else {
-				Operators.onErrorDropped(e, actual.currentContext());
+				Operators.onOperatorError(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,8 +32,6 @@
 /**
  * Waits for all Mono sources to produce a value or terminate, and if all of them produced
  * a value, emit a Tuples of those values; otherwise terminate.
- *
- * @param <R> the source value types
  */
 final class MonoWhen extends Mono<Void> {
 

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -371,6 +371,7 @@ final public Flux<IN> forceShutdown() {
 		int t = terminated;
 		if (t != FORCED_SHUTDOWN && TERMINATED.compareAndSet(this, t, FORCED_SHUTDOWN)) {
 			executor.shutdownNow();
+			requestTaskExecutor.shutdownNow();
 		}
 		return drain();
 	}

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -222,7 +222,7 @@ void eviction() {
 			if (e.expireMillis < now) {
 				if (cache.remove(e)) {
 					e.cached.exec.shutdownNow();
-					//TODO shouldn't we remove from all at some point?
+					all.remove(e.cached);
 				}
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3972,7 +3972,7 @@ public final Flux<T> expandDeep(Function<? super T, ? extends Publisher<? extend
 	 *  A
 	 *  B
 	 *  AA
-	 *  AB
+	 *  BB
 	 *  aa1
 	 *  bb1
 	 * </pre>
@@ -4012,7 +4012,7 @@ public final Flux<T> expand(Function<? super T, ? extends Publisher<? extends T>
 	 *  A
 	 *  B
 	 *  AA
-	 *  AB
+	 *  BB
 	 *  aa1
 	 *  bb1
 	 * </pre>

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -80,7 +80,7 @@ public void cancel() {
 		@Override
 		public void onSubscribe(Subscription s) {
 			this.s = s;
-			actual.onSubscribe(s);
+			actual.onSubscribe(this);
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -1193,7 +1193,7 @@ public void scanSerializedSink() {
 		FluxCreate.BaseSink<String> decorated = new FluxCreate.LatestAsyncSink<>(actual);
 		SerializedSink<String> test = new SerializedSink<>(decorated);
 
-		test.queue.offer("foo");
+		test.mpscQueue.offer("foo");
 		assertThat(test.scan(Scannable.Attr.BUFFERED)).isEqualTo(1);
 		assertThat(decorated.scan(Scannable.Attr.BUFFERED)).isEqualTo(0);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxJoinTest.java
Patch:
@@ -258,11 +258,10 @@ public void resultSelectorThrows() {
 	public void scanSubscription() {
 		CoreSubscriber<String> actual = new LambdaSubscriber<>(null, e -> {}, null, sub -> sub.request(100));
 		FluxJoin.JoinSubscription<String, String, String, String, String> test =
-				new FluxJoin.JoinSubscription<String, String, String, String, String>(actual,
+				new FluxJoin.JoinSubscription<>(actual,
 						s -> Mono.just(s),
 						s -> Mono.just(s),
-						(l, r) -> l,
-						Queues.unbounded().get());
+						(l, r) -> l);
 
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);
 		test.request(123);

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -251,7 +251,7 @@ public void windowWillAcumulateMultipleListsOfValues() {
     public void scanMainSubscriber() {
         CoreSubscriber<Flux<Integer>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxWindowBoundary.WindowBoundaryMain<Integer, Integer> test = new FluxWindowBoundary.WindowBoundaryMain<>(actual,
-        		Queues.unbounded(), Queues.<Integer>unbounded().get(), Queues.unbounded().get());
+        		Queues.unbounded(), Queues.<Integer>unbounded().get());
         Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 
@@ -280,7 +280,7 @@ public void scanMainSubscriber() {
     public void scanOtherSubscriber() {
         CoreSubscriber<Flux<Integer>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxWindowBoundary.WindowBoundaryMain<Integer, Integer> main = new FluxWindowBoundary.WindowBoundaryMain<>(actual,
-        		Queues.unbounded(), Queues.<Integer>unbounded().get(), Queues.unbounded().get());
+        		Queues.unbounded(), Queues.<Integer>unbounded().get());
         FluxWindowBoundary.WindowBoundaryOther<Integer> test =
         		new FluxWindowBoundary.WindowBoundaryOther<>(main);
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterWhenTest.java
Patch:
@@ -153,7 +153,7 @@ public void oneAndErrorInner() {
 	public void predicateThrows() {
 		StepVerifier.create(Flux.just(1)
 		                        .filterWhen(v -> { throw new IllegalStateException(); }))
-		            .expectError(IllegalStateException.class);
+		            .verifyError(IllegalStateException.class);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -156,7 +156,7 @@ public void oneAndErrorInner() {
 	public void predicateThrows() {
 		StepVerifier.create(Mono.just(1)
 		                        .filterWhen(v -> { throw new IllegalStateException(); }))
-		            .expectError(IllegalStateException.class);
+		            .verifyError(IllegalStateException.class);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoIgnoreEmptyTest.java
Patch:
@@ -30,14 +30,14 @@ public class MonoIgnoreEmptyTest {
 	public void normal() {
 		StepVerifier.create(Flux.just(1)
 		                        .thenEmpty(Flux.empty()))
-		            .expectComplete();
+		            .verifyComplete();
 	}
 
 	@Test
 	public void normal3() {
 		StepVerifier.create(Flux.just(1)
 		                        .then())
-		            .expectComplete();
+		            .verifyComplete();
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/util/concurrent/MpscLinkedQueue.java
Patch:
@@ -32,7 +32,7 @@
  * A multi-producer single consumer unbounded queue.
  * @param <E> the contained value type
  */
-public class MpscLinkedQueue<E> extends AbstractQueue<E> implements BiPredicate<E, E> {
+final class MpscLinkedQueue<E> extends AbstractQueue<E> implements BiPredicate<E, E> {
 	private volatile LinkedQueueNode<E> producerNode;
 
 	private final static AtomicReferenceFieldUpdater<MpscLinkedQueue, LinkedQueueNode> PRODUCER_NODE_UPDATER

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySequence.java
Patch:
@@ -28,12 +28,12 @@
  * @author Simon Baslé
  */
 //adapted from RxJava2 FlowableDelay: https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java
-public final class FluxDelaySequence<T> extends FluxOperator<T, T> {
+final class FluxDelaySequence<T> extends FluxOperator<T, T> {
 
 	final Duration  delay;
 	final Scheduler scheduler;
 
-	public FluxDelaySequence(Flux<T> source, Duration delay, Scheduler scheduler) {
+	FluxDelaySequence(Flux<T> source, Duration delay, Scheduler scheduler) {
 		super(source);
 		this.delay = delay;
 		this.scheduler = scheduler;

File: reactor-core/src/main/java/reactor/core/publisher/FluxIndex.java
Patch:
@@ -34,7 +34,7 @@
  *
  * @author Simon Baslé
  */
-public class FluxIndex<T, I> extends FluxOperator<T, I> {
+final class FluxIndex<T, I> extends FluxOperator<T, I> {
 
 	private final BiFunction<? super Long, ? super T, ? extends I> indexMapper;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxIndexFuseable.java
Patch:
@@ -51,7 +51,7 @@
  *
  * @author Simon Baslé
  */
-public class FluxIndexFuseable<T, I> extends FluxOperator<T, I>
+final class FluxIndexFuseable<T, I> extends FluxOperator<T, I>
 		implements Fuseable {
 
 	private final BiFunction<? super Long, ? super T, ? extends I> indexMapper;

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -571,7 +571,6 @@ public String get() {
 	static void handleError(Throwable ex) {
 		Thread thread = Thread.currentThread();
 		Throwable t = unwrap(ex);
-		Exceptions.throwIfJvmFatal(t);
 		Thread.UncaughtExceptionHandler x = thread.getUncaughtExceptionHandler();
 		if (x != null) {
 			x.uncaughtException(thread, t);

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7713,7 +7713,6 @@ public final <U, V> Flux<Flux<T>> windowWhen(Publisher<U> bucketOpening,
 		return onAssembly(new FluxWindowWhen<>(this,
 				bucketOpening,
 				closeSelector,
-				Queues.unbounded(Queues.XS_BUFFER_SIZE),
 				Queues.unbounded(Queues.XS_BUFFER_SIZE)));
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -685,7 +685,8 @@ public void manualRequestWindowWhileOverRequestingSourceByPrefetch() {
 		            .thenCancel()
 		            .verify();
 
-		assertThat(req.get()).isEqualTo(10 + prefetch); //9 forwarded elements, 2 delimiters
+		assertThat(req.get()).isEqualTo(12 + prefetch); //9 forwarded elements, 2
+		// delimiters, 1 cancel and prefetch
 	}
 
 	// see https://github.com/reactor/reactor-core/issues/477

File: reactor-core/src/main/java/reactor/util/concurrent/Queues.java
Patch:
@@ -52,6 +52,9 @@ public static final int capacity(Queue q) {
 		else if (q instanceof SpscArrayQueue) {
 			return ((SpscArrayQueue) q).length();
 		}
+		else if(q instanceof MpscLinkedQueue) {
+			return Integer.MAX_VALUE;
+		}
 		else if (q instanceof BlockingQueue) {
 			return ((BlockingQueue) q).remainingCapacity();
 		}

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4911,8 +4911,7 @@ public final <V> Flux<V> map(Function<? super T, ? extends V> mapper) {
 	 * materializing these signals.
 	 * Since the error is materialized as a {@code Signal}, the propagation will be stopped and onComplete will be
 	 * emitted. Complete signal will first emit a {@code Signal.complete()} and then effectively complete the flux.
-	 * <p>
-	 * These {@link Signal} don't have a {@link Context} associated with them (empty {@link Context}).
+	 * All these {@link Signal} have a {@link Context} associated to them.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.1.RELEASE/src/docs/marble/materialize.png" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2318,8 +2318,7 @@ public final <R> Mono<R> map(Function<? super T, ? extends R> mapper) {
 	 * materializing these signals.
 	 * Since the error is materialized as a {@code Signal}, the propagation will be stopped and onComplete will be
 	 * emitted. Complete signal will first emit a {@code Signal.complete()} and then effectively complete the flux.
-	 * <p>
-	 * These {@link Signal} don't have a {@link Context} associated with them (empty {@link Context}).
+	 * All these {@link Signal} have a {@link Context} associated to them.
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.1.RELEASE/src/docs/marble/materialize1.png" alt="">
 	 *

File: reactor-core/src/main/java/reactor/core/publisher/FluxMaterialize.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * @author Stephane Maldini
@@ -182,6 +183,6 @@ public int size() {
             return terminalSignal == null || terminalSignal == empty ? 0 : 1;
         }
 
-		static final Signal empty = new ImmutableSignal<>(SignalType.ON_NEXT, null, null, null);
+		static final Signal empty = new ImmutableSignal<>(Context.empty(), SignalType.ON_NEXT, null, null, null);
 	}
 }

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -381,7 +381,6 @@ public Disposable schedule(Runnable run, long delayTime, TimeUnit unit) {
 					run,
 					COUNTER.getAndIncrement(VirtualTimeScheduler.this));
 			queue.add(timedTask);
-			advanceTime();
 			return () -> queue.remove(timedTask);
 		}
 
@@ -399,7 +398,6 @@ public Disposable schedulePeriodically(Runnable task,
 					periodInNanoseconds);
 
 			replace(periodicTask, schedule(periodicTask, initialDelay, unit));
-			advanceTime();
 			return periodicTask;
 		}
 

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java
Patch:
@@ -37,7 +37,7 @@ public abstract class AbstractFluxVerification
 	final int batch = 1024;
 
 	AbstractFluxVerification() {
-		super(new TestEnvironment(true));
+		super(new TestEnvironment(false));
 	}
 
 	abstract Flux<Integer> transformFlux(Flux<Integer> f);

File: reactor-core/src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.core.publisher.tck;
 
+import java.util.logging.Level;
+
 import org.reactivestreams.Processor;
 import org.testng.SkipException;
 import reactor.core.publisher.EmitterProcessor;
@@ -29,7 +31,7 @@ public class EmitterProcessorVerification extends AbstractProcessorVerification
 	@Override
 	public Processor<Long, Long> createIdentityProcessor(int bufferSize) {
 		FluxProcessor<Long, Long> p = EmitterProcessor.create(bufferSize);
-		return FluxProcessor.wrap(p, p.log());
+		return FluxProcessor.wrap(p, p.log("EmitterProcessorVerification", Level.FINE));
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/publisher/tck/FluxGenerateVerification.java
Patch:
@@ -16,6 +16,8 @@
 
 package reactor.core.publisher.tck;
 
+import java.util.logging.Level;
+
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;
 import org.reactivestreams.tck.TestEnvironment;
@@ -47,7 +49,7 @@ else if(cursor == elements){
 
 				.map(data -> data * 10)
 				.map( data -> data / 10)
-				.log("log-test");
+				.log("log-test", Level.FINE);
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java
Patch:
@@ -39,7 +39,7 @@ public class FluxWithProcessorVerification extends AbstractProcessorVerification
 	@Override
 	public Processor<Long, Long> createIdentityProcessor(int bufferSize) {
 		Flux<String> otherStream = Flux.just("test", "test2", "test3");
-		System.out.println("Providing new downstream");
+//		System.out.println("Providing new downstream");
 		FluxProcessor<Long, Long> p =
 				WorkQueueProcessor.<Long>builder().name("fluxion-raw-fork").bufferSize(bufferSize).build();
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -414,7 +414,7 @@ public void afterTerminateCallbackFatalIsThrownDirectly() {
 
 	@Test
 	public void afterTerminateCallbackErrorAndErrorCallbackError() {
-		IllegalStateException err = new IllegalStateException("afterTerminate");
+		IllegalStateException err = new IllegalStateException("expected afterTerminate");
 		IllegalArgumentException err2 = new IllegalArgumentException("error");
 
 		FluxPeekFuseable<String> flux = new FluxPeekFuseable<>(
@@ -793,7 +793,6 @@ public void should_reduce_to_10_events() {
 			    })
 			    .blockLast();
 
-			System.out.println(rs);
 			assertEquals(10, count.get());
 		}
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnValueTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.logging.Level;
 
 import org.junit.Test;
 import reactor.core.CoreSubscriber;
@@ -45,7 +46,7 @@ public void testSubscribeOnValueFusion() {
 		StepVerifier.create(Flux.range(1, 100)
 		                        .flatMap(f -> Flux.just(f)
 		                                          .subscribeOn(Schedulers.parallel())
-		                                          .log()
+		                                          .log("testSubscribeOnValueFusion", Level.FINE)
 		                                          .map(this::slow)))
 		            .expectFusion(Fuseable.ASYNC, Fuseable.NONE)
 		            .expectNextCount(100)

File: reactor-core/src/test/java/reactor/core/publisher/ParallelCollectTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.function.Supplier;
+import java.util.logging.Level;
 
 import org.junit.Test;
 import org.reactivestreams.Subscription;
@@ -45,7 +46,7 @@ public void collect() {
 		    .collect(as, (a, b) -> a.add(b))
 		    .sequential()
 		    .flatMapIterable(v -> v)
-		    .log()
+		    .log("ParallelCollectTest#collect", Level.FINE)
 		    .subscribe(ts);
 
 		ts.assertContainValues(new HashSet<>(Arrays.asList(1,

File: reactor-core/src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * @author Stephane Maldini
  */
-@org.testng.annotations.Test
+@org.testng.annotations.Test //FIXME
 public class FluxWithProcessorVerification extends AbstractProcessorVerification {
 
 	final AtomicLong cumulated = new AtomicLong(0);

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -409,6 +409,7 @@ public void cancel() {
 		if (!outputFused) {
 			if (WIP.getAndIncrement(this) == 0) {
 				queue.clear();
+				actual = null;
 			}
 		}
 	}

File: reactor-core/src/test/java/reactor/core/publisher/ContextTests.java
Patch:
@@ -47,7 +47,7 @@ public void contextPassing() throws InterruptedException {
 		                                })
 		                                .log())
 		    .take(10)
-		    //ctx: test=baseSubscriber_range
+		    //ctx: test=baseSubscriber_take
 		    //return: test=baseSubscriber_take_range
 		    .subscriberContext(ctx -> ctx.put("test", ctx.get("test") + "_range"))
 		    //ctx: test=baseSubscriber

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -116,7 +116,7 @@ public static Scheduler fromExecutorService(ExecutorService executorService) {
 	 * <p>
 	 * This scheduler is not restartable.
 	 *
-	 * @return a new {@link Scheduler} that hosts a fixed pool of single-threaded
+	 * @return default instance of a {@link Scheduler} that hosts a fixed pool of single-threaded
 	 * ExecutorService-based workers and is suited for parallel work
 	 */
 	public static Scheduler elastic() {
@@ -333,7 +333,7 @@ public static void onHandleError(BiConsumer<Thread, ? super Throwable> c) {
 	 * {@link Scheduler} that hosts a fixed pool of single-threaded ExecutorService-based
 	 * workers and is suited for parallel work.
 	 *
-	 * @return a reusable {@link Scheduler} that hosts a fixed pool of single-threaded
+	 * @return default instance of a {@link Scheduler} that hosts a fixed pool of single-threaded
 	 * ExecutorService-based workers
 	 */
 	public static Scheduler parallel() {
@@ -391,7 +391,7 @@ public static void shutdownNow() {
 	 * {@link Scheduler} that hosts a single-threaded ExecutorService-based worker and is
 	 * suited for parallel work. Will cache the returned schedulers for subsequent calls until dispose.
 	 *
-	 * @return a cached {@link Scheduler} that hosts a single-threaded
+	 * @return default instance of a {@link Scheduler} that hosts a single-threaded
 	 * ExecutorService-based worker
 	 */
 	public static Scheduler single() {

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -60,6 +60,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 
 	static final class SingleSubscriber<T> extends Operators.MonoSubscriber<T, T>  {
 
+		@Nullable
 		final T       defaultValue;
 		final boolean completeOnEmpty;
 
@@ -79,7 +80,7 @@ public Object scanUnsafe(Attr key) {
 		}
 
 		SingleSubscriber(CoreSubscriber<? super T> actual,
-				T defaultValue,
+				@Nullable T defaultValue,
 				boolean completeOnEmpty) {
 			super(actual);
 			this.defaultValue = defaultValue;

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -358,7 +358,9 @@ public void onNext(T t) {
 					v = ((Callable<R>) p).call();
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
+					if (!delayError || !Exceptions.addThrowable(ERROR, this, e)) {
+						onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
+					}
 					return;
 				}
 				tryEmitScalar(v);

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3241,7 +3241,7 @@ public final Mono<T> timeout(Duration timeout, @Nullable Mono<? extends T> fallb
 		final Mono<Long> _timer = Mono.delay(timeout, timer).onErrorReturn(0L);
 
 		if(fallback == null) {
-			return onAssembly(new MonoTimeout<>(this, _timer));
+			return onAssembly(new MonoTimeout<>(this, _timer, timeout.toMillis() + "ms"));
 		}
 		return onAssembly(new MonoTimeout<>(this, _timer, fallback));
 	}
@@ -3260,7 +3260,7 @@ public final Mono<T> timeout(Duration timeout, @Nullable Mono<? extends T> fallb
 	 *
 	 */
 	public final <U> Mono<T> timeout(Publisher<U> firstTimeout) {
-		return onAssembly(new MonoTimeout<>(this, firstTimeout));
+		return onAssembly(new MonoTimeout<>(this, firstTimeout, "first signal from a Publisher"));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2666,7 +2666,7 @@ public final Mono<T> repeatWhenEmpty(Function<Flux<Long>, ? extends Publisher<?>
 	 * it is different from {@code Integer.MAX_VALUE}).
 	 *
 	 * <p>
-	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.1.RELEASE/src/docs/marble/repeatwhen1.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.1.RELEASE/src/docs/marble/repeatwhenempty.png" alt="">
 	 *
 	 * @param maxRepeat the maximum number of repeats (infinite if {@code Integer.MAX_VALUE})
 	 * @param repeatFactory the {@link Function} that returns the associated {@link Publisher}

File: reactor-core/src/main/java/reactor/core/Disposable.java
Patch:
@@ -64,7 +64,7 @@ interface Swap extends Disposable, Supplier<Disposable> {
 		 * @return true if the operation succeeded, false if the container has been disposed
 		 * @see #replace(Disposable)
 		 */
-		boolean update(Disposable next);
+		boolean update(@Nullable Disposable next);
 
 		/**
 		 * Atomically push the next {@link Disposable} on this container but don't dispose the previous

File: reactor-core/src/main/java/reactor/core/Disposables.java
Patch:
@@ -434,7 +434,7 @@ static final class SwapDisposable implements Disposable.Swap {
 				AtomicReferenceFieldUpdater.newUpdater(SwapDisposable.class, Disposable.class, "inner");
 
 		@Override
-		public boolean update(Disposable next) {
+		public boolean update(@Nullable Disposable next) {
 			return Disposables.set(INNER, this, next);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2289,7 +2289,7 @@ public final Flux<List<T>> bufferTimeout(int maxSize, Duration timespan, Schedul
 	 */
 	public final  <C extends Collection<? super T>> Flux<C> bufferTimeout(int maxSize, Duration timespan,
 			Scheduler timer, Supplier<C> bufferSupplier) {
-		return onAssembly(new FluxBufferTimeOrSize<>(this, maxSize, timespan.toMillis(), timer, bufferSupplier));
+		return onAssembly(new FluxBufferTimeout<>(this, maxSize, timespan.toMillis(), timer, bufferSupplier));
 	}
 
 	/**
@@ -7448,7 +7448,7 @@ public final Flux<Flux<T>> windowTimeout(int maxSize, Duration timespan) {
 	 * @return a {@link Flux} of {@link Flux} windows based on element count and duration
 	 */
 	public final Flux<Flux<T>> windowTimeout(int maxSize, Duration timespan, Scheduler timer) {
-		return onAssembly(new FluxWindowTimeOrSize<>(this, maxSize, timespan.toMillis(), timer));
+		return onAssembly(new FluxWindowTimeout<>(this, maxSize, timespan.toMillis(), timer));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeout.java
Patch:
@@ -34,15 +34,15 @@
 /**
  * @author Stephane Maldini
  */
-final class FluxBufferTimeOrSize<T, C extends Collection<? super T>> extends FluxOperator<T,
+final class FluxBufferTimeout<T, C extends Collection<? super T>> extends FluxOperator<T,
 		C> {
 
 	final int            batchSize;
 	final Supplier<C>    bufferSupplier;
 	final Scheduler      timer;
 	final long           timespan;
 
-	FluxBufferTimeOrSize(Flux<T> source,
+	FluxBufferTimeout(Flux<T> source,
 			int maxSize,
 			long timespan,
 			Scheduler timer,

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferTimeoutTest.java
Patch:
@@ -28,7 +28,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class FluxBufferTimeOrSizeTest {
+public class FluxBufferTimeoutTest {
 
 	Flux<List<Integer>> scenario_bufferWithTimeoutAccumulateOnTimeOrSize() {
 		return Flux.range(1, 6)
@@ -66,7 +66,7 @@ public void bufferWithTimeoutAccumulateOnTimeOrSize2() {
 	public void scanSubscriber() {
 		CoreSubscriber<List<String>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 
-		FluxBufferTimeOrSize.BufferTimeoutSubscriber<String, List<String>> test = new FluxBufferTimeOrSize.BufferTimeoutSubscriber<String, List<String>>(
+		FluxBufferTimeout.BufferTimeoutSubscriber<String, List<String>> test = new FluxBufferTimeout.BufferTimeoutSubscriber<String, List<String>>(
 						actual, 123, 1000, Schedulers.elastic().createWorker(), ArrayList::new);
 
 		Subscription subscription = Operators.emptySubscription();
@@ -95,7 +95,7 @@ public void scanSubscriberCancelled() {
 		CoreSubscriber<List<String>>
 				actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 
-		FluxBufferTimeOrSize.BufferTimeoutSubscriber<String, List<String>> test = new FluxBufferTimeOrSize.BufferTimeoutSubscriber<String, List<String>>(
+		FluxBufferTimeout.BufferTimeoutSubscriber<String, List<String>> test = new FluxBufferTimeout.BufferTimeoutSubscriber<String, List<String>>(
 						actual, 123, 1000, Schedulers.elastic().createWorker(), ArrayList::new);
 
 		assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxWindowConsistencyTest.java
Patch:
@@ -300,7 +300,7 @@ public void windowTimeoutMainCancel() throws Exception {
 		generate(2, 3);
 		Thread.sleep(200);
 		generate(5, 10);
-		verifyMainCancel(true, Arrays.asList(0, 1, 2, 3, 4));
+		verifyMainCancel(true);
 	}
 
 	@Test
@@ -408,7 +408,7 @@ public void windowTimeoutMainCancelNoNewWindow() throws Exception {
 		mainSubscriber.cancel();
 		Thread.sleep(300);
 		generate(2, 1);
-		verifyMainCancelNoNewWindow(2, Arrays.asList(0), Arrays.asList(1));
+		verifyMainCancelNoNewWindow(1, Arrays.asList(0), Arrays.asList(1));
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -173,7 +173,7 @@ public void onSubscribe(Subscription s) {
 					@SuppressWarnings("unchecked")
 					Fuseable.QueueSubscription<T> qs = (Fuseable.QueueSubscription<T>) s;
 					
-					int m = qs.requestFusion(Fuseable.ANY);
+					int m = qs.requestFusion(Fuseable.ANY | Fuseable.THREAD_BARRIER);
 					
 					if (m == Fuseable.SYNC) {
 						sourceMode = m;

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -118,7 +118,8 @@ public void run() {
 				} else {
 					cancel();
 					
-					actual.onError(Exceptions.failWithOverflow("Could not emit value " + count + " due to lack of requests"));
+					actual.onError(Exceptions.failWithOverflow("Could not emit tick " + count + " due to lack of requests" +
+							" (interval doesn't support small downstream requests that replenish slower than the ticks)"));
 				}
 			}
 		}

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleTest.java
Patch:
@@ -187,7 +187,7 @@ public void otherCompletesImmediately() {
 	public void sampleIncludesLastItem() {
 		Flux<Integer> source = Flux.concat(
 				Flux.range(1, 5),
-				Mono.delay(Duration.ofMillis(260)).ignoreElement().map(Long::intValue),
+				Mono.delay(Duration.ofMillis(300)).ignoreElement().map(Long::intValue),
 				Flux.just(80, 90, 100)
 		).hide();
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -80,12 +80,12 @@ public void subscribe(CoreSubscriber<? super T>[] subscribers) {
 				parents[i] = new FluxPublishOn.PublishOnConditionalSubscriber<>(
 						(Fuseable.ConditionalSubscriber<T>)subscribers[i],
 						scheduler, w, true,
-						prefetch, queueSupplier);
+						prefetch, prefetch, queueSupplier);
 			}
 			else {
 				parents[i] = new FluxPublishOn.PublishOnSubscriber<>(subscribers[i],
 						scheduler, w, true,
-						prefetch, queueSupplier);
+						prefetch, prefetch, queueSupplier);
 			}
 		}
 		

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.junit.Test;
 import org.mockito.Mockito;
-import org.reactivestreams.Processor;
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
 
@@ -29,7 +28,7 @@ public class DelegateProcessorTest {
 
 	@Test
 	public void scanReturnsDownStreamForParentElseDelegates() {
-		Publisher<?> downstream = Mockito.mock(Publisher.class);
+		Publisher<?> downstream = Mockito.mock(FluxOperator.class);
 
 		IllegalStateException boom = new IllegalStateException("boom");
 		InnerConsumer<?> upstream = Mockito.mock(InnerConsumer.class);

File: reactor-core/src/test/java/reactor/core/publisher/DirectProcessorTest.java
Patch:
@@ -18,7 +18,6 @@
 import org.junit.Assert;
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
-import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
@@ -254,7 +253,7 @@ public void subscriberCancels() {
     @Test
     @SuppressWarnings("unchecked")
     public void scanInner() {
-	    CoreSubscriber<? super String> actual = mock(CoreSubscriber.class);
+	    InnerConsumer<? super String> actual = mock(InnerConsumer.class);
         DirectProcessor<String> parent = new DirectProcessor<>();
 
         DirectProcessor.DirectInner<String> test =

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.mockito.Mockito;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.subscriber.AssertSubscriber;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -82,7 +83,7 @@ public void connectAfterMany() {
 	@Test
 	public void scanMain() {
 		@SuppressWarnings("unchecked")
-		ConnectableFlux<String> source = Mockito.mock(ConnectableFlux.class);
+		ConnectableFlux<String> source = Mockito.mock(MockUtils.TestScannableConnectableFlux.class);
 		Mockito.when(source.getPrefetch()).thenReturn(888);
 		FluxAutoConnect<String> test = new FluxAutoConnect<>(source, 123, d -> { });
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java
Patch:
@@ -30,6 +30,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
@@ -442,7 +443,7 @@ public void scanSubscriber() {
 	@Test
 	public void scanConditionalSubscriber() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
 		FluxDistinct.DistinctConditionalSubscriber<String, Integer, Set<Integer>> test =
 				new FluxDistinct.DistinctConditionalSubscriber<>(actual, new HashSet<>(), String::hashCode);
 		Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -27,6 +27,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -249,7 +250,7 @@ public void scanSubscriber() {
 	@Test
 	public void scanConditionalSubscriber() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
 		FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber<String, Integer> test = new FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber<>(
 				actual, String::hashCode, Objects::equals);
 		Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxErrorTest.java
Patch:
@@ -39,7 +39,7 @@ public void normalOnRequest() {
 
     @Test
     public void scanSubscription() {
-	    @SuppressWarnings("unchecked") CoreSubscriber<String> subscriber = Mockito.mock(CoreSubscriber.class);
+	    @SuppressWarnings("unchecked") CoreSubscriber<String> subscriber = Mockito.mock(InnerOperator.class);
         FluxErrorOnRequest.ErrorSubscription test =
                 new FluxErrorOnRequest.ErrorSubscription(subscriber, new IllegalStateException("boom"));
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterFuseableTest.java
Patch:
@@ -22,6 +22,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.publisher.FluxOperatorTest;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -46,7 +47,7 @@ public void scanSubscriber() {
     @Test
     public void scanConditionalSubscriber() {
         @SuppressWarnings("unchecked")
-        Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+        Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxFilterFuseable.FilterFuseableConditionalSubscriber<String> test = new FluxFilterFuseable.FilterFuseableConditionalSubscriber<>(actual, t -> true);
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -26,6 +26,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -264,7 +265,7 @@ public void scanSubscriber() {
     @Test
     public void scanConditionalSubscriber() {
 	    @SuppressWarnings("unchecked")
-	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxFilter.FilterConditionalSubscriber<String> test = new FluxFilter.FilterConditionalSubscriber<>(actual, t -> true);
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxFlattenIterableTest.java
Patch:
@@ -338,7 +338,8 @@ public void testPublishingTwice() {
 
     @Test
     public void scanOperator() {
-        Flux<Integer> source = Flux.range(1, 10);
+        Flux<Integer> source = Flux.range(1, 10).map(i -> i - 1);
+
         FluxFlattenIterable<Integer, Integer> test = new FluxFlattenIterable<>(source, i -> new ArrayList<>(i), 35, Queues.one());
 
         assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/FluxHandleTest.java
Patch:
@@ -31,6 +31,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.publisher.TestPublisher;
@@ -402,7 +403,7 @@ public void scanSubscriber() {
     @Test
     public void scanConditionalSubscriber() {
 	    @SuppressWarnings("unchecked")
-	    Fuseable.ConditionalSubscriber<? super Object> subscriber = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    Fuseable.ConditionalSubscriber<? super Object> subscriber = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxHandle.HandleConditionalSubscriber<String, String> test =
         		new FluxHandle.HandleConditionalSubscriber<>(subscriber, (a, b) -> {});
         Subscription parent = Operators.emptySubscription();
@@ -439,7 +440,7 @@ public void scanFuseableSubscriber() {
     @Test
     public void scanFuseableConditionalSubscriber() {
 	    @SuppressWarnings("unchecked")
-	    Fuseable.ConditionalSubscriber<? super Object> subscriber = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    Fuseable.ConditionalSubscriber<? super Object> subscriber = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
 	    FluxHandleFuseable.HandleFuseableConditionalSubscriber<String, String> test =
         		new FluxHandleFuseable.HandleFuseableConditionalSubscriber<>(subscriber, (a, b) -> {});
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxIterableTest.java
Patch:
@@ -25,6 +25,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -151,7 +152,7 @@ public void scanSubscription() {
 	@Test
 	public void scanConditionalSubscription() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<? super String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<? super String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxIterable.IterableSubscriptionConditional<String> test =
 				new FluxIterable.IterableSubscriptionConditional<>(actual, Collections.singleton("test").iterator());
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxMapTest.java
Patch:
@@ -26,6 +26,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -312,7 +313,7 @@ public void scanSubscriber() {
     @Test
     public void scanConditionalSubscriber() {
 	    @SuppressWarnings("unchecked")
-	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxMap.MapConditionalSubscriber<Integer, String> test = new FluxMap.MapConditionalSubscriber<>(actual, i -> String.valueOf(i));
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);
@@ -344,7 +345,7 @@ public void scanFuseableSubscriber() {
     @Test
     public void scanFuseableConditionalSubscriber() {
 	    @SuppressWarnings("unchecked")
-	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxMapFuseable.MapFuseableConditionalSubscriber<Integer, String> test =
         		new FluxMapFuseable.MapFuseableConditionalSubscriber<>(actual, i -> String.valueOf(i));
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameFuseableTest.java
Patch:
@@ -36,7 +36,7 @@ public void scanOperator() throws Exception {
 		tags.add(tag1);
 		tags.add(tag2);
 
-		Flux<Integer> source = Flux.range(1, 4);
+		Flux<Integer> source = Flux.range(1, 4).map(i -> i);
 		FluxNameFuseable<Integer> test = new FluxNameFuseable<>(source, "foo", tags);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/FluxNameTest.java
Patch:
@@ -36,7 +36,7 @@ public void scanOperator() throws Exception {
 		tags.add(tag1);
 		tags.add(tag2);
 
-		Flux<Integer> source = Flux.range(1, 4);
+		Flux<Integer> source = Flux.range(1, 4).map(i -> i);
 		FluxName<Integer> test = new FluxName<>(source, "foo", tags);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -33,6 +33,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.concurrent.Queues;
@@ -847,7 +848,7 @@ public void scanFuseableSubscriber() {
     @Test
     public void scanFuseableConditionalSubscriber() {
 	    @SuppressWarnings("unchecked")
-	    Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxPeek<Integer> peek = new FluxPeek<>(Flux.just(1), s -> {}, s -> {},
         		e -> {}, () -> {}, () -> {}, r -> {}, () -> {});
         FluxPeekFuseable.PeekFuseableConditionalSubscriber<Integer> test =

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -50,6 +50,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
@@ -1281,7 +1282,7 @@ public void scanSubscriber() {
 	@Test
     public void scanConditionalSubscriber() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
         FluxPublishOn.PublishOnConditionalSubscriber<Integer> test =
         		new FluxPublishOn.PublishOnConditionalSubscriber<>(actual, Schedulers.single(),
         				Schedulers.single().createWorker(), true, 123, Queues.unbounded());

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -477,7 +477,7 @@ public void retryWithPublishOn() {
 
 	@Test
     public void scanMain() {
-        Flux<Integer> parent = Flux.just(1);
+        Flux<Integer> parent = Flux.just(1).map(i -> i);
         FluxPublish<Integer> test = new FluxPublish<>(parent, 123, Queues.unbounded());
 
         assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxRangeTest.java
Patch:
@@ -21,6 +21,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.subscriber.AssertSubscriber;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -143,7 +144,7 @@ public void scanSubscription() {
 	@Test
 	public void scanConditionalSubscription() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
 		FluxRange.RangeSubscriptionConditional test = new FluxRange.RangeSubscriptionConditional(actual, 1L, 10L);
 
 		assertThat(test.scan(Scannable.Attr.ACTUAL)).isSameAs(actual);

File: reactor-core/src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -286,7 +286,7 @@ public void cancel() {
 
 	@Test
     public void scanMain() {
-        Flux<Integer> parent = Flux.just(1);
+        Flux<Integer> parent = Flux.just(1).map(i -> i);
         FluxReplay<Integer> test = new FluxReplay<>(parent, 25, 1000, Schedulers.single());
 
         Assertions.assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -112,7 +112,7 @@ public void fluxEmpty() {
 
 	@Test
 	public void scanMain() {
-		Flux<Integer> parent = Flux.range(1,  10);
+		Flux<Integer> parent = Flux.range(1,  10).map(i -> i);
 		FluxSource<Integer> test = new FluxSource<>(parent);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeTest.java
Patch:
@@ -17,15 +17,14 @@
 package reactor.core.publisher;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Assert;
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
 import reactor.test.subscriber.AssertSubscriber;
@@ -603,7 +602,7 @@ public void scanSubscriber() {
 	@Test
     public void scanConditionalSubscriber() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
 		FluxTake.TakeConditionalSubscriber<Integer> test = new FluxTake.TakeConditionalSubscriber<>(actual, 5);
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -30,6 +30,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.test.MockUtils;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
@@ -331,7 +332,7 @@ public void scanSubscriber() {
 	@Test
     public void scanConditionalSubscriber() {
 		@SuppressWarnings("unchecked")
-		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(MockUtils.TestScannableConditionalSubscriber.class);
 		FluxUsing.UsingConditionalSubscriber<Integer, String> test =
 				new FluxUsing.UsingConditionalSubscriber<>(actual, s -> {}, "", true);
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameFuseableTest.java
Patch:
@@ -36,7 +36,7 @@ public void scanOperator() throws Exception {
 		tags.add(tag1);
 		tags.add(tag2);
 
-		Mono<Integer> source = Mono.just(1);
+		Mono<Integer> source = Mono.just(1).map(i -> i);
 		MonoNameFuseable<Integer> test = new MonoNameFuseable<>(source, "foo", tags);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/MonoNameTest.java
Patch:
@@ -36,7 +36,7 @@ public void scanOperator() throws Exception {
 		tags.add(tag1);
 		tags.add(tag2);
 
-		Mono<Integer> source = Mono.just(1);
+		Mono<Integer> source = Mono.just(1).map(i -> i);
 		MonoName<Integer> test = new MonoName<>(source, "foo", tags);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/MonoSourceTest.java
Patch:
@@ -158,7 +158,7 @@ public void onAssemblyDescription() {
 
 	@Test
 	public void scanSubscriber() {
-		Flux<String> source = Flux.just("foo");
+		Flux<String> source = Flux.just("foo").map(i -> i);
 		Mono<String> test = Mono.fromDirect(source);
 
 		assertThat(Scannable.from(test).scan(Scannable.Attr.PARENT)).isSameAs(source);
@@ -177,7 +177,7 @@ public void scanSubscriberHide() {
 
 	@Test
 	public void scanSubscriberIgnore() {
-		Flux<String> source = Flux.just("foo");
+		Flux<String> source = Flux.just("foo").map(i -> i);
 		MonoIgnorePublisher<String> test = new MonoIgnorePublisher<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);
@@ -186,7 +186,7 @@ public void scanSubscriberIgnore() {
 
 	@Test
 	public void scanSubscriberFrom() {
-		Flux<String> source = Flux.just("foo");
+		Flux<String> source = Flux.just("foo").map(i -> i);
 		MonoFromPublisher<String> test = new MonoFromPublisher<>(source);
 
 		assertThat(test.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/test/java/reactor/core/publisher/ParallelSourceTest.java
Patch:
@@ -35,7 +35,7 @@ public void parallelism() {
 
 	@Test
 	public void scanOperator() throws Exception {
-		Flux<String> source = Flux.empty();
+		Flux<String> source = Flux.just("").map(i -> i);
 		ParallelSource<String> test = new ParallelSource<>(source, 100, 123,
 				Queues.small());
 

File: reactor-core/src/test/java/reactor/core/publisher/SignalLoggerTests.java
Patch:
@@ -99,7 +99,7 @@ public void cancel() {}
 
 	@Test
 	public void scanSignalLogger() {
-		Mono<String> source = Mono.empty();
+		Mono<String> source = Mono.just("").map(i -> i);
 		SignalLogger<String> sl = new SignalLogger<>(source, null, Level.INFO, false);
 
 		Assertions.assertThat(sl.scan(Scannable.Attr.PARENT)).isSameAs(source);

File: reactor-core/src/main/java/reactor/adapter/JdkFlowAdapter.java
Patch:
@@ -34,7 +34,7 @@
 public abstract class JdkFlowAdapter {
 
 	/**
-	 * Return a {@link Flux} from a java {@code Flow.Publisher}
+	 * Return a java {@code Flow.Publisher} from a {@link Flux}
 	 * @param publisher the source Publisher to convert
 	 * @param <T> the type of the publisher
 	 * @return a java {@code Flow.Publisher} from the given {@link Publisher}

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -180,9 +180,7 @@ public T poll() {
 			T[] a = array;
 			if (i != a.length) {
 				T t = a[i];
-				if (t == null) {
-					throw new NullPointerException();
-				}
+				Objects.requireNonNull(t);
 				index = i + 1;
 				return t;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishMulticast.java
Patch:
@@ -46,7 +46,7 @@ final class MonoPublishMulticast<T, R> extends MonoOperator<T, R> implements Fus
 	@Override
 	public void subscribe(CoreSubscriber<? super R> actual) {
 
-		FluxPublishMulticast.FluxPublishMulticaster<T, R> multicast =
+		FluxPublishMulticast.FluxPublishMulticaster<T> multicast =
 				new FluxPublishMulticast.FluxPublishMulticaster<>(Integer.MAX_VALUE,
 						Queues.one(), actual.currentContext());
 

File: reactor-core/src/main/java/reactor/core/Exceptions.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import reactor.util.annotation.NonNull;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -104,7 +103,7 @@ public static <T> boolean addThrowable(AtomicReferenceFieldUpdater<T, Throwable>
 	 * suppressed exceptions
 	 * @see #addThrowable(AtomicReferenceFieldUpdater, Object, Throwable)
 	 */
-	public static RuntimeException multiple(Throwable @NonNull ... throwables) {
+	public static RuntimeException multiple(Throwable... throwables) {
 		CompositeException multiple = new CompositeException();
 		//noinspection ConstantConditions
 		if (throwables != null) {
@@ -129,7 +128,7 @@ public static RuntimeException multiple(Throwable @NonNull ... throwables) {
 	 * suppressed exceptions
 	 * @see #addThrowable(AtomicReferenceFieldUpdater, Object, Throwable)
 	 */
-	public static RuntimeException multiple(Iterable<@NonNull Throwable> throwables) {
+	public static RuntimeException multiple(Iterable<Throwable> throwables) {
 		RuntimeException multiple = new RuntimeException("Multiple exceptions");
 		//noinspection ConstantConditions
 		if (throwables != null) {

File: reactor-core/src/main/java/reactor/core/publisher/DelegateProcessor.java
Patch:
@@ -22,9 +22,10 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -26,8 +26,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Buffers elements into custom collections where the buffer boundary is signalled

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -34,8 +34,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * buffers elements into possibly overlapping buffers whose boundaries are determined

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -33,8 +33,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Combines the latest values from multiple sources through a function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -29,8 +29,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 import static reactor.core.Exceptions.TERMINATED;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxContextStart.java
Patch:
@@ -22,8 +22,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 final class FluxContextStart<T> extends FluxOperator<T, T> implements Fuseable {
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -32,9 +32,9 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxSink.OverflowStrategy;
+import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
-import reactor.util.annotation.Nullable;
 
 /**
  * Provides a multi-valued sink API for a callback that is called for each individual

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -21,8 +21,8 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Delays the subscription to the main source until another Publisher

File: reactor-core/src/main/java/reactor/core/publisher/FluxElapsed.java
Patch:
@@ -22,9 +22,9 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorOnRequest.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
+import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.util.annotation.Nullable;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -31,9 +31,9 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
-import reactor.util.annotation.Nullable;
 
 /**
  * Maps each upstream value into a single {@code true} or {@code false} value provided by

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -33,8 +33,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Maps a sequence of values each into a Publisher and flattens them

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -24,8 +24,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Generate signals one-by-one via a function callback.

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -33,8 +33,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Groups upstream items into their own Publisher sequence based on a key selector.

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -37,8 +37,8 @@
 import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * A Publisher that correlates two Publishers when they overlap in time and groups the

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -21,8 +21,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Maps the values of the source publisher one-on-one via a handler function as long as the handler function result is

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -23,8 +23,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Maps the values of the source publisher one-on-one via a handler function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -34,9 +34,9 @@
 import reactor.core.Fuseable.QueueSubscription;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxConcatMap.ErrorMode;
+import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
-import reactor.util.annotation.Nullable;
 
 /**
  * Maps each upstream value into a Publisher and concatenates them into one

File: reactor-core/src/main/java/reactor/core/publisher/FluxName.java
Patch:
@@ -23,9 +23,9 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import reactor.util.annotation.Nullable;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/FluxNameFuseable.java
Patch:
@@ -20,8 +20,8 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.util.function.Tuple2;
 import reactor.util.annotation.Nullable;
+import reactor.util.function.Tuple2;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -24,9 +24,9 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple3;
 import reactor.util.function.Tuples;
-import reactor.util.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this publisher is created and

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -26,8 +26,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.concurrent.Queues;
 import reactor.util.annotation.Nullable;
+import reactor.util.concurrent.Queues;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxOperator.java
Patch:
@@ -17,8 +17,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
+import java.util.function.BiFunction;
+import java.util.function.Function;
 
 import org.reactivestreams.Publisher;
+import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -23,8 +23,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.publisher.FluxPeekFuseable.PeekConditionalSubscriber;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Peek into the lifecycle events and signals of a sequence.

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -23,8 +23,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Peek into the lifecycle events and signals of a sequence.

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -31,8 +31,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Shares a sequence for the duration of a function that may transform it and

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -26,8 +26,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Repeats a source when a companion sequence signals an item in response to the main's

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -34,8 +34,8 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
-import reactor.util.concurrent.Queues;
 import reactor.util.annotation.Nullable;
+import reactor.util.concurrent.Queues;
 
 /**
  * @param <T>

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -25,8 +25,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * retries a source when a companion sequence signals

File: reactor-core/src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -25,8 +25,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Samples the main source and emits its latest value whenever the other Publisher

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -28,8 +28,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Takes a value from upstream then uses the duration provided by a

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -31,8 +31,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Emits the last value from upstream only if there were no newer values emitted

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -24,8 +24,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Skips values from the main publisher until the other publisher signals

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -32,8 +32,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Switches to a new Publisher generated via a function whenever the upstream produces an

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -23,8 +23,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Relays values from the main Publisher until another Publisher signals an event.

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -30,8 +30,8 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Splits the source sequence into continuous, non-overlapping windowEnds

File: reactor-core/src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -25,8 +25,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Combines values from a main Publisher with values from another

File: reactor-core/src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -35,8 +35,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 import static reactor.core.Fuseable.ASYNC;
 import static reactor.core.Fuseable.SYNC;

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -23,8 +23,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * An unbounded Java Lambda adapter to {@link Subscriber}, targetted at {@link Mono}.

File: reactor-core/src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -23,9 +23,9 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
+import reactor.util.annotation.Nullable;
 import reactor.util.context.Context;
 
-import reactor.util.annotation.Nullable;
 
 /**
  * An unbounded Java Lambda adapter to {@link Subscriber}

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -26,8 +26,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.publisher.FluxCreate.SinkDisposable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Wraps a the downstream Subscriber into a single emission object and calls the given

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -27,8 +27,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Waits for a Mono source to terminate or produce a value, in which case the value is

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -27,8 +27,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Maps the upstream value into a single {@code true} or {@code false} value

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -26,8 +26,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Given a Mono source, applies a function on its single item and continues

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -27,8 +27,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 final class MonoFlatMapMany<T, R> extends FluxFromMonoOperator<T, R> {
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -27,8 +27,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Concatenates a several Mono sources with a final Mono source by

File: reactor-core/src/main/java/reactor/core/publisher/MonoName.java
Patch:
@@ -23,9 +23,9 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import reactor.util.annotation.Nullable;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/MonoNameFuseable.java
Patch:
@@ -20,8 +20,8 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.util.function.Tuple2;
 import reactor.util.annotation.Nullable;
+import reactor.util.function.Tuple2;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/MonoOperator.java
Patch:
@@ -17,9 +17,12 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
+import java.util.function.BiFunction;
+import java.util.function.Function;
 
 
 import org.reactivestreams.Publisher;
+import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.annotation.Nullable;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -31,8 +31,9 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.concurrent.WaitStrategy;
 import reactor.util.annotation.Nullable;
+import reactor.util.concurrent.WaitStrategy;
+import reactor.util.context.Context;
 
 /**
  * A {@code MonoProcessor} is a {@link Mono} extension that implements stateful semantics. Multi-subscribe is allowed.

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -27,9 +27,9 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
-import reactor.util.annotation.Nullable;
 
 import static reactor.core.publisher.Operators.cancelledSubscription;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -22,8 +22,8 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Wrapper API around an actual downstream Subscriber

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.concurrent.Callable;
 import java.util.function.Supplier;
 
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.annotation.Nullable;

File: reactor-core/src/main/java/reactor/core/publisher/MonoZip.java
Patch:
@@ -28,8 +28,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Waits for all Mono sources to produce a value or terminate, and if all of them produced

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxName.java
Patch:
@@ -23,9 +23,9 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import reactor.util.annotation.Nullable;
 
 /**
  * Hides the identities of the upstream Publisher object and its Subscription as well.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -25,8 +25,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Reduces all 'rails' into a single value which then gets reduced into a single

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -27,8 +27,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Merges the individual 'rails' of the source ParallelFlux, unordered,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -28,8 +28,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Given sorted rail sequences (according to the provided comparator) as List

File: reactor-core/src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -20,8 +20,8 @@
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.util.annotation.Nullable;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Execute a Consumer in each 'rail' for the current element passing through.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -28,8 +28,8 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Dispatches the values from upstream in a round robin fashion to subscribers which are

File: reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -25,9 +25,9 @@
 import java.util.function.LongSupplier;
 import java.util.function.Supplier;
 
+import reactor.util.annotation.Nullable;
 import reactor.util.concurrent.Queues;
 import reactor.util.concurrent.WaitStrategy;
-import reactor.util.annotation.Nullable;
 import sun.misc.Unsafe;
 
 import static java.util.Arrays.copyOf;

File: reactor-core/src/main/java/reactor/core/publisher/SignalPeek.java
Patch:
@@ -21,8 +21,8 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Peek into the lifecycle and sequence signals.

File: reactor-core/src/main/java/reactor/core/publisher/StrictSubscriber.java
Patch:
@@ -25,8 +25,8 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.Context;
 import reactor.util.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Reactive Streams Commons safe exit

File: reactor-core/src/main/java/reactor/util/Loggers.java
Patch:
@@ -401,7 +401,7 @@ public void error(String msg, Throwable t) {
 		}
 
 		@Nullable
-		private String format(@Nullable String from, @Nullable Object @Nullable ... arguments){
+		private String format(@Nullable String from, @Nullable Object... arguments){
 			if(from != null) {
 				String computed = from;
 				if (arguments != null && arguments.length != 0) {
@@ -449,7 +449,7 @@ public String getName() {
 		}
 
 		@Nullable
-		private String format(@Nullable String from, @Nullable Object @Nullable ... arguments){
+		private String format(@Nullable String from, @Nullable Object... arguments){
 			if(from != null) {
 				String computed = from;
 				if (arguments != null && arguments.length != 0) {

File: reactor-core/src/main/java/reactor/util/annotation/Nullable.java
Patch:
@@ -32,7 +32,7 @@
  * indicate nullability in Java to common tools with JSR 305 support and used by Kotlin to
  * infer nullability of Reactor API.
  *
- * <p>Should be used at generic type argument, parameter, return value, and field level.
+ * <p>Should be used at parameter, return value, and field level.
  * Methods overrides should repeat parent {@code @Nullable} annotations unless they behave
  * differently.
  *
@@ -45,7 +45,7 @@
  * @see NonNullApi
  * @see NonNull
  */
-@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE, ElementType.FIELD})
+@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @Nonnull(when = When.MAYBE)

File: reactor-core/src/main/java/reactor/util/context/Context.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.Optional;
 import java.util.stream.Stream;
 
-import reactor.util.annotation.NonNull;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -251,7 +250,7 @@ default boolean isEmpty() {
 	 *
 	 * @return a {@link Stream} of key/value pairs held by this context
 	 */
-	Stream<Map.@NonNull Entry<@NonNull Object, @NonNull Object>> stream();
+	Stream<Map.Entry<Object,Object>> stream();
 
 	/**
 	 * Create a new {@link Context} by merging the content of this context and a given

File: reactor-core/src/main/java/reactor/util/context/ContextN.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;

File: reactor-core/src/main/java/reactor/util/function/Tuple2.java
Patch:
@@ -89,7 +89,7 @@ public Object get(int index) {
 	 *
 	 * @return A new Object list.
 	 */
-	public List<@NonNull Object> toList() {
+	public List<Object> toList() {
 		return Arrays.asList(toArray());
 	}
 
@@ -98,7 +98,7 @@ public Object get(int index) {
 	 *
 	 * @return A new Object array.
 	 */
-	public Object @NonNull[] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2};
 	}
 

File: reactor-core/src/main/java/reactor/util/function/Tuple3.java
Patch:
@@ -66,7 +66,7 @@ public Object get(int index) {
 	}
 
 	@Override
-	public Object @NonNull [] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2, t3};
 	}
 

File: reactor-core/src/main/java/reactor/util/function/Tuple4.java
Patch:
@@ -69,7 +69,7 @@ public Object get(int index) {
 	}
 
 	@Override
-	public Object @NonNull [] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2, t3, t4};
 	}
 

File: reactor-core/src/main/java/reactor/util/function/Tuple5.java
Patch:
@@ -72,7 +72,7 @@ public Object get(int index) {
 	}
 
 	@Override
-	public Object @NonNull [] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2, t3, t4, t5};
 	}
 

File: reactor-core/src/main/java/reactor/util/function/Tuple6.java
Patch:
@@ -75,7 +75,7 @@ public Object get(int index) {
 	}
 
 	@Override
-	public Object @NonNull [] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2, t3, t4, t5, t6};
 	}
 

File: reactor-core/src/main/java/reactor/util/function/Tuple7.java
Patch:
@@ -78,7 +78,7 @@ public Object get(int index) {
 	}
 
 	@Override
-	public Object @NonNull [] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2, t3, t4, t5, t6, t7};
 	}
 

File: reactor-core/src/main/java/reactor/util/function/Tuple8.java
Patch:
@@ -82,7 +82,7 @@ public Object get(int index) {
 	}
 
 	@Override
-	public Object @NonNull [] toArray() {
+	public Object[] toArray() {
 		return new Object[]{t1, t2, t3, t4, t5, t6, t7, t8};
 	}
 

File: reactor-core/src/main/java/reactor/util/package-info.java
Patch:
@@ -21,3 +21,4 @@
 package reactor.util;
 
 import reactor.util.annotation.NonNullApi;
+import javax.annotation.Nullable;
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/CoreTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.Collections;
 
+
 import org.junit.Test;
 import reactor.util.annotation.Nullable;
 

File: reactor-core/src/test/java/reactor/core/publisher/UnicastProcessorTest.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.function.Consumer;
 
+
 import org.junit.Test;
 
 import reactor.core.Disposable;

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;

File: reactor-core/src/test/java/reactor/test/publisher/FluxEmptySyncFuseable.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.test.publisher;
 
+
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Flux;

File: reactor-core/src/test/java/reactor/test/publisher/FluxFuseableExceptionOnPoll.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.test.publisher;
 
+
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;

File: reactor-core/src/test/java/reactor/test/publisher/MonoOperatorTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.function.Function;
 import java.util.function.IntFunction;
 
+
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;

File: reactor-core/src/test/java/reactor/test/publisher/OperatorScenario.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.function.Function;
 import java.util.function.IntFunction;
 
+
 import org.reactivestreams.Publisher;
 import reactor.test.StepVerifier;
 import reactor.util.annotation.Nullable;

File: reactor-core/src/test/java/reactor/test/publisher/ParallelOperatorTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.function.Function;
 import java.util.function.IntFunction;
 
+
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -53,9 +53,9 @@
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.util.Logger;
 import reactor.util.Loggers;
+import reactor.util.annotation.Nullable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import reactor.util.annotation.Nullable;
 
 /**
  * Default implementation of {@link StepVerifier.Step} and

File: reactor-test/src/main/java/reactor/test/StepVerifierOptions.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.function.Supplier;
 
 import reactor.test.scheduler.VirtualTimeScheduler;
-import reactor.util.annotation.NonNull;
 import reactor.util.annotation.Nullable;
 
 /**
@@ -90,7 +89,7 @@ public long getInitialRequest() {
 	 * @param vtsLookup the supplier of {@link VirtualTimeScheduler} to use.
 	 * @return this instance, to continue setting the options.
 	 */
-	public StepVerifierOptions virtualTimeSchedulerSupplier(Supplier<? extends @NonNull VirtualTimeScheduler> vtsLookup) {
+	public StepVerifierOptions virtualTimeSchedulerSupplier(Supplier<? extends VirtualTimeScheduler> vtsLookup) {
 		this.vtsLookup = vtsLookup;
 		return this;
 	}
@@ -101,7 +100,7 @@ public StepVerifierOptions virtualTimeSchedulerSupplier(Supplier<? extends @NonN
 	 *
 	 */
 	@Nullable
-	public Supplier<? extends @NonNull VirtualTimeScheduler> getVirtualTimeSchedulerSupplier() {
+	public Supplier<? extends VirtualTimeScheduler> getVirtualTimeSchedulerSupplier() {
 		return vtsLookup;
 	}
 }

File: reactor-core/src/main/java/reactor/adapter/package-info.java
Patch:
@@ -26,4 +26,4 @@
 @NonNullApi
 package reactor.adapter;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/Disposable.java
Patch:
@@ -18,7 +18,8 @@
 
 import java.util.Collection;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
+
+import reactor.util.annotation.Nullable;
 
 /**
  * Indicates that a task or resource can be cancelled/disposed.

File: reactor-core/src/main/java/reactor/core/package-info.java
Patch:
@@ -22,4 +22,4 @@
 @NonNullApi
 package reactor.core;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java
Patch:
@@ -22,7 +22,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/DelegateProcessor.java
Patch:
@@ -17,15 +17,14 @@
 
 import java.util.Objects;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits the contents of a wrapped (shared) array.

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -18,11 +18,11 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Connects to the underlying Flux once the given amount of Subscribers

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -18,12 +18,12 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Connects to the underlying Flux once the given amount of Subscribers

File: reactor-core/src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -23,10 +23,10 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Buffers a certain number of subsequent elements and emits the buffers.

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -21,13 +21,13 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Buffers elements into custom collections where the buffer boundary is signalled

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -25,12 +25,12 @@
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Buffers elements into custom collections where the buffer boundary is determined by

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java
Patch:
@@ -23,13 +23,13 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -28,14 +28,14 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * buffers elements into possibly overlapping buffers whose boundaries are determined

File: reactor-core/src/main/java/reactor/core/publisher/FluxCancelOn.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Objects;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 final class FluxCancelOn<T> extends FluxOperator<T, T> {
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -35,6 +34,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Combines the latest values from multiple sources through a function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -18,11 +18,11 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
+import reactor.util.annotation.Nullable;
 
 /**
  * Concatenates a fixed array of Publishers' values.

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -31,6 +30,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 import static reactor.core.Exceptions.TERMINATED;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxContextStart.java
Patch:
@@ -18,12 +18,12 @@
 
 import java.util.Objects;
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 final class FluxContextStart<T> extends FluxOperator<T, T> implements Fuseable {
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
@@ -35,6 +34,7 @@
 import reactor.core.publisher.FluxSink.OverflowStrategy;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Provides a multi-valued sink API for a callback that is called for each individual

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefaultIfEmpty.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a scalar value if the source sequence turns out to be empty.

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -17,12 +17,12 @@
 
 import java.util.Objects;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Delays the subscription to the main source until another Publisher

File: reactor-core/src/main/java/reactor/core/publisher/FluxDematerialize.java
Patch:
@@ -20,10 +20,10 @@
 import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.BooleanSupplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxDetach.java
Patch:
@@ -15,11 +15,11 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Detaches the both the child Subscriber and the Subscription on

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinct.java
Patch:
@@ -20,13 +20,13 @@
 import java.util.Objects;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.Fuseable.QueueSubscription;
+import reactor.util.annotation.Nullable;
 
 /**
  * For each subscriber, tracks the source values that have been seen and

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -18,11 +18,11 @@
 import java.util.Objects;
 import java.util.function.BiPredicate;
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Filters out subsequent and repeated elements.

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFinally.java
Patch:
@@ -18,14 +18,14 @@
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.Fuseable.QueueSubscription;
+import reactor.util.annotation.Nullable;
 
 /**
  * Hook into the lifecycle events and signals of a {@link Flux} and execute

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.Objects;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peek into the lifecycle events and signals of a sequence

File: reactor-core/src/main/java/reactor/core/publisher/FluxElapsed.java
Patch:
@@ -17,14 +17,14 @@
 package reactor.core.publisher;
 
 import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -15,10 +15,10 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Represents an empty publisher which only calls onSubscribe and onComplete.

File: reactor-core/src/main/java/reactor/core/publisher/FluxErrorOnRequest.java
Patch:
@@ -18,10 +18,9 @@
 
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import javax.annotation.Nullable;
 
-import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a constant or generated Throwable instance to Subscribers.

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilter.java
Patch:
@@ -18,12 +18,12 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Filters out values that make a filter function return false.

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterFuseable.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Filters out values that make a filter function return false.

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -34,6 +33,7 @@
 import reactor.core.Scannable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps each upstream value into a single {@code true} or {@code false} value provided by

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -20,12 +20,12 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Given a push of source Publishers the values of that Publisher is forwarded to the

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -35,6 +34,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps a sequence of values each into a Publisher and flattens them

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -25,13 +25,13 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Concatenates values from Iterable sequences generated via a mapper function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxFromMonoOperator.java
Patch:
@@ -17,10 +17,10 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A decorating {@link Flux} {@link Publisher} that exposes {@link Flux} API over an

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -20,12 +20,12 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Generate signals one-by-one via a function callback.

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -35,6 +34,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Groups upstream items into their own Publisher sequence based on a key selector.

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -28,7 +28,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -39,6 +38,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * A Publisher that correlates two Publishers when they overlap in time and groups the

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -17,12 +17,12 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps the values of the source publisher one-on-one via a handler function as long as the handler function result is

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -18,13 +18,13 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps the values of the source publisher one-on-one via a handler function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxHide.java
Patch:
@@ -15,11 +15,11 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Hides the identities of the upstream Publisher object and its Subscription

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.annotation.Nullable;
 
 /**
  * Periodically emits an ever increasing long value either via a ScheduledExecutorService

File: reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Iterator;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits the contents of an Iterable source.

File: reactor-core/src/main/java/reactor/core/publisher/FluxJoin.java
Patch:
@@ -28,7 +28,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -40,6 +39,7 @@
 import reactor.core.publisher.FluxGroupJoin.JoinSupport;
 import reactor.core.publisher.FluxGroupJoin.LeftRightEndSubscriber;
 import reactor.core.publisher.FluxGroupJoin.LeftRightSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -17,11 +17,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A Stream that emits only one value and then complete.

File: reactor-core/src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.Objects;
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps the values of the source publisher one-on-one via a mapper function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapFuseable.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.Objects;
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps the values of the source publisher one-on-one via a mapper function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -22,10 +22,10 @@
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps the values of the source publisher one-on-one via a mapper function.

File: reactor-core/src/main/java/reactor/core/publisher/FluxMaterialize.java
Patch:
@@ -20,10 +20,10 @@
 import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.BooleanSupplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -37,6 +36,7 @@
 import reactor.core.publisher.FluxConcatMap.ErrorMode;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps each upstream value into a Publisher and concatenates them into one

File: reactor-core/src/main/java/reactor/core/publisher/FluxName.java
Patch:
@@ -20,12 +20,12 @@
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
+import reactor.util.annotation.Nullable;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/FluxNameFuseable.java
Patch:
@@ -17,11 +17,11 @@
 package reactor.core.publisher;
 
 import java.util.Set;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.function.Tuple2;
+import reactor.util.annotation.Nullable;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.LinkedList;
 import java.util.List;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
@@ -27,6 +26,7 @@
 import reactor.core.Scannable;
 import reactor.util.function.Tuple3;
 import reactor.util.function.Tuples;
+import reactor.util.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this publisher is created and

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -20,14 +20,14 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.util.concurrent.Queues;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferStrategy.java
Patch:
@@ -20,12 +20,12 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
+import reactor.util.annotation.Nullable;
 
 /**
  * Buffers values if the subscriber doesn't request fast enough, bounding the

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java
Patch:
@@ -24,13 +24,13 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.Logger;
 import reactor.util.Loggers;
+import reactor.util.annotation.Nullable;
 
 /**
  * Buffers values if the subscriber doesn't request fast enough, bounding the buffer to a

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -19,10 +19,10 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Drops values if the subscriber doesn't request fast enough.

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -18,11 +18,11 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Runs the source in unbounded mode and emits only the latest value

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -17,14 +17,14 @@
 
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.publisher.FluxPeekFuseable.PeekConditionalSubscriber;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peek into the lifecycle events and signals of a sequence.

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -18,13 +18,13 @@
 
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peek into the lifecycle events and signals of a sequence.

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -19,14 +19,14 @@
 import java.util.Objects;
 import java.util.concurrent.CancellationException;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Processor;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A base processor that exposes {@link Flux} API for {@link Processor}.

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -25,14 +25,14 @@
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A connectable publisher which shares an underlying source and dispatches source values

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
@@ -33,6 +32,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Shares a sequence for the duration of a function that may transform it and

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -31,6 +30,7 @@
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits events on a different thread specified by a scheduler callback.

File: reactor-core/src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a range of integer values.

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Connects to the underlying Flux once the given number of Subscribers subscribed

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
@@ -30,6 +29,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Simon Baslé

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -20,14 +20,14 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Repeats a source when a companion sequence signals an item in response to the main's

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -36,6 +35,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.concurrent.Queues;
+import reactor.util.annotation.Nullable;
 
 /**
  * @param <T>

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -19,14 +19,14 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * retries a source when a companion sequence signals

File: reactor-core/src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -19,14 +19,14 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Samples the main source and emits its latest value whenever the other Publisher

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -22,14 +22,14 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Takes a value from upstream then uses the duration provided by a

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -33,6 +32,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits the last value from upstream only if there were no newer values emitted

File: reactor-core/src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.Objects;
 import java.util.function.BiFunction;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Accumulates the source values with an accumulator function and

File: reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -20,10 +20,10 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.BiFunction;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Aggregates the source values with the help of an accumulator function

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkip.java
Patch:
@@ -15,10 +15,10 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Skips the first N elements from a reactive stream.

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipLast.java
Patch:
@@ -16,10 +16,10 @@
 package reactor.core.publisher;
 
 import java.util.ArrayDeque;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Skips the last N elements from the source stream.

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Skips source values while a predicate returns

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Skips values from the main publisher until the other publisher signals

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Skips source values while a predicate returns

File: reactor-core/src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A connecting {@link Flux} Publisher (right-to-left from a composition chain perspective)

File: reactor-core/src/main/java/reactor/core/publisher/FluxSourceFuseable.java
Patch:
@@ -16,12 +16,12 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.annotation.Nullable;
 
 /**
  * Subscribes to the source Publisher asynchronously through a scheduler function or

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -21,12 +21,12 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * Executes a Callable and emits its value on the given Scheduler.

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
@@ -29,6 +28,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * Publisher indicating a scalar/empty source that subscribes on the specified scheduler.

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -34,6 +33,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Switches to a new Publisher generated via a function whenever the upstream produces an

File: reactor-core/src/main/java/reactor/core/publisher/FluxTake.java
Patch:
@@ -16,13 +16,13 @@
 package reactor.core.publisher;
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.Fuseable.QueueSubscription;
+import reactor.util.annotation.Nullable;
 
 /**
  * Takes only the first N values from the source Publisher.

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -19,10 +19,10 @@
 import java.util.ArrayDeque;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.BooleanSupplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits the last N values the source emitted before its completion.

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Relays values until a predicate returns

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -18,13 +18,13 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Relays values from the main Publisher until another Publisher signals an event.

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Relays values while a predicate returns

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -21,13 +21,13 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Uses a resource, generated by a supplier for each individual Subscriber,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindow.java
Patch:
@@ -23,14 +23,14 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Processor;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Splits the source sequence into possibly overlapping publishers.

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -32,6 +31,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Splits the source sequence into continuous, non-overlapping windowEnds

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -33,6 +32,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxBufferPredicate.Mode;
+import reactor.util.annotation.Nullable;
 
 /**
  * Cut a sequence into non-overlapping windows where each window boundary is determined by

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java
Patch:
@@ -21,13 +21,13 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * WindowTimeoutSubscriber is forwarding events on a steam until {@code maxSize} is reached,

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -25,14 +25,14 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
+import reactor.util.annotation.Nullable;
 
 /**
  * Splits the source sequence into potentially overlapping windowEnds controlled by items

File: reactor-core/src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -20,13 +20,13 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.BiFunction;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Combines values from a main Publisher with values from another

File: reactor-core/src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -27,7 +27,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
@@ -37,6 +36,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 import static reactor.core.Fuseable.ASYNC;
 import static reactor.core.Fuseable.SYNC;

File: reactor-core/src/main/java/reactor/core/publisher/FluxZipIterable.java
Patch:
@@ -19,10 +19,10 @@
 import java.util.Iterator;
 import java.util.Objects;
 import java.util.function.BiFunction;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Pairwise combines elements of a publisher and an iterable sequence through a function.

File: reactor-core/src/main/java/reactor/core/publisher/GroupedFlux.java
Patch:
@@ -15,7 +15,8 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
+
+import reactor.util.annotation.Nullable;
 
 /**
  * Represents a sequence of events which has an associated key.

File: reactor-core/src/main/java/reactor/core/publisher/ImmutableSignal.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Objects;
 
 import org.reactivestreams.Subscription;
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
 
 /**
  * The common implementation of a {@link Signal} (serializable and immutable).

File: reactor-core/src/main/java/reactor/core/publisher/InnerProducer.java
Patch:
@@ -15,12 +15,12 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  *

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -18,13 +18,13 @@
 
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * An unbounded Java Lambda adapter to {@link Subscriber}, targetted at {@link Mono}.

File: reactor-core/src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -25,7 +25,7 @@
 import reactor.core.Exceptions;
 import reactor.util.context.Context;
 
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
 
 /**
  * An unbounded Java Lambda adapter to {@link Subscriber}

File: reactor-core/src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a single boolean true if all values of the source sequence match

File: reactor-core/src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.util.Objects;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a single boolean true if any of the values of the source sequence match

File: reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java
Patch:
@@ -19,13 +19,13 @@
 import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.Logger;
 import reactor.util.Loggers;
+import reactor.util.annotation.Nullable;
 
 /**
  * An operator that caches the value from a source Mono with a TTL, after which the value

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -18,12 +18,12 @@
 
 import java.time.Duration;
 import java.util.concurrent.Callable;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
+import reactor.util.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this publisher is created and makes it

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Objects;
 import java.util.function.BiConsumer;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Collects the values of the source sequence into a container returned by

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Collection;
 import java.util.Objects;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Buffers all values from the source Publisher and emits it as a single Collection.

File: reactor-core/src/main/java/reactor/core/publisher/MonoCount.java
Patch:
@@ -15,11 +15,11 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Counts the number of values in the source sequence.

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -22,12 +22,12 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.publisher.FluxCreate.SinkDisposable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Wraps a the downstream Subscriber into a single emission object and calls the given

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a single 0L value delayed by some time amount with a help of

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -19,12 +19,12 @@
 import java.util.Objects;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits the first value emitted by a given source publisher, delayed by some time amount

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -21,14 +21,14 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Waits for a Mono source to terminate or produce a value, in which case the value is

File: reactor-core/src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits only the element at the given index position or signals a

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.time.Duration;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Represents an empty publisher which only calls onSubscribe and onComplete.

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -21,14 +21,14 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps the upstream value into a single {@code true} or {@code false} value

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -18,10 +18,10 @@
 
 import java.util.Iterator;
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Given a push of source Publishers the values of that Publisher is forwarded to the

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -21,13 +21,13 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Given a Mono source, applies a function on its single item and continues

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -22,13 +22,13 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 final class MonoFlatMapMany<T, R> extends FluxFromMonoOperator<T, R> {
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromFluxOperator.java
Patch:
@@ -17,10 +17,10 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A decorating {@link Mono} {@link Publisher} that exposes {@link Mono} API over an

File: reactor-core/src/main/java/reactor/core/publisher/MonoFromPublisher.java
Patch:
@@ -17,11 +17,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a single item at most from the source.

File: reactor-core/src/main/java/reactor/core/publisher/MonoHasElement.java
Patch:
@@ -15,11 +15,11 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/MonoHasElements.java
Patch:
@@ -15,11 +15,11 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreElements.java
Patch:
@@ -15,10 +15,10 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Ignores normal values and passes only the terminal signals along.

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnorePublisher.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Ignores normal values and passes only the terminal signals along.

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -21,14 +21,14 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Concatenates a several Mono sources with a final Mono source by

File: reactor-core/src/main/java/reactor/core/publisher/MonoName.java
Patch:
@@ -20,12 +20,12 @@
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
+import reactor.util.annotation.Nullable;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/MonoNameFuseable.java
Patch:
@@ -17,11 +17,11 @@
 package reactor.core.publisher;
 
 import java.util.Set;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.util.function.Tuple2;
+import reactor.util.annotation.Nullable;
 
 /**
  * An operator that just bears a name or a set of tags, which can be retrieved via the

File: reactor-core/src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -17,10 +17,10 @@
 package reactor.core.publisher;
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Emits a single item at most from the source.

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -16,11 +16,11 @@
 
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
+import reactor.util.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this publisher is created and makes it

File: reactor-core/src/main/java/reactor/core/publisher/MonoPeek.java
Patch:
@@ -17,12 +17,12 @@
 
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.publisher.FluxPeekFuseable.PeekConditionalSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peeks out values that make a filter function return false.

File: reactor-core/src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peeks out values that make a filter function return false.

File: reactor-core/src/main/java/reactor/core/publisher/MonoPeekTerminal.java
Patch:
@@ -18,12 +18,12 @@
 
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peeks the value of a {@link Mono} and execute terminal callbacks accordingly, allowing

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.LongSupplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Processor;
 import org.reactivestreams.Publisher;
@@ -33,7 +32,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.concurrent.WaitStrategy;
-import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * A {@code MonoProcessor} is a {@link Mono} extension that implements stateful semantics. Multi-subscribe is allowed.

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -18,12 +18,12 @@
 
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * Schedules the emission of the value or completion of the wrapped Mono via

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduce.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.Objects;
 import java.util.function.BiFunction;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Aggregates the source items with an aggregator function and returns the last result.

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Objects;
 import java.util.function.BiFunction;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Aggregates the source values with the help of an accumulator

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -19,9 +19,9 @@
 import java.time.Duration;
 import java.util.Objects;
 import java.util.concurrent.Callable;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Executes the runnable whenever a Subscriber subscribes to this Mono.

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.BiPredicate;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
@@ -30,6 +29,7 @@
 import reactor.core.Scannable;
 import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 import static reactor.core.publisher.Operators.cancelledSubscription;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -18,11 +18,11 @@
 
 import java.util.NoSuchElementException;
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Expects and emits a single item from the source or signals

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Wrapper API around an actual downstream Subscriber

File: reactor-core/src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A decorating {@link Mono} {@link Publisher} that exposes {@link Mono} API over an arbitrary {@link Publisher}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSourceFuseable.java
Patch:
@@ -16,12 +16,12 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -20,11 +20,11 @@
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.stream.Collector;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Collects the values from the source sequence into a {@link java.util.stream.Collector}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.annotation.Nullable;
 
 /**
  * Subscribes to the upstream Mono on the specified Scheduler and makes sure

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -18,12 +18,12 @@
 
 import java.util.Objects;
 import java.util.concurrent.RejectedExecutionException;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledEmpty;
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.annotation.Nullable;
 
 /**
  * Mono indicating a scalar/empty source that subscribes on the specified scheduler.

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.util.NoSuchElementException;
 import java.util.Objects;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Take the very last value from a Publisher source and and emit that one.

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeUntilOther.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;

File: reactor-core/src/main/java/reactor/core/publisher/MonoZip.java
Patch:
@@ -22,14 +22,14 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Waits for all Mono sources to produce a value or terminate, and if all of them produced

File: reactor-core/src/main/java/reactor/core/publisher/OperatorDisposables.java
Patch:
@@ -19,10 +19,10 @@
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Consumer;
-import javax.annotation.Nullable;
 
 import reactor.core.Disposable;
 import reactor.core.Disposables;
+import reactor.util.annotation.Nullable;
 
 /**
  * Utility methods to work with {@link Disposable} atomically.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.Objects;
 import java.util.function.BiConsumer;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Reduce the sequence of values in each 'rail' to a single value.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -19,12 +19,12 @@
 import java.util.Queue;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxConcatMap.ErrorMode;
+import reactor.util.annotation.Nullable;
 
 /**
  * Concatenates the generated Publishers on each rail.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFilter.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Filters each 'rail' of the source ParallelFlux with a predicate function.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -18,11 +18,11 @@
 import java.util.Queue;
 import java.util.function.Function;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Flattens the generated Publishers on each rail.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -16,10 +16,10 @@
 
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Hides the identities of the upstream Publisher object and its Subscription as well.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxName.java
Patch:
@@ -20,12 +20,12 @@
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
+import reactor.util.annotation.Nullable;
 
 /**
  * Hides the identities of the upstream Publisher object and its Subscription as well.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -16,13 +16,13 @@
 
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblyLightSnapshotException;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
+import reactor.util.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this connectable publisher is created and makes it

File: reactor-core/src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -18,12 +18,12 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Exposes the 'rails' as individual GroupedFlux instances, keyed by the rail index (zero based).

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLift.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.Objects;
 import java.util.function.BiFunction;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -15,11 +15,11 @@
  */
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Execute a Consumer in each 'rail' for the current element passing through.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMap.java
Patch:
@@ -16,11 +16,11 @@
 package reactor.core.publisher;
 
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Maps each 'rail' of the source ParallelFlux with a mapper function.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -20,13 +20,13 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.BiFunction;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Reduces all 'rails' into a single value which then gets reduced into a single

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -21,14 +21,14 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Merges the individual 'rails' of the source ParallelFlux, unordered,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -23,13 +23,13 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Given sorted rail sequences (according to the provided comparator) as List

File: reactor-core/src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 import reactor.core.Fuseable;
 
 /**

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -19,13 +19,13 @@
 import java.util.Objects;
 import java.util.function.BiFunction;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.annotation.Nullable;
 
 /**
  * Reduce the sequence of values in each 'rail' to a single value.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -17,13 +17,13 @@
 
 import java.util.Queue;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.annotation.Nullable;
 
 /**
  * Ensures each 'rail' from upstream runs on a Worker from a Scheduler.

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.atomic.AtomicLongArray;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -30,6 +29,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Dispatches the values from upstream in a round robin fashion to subscribers which are

File: reactor-core/src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -27,7 +27,7 @@
 
 import reactor.util.concurrent.Queues;
 import reactor.util.concurrent.WaitStrategy;
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
 import sun.misc.Unsafe;
 
 import static java.util.Arrays.copyOf;

File: reactor-core/src/main/java/reactor/core/publisher/SerializedSubscriber.java
Patch:
@@ -16,10 +16,10 @@
 
 package reactor.core.publisher;
 
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.util.annotation.Nullable;
 
 /**
  * Subscriber that makes sure signals are delivered sequentially in case the onNext, onError or onComplete methods are

File: reactor-core/src/main/java/reactor/core/publisher/SignalPeek.java
Patch:
@@ -21,8 +21,8 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-import javax.annotation.Nullable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Peek into the lifecycle and sequence signals.

File: reactor-core/src/main/java/reactor/core/publisher/StrictSubscriber.java
Patch:
@@ -19,14 +19,14 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
+import reactor.util.annotation.Nullable;
 
 /**
  * Reactive Streams Commons safe exit

File: reactor-core/src/main/java/reactor/core/publisher/package-info.java
Patch:
@@ -47,4 +47,4 @@
 @NonNullApi
 package reactor.core.publisher;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -27,10 +27,10 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Supplier;
-import javax.annotation.Nullable;
 
 import reactor.core.Disposable;
 import reactor.core.Disposables;
+import reactor.util.annotation.Nullable;
 
 /**
  * Dynamically creates ScheduledExecutorService-based Workers and caches the thread pools, reusing

File: reactor-core/src/main/java/reactor/core/scheduler/SchedulerTask.java
Patch:
@@ -20,9 +20,9 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import javax.annotation.Nullable;
 
 import reactor.core.Disposable;
+import reactor.util.annotation.Nullable;
 
 final class SchedulerTask implements Runnable, Disposable, Callable<Void> {
 

File: reactor-core/src/main/java/reactor/core/scheduler/WorkerTask.java
Patch:
@@ -22,9 +22,9 @@
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import javax.annotation.Nullable;
 
 import reactor.core.Disposable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A runnable task for {@link Scheduler} Workers that are time-capable (implementing a

File: reactor-core/src/main/java/reactor/core/scheduler/package-info.java
Patch:
@@ -23,4 +23,4 @@
 @NonNullApi
 package reactor.core.scheduler;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/util/concurrent/SpscArrayQueue.java
Patch:
@@ -21,7 +21,8 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.*;
 
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
+
 
 /**
  * A bounded, array backed, single-producer single-consumer queue.

File: reactor-core/src/main/java/reactor/util/concurrent/SpscLinkedArrayQueue.java
Patch:
@@ -23,7 +23,8 @@
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.function.BiPredicate;
 
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
+
 
 /**
  * An unbounded, array-backed single-producer, single-consumer queue with a fixed link

File: reactor-core/src/main/java/reactor/util/concurrent/package-info.java
Patch:
@@ -24,4 +24,4 @@
 @NonNullApi
 package reactor.util.concurrent;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/util/context/ContextN.java
Patch:
@@ -17,15 +17,15 @@
 
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
+
+import reactor.util.annotation.Nullable;
 
 @SuppressWarnings("unchecked")
 final class ContextN extends HashMap<Object, Object>

File: reactor-core/src/main/java/reactor/util/context/package-info.java
Patch:
@@ -20,4 +20,4 @@
 @NonNullApi
 package reactor.util.context;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/util/function/package-info.java
Patch:
@@ -20,4 +20,4 @@
 @NonNullApi
 package reactor.util.function;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/util/package-info.java
Patch:
@@ -20,5 +20,4 @@
 @NonNullApi
 package reactor.util;
 
-import reactor.util.lang.NonNullApi;
-import javax.annotation.Nullable;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -59,7 +59,6 @@
 import reactor.util.context.Context;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import reactor.util.lang.NonNullApi;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -69,7 +68,6 @@
  * @author Stephane Maldini
  * @author Simon Baslé
  */
-@NonNullApi
 public class GuideTests {
 
 	@Test @SuppressWarnings("unchecked")
@@ -987,7 +985,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single(GuideTests.java:951)\n");
+						.hasMessageEndingWith("Flux.single(GuideTests.java:949)\n");
 			});
 		}
 	}

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -40,7 +40,6 @@
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
@@ -56,6 +55,7 @@
 import reactor.util.Loggers;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
+import reactor.util.annotation.Nullable;
 
 /**
  * Default implementation of {@link StepVerifier.Step} and

File: reactor-test/src/main/java/reactor/test/package-info.java
Patch:
@@ -20,4 +20,4 @@
 @NonNullApi
 package reactor.test;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-test/src/main/java/reactor/test/publisher/DefaultTestPublisher.java
Patch:
@@ -28,7 +28,7 @@
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Operators;
-import javax.annotation.Nullable;
+import reactor.util.annotation.Nullable;
 
 /**
  * A default implementation of a {@link TestPublisher}.

File: reactor-test/src/main/java/reactor/test/publisher/package-info.java
Patch:
@@ -21,4 +21,4 @@
 @NonNullApi
 package reactor.test.publisher;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-test/src/main/java/reactor/test/scheduler/package-info.java
Patch:
@@ -21,4 +21,4 @@
 @NonNullApi
 package reactor.test.scheduler;
 
-import reactor.util.lang.NonNullApi;
\ No newline at end of file
+import reactor.util.annotation.NonNullApi;
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -213,14 +213,14 @@ public void onSubscribe(final Subscription s) {
 				else if (m == Fuseable.ASYNC) {
 					sourceMode = m;
 					queue = f;
-					s.request(prefetch);
+					s.request(Operators.unboundedOrPrefetch(prefetch));
 					return;
 				}
 			}
 
 			queue = Queues.<T>get(prefetch).get();
 
-			s.request(prefetch);
+			s.request(Operators.unboundedOrPrefetch(prefetch));
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -198,7 +198,7 @@ void drain() {
 			}
 
 			int missed = 1;
-			int limit = bufferSize - (bufferSize >> 2);
+			int limit = Operators.unboundedOrLimit(bufferSize);
 			long e = emitted;
 			long ci = consumerIndex;
 			int f = consumed;

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -165,7 +165,7 @@ static final class FlattenIterableSubscriber<T, R>
 			this.mapper = mapper;
 			this.prefetch = prefetch;
 			this.queueSupplier = queueSupplier;
-			this.limit = prefetch - (prefetch >> 2);
+			this.limit = Operators.unboundedOrLimit(prefetch);
 		}
 
 		@Override
@@ -213,7 +213,7 @@ else if (m == Fuseable.ASYNC) {
 
 						actual.onSubscribe(this);
 
-						s.request(prefetch);
+						s.request(Operators.unboundedOrPrefetch(prefetch));
 						return;
 					}
 				}
@@ -222,7 +222,7 @@ else if (m == Fuseable.ASYNC) {
 
 				actual.onSubscribe(this);
 
-				s.request(prefetch);
+				s.request(Operators.unboundedOrPrefetch(prefetch));
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -224,17 +224,17 @@ public void onSubscribe(Subscription s) {
 						drain();
 						return;
 					}
-					else if (m == Fuseable.ASYNC) {
+					if (m == Fuseable.ASYNC) {
 						sourceMode = m;
 						queue = f;
-						s.request(prefetch);
+						s.request(Operators.unboundedOrPrefetch(prefetch));
 						return;
 					}
 				}
 
 				queue = parent.queueSupplier.get();
 
-				s.request(prefetch);
+				s.request(Operators.unboundedOrPrefetch(prefetch));
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -842,7 +842,7 @@ static final class ZipInner<T>
 			this.prefetch = prefetch;
 			this.index = index;
 			this.queueSupplier = queueSupplier;
-			this.limit = prefetch - (prefetch >> 2);
+			this.limit = Operators.unboundedOrLimit(prefetch);
 		}
 
 		@SuppressWarnings("unchecked")
@@ -872,7 +872,7 @@ else if (m == ASYNC) {
 				else {
 					queue = queueSupplier.get();
 				}
-				s.request(prefetch);
+				s.request(Operators.unboundedOrPrefetch(prefetch));
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -547,7 +547,7 @@ public static <T> Mono<Boolean> sequenceEqual(Publisher<? extends T> source1, Pu
 	 *            the second Publisher to compare
 	 * @param isEqual
 	 *            a function used to compare items emitted by each Publisher
-	 * @param bufferSize
+	 * @param prefetch
 	 *            the number of items to prefetch from the first and second source Publisher
 	 * @param <T>
 	 *            the type of items emitted by each Publisher
@@ -556,8 +556,8 @@ public static <T> Mono<Boolean> sequenceEqual(Publisher<? extends T> source1, Pu
 	 */
 	public static <T> Mono<Boolean> sequenceEqual(Publisher<? extends T> source1,
 			Publisher<? extends T> source2,
-			BiPredicate<? super T, ? super T> isEqual, int bufferSize) {
-		return onAssembly(new MonoSequenceEqual<>(source1, source2, isEqual, bufferSize));
+			BiPredicate<? super T, ? super T> isEqual, int prefetch) {
+		return onAssembly(new MonoSequenceEqual<>(source1, source2, isEqual, prefetch));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -136,7 +136,7 @@ static final class ParallelSourceMain<T> implements InnerConsumer<T> {
 			this.subscribers = subscribers;
 			this.prefetch = prefetch;
 			this.queueSupplier = queueSupplier;
-			this.limit = prefetch - (prefetch >> 2);
+			this.limit = Operators.unboundedOrLimit(prefetch);
 			this.requests = new AtomicLongArray(subscribers.length);
 			this.emissions = new long[subscribers.length];
 		}
@@ -189,7 +189,7 @@ public void onSubscribe(Subscription s) {
 						
 						setupSubscribers();
 						
-						s.request(prefetch);
+						s.request(Operators.unboundedOrPrefetch(prefetch));
 						
 						return;
 					}
@@ -199,7 +199,7 @@ public void onSubscribe(Subscription s) {
 				
 				setupSubscribers();
 				
-				s.request(prefetch);
+				s.request(Operators.unboundedOrPrefetch(prefetch));
 			}
 		}
 		

File: reactor-core/src/test/java/reactor/core/publisher/BlockingIterableTest.java
Patch:
@@ -149,10 +149,10 @@ public void scanOperator() {
 	public void scanOperatorLargePrefetchIsLimitedToIntMax() {
 		Flux<Integer> source = Flux.range(1, 10);
 		BlockingIterable<Integer> test = new BlockingIterable<>(source,
-				Integer.MAX_VALUE + 30L,
+				Integer.MAX_VALUE,
 				Queues.one());
 
-		assertThat(test.scan(Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE); //FIXME
+		assertThat(test.scan(Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE);
 	}
 
 	@Test
@@ -175,7 +175,7 @@ public void scanSubscriber() {
 	public void scanSubscriberLargePrefetchIsLimitedToIntMax() {
 		BlockingIterable.SubscriberIterator<String> subscriberIterator =
 				new BlockingIterable.SubscriberIterator<>(Queues.<String>one().get(),
-						Integer.MAX_VALUE + 30L);
+						Integer.MAX_VALUE);
 
 		assertThat(subscriberIterator.scan(Attr.PREFETCH)).isEqualTo(Integer.MAX_VALUE); //FIXME
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxCallableTest.java
Patch:
@@ -26,12 +26,12 @@ public class FluxCallableTest {
 	public void callableReturnsNull() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		Mono.<Integer>fromCallable(() -> null).flux()
+		Mono.<Integer>fromCallable(() -> null).log().flux()
 		                                      .subscribe(ts);
 
 		ts.assertNoValues()
-		  .assertNotComplete()
-		  .assertError(NullPointerException.class);
+		  .assertNoError()
+		  .assertComplete();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java
Patch:
@@ -555,14 +555,14 @@ public void failScalarMapCallableError() {
 	}
 
 	@Test
-	public void failMapCallableNullError() {
+	public void prematureScalarMapCallableNullComplete() {
 		StepVerifier.create(Mono.just(1)
 		                        .flatMapMany(f -> Mono.fromCallable(() -> null)))
-		            .verifyError(NullPointerException.class);
+		            .verifyComplete();
 	}
 
 	@Test
-	public void prematureScalarMapCallableNullComplete() {
+	public void prematureScalarMapCallableEmptyComplete() {
 		StepVerifier.create(Mono.just(1)
 		                        .flatMapMany(f -> Mono.empty()))
 		            .verifyComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1248,7 +1248,7 @@ public void callablePath() {
 		StepVerifier.create(Mono.fromCallable(() -> null)
 		                        .flux()
 		                        .publishOn(Schedulers.immediate()))
-		            .verifyError(NullPointerException.class);
+		            .verifyComplete();
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java
Patch:
@@ -178,9 +178,7 @@ public final void onError(Throwable t) {
 			hookOnError(t);
 		}
 		catch (Throwable e) {
-			if (e != t) {
-				e.addSuppressed(t);
-			}
+			e = Exceptions.addSuppressed(e, t);
 			Operators.onErrorDropped(e, currentContext());
 		}
 		finally {

File: reactor-core/src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java
Patch:
@@ -85,6 +85,7 @@ final T blockingGet() {
 		Throwable e = error;
 		if (e != null) {
 			RuntimeException re = Exceptions.propagate(e);
+			//this is ok, as re is always a new non-singleton instance
 			re.addSuppressed(new Exception("#block terminated with an error"));
 			throw re;
 		}
@@ -112,6 +113,7 @@ final T blockingGet(long timeout, TimeUnit unit) {
 			catch (InterruptedException ex) {
 				dispose();
 				RuntimeException re = Exceptions.propagate(ex);
+				//this is ok, as re is always a new non-singleton instance
 				re.addSuppressed(new Exception("#block has been interrupted"));
 				throw re;
 			}
@@ -120,6 +122,7 @@ final T blockingGet(long timeout, TimeUnit unit) {
 		Throwable e = error;
 		if (e != null) {
 			RuntimeException re = Exceptions.propagate(e);
+			//this is ok, as re is always a new non-singleton instance
 			re.addSuppressed(new Exception("#block terminated with an error"));
 			throw re;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.stream.Stream;
 
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.concurrent.Queues;
 import reactor.util.concurrent.WaitStrategy;
@@ -63,9 +64,7 @@ static <E> Flux<E> coldSource(RingBuffer<Slot<E>> ringBuffer,
 		});
 		if (error != null) {
 			if (t != null) {
-				if (t != error) {
-					t.addSuppressed(error);
-				}
+				t = Exceptions.addSuppressed(t, error);
 				return concat(bufferIterable, Flux.error(t));
 			}
 			return concat(bufferIterable, Flux.error(error));

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnErrorResume.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.core.Exceptions;
 
 /**
  * Resumes the failed main sequence with another sequence returned by
@@ -89,9 +90,7 @@ public void onError(Throwable t) {
 				}
 				catch (Throwable e) {
 					Throwable _e = Operators.onOperatorError(e, actual.currentContext());
-					if (t != _e) {
-						_e.addSuppressed(t);
-					}
+					_e = Exceptions.addSuppressed(_e, t);
 					actual.onError(_e);
 					return;
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Publisher;
 import reactor.core.CoreSubscriber;
+import reactor.core.Exceptions;
 
 /**
  * Repeatedly subscribes to the source if the predicate returns true after
@@ -88,9 +89,7 @@ public void onError(Throwable t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				Throwable _t = Operators.onOperatorError(e, actual.currentContext());
-				if (_t != t) {
-					_t.addSuppressed(t);
-				}
+				_t = Exceptions.addSuppressed(_t, t);
 				actual.onError(_t);
 				return;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -184,6 +184,7 @@ void signal() {
 				Throwable e = mt.error;
 				if (e != null) {
 					if (compositeError != null) {
+						//this is ok as the composite created by multiple is never a singleton
 						compositeError.addSuppressed(e);
 					} else
 					if (error != null) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -171,7 +171,7 @@ else if(subscription == null) {
 						return value;
 					case STATE_ERROR:
 						RuntimeException re = Exceptions.propagate(error);
-						re.addSuppressed(new Exception("Mono#block terminated with an error"));
+						re = Exceptions.addSuppressed(re, new Exception("Mono#block terminated with an error"));
 						throw re;
 					case STATE_COMPLETE_NO_VALUE:
 						return null;
@@ -389,7 +389,7 @@ public O peek() {
 		}
 		else if (endState == STATE_ERROR) {
 			RuntimeException re = Exceptions.propagate(error);
-			re.addSuppressed(new Exception("Mono#peek terminated with an error"));
+			re = Exceptions.addSuppressed(re, new Exception("Mono#peek terminated with an error"));
 			throw re;
 		}
 		else {

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.function.Function;
 
 import reactor.core.CoreSubscriber;
+import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 
 /**
@@ -86,8 +87,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 				resourceCleanup.accept(resource);
 			}
 			catch (Throwable ex) {
-				ex.addSuppressed(Operators.onOperatorError(e, actual.currentContext()));
-				e = ex;
+				e = Exceptions.addSuppressed(ex, Operators.onOperatorError(e, actual.currentContext()));
 			}
 
 			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));

File: reactor-core/src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -181,6 +181,7 @@ void signal() {
 				Throwable e = m.error;
 				if (e != null) {
 					if (compositeError != null) {
+						//this is ok as the composite created below is never a singleton
 						compositeError.addSuppressed(e);
 					}
 					else if (error != null) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoZip.java
Patch:
@@ -217,6 +217,7 @@ void signal() {
 					Throwable e = m.error;
 					if (e != null) {
 						if (compositeError != null) {
+							//this is ok as the composite created below is never a singleton
 							compositeError.addSuppressed(e);
 						}
 						else if (error != null) {

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -375,7 +375,7 @@ public static Throwable onOperatorError(@Nullable Subscription subscription,
 		if (hook == null) {
 			if (dataSignal != null) {
 				if (dataSignal != t && dataSignal instanceof Throwable) {
-					t.addSuppressed((Throwable) dataSignal);
+					t = Exceptions.addSuppressed(t, (Throwable) dataSignal);
 				}
 				//do not wrap original value to avoid strong references
 				/*else {
@@ -407,7 +407,7 @@ public static RuntimeException onRejectedExecution(Throwable original, Context c
 	 * operator. This exception denotes that an execution was rejected by a
 	 * {@link reactor.core.scheduler.Scheduler}, notably when it was already disposed.
 	 * <p>
-	 * Wrapping is done by calling both {@link Exceptions#bubble(Throwable)} and
+	 * Wrapping is done by calling both {@link Exceptions#failWithRejected(Throwable)} and
 	 * {@link #onOperatorError(Subscription, Throwable, Object, Context)} (with the passed
 	 * {@link Subscription}).
 	 *
@@ -427,7 +427,7 @@ public static RuntimeException onRejectedExecution(Throwable original,
 			context = context.put(Hooks.KEY_ON_OPERATOR_ERROR, context.get(Hooks.KEY_ON_REJECTED_EXECUTION));
 		}
 
-		//FIXME only create REE if original is REE singleton OR there's suppressed OR there's Throwable dataSignal
+		//don't create REE if original is a reactor-produced REE (not including singletons)
 		RejectedExecutionException ree = Exceptions.failWithRejected(original);
 		if (suppressed != null) {
 			ree.addSuppressed(suppressed);

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -274,7 +274,7 @@ static <T> FirstStep<T> withVirtualTime(
 
 	/**
 	 * Verify the signals received by this subscriber. Unless a default timeout has been
-	 * push before construction of the {@link StepVerifier} via {@link StepVerifier#setDefaultTimeout(Duration),
+	 * push before construction of the {@link StepVerifier} via {@link StepVerifier#setDefaultTimeout(Duration)},
 	 * this method will <strong>block</strong> until the stream has been terminated
 	 * (either through {@link Subscriber#onComplete()}, {@link Subscriber#onError(Throwable)} or
 	 * {@link Subscription#cancel()}). Depending on the declared expectations and actions,

File: reactor-core/src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -61,6 +61,7 @@ final class ParallelConcatMap<T, R> extends ParallelFlux<R> implements Scannable
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.DELAY_ERROR) return errorMode != ErrorMode.IMMEDIATE;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -66,6 +66,7 @@ final class ParallelFlatMap<T, R> extends ParallelFlux<R> implements Scannable{
 	public Object scanUnsafe(Attr key) {
 		if (key == Attr.PARENT) return source;
 		if (key == Attr.PREFETCH) return getPrefetch();
+		if (key == Attr.DELAY_ERROR) return delayError;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -152,6 +152,7 @@ public void cancel() {
 			for (MergeReduceInner<T> inner : subscribers) {
 				inner.cancel();
 			}
+			super.cancel();
 		}
 
 		void innerError(Throwable ex) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -215,7 +215,7 @@ static final class FlatMapManyInner<R> implements InnerConsumer<R> {
 
 		@Override
 		public Context currentContext() {
-			return parent.currentContext();
+			return actual.currentContext();
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2931,7 +2931,7 @@ public final Mono<T> take(Duration duration) {
 	 * The timeframe is evaluated using the provided {@link Scheduler}.
 	 *
 	 * @param duration the maximum duration to wait for the source Mono to resolve.
-	 * @parama timer the {@link Scheduler} on which to measure the duration.
+	 * @param timer the {@link Scheduler} on which to measure the duration.
 	 *
 	 * @return a new {@link Mono} that will propagate the signals from the source unless
 	 * no signal is received for {@code duration}, in which case it completes.

File: reactor-core/src/main/java/reactor/util/context/Context.java
Patch:
@@ -122,8 +122,8 @@ static Context of(Object key1, Object value1,
 	 * @param value3 the value for the third key.
 	 * @param key4 the fourth key to initialize.
 	 * @param value4 the value for the fourth key.
-	 * @param key4 the fifth key to initialize.
-	 * @param value4 the value for the fifth key.
+	 * @param key5 the fifth key to initialize.
+	 * @param value5 the value for the fifth key.
 	 * @return a {@link Context} with five entries.
 	 */
 	static Context of(Object key1, Object value1,

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -283,8 +283,8 @@ static <T> FirstStep<T> withVirtualTime(
 	 *
 	 * @return the actual {@link Duration} the verification took.
 	 * @throws AssertionError in case of expectation failures
-	 * @see #verify(Duration) verify(Duration) to put a specific timeout
-	 * @see #setDefaultTimeout setDefaultTimeout(Duration) to change the global default timeout
+	 * @see #verify(Duration)
+	 * @see #setDefaultTimeout(Duration)
 	 */
 	Duration verify() throws AssertionError;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1317,7 +1317,7 @@ public void publishOnAsyncDetection() {
 	    Flux<Tuple2<String, String>> flux =
 			    Flux.from(a)
 			        .flatMap(value -> Mono.just(value)
-			                              .and(Mono.from(b)))
+			                              .zipWith(Mono.from(b)))
 			        .publishOn(Schedulers.single());
 
 	    StepVerifier.create(flux)
@@ -1338,7 +1338,7 @@ public void publishOnAsyncDetectionConditional() {
 	    Flux<Tuple2<String, String>> flux =
 			    Flux.from(a)
 			        .flatMap(value -> Mono.just(value)
-			                              .and(Mono.from(b)))
+			                              .zipWith(Mono.from(b)))
 			        .publishOn(Schedulers.single())
 			        .filter(t -> true);
 

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -181,7 +181,7 @@ private static Mono<Integer> handle(String t) {
 	@Test
 	public void testMonoAndFunction() {
 		StepVerifier.create(Mono.just("source")
-		                        .and(t -> handle(t)))
+		                        .zipWhen(t -> handle(t)))
 		            .expectNextMatches(pair -> pair.getT1().equals("source") && pair.getT2() == 6)
 		            .expectComplete()
 		            .verify();
@@ -190,15 +190,15 @@ public void testMonoAndFunction() {
 	@Test
 	public void testMonoAndFunctionEmpty() {
 		StepVerifier.create(
-				Mono.<String>empty().and(t -> handle(t)))
+				Mono.<String>empty().zipWhen(MonoTests::handle))
 		            .expectComplete()
 		            .verify();
 	}
 
 	@Test
 	public void testMonoAndFunctionRightSideEmpty() {
 		StepVerifier.create(
-				Mono.just("foo").and(t -> Mono.empty()))
+				Mono.just("foo").zipWhen(t -> Mono.empty()))
 		            .expectComplete()
 		            .verify();
 	}

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -106,7 +106,7 @@ public void introFutureHellReactorVersion() {
 					Mono<String> nameTask = ifhrName(id); // <3>
 					Mono<Integer> statTask = ifhrStat(id); // <4>
 
-					return nameTask.and(statTask, // <5>
+					return nameTask.zipWith(statTask, // <5>
 							(name, stat) -> "Name " + name + " has stats " + stat);
 				});
 

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -123,8 +123,8 @@ public void sampleAmbTest() throws Exception {
 		int elements = 40;
 		CountDownLatch latch = new CountDownLatch(elements / 2 + 1);
 
-		Flux<SensorData> p = Flux.firstEmitting(sensorOdd(), sensorEven())
-		                              .log("firstEmitting");
+		Flux<SensorData> p = Flux.first(sensorOdd(), sensorEven())
+		                              .log("first");
 
 		p.subscribe(d -> latch.countDown(), null, latch::countDown);
 		Thread.sleep(1000);

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1409,7 +1409,7 @@ public void multiplexUsingDispatchersAndSplit() throws Exception {
 		final MonoProcessor<List<String>> listPromise = joinStream.flatMap(Flux::fromIterable)
 		                                                 .log("resultStream")
 		                                                 .collectList()
-		                                                 .doOnTerminate((v, e) -> doneSemaphore.release())
+		                                                 .doOnTerminate(doneSemaphore::release)
 		                                                 .toProcessor();
 		listPromise.subscribe();
 

File: reactor-core/src/test/java/reactor/core/scheduler/DelegateServiceSchedulerTest.java
Patch:
@@ -100,7 +100,7 @@ public void smokeTestDelay() {
 						.delay(Duration.ofMillis(100), s)
 						.log()
 						.doOnSubscribe(sub -> start.set(System.nanoTime()))
-						.doOnTerminate((v, e) -> end.set(System.nanoTime()))
+						.doOnTerminate(() -> end.set(System.nanoTime()))
 				)
 				            .expectSubscription()
 				            .expectNext(0L)

File: reactor-core/src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java
Patch:
@@ -115,7 +115,7 @@ public void smokeTestDelay() {
 				StepVerifier.create(Mono
 						.delay(Duration.ofMillis(100), s)
 						.doOnSubscribe(sub -> start.set(System.nanoTime()))
-						.doOnTerminate((v, e) -> end.set(System.nanoTime()))
+						.doOnTerminate(() -> end.set(System.nanoTime()))
 				)
 				            .expectSubscription()
 				            .expectNext(0L)

File: reactor-core/src/test/java/reactor/core/scheduler/ParallelSchedulerTest.java
Patch:
@@ -80,7 +80,7 @@ public void smokeTestDelay() {
 				StepVerifier.create(Mono
 						.delay(Duration.ofMillis(100), s)
 						.doOnSubscribe(sub -> start.set(System.nanoTime()))
-						.doOnTerminate((v, e) -> end.set(System.nanoTime()))
+						.doOnTerminate(() -> end.set(System.nanoTime()))
 				)
 				            .expectSubscription()
 				            .expectNext(0L)

File: reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java
Patch:
@@ -55,7 +55,7 @@ public void smokeTestDelay() {
 						.delay(Duration.ofMillis(100), s)
 						.log()
 						.doOnSubscribe(sub -> start.set(System.nanoTime()))
-						.doOnTerminate((v, e) -> end.set(System.nanoTime()))
+						.doOnTerminate(() -> end.set(System.nanoTime()))
 				)
 				            .expectSubscription()
 				            .expectNext(0L)

File: reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @author Simon Basle
  */
-public abstract class TestPublisher<T> implements Publisher<T> {
+public abstract class TestPublisher<T> implements Publisher<T>, PublisherProbe<T> {
 
 	/**
 	 * Create a standard {@link TestPublisher}.

File: reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -35,6 +35,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 
 /**
  * An iterable that consumes a Publisher in a blocking fashion.
@@ -221,7 +222,7 @@ public void onNext(T t) {
 
 				onError(Operators.onOperatorError(null,
 						Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL),
-						t));
+						t, currentContext()));
 			}
 			else {
 				signalConsumer();

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -98,7 +98,7 @@ public void onNext(T t) {
 		DirectInner<T>[] inners = subscribers;
 
 		if (inners == TERMINATED) {
-			Operators.onNextDropped(t);
+			Operators.onNextDropped(t, currentContext());
 			return;
 		}
 
@@ -114,7 +114,7 @@ public void onError(Throwable t) {
 		DirectInner<T>[] inners = subscribers;
 
 		if (inners == TERMINATED) {
-			Operators.onErrorDropped(t);
+			Operators.onErrorDropped(t, currentContext());
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3535,7 +3535,7 @@ public final Flux<T> doOnNext(Consumer<? super T> onNext) {
 	 * receives any request.
 	 * <p>
 	 *     Note that non fatal error raised in the callback will not be propagated and
-	 *     will simply trigger {@link Operators#onOperatorError(Throwable)}.
+	 *     will simply trigger {@link Operators#onOperatorError(Throwable, Context)}.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.M3/src/docs/marble/doonrequest.png" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -140,7 +140,7 @@ public void onNext(T t) {
 							"The bufferSupplier returned a null buffer");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 					return;
 				}
 				buffer = b;
@@ -285,7 +285,7 @@ public void onNext(T t) {
 							"The bufferSupplier returned a null buffer");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 					return;
 				}
 
@@ -464,7 +464,7 @@ public void onNext(T t) {
 							"The bufferSupplier returned a null buffer");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 					return;
 				}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -68,7 +68,7 @@ public void subscribe(CoreSubscriber<? super C> actual) {
 					"The bufferSupplier returned a null buffer");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 
@@ -253,7 +253,7 @@ void otherNext() {
 						"The bufferSupplier returned a null buffer");
 			}
 			catch (Throwable e) {
-				otherError(Operators.onOperatorError(other, e));
+				otherError(Operators.onOperatorError(other, e, actual.currentContext()));
 				return;
 			}
 
@@ -281,7 +281,7 @@ boolean emit(C b) {
 			}
 			else {
 				actual.onError(Operators.onOperatorError(this, Exceptions
-						.failWithOverflow(), b));
+						.failWithOverflow(), b, actual.currentContext()));
 
 				return false;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -84,7 +84,7 @@ public void subscribe(CoreSubscriber<? super C> actual) {
 					"The bufferSupplier returned a null initial buffer");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 
@@ -195,7 +195,7 @@ public boolean tryOnNext(T t) {
 				match = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return true;
 			}
 
@@ -237,7 +237,7 @@ private C triggerNewBuffer() {
 						"The bufferSupplier returned a null buffer");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e));
+				onError(Operators.onOperatorError(s, e, actual.currentContext()));
 				return null;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java
Patch:
@@ -199,7 +199,8 @@ public void onNext(final T value) {
 					timespanRegistration = timer.schedule(flushTask, timespan, TimeUnit.MILLISECONDS);
 				}
 				catch (RejectedExecutionException ree) {
-					onError(Operators.onRejectedExecution(ree, this, null, value));
+					onError(Operators.onRejectedExecution(ree, this, null, value,
+							actual.currentContext()));
 					return;
 				}
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -328,7 +328,7 @@ void startNext(U u) {
 				"The bufferSupplier returned a null buffer");
 			}
 			catch (Throwable e) {
-				anyError(Operators.onOperatorError(starter, e, u));
+				anyError(Operators.onOperatorError(starter, e, u, actual.currentContext()));
 				return;
 			}
 
@@ -348,7 +348,7 @@ void startNext(U u) {
 				"The end returned a null publisher");
 			}
 			catch (Throwable e) {
-				anyError(Operators.onOperatorError(starter, e, u));
+				anyError(Operators.onOperatorError(starter, e, u, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -45,7 +45,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			v = Objects.requireNonNull(callable.call(), "callable returned null");
 		}
 		catch (Throwable ex) {
-			actual.onError(Operators.onOperatorError(ex));
+			actual.onError(Operators.onOperatorError(ex, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCancelOn.java
Patch:
@@ -110,7 +110,7 @@ public void cancel() {
 					scheduler.schedule(this);
 				}
 				catch (RejectedExecutionException ree) {
-					throw Operators.onRejectedExecution(ree);
+					throw Operators.onRejectedExecution(ree, actual.currentContext());
 				}
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxContextStart.java
Patch:
@@ -42,7 +42,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			c = doOnContext.apply(actual.currentContext());
 		}
 		catch (Throwable t) {
-			Operators.error(actual, Operators.onOperatorError(t));
+			Operators.error(actual, Operators.onOperatorError(t, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -95,7 +95,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		}
 		catch (Throwable ex) {
 			Exceptions.throwIfFatal(ex);
-			sink.error(Operators.onOperatorError(ex));
+			sink.error(Operators.onOperatorError(ex, actual.currentContext()));
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -47,7 +47,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 					"The Publisher returned by the supplier is null");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -60,7 +60,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 					"The collectionSupplier returned a null collection");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -106,7 +106,7 @@ public void onNext(T t) {
 				onSignal.accept(this);
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 
@@ -126,7 +126,7 @@ public void onError(Throwable t) {
 			}
 			catch (Throwable e) {
 				//this performs a throwIfFatal or suppresses t in e
-				t = Operators.onOperatorError(null, e, t);
+				t = Operators.onOperatorError(null, e, t, actual.currentContext());
 			}
 
 			try {
@@ -152,7 +152,7 @@ public void onComplete() {
 			}
 			catch (Throwable e) {
 				done = false;
-				onError(Operators.onOperatorError(s, e));
+				onError(Operators.onOperatorError(s, e, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -77,7 +77,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		try {
 			state = stateSupplier.call();
 		} catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 		actual.onSubscribe(new GenerateSubscription<>(actual, state, generator, stateConsumer));
@@ -219,7 +219,7 @@ void fastPath() {
 				} catch (Throwable e) {
 					cleanup(s);
 
-					actual.onError(Operators.onOperatorError(e));
+					actual.onError(Operators.onOperatorError(e, actual.currentContext()));
 					return;
 				}
 				if (terminate || cancelled) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -186,7 +186,7 @@ public void onNext(T t) {
 				value = Objects.requireNonNull(valueSelector.apply(t), "The valueSelector returned a null value");
 			}
 			catch (Throwable ex) {
-				onError(Operators.onOperatorError(s, ex, t));
+				onError(Operators.onOperatorError(s, ex, t, actual.currentContext()));
 				return;
 			}
 
@@ -663,7 +663,8 @@ public void onNext(V t) {
 			Subscriber<? super V> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
+				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t,
+						actual.currentContext()));
 				return;
 			}
 			if (outputFused) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -69,7 +69,8 @@ public void subscribe(CoreSubscriber<? super Long> actual) {
 		}
 		catch (RejectedExecutionException ree) {
 			if (!r.cancelled) {
-				actual.onError(Operators.onRejectedExecution(ree, r, null, null));
+				actual.onError(Operators.onRejectedExecution(ree, r, null, null,
+						actual.currentContext()));
 			}
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -48,7 +48,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			it = iterable.iterator();
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 
@@ -75,7 +75,7 @@ static <T> void subscribe(CoreSubscriber<? super T> s, Iterator<? extends T> it)
 			b = it.hasNext();
 		}
 		catch (Throwable e) {
-			Operators.error(s, Operators.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e, s.currentContext()));
 			return;
 		}
 		if (!b) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -101,7 +101,7 @@ public void onNext(T t) {
 						"The mapper returned a null value.");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 
@@ -194,7 +194,7 @@ public void onNext(T t) {
 						"The mapper returned a null value.");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 
@@ -216,7 +216,7 @@ public boolean tryOnNext(T t) {
 			}
 			catch (Throwable e) {
 				done = true;
-				actual.onError(Operators.onOperatorError(s, e, t));
+				actual.onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return true;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapFuseable.java
Patch:
@@ -108,7 +108,7 @@ public void onNext(T t) {
 							"The mapper returned a null value.");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 					return;
 				}
 
@@ -259,7 +259,7 @@ public void onNext(T t) {
 							"The mapper returned a null value.");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 					return;
 				}
 
@@ -281,7 +281,7 @@ public boolean tryOnNext(T t) {
 						"The mapper returned a null value.");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return true;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -139,7 +139,7 @@ public void onNext(T t) {
             }
             catch (Throwable e) {
 	            done = true;
-	            actual.onError(Operators.onOperatorError(s, e, t));
+	            actual.onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
                 return;
             }
 
@@ -169,7 +169,7 @@ public void onError(Throwable t) {
 	        }
 	        catch (Throwable e) {
 		        done = true;
-		        actual.onError(Operators.onOperatorError(s, e, t));
+		        actual.onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 		        return;
 	        }
 
@@ -201,7 +201,7 @@ public void onComplete() {
 	        }
 	        catch (Throwable e) {
 		        done = true;
-		        actual.onError(Operators.onOperatorError(s, e));
+		        actual.onError(Operators.onOperatorError(s, e, actual.currentContext()));
 		        return;
 	        }
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -147,7 +147,8 @@ public void onNext(T t) {
 			}
 			if (!queue.offer(t)) {
 				Throwable ex =
-						Operators.onOperatorError(s, Exceptions.failWithOverflow(), t);
+						Operators.onOperatorError(s, Exceptions.failWithOverflow(), t,
+								actual.currentContext());
 				if (onOverflow != null) {
 					try {
 						onOverflow.accept(t);

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java
Patch:
@@ -222,7 +222,8 @@ public void onNext(T t) {
 			}
 			catch (RejectedExecutionException re) {
 				done = true;
-				error = Operators.onRejectedExecution(re, this, null, t);
+				error = Operators.onRejectedExecution(re, this, null, t,
+						actual.currentContext());
 			}
 			drain();
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -128,7 +128,7 @@ public void onNext(T t) {
 					onDrop.accept(t);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				}
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnErrorResume.java
Patch:
@@ -88,7 +88,7 @@ public void onError(Throwable t) {
 					"The nextFactory returned a null Publisher");
 				}
 				catch (Throwable e) {
-					Throwable _e = Operators.onOperatorError(e);
+					Throwable _e = Operators.onOperatorError(e, actual.currentContext());
 					if (t != _e) {
 						_e.addSuppressed(t);
 					}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -85,7 +85,7 @@ public void onComplete() {
 			try {
 				b = predicate.getAsBoolean();
 			} catch (Throwable e) {
-				actual.onError(Operators.onOperatorError(e));
+				actual.onError(Operators.onOperatorError(e, actual.currentContext()));
 				return;
 			}
 			

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -74,7 +74,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 					"The whenSourceFactory returned a null Publisher");
 		}
 		catch (Throwable e) {
-			actual.onError(Operators.onOperatorError(e));
+			actual.onError(Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -1151,7 +1151,7 @@ else if (Operators.setOnce(S, this, s)) {
 		public void onNext(T t) {
 			ReplayBuffer<T> b = buffer;
 			if (b.isDone()) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, currentContext());
 			}
 			else {
 				b.add(t);
@@ -1165,7 +1165,7 @@ public void onNext(T t) {
 		public void onError(Throwable t) {
 			ReplayBuffer<T> b = buffer;
 			if (b.isDone()) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, currentContext());
 			}
 			else {
 				b.onError(t);

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -87,7 +87,7 @@ public void onError(Throwable t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				Throwable _t = Operators.onOperatorError(e);
+				Throwable _t = Operators.onOperatorError(e, actual.currentContext());
 				if (_t != t) {
 					_t.addSuppressed(t);
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -71,7 +71,7 @@ static <T> void subscribe(CoreSubscriber<? super T> s, Function<? super
 			"The whenSourceFactory returned a null Publisher");
 		}
 		catch (Throwable e) {
-			s.onError(Operators.onOperatorError(e));
+			s.onError(Operators.onOperatorError(e, s.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -175,7 +175,7 @@ public void onNext(T t) {
 				}
 				catch (Throwable e) {
 					Operators.terminate(S, this);
-					error(Operators.onOperatorError(null, e, t));
+					error(Operators.onOperatorError(null, e, t, actual.currentContext()));
 					return;
 				}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -191,7 +191,7 @@ public void onNext(T t) {
 						"throttler returned a null publisher");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -96,7 +96,7 @@ public void onNext(T t) {
 							"The accumulator returned a null value");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, t));
+					onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 					return;
 				}
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -115,7 +115,7 @@ public void onComplete() {
 									"The initial value supplied is null");
 						}
 						catch (Throwable e) {
-							onError(Operators.onOperatorError(e));
+							onError(Operators.onOperatorError(e, actual.currentContext()));
 							return;
 						}
 
@@ -210,7 +210,7 @@ public void onNext(T t) {
 						"The accumulator returned a null value");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -85,7 +85,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 
@@ -115,7 +115,7 @@ public boolean tryOnNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 
 				return true;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -86,7 +86,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 
@@ -116,7 +116,7 @@ public boolean tryOnNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 
 				return true;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -47,7 +47,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			"The stream returned a null Iterator");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -59,7 +59,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			}
 			catch (RejectedExecutionException ree) {
 				if (parent.future != OperatorDisposables.DISPOSED) {
-					actual.onError(Operators.onRejectedExecution(ree));
+					actual.onError(Operators.onRejectedExecution(ree,
+							actual.currentContext()));
 				}
 			}
 		}
@@ -141,7 +142,7 @@ public void request(long n) {
 							actual.onError(Operators.onRejectedExecution(ree,
 									this,
 									null,
-									value));
+									value, actual.currentContext()));
 						}
 					}
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -215,7 +215,7 @@ public void onNext(T t) {
 				"The mapper returned a null publisher");
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -81,7 +81,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 
 				return;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -78,7 +78,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Operators.onOperatorError(s, e, t));
+				onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 
 				return;
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -153,7 +153,8 @@ public void onNext(T t) {
 						"The itemTimeout returned a null Publisher");
 			}
 			catch (Throwable e) {
-				actual.onError(Operators.onOperatorError(this, e, t));
+				actual.onError(Operators.onOperatorError(this, e, t,
+						actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java
Patch:
@@ -194,7 +194,8 @@ void subscribeAndCreateWindow() {
 				//or the first emission, which will follow the subscribe
 			}
 			catch (RejectedExecutionException ree) {
-				RuntimeException error = Operators.onRejectedExecution(ree, subscription, null, null);
+				RuntimeException error = Operators.onRejectedExecution(ree, subscription, null, null,
+						actual.currentContext());
 				Operators.error(actual, error);
 			}
 		}
@@ -235,7 +236,7 @@ boolean timerStart() {
 				return true;
 			}
 			catch (RejectedExecutionException ree) {
-				onError(Operators.onRejectedExecution(ree));
+				onError(Operators.onRejectedExecution(ree, actual.currentContext()));
 				return false;
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -402,7 +402,7 @@ else if (windowCount == 0) {
 										this,
 										Operators.onOperatorError(s,
 												ex,
-												newWindow.value));
+												newWindow.value, actual.currentContext()));
 								continue;
 							}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -187,7 +187,7 @@ public void onNext(T t) {
 					"The combiner returned a null value");
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(this, e, t));
+					onError(Operators.onOperatorError(this, e, t, actual.currentContext()));
 					return;
 				}
 

File: reactor-core/src/main/java/reactor/core/publisher/LambdaMonoSubscriber.java
Patch:
@@ -128,7 +128,7 @@ void doError(Throwable t) {
 	public final void onNext(T x) {
 		Subscription s = S.getAndSet(this, Operators.cancelledSubscription());
 		if (s == Operators.cancelledSubscription()) {
-			Operators.onNextDropped(x);
+			Operators.onNextDropped(x, currentContext());
 			return;
 		}
 		if (consumer != null) {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2159,7 +2159,7 @@ public final Mono<T> doOnError(Predicate<? super Throwable> predicate,
 	 * Add behavior triggering a {@link LongConsumer} when the {@link Mono} receives any request.
 	 * <p>
 	 *     Note that non fatal error raised in the callback will not be propagated and
-	 *     will simply trigger {@link Operators#onOperatorError(Throwable)}.
+	 *     will simply trigger {@link Operators#onOperatorError(Throwable, Context)}.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.M3/src/docs/marble/doonrequest1.png" alt="">

File: reactor-core/src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -98,7 +98,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				actual.onError(Operators.onOperatorError(s, e, t));
+				actual.onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 			if (!b) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -99,7 +99,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				actual.onError(Operators.onOperatorError(s, e, t));
+				actual.onError(Operators.onOperatorError(s, e, t, actual.currentContext()));
 				return;
 			}
 			if (b) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -58,7 +58,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			t = Objects.requireNonNull(callable.call(), "callable returned null");
 		}
 		catch (Throwable e) {
-			actual.onError(Operators.onOperatorError(e));
+			actual.onError(Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -59,7 +59,7 @@ public void subscribe(CoreSubscriber<? super R> actual) {
 					"The supplier returned a null container");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 
@@ -119,7 +119,7 @@ public void onNext(T t) {
 				action.accept(value, t);
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(this, e, t));
+				onError(Operators.onOperatorError(this, e, t, actual.currentContext()));
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -52,7 +52,7 @@ public void subscribe(CoreSubscriber<? super C> actual) {
 					"The collectionSupplier returned a null collection");
 		}
 		catch (Throwable ex) {
-			Operators.error(actual, Operators.onOperatorError(ex));
+			Operators.error(actual, Operators.onOperatorError(ex, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			callback.accept(emitter);
 		}
 		catch (Throwable ex) {
-			emitter.error(Operators.onOperatorError(ex));
+			emitter.error(Operators.onOperatorError(ex, actual.currentContext()));
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -45,7 +45,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 					"The Mono returned by the supplier is null");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -58,7 +58,8 @@ public void subscribe(CoreSubscriber<? super Long> actual) {
 		}
 		catch (RejectedExecutionException ree) {
 			if(r.cancel != OperatorDisposables.DISPOSED) {
-				actual.onError(Operators.onRejectedExecution(ree, r, null, null));
+				actual.onError(Operators.onRejectedExecution(ree, r, null, null,
+						actual.currentContext()));
 			}
 		}
 	}
@@ -110,7 +111,7 @@ public void run() {
 					}
 				}
 				catch (Throwable t){
-					actual.onError(Operators.onOperatorError(t));
+					actual.onError(Operators.onOperatorError(t, actual.currentContext()));
 				}
 			} else {
 				actual.onError(Exceptions.failWithOverflow("Could not emit value due to lack of requests"));

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -115,7 +115,8 @@ public void onNext(T t) {
 				this.task = scheduler.schedule(() -> complete(t), delay, unit);
 			}
 			catch (RejectedExecutionException ree) {
-				throw Operators.onRejectedExecution(ree, this, null, t);
+				throw Operators.onRejectedExecution(ree, this, null, t,
+						actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -150,7 +150,7 @@ public void onComplete() {
 			}
 			else{
 				actual.onError(Operators.onOperatorError(new
-						IndexOutOfBoundsException()));
+						IndexOutOfBoundsException(), actual.currentContext()));
 			}
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -49,7 +49,7 @@ public T block() {
 
 	@Override
 	public void subscribe(CoreSubscriber<? super T> actual) {
-		Operators.error(actual, Operators.onOperatorError(error));
+		Operators.error(actual, Operators.onOperatorError(error, actual.currentContext()));
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishMulticast.java
Patch:
@@ -57,7 +57,7 @@ public void subscribe(CoreSubscriber<? super R> actual) {
 					"The transform returned a null Mono");
 		}
 		catch (Throwable ex) {
-			Operators.error(actual, Operators.onOperatorError(ex));
+			Operators.error(actual, Operators.onOperatorError(ex, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -136,7 +136,7 @@ void trySchedule(
 				}
 				catch (RejectedExecutionException ree) {
 					actual.onError(Operators.onRejectedExecution(ree, subscription,
-							suppressed,	dataSignal));
+							suppressed,	dataSignal, actual.currentContext()));
 				}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduce.java
Patch:
@@ -98,7 +98,8 @@ public void onNext(T t) {
 				catch (Throwable ex) {
 					result = null;
 					done = true;
-					actual.onError(Operators.onOperatorError(s, ex, t));
+					actual.onError(Operators.onOperatorError(s, ex, t,
+							actual.currentContext()));
 					return;
 				}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java
Patch:
@@ -58,7 +58,7 @@ public void subscribe(CoreSubscriber<? super R> actual) {
 					"The initial value supplied is null");
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 
@@ -122,7 +122,7 @@ public void onNext(T t) {
 
 			}
 			catch (Throwable e) {
-				onError(Operators.onOperatorError(this, e, t));
+				onError(Operators.onOperatorError(this, e, t, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoRepeatWhen.java
Patch:
@@ -69,7 +69,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 					"The whenSourceFactory returned a null Publisher");
 		}
 		catch (Throwable e) {
-			actual.onError(Operators.onOperatorError(e));
+			actual.onError(Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -39,7 +39,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
         try {
             run.run();
         } catch (Throwable ex) {
-            Operators.error(actual, Operators.onOperatorError(ex));
+            Operators.error(actual, Operators.onOperatorError(ex, actual.currentContext()));
             return;
         }
         Operators.complete(actual);

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -162,7 +162,8 @@ public void onComplete() {
 				}
 				else {
 					actual.onError(Operators.onOperatorError(this,
-							new NoSuchElementException("Source was empty")));
+							new NoSuchElementException("Source was empty"),
+							actual.currentContext()));
 				}
 			}
 			else if (c == 1) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -62,7 +62,7 @@ public void subscribe(CoreSubscriber<? super R> actual) {
 			finisher = collector.finisher();
 		}
 		catch (Throwable ex) {
-			Operators.error(actual, Operators.onOperatorError(ex));
+			Operators.error(actual, Operators.onOperatorError(ex, actual.currentContext()));
 			return;
 		}
 
@@ -125,7 +125,7 @@ public void onNext(T t) {
 				accumulator.accept(container, t);
 			}
 			catch (Throwable ex) {
-				onError(Operators.onOperatorError(s, ex, t));
+				onError(Operators.onOperatorError(s, ex, t, actual.currentContext()));
 			}
 		}
 
@@ -156,7 +156,7 @@ public void onComplete() {
 				r = finisher.apply(a);
 			}
 			catch (Throwable ex) {
-				actual.onError(Operators.onOperatorError(ex));
+				actual.onError(Operators.onOperatorError(ex, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.concurrent.RejectedExecutionException;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
 
@@ -53,7 +52,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 		}
 		catch (RejectedExecutionException ree) {
 			if(parent.state != FluxSubscribeOnCallable.CallableSubscribeOnSubscription.HAS_CANCELLED) {
-				actual.onError(Operators.onRejectedExecution(ree));
+				actual.onError(Operators.onRejectedExecution(ree, actual.currentContext()));
 			}
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -52,7 +52,8 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			}
 			catch (RejectedExecutionException ree) {
 				if (parent.future != OperatorDisposables.DISPOSED) {
-					actual.onError(Operators.onRejectedExecution(ree));
+					actual.onError(Operators.onRejectedExecution(ree,
+							actual.currentContext()));
 				}
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscriberContext.java
Patch:
@@ -40,7 +40,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			c = doOnContext.apply(actual.currentContext());
 		}
 		catch (Throwable t) {
-			Operators.error(actual, Operators.onOperatorError(t));
+			Operators.error(actual, Operators.onOperatorError(t, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -57,7 +57,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 					"The supplier source returned null");
 		}
 		catch (Throwable e) {
-			actual.onError(Operators.onOperatorError(e));
+			actual.onError(Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -98,7 +98,8 @@ public void onComplete() {
 					}
 					else {
 						actual.onError(Operators.onOperatorError(new NoSuchElementException(
-								"Flux#last() didn't observe any " + "onNext signal")));
+								"Flux#last() didn't observe any " + "onNext signal"),
+								actual.currentContext()));
 					}
 				}
 				else {

File: reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java
Patch:
@@ -58,7 +58,7 @@ public void onNext(T t) {
 			s.cancel();
 		}
 		else {
-			Operators.onNextDropped(t);
+			Operators.onNextDropped(t, currentContext());
 		}
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -70,7 +70,7 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 			resource = resourceSupplier.call();
 		}
 		catch (Throwable e) {
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 
@@ -86,11 +86,11 @@ public void subscribe(CoreSubscriber<? super T> actual) {
 				resourceCleanup.accept(resource);
 			}
 			catch (Throwable ex) {
-				ex.addSuppressed(Operators.onOperatorError(e));
+				ex.addSuppressed(Operators.onOperatorError(e, actual.currentContext()));
 				e = ex;
 			}
 
-			Operators.error(actual, Operators.onOperatorError(e));
+			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoZip.java
Patch:
@@ -240,7 +240,8 @@ void signal() {
 				            "zipper produced a null value");
 	            }
 	            catch (Throwable t) {
-		            actual.onError(Operators.onOperatorError(null, t, o));
+		            actual.onError(Operators.onOperatorError(null, t, o,
+				            actual.currentContext()));
 		            return;
 	            }
 	            complete(r);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -81,7 +81,8 @@ public void subscribe(CoreSubscriber<? super C>[] subscribers) {
 						"The initialSupplier returned a null value");
 			}
 			catch (Throwable ex) {
-				reportError(subscribers, Operators.onOperatorError(ex));
+				reportError(subscribers, Operators.onOperatorError(ex,
+						subscribers[i].currentContext()));
 				return;
 			}
 
@@ -145,7 +146,7 @@ public void onNext(T t) {
 				collector.accept(collection, t);
 			}
 			catch (Throwable ex) {
-				onError(Operators.onOperatorError(this, ex, t));
+				onError(Operators.onOperatorError(this, ex, t, actual.currentContext()));
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -82,7 +82,8 @@ public void subscribe(CoreSubscriber<? super R>[] subscribers) {
 						"The initialSupplier returned a null value");
 			}
 			catch (Throwable ex) {
-				reportError(subscribers, Operators.onOperatorError(ex));
+				reportError(subscribers, Operators.onOperatorError(ex,
+						subscribers[i].currentContext()));
 				return;
 			}
 			parents[i] =
@@ -147,7 +148,7 @@ public void onNext(T t) {
 				v = Objects.requireNonNull(reducer.apply(accumulator, t), "The reducer returned a null value");
 			}
 			catch (Throwable ex) {
-				onError(Operators.onOperatorError(this, ex, t));
+				onError(Operators.onOperatorError(this, ex, t, actual.currentContext()));
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -423,7 +423,7 @@ public int getPrefetch() {
 	public void onNext(T t) {
 		FluxReplay.ReplayBuffer<T> b = buffer;
 		if (b.isDone()) {
-			Operators.onNextDropped(t);
+			Operators.onNextDropped(t, currentContext());
 		}
 		else {
 			b.add(t);

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -228,6 +228,7 @@ else if (m == Fuseable.ASYNC) {
 	@SuppressWarnings("unchecked")
 	public void onNext(T t) {
 		if (done) {
+			Operators.onNextDropped(t);
 			return;
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -167,7 +167,7 @@ public void onNext(T t) {
 				}
 			}
 
-			Operators.onNextDropped(t);
+			Operators.onNextDropped(t, actual.currentContext());
 		}
 
 		@Override
@@ -181,7 +181,7 @@ public void onError(Throwable t) {
 				actual.onError(t);
 				return;
 			}
-			Operators.onErrorDropped(t);
+			Operators.onErrorDropped(t, actual.currentContext());
 		}
 
 		@Override
@@ -242,7 +242,7 @@ void otherError(Throwable t){
 				actual.onError(t);
 				return;
 			}
-			Operators.onErrorDropped(t);
+			Operators.onErrorDropped(t, actual.currentContext());
 		}
 
 		void otherNext() {

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -185,7 +185,7 @@ public void onNext(T t) {
 		@Override
 		public boolean tryOnNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return true;
 			}
 
@@ -261,7 +261,7 @@ public CoreSubscriber<? super C> actual() {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -185,7 +185,7 @@ public void onNext(T t) {
 				}
 			}
 
-			Operators.onNextDropped(t);
+			Operators.onNextDropped(t, actual.currentContext());
 		}
 
 		@Override
@@ -206,7 +206,7 @@ public void onError(Throwable t) {
 				anyError(t);
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 
@@ -312,7 +312,7 @@ void anyError(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -355,7 +355,7 @@ void innerError(Throwable e) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -247,7 +247,7 @@ public void onError(Throwable t) {
 			if (Exceptions.addThrowable(ERROR, this, t)) {
 				onComplete();
 			} else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -125,7 +125,7 @@ public void onNext(U t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxDematerialize.java
Patch:
@@ -94,7 +94,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(Signal<T> t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			if (t.isOnComplete()) {
@@ -119,7 +119,7 @@ else if (t.isOnNext()) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFinally.java
Patch:
@@ -35,7 +35,7 @@
  * {@link SignalType#CANCEL}).
  * <p>
  * Note that any exception thrown by the hook are caught and bubbled up
- * using {@link Operators#onErrorDropped(Throwable)}.
+ * using {@link Operators#onErrorDropped(Throwable, reactor.util.context.Context)}.
  *
  * @param <T> the value type
  * @author Simon Baslé
@@ -152,7 +152,7 @@ void runFinally(SignalType signalType) {
 					onFinally.accept(signalType);
 				} catch (Throwable ex) {
 					Exceptions.throwIfFatal(ex);
-					Operators.onErrorDropped(ex);
+					Operators.onErrorDropped(ex, actual.currentContext());
 				}
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFinallyFuseable.java
Patch:
@@ -29,7 +29,7 @@
  * {@link SignalType#CANCEL}).
  * <p>
  * Note that any exception thrown by the hook are caught and bubbled up
- * using {@link Operators#onErrorDropped(Throwable)}.
+ * using {@link Operators#onErrorDropped(Throwable, reactor.util.context.Context)}.
  *
  * @param <T> the value type
  * @author Simon Baslé

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoOnEach.java
Patch:
@@ -17,7 +17,6 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 
@@ -98,7 +97,7 @@ public Object scanUnsafe(Attr key) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			try {
@@ -117,7 +116,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -439,7 +439,7 @@ public void onError(Throwable t) {
 				done = true;
 				parent.innerError(t);
 			} else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, parent.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -242,7 +242,7 @@ public void onError(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -145,7 +145,7 @@ public CoreSubscriber<? super T> actual() {
 		@Override
 		public void next(T t) {
 			if (terminate) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			if (hasValue) {
@@ -306,7 +306,7 @@ void cleanup(S s) {
 
 				stateConsumer.accept(s);
 			} catch (Throwable e) {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 		

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -174,7 +174,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if(done){
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -218,7 +218,7 @@ public void onError(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -466,7 +466,7 @@ public void innerError(Throwable ex) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 
@@ -499,7 +499,7 @@ public void innerCloseError(Throwable ex) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxJoin.java
Patch:
@@ -478,7 +478,7 @@ public void innerError(Throwable ex) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 
@@ -511,7 +511,7 @@ public void innerCloseError(Throwable ex) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -123,7 +123,7 @@ public void onSubscribe(Subscription s) {
         @Override
         public void onNext(T t) {
 	        if (done) {
-	            Operators.onNextDropped(t);
+	            Operators.onNextDropped(t, actual.currentContext());
                 return;
             }
 
@@ -150,7 +150,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
-                Operators.onErrorDropped(t);
+                Operators.onErrorDropped(t, actual.currentContext());
                 return;
             }
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMaterialize.java
Patch:
@@ -92,7 +92,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T ev) {
 			if(terminalSignal != null){
-				Operators.onNextDropped(ev);
+				Operators.onNextDropped(ev, actual.currentContext());
 				return;
 			}
 		    produced++;
@@ -102,7 +102,7 @@ public void onNext(T ev) {
 		@Override
 		public void onError(Throwable ev) {
 			if(terminalSignal != null){
-				Operators.onErrorDropped(ev);
+				Operators.onErrorDropped(ev, actual.currentContext());
 				return;
 			}
 			terminalSignal = Signal.error(ev);

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -242,7 +242,7 @@ public void onError(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 
@@ -307,7 +307,7 @@ void innerError(MergeSequentialInner<R> inner, Throwable e) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -142,7 +142,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			if (!queue.offer(t)) {
@@ -166,7 +166,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			error = t;

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferStrategy.java
Patch:
@@ -132,7 +132,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -185,7 +185,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			error = t;

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferTimeout.java
Patch:
@@ -289,7 +289,7 @@ void evict(@Nullable T evicted) {
 								evicted,
 								ex);
 					}
-					Operators.onErrorDropped(ex);
+					Operators.onErrorDropped(ex, actual.currentContext());
 				}
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -110,7 +110,7 @@ public void onNext(T t) {
 					onDrop.accept(t);
 				}
 				catch (Throwable e) {
-					Operators.onErrorDropped(e);
+					Operators.onErrorDropped(e, actual.currentContext());
 				}
 				return;
 			}
@@ -136,7 +136,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -204,7 +204,7 @@ void error(Throwable e) {
 				}
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -208,7 +208,7 @@ void error(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 
@@ -243,7 +243,7 @@ void otherError(long idx, Throwable e) {
 				error(e);
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 
@@ -386,7 +386,7 @@ public void onError(Throwable t) {
 				main.otherError(index, t);
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, main.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -84,7 +84,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -107,7 +107,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -189,7 +189,7 @@ public void onComplete() {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;
@@ -199,7 +199,7 @@ public void onError(Throwable t) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -72,7 +72,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -101,7 +101,7 @@ public void onNext(T t) {
 		@Override
 		public boolean tryOnNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return true;
 			}
 
@@ -132,7 +132,7 @@ public boolean tryOnNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -101,7 +101,7 @@ public void onNext(U t) {
 		public void onError(Throwable t) {
 			SkipUntilMainSubscriber<?> m = main;
 			if (m.gate) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, main.currentContext());
 				return;
 			}
 			m.onError(t);
@@ -217,7 +217,7 @@ public void onError(Throwable t) {
 					return;
 			}
 			else if (main == Operators.cancelledSubscription()){
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			cancel();

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -72,7 +72,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -102,7 +102,7 @@ public void onNext(T t) {
 		@Override
 		public boolean tryOnNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return true;
 			}
 
@@ -133,7 +133,7 @@ public boolean tryOnNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -70,7 +70,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -96,7 +96,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -69,7 +69,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -97,7 +97,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -177,7 +177,7 @@ void cleanup() {
 				resourceCleanup.accept(resource);
 			}
 			catch (Throwable e) {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 
@@ -329,7 +329,7 @@ void cleanup() {
 				resourceCleanup.accept(resource);
 			}
 			catch (Throwable e) {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 
@@ -489,7 +489,7 @@ void cleanup() {
 				resourceCleanup.accept(resource);
 			}
 			catch (Throwable e) {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -172,7 +172,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			synchronized (this) {
@@ -184,7 +184,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;
@@ -255,7 +255,7 @@ void boundaryError(Throwable e) {
 			if (Exceptions.addThrowable(ERROR, this, e)) {
 				drain();
 			} else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -212,7 +212,7 @@ void offerNewWindow(@Nullable T emitInNewWindow) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			WindowFlux<T> g = window;
@@ -253,7 +253,7 @@ public void onError(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -195,7 +195,7 @@ public void onError(Throwable t) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 			}
 		}
 
@@ -237,7 +237,7 @@ void starterError(Throwable e) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 
@@ -262,7 +262,7 @@ void endError(Throwable e) {
 				drain();
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxZipIterable.java
Patch:
@@ -119,7 +119,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -169,7 +169,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -112,7 +112,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -113,7 +113,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoCacheTime.java
Patch:
@@ -114,7 +114,7 @@ static final class CoordinatorSubscriber<T> implements InnerConsumer<T>, Signal<
 		static final AtomicReferenceFieldUpdater<CoordinatorSubscriber, Operators.MonoSubscriber[]> SUBSCRIBERS =
 				AtomicReferenceFieldUpdater.newUpdater(CoordinatorSubscriber.class, Operators.MonoSubscriber[].class, "subscribers");
 
-		public CoordinatorSubscriber(MonoCacheTime<T> main) {
+		CoordinatorSubscriber(MonoCacheTime<T> main) {
 			this.main = main;
 			//noinspection unchecked
 			this.subscribers = EMPTY;

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -111,7 +111,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -126,7 +126,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -163,7 +163,7 @@ public void error(Throwable e) {
 				}
 			}
 			else {
-				Operators.onErrorDropped(e);
+				Operators.onErrorDropped(e, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -107,7 +107,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			this.done = true;
@@ -131,7 +131,7 @@ public void onComplete() {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			this.done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoFinally.java
Patch:
@@ -28,7 +28,7 @@
  * {@link SignalType#CANCEL}).
  * <p>
  * Note that any exception thrown by the hook are caught and bubbled up
- * using {@link Operators#onErrorDropped(Throwable)}.
+ * using {@link Operators#onErrorDropped(Throwable, reactor.util.context.Context)}.
  *
  * @param <T> the value type
  * @author Simon Baslé

File: reactor-core/src/main/java/reactor/core/publisher/MonoDoFinallyFuseable.java
Patch:
@@ -29,7 +29,7 @@
  * {@link SignalType#CANCEL}).
  * <p>
  * Note that any exception thrown by the hook are caught and bubbled up
- * using {@link Operators#onErrorDropped(Throwable)}.
+ * using {@link Operators#onErrorDropped(Throwable, reactor.util.context.Context)}.
  *
  * @param <T> the value type
  * @author Simon Baslé

File: reactor-core/src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -111,7 +111,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -130,7 +130,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -262,7 +262,7 @@ public void onError(Throwable t) {
 				done = true;
 				main.innerError(t);
 			} else {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, main.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -185,7 +185,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (hasValue) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			actual.onError(t);

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -281,7 +281,7 @@ public void onSubscribe(Subscription s) {
         @Override
         public void onNext(T t) {
             if (done) {
-                Operators.onNextDropped(t);
+                Operators.onNextDropped(t, parent.currentContext());
                 return;
             }
             done = true;
@@ -291,7 +291,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
-                Operators.onErrorDropped(t);
+                Operators.onErrorDropped(t, parent.currentContext());
                 return;
             }
             done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -68,7 +68,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -80,7 +80,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduce.java
Patch:
@@ -83,7 +83,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			T r = result;
@@ -109,7 +109,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java
Patch:
@@ -132,7 +132,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -117,7 +117,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			value = t;
@@ -132,7 +132,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -118,7 +118,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 			try {
@@ -132,7 +132,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -137,7 +137,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -152,7 +152,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeReduce.java
Patch:
@@ -160,7 +160,7 @@ void innerError(Throwable ex) {
 				actual.onError(ex);
 			}
 			else if(error != ex) {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 
@@ -252,7 +252,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, parent.currentContext());
 				return;
 			}
 			T v = value;
@@ -277,7 +277,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, parent.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -208,7 +208,7 @@ void onError(Throwable ex) {
 				drain();
 			}
 			else if(error != ex) {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 		

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -191,7 +191,7 @@ void innerError(Throwable ex) {
 				drain();
 			}
 			else if(error != ex) {
-				Operators.onErrorDropped(ex);
+				Operators.onErrorDropped(ex, actual.currentContext());
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -137,7 +137,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, actual.currentContext());
 				return;
 			}
 
@@ -157,7 +157,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, actual.currentContext());
 				return;
 			}
 			done = true;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -221,7 +221,7 @@ void setupSubscribers() {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Operators.onNextDropped(t);
+				Operators.onNextDropped(t, currentContext());
 				return;
 			}
 			if (sourceMode == Fuseable.NONE) {
@@ -236,7 +236,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Operators.onErrorDropped(t);
+				Operators.onErrorDropped(t, currentContext());
 				return;
 			}
 			error = t;

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -27,7 +27,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -307,7 +307,7 @@ public int getPrefetch() {
 	@Override
 	public void onNext(T t) {
 		if (done || cancelled) {
-			Operators.onNextDropped(t);
+			Operators.onNextDropped(t, actual.currentContext());
 			return;
 		}
 
@@ -332,7 +332,7 @@ public void onNext(T t) {
 	@Override
 	public void onError(Throwable t) {
 		if (done || cancelled) {
-			Operators.onErrorDropped(t);
+			Operators.onErrorDropped(t, actual.currentContext());
 			return;
 		}
 

File: reactor-test/src/main/java/reactor/test/DefaultStepVerifierBuilder.java
Patch:
@@ -909,9 +909,7 @@ public void onNext(T t) {
 
 		@Override
 		public void onSubscribe(Subscription subscription) {
-			if (subscription == null) {
-				throw Exceptions.argumentIsNullException();
-			}
+			Objects.requireNonNull(subscription, "onSubscribe");
 
 			if (this.compareAndSet(null, subscription)) {
 				onExpectation(Signal.subscribe(subscription));

File: reactor-core/src/main/java/reactor/core/scheduler/Scheduler.java
Patch:
@@ -30,8 +30,7 @@
  * Implementations that use an underlying {@link ExecutorService} or
  * {@link ScheduledExecutorService} should instantiate it through a {@link Supplier}
  * passed through the relevant {@link Schedulers} hook
- * ({@link Schedulers#decorateExecutorService(String, Supplier)} or
- * {@link Schedulers#decorateScheduledExecutorService(String, Supplier)}).
+ * ({@link Schedulers#decorateExecutorService(String, Supplier)}.
  *
  * @author Stephane Maldini
  * @author Simon Baslé

File: reactor-core/src/main/java/reactor/core/scheduler/SingleWorkerScheduler.java
Patch:
@@ -64,7 +64,6 @@ public void execute(Runnable command) {
     
     @Override
     public Worker createWorker() {
-        //TODO could this be simplified by returning this.main?
         return new ExecutorScheduler.ExecutorSchedulerWorker(this);
     }
 

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -173,7 +173,8 @@ public static <T> Mono<T> create(Consumer<MonoSink<T>> callback) {
 
 	/**
 	 * Create a {@link Mono} emitting the {@link Context} available on subscribe.
-	 * If no {@link Context is available}, the mono will simply complete.
+	 * If no Context is available, the mono will simply emit the
+	 * {@link Context#empty() empty Context}.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.M3/src/docs/marble/justorempty.png" alt="">

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -150,8 +150,7 @@ static VirtualTimeScheduler enable(Supplier<VirtualTimeScheduler>
 	public static VirtualTimeScheduler get(){
 		VirtualTimeScheduler s = CURRENT.get();
 		if (s == null) {
-			throw new IllegalStateException(
-					"Check if VirtualTimeScheduler#enable has been invoked" + " first" + ": " + s);
+			throw new IllegalStateException("Check if VirtualTimeScheduler#enable has been invoked first");
 		}
 		return s;
 	}

File: reactor-core/src/main/java/reactor/util/context/Context.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.NoSuchElementException;
 import java.util.Optional;
 import java.util.stream.Stream;
+import javax.annotation.Nullable;
 
 /**
  * A key/value store that is propagated between components such as operators via the
@@ -176,7 +177,8 @@ default <T> T get(Class<T> key){
 	 *
 	 * @return an eventual value or the default passed
 	 */
-	default <T> T getOrDefault(Object key, T defaultValue){
+	@Nullable
+	default <T> T getOrDefault(Object key, @Nullable T defaultValue){
 		if(!hasKey(key)){
 			return defaultValue;
 		}

File: reactor-core/src/main/java/reactor/util/context/ContextN.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.function.Function;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import javax.annotation.Nullable;
 
 @SuppressWarnings("unchecked")
 final class ContextN extends HashMap<Object, Object>
@@ -72,7 +73,8 @@ public Object get(Object key) {
 	}
 
 	@Override
-	public Object getOrDefault(Object key, Object defaultValue) {
+	@Nullable
+	public Object getOrDefault(Object key, @Nullable Object defaultValue) {
 		return Context.super.getOrDefault(key, defaultValue);
 	}
 

File: reactor-core/src/main/java/reactor/util/context/Context0.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 final class Context0 implements Context {
 

File: reactor-core/src/main/java/reactor/util/context/Context1.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
 
 final class Context1 implements Context, Map.Entry<Object, Object> {
 
@@ -40,7 +39,7 @@ public Context put(Object key, Object value) {
 			return new Context1(key, value);
 		}
 
-		return new ContextN(this.key, this.value, key, value);
+		return new Context2(this.key, this.value, key, value);
 	}
 
 	@Override
@@ -54,7 +53,7 @@ public <T> T get(Object key) {
 		if (hasKey(key)) {
 			return (T)this.value;
 		}
-		throw new NoSuchElementException("Context does contain key: "+key);
+		throw new NoSuchElementException("Context does not contain key: " + key);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -35,6 +35,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
@@ -190,7 +191,7 @@ static final class GroupJoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>
 				Supplier<? extends
 						Queue<TRight>> processorQueueSupplier) {
 			this.actual = actual;
-			this.cancellations = Disposable.composite();
+			this.cancellations = Disposables.composite();
 			this.queue = queue;
 			this.processorQueueSupplier = processorQueueSupplier;
 			if (!(queue instanceof BiPredicate)) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxJoin.java
Patch:
@@ -34,6 +34,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxGroupJoin.JoinSupport;
@@ -154,7 +155,7 @@ static final class JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>
 				BiFunction<? super TLeft, ? super TRight, ? extends R> resultSelector,
 				Queue<Object> queue) {
 			this.actual = actual;
-			this.cancellations = Disposable.composite();
+			this.cancellations = Disposables.composite();
 			this.queue = queue;
 			if (!(queue instanceof BiPredicate)) {
 				throw new IllegalArgumentException("The provided queue must implement " + "BiPredicate to expose atomic dual insert");

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -21,7 +21,6 @@
 import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Disposable;
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledEmpty;
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar;
 import reactor.core.scheduler.Scheduler;
@@ -52,7 +51,7 @@ public void subscribe(CoreSubscriber<? super T> s) {
 				parent.setFuture(scheduler.schedule(parent));
 			}
 			catch (RejectedExecutionException ree) {
-				if (parent.future != Disposables.DISPOSED) {
+				if (parent.future != OperatorDisposables.DISPOSED) {
 					s.onError(Operators.onRejectedExecution(ree));
 				}
 			}

File: reactor-core/src/main/java/reactor/core/publisher/OperatorDisposables.java
Patch:
@@ -22,21 +22,22 @@
 import javax.annotation.Nullable;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 
 /**
  * Utility methods to work with {@link Disposable} atomically.
  *
  * @author Simon Baslé
  * @author David Karnok
  */
-final class Disposables {
+final class OperatorDisposables {
 
 	/**
 	 * A singleton {@link Disposable} that represents a disposed instance. Should not be
 	 * leaked to clients.
 	 */
 	//NOTE: There is a private similar DISPOSED singleton in DefaultDisposable as well
-	static final Disposable DISPOSED = Disposable.disposed();
+	static final Disposable DISPOSED = Disposables.disposed();
 
 	/**
 	 * Atomically push the field to a {@link Disposable} and dispose the old content.

File: reactor-core/src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -30,6 +30,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -38,6 +38,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxConcatMap.ErrorMode;
 import reactor.core.scheduler.Scheduler;
@@ -976,7 +977,7 @@ public final Disposable subscribe(
 		}
 
 		onLastAssembly(this).subscribe(subscribers);
-		return Disposable.composite(subscribers);
+		return Disposables.composite(subscribers);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.function.Supplier;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 
 import static reactor.core.scheduler.ExecutorServiceScheduler.CANCELLED;
@@ -273,7 +274,7 @@ static final class CachedWorker extends AtomicBoolean implements Worker {
 		CachedWorker(ScheduledExecutorService executor, ElasticScheduler parent) {
 			this.executor = executor;
 			this.parent = parent;
-			this.tasks = Disposable.composite();
+			this.tasks = Disposables.composite();
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/scheduler/ExecutorScheduler.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 
 /**
@@ -194,7 +195,7 @@ static final class ExecutorSchedulerWorker implements Scheduler.Worker, WorkerDe
 
 		ExecutorSchedulerWorker(Executor executor) {
 			this.executor = executor;
-			this.tasks = Disposable.composite();
+			this.tasks = Disposables.composite();
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 
 /**
@@ -137,7 +138,7 @@ static final class ExecutorServiceWorker implements Worker, Disposable {
 		ExecutorServiceWorker(ExecutorService executor, boolean interruptOnCancel) {
 			this.executor = executor;
 			this.interruptOnCancel = interruptOnCancel;
-			this.tasks = Disposable.composite();
+			this.tasks = Disposables.composite();
 		}
 
 		boolean isTimeCapable() {

File: reactor-core/src/main/java/reactor/core/scheduler/ImmediateScheduler.java
Patch:
@@ -16,6 +16,7 @@
 package reactor.core.scheduler;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 
 /**
@@ -38,7 +39,7 @@ private ImmediateScheduler() {
         
     }
     
-    static final Disposable FINISHED = Disposable.disposed();
+    static final Disposable FINISHED = Disposables.disposed();
     
     @Override
     public Disposable schedule(Runnable task) {

File: reactor-core/src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.function.Supplier;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 
 /**
@@ -184,7 +185,7 @@ static final class ParallelWorker implements Worker {
         
         ParallelWorker(ScheduledExecutorService exec) {
             this.exec = exec;
-            this.tasks = Disposable.composite();
+            this.tasks = Disposables.composite();
         }
 
 	    @Override

File: reactor-core/src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -16,7 +16,6 @@
 
 package reactor.core.scheduler;
 
-import java.util.Objects;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
@@ -29,6 +28,7 @@
 import java.util.function.Supplier;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 
 /**
@@ -155,7 +155,7 @@ static final class SingleWorker implements Worker, Disposable {
 
 		SingleWorker(ScheduledExecutorService exec) {
 			this.exec = exec;
-			this.tasks = Disposable.composite();
+			this.tasks = Disposables.composite();
 		}
 
 		@Override

File: reactor-core/src/test/java/reactor/core/CompositeDisposableTest.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 
 import org.junit.Test;
-import reactor.core.DefaultDisposable.CompositeDisposable;
+import reactor.core.Disposables.CompositeDisposable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.FakeDisposable;
 import reactor.test.RaceTestUtils;

File: reactor-core/src/test/java/reactor/core/SwapDisposableTest.java
Patch:
@@ -35,11 +35,11 @@
 @RunWith(MockitoJUnitRunner.class)
 public class SwapDisposableTest {
 
-	private DefaultDisposable.SwapDisposable sequentialDisposable;
+	private Disposables.SwapDisposable sequentialDisposable;
 
 	@Before
 	public void setUp() {
-		sequentialDisposable = new DefaultDisposable.SwapDisposable();
+		sequentialDisposable = new Disposables.SwapDisposable();
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/FluxSubscribeOnValueTest.java
Patch:
@@ -88,7 +88,7 @@ public void scanMainSubscriber() {
         assertThat(test.scan(Scannable.Attr.TERMINATED)).isTrue();
 
         assertThat(test.scan(Scannable.Attr.CANCELLED)).isFalse();
-        test.future = Disposables.DISPOSED;
+        test.future = OperatorDisposables.DISPOSED;
         assertThat(test.scan(Scannable.Attr.CANCELLED)).isTrue();
     }
 }
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 
 import org.assertj.core.api.Assertions;
-import org.junit.Assert;
 import org.junit.Test;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
@@ -133,7 +132,7 @@ public void cancelledSubscription(){
 
 	@Test
 	public void noopFluxCancelled(){
-		Disposables.DISPOSED.dispose(); //noop
+		OperatorDisposables.DISPOSED.dispose(); //noop
 	}
 
 	@Test

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -28,6 +28,7 @@
 import javax.annotation.Nullable;
 
 import reactor.core.Disposable;
+import reactor.core.Disposables;
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
@@ -466,8 +467,8 @@ public void dispose() {
 		}
 	}
 
-	static final Disposable CANCELLED = Disposable.disposed();
-	static final Disposable EMPTY = Disposable.never();
+	static final Disposable CANCELLED = Disposables.disposed();
+	static final Disposable EMPTY = Disposables.never();
 
 	static boolean replace(AtomicReference<Disposable> ref, @Nullable Disposable c) {
 		for (; ; ) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -73,7 +73,7 @@ static final class MonoDelayRunnable implements Runnable, InnerProducer<Long> {
 
 		volatile boolean requested;
 
-		static final Disposable FINISHED = () -> { };
+		static final Disposable FINISHED = Disposable.disposed();
 
 		MonoDelayRunnable(CoreSubscriber<? super Long> actual) {
 			this.actual = actual;

File: reactor-core/src/main/java/reactor/core/scheduler/ImmediateScheduler.java
Patch:
@@ -38,12 +38,12 @@ private ImmediateScheduler() {
         
     }
     
-    static final Disposable EMPTY = () -> { };
+    static final Disposable FINISHED = Disposable.disposed();
     
     @Override
     public Disposable schedule(Runnable task) {
         task.run();
-        return EMPTY;
+        return FINISHED;
     }
 
     @Override
@@ -66,7 +66,7 @@ public Disposable schedule(Runnable task) {
                 throw Exceptions.failWithRejected();
             }
             task.run();
-            return EMPTY;
+            return FINISHED;
         }
 
         @Override

File: reactor-core/src/main/java/reactor/core/DefaultDisposable.java
Patch:
@@ -28,8 +28,8 @@
 
 /**
  * A support class that offers implementations for the specialized {@link Disposable}
- * sub-interfaces ({@link Disposable.Composite Disposable.CompositeDisposable},
- * {@link Disposable.Swap Disposable.SwapDisposable}).
+ * sub-interfaces ({@link Disposable.Composite Disposable.Composite},
+ * {@link Disposable.Swap Disposable.Swap}).
  *
  * @author Simon Baslé
  * @author Stephane Maldini

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -733,7 +733,7 @@ public final ParallelFlux<T> name(String name) {
 
 	/**
 	 * Reduces all values within a 'rail' and across 'rails' with a reducer function into
-	 * a single swap value.
+	 * a single sequential value.
 	 * <p>
 	 * Note that the same reducer function may be called from multiple threads
 	 * concurrently.

File: reactor-core/src/main/java/reactor/core/publisher/FluxName.java
Patch:
@@ -35,7 +35,7 @@
  * @author Simon Baslé
  * @author Stephane Maldini
  */
-public class FluxName<T> extends FluxOperator<T, T> {
+final class FluxName<T> extends FluxOperator<T, T> {
 
 	final String name;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxNameFuseable.java
Patch:
@@ -31,7 +31,7 @@
  * @author Simon Baslé
  * @author Stephane Maldini
  */
-public class FluxNameFuseable<T> extends FluxOperator<T, T> implements Fuseable {
+final class FluxNameFuseable<T> extends FluxOperator<T, T> implements Fuseable {
 
 	final String name;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoName.java
Patch:
@@ -34,7 +34,7 @@
  *
  * @author Stephane Maldini
  */
-public class MonoName<T> extends MonoOperator<T, T> {
+final class MonoName<T> extends MonoOperator<T, T> {
 
 	final String name;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoNameFuseable.java
Patch:
@@ -30,7 +30,7 @@
  *
  * @author Stephane Maldini
  */
-public class MonoNameFuseable<T> extends MonoOperator<T, T> implements Fuseable {
+final class MonoNameFuseable<T> extends MonoOperator<T, T> implements Fuseable {
 
 	final String name;
 

File: reactor-core/src/test/java/reactor/HooksTest.java
Patch:
@@ -168,7 +168,6 @@ public void accumulatingHooks() throws Exception {
 		Flux.just("test").filter(d -> true).subscribe();
 
 		assertThat(hook.get()).isNotNull().isEqualTo(hook2.get());
-
 		Hooks.resetOnEachOperator();
 
 		hook.set(null);

File: reactor-core/src/test/java/reactor/HooksTest.java
Patch:
@@ -187,7 +187,7 @@ public void accumulatingHooks() throws Exception {
 
 		assertThat(hook.get()).isNotNull().isEqualTo(hook2.get());
 
-		Hooks.resetOnEachOperator();
+		Hooks.resetOnLastOperator();
 	}
 
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxOperator.java
Patch:
@@ -17,10 +17,12 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-
+import java.util.function.BiFunction;
+import java.util.function.Function;
 import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
+import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 
 /**

File: reactor-core/src/main/java/reactor/core/publisher/MonoOperator.java
Patch:
@@ -17,10 +17,13 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
+import java.util.function.BiFunction;
+import java.util.function.Function;
 
 import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;
+import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 
 /**

File: reactor-core/src/test/java/reactor/core/publisher/FluxOnAssemblyTest.java
Patch:
@@ -88,7 +88,7 @@ public void checkpointEmpty() {
 	public void checkpointEmptyAndDebug() {
 		StringWriter sw = new StringWriter();
 
-		Hooks.onOperator(Hooks.OperatorHook::operatorStacktrace);
+		Hooks.onOperatorDebug();
 
 		try {
 			Flux<Integer> tested = Flux.range(1, 10)
@@ -107,7 +107,7 @@ public void checkpointEmptyAndDebug() {
 					"Assembly trace from producer [reactor.core.publisher.FluxMapFuseable] :");
 		}
 		finally {
-			Hooks.resetOnOperator();
+			Hooks.resetOnOperatorDebug();
 		}
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -16,6 +16,8 @@
 package reactor.core.publisher;
 
 import org.junit.Test;
+import org.reactivestreams.Subscription;
+import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 
@@ -103,7 +105,7 @@ public void fluxError() {
 
 
 	@Test
-	public void fluxmpty() {
+	public void fluxEmpty() {
 		StepVerifier.create(Mono.empty().flux())
 		            .verifyComplete();
 	}

File: reactor-core/src/test/java/reactor/guide/GuideDebuggingExtraTests.java
Patch:
@@ -32,7 +32,7 @@ public class GuideDebuggingExtraTests {
 
 	@Test
 	public void debuggingActivatedWithDeepTraceback() {
-		Hooks.onOperator(h -> h.operatorStacktrace());
+		Hooks.onOperatorDebug();
 
 		try {
 			StringWriter sw = new StringWriter();
@@ -55,7 +55,7 @@ public void debuggingActivatedWithDeepTraceback() {
 							+ "\t|_\tFlux.transform(GuideDebuggingExtraTests.java:41)\n\n");
 		}
 		finally {
-			Hooks.resetOnOperator();
+			Hooks.resetOnOperatorDebug();
 		}
 	}
 }

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -964,9 +964,9 @@ final void touchTreeState(@Nullable Object parent){
 	final void resetHooks() {
 		Hooks.resetOnErrorDropped();
 		Hooks.resetOnNextDropped();
-		Hooks.resetOnOperator();
+		Hooks.resetOnEachOperator();
 		Hooks.resetOnOperatorError();
-		Hooks.resetOnNewSubscriber();
+		Hooks.resetOnLastOperator();
 	}
 
 	final  void testPublisherSource(OperatorScenario<I, PI, O, PO> scenario, TestPublisher<I> ts) {

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -161,7 +161,7 @@ public abstract class Mono<T> implements Publisher<T> {
      *         }
      *     });
      * }); 
-     * <code></pre>
+     * </code></pre>
 	 *
 	 * @param callback Consume the {@link MonoSink} provided per-subscriber by Reactor to generate signals.
 	 * @param <T> The type of the value emitted

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java
Patch:
@@ -235,7 +235,7 @@ boolean timerStart() {
 				return true;
 			}
 			catch (RejectedExecutionException ree) {
-				onError(Operators.onRejectedExecution(ree, this, null, null));
+				onError(Operators.onRejectedExecution(ree));
 				return false;
 			}
 		}

File: reactor-core/src/main/java/reactor/core/scheduler/ImmediateScheduler.java
Patch:
@@ -16,6 +16,7 @@
 package reactor.core.scheduler;
 
 import reactor.core.Disposable;
+import reactor.core.Exceptions;
 
 /**
  * Executes tasks on the caller's thread immediately.
@@ -62,7 +63,7 @@ static final class ImmediateSchedulerWorker implements Scheduler.Worker {
         @Override
         public Disposable schedule(Runnable task) {
             if (shutdown) {
-                return REJECTED;
+                throw Exceptions.failWithRejected();
             }
             task.run();
             return EMPTY;

File: reactor-core/src/test/java/reactor/core/scheduler/SingleSchedulerTest.java
Patch:
@@ -35,7 +35,7 @@ public class SingleSchedulerTest extends AbstractSchedulerTest {
 
 	@Override
 	protected Scheduler scheduler() {
-		return Schedulers.single();
+		return Schedulers.newSingle("SingleSchedulerTest");
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/scheduler/TimedSchedulerTest.java
Patch:
@@ -30,7 +30,7 @@ public class TimedSchedulerTest extends AbstractSchedulerTest {
 
 	@Override
 	protected Scheduler scheduler() {
-		return Schedulers.newSingle("test-timer");
+		return Schedulers.newSingle("TimedSchedulerTest");
 	}
 
 	@Test

File: reactor-core/src/main/java/reactor/core/publisher/FluxName.java
Patch:
@@ -108,8 +108,8 @@ public Object scanUnsafe(Attr key) {
 			return name;
 		}
 
-		if (key == Attr.TAGS) {
-			return tags;
+		if (key == Attr.TAGS && tags != null) {
+			return tags.stream();
 		}
 
 		return super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/MonoName.java
Patch:
@@ -107,8 +107,8 @@ public Object scanUnsafe(Attr key) {
 			return name;
 		}
 
-		if (key == Attr.TAGS) {
-			return tags;
+		if (key == Attr.TAGS && tags != null) {
+			return tags.stream();
 		}
 
 		return super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/MonoNameFuseable.java
Patch:
@@ -56,8 +56,8 @@ public Object scanUnsafe(Attr key) {
 			return name;
 		}
 
-		if (key == Attr.TAGS) {
-			return tags;
+		if (key == Attr.TAGS && tags != null) {
+			return tags.stream();
 		}
 
 		return super.scanUnsafe(key);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxName.java
Patch:
@@ -23,7 +23,6 @@
 import javax.annotation.Nullable;
 
 import reactor.core.CoreSubscriber;
-import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
@@ -96,8 +95,8 @@ public Object scanUnsafe(Attr key) {
 			return name;
 		}
 
-		if (key == Attr.TAGS) {
-			return tags;
+		if (key == Attr.TAGS && tags != null) {
+			return tags.stream();
 		}
 
 		if (key == Attr.PARENT) return source;

File: reactor-core/src/test/java/reactor/core/ScannableTest.java
Patch:
@@ -158,7 +158,7 @@ public void scannableNameDefaultsToToString() {
 		                               .map(i -> i + 10);
 
 		assertThat(Scannable.from(flux).name())
-				.isEqualTo(flux.toString())
+				.isEqualTo(Scannable.from(flux).operatorName())
 				.isEqualTo("map");
 	}
 
@@ -289,7 +289,7 @@ public void scannableNameMonoDefaultsToToString() {
 		                               .map(i -> i + 10);
 
 		assertThat(Scannable.from(flux).name())
-				.isEqualTo(flux.toString())
+				.isEqualTo(Scannable.from(flux).operatorName())
 				.isEqualTo("map");
 	}
 
@@ -388,7 +388,7 @@ public void scannableNameParallelFluxDefaultsToToString() {
 		                               .map(i -> i + 10);
 
 		assertThat(Scannable.from(flux).name())
-				.isEqualTo(flux.toString())
+				.isEqualTo(Scannable.from(flux).operatorName())
 				.isEqualTo("map");
 	}
 

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -274,12 +274,13 @@ public final void errorOnSubscribe() {
 			verifier.accept(this.inputHiddenErrorOutputConditional(scenario));
 			verifier.accept(this.inputConditionalError(scenario));
 			verifier.accept(this.inputConditionalErrorOutputConditional(scenario));
-			verifier.accept(this.inputFusedError(scenario));
-			verifier.accept(this.inputFusedErrorOutputFusedConditional(scenario));
 
 			scenario.shouldHitDropErrorHookAfterTerminate(false)
 			        .shouldHitDropNextHookAfterTerminate(false);
 
+			verifier.accept(this.inputFusedError(scenario));
+			verifier.accept(this.inputFusedErrorOutputFusedConditional(scenario));
+
 			if (scenario.prefetch() != -1 || (fusion & Fuseable.SYNC) != 0) {
 				verifier.accept(this.inputFusedSyncErrorOutputFusedSync(scenario));
 			}

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/BurstyWorkQueueProcessorTests.java
Patch:
@@ -111,7 +111,7 @@ public Runnable burstyProducerRunnable(final FluxSink<Object> emitter, int count
 			burstSize) {
 		return () -> {
 
-			// Let's start with some messages to keep the ringbuffer scenario going total empty
+			// Let's start with some messages to keep the ringbuffer from going total empty
 			for (int i = 0; i < INITAL_MESSAGES_COUNT; ++i) {
 				emitter.next("initial" + i);
 			}

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -669,7 +669,7 @@ public void partitionByHashCodeShouldNeverCreateMoreStreamsThanSpecified() throw
 	}
 
 	/**
-	 * original scenario @oiavorskyl https://github.com/eventBus/eventBus/issues/358
+	 * original from @oiavorskyl https://github.com/eventBus/eventBus/issues/358
 	 * @throws Exception for convenience
 	 */
 	//@Test
@@ -680,7 +680,7 @@ public void shouldNotFlushStreamOnTimeoutPrematurelyAndShouldDoItConsistently()
 	}
 
 	/**
-	 * original scenario @oiavorskyl https://github.com/eventBus/eventBus/issues/358
+	 * original from @oiavorskyl https://github.com/eventBus/eventBus/issues/358
      * @throws Exception for convenience
 	 */
 	@Test

File: reactor-core/src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -153,7 +153,7 @@ public void testUncaughtHookNotCalledWhenThreadDeath() {
 		AtomicBoolean handled = new AtomicBoolean(false);
 		AtomicReference<String> failure = new AtomicReference<>(null);
 		Thread.setDefaultUncaughtExceptionHandler((t, e) -> failure.set("unexpected call to default" +
-				" UncaughtExceptionHandler scenario " + t.getName() + ": " + e));
+				" UncaughtExceptionHandler from " + t.getName() + ": " + e));
 		Schedulers.onHandleError((t, e) -> {
 			handled.set(true);
 			failure.set("Fatal JVM error was unexpectedly handled in " + t.getName() + ": " + e);

File: reactor-core/src/test/java/reactor/test/subscriber/AssertSubscriber.java
Patch:
@@ -56,7 +56,7 @@
  * {@code await*()} methods to wait for the data to assert.
  *
  * <p> You can extend this class but only the onNext, onError and onComplete can be overridden.
- * You can call {@link #request(long)} and {@link #cancel()} scenario any thread or scenario within
+ * You can call {@link #request(long)} and {@link #cancel()} from any thread or from within
  * the overridable methods but you should avoid calling the assertXXX methods asynchronously.
  *
  * <p>Usage:
@@ -942,7 +942,7 @@ public void request(long n) {
 	}
 
 	/**
-	 * Setup what fusion mode should be requested scenario the incoming
+	 * Setup what fusion mode should be requested from the incoming
 	 * Subscription if it happens to be QueueSubscription
 	 * @param requestMode the mode to request, see Fuseable constants
 	 * @return this
@@ -992,7 +992,7 @@ protected final void requestDeferred() {
 	}
 
 	/**
-	 * Atomically sets the single subscription and requests the missed amount scenario it.
+	 * Atomically sets the single subscription and requests the missed amount from it.
 	 *
 	 * @param s
 	 * @return false if this arbiter is cancelled or there was a subscription already push

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -214,7 +214,7 @@ void initialRequest() {
 
 		@Override
 		public void onNext(T t) {
-			if (t == null) {//async fusion
+			if (sourceMode == ASYNC) {
 				if (trySchedule() == Scheduler.REJECTED) {
 					throw Operators.onRejectedExecution(this, null, t);
 				}
@@ -697,7 +697,7 @@ void initialRequest() {
 
 		@Override
 		public void onNext(T t) {
-			if (t == null) {//async fusion
+			if (sourceMode == ASYNC) {
 				if (trySchedule() == Scheduler.REJECTED) {
 					throw Operators.onRejectedExecution(this, null, null);
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -124,8 +124,7 @@ public void request(long n) {
 					parent.onRequestCall().accept(n);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e));
-					return;
+					Operators.onOperatorError(e);
 				}
 			}
 			s.request(n);

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeekStateful.java
Patch:
@@ -120,8 +120,7 @@ public void request(long n) {
 					parent.onRequestCall().accept(n, state);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e));
-					return;
+					Operators.onOperatorError(e);
 				}
 			}
 			s.request(n);

File: reactor-core/src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.function.Supplier;
@@ -56,7 +57,7 @@ final class ParallelScheduler implements Scheduler, Supplier<ScheduledExecutorSe
         TERMINATED = Executors.newSingleThreadScheduledExecutor();
         TERMINATED.shutdownNow();
     }
-    
+
     int roundRobin;
 
     ParallelScheduler(int n, ThreadFactory factory) {
@@ -137,7 +138,7 @@ ScheduledExecutorService pick() {
             int idx = roundRobin;
             if (idx == n) {
                 idx = 0;
-                roundRobin = 0;
+                roundRobin = 1;
             } else {
                 roundRobin = idx + 1;
             }

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -116,9 +116,6 @@ public void onNext(T t) {
 			}
 			else {
 				this.task = task;
-				Subscription actualS = s;
-				s = Operators.cancelledSubscription();
-				actualS.cancel();
 			}
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -142,7 +142,7 @@ static <T, R> boolean trySubscribeScalarMap(Publisher<? extends T> source,
 						"The mapper returned a null Publisher");
 			}
 			catch (Throwable e) {
-				Operators.error(s, Operators.onOperatorError(e));
+				Operators.error(s, Operators.onOperatorError(null, e, t));
 				return true;
 			}
 
@@ -153,7 +153,7 @@ static <T, R> boolean trySubscribeScalarMap(Publisher<? extends T> source,
 					v = ((Callable<R>) p).call();
 				}
 				catch (Throwable e) {
-					Operators.error(s, Operators.onOperatorError(e));
+					Operators.error(s, Operators.onOperatorError(null, e, t));
 					return true;
 				}
 

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -111,7 +111,7 @@ class Attr<T> {
 		 * {@code Flux.flatMap}, {@code Flux.filterWhen}, {@link reactor.core.publisher.TopicProcessor},
 		 * and {@code Flux.window} (with overlap) are known to use this attribute.
 		 */
-		public static final Attr<Long> LARGE_BUFFERED = new Attr<>(0L);
+		public static final Attr<Long> LARGE_BUFFERED = new Attr<>(null);
 
 		/**
 		 * Parent key exposes the direct upstream relationship of the scanned component.

File: reactor-core/src/test/java/reactor/core/ScannableTest.java
Patch:
@@ -52,7 +52,7 @@ public void meaningfulDefaults() {
 		Scannable emptyScannable = key -> null;
 
 		assertThat(emptyScannable.scan(Scannable.Attr.BUFFERED)).isEqualTo(0);
-		assertThat(emptyScannable.scan(Scannable.Attr.LARGE_BUFFERED)).isEqualTo(0L);
+		assertThat(emptyScannable.scan(Scannable.Attr.LARGE_BUFFERED)).isNull();
 		assertThat(emptyScannable.scan(Scannable.Attr.CAPACITY)).isEqualTo(0);
 		assertThat(emptyScannable.scan(Scannable.Attr.PREFETCH)).isEqualTo(0);
 

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -59,7 +59,7 @@ public void scanSerializedSubscriberMaxBuffered() {
 		test.tail.count = Integer.MAX_VALUE;
 
 		assertThat(test.scan(Scannable.Attr.BUFFERED)).isEqualTo(Integer.MAX_VALUE);
-		assertThat(test.scan(Scannable.Attr.LARGE_BUFFERED)).isEqualTo(0L);
+		assertThat(test.scan(Scannable.Attr.LARGE_BUFFERED)).isNull();
 	}
 
 }
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -55,10 +55,12 @@ protected List<Scenario<String, List<String>>> scenarios_operatorError() {
 	@Override
 	protected List<Scenario<String, List<String>>> scenarios_operatorSuccess() {
 		return Arrays.asList(scenario(f -> f.buffer(Mono.never()))
-						.receive(i -> assertThat(i).containsExactly(item(0), item(1), item(2))),
+						.receive(i -> assertThat(i).containsExactly(item(0), item(1), item(2)))
+				.shouldAssertPostTerminateState(false),
 
 				scenario(f -> f.buffer(Mono.just(1)))
 						.receiverEmpty()
+						.shouldAssertPostTerminateState(false)
 		);
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -115,7 +115,8 @@ protected List<Scenario<String, String>> scenarios_operatorSuccess() {
 						f,
 						Flux.just(item(0), item(1), item(2)),
 						Flux.just(item(0), item(1), item(2))))
-						.receiveValues(item(2), item(2), item(2)),
+						.receiveValues(item(2), item(2), item(2))
+						.shouldAssertPostTerminateState(false),
 
 				scenario(f -> Flux.combineLatest(o -> (String) o[2],
 						1,
@@ -124,6 +125,7 @@ protected List<Scenario<String, String>> scenarios_operatorSuccess() {
 						Flux.just(item(0), item(0), item(0))))
 						.prefetch(1)
 						.receiveValues(item(0), item(0), item(0))
+						.shouldAssertPostTerminateState(false)
 		);
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipUntilOtherTest.java
Patch:
@@ -51,10 +51,12 @@ protected List<Scenario<String, String>> scenarios_operatorError() {
 	@Override
 	protected List<Scenario<String, String>> scenarios_operatorSuccess() {
 		return Arrays.asList(
-				scenario(f -> f.skipUntilOther(Flux.empty())),
+				scenario(f -> f.skipUntilOther(Flux.empty()))
+						.shouldAssertPostTerminateState(false),
 
 				scenario(f -> Flux.<String>empty().skipUntilOther(f))
 					.receiverEmpty()
+					.shouldAssertPostTerminateState(false)
 		);
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/SerializedSubscriberTest.java
Patch:
@@ -59,7 +59,7 @@ public void scanSerializedSubscriberMaxBuffered() {
 		test.tail.count = Integer.MAX_VALUE;
 
 		assertThat(test.scan(Scannable.Attr.BUFFERED)).isEqualTo(Integer.MAX_VALUE);
-		assertThat(test.scan(Scannable.Attr.LARGE_BUFFERED)).isNull();
+		assertThat(test.scan(Scannable.Attr.LARGE_BUFFERED)).isEqualTo(0L);
 	}
 
 }
\ No newline at end of file

File: reactor-core/src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -30,11 +30,10 @@
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 
-import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 import reactor.util.concurrent.WaitStrategy;
 import javax.annotation.Nullable;
 
@@ -211,7 +210,7 @@ static long getAndSub(RingBuffer.Sequence sequence, long toSub) {
 			Supplier<Slot<IN>> factory,
 			WaitStrategy strategy) {
 
-		if (!QueueSupplier.isPowerOfTwo(bufferSize)) {
+		if (!Queues.isPowerOfTwo(bufferSize)) {
 			throw new IllegalArgumentException("bufferSize must be a power of 2 : " + bufferSize);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterWhen.java
Patch:
@@ -32,7 +32,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
 
 /**
@@ -110,7 +110,7 @@ static final class FluxFilterWhenSubscriber<T> implements InnerOperator<T, T> {
 				Function<? super T, ? extends Publisher<Boolean>> asyncPredicate,
 				int bufferSize) {
 			this.actual = actual;
-			this.toFilter = new AtomicReferenceArray<>(QueueSupplier.ceilingNextPowerOfTwo(bufferSize));
+			this.toFilter = new AtomicReferenceArray<>(Queues.ceilingNextPowerOfTwo(bufferSize));
 			this.asyncPredicate = asyncPredicate;
 			this.bufferSize = bufferSize;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -35,7 +35,7 @@
 import reactor.core.Fuseable.QueueSubscription;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxConcatMap.ErrorMode;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
 
 /**
@@ -62,7 +62,7 @@ final class FluxMergeSequential<T, R> extends FluxOperator<T, R> {
 			Function<? super T, ? extends Publisher<? extends R>> mapper,
 			int maxConcurrency, int prefetch, ErrorMode errorMode) {
 		this(source, mapper, maxConcurrency, prefetch, errorMode,
-				QueueSupplier.get(Math.max(prefetch, maxConcurrency)));
+				Queues.get(Math.max(prefetch, maxConcurrency)));
 	}
 
 	//for testing purpose
@@ -547,7 +547,7 @@ public void onSubscribe(Subscription s) {
 					}
 				}
 
-				queue = QueueSupplier.<R>get(prefetch).get();
+				queue = Queues.<R>get(prefetch).get();
 				s.request(prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : prefetch);
 			}
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -27,7 +27,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 /**
  * @author Stephane Maldini
@@ -106,10 +106,10 @@ static final class BackpressureBufferSubscriber<T>
 			Queue<T> q;
 
 			if (unbounded) {
-				q = QueueSupplier.<T>unbounded(bufferSize).get();
+				q = Queues.<T>unbounded(bufferSize).get();
 			}
 			else {
-				q = QueueSupplier.<T>get(bufferSize).get();
+				q = Queues.<T>get(bufferSize).get();
 			}
 
 			this.queue = q;

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -35,7 +35,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 /**
  * @param <T>
@@ -1002,7 +1002,7 @@ ReplaySubscriber<T> newState() {
 			return new ReplaySubscriber<>(new SizeBoundReplayBuffer<>(history),
 					this);
 		}
-		return new ReplaySubscriber<>(new UnboundedReplayBuffer<>(QueueSupplier.SMALL_BUFFER_SIZE),
+		return new ReplaySubscriber<>(new UnboundedReplayBuffer<>(Queues.SMALL_BUFFER_SIZE),
 					this);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishMulticast.java
Patch:
@@ -21,7 +21,7 @@
 
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 /**
  * Shares a sequence for the duration of a function that may transform it and
@@ -48,7 +48,7 @@ public void subscribe(CoreSubscriber<? super R> s) {
 
 		FluxPublishMulticast.FluxPublishMulticaster<T, R> multicast =
 				new FluxPublishMulticast.FluxPublishMulticaster<>(Integer.MAX_VALUE,
-						QueueSupplier.one(), s.currentContext());
+						Queues.one(), s.currentContext());
 
 		Mono<? extends R> out;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -28,7 +28,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 import reactor.util.context.Context;
 
 import static reactor.core.publisher.Operators.cancelledSubscription;
@@ -294,7 +294,7 @@ static final class EqualSubscriber<T>
 		EqualSubscriber(EqualCoordinator<T> parent, int bufferSize) {
 			this.parent = parent;
 			this.bufferSize = bufferSize;
-			this.queue = QueueSupplier.<T>get(bufferSize).get();
+			this.queue = Queues.<T>get(bufferSize).get();
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -32,7 +32,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static reactor.core.publisher.FluxReplay.ReplaySubscriber.EMPTY;
 import static reactor.core.publisher.FluxReplay.ReplaySubscriber.TERMINATED;
@@ -91,15 +91,15 @@ public static <T> ReplayProcessor<T> cacheLastOrDefault(@Nullable T value) {
 	}
 
 	/**
-	 * Create a new {@link ReplayProcessor} using {@link QueueSupplier#SMALL_BUFFER_SIZE}
+	 * Create a new {@link ReplayProcessor} using {@link Queues#SMALL_BUFFER_SIZE}
 	 * backlog size, blockingWait Strategy and auto-cancel.
 	 *
 	 * @param <E> Type of processed signals
 	 *
 	 * @return a fresh processor
 	 */
 	public static <E> ReplayProcessor<E> create() {
-		return create(QueueSupplier.SMALL_BUFFER_SIZE, true);
+		return create(Queues.SMALL_BUFFER_SIZE, true);
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -29,7 +29,6 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-import reactor.util.concurrent.QueueSupplier;
 import reactor.util.concurrent.Queues;
 
 /**
@@ -53,7 +52,7 @@ public final class UnicastProcessor<T>
 	 * @return a unicast {@link FluxProcessor}
 	 */
 	public static <E> UnicastProcessor<E> create() {
-		return new UnicastProcessor<>(QueueSupplier.<E>unbounded().get());
+		return new UnicastProcessor<>(Queues.<E>unbounded().get());
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/util/concurrent/OpenHashSet.java
Patch:
@@ -45,7 +45,7 @@ public OpenHashSet() {
     @SuppressWarnings("unchecked")
     public OpenHashSet(int capacity, float loadFactor) {
         this.loadFactor = loadFactor;
-        int c = QueueSupplier.ceilingNextPowerOfTwo(capacity);
+        int c = Queues.ceilingNextPowerOfTwo(capacity);
         this.mask = c - 1;
         this.maxSize = (int)(loadFactor * c);
         this.keys = (T[])new Object[c];

File: reactor-core/src/main/java/reactor/util/concurrent/SpscArrayQueue.java
Patch:
@@ -40,7 +40,7 @@ final class SpscArrayQueue<T> extends SpscArrayQueueP3<T> implements Queue<T> {
 	private static final long serialVersionUID = 494623116936946976L;
 
 	SpscArrayQueue(int capacity) {
-		super(QueueSupplier.ceilingNextPowerOfTwo(capacity));
+		super(Queues.ceilingNextPowerOfTwo(capacity));
 	}
 	
 	@Override

File: reactor-core/src/main/java/reactor/util/concurrent/SpscLinkedArrayQueue.java
Patch:
@@ -61,7 +61,7 @@ final class SpscLinkedArrayQueue<T> extends AbstractQueue<T>
 	static final Object NEXT = new Object();
 
 	SpscLinkedArrayQueue(int linkSize) {
-		int c = QueueSupplier.ceilingNextPowerOfTwo(Math.max(8, linkSize));
+		int c = Queues.ceilingNextPowerOfTwo(Math.max(8, linkSize));
 		this.producerArray = this.consumerArray = new AtomicReferenceArray<>(c + 1);
 		this.mask = c - 1;
 	}

File: reactor-core/src/main/java/reactor/util/concurrent/package-info.java
Patch:
@@ -15,8 +15,7 @@
  */
 
 /**
- * Queue {@link reactor.util.concurrent.QueueSupplier suppliers} and
- * {@link reactor.util.concurrent.Queues utilities}, busy spin utils
+ * Queue {@link reactor.util.concurrent.Queues suppliers and utilities}, busy spin utils
  * {@link reactor.util.concurrent.WaitStrategy}.
  * Used for operational serialization (serializing threads) or buffering (asynchronous boundary).
  *

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -39,7 +39,7 @@
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
@@ -264,7 +264,7 @@ public void normalAtomicRingBufferBackpressured() {
 	public void state(){
 		EmitterProcessor<Integer> tp = EmitterProcessor.create();
 		assertThat(tp.getPending()).isEqualTo(0);
-		assertThat(tp.getBufferSize()).isEqualTo(QueueSupplier.SMALL_BUFFER_SIZE);
+		assertThat(tp.getBufferSize()).isEqualTo(Queues.SMALL_BUFFER_SIZE);
 		assertThat(tp.isCancelled()).isFalse();
 		assertThat(tp.inners()).isEmpty();
 
@@ -721,7 +721,7 @@ public void createOverrideAll() {
 	public void assertProcessor(EmitterProcessor<Integer> processor,
 			@Nullable Integer bufferSize,
 			@Nullable Boolean autoCancel) {
-		int expectedBufferSize = bufferSize != null ? bufferSize : QueueSupplier.SMALL_BUFFER_SIZE;
+		int expectedBufferSize = bufferSize != null ? bufferSize : Queues.SMALL_BUFFER_SIZE;
 		boolean expectedAutoCancel = autoCancel != null ? autoCancel : true;
 
 		assertEquals(expectedBufferSize, processor.prefetch);

File: reactor-core/src/test/java/reactor/core/publisher/FluxJoinTest.java
Patch:
@@ -23,7 +23,7 @@
 import reactor.core.CoreSubscriber;
 import reactor.core.Scannable;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -262,7 +262,7 @@ public void scanSubscription() {
 						s -> Mono.just(s),
 						s -> Mono.just(s),
 						(l, r) -> l,
-						QueueSupplier.unbounded().get());
+						Queues.unbounded().get());
 
 		assertThat(test.scan(Scannable.ScannableAttr.ACTUAL)).isSameAs(actual);
 		test.request(123);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -35,7 +35,7 @@
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static java.lang.Thread.sleep;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -488,7 +488,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.create(QueueSupplier.<Integer>get(2).get())
+		UnicastProcessor.create(Queues.<Integer>get(2).get())
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -35,7 +35,7 @@
 import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static java.lang.Thread.sleep;
 import static org.hamcrest.CoreMatchers.*;
@@ -736,7 +736,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.create(QueueSupplier.<Integer>get(2).get())
+		UnicastProcessor.create(Queues.<Integer>get(2).get())
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxSampleTimeoutTest.java
Patch:
@@ -27,7 +27,7 @@
 import reactor.core.publisher.FluxSampleTimeout.SampleTimeoutOther;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 public class FluxSampleTimeoutTest {
 
@@ -165,7 +165,7 @@ public void scanMain() {
         CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxSampleTimeout.SampleTimeoutMain<Integer, Integer> test =
         		new FluxSampleTimeout.SampleTimeoutMain<>(actual, i -> Flux.just(i),
-        				QueueSupplier.<SampleTimeoutOther<Integer, Integer>>one().get());
+        				Queues.<SampleTimeoutOther<Integer, Integer>>one().get());
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);
 
@@ -190,7 +190,7 @@ public void scanOther() {
 		CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxSampleTimeout.SampleTimeoutMain<Integer, Integer> main =
         		new FluxSampleTimeout.SampleTimeoutMain<>(actual, i -> Flux.just(i),
-        				QueueSupplier.<SampleTimeoutOther<Integer, Integer>>one().get());
+        				Queues.<SampleTimeoutOther<Integer, Integer>>one().get());
         FluxSampleTimeout.SampleTimeoutOther<Integer, Integer> test =
         		new FluxSampleTimeout.SampleTimeoutOther<Integer, Integer>(main, 1, 0);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxSwitchMapTest.java
Patch:
@@ -26,7 +26,7 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 public class FluxSwitchMapTest {
 
@@ -292,7 +292,7 @@ public void switchOnNextDynamicallyOnNext() {
     public void scanMain() {
         CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxSwitchMap.SwitchMapMain<Integer, Integer> test =
-        		new FluxSwitchMap.SwitchMapMain<>(actual, i -> Mono.just(i), QueueSupplier.unbounded().get(), 234);
+        		new FluxSwitchMap.SwitchMapMain<>(actual, i -> Mono.just(i), Queues.unbounded().get(), 234);
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);
 
@@ -319,7 +319,7 @@ public void scanMain() {
     public void scanInner() {
         CoreSubscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxSwitchMap.SwitchMapMain<Integer, Integer> main =
-        		new FluxSwitchMap.SwitchMapMain<>(actual, i -> Mono.just(i), QueueSupplier.unbounded().get(), 234);
+        		new FluxSwitchMap.SwitchMapMain<>(actual, i -> Mono.just(i), Queues.unbounded().get(), 234);
         FluxSwitchMap.SwitchMapInner<Integer> test = new FluxSwitchMap.SwitchMapInner<Integer>(main, 1, 0);
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -29,7 +29,7 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -251,7 +251,7 @@ public void windowWillAcumulateMultipleListsOfValues() {
     public void scanMainSubscriber() {
         CoreSubscriber<Flux<Integer>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxWindowBoundary.WindowBoundaryMain<Integer, Integer> test = new FluxWindowBoundary.WindowBoundaryMain<>(actual,
-        		QueueSupplier.unbounded(), QueueSupplier.<Integer>unbounded().get(), QueueSupplier.unbounded().get());
+        		Queues.unbounded(), Queues.<Integer>unbounded().get(), Queues.unbounded().get());
         Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 
@@ -280,7 +280,7 @@ public void scanMainSubscriber() {
     public void scanOtherSubscriber() {
         CoreSubscriber<Flux<Integer>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxWindowBoundary.WindowBoundaryMain<Integer, Integer> main = new FluxWindowBoundary.WindowBoundaryMain<>(actual,
-        		QueueSupplier.unbounded(), QueueSupplier.<Integer>unbounded().get(), QueueSupplier.unbounded().get());
+        		Queues.unbounded(), Queues.<Integer>unbounded().get(), Queues.unbounded().get());
         FluxWindowBoundary.WindowBoundaryOther<Integer> test =
         		new FluxWindowBoundary.WindowBoundaryOther<>(main);
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowWhenTest.java
Patch:
@@ -29,7 +29,7 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -263,8 +263,8 @@ public void windowWillSubdivideAnInputFluxGapTime() {
     public void scanMainSubscriber() {
         CoreSubscriber<Flux<Integer>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxWindowWhen.WindowStartEndMainSubscriber<Integer, Integer, Integer> test =
-        		new FluxWindowWhen.WindowStartEndMainSubscriber<>(actual, QueueSupplier.one().get(),
-        		s -> Flux.just(s), QueueSupplier.unbounded());
+        		new FluxWindowWhen.WindowStartEndMainSubscriber<>(actual, Queues.one().get(),
+        		s -> Flux.just(s), Queues.unbounded());
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java
Patch:
@@ -29,7 +29,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -135,7 +135,7 @@ public void equalPredicateFailure() {
 
 	@Test
 	public void largeSequence() {
-		Flux<Integer> source = Flux.range(1, QueueSupplier.SMALL_BUFFER_SIZE * 4).subscribeOn(Schedulers.elastic());
+		Flux<Integer> source = Flux.range(1, Queues.SMALL_BUFFER_SIZE * 4).subscribeOn(Schedulers.elastic());
 
 		StepVerifier.create(Mono.sequenceEqual(source, source))
 		            .expectNext(Boolean.TRUE)

File: reactor-core/src/test/java/reactor/core/publisher/TopicProcessorTest.java
Patch:
@@ -35,7 +35,7 @@
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 import reactor.util.concurrent.WaitStrategy;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -821,7 +821,7 @@ private void assertProcessor(TopicProcessor<Integer> processor,
 			@Nullable ExecutorService requestTaskExecutor) {
 
 		String expectedName = name != null ? name : TopicProcessor.class.getSimpleName();
-		int expectedBufferSize = bufferSize != null ? bufferSize : QueueSupplier.SMALL_BUFFER_SIZE;
+		int expectedBufferSize = bufferSize != null ? bufferSize : Queues.SMALL_BUFFER_SIZE;
 		boolean expectedAutoCancel = autoCancel != null ? autoCancel : true;
 		WaitStrategy expectedWaitStrategy = waitStrategy != null ? waitStrategy : WaitStrategy.phasedOffLiteLock(200, 100, TimeUnit.MILLISECONDS);
 		Class<?> sequencerClass = shared ? MultiProducerRingBuffer.class : SingleProducerSequencer.class;

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -40,7 +40,7 @@
 import reactor.core.publisher.ReplayProcessor;
 import reactor.core.publisher.UnicastProcessor;
 import reactor.test.StepVerifier;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static reactor.core.Fuseable.*;
@@ -329,7 +329,7 @@ protected final RuntimeException exception() {
 
 	final int defaultLimit(OperatorScenario<I, PI, O, PO> scenario) {
 		if (scenario.prefetch() == -1) {
-			return QueueSupplier.SMALL_BUFFER_SIZE - (QueueSupplier.SMALL_BUFFER_SIZE >> 2);
+			return Queues.SMALL_BUFFER_SIZE - (Queues.SMALL_BUFFER_SIZE >> 2);
 		}
 		if (scenario.prefetch() == Integer.MAX_VALUE) {
 			return Integer.MAX_VALUE;

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -30,7 +30,8 @@
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
-import reactor.util.concurrent.QueueSupplier;
+import reactor.util.concurrent.Queues;
+
 import javax.annotation.Nullable;
 
 /**
@@ -177,7 +178,7 @@ public static void reset() {
 	}
 
 	final Queue<TimedRunnable> queue =
-			new PriorityBlockingQueue<>(QueueSupplier.XS_BUFFER_SIZE);
+			new PriorityBlockingQueue<>(Queues.XS_BUFFER_SIZE);
 
 	@SuppressWarnings("unused")
 	volatile long counter;

File: reactor-core/src/main/java/reactor/util/concurrent/package-info.java
Patch:
@@ -15,7 +15,8 @@
  */
 
 /**
- * Queue {@link reactor.util.concurrent.QueueSupplier suppliers} and busy spin utils
+ * Queue {@link reactor.util.concurrent.QueueSupplier suppliers} and
+ * {@link reactor.util.concurrent.Queues utilities}, busy spin utils
  * {@link reactor.util.concurrent.WaitStrategy}.
  * Used for operational serialization (serializing threads) or buffering (asynchronous boundary).
  *

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -352,8 +352,9 @@ final void drain() {
 				return;
 			}
 
-			if (!empty) {
-				FluxPublish.PubSubInner<T>[] a = subscribers;
+			FluxPublish.PubSubInner<T>[] a = subscribers;
+
+			if (a != EMPTY && !empty) {
 				long maxRequested = Long.MAX_VALUE;
 
 				int len = a.length;

File: reactor-core/src/test/java/reactor/core/publisher/EventLoopProcessorTest.java
Patch:
@@ -35,6 +35,7 @@ public void scanMain() throws Exception {
 		EventLoopProcessor<String> test = new EventLoopProcessor<String>(128,
 				r -> new Thread(r),
 				Executors.newSingleThreadExecutor(),
+				Executors.newSingleThreadExecutor(),
 				true,
 				false,
 				() -> null,

File: reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java
Patch:
@@ -349,7 +349,7 @@ public void singleSubscriberOnly() {
 		source2.onNext(2);
 		source2.onComplete();
 
-		ts.assertValues(1, 2)
+		ts.assertValues(1, 10, 2)
 		.assertNoError()
 		.assertComplete();
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxProcessorTest.java
Patch:
@@ -122,7 +122,7 @@ public void testSubmitSession() throws Exception {
 		processor.publishOn(scheduler)
 		         .delaySubscription(Duration.ofMillis(1000))
 		         .limitRate(1)
-		                                    .subscribe(d -> {
+		         .subscribe(d -> {
 			         count.incrementAndGet();
 			         latch.countDown();
 		         });
@@ -133,7 +133,7 @@ public void testSubmitSession() throws Exception {
 		session.complete();
 
 		latch.await(5, TimeUnit.SECONDS);
-		Assert.assertTrue("latch : " + count, count.get() == 0);
+		Assert.assertTrue("latch : " + count, count.get() == 1);
 		scheduler.dispose();
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractFluxVerification.java
Patch:
@@ -46,7 +46,7 @@ public abstract class AbstractFluxVerification extends org.reactivestreams.tck.I
 	protected final int batch = 1024;
 
 	public AbstractFluxVerification() {
-		super(new TestEnvironment(1000, true));
+		super(new TestEnvironment(true));
 	}
 
 	final ExecutorService executorService = Executors.newCachedThreadPool();

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractProcessorVerification.java
Patch:
@@ -48,7 +48,7 @@ public ExecutorService publisherExecutorService() {
 	}
 
 	public AbstractProcessorVerification() {
-		super(new TestEnvironment(500, true));
+		super(new TestEnvironment(500));
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/publisher/tck/FluxBlackboxProcessorVerification.java
Patch:
@@ -65,7 +65,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				 .publishOn(sharedGroup)
 				 .doAfterTerminate(asyncGroup::dispose)
 				 .doOnError(Throwable::printStackTrace)
-				.awaitOnSubscribe());
+				 .log());
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/publisher/tck/FluxGenerateVerification.java
Patch:
@@ -30,7 +30,7 @@
 public class FluxGenerateVerification extends PublisherVerification<Long> {
 
 	public FluxGenerateVerification() {
-		super(new TestEnvironment(500, true), 1000);
+		super(new TestEnvironment(500), 1000);
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java
Patch:
@@ -64,8 +64,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                          .doOnNext(this::monitorThreadUse))
 				 .doOnNext(array -> cumulatedJoin.getAndIncrement())
 				 .subscribeWith(TopicProcessor.<Integer>builder().name("fluxion-raw-join").bufferSize(bufferSize).build())
-				 .doOnError(Throwable::printStackTrace)
-				 .awaitOnSubscribe());
+				 .doOnError(Throwable::printStackTrace));
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/adapter/JdkFlowAdapter.java
Patch:
@@ -81,7 +81,7 @@ public void subscribe(Flow.Subscriber<? super T> subscriber) {
         }
     }
 
-    private static class FlowSubscriber<T> implements Subscriber<T>, Flow.Subscription {
+    private static class FlowSubscriber<T> implements CoreSubscriber<T>, Flow.Subscription {
 
 		private final Flow.Subscriber<? super T> subscriber;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -267,7 +267,7 @@ void handleTimeout() {
 		}
 	}
 
-	static final class TimeoutOtherSubscriber<T> implements Subscriber<T> {
+	static final class TimeoutOtherSubscriber<T> implements CoreSubscriber<T> {
 
 		final CoreSubscriber<? super T> actual;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoToCompletableFuture.java
Patch:
@@ -20,11 +20,12 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.CoreSubscriber;
 
 /**
  * @author Stephane Maldini
  */
-final class MonoToCompletableFuture<T> extends CompletableFuture<T> implements Subscriber<T> {
+final class MonoToCompletableFuture<T> extends CompletableFuture<T> implements CoreSubscriber<T> {
 
 	final AtomicReference<Subscription> ref = new AtomicReference<>();
 

File: reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java
Patch:
@@ -20,6 +20,7 @@
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Flux;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher.Violation;
@@ -84,7 +85,7 @@ public void normalIgnoresMultipleTerminations() {
 		TestPublisher<String> publisher = TestPublisher.create();
 		AtomicLong count = new AtomicLong();
 
-		Subscriber<String> subscriber = new Subscriber<String>() {
+		Subscriber<String> subscriber = new CoreSubscriber<String>() {
 			@Override
 			public void onSubscribe(Subscription s) { }
 
@@ -115,7 +116,7 @@ public void misbehavingAllowsMultipleTerminations() {
 		TestPublisher<String> publisher = TestPublisher.createNoncompliant(Violation.CLEANUP_ON_TERMINATE);
 		AtomicLong count = new AtomicLong();
 
-		Subscriber<String> subscriber = new Subscriber<String>() {
+		Subscriber<String> subscriber = new CoreSubscriber<String>() {
 			@Override
 			public void onSubscribe(Subscription s) {
 				s.request(Long.MAX_VALUE);

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -55,7 +55,7 @@ public static <T> Flux<T> instance() {
 
 	@Override
 	@Nullable
-	public Object call() {
+	public Object call() throws Exception {
 		return null; /* Scalar optimizations on empty */
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -59,7 +59,7 @@ final class FluxJust<T> extends Flux<T> implements Fuseable.ScalarCallable<T>, F
 	}
 
 	@Override
-	public T call() {
+	public T call() throws Exception {
 		return value;
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -58,7 +58,7 @@ static <T> Mono<T> instance() {
 
 	@Override
 	@Nullable
-	public Object call() {
+	public Object call() throws Exception {
 		return null; /* Scalar optimizations on empty */
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -35,7 +35,7 @@ final class MonoJust<T>
 	}
 
 	@Override
-	public T call() {
+	public T call() throws Exception {
 		return value;
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxFlatMapTest.java
Patch:
@@ -486,7 +486,7 @@ public void failPublisher() {
 	@Test
 	public void failPublisherDelay() {
 		StepVerifier.create(Flux.just(1, 2, 3)
-		                        .flatMapDelayError(d -> Flux.error(new Exception("test")),
+		                        .flatMapDelayError(d -> Flux.error(new Exception("test")).hide(),
 				                        1,
 				                        1))
 		            .verifyErrorMessage("Multiple exceptions");

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeTest.java
Patch:
@@ -112,7 +112,7 @@ public void mergeDelayError() {
 		IllegalStateException boom = new IllegalStateException("boom");
 
 		StepVerifier.create(Flux.mergeDelayError(32,
-				Flux.error(boom),
+				Flux.error(boom).hide(),
 				Flux.range(1, 4)
 		))
 		            .expectNext(1, 2, 3, 4)

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekStatefulTest.java
Patch:
@@ -97,7 +97,7 @@ public void error() {
 		LongAdder seedCount = new LongAdder();
 		LongAdder state = new LongAdder();
 
-		new FluxPeekStateful<>(new FluxError<Integer>(new RuntimeException("forced " + "failure"),	false),
+		new FluxPeekStateful<>(new FluxError<Integer>(new RuntimeException("forced " + "failure")),
 				() -> {
 					seedCount.increment();
 					return state;

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -306,7 +306,7 @@ public void error() {
 		AtomicBoolean onAfterComplete = new AtomicBoolean();
 		AtomicBoolean onCancel = new AtomicBoolean();
 
-		new FluxPeek<>(new FluxError<>(new RuntimeException("forced failure"), false),
+		new FluxPeek<>(new FluxError<>(new RuntimeException("forced failure")),
 				onSubscribe::set,
 				onNext::set,
 				onError::set,

File: reactor-core/src/test/java/reactor/core/publisher/FluxZipTest.java
Patch:
@@ -57,6 +57,9 @@ protected List<Scenario<String, String>> scenarios_errorFromUpstreamFailure() {
 					.prefetch(3),
 
 				scenario(f -> f.zipWith(Flux.<String>error(exception()),
+						(a, b) -> a)).shouldHitDropErrorHookAfterTerminate(false),
+
+				scenario(f -> f.zipWith(Flux.<String>error(exception()).hide(),
 						(a, b) -> a)));
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/EmitterProcessorTest.java
Patch:
@@ -751,7 +751,7 @@ public static long getAndSub(AtomicLong sequence, long toSub) {
 
 	@Test
 	public void scanMain() {
-		EmitterProcessor<Integer> test = EmitterProcessor.<Integer>builder().bufferSize(123).build();
+		EmitterProcessor<Integer> test = EmitterProcessor.create(123);
 		assertThat(test.scan(BUFFERED)).isEqualTo(0);
 		assertThat(test.scan(CANCELLED)).isFalse();
 		assertThat(test.scan(PREFETCH)).isEqualTo(123);

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -328,6 +328,7 @@ public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return s;
 		if (key == IntAttr.BUFFERED) return getPending();
 		if (key == BooleanAttr.CANCELLED) return isCancelled();
+		if (key == IntAttr.PREFETCH) return getPrefetch();
 
 		return super.scanUnsafe(key);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -73,6 +73,7 @@ public int getPrefetch() {
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;
+		if (key == IntAttr.CAPACITY) return remaining;
 
 		return null;
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -74,6 +74,7 @@ public int getPrefetch() {
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;
+		if (key == IntAttr.CAPACITY) return remaining;
 
 		return null;
 	}

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectFuseableTest.java
Patch:
@@ -33,7 +33,7 @@ public void scanMain() {
 
 		assertThat(test.scan(Scannable.ScannableAttr.PARENT)).isSameAs(source);
 		assertThat(test.scan(Scannable.IntAttr.PREFETCH)).isEqualTo(888);
-//		assertThat(test.scan(Scannable.IntAttr.CAPACITY)).isEqualTo(123);
+		assertThat(test.scan(Scannable.IntAttr.CAPACITY)).isEqualTo(123);
 	}
 
 }
\ No newline at end of file

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -87,7 +87,7 @@ public void scanMain() {
 		FluxAutoConnect<String> test = new FluxAutoConnect<>(source, 123, d -> { });
 
 		assertThat(test.scan(Scannable.IntAttr.PREFETCH)).isEqualTo(888);
-//		assertThat(test.scan(Scannable.IntAttr.CAPACITY)).isEqualTo(123);
+		assertThat(test.scan(Scannable.IntAttr.CAPACITY)).isEqualTo(123);
 		assertThat(test.scan(Scannable.ScannableAttr.PARENT)).isSameAs(source);
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -568,7 +568,7 @@ public void syncFusionMapToNullFilter() {
 	public void asyncFusionMapToNull() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build();
+		UnicastProcessor<Integer> up = UnicastProcessor.create(QueueSupplier.<Integer>get(2).get());
 		up.onNext(1);
 		up.onNext(2);
 		up.onComplete();
@@ -587,7 +587,7 @@ public void asyncFusionMapToNullFilter() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build();
+				UnicastProcessor.create(QueueSupplier.<Integer>get(2).get());
 		up.onNext(1);
 		up.onNext(2);
 		up.onComplete();

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -180,7 +180,7 @@ public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
 
 		up.filter(v -> (v & 1) == 0)
 		  .subscribe(ts);
@@ -200,7 +200,7 @@ public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
 
 		Flux.just(1)
 		    .hide()
@@ -226,7 +226,7 @@ public void asyncFusionBackpressured2() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
 
 		Flux.just(1)
 		    .hide()

File: reactor-core/src/test/java/reactor/core/publisher/FluxMapTest.java
Patch:
@@ -145,7 +145,7 @@ public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
 
 		up.map(v -> v + 1)
 		  .subscribe(ts);
@@ -165,7 +165,7 @@ public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
 
 		Flux.just(1)
 		    .hide()

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -490,7 +490,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build()
+		UnicastProcessor.create(QueueSupplier.<Integer>get(2).get())
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -736,7 +736,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build()
+		UnicastProcessor.create(QueueSupplier.<Integer>get(2).get())
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -148,7 +148,7 @@ public void subsequentSumAsync() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(16).get()).build();
+				UnicastProcessor.create(QueueSupplier.<Integer>get(16).get());
 
 		up.publish(o -> zip((Object[] a) -> (Integer) a[0] + (Integer) a[1], o, o.skip(1)))
 		  .subscribe(ts);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -157,7 +157,7 @@ public void normalAsyncFused() {
 		AssertSubscriber<Integer> ts1 = AssertSubscriber.create();
 		AssertSubscriber<Integer> ts2 = AssertSubscriber.create();
 
-		UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(8).get()).build();
+		UnicastProcessor<Integer> up = UnicastProcessor.create(QueueSupplier.<Integer>get(8).get());
 		up.onNext(1);
 		up.onNext(2);
 		up.onNext(3);
@@ -196,7 +196,7 @@ public void normalBackpressuredAsyncFused() {
 		AssertSubscriber<Integer> ts1 = AssertSubscriber.create(0);
 		AssertSubscriber<Integer> ts2 = AssertSubscriber.create(0);
 
-		UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(8).get()).build();
+		UnicastProcessor<Integer> up = UnicastProcessor.create(QueueSupplier.<Integer>get(8).get());
 		up.onNext(1);
 		up.onNext(2);
 		up.onNext(3);

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1363,7 +1363,7 @@ public void multiplexUsingDispatchersAndSplit() throws Exception {
 
 		final EmitterProcessor<Integer> forkEmitterProcessor = EmitterProcessor.create();
 
-		final EmitterProcessor<Integer> computationEmitterProcessor = EmitterProcessor.<Integer>builder().autoCancel(false).build();
+		final EmitterProcessor<Integer> computationEmitterProcessor = EmitterProcessor.create(false);
 
 		Scheduler computation = Schedulers.newSingle("computation");
 		Scheduler persistence = Schedulers.newSingle("persistence");
@@ -1381,7 +1381,7 @@ public void multiplexUsingDispatchersAndSplit() throws Exception {
 				                      .doOnNext(ls -> println("Computed: ", ls))
 				                      .log("computation");
 
-		final EmitterProcessor<Integer> persistenceEmitterProcessor = EmitterProcessor.<Integer>builder().autoCancel(false).build();
+		final EmitterProcessor<Integer> persistenceEmitterProcessor = EmitterProcessor.create(false);
 
 		final Flux<List<String>> persistenceStream =
 				persistenceEmitterProcessor.publishOn(persistence)

File: reactor-core/src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -29,7 +29,7 @@ public class EmitterProcessorVerification extends AbstractProcessorVerification
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
-		return EmitterProcessor.<Long>builder().bufferSize(bufferSize).build();
+		return EmitterProcessor.create(bufferSize);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5970,7 +5970,9 @@ public final <A> Flux<A> scanWith(Supplier<A> initial, BiFunction<A, ? super T,
 	 * to subscribe once, late subscribers might therefore miss items.
 	 */
 	public final Flux<T> share() {
-		return publish().refCount();
+		return onAssembly(new FluxRefCount<>(
+				new FluxPublish<>(this, QueueSupplier.SMALL_BUFFER_SIZE, QueueSupplier.small()), 1)
+		);
 	}
 
 	/**

File: reactor-core/src/test/java/reactor/HooksTest.java
Patch:
@@ -352,7 +352,7 @@ public void testTrace3() throws Exception {
 			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains
 					("HooksTest.java:"));
 			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains("|_\tFlux" +
-					".publish" +
+					".share" +
 					"(HooksTest.java:"));
 			return;
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -232,7 +232,7 @@ static String extract(String source, boolean skipFirst) {
 				usercode = s.substring(s.indexOf('('));
 				break;
 			}
-			else if(last == null){
+			else {
 				last = s.replace("reactor.core.publisher.", "");
 				last = last.substring(0, last.indexOf("("));
 			}

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -17,8 +17,6 @@
 
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
-import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
 import org.reactivestreams.Publisher;

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -965,7 +965,7 @@ final void resetHooks() {
 		Hooks.resetOnNextDropped();
 		Hooks.resetOnOperator();
 		Hooks.resetOnOperatorError();
-		Hooks.resetOnSubscriber();
+		Hooks.resetOnNewSubscriber();
 	}
 
 	final  void testPublisherSource(OperatorScenario<I, PI, O, PO> scenario, TestPublisher<I> ts) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxElapsed.java
Patch:
@@ -17,6 +17,7 @@
 package reactor.core.publisher;
 
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -25,7 +26,6 @@
 import reactor.util.context.Context;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
-import javax.annotation.Nullable;
 
 /**
  * @author Stephane Maldini
@@ -41,7 +41,7 @@ final class FluxElapsed<T> extends FluxOperator<T, Tuple2<Long, T>> implements F
 
 	@Override
 	public void subscribe(Subscriber<? super Tuple2<Long, T>> s, Context ctx) {
-		source.subscribe(new ElapsedSubscriber<T>(s, scheduler), ctx);
+		source.subscribe(new ElapsedSubscriber<>(s, scheduler), ctx);
 	}
 
 	static final class ElapsedSubscriber<T>

File: reactor-core/src/test/java/reactor/core/publisher/FluxElapsedTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-
 import reactor.core.Scannable;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -19,6 +19,7 @@
 import java.time.Duration;
 import java.util.Collection;
 import java.util.Objects;
+import java.util.Optional;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -1044,14 +1045,14 @@ interface Assertions {
 		 * Assert that the tested publisher has triggered the {@link Hooks#onOperatorError(BiFunction) onOperatorError} hook
 		 * once or more, and assert the errors and optionally associated data as a collection.
 		 */
-		Assertions hasOperatorErrorsSatisfying(Consumer<Collection<Tuple2<Throwable, ?>>> errorsConsumer);
+		Assertions hasOperatorErrorsSatisfying(Consumer<Collection<Tuple2<Optional<Throwable>, Optional<?>>>> errorsConsumer);
 
 		/**
 		 * Assert that the tested publisher has triggered the {@link Hooks#onOperatorError(BiFunction) onOperatorError} hook
 		 * once or more, and check that the collection of errors and their optionally
 		 * associated data matches a predicate.
 		 */
-		Assertions hasOperatorErrorsMatching(Predicate<Collection<Tuple2<Throwable, ?>>> errorsConsumer);
+		Assertions hasOperatorErrorsMatching(Predicate<Collection<Tuple2<Optional<Throwable>, Optional<?>>>> errorsConsumer);
 
 		/**
 		 * Assert that the whole verification took strictly less than the provided

File: reactor-core/src/main/java/reactor/util/context/Context.java
Patch:
@@ -112,7 +112,7 @@ static void push(Object o, Context c) {
 	@Nullable
 	default <T> T get(Class<T> key){
 		T v = get((Object)key);
-		if(key.isInstance(key)){
+		if(key.isInstance(v)){
 			return v;
 		}
 		return null;

File: reactor-core/src/test/java/reactor/core/publisher/FluxSourceTest.java
Patch:
@@ -54,13 +54,11 @@ public void just() {
 	@Test
 	public void wrap() {
 		Flux<Integer> m = Flux.wrap(Flux.just(1));
-		assertTrue(m instanceof FluxJust);
 		StepVerifier.create(m)
 		            .expectNext(1)
 		            .verifyComplete();
 
 		m = Flux.wrap(Flux.just(1).hide());
-		assertTrue(m instanceof FluxJust);
 		StepVerifier.create(m)
 		            .expectNext(1)
 		            .verifyComplete();

File: reactor-core/src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2531,7 +2531,7 @@ public final Flux<T> cancelOn(Scheduler scheduler) {
 	 * @return the assembly tracing {@link Flux}.
 	 */
 	public final Flux<T> checkpoint() {
-		return new FluxOnAssembly<>(this, null);
+		return checkpoint(null, true);
 	}
 
 	/**
@@ -2551,7 +2551,7 @@ public final Flux<T> checkpoint() {
 	 * @return the assembly marked {@link Flux}
 	 */
 	public final Flux<T> checkpoint(String description) {
-		return new FluxOnAssembly<>(this, description, true);
+		return checkpoint(Objects.requireNonNull(description), false);
 	}
 
 	/**
@@ -2580,7 +2580,7 @@ public final Flux<T> checkpoint(String description) {
 	 * to use a stack trace.
 	 * @return the assembly marked {@link Flux}.
 	 */
-	public final Flux<T> checkpoint(String description, boolean forceStackTrace) {
+	public final Flux<T> checkpoint(@Nullable String description, boolean forceStackTrace) {
 		return new FluxOnAssembly<>(this, description, !forceStackTrace);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoUntilOther.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
 import javax.annotation.Nullable;
@@ -182,9 +183,7 @@ void signal() {
 						compositeError.addSuppressed(e);
 					} else
 					if (error != null) {
-						compositeError = new Throwable("Multiple errors");
-						compositeError.addSuppressed(error);
-						compositeError.addSuppressed(e);
+						compositeError = Exceptions.multiple(error, e);
 					} else {
 						error = e;
 					}

File: reactor-core/src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -26,6 +26,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
 import javax.annotation.Nullable;
@@ -214,9 +215,7 @@ void signal() {
                             compositeError.addSuppressed(e);
                         } else
                         if (error != null) {
-                            compositeError = new Throwable("Multiple errors");
-                            compositeError.addSuppressed(error);
-                            compositeError.addSuppressed(e);
+	                        compositeError = Exceptions.multiple(error, e);
                         } else {
                             error = e;
                         }

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java
Patch:
@@ -137,7 +137,7 @@ public void multipleTriggersWithErrorDelayed() {
 				Mono.just("ok"), a -> Mono.<Integer>error(boom1))
 				.delayUntilDelayError(a -> Mono.error(boom2))
 		)
-		            .verifyErrorMatches(e -> e.getMessage().equals("Multiple errors") &&
+		            .verifyErrorMatches(e -> e.getMessage().equals("Multiple exceptions") &&
 				            e.getSuppressed()[0] == boom1 &&
 				            e.getSuppressed()[1] == boom2);
 	}

File: reactor-core/src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -420,7 +420,7 @@ public void whenIterableDelayErrorCombinesErrors() {
 		StepVerifier.create(Mono.whenDelayError(
 				Arrays.asList(Mono.just("foo"), Mono.<String>error(boom1), Mono.<String>error(boom2)),
 				Tuples.fn3()))
-		            .verifyErrorMatches(e -> e.getMessage().equals("Multiple errors") &&
+		            .verifyErrorMatches(e -> e.getMessage().equals("Multiple exceptions") &&
 				            e.getSuppressed()[0] == boom1 &&
 				            e.getSuppressed()[1] == boom2);
 	}
@@ -447,7 +447,7 @@ public void whenIterableDelayErrorPublishersVoidCombinesErrors() {
 				Mono.<Void>error(boom2));
 
 		StepVerifier.create(Mono.whenDelayError(voidPublishers))
-		            .verifyErrorMatches(e -> e.getMessage().equals("Multiple errors") &&
+		            .verifyErrorMatches(e -> e.getMessage().equals("Multiple exceptions") &&
 				            e.getSuppressed()[0] == boom1 &&
 				            e.getSuppressed()[1] == boom2);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -396,10 +396,11 @@ public static <T> Mono<T> fromFuture(CompletableFuture<? extends T> future) {
 	 * <p>
 	 * @param runnable {@link Runnable} that will be executed before emitting the completion signal
 	 *
+	 * @param <T> The generic type of the upstream, which is preserved by this operator
 	 * @return A {@link Mono}.
 	 */
-	public static Mono<Void> fromRunnable(Runnable runnable) {
-		return onAssembly(new MonoRunnable(runnable));
+	public static <T> Mono<T> fromRunnable(Runnable runnable) {
+		return onAssembly(new MonoRunnable<>(runnable));
 	}
 
 	/**

File: reactor-core/src/test/java/reactor/core/publisher/MonoRunnableTest.java
Patch:
@@ -37,7 +37,7 @@ public void nullValue() {
 	public void normal() {
 		AssertSubscriber<Void> ts = AssertSubscriber.create();
 
-		Mono.fromRunnable(() -> {
+		Mono.<Void>fromRunnable(() -> {
 		})
 		    .subscribe(ts);
 
@@ -50,7 +50,7 @@ public void normal() {
 	public void normalBackpressured() {
 		AssertSubscriber<Void> ts = AssertSubscriber.create(0);
 
-		Mono.fromRunnable(() -> {
+		Mono.<Void>fromRunnable(() -> {
 		})
 		    .hide()
 		    .subscribe(ts);
@@ -102,7 +102,7 @@ public void runnableThrows() {
 	public void nonFused() {
 		AssertSubscriber<Void> ts = AssertSubscriber.create();
 
-		Mono.fromRunnable(() -> {
+		Mono.<Void>fromRunnable(() -> {
 		})
 		    .subscribe(ts);
 

File: reactor-core/src/main/java/reactor/core/Exceptions.java
Patch:
@@ -261,7 +261,7 @@ public static <T> Throwable terminate(AtomicReferenceFieldUpdater<T, Throwable>
 	}
 
 	/**
-	 * Throws a particular {@code Throwable} only if it belongs to a set of "fatal" error
+	 * Throws a particular {@code Throwable} only if it belongs to a push of "fatal" error
 	 * varieties. These varieties are as follows: <ul>
 	 *     <li>{@code BubblingException} (as detectable by {@link #isBubbling(Throwable)})</li>
 	 *     <li>{@code ErrorCallbackNotImplemented} (as detectable by {@link #isErrorCallbackNotImplemented(Throwable)})</li>
@@ -280,7 +280,7 @@ public static void throwIfFatal(@Nullable Throwable t) {
 	}
 
 	/**
-	 * Throws a particular {@code Throwable} only if it belongs to a set of "fatal" error
+	 * Throws a particular {@code Throwable} only if it belongs to a push of "fatal" error
 	 * varieties native to the JVM. These varieties are as follows:
 	 * <ul> <li>{@link VirtualMachineError}</li> <li>{@link ThreadDeath}</li>
 	 * <li>{@link LinkageError}</li> </ul>

File: reactor-core/src/main/java/reactor/core/Scannable.java
Patch:
@@ -161,7 +161,7 @@ enum IntAttr implements Attr<Integer> {
 		 * Prefetch is an {@link Integer} attribute defining the rate of processing in a
 		 * component which has capacity to request and hold a backlog of data. It
 		 * usually maps to a component capacity when no arbitrary {@link #CAPACITY} is
-		 * set. {@link Integer#MAX_VALUE} signal unlimited capacity and therefore
+		 * push. {@link Integer#MAX_VALUE} signal unlimited capacity and therefore
 		 * unbounded demand.
 		 * <p>
 		 * Note: This attribute usually resolves to a constant value.

File: reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -36,7 +36,7 @@
  * receive a value due to not requesting enough.
  * <p>
  * <p>
- * The implementation ignores Subscriptions set via onSubscribe.
+ * The implementation ignores Subscriptions push via onSubscribe.
  * <p>
  * <p>
  * A terminated DirectProcessor will emit the terminal signal to late subscribers.

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
 
 /**
  * Delays the subscription to the main source until another Publisher
@@ -168,7 +167,7 @@ static final class DelaySubscriptionMainSubscriber<T>
 
 		@Override
 		public void onContextUpdate(Context context) {
-			ContextRelay.set(actual, context);
+			Context.push(actual, context);
 		}
 
 		@Override

File: reactor-core/src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -29,7 +29,7 @@
 import javax.annotation.Nullable;
 
 /**
- * Given a set of source Publishers the values of that Publisher is forwarded to the
+ * Given a push of source Publishers the values of that Publisher is forwarded to the
  * subscriber which responds first with any signal.
  *
  * @param <T> the value type

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -34,7 +34,6 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
 
 /**
  * Groups upstream items into their own Publisher sequence based on a key selector.
@@ -259,7 +258,7 @@ public Stream<? extends Scannable> inners() {
 		void signalAsyncError() {
 			Throwable e = Exceptions.terminate(ERROR, this); //TODO investigate if e == null
 			if (e == null) {
-				e = new IllegalStateException("FluxGroupBy.signalAsyncError called without error set");
+				e = new IllegalStateException("FluxGroupBy.signalAsyncError called without error push");
 			}
 			groupCount = 0;
 			for (UnicastGroupedFlux<K, V> g : groupMap.values()) {
@@ -697,7 +696,7 @@ public void onComplete() {
 		@Override
 		public void subscribe(Subscriber<? super V> s, Context context) {
 			if (once == 0 && ONCE.compareAndSet(this, 0, 1)) {
-				ContextRelay.set(s, context);
+				Context.push(s, context);
 				s.onSubscribe(this);
 				ACTUAL.lazySet(this, s);
 				drain();

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -37,7 +37,7 @@
 import reactor.core.Scannable;
 import reactor.util.concurrent.OpenHashSet;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
+import reactor.util.context.Contextualized;
 import javax.annotation.Nullable;
 
 /**
@@ -111,7 +111,7 @@ public void subscribe(Subscriber<? super R> s, Context ctx) {
 		other.subscribe(right);
 	}
 
-	interface JoinSupport extends ContextRelay {
+	interface JoinSupport extends Contextualized {
 
 		void innerError(Throwable ex);
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -52,7 +52,7 @@ final class FluxOnAssembly<T> extends FluxOperator<T, T> implements Fuseable, As
 	final AssemblySnapshotException snapshotStack;
 
 	/**
-	 * If set to true, the creation of FluxOnAssembly will capture the raw stacktrace
+	 * If push to true, the creation of FluxOnAssembly will capture the raw stacktrace
 	 * instead of the sanitized version.
 	 */
 	static final boolean fullStackTrace = Boolean.parseBoolean(System.getProperty(

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -24,9 +24,9 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Disposable;
-import reactor.core.Exceptions;
 import reactor.core.Scannable;
-import reactor.util.context.ContextRelay;
+import reactor.util.context.Context;
+
 import javax.annotation.Nullable;
 
 /**
@@ -205,7 +205,7 @@ public final FluxSink<IN> sink(FluxSink.OverflowStrategy strategy) {
 			strategy = FluxSink.OverflowStrategy.IGNORE;
 		}
 
-		FluxCreate.BaseSink<IN> s = FluxCreate.createSink(this, strategy, ContextRelay.getOrEmpty(this));
+		FluxCreate.BaseSink<IN> s = FluxCreate.createSink(this, strategy);
 		onSubscribe(s);
 
 		if(s.isCancelled() ||

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -32,7 +32,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
+
 import javax.annotation.Nullable;
 
 /**
@@ -186,11 +186,11 @@ public Context currentContext() {
 		@Override
 		public void subscribe(Subscriber<? super T> s, Context ctx) {
 			PublishMulticastInner<T> pcs = new PublishMulticastInner<>(this, s);
-			ContextRelay.set(s, ctx);
+			Context.push(s, ctx);
 			s.onSubscribe(pcs);
 
 			if (add(pcs)) {
-				ContextRelay.set(s, context);
+				Context.push(s, context);
 				if (pcs.once != 0) {
 					removeAndDrain(pcs);
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -26,7 +26,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
+
 import javax.annotation.Nullable;
 
 /**
@@ -224,7 +224,7 @@ public void onComplete() {
 
 		@Override
 		public void subscribe(Subscriber<? super Long> s, Context ctx) {
-			ContextRelay.set(s, main.currentContext());
+			Context.push(s, main.currentContext());
 			completionSignal.subscribe(s);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -25,7 +25,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
+
 import javax.annotation.Nullable;
 
 /**
@@ -225,7 +225,7 @@ public void onComplete() {
 
 		@Override
 		public void subscribe(Subscriber<? super Throwable> s, Context ctx) {
-			ContextRelay.set(s, main.currentContext());
+			Context.push(s, main.currentContext());
 			completionSignal.subscribe(s);
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -33,7 +33,6 @@
 import reactor.core.publisher.FluxBufferPredicate.Mode;
 import javax.annotation.Nullable;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
 
 /**
  * Cut a sequence into non-overlapping windows where each window boundary is determined by
@@ -764,7 +763,7 @@ public void onComplete() {
 		@Override
 		public void subscribe(Subscriber<? super T> s, Context ctx) {
 			if (once == 0 && ONCE.compareAndSet(this, 0, 1)) {
-				ContextRelay.set(s, context);
+				Context.push(s, context);
 				s.onSubscribe(this);
 				ACTUAL.lazySet(this, s);
 				drain();

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java
Patch:
@@ -27,7 +27,6 @@
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
 
 /**
  * WindowTimeoutSubscriber is forwarding events on a steam until {@code maxSize} is reached,
@@ -100,7 +99,7 @@ public void onComplete() {
 
 		@Override
 		public void subscribe(Subscriber<? super T> s, Context ctx) {
-			ContextRelay.set(s, context);
+			Context.push(s, context);
 			processor.subscribe(s, ctx);
 		}
 

File: reactor-core/src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -35,7 +35,7 @@
 
 
 /**
- * A set of overridable lifecycle hooks that can be used for cross-cutting
+ * A push of overridable lifecycle hooks that can be used for cross-cutting
  * added behavior on {@link Flux}/{@link Mono} operators.
  */
 public abstract class Hooks {

File: reactor-core/src/main/java/reactor/core/publisher/InnerConsumer.java
Patch:
@@ -16,8 +16,7 @@
 package reactor.core.publisher;
 
 import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
-import reactor.util.context.ContextRelay;
+import reactor.util.context.Contextualized;
 import reactor.core.Scannable;
 
 /**
@@ -29,5 +28,5 @@
  * @author Stephane Maldini
  */
 interface InnerConsumer<I>
-		extends ContextRelay, Subscriber<I>, Scannable {
+		extends Contextualized, Subscriber<I>, Scannable {
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -25,7 +25,7 @@
 import reactor.util.context.Context;
 
 /**
- * Given a set of source Publishers the values of that Publisher is forwarded to the
+ * Given a push of source Publishers the values of that Publisher is forwarded to the
  * actual which responds first with any signal.
  *
  * @param <T> the value type

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -32,7 +32,7 @@
 
 /**
  * Concatenates a several Mono sources with a final Mono source by
- * ignoring values from the first set of sources and emitting the value
+ * ignoring values from the first push of sources and emitting the value
  * the last Mono source generates.
  *
  * @param <T> the final value type
@@ -60,7 +60,7 @@ public void subscribe(Subscriber<? super T> s, Context ctx) {
      * Shifts the current last Mono into the ignore array and sets up a new last Mono instance.
      * @param <U> the new last value type
      * @param newLast the new last Mono instance
-     * @return the new operator set up
+     * @return the new operator push up
      */
     <U> MonoIgnoreThen<U> shift(Mono<U> newLast) {
         Objects.requireNonNull(newLast, "newLast");

File: reactor-core/src/main/java/reactor/core/publisher/MutableNextSignal.java
Patch:
@@ -32,7 +32,7 @@
 public class MutableNextSignal<T> extends Signal<T> {
 
 	/**
-	 * Create a new {@link MutableNextSignal} that hasn't had a value set yet.
+	 * Create a new {@link MutableNextSignal} that hasn't had a value push yet.
 	 *
 	 * @param <T> the type of the onNext elements.
 	 * @return a new mutable next {@link Signal}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -39,7 +39,6 @@
 import reactor.util.Logger;
 import reactor.util.concurrent.QueueSupplier;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
 
 import javax.annotation.Nullable;
 
@@ -203,7 +202,7 @@ public final ParallelFlux<T> checkpoint(String description) {
 	 * It should be placed towards the end of the reactive chain, as errors
 	 * triggered downstream of it cannot be observed and augmented with assembly marker.
 	 *
-	 * @param description a description (must be unique enough if forceStackTrace is set
+	 * @param description a description (must be unique enough if forceStackTrace is push
 	 * to false).
 	 * @param forceStackTrace false to make a light checkpoint without a stacktrace, true
 	 * to use a stack trace.
@@ -1014,7 +1013,7 @@ public final void subscribe(Subscriber<? super T> s) {
 		s = Operators.onNewSubscriber(this, s);
 		sequential().subscribe(
 				new FluxHide.SuppressFuseableSubscriber<>(s),
-				ContextRelay.getOrEmpty(s));
+				Context.from(s));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -24,7 +24,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.context.Context;
-import reactor.util.context.ContextRelay;
+
 import javax.annotation.Nullable;
 
 /**
@@ -106,7 +106,7 @@ public Integer key() {
 		public void subscribe(Subscriber<? super T> s, Context context) {
 			if (ONCE.compareAndSet(this, 0, 1)) {
 				this.actual = s;
-				ContextRelay.set(s, ctx);
+				Context.push(s, ctx);
 				s.onSubscribe(this);
 			} else {
 				Operators.error(s, new IllegalStateException("This ParallelGroup can be subscribed to at most once."));

File: reactor-core/src/main/java/reactor/core/publisher/SignalPeek.java
Patch:
@@ -112,7 +112,7 @@ default Consumer<? super Context> onContextPropagateCall(){
 	 * @return A task that will run on {@link Context} propagation from upstream to downstream
 	 */
 	@Nullable
-	default Consumer<? super Context> onContextParentCall(){
+	default Consumer<? super Context> onCurrentContextCall(){
 		return null;
 	}
 }

File: reactor-core/src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -44,7 +44,7 @@
  * The maximum number of created thread pools is unbounded.
  * <p>
  * The default time-to-live for unused thread pools is 60 seconds, use the
- * appropriate constructor to set a different value.
+ * appropriate constructor to push a different value.
  * <p>
  * This scheduler is not restartable (may be later).
  *

File: reactor-core/src/main/java/reactor/util/concurrent/OpenHashSet.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.function.Consumer;
 
 /**
- * A simple open hash set with add, remove and clear capabilities only.
+ * A simple open hash push with add, remove and clear capabilities only.
  * <p>Doesn't support nor checks for {@code null}s.
  *
  * @param <T> the element type

File: reactor-core/src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -263,7 +263,7 @@ public void scanMain() {
 		FluxCombineLatest.CombineLatestCoordinator<String, Integer> test = new FluxCombineLatest.CombineLatestCoordinator<>(
 				actual, arr -> { throw new IllegalStateException("boomArray");}, 123, QueueSupplier.<FluxCombineLatest.SourceAndArray>one().get(), 456);
 		test.request(2L);
-		test.error = new IllegalStateException("boom"); //most straightforward way to set it as otherwise it is drained
+		test.error = new IllegalStateException("boom"); //most straightforward way to push it as otherwise it is drained
 
 		assertThat(test.scan(Scannable.LongAttr.REQUESTED_FROM_DOWNSTREAM)).isEqualTo(2L);
 		assertThat(test.scan(Scannable.ScannableAttr.ACTUAL)).isSameAs(actual);

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -822,7 +822,7 @@ public void scanConcatMapImmediate() {
 		assertThat(test.scan(Scannable.ScannableAttr.ACTUAL)).isSameAs(actual);
 
 		assertThat(test.scan(Scannable.BooleanAttr.TERMINATED)).isFalse();
-//		test.onError(new IllegalStateException("boom")); //TODO should the operator set done = true in onError?
+//		test.onError(new IllegalStateException("boom")); //TODO should the operator push done = true in onError?
 		test.onComplete();
 		assertThat(test.scan(Scannable.BooleanAttr.TERMINATED)).isTrue();
 

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -306,7 +306,7 @@ public final void sequenceOfNextAndError() {
 	//common n unused item or dropped
 	protected final I item(int i) {
 		if (defaultScenario.producingMapper == null) {
-			throw Exceptions.bubble(new Exception("No producer set in " + "defaultScenario"));
+			throw Exceptions.bubble(new Exception("No producer push in " + "defaultScenario"));
 		}
 		return defaultScenario.producingMapper
 		                      .apply(i);
@@ -315,14 +315,14 @@ protected final I item(int i) {
 	//unprocessable exception (dropped)
 	protected final RuntimeException droppedException() {
 		if (defaultScenario.droppedError == null) {
-			throw Exceptions.bubble(new Exception("No dropped exception set in " + "defaultScenario"));
+			throw Exceptions.bubble(new Exception("No dropped exception push in " + "defaultScenario"));
 		}
 		return defaultScenario.droppedError;
 	}
 
 	protected final RuntimeException exception() {
 		if (defaultScenario.producerError == null) {
-			throw Exceptions.bubble(new Exception("No exception set in " + "defaultScenario"));
+			throw Exceptions.bubble(new Exception("No exception push in " + "defaultScenario"));
 		}
 		return defaultScenario.producerError;
 	}

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -273,7 +273,7 @@ static <T> FirstStep<T> withVirtualTime(
 
 	/**
 	 * Verify the signals received by this subscriber. Unless a default timeout has been
-	 * set before construction of the {@link StepVerifier} via {@link StepVerifier#setDefaultTimeout(Duration),
+	 * push before construction of the {@link StepVerifier} via {@link StepVerifier#setDefaultTimeout(Duration),
 	 * this method will <strong>block</strong> until the stream has been terminated
 	 * (either through {@link Subscriber#onComplete()}, {@link Subscriber#onError(Throwable)} or
 	 * {@link Subscription#cancel()}). Depending on the declared expectations and actions,

File: reactor-test/src/main/java/reactor/test/StepVerifierOptions.java
Patch:
@@ -33,7 +33,7 @@ public class StepVerifierOptions {
 	private Supplier<? extends VirtualTimeScheduler> vtsLookup = null;
 
 	/**
-	 * Create a new default set of options for a {@link StepVerifier} that can be tuned
+	 * Create a new default push of options for a {@link StepVerifier} that can be tuned
 	 * using the various available non-getter methods (which can be chained).
 	 */
 	public static StepVerifierOptions create() {

File: reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java
Patch:
@@ -52,7 +52,7 @@ public static <T> TestPublisher<T> create() {
 
 	/**
 	 * Create a {@link Violation noncompliant} {@link TestPublisher}
-	 * with a given set of reactive streams spec violations that will be overlooked.
+	 * with a given push of reactive streams spec violations that will be overlooked.
 	 *
 	 * @param first the first allowed {@link Violation}
 	 * @param rest additional optional violations
@@ -147,7 +147,7 @@ public static <T> TestPublisher<T> createNoncompliant(Violation first, Violation
 	/**
 	 * Send 1 {@link Subscriber#onNext(Object) onNext} signal to the subscribers.
 	 *
-	 * @param value the item to emit (can be null if the relevant {@link Violation} is set)
+	 * @param value the item to emit (can be null if the relevant {@link Violation} is push)
 	 * @return this {@link TestPublisher} for chaining.
 	 */
 	public abstract TestPublisher<T> next(@Nullable T value);

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -59,7 +59,7 @@ public static VirtualTimeScheduler create() {
 	 * factories. While the method is thread safe, its usually advised to execute such
 	 * wide-impact BEFORE all tested code runs (setup etc). The created scheduler is returned.
 	 *
-	 * @return the VirtualTimeScheduler that was created and set through the factory
+	 * @return the VirtualTimeScheduler that was created and push through the factory
 	 */
 	public static VirtualTimeScheduler getOrSet() {
 		return enable(VirtualTimeScheduler::new, false);
@@ -129,7 +129,7 @@ static VirtualTimeScheduler enable(Supplier<VirtualTimeScheduler>
 			}
 			VirtualTimeScheduler newS = schedulerSupplier.get();
 			if (newS == CURRENT.get()) {
-				return newS; //nothing to do, it has already been set in the past
+				return newS; //nothing to do, it has already been push in the past
 			}
 
 			if (CURRENT.compareAndSet(s, newS)) {

File: reactor-test/src/test/java/reactor/test/StepVerifierTests.java
Patch:
@@ -1239,7 +1239,7 @@ public void noCancelOnErrorWhenCollectUnexpected() {
 	}
 
 	//TODO records: find a way to test the case where supplied collection is null, and signal is complete/error
-	//TODO records: find a way to test the case where there hasn't been a recorder set, and signal is complete/error
+	//TODO records: find a way to test the case where there hasn't been a recorder push, and signal is complete/error
 
 	@Test
 	public void cancelOnUnexpectedNextWithMoreData() {

File: reactor-core/src/main/java/reactor/adapter/JdkFlowAdapter.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
+import reactor.util.context.Context;
 
 /**
  * Convert a Java 9+ {@literal Flow.Publisher} to/from a Reactive Streams {@link Publisher}.
@@ -62,7 +63,7 @@ private FlowPublisherAsFlux(java.util.concurrent.Flow.Publisher<T> pub) {
         }
 
         @Override
-        public void subscribe(final Subscriber<? super T> s) {
+        public void subscribe(final Subscriber<? super T> s, Context ctx) {
         	pub.subscribe(new SubscriberToRS<>(s));
         }
     }

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFlux.java
Patch:
@@ -158,7 +158,7 @@ public final Flux<T> refCount(int minSubscribers) {
 	 * @return a reference counting {@link Flux} with a grace period for disconnection
 	 */
 	public final Flux<T> refCount(int minSubscribers, Duration gracePeriod) {
-		return refCount(minSubscribers, gracePeriod, Schedulers.elastic());
+		return refCount(minSubscribers, gracePeriod, Schedulers.parallel());
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -24,6 +24,7 @@
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Captures the current stacktrace when this connectable publisher is created and
@@ -57,8 +58,8 @@ final class ConnectableFluxOnAssembly<T> extends ConnectableFlux<T> implements
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
-		FluxOnAssembly.subscribe(s, source, stacktrace);
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
+		FluxOnAssembly.subscribe(s, source, stacktrace, ctx);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -28,6 +28,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.util.concurrent.QueueSupplier;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 import static reactor.core.publisher.FluxPublish.PublishSubscriber.EMPTY;
@@ -225,7 +226,7 @@ public Stream<? extends Scannable> inners() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		//noinspection ConstantConditions
 		if (s == null) {
 			throw Exceptions.argumentIsNullException();

File: reactor-core/src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -54,7 +55,7 @@ public static <T> void subscribe(Subscriber<? super T> s, T[] array) {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		subscribe(s, array);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -19,10 +19,10 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -56,8 +56,8 @@ final class FluxAutoConnect<T> extends Flux<T>
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
-		source.subscribe(s);
+	public void subscribe(Subscriber<? super T> s, Context context) {
+		source.subscribe(s, context);
 		if (remaining > 0 && REMAINING.decrementAndGet(this) == 0) {
 			source.connect(cancelSupport);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -57,8 +57,8 @@ final class FluxAutoConnectFuseable<T> extends Flux<T>
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
-		source.subscribe(s);
+	public void subscribe(Subscriber<? super T> s, Context context) {
+		source.subscribe(s, context);
 		if (remaining > 0 && REMAINING.decrementAndGet(this) == 0) {
 			source.connect(cancelSupport);
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 
 
 /**
@@ -37,7 +38,7 @@ final class FluxCallable<T> extends Flux<T> implements Callable<T>, Fuseable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		Operators.MonoSubscriber<T, T> wrapper = new Operators.MonoSubscriber<>(s);
 		s.onSubscribe(wrapper);
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -37,7 +38,7 @@ private FluxEmpty() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super Object> s) {
+	public void subscribe(Subscriber<? super Object> s, Context context) {
 		Operators.complete(s);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import org.reactivestreams.Subscriber;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -41,7 +42,7 @@ final class FluxError<T> extends Flux<T> {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		if (whenRequested) {
 			s.onSubscribe(new ErrorSubscription(s, error));
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -70,7 +71,7 @@ final class FluxGenerate<T, S>
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		S state;
 
 		try {

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -24,6 +24,8 @@
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.context.Context;
+
 import javax.annotation.Nullable;
 
 /**
@@ -56,7 +58,7 @@ final class FluxInterval extends Flux<Long> {
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super Long> s) {
+	public void subscribe(Subscriber<? super Long> s, Context context) {
 		Worker w = timedScheduler.createWorker();
 
 		IntervalRunnable r = new IntervalRunnable(s, w);

File: reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -40,7 +41,7 @@ final class FluxIterable<T> extends Flux<T> implements Fuseable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		Iterator<? extends T> it;
 
 		try {

File: reactor-core/src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -63,7 +64,7 @@ public T call() {
 	}
 
 	@Override
-	public void subscribe(final Subscriber<? super T> subscriber) {
+	public void subscribe(final Subscriber<? super T> subscriber, Context context) {
 		subscriber.onSubscribe(new WeakScalarSubscription<>(value, subscriber));
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxMerge.java
Patch:
@@ -22,7 +22,7 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-
+import reactor.util.context.Context;
 
 /**
  * Merges a fixed array of Publishers.
@@ -62,7 +62,7 @@ final class FluxMerge<T> extends Flux<T> {
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		FluxFlatMap.FlatMapMain<Publisher<? extends T>, T> merger = new FluxFlatMap.FlatMapMain<>(
 				s, identityFunction(), delayError, maxConcurrency, mainQueueSupplier, prefetch,
 				innerQueueSupplier);

File: reactor-core/src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-
+import reactor.util.context.Context;
 
 /**
  * Represents an never publisher which only calls onSubscribe.
@@ -37,7 +37,7 @@ final class FluxNever
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super Object> s) {
+	public void subscribe(Subscriber<? super Object> s, Context context) {
 		s.onSubscribe(Operators.emptySubscription());
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -32,6 +32,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -101,7 +102,7 @@ public void connect(Consumer<? super Disposable> cancelSupport) {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		PublishInner<T> inner = new PublishInner<>(s);
 		s.onSubscribe(inner);
 		for (; ; ) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Emits a range of integer values.
@@ -48,7 +49,7 @@ final class FluxRange extends Flux<Integer>
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public void subscribe(Subscriber<? super Integer> s) {
+	public void subscribe(Subscriber<? super Integer> s, Context context) {
 		long st = start;
 		long en = end;
 		if (st == en) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -34,6 +34,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.util.concurrent.QueueSupplier;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -1031,7 +1032,7 @@ public void connect(Consumer<? super Disposable> cancelSupport) {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		ReplayInner<T> inner = new ReplayInner<>(s);
 		for (; ; ) {
 			ReplaySubscriber<T> c = connection;

File: reactor-core/src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -22,7 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
-
+import reactor.util.context.Context;
 
 /**
  * Emits the contents of a Stream source.
@@ -40,7 +40,7 @@ final class FluxStream<T> extends Flux<T> implements Fuseable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		Iterator<? extends T> it;
 
 		try {

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -33,7 +34,7 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxSubscribeOn<T> extends FluxSource<T, T> {
+final class FluxSubscribeOn<T> extends FluxOperator<T, T> {
 
 	final Scheduler scheduler;
 	
@@ -46,7 +47,7 @@ final class FluxSubscribeOn<T> extends FluxSource<T, T> {
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		Worker worker;
 		
 		try {

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -26,6 +26,7 @@
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Executes a Callable and emits its value on the given Scheduler.
@@ -45,7 +46,7 @@ final class FluxSubscribeOnCallable<T> extends Flux<T> implements Fuseable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		CallableSubscribeOnSubscription<T> parent =
 				new CallableSubscribeOnSubscription<>(s, callable, scheduler);
 		s.onSubscribe(parent);

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -25,6 +25,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Publisher indicating a scalar/empty source that subscribes on the specified scheduler.
@@ -45,7 +46,7 @@ final class FluxSubscribeOnValue<T> extends Flux<T> implements Fuseable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		T v = value;
 		if (v == null) {
 			ScheduledEmpty parent = new ScheduledEmpty(s);

File: reactor-core/src/main/java/reactor/core/publisher/InnerConsumer.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.util.context.ContextRelay;
 import reactor.core.Scannable;
 
 /**
@@ -28,5 +29,5 @@
  * @author Stephane Maldini
  */
 interface InnerConsumer<I>
-		extends Subscriber<I>, Scannable {
+		extends ContextRelay, Subscriber<I>, Scannable {
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -43,7 +44,7 @@ final class MonoCallable<T>
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 
 		Operators.MonoSubscriber<T, T>
 				sds = new Operators.MonoSubscriber<>(s);

File: reactor-core/src/main/java/reactor/core/publisher/MonoCompletionStage.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
-
+import reactor.util.context.Context;
 
 /**
  * Emits the value or error produced by the wrapped CompletionStage.
@@ -41,7 +41,7 @@ final class MonoCompletionStage<T>
     }
 
     @Override
-    public void subscribe(Subscriber<? super T> s) {
+    public void subscribe(Subscriber<? super T> s, Context context) {
         Operators.MonoSubscriber<T, T>
                 sds = new Operators.MonoSubscriber<>(s);
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -24,6 +24,7 @@
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Emits a single 0L value delayed by some time amount with a help of
@@ -46,7 +47,7 @@ final class MonoDelay extends Mono<Long> {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super Long> s) {
+	public void subscribe(Subscriber<? super Long> s, Context context) {
 		MonoDelayRunnable r = new MonoDelayRunnable(s);
 
 		s.onSubscribe(r);

File: reactor-core/src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Represents an empty publisher which only calls onSubscribe and onComplete.
@@ -41,7 +42,7 @@ final class MonoEmpty
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super Object> s) {
+	public void subscribe(Subscriber<? super Object> s, Context context) {
 		Operators.complete(s);
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Exceptions;
+import reactor.util.context.Context;
 
 
 /**
@@ -47,7 +48,7 @@ public T block() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		Operators.error(s, Operators.onOperatorError(error));
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import javax.annotation.Nullable;
+import reactor.util.context.Context;
 
 /**
  * Given a set of source Publishers the values of that Publisher is forwarded to the
@@ -64,7 +65,7 @@ Mono<T> orAdditionalSource(Mono<? extends T> other) {
 	@SuppressWarnings("unchecked")
 	@Override
 	//TODO mutualize with FluxFirstEmitting
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		Publisher<? extends T>[] a = array;
 		int n;
 		if (a == null) {
@@ -139,7 +140,7 @@ public void subscribe(Subscriber<? super T> s) {
 		}
 
 		FluxFirstEmitting.RaceCoordinator<T> coordinator =
-				new FluxFirstEmitting.RaceCoordinator<>(n);
+				new FluxFirstEmitting.RaceCoordinator<>(n, ctx);
 
 		coordinator.subscribe(a, n, s);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
@@ -50,7 +51,7 @@ public T block() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		s.onSubscribe(Operators.scalarSubscription(s, value));
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.publisher;
 
 import org.reactivestreams.Subscriber;
-
+import reactor.util.context.Context;
 
 /**
  * Represents an never publisher which only calls onSubscribe.
@@ -36,7 +36,7 @@ final class MonoNever
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super Object> s) {
+	public void subscribe(Subscriber<? super Object> s, Context context) {
 		s.onSubscribe(Operators.emptySubscription());
 	}
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.concurrent.Callable;
 
 import org.reactivestreams.Subscriber;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -35,7 +36,7 @@ final class MonoRunnable extends Mono<Void> implements Callable<Void> {
     }
 
     @Override
-    public void subscribe(Subscriber<? super Void> s) {
+    public void subscribe(Subscriber<? super Void> s, Context context) {
         try {
             run.run();
         } catch (Throwable ex) {

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -33,7 +34,7 @@
  *
  * @param <T> the value type
  */
-final class MonoSubscribeOn<T> extends MonoSource<T, T> {
+final class MonoSubscribeOn<T> extends MonoOperator<T, T> {
 
 	final Scheduler scheduler;
 
@@ -43,7 +44,7 @@ final class MonoSubscribeOn<T> extends MonoSource<T, T> {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		Scheduler.Worker worker = scheduler.createWorker();
 
 		SubscribeOnSubscriber<T> parent = new SubscribeOnSubscriber<>(source, s, worker);

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -23,6 +23,7 @@
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.context.Context;
 
 
 /**
@@ -43,7 +44,7 @@ final class MonoSubscribeOnCallable<T> extends Mono<T> implements Fuseable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		FluxSubscribeOnCallable.CallableSubscribeOnSubscription<T> parent =
 				new FluxSubscribeOnCallable.CallableSubscribeOnSubscription<>(s, callable, scheduler);
 		s.onSubscribe(parent);

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -23,6 +23,7 @@
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledEmpty;
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar;
 import reactor.core.scheduler.Scheduler;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -42,7 +43,7 @@ final class MonoSubscribeOnValue<T> extends Mono<T> {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context context) {
 		T v = value;
 		if (v == null) {
 			ScheduledEmpty parent = new ScheduledEmpty(s);

File: reactor-core/src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.util.context.Context;
 
 /**
  * Executes a Supplier function and emits a single value to each individual Subscriber.
@@ -40,7 +41,7 @@ final class MonoSupplier<T>
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 
 		Operators.MonoSubscriber<T, T>
 				sds = new Operators.MonoSubscriber<>(s);

File: reactor-core/src/main/java/reactor/core/publisher/ParallelArraySource.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
+import reactor.util.context.Context;
 
 /**
  * Wraps multiple Publishers into a ParallelFlux which runs them
@@ -41,15 +42,15 @@ public int parallelism() {
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super T>[] subscribers) {
+	public void subscribe(Subscriber<? super T>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
 		
 		int n = subscribers.length;
 		
 		for (int i = 0; i < n; i++) {
-			sources[i].subscribe(subscribers[i]);
+			Operators.contextual(sources[i]).subscribe(subscribers[i], ctx);
 		}
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -63,7 +64,7 @@ public int getPrefetch() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super C>[] subscribers) {
+	public void subscribe(Subscriber<? super C>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -89,7 +90,7 @@ public void subscribe(Subscriber<? super C>[] subscribers) {
 					collector);
 		}
 
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 
 	void reportError(Subscriber<?>[] subscribers, Throwable ex) {

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -54,7 +55,7 @@ public Object scanUnsafe(Attr key) {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T>[] subscribers) {
+	public void subscribe(Subscriber<? super T>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -66,6 +67,6 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 			parents[i] = new FluxHide.HideSubscriber<>(subscribers[i]);
 		}
 
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 }

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -21,6 +21,7 @@
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblyLightSnapshotException;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -86,7 +87,7 @@ public int parallelism() {
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public void subscribe(Subscriber<? super T>[] subscribers) {
+	public void subscribe(Subscriber<? super T>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -110,7 +111,7 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 			parents[i] = s;
 		}
 
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -38,7 +39,7 @@ final class ParallelLog<T> extends ParallelFlux<T> implements Scannable {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T>[] subscribers) {
+	public void subscribe(Subscriber<? super T>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -51,7 +52,7 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 			parents[i] = new FluxPeek.PeekSubscriber<>(subscribers[i], log);
 		}
 		
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -63,7 +64,7 @@ final class ParallelPeek<T> extends ParallelFlux<T> implements SignalPeek<T>{
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T>[] subscribers) {
+	public void subscribe(Subscriber<? super T>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -76,7 +77,7 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 			parents[i] = new FluxPeek.PeekSubscriber<>(subscribers[i], this);
 		}
 		
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -64,7 +65,7 @@ public int getPrefetch() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super R>[] subscribers) {
+	public void subscribe(Subscriber<? super R>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -88,7 +89,7 @@ public void subscribe(Subscriber<? super R>[] subscribers) {
 					new ParallelReduceSeedSubscriber<>(subscribers[i], initialValue, reducer);
 		}
 
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 
 	void reportError(Subscriber<?>[] subscribers, Throwable ex) {

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -23,6 +23,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -60,7 +61,7 @@ public Object scanUnsafe(Attr key) {
 	}
 	
 	@Override
-	public void subscribe(Subscriber<? super T>[] subscribers) {
+	public void subscribe(Subscriber<? super T>[] subscribers, Context ctx) {
 		if (!validate(subscribers)) {
 			return;
 		}
@@ -81,7 +82,7 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 			parents[i] = parent;
 		}
 		
-		source.subscribe(parents);
+		source.subscribe(parents, ctx);
 	}
 
 	@Override

File: reactor-core/src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -28,9 +28,11 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import reactor.core.scheduler.Schedulers;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
 import reactor.util.concurrent.QueueSupplier;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 import static reactor.core.publisher.FluxReplay.ReplaySubscriber.EMPTY;
@@ -304,7 +306,7 @@ public static <T> ReplayProcessor<T> createSizeAndTimeout(int size,
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		//noinspection ConstantConditions
 		if (s == null) {
 			throw Exceptions.argumentIsNullException();

File: reactor-core/src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -30,6 +30,7 @@
 import reactor.core.Exceptions;
 import reactor.util.concurrent.QueueSupplier;
 import reactor.util.concurrent.WaitStrategy;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -912,7 +913,7 @@ public static <E> TopicProcessor<E> share(ExecutorService service,
 	}
 
 	@Override
-	public void subscribe(final Subscriber<? super E> subscriber) {
+	public void subscribe(final Subscriber<? super E> subscriber, Context ctx) {
 		//noinspection ConstantConditions
 		if (subscriber == null) {
 			throw Exceptions.argumentIsNullException();

File: reactor-core/src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -28,6 +28,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.util.concurrent.QueueSupplier;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -430,7 +431,7 @@ public void onComplete() {
 	}
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context ctx) {
 		//noinspection ConstantConditions
 		if (s == null) {
 			throw Exceptions.argumentIsNullException();

File: reactor-core/src/main/java/reactor/core/publisher/WorkQueueProcessor.java
Patch:
@@ -36,6 +36,7 @@
 import reactor.util.Loggers;
 import reactor.util.concurrent.QueueSupplier;
 import reactor.util.concurrent.WaitStrategy;
+import reactor.util.context.Context;
 import javax.annotation.Nullable;
 
 /**
@@ -803,7 +804,7 @@ public static <E> WorkQueueProcessor<E> share(ExecutorService executor,
 	}
 
 	@Override
-	public void subscribe(final Subscriber<? super E> subscriber) {
+	public void subscribe(final Subscriber<? super E> subscriber, Context ctx) {
 		//noinspection ConstantConditions
 		if (subscriber == null) {
 			throw Exceptions.argumentIsNullException();

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -31,6 +31,7 @@
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.concurrent.QueueSupplier;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -777,7 +778,7 @@ public void prefetchMaxTranslatesToUnboundedRequest2() {
 	public void scanConcatMapDelayed() {
 		Subscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		FluxConcatMap.ConcatMapDelayed<String, Integer> test = new FluxConcatMap.ConcatMapDelayed<>(
-				actual, s -> Mono.just(s.length()), QueueSupplier.one(), 123, true);
+				actual, s -> Mono.just(s.length()), QueueSupplier.one(), 123, true, Context.empty());
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
@@ -805,7 +806,7 @@ public void scanConcatMapDelayed() {
 	public void scanConcatMapImmediate() {
 		Subscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
 		FluxConcatMap.ConcatMapImmediate<String, Integer> test = new FluxConcatMap.ConcatMapImmediate<>(
-				actual, s -> Mono.just(s.length()), QueueSupplier.one(), 123);
+				actual, s -> Mono.just(s.length()), QueueSupplier.one(), 123, Context.empty());
 
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxDelaySubscriptionTest.java
Patch:
@@ -25,6 +25,7 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -216,7 +217,7 @@ public void scanMainSubscriber() {
 				sub -> sub.request(100));
 		Flux<String> source = Flux.just("foo", "bar");
 		FluxDelaySubscription.DelaySubscriptionOtherSubscriber<String, Integer> arbiter = new FluxDelaySubscription.DelaySubscriptionOtherSubscriber<String, Integer>(
-				actual, source);
+				actual, source, Context.empty());
 		FluxDelaySubscription.DelaySubscriptionMainSubscriber<String> test = new FluxDelaySubscription.DelaySubscriptionMainSubscriber<String>(
 				actual, arbiter);
 
@@ -229,7 +230,7 @@ public void scanOtherSubscriber() {
 				sub -> sub.request(100));
 		Flux<String> source = Flux.just("foo", "bar");
 		FluxDelaySubscription.DelaySubscriptionOtherSubscriber<String, Integer> test = new FluxDelaySubscription.DelaySubscriptionOtherSubscriber<String, Integer>(
-				actual, source);
+				actual, source, Context.empty());
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxFirstEmittingTest.java
Patch:
@@ -26,6 +26,7 @@
 
 import reactor.core.Scannable;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.util.context.Context;
 
 public class FluxFirstEmittingTest {
 
@@ -145,7 +146,7 @@ public void iterableOneIsNullSource() {
     @Test
     public void scanSubscriber() {
         Subscriber<String> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-        FluxFirstEmitting.RaceCoordinator<String> parent = new FluxFirstEmitting.RaceCoordinator<>(1);
+        FluxFirstEmitting.RaceCoordinator<String> parent = new FluxFirstEmitting.RaceCoordinator<>(1, Context.empty());
         FluxFirstEmitting.FirstEmittingSubscriber<String> test = new FluxFirstEmitting.FirstEmittingSubscriber<>(actual, parent, 1);
         Subscription sub = Operators.emptySubscription();
         test.onSubscribe(sub);
@@ -160,7 +161,7 @@ public void scanSubscriber() {
     @Test
     public void scanRaceCoordinator() {
         Subscriber<String> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-        FluxFirstEmitting.RaceCoordinator<String> parent = new FluxFirstEmitting.RaceCoordinator<>(1);
+        FluxFirstEmitting.RaceCoordinator<String> parent = new FluxFirstEmitting.RaceCoordinator<>(1, Context.empty());
         FluxFirstEmitting.FirstEmittingSubscriber<String> test = new FluxFirstEmitting.FirstEmittingSubscriber<>(actual, parent, 1);
         Subscription sub = Operators.emptySubscription();
         test.onSubscribe(sub);

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -504,7 +504,7 @@ public void asyncFusionAvailable() {
 	public void conditionalFusionAvailable() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
-		FluxSource.wrap(u -> {
+		Flux.from(u -> {
 			if (!(u instanceof Fuseable.ConditionalSubscriber)) {
 				Operators.error(u,
 						new IllegalArgumentException("The subscriber is not conditional: " + u));

File: reactor-core/src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -29,6 +29,7 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -320,7 +321,7 @@ public void exponentialRetry() {
     public void scanMainSubscriber() {
         Subscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxRetryWhen.RetryWhenMainSubscriber<Integer> test =
-        		new FluxRetryWhen.RetryWhenMainSubscriber<>(actual, null, Flux.empty());
+        		new FluxRetryWhen.RetryWhenMainSubscriber<>(actual, null, Flux.empty(), Context.empty());
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);
 
@@ -338,7 +339,7 @@ public void scanMainSubscriber() {
     public void scanOtherSubscriber() {
 		Subscriber<Integer> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxRetryWhen.RetryWhenMainSubscriber<Integer> main =
-        		new FluxRetryWhen.RetryWhenMainSubscriber<>(actual, null, Flux.empty());
+        		new FluxRetryWhen.RetryWhenMainSubscriber<>(actual, null, Flux.empty(), Context.empty());
         FluxRetryWhen.RetryWhenOtherSubscriber test = new FluxRetryWhen.RetryWhenOtherSubscriber();
         test.main = main;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowTimeOrSizeTest.java
Patch:
@@ -31,6 +31,8 @@
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
+import reactor.util.context.Context;
+
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class FluxWindowTimeOrSizeTest {
@@ -208,7 +210,7 @@ public void dispose() {
     public void scanMainSubscriber() {
         Subscriber<Flux<Integer>> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
         FluxWindowTimeOrSize.WindowTimeoutSubscriber<Integer> test = new FluxWindowTimeOrSize.WindowTimeoutSubscriber<>(actual,
-        		123, 1000, Schedulers.single());
+        		123, 1000, Schedulers.single(), Context.empty());
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/LambdaMonoSubscriberTest.java
Patch:
@@ -186,7 +186,7 @@ public void onNextConsumerFatalDoesntTriggerCancellation() {
 
 	@Test
 	public void emptyMonoState(){
-		assertTrue(MonoSource.wrap(s -> {
+		assertTrue(Mono.fromDirect(s -> {
 			assertTrue(s instanceof LambdaMonoSubscriber);
 			LambdaMonoSubscriber<?> bfs = (LambdaMonoSubscriber<?>)s;
 			assertTrue(bfs.scan(Scannable.IntAttr.PREFETCH) == Integer.MAX_VALUE);
@@ -207,7 +207,7 @@ public void errorMonoState(){
 		Hooks.onErrorDropped(e -> assertTrue(e.getMessage().equals("test2")));
 		Hooks.onNextDropped(d -> assertTrue(d.equals("test2")));
 		try {
-			MonoSource.wrap(s -> {
+			Mono.fromDirect(s -> {
 				assertTrue(s instanceof LambdaMonoSubscriber);
 				LambdaMonoSubscriber<?> bfs = (LambdaMonoSubscriber<?>) s;
 				Operators.error(s, new Exception("test"));

File: reactor-core/src/test/java/reactor/core/publisher/MonoDelayUntilTest.java
Patch:
@@ -29,6 +29,7 @@
 import reactor.core.Disposable;
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoPeekAfterTest.java
Patch:
@@ -550,7 +550,7 @@ public void testCallbacksFusionSync() {
 		AtomicReference<Integer> afterTerminateInvocation = new AtomicReference<>();
 		AtomicReference<Throwable> error = new AtomicReference<>();
 
-		Mono<Integer> source = MonoSource.wrap(Flux.range(55, 1));
+		Mono<Integer> source = Mono.fromDirect(Flux.range(55, 1));
 
 		Mono<Integer> mono = new MonoPeekTerminal<>(source,
 				successInvocation::set,

File: reactor-core/src/test/java/reactor/core/publisher/MonoSequenceEqualTest.java
Patch:
@@ -31,6 +31,7 @@
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 import reactor.util.concurrent.QueueSupplier;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -273,7 +274,7 @@ public void scanCoordinator() {
 						123,
 						Mono.just("foo"),
 						Mono.just("bar"),
-						(s1, s2) -> s1.equals(s2));
+						(s1, s2) -> s1.equals(s2), Context.empty());
 
 		assertThat(test.scan(Scannable.ScannableAttr.ACTUAL)).isSameAs(actual);
 		assertThat(test.scan(Scannable.BooleanAttr.CANCELLED)).isFalse();
@@ -289,7 +290,7 @@ public void scanSubscriber() {
 						123,
 						Mono.just("foo"),
 						Mono.just("bar"),
-						(s1, s2) -> s1.equals(s2));
+						(s1, s2) -> s1.equals(s2), Context.empty());
 
 		MonoSequenceEqual.EqualSubscriber<String> test = new MonoSequenceEqual.EqualSubscriber<>(
 				coordinator, 456);

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenIgnoreTest.java
Patch:
@@ -24,6 +24,7 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java
Patch:
@@ -34,6 +34,7 @@
 import reactor.core.publisher.Operators.MultiSubscriptionSubscriber;
 import reactor.core.publisher.Operators.ScalarSubscription;
 import reactor.test.RaceTestUtils;
+import reactor.util.context.Context;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -263,7 +264,7 @@ public void scanMonoSubscriber() {
 	@Test
 	public void scanMultiSubscriptionSubscriber() {
 		Subscriber<Integer> actual = new LambdaSubscriber<>(null, null, null, null);
-		MultiSubscriptionSubscriber<Integer, Integer> test = new MultiSubscriptionSubscriber<Integer, Integer>(actual) {
+		MultiSubscriptionSubscriber<Integer, Integer> test = new MultiSubscriptionSubscriber<Integer, Integer>(actual, Context.empty()) {
 			@Override
 			public void onNext(Integer t) {
 			}

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -965,6 +965,7 @@ final void resetHooks() {
 		Hooks.resetOnNextDropped();
 		Hooks.resetOnOperator();
 		Hooks.resetOnOperatorError();
+		Hooks.resetOnSubscriber();
 	}
 
 	final  void testPublisherSource(OperatorScenario<I, PI, O, PO> scenario, TestPublisher<I> ts) {

File: reactor-core/src/test/java/reactor/test/publisher/FluxEmptySyncFuseable.java
Patch:
@@ -20,14 +20,15 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Flux;
+import reactor.util.context.Context;
 
 /**
  * @author Stephane Maldini
  */
 final class FluxEmptySyncFuseable<T> extends Flux<T> implements Fuseable {
 
 	@Override
-	public void subscribe(Subscriber<? super T> s) {
+	public void subscribe(Subscriber<? super T> s, Context c) {
 		s.onSubscribe(new SynchronousSubscription<T>() {
 			@Override
 			@Nullable

File: reactor-core/src/test/java/reactor/test/publisher/MonoOperatorTest.java
Patch:
@@ -27,7 +27,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.MonoSource;
 import reactor.test.StepVerifier;
 
 /**
@@ -245,7 +244,7 @@ protected Mono<I> sourceCallable(OperatorScenario<I, Mono<I>, O, Mono<O>> scenar
 
 	@Override
 	protected Mono<I> withFluxSource(Flux<I> input) {
-		return MonoSource.wrap(input);
+		return Mono.fromDirect(input);
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -26,8 +26,6 @@
 import reactor.core.Scannable;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
-import reactor.util.function.Tuple2;
-import reactor.util.function.Tuples;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -24,8 +24,6 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.assertj.core.api.Assertions;
-import org.assertj.core.internal.Predicates;
 import org.junit.Assert;
 import org.junit.Test;
 import org.mockito.Mockito;

File: reactor-core/src/test/java/reactor/core/publisher/FluxRepeatTest.java
Patch:
@@ -17,7 +17,6 @@
 package reactor.core.publisher;
 
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
 import reactor.test.StepVerifier;

File: reactor-core/src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.assertj.core.api.Assertions;
-import org.assertj.core.api.SoftAssertions;
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;

File: reactor-core/src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -30,7 +30,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.LongAdder;
-import java.util.function.Supplier;
 
 import org.assertj.core.api.Assertions;
 import org.junit.Assert;

File: reactor-core/src/test/java/reactor/core/publisher/tck/AbstractProcessorVerification.java
Patch:
@@ -25,9 +25,7 @@
 import org.reactivestreams.tck.TestEnvironment;
 import org.testng.SkipException;
 import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
 import reactor.core.publisher.Flux;
-import reactor.core.scheduler.Schedulers;
 
 /**
  * @author Stephane Maldini

File: reactor-test/src/test/java/reactor/test/publisher/DefaultTestPublisherTests.java
Patch:
@@ -20,7 +20,6 @@
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Disposable;
 import reactor.core.publisher.Flux;
 import reactor.test.StepVerifier;
 import reactor.test.publisher.TestPublisher.Violation;

File: reactor-core/src/test/java/reactor/core/publisher/BlockingSingleSubscriberTest.java
Patch:
@@ -24,7 +24,7 @@
 
 public class BlockingSingleSubscriberTest {
 
-	BlockingSingleSubscriber test = new BlockingSingleSubscriber() {
+	BlockingSingleSubscriber<Object> test = new BlockingSingleSubscriber<Object>() {
 		@Override
 		public void onNext(Object o) { }
 

File: reactor-core/src/test/java/reactor/core/publisher/DelegateProcessorTest.java
Patch:
@@ -29,16 +29,16 @@ public class DelegateProcessorTest {
 
 	@Test
 	public void scanReturnsDownStreamForParentElseDelegates() {
-		Publisher downstream = Mockito.mock(Publisher.class);
+		Publisher<?> downstream = Mockito.mock(Publisher.class);
 
 		IllegalStateException boom = new IllegalStateException("boom");
-		InnerConsumer upstream = Mockito.mock(InnerConsumer.class);
+		InnerConsumer<?> upstream = Mockito.mock(InnerConsumer.class);
 		when(upstream.scanUnsafe(Scannable.ThrowableAttr.ERROR))
 				.thenReturn(boom);
 		when(upstream.scanUnsafe(Scannable.BooleanAttr.DELAY_ERROR))
 				.thenReturn(true);
 
-		DelegateProcessor processor = new DelegateProcessor(
+		DelegateProcessor<?, ?> processor = new DelegateProcessor<>(
 				downstream, upstream);
 
 		assertThat(processor.scan(Scannable.ScannableAttr.PARENT)).isSameAs(downstream);

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectFuseableTest.java
Patch:
@@ -26,6 +26,7 @@ public class FluxAutoConnectFuseableTest {
 
 	@Test
 	public void scanMain() {
+		@SuppressWarnings("unchecked")
 		ConnectableFlux<String> source = Mockito.mock(ConnectableFlux.class);
 		Mockito.when(source.getPrefetch()).thenReturn(888);
 		FluxAutoConnectFuseable<String> test = new FluxAutoConnectFuseable<>(source, 123, d -> { });

File: reactor-core/src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -81,6 +81,7 @@ public void connectAfterMany() {
 
 	@Test
 	public void scanMain() {
+		@SuppressWarnings("unchecked")
 		ConnectableFlux<String> source = Mockito.mock(ConnectableFlux.class);
 		Mockito.when(source.getPrefetch()).thenReturn(888);
 		FluxAutoConnect<String> test = new FluxAutoConnect<>(source, 123, d -> { });

File: reactor-core/src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -238,7 +238,9 @@ public void startWith(){
 	@Test
 	public void scanDelayErrorSubscriber() {
 		Subscriber<String> actual = new LambdaSubscriber<>(null, e -> {}, null, null);
-		FluxConcatArray.ConcatArrayDelayErrorSubscriber<String> test = new FluxConcatArray.ConcatArrayDelayErrorSubscriber<>(actual, new Publisher[0]);
+		@SuppressWarnings("unchecked")
+		Publisher<String>[] emptyPub = (Publisher<String>[]) new Publisher[0];
+		FluxConcatArray.ConcatArrayDelayErrorSubscriber<String> test = new FluxConcatArray.ConcatArrayDelayErrorSubscriber<>(actual, emptyPub);
 		Subscription parent = Operators.emptySubscription();
 		test.onSubscribe(parent);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java
Patch:
@@ -442,6 +442,7 @@ public void scanSubscriber() {
 
 	@Test
 	public void scanConditionalSubscriber() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		FluxDistinct.DistinctConditionalSubscriber<String, Integer, Set<Integer>> test =
 				new FluxDistinct.DistinctConditionalSubscriber<>(actual, new HashSet<>(), String::hashCode);

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctUntilChangedTest.java
Patch:
@@ -249,6 +249,7 @@ public void scanSubscriber() {
 
 	@Test
 	public void scanConditionalSubscriber() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber<String, Integer> test = new FluxDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber<>(
 				actual, String::hashCode, Objects::equals);

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterFuseableTest.java
Patch:
@@ -46,6 +46,7 @@ public void scanSubscriber() {
 
     @Test
     public void scanConditionalSubscriber() {
+        @SuppressWarnings("unchecked")
         Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
         FluxFilterFuseable.FilterFuseableConditionalSubscriber<String> test = new FluxFilterFuseable.FilterFuseableConditionalSubscriber<>(actual, t -> true);
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -264,7 +264,8 @@ public void scanSubscriber() {
 
     @Test
     public void scanConditionalSubscriber() {
-        Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    @SuppressWarnings("unchecked")
+	    Fuseable.ConditionalSubscriber<String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
         FluxFilter.FilterConditionalSubscriber<String> test = new FluxFilter.FilterConditionalSubscriber<>(actual, t -> true);
         Subscription parent = Operators.emptySubscription();
         test.onSubscribe(parent);

File: reactor-core/src/test/java/reactor/core/publisher/FluxIterableTest.java
Patch:
@@ -150,6 +150,7 @@ public void scanSubscription() {
 
 	@Test
 	public void scanConditionalSubscription() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<? super String> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
         FluxIterable.IterableSubscriptionConditional<String> test =
 				new FluxIterable.IterableSubscriptionConditional<>(actual, Collections.singleton("test").iterator());

File: reactor-core/src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -850,7 +850,8 @@ public void scanFuseableSubscriber() {
 
     @Test
     public void scanFuseableConditionalSubscriber() {
-        Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
+	    @SuppressWarnings("unchecked")
+	    Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
         FluxPeek<Integer> peek = new FluxPeek<>(Flux.just(1), s -> {}, s -> {},
         		e -> {}, () -> {}, () -> {}, r -> {}, () -> {});
         FluxPeekFuseable.PeekFuseableConditionalSubscriber<Integer> test =

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -1281,6 +1281,7 @@ public void scanSubscriber() {
 
 	@Test
     public void scanConditionalSubscriber() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
         FluxPublishOn.PublishOnConditionalSubscriber<Integer> test =
         		new FluxPublishOn.PublishOnConditionalSubscriber<>(actual, Schedulers.single(),

File: reactor-core/src/test/java/reactor/core/publisher/FluxRangeTest.java
Patch:
@@ -143,6 +143,7 @@ public void scanSubscription() {
 
 	@Test
 	public void scanConditionalSubscription() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		FluxRange.RangeSubscriptionConditional test = new FluxRange.RangeSubscriptionConditional(actual, 1L, 10L);
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeTest.java
Patch:
@@ -612,6 +612,7 @@ public void scanSubscriber() {
 
 	@Test
     public void scanConditionalSubscriber() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		FluxTake.TakeConditionalSubscriber<Integer> test = new FluxTake.TakeConditionalSubscriber<>(actual, 5);
         Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -331,6 +331,7 @@ public void scanSubscriber() {
 
 	@Test
     public void scanConditionalSubscriber() {
+		@SuppressWarnings("unchecked")
 		Fuseable.ConditionalSubscriber<Integer> actual = Mockito.mock(Fuseable.ConditionalSubscriber.class);
 		FluxUsing.UsingConditionalSubscriber<Integer, String> test =
 				new FluxUsing.UsingConditionalSubscriber<>(actual, s -> {}, "", true);

File: reactor-core/src/test/java/reactor/core/publisher/MonoFilterWhenTest.java
Patch:
@@ -292,9 +292,9 @@ public void innerMonoNotCancelled() {
 	public void scanTerminatedOnlyTrueIfFilterTerminated() {
 		AtomicReference<Subscriber> subscriber = new AtomicReference<>();
 		TestPublisher<Boolean> filter = TestPublisher.create();
-		new MonoFilterWhen(new Mono() {
+		new MonoFilterWhen<>(new Mono<Integer>() {
 			@Override
-			public void subscribe(Subscriber s) {
+			public void subscribe(Subscriber<? super Integer> s) {
 				subscriber.set(s);
 				//NON-EMPTY SOURCE WILL TRIGGER FILTER SUBSCRIPTION
 				s.onNext(2);

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -70,7 +70,7 @@
 @NonNullApi
 public class GuideTests {
 
-	@Test
+	@Test @SuppressWarnings("unchecked")
 	public void introFutureHell() {
 		CompletableFuture<List<String>> ids = ifhIds(); // <1>
 

File: reactor-core/src/test/java/reactor/test/publisher/FluxOperatorTest.java
Patch:
@@ -202,7 +202,7 @@ protected Flux<I> sourceScalar(OperatorScenario<I, Flux<I>, O, Flux<O>> scenario
 		if(scenario.producerCount() == 0){
 			return (Flux<I>)Flux.empty();
 		}
-		return (Flux<I>)Flux.just(scenario.producingMapper.apply(0));
+		return Flux.just(scenario.producingMapper.apply(0));
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/test/publisher/ReduceOperatorTest.java
Patch:
@@ -246,7 +246,7 @@ final Flux<I> sourceScalar(OperatorScenario<I, Flux<I>, O, Mono<O>>
 		if(scenario.producerCount() == 0){
 			return (Flux<I>)Flux.empty();
 		}
-		return (Flux<I>)Flux.just(scenario.producingMapper.apply(0));
+		return Flux.just(scenario.producingMapper.apply(0));
 	}
 
 	@Override

File: reactor-core/src/test/java/reactor/util/ExceptionTests.java
Patch:
@@ -57,7 +57,8 @@ public void allIllegalStateIsntOverflow() {
 
 	@Test
 	public void multipleWithNullVararg() {
-		assertThat(Exceptions.multiple(null))
+		//noinspection ConstantConditions
+		assertThat(Exceptions.multiple((Throwable[]) null))
 				.isInstanceOf(RuntimeException.class)
 				.hasMessage("Multiple exceptions")
 	            .hasNoSuppressedExceptions();

File: reactor-core/src/main/java/reactor/core/Fuseable.java
Patch:
@@ -60,7 +60,7 @@ public interface Fuseable {
 	interface ConditionalSubscriber<T> extends Subscriber<T> {
 		/**
 		 * Try consuming the value and return true if successful.
-		 * @param t the value to consume
+		 * @param t the value to consume, not null
 		 * @return true if consumed, false if dropped and a new value can be immediately sent
 		 */
 		boolean tryOnNext(T t);

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinct.java
Patch:
@@ -264,7 +264,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return true;
@@ -384,7 +384,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 
 			if (sourceMode == Fuseable.ASYNC) {
 				actual.onNext(null);

File: reactor-core/src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -220,7 +220,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxDoFinally.java
Patch:
@@ -225,7 +225,7 @@ static final class DoFinallyConditionalSubscriber<T> extends DoFinallySubscriber
 
 		@Override
 		@SuppressWarnings("unchecked")
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			return ((ConditionalSubscriber<? super T>)actual).tryOnNext(t);
 		}
 	}
@@ -240,7 +240,7 @@ static final class DoFinallyFuseableConditionalSubscriber<T> extends DoFinallyFu
 
 		@Override
 		@SuppressWarnings("unchecked")
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			return ((ConditionalSubscriber<? super T>)actual).tryOnNext(t);
 		}
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilter.java
Patch:
@@ -102,7 +102,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;
@@ -218,7 +218,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;

File: reactor-core/src/main/java/reactor/core/publisher/FluxFilterFuseable.java
Patch:
@@ -110,7 +110,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;
@@ -291,7 +291,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;

File: reactor-core/src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -262,6 +262,9 @@ public Stream<? extends Scannable> inners() {
 
 		void signalAsyncError() {
 			Throwable e = Exceptions.terminate(ERROR, this); //TODO investigate if e == null
+			if (e == null) {
+				e = new IllegalStateException("FluxGroupBy.signalAsyncError called without error set");
+			}
 			groupCount = 0;
 			for (UnicastGroupedFlux<K, V> g : groupMap.values()) {
 				g.onError(e);

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -111,7 +111,7 @@ else if(v == null){
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;
@@ -268,7 +268,7 @@ else if(v == null){
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;

File: reactor-core/src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -88,7 +88,7 @@ static final class HandleFuseableSubscriber<T, R>
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return true;
@@ -392,7 +392,7 @@ else if (v == null) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return true;

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureBufferStrategy.java
Patch:
@@ -210,7 +210,8 @@ void drain() {
 
 			for (; ; ) {
 				Subscriber<? super T> a = actual;
-				if (a != null) { //TODO investigate null (can actual be null?)
+				//noinspection ConstantConditions
+				if (a != null) {
 					innerDrain(a);
 					return;
 				}

File: reactor-core/src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -768,7 +768,7 @@ public void onNext(T t) {
 		}
 
 		@Override
-		public boolean tryOnNext(@Nullable T t) {
+		public boolean tryOnNext(T t) {
 			if (done) {
 				Operators.onNextDropped(t);
 				return false;

File: reactor-core/src/main/java/reactor/core/publisher/SignalLogger.java
Patch:
@@ -192,7 +192,7 @@ public Consumer<? super Subscription> onSubscribeCall() {
 		return null;
 	}
 
-	String subscriptionAsString(@Nullable Subscription s) {
+	static String subscriptionAsString(@Nullable Subscription s) {
 		if (s == null) {
 			return "null subscription";
 		}

File: reactor-core/src/test/java/reactor/core/CoreTest.java
Patch:
@@ -17,6 +17,8 @@
 
 import java.util.Collections;
 
+import javax.annotation.Nullable;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
@@ -71,6 +73,7 @@ public int requestFusion(int requestedMode) {
 		}
 
 		@Override
+		@Nullable
 		public Integer poll() {
 			return null;
 		}

File: reactor-core/src/test/java/reactor/core/ScannableTest.java
Patch:
@@ -86,7 +86,9 @@ public void availableScan() {
 
 	@Test
 	public void nullScan() {
-		assertThat(Scannable.from(null)).isNull();
+		assertThat(Scannable.from(null))
+				.isNotNull()
+				.isSameAs(Scannable.Attr.NULL_SCAN);
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/DisposablesTest.java
Patch:
@@ -77,7 +77,7 @@ public void validationNull() {
 		Hooks.onErrorDropped(e -> assertThat(e).isInstanceOf(NullPointerException.class)
 		                                       .hasMessage("next is null"));
 		try {
-			assertThat(Disposables.validate(null, null));
+			assertThat(Disposables.validate(null, null)).isFalse();
 		} finally {
 			Hooks.resetOnErrorDropped();
 		}

File: reactor-core/src/test/java/reactor/core/publisher/FluxDistinctTest.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.Objects;
 import java.util.Set;
 
+import javax.annotation.Nullable;
+
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscriber;
@@ -384,6 +386,7 @@ public NaiveFifoQueue(int limit) {
 		}
 
 		@Override
+		@Nullable
 		public Iterator<T> iterator() {
 			return null;
 		}

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -33,6 +33,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
+import javax.annotation.Nullable;
+
 import org.assertj.core.api.Assertions;
 import org.hamcrest.CoreMatchers;
 import org.junit.AfterClass;
@@ -1314,6 +1316,7 @@ public Disposable schedule(Runnable task) {
 		}
 
 		@Override
+		@Nullable
 		public Worker createWorker() {
 			return null;
 		}

File: reactor-core/src/test/java/reactor/core/publisher/FluxSkipUntilOtherTest.java
Patch:
@@ -262,6 +262,7 @@ public void scanMainSubscriber() {
 
         Assertions.assertThat(test.scan(Scannable.ScannableAttr.PARENT)).isSameAs(parent);
         SerializedSubscriber<?> serialized = (SerializedSubscriber<?>) test.scan(Scannable.ScannableAttr.ACTUAL);
+        Assertions.assertThat(serialized).isNotNull();
         Assertions.assertThat(serialized.actual()).isSameAs(actual);
 
         Assertions.assertThat(test.scan(Scannable.BooleanAttr.CANCELLED)).isFalse();

File: reactor-core/src/test/java/reactor/core/publisher/FluxTakeUntilOtherTest.java
Patch:
@@ -201,6 +201,7 @@ public void scanMainSubscriber() {
         Assertions.assertThat(test.scan(Scannable.ScannableAttr.PARENT)).isSameAs(parent);
         @SuppressWarnings("unchecked")
 		SerializedSubscriber<Integer> serialized = (SerializedSubscriber<Integer>) test.scan(Scannable.ScannableAttr.ACTUAL);
+        Assertions.assertThat(serialized).isNotNull();
         Assertions.assertThat(serialized.actual()).isSameAs(actual);
 
         Assertions.assertThat(test.scan(Scannable.BooleanAttr.CANCELLED)).isFalse();

File: reactor-core/src/test/java/reactor/core/publisher/FluxWindowPredicateTest.java
Patch:
@@ -382,8 +382,8 @@ public void predicateErrorUntilCutBefore() {
 
 	private <T> Predicate<? super Signal<T>> signalErrorMessage(String expectedMessage) {
 		return signal -> signal.isOnError()
-				&& signal.getThrowable().getMessage() != null
-				&& signal.getThrowable().getMessage().equals(expectedMessage);
+				&& signal.getThrowable() != null
+				&& expectedMessage.equals(signal.getThrowable().getMessage());
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/core/publisher/MonoThenIgnoreTest.java
Patch:
@@ -86,7 +86,7 @@ public void cancel() {
 	@Test
 	public void scanThenAcceptInner() {
 		Subscriber<String> actual = new LambdaMonoSubscriber<>(null, e -> {}, null, null);
-		MonoThenIgnore.ThenIgnoreMain<String> main = new MonoThenIgnore.ThenIgnoreMain<>(actual, new Publisher[0], null);
+		MonoThenIgnore.ThenIgnoreMain<String> main = new MonoThenIgnore.ThenIgnoreMain<>(actual, new Publisher[0], Mono.just("foo"));
 
 		MonoThenIgnore.ThenAcceptInner<String> test = new MonoThenIgnore.ThenAcceptInner<>(main);
 		Subscription parent = Operators.emptySubscription();
@@ -107,7 +107,7 @@ public void scanThenAcceptInner() {
 	@Test
 	public void scanThenIgnoreInner() {
 		Subscriber<String> actual = new LambdaMonoSubscriber<>(null, e -> {}, null, null);
-		MonoThenIgnore.ThenIgnoreMain<String> main = new MonoThenIgnore.ThenIgnoreMain<>(actual, new Publisher[0], null);
+		MonoThenIgnore.ThenIgnoreMain<String> main = new MonoThenIgnore.ThenIgnoreMain<>(actual, new Publisher[0], Mono.just("foo"));
 
 		MonoThenIgnore.ThenIgnoreInner test = new MonoThenIgnore.ThenIgnoreInner(main);
 		Subscription parent = Operators.emptySubscription();

File: reactor-core/src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -22,6 +22,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 
+import javax.annotation.Nullable;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -262,7 +264,7 @@ public Float getValue() {
 		}
 
 		@Override
-		public int compareTo(SensorData other) {
+		public int compareTo(@Nullable SensorData other) {
 			if (null == other) {
 				return 1;
 			}

File: reactor-core/src/test/java/reactor/test/publisher/FluxEmptySyncFuseable.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.test.publisher;
 
+import javax.annotation.Nullable;
+
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Flux;
@@ -28,6 +30,7 @@ final class FluxEmptySyncFuseable<T> extends Flux<T> implements Fuseable {
 	public void subscribe(Subscriber<? super T> s) {
 		s.onSubscribe(new SynchronousSubscription<T>() {
 			@Override
+			@Nullable
 			public T poll() {
 				return null;
 			}

File: reactor-core/src/test/java/reactor/test/publisher/FluxFuseableExceptionOnPoll.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.test.publisher;
 
+import javax.annotation.Nullable;
+
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
@@ -106,6 +108,7 @@ public int requestFusion(int requestedMode) {
 		}
 
 		@Override
+		@Nullable
 		public T poll() {
 			T t = qs.poll();
 			if (t != null) {

File: reactor-core/src/test/java/reactor/test/publisher/ParallelOperatorTest.java
Patch:
@@ -21,6 +21,8 @@
 import java.util.function.Function;
 import java.util.function.IntFunction;
 
+import javax.annotation.Nullable;
+
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
@@ -50,7 +52,7 @@ static <I, O> Scenario<I, O> create(Function<ParallelFlux<I>, ? extends Parallel
 			return new Scenario<>(scenario, new Exception("scenario:"));
 		}
 
-		Scenario(Function<ParallelFlux<I>, ? extends ParallelFlux<O>> scenario, Exception stack) {
+		Scenario(@Nullable Function<ParallelFlux<I>, ? extends ParallelFlux<O>> scenario, @Nullable Exception stack) {
 			super(scenario, stack);
 		}
 

File: reactor-core/src/test/java/reactor/core/publisher/FluxMergeTest.java
Patch:
@@ -116,7 +116,6 @@ public void mergeDelayError() {
 				Flux.range(1, 4)
 		))
 		            .expectNext(1, 2, 3, 4)
-		            .consumeErrorWith(e -> assertThat(e).isEqualTo(boom))
-		            .verify();
+		            .verifyErrorSatisfies(e -> assertThat(e).isEqualTo(boom));
 	}
 }

File: reactor-core/src/test/java/reactor/core/publisher/FluxPublishOnTest.java
Patch:
@@ -74,8 +74,7 @@ protected Scenario<String, String> defaultScenarioOptions(Scenario<String, Strin
 
 	void assertRejected(StepVerifier.Step<String> step) {
 		try {
-			step.consumeErrorWith(e -> Assert.assertTrue(Exceptions.unwrap(e) instanceof RejectedExecutionException))
-			    .verify();
+			step.verifyErrorSatisfies(e -> Assert.assertTrue(Exceptions.unwrap(e) instanceof RejectedExecutionException));
 		}
 		catch (Exception e) {
 			assertTrue(Exceptions.unwrap(e) instanceof RejectedExecutionException);

File: reactor-core/src/test/java/reactor/core/publisher/FluxUsingTest.java
Patch:
@@ -305,10 +305,9 @@ public void sourceFactoryAndResourceCleanupThrow() {
 				false);
 
 		StepVerifier.create(test)
-		            .consumeErrorWith(e -> assertThat(e)
+		            .verifyErrorSatisfies(e -> assertThat(e)
 				            .hasMessage("resourceCleanup")
-				            .is(suppressingFactory))
-		            .verify();
+				            .is(suppressingFactory));
 
 	}
 

File: reactor-core/src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -320,8 +320,7 @@ public void whenMonoError() {
 		            .then(() -> assertThat(mp.isError()).isTrue())
 		            .then(() -> assertThat(mp.isSuccess()).isFalse())
 		            .then(() -> assertThat(mp.isTerminated()).isTrue())
-		            .consumeErrorWith(e -> assertThat(e).hasMessage("test1"))
-		            .verify();
+		            .verifyErrorSatisfies(e -> assertThat(e).hasMessage("test1"));
 	}
 
 	@Test

File: reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java
Patch:
@@ -169,13 +169,13 @@ public final void sequenceOfNextWithCallbackError() {
 			String m = scenario.producerError.getMessage();
 			Consumer<StepVerifier.Step<O>> errorVerifier = step -> {
 				try {
-					step.consumeErrorWith(e -> {
+					step.verifyErrorSatisfies(e -> {
 						if (e instanceof NullPointerException || e instanceof IllegalStateException || e.getMessage()
 						                                                                                .equals(m)) {
 							return;
 						}
 						throw Exceptions.propagate(e);
-					}).verify();
+					});
 //						step.expectErrorMessage(m)
 //						.verifyThenAssertThat()
 //						.hasOperatorErrorWithMessage(m);

File: reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -422,7 +422,9 @@ public final FluxSink<T> onDispose(@Nullable Disposable d) {
 				SinkDisposable sd = new SinkDisposable(d, null);
 				if (!DISPOSABLE.compareAndSet(this, null, sd)) {
 					Disposable c = disposable;
-					if (c instanceof SinkDisposable) {
+					if (c == Disposables.DISPOSED)
+						d.dispose();
+					else if (c instanceof SinkDisposable) {
 						SinkDisposable current = (SinkDisposable) c;
 						if (current.disposable == null)
 							current.disposable = d;

File: reactor-core/src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -3007,7 +3007,7 @@ public final <V> Mono<V> then(Mono<V> other) {
             MonoThenIgnore<T> a = (MonoThenIgnore<T>) this;
             return a.shift(other);
 		}
-		return onAssembly(new MonoThenIgnore<>(new Mono[] { this }, other));
+		return onAssembly(new MonoThenIgnore<>(new Publisher[] { this }, other));
 	}
 
 	/**

File: reactor-core/src/main/java/reactor/core/publisher/MonoThenIgnore.java
Patch:
@@ -65,7 +65,7 @@ <U> MonoThenIgnore<U> shift(Mono<U> newLast) {
         Objects.requireNonNull(newLast, "newLast");
         Publisher<?>[] a = ignore;
         int n = a.length;
-        Mono<?>[] b = new Mono[n + 1];
+        Publisher<?>[] b = new Publisher[n + 1];
         System.arraycopy(a, 0, b, 0, n);
         b[n] = last;
         

File: reactor-core/src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -34,6 +34,7 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * An iterable that consumes a Publisher in a blocking fashion.
@@ -63,6 +64,7 @@ final class BlockingIterable<T> implements Iterable<T>, Scannable {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return (int) Math.min(Integer.MAX_VALUE, batchSize); //FIXME should batchSize be forced to int?
 		if (key == ScannableAttr.PARENT) return source;
@@ -256,6 +258,7 @@ public void run() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return  s;

File: reactor-core/src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -23,6 +23,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
+import javax.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this connectable publisher is created and
@@ -66,6 +67,7 @@ public void connect(Consumer<? super Disposable> cancelSupport) {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -23,7 +23,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Disposable;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Connects to the underlying Flux once the given amount of Subscribers
@@ -69,6 +69,7 @@ public int getPrefetch() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -24,7 +24,7 @@
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Connects to the underlying Flux once the given amount of Subscribers
@@ -70,6 +70,7 @@ public int getPrefetch() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxAwaitOnSubscribe.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Intercepts the onSubscribe call and makes sure calls to Subscription methods only
@@ -130,6 +131,7 @@ public Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.CANCELLED) return s == Operators.cancelledSubscription();

File: reactor-core/src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java
Patch:
@@ -27,6 +27,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 /**
  * @author Stephane Maldini
@@ -167,7 +168,7 @@ public void nextCallback(T value) {
 			}
 		}
 
-		public void flushCallback(T ev) {
+		public void flushCallback(@Nullable T ev) { //TODO investigate ev not used
 			C v = values;
 			boolean flush = false;
 			synchronized (this) {
@@ -183,6 +184,7 @@ public void flushCallback(T ev) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return subscription;
 			if (key == BooleanAttr.CANCELLED) return terminated == TERMINATED_WITH_CANCEL;

File: reactor-core/src/main/java/reactor/core/publisher/FluxCancelOn.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 import static reactor.core.scheduler.Scheduler.REJECTED;
 
@@ -65,6 +66,7 @@ public void onSubscribe(Subscription s) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.CANCELLED) return cancelled == 1;

File: reactor-core/src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Exceptions;
+import javax.annotation.Nullable;
 
 /**
  * Concatenates a fixed array of Publishers' values.
@@ -251,6 +252,7 @@ public void onError(Throwable t) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.DELAY_ERROR) return true;
 			if (key == ThrowableAttr.ERROR) return error;

File: reactor-core/src/main/java/reactor/core/publisher/FluxDefaultIfEmpty.java
Patch:
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Emits a scalar value if the source sequence turns out to be empty.
@@ -54,6 +55,7 @@ static final class DefaultIfEmptySubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -20,8 +20,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-
-
+import javax.annotation.Nullable;
 
 /**
  * Delays the subscription to the main source until another Publisher
@@ -68,6 +67,7 @@ static final class DelaySubscriptionOtherSubscriber<T, U>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == ScannableAttr.ACTUAL) return actual;
@@ -148,6 +148,7 @@ static final class DelaySubscriptionMainSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.ACTUAL) return actual;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxDetach.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Detaches the both the child Subscriber and the Subscription on
@@ -49,6 +50,7 @@ static final class DetachSubscriber<T> implements InnerOperator<T, T> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return actual == null;

File: reactor-core/src/main/java/reactor/core/publisher/FluxElapsed.java
Patch:
@@ -24,6 +24,7 @@
 import reactor.core.scheduler.Scheduler;
 import reactor.util.function.Tuple2;
 import reactor.util.function.Tuples;
+import javax.annotation.Nullable;
 
 /**
  * @author Stephane Maldini
@@ -60,6 +61,7 @@ static final class ElapsedSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 
@@ -128,6 +130,7 @@ Tuple2<Long, T> snapshot(T data){
 		}
 
 		@Override
+		@Nullable
 		public Tuple2<Long, T> poll() {
 			T data = qs.poll();
 			if(data != null){

File: reactor-core/src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
-
+import javax.annotation.Nullable;
 
 /**
  * Represents an empty publisher which only calls onSubscribe and onComplete.
@@ -53,6 +53,7 @@ public static <T> Flux<T> instance() {
 	}
 
 	@Override
+	@Nullable
 	public Object call() {
 		return null; /* Scalar optimizations on empty */
 	}

File: reactor-core/src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import org.reactivestreams.Subscriber;
-
+import javax.annotation.Nullable;
 
 /**
  * Emits a constant or generated Throwable instance to Subscribers.
@@ -85,6 +85,7 @@ public Subscriber<?> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ThrowableAttr.ERROR) return error;
 			if (key == BooleanAttr.CANCELLED || key == BooleanAttr.TERMINATED)

File: reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -31,6 +31,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Concatenates values from Iterable sequences generated via a mapper function.
@@ -166,6 +167,7 @@ static final class FlattenIterableSubscriber<T, R>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return done;
@@ -625,6 +627,7 @@ public boolean isEmpty() {
 		}
 
 		@Override
+		@Nullable
 		public R poll() {
 			Iterator<? extends R> it = current;
 			for (; ; ) {

File: reactor-core/src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -24,7 +24,7 @@
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
-
+import javax.annotation.Nullable;
 
 /**
  * Periodically emits an ever increasing long value either via a ScheduledExecutorService
@@ -91,6 +91,7 @@ public Subscriber<? super Long> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return cancelled;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxJoin.java
Patch:
@@ -38,6 +38,7 @@
 import reactor.core.publisher.FluxGroupJoin.LeftRightEndSubscriber;
 import reactor.core.publisher.FluxGroupJoin.LeftRightSubscriber;
 import reactor.util.concurrent.OpenHashSet;
+import javax.annotation.Nullable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
@@ -181,6 +182,7 @@ public final Subscriber<? super R> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == LongAttr.REQUESTED_FROM_DOWNSTREAM) return requested;
 			if (key == BooleanAttr.CANCELLED) return cancelled;

File: reactor-core/src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Maps the values of the source publisher one-on-one via a mapper function.
@@ -131,6 +132,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return done;
@@ -245,6 +247,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return done;

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Drops values if the subscriber doesn't request fast enough.
@@ -159,6 +160,7 @@ public Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == LongAttr.REQUESTED_FROM_DOWNSTREAM) return requested;

File: reactor-core/src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Runs the source in unbounded mode and emits only the latest value
@@ -210,6 +211,7 @@ public Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == LongAttr.REQUESTED_FROM_DOWNSTREAM) return requested;

File: reactor-core/src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -27,6 +27,7 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * A base processor that exposes {@link Flux} API for {@link Processor}.
@@ -103,6 +104,7 @@ public int getBufferSize() {
 	 *
 	 * @return Current error if any, default to null
 	 */
+	@Nullable
 	public Throwable getError() {
 		return null;
 	}
@@ -140,6 +142,7 @@ public boolean isSerialized() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == BooleanAttr.TERMINATED) return isTerminated();
 		if (key == ThrowableAttr.ERROR) return getError();

File: reactor-core/src/main/java/reactor/core/publisher/FluxRefCountGrace.java
Patch:
@@ -28,6 +28,7 @@
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 /**
  * @author Simon Baslé
@@ -57,6 +58,7 @@ public int getPrefetch() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;
@@ -245,6 +247,7 @@ public int requestFusion(int requestedMode) {
 		}
 
 		@Override
+		@Nullable
 		public T poll() {
 			return qs.poll();
 		}

File: reactor-core/src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -25,8 +25,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
-
+import javax.annotation.Nullable;
 
 /**
  * Repeats a source when a companion sequence signals an item in response to the main's
@@ -114,6 +113,7 @@ static final class RepeatWhenMainSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return cancelled;
 
@@ -208,6 +208,7 @@ static final class RepeatWhenOtherSubscriber extends Flux<Long>
 		final DirectProcessor<Long> completionSignal = new DirectProcessor<>();
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return main.otherArbiter;
 			if (key == ScannableAttr.ACTUAL) return main;

File: reactor-core/src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -24,8 +24,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
-
+import javax.annotation.Nullable;
 
 /**
  * retries a source when a companion sequence signals
@@ -114,6 +113,7 @@ static final class RetryWhenMainSubscriber<T> extends
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return cancelled;
 
@@ -207,6 +207,7 @@ static final class RetryWhenOtherSubscriber extends Flux<Throwable>
 		final DirectProcessor<Throwable> completionSignal = new DirectProcessor<>();
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return main.otherArbiter;
 			if (key == ScannableAttr.ACTUAL) return main;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -28,7 +28,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Takes a value from upstream then uses the duration provided by a
@@ -121,6 +121,7 @@ public Stream<? extends Scannable> inners() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return s == Operators.cancelledSubscription();
 			if (key == ScannableAttr.PARENT) return s;
@@ -244,6 +245,7 @@ static final class SampleFirstOther<U> extends Operators.DeferredSubscription
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.ACTUAL) return main;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -30,7 +30,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Emits the last value from upstream only if there were no newer values emitted
@@ -142,6 +142,7 @@ public Stream<? extends Scannable> inners() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == BooleanAttr.CANCELLED) return cancelled;
@@ -351,6 +352,7 @@ static final class SampleTimeoutOther<T, U> extends Operators.DeferredSubscripti
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return once == 1;
 			if (key == ScannableAttr.ACTUAL) return main;

File: reactor-core/src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Accumulates the source values with an accumulator function and
@@ -123,6 +124,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return done;

File: reactor-core/src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Aggregates the source values with the help of an accumulator function
@@ -233,6 +234,7 @@ public void request(long n) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) {
 				return s;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Disposable;
 
-
 /**
  * Wrapper API around a downstream Subscriber for emitting any number of
  * next signals followed by zero or one onError/onComplete.

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkip.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Skips the first N elements from a reactive stream.
@@ -90,6 +91,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipLast.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Skips the last N elements from the source stream.
@@ -92,6 +93,7 @@ public void onComplete() {
 
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == IntAttr.PREFETCH) return n;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import javax.annotation.Nullable;
 
 /**
  * Skips source values while a predicate returns
@@ -150,6 +151,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return done;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Skips values from the main publisher until the other publisher signals
@@ -64,6 +64,7 @@ static final class SkipUntilOtherSubscriber<U> implements InnerConsumer<U> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return main.other == Operators.cancelledSubscription();
 			if (key == ScannableAttr.PARENT) return main.other;
@@ -146,6 +147,7 @@ public final Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return main;
 			if (key == BooleanAttr.CANCELLED) return main == Operators.cancelledSubscription();

File: reactor-core/src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable.ConditionalSubscriber;
+import javax.annotation.Nullable;
 
 /**
  * Skips source values while a predicate returns
@@ -151,6 +152,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return done;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * A connecting {@link Flux} Publisher (right-to-left from a composition chain perspective)
@@ -79,6 +80,7 @@ public String toString() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == IntAttr.PREFETCH) return getPrefetch();
 		if (key == ScannableAttr.PARENT) return source;

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import javax.annotation.Nullable;
 
 /**
  * Subscribes to the source Publisher asynchronously through a scheduler function or
@@ -187,6 +188,7 @@ public void cancel() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.CANCELLED) return s == Operators.cancelledSubscription();

File: reactor-core/src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -25,7 +25,7 @@
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
-
+import javax.annotation.Nullable;
 
 /**
  * Executes a Callable and emits its value on the given Scheduler.
@@ -118,6 +118,7 @@ public Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return state == HAS_CANCELLED;
 			if (key == IntAttr.BUFFERED) return value != null ? 1 : 0;
@@ -157,6 +158,7 @@ public boolean isEmpty() {
 		}
 
 		@Override
+		@Nullable
 		public T poll() {
 			if (fusionState == HAS_VALUE) {
 				fusionState = COMPLETE;

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Emits the last N values the source emitted before its completion.
@@ -68,6 +69,7 @@ static final class TakeLastZeroSubscriber<T> implements InnerOperator<T, T> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 
@@ -186,6 +188,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return cancelled;
 			if (key == LongAttr.REQUESTED_FROM_DOWNSTREAM) return requested;

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Relays values until a predicate returns
@@ -114,6 +115,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -23,7 +23,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Relays values from the main Publisher until another Publisher signals an event.
@@ -67,6 +67,7 @@ static final class TakeUntilOtherSubscriber<U> implements InnerConsumer<U> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return main.other == Operators.cancelledSubscription();
 			if (key == ScannableAttr.PARENT) return main.other;
@@ -131,6 +132,7 @@ public final Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return main;
 			if (key == BooleanAttr.CANCELLED) return main == Operators.cancelledSubscription();

File: reactor-core/src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Relays values while a predicate returns
@@ -115,6 +116,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -29,7 +29,7 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Splits the source sequence into continuous, non-overlapping windowEnds
@@ -141,6 +141,7 @@ public final Subscriber<? super Flux<T>> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == ThrowableAttr.ERROR) return error;
@@ -380,6 +381,7 @@ public void onSubscribe(Subscription s) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.ACTUAL) {
 				return main;

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowTimeOrSize.java
Patch:
@@ -26,6 +26,7 @@
 
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 /**
  * WindowTimeoutSubscriber is forwarding events on a steam until {@code maxSize} is reached,
@@ -312,6 +313,7 @@ public void onError(Throwable throwable) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return cancelled == 1;
 			if (key == ScannableAttr.PARENT) return subscription;

File: reactor-core/src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -31,6 +31,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
+import javax.annotation.Nullable;
 
 /**
  * Splits the source sequence into potentially overlapping windowEnds controlled by items
@@ -160,6 +161,7 @@ static final class WindowStartEndMainSubscriber<T, U, V>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 

File: reactor-core/src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -25,7 +25,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Combines values from a main Publisher with values from another
@@ -118,6 +118,7 @@ void setOther(Subscription s) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return main == Operators.cancelledSubscription();
 			if (key == ScannableAttr.PARENT) return main;
@@ -271,6 +272,7 @@ public void onSubscribe(Subscription s) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.ACTUAL) {
 				return main;

File: reactor-core/src/main/java/reactor/core/publisher/FluxZipIterable.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Pairwise combines elements of a publisher and an iterable sequence through a function.
@@ -99,6 +100,7 @@ static final class ZipSubscriber<T, U, R>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/GroupedFlux.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.core.publisher;
 
+import javax.annotation.Nullable;
+
 /**
  * Represents a sequence of events which has an associated key.
  *
@@ -27,5 +29,6 @@ public abstract class GroupedFlux<K, V> extends Flux<V> {
 	 * Return the key of the {@link GroupedFlux}.
 	 * @return the key
 	 */
+	@Nullable
 	public abstract K key();
 }

File: reactor-core/src/main/java/reactor/core/publisher/InnerOperator.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.publisher;
 
+
 /**
  *
  * @param <I> input operator consumed type

File: reactor-core/src/main/java/reactor/core/publisher/InnerProducer.java
Patch:
@@ -18,7 +18,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  *
@@ -35,6 +35,7 @@ interface InnerProducer<O>
 	Subscriber<? super O> actual();
 
 	@Override
+	@Nullable
 	default Object scanUnsafe(Attr key){
 		if (key == ScannableAttr.ACTUAL) {
 			return actual();

File: reactor-core/src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Emits a single boolean true if all values of the source sequence match
@@ -59,6 +60,7 @@ static final class AllSubscriber<T> extends Operators.MonoSubscriber<T, Boolean>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Emits a single boolean true if any of the values of the source sequence match
@@ -59,6 +60,7 @@ static final class AnySubscriber<T> extends Operators.MonoSubscriber<T, Boolean>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -22,7 +22,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
-
+import javax.annotation.Nullable;
 
 /**
  * Executes a Callable function and emits a single value to each individual Subscriber.

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Collects the values of the source sequence into a container returned by
@@ -81,6 +82,7 @@ static final class CollectSubscriber<T, R> extends Operators.MonoSubscriber<T, R
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Buffers all values from the source Publisher and emits it as a single Collection.
@@ -70,6 +71,7 @@ static final class MonoBufferAllSubscriber<T, C extends Collection<? super T>>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.TERMINATED) return collection == null;

File: reactor-core/src/main/java/reactor/core/publisher/MonoCount.java
Patch:
@@ -18,6 +18,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Counts the number of values in the source sequence.
@@ -48,6 +49,7 @@ static final class CountSubscriber<T> extends Operators.MonoSubscriber<T, Long>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -23,7 +23,7 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
-
+import javax.annotation.Nullable;
 
 /**
  * Emits a single 0L value delayed by some time amount with a help of
@@ -92,6 +92,7 @@ public Subscriber<? super Long> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return cancel == FINISHED;
 			if (key == BooleanAttr.CANCELLED) return cancel == Disposables.DISPOSED;

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 /**
  * Emits the first value emitted by a given source publisher, delayed by some time amount
@@ -73,6 +74,7 @@ static final class DelayElementSubscriber<T> extends Operators.MonoSubscriber<T,
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoDelayUntil.java
Patch:
@@ -26,6 +26,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Waits for a Mono source to terminate or produce a value, in which case the value is
@@ -149,6 +150,7 @@ public void onComplete() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done == n;
 			if (key == BooleanAttr.DELAY_ERROR) return delayError;
@@ -259,6 +261,7 @@ static final class DelayUntilTrigger<T> implements InnerConsumer<T> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return s == Operators.cancelledSubscription();
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Emits only the element at the given index position or signals a
@@ -75,6 +76,7 @@ static final class ElementAtSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
+import javax.annotation.Nullable;
 
 /**
  * Given a set of source Publishers the values of that Publisher is forwarded to the
@@ -47,6 +48,7 @@ final class MonoFirst<T> extends Mono<T> {
 		this.iterable = Objects.requireNonNull(iterable);
 	}
 
+	@Nullable
 	Mono<T> orAdditionalSource(Mono<? extends T> other) {
 		if (array != null) {
 			int n = array.length;

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -26,7 +26,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Given a Mono source, applies a function on its single item and continues
@@ -87,6 +87,7 @@ public Stream<? extends Scannable> inners() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == BooleanAttr.CANCELLED) return s == Operators.cancelledSubscription();
@@ -203,6 +204,7 @@ static final class ThenMapInner<R> implements InnerConsumer<R> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == ScannableAttr.ACTUAL) return parent;

File: reactor-core/src/main/java/reactor/core/publisher/MonoFlatMapMany.java
Patch:
@@ -27,7 +27,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 final class MonoFlatMapMany<T, R> extends Flux<R> {
 
@@ -78,6 +78,7 @@ static final class FlatMapMain<T, R> implements InnerOperator<T, R> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return main;
 
@@ -211,6 +212,7 @@ static final class FlatMapInner<R> implements InnerConsumer<R> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return parent.inner;
 			if (key == ScannableAttr.ACTUAL) return parent;

File: reactor-core/src/main/java/reactor/core/publisher/MonoHasElements.java
Patch:
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
@@ -48,6 +49,7 @@ static final class HasElementsSubscriber<T> extends Operators.MonoSubscriber<T,
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 
@@ -93,6 +95,7 @@ static final class HasElementSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) {
 				return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoIgnoreEmpty.java
Patch:
@@ -18,6 +18,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Ignores normal values and passes only the terminal signals along.
@@ -46,6 +47,7 @@ static final class IgnoreElementsSubscriber<T> implements InnerOperator<T, T> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Emits a single item at most from the source.
@@ -109,6 +110,7 @@ public void cancel() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -19,6 +19,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
+import javax.annotation.Nullable;
 
 /**
  * Captures the current stacktrace when this publisher is created and makes it
@@ -49,7 +50,7 @@ final class MonoOnAssembly<T> extends MonoSource<T, T> implements Fuseable, Asse
 	 * Create an assembly trace augmented with a custom description (eg. a name for a Mono
 	 * or a wider correlation ID) and exposed as a {@link Mono}.
 	 */
-	MonoOnAssembly(Mono<? extends T> source, String description) {
+	MonoOnAssembly(Mono<? extends T> source, @Nullable String description) {
 		super(source);
 		this.stacktrace = new AssemblySnapshotException(description);
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 /**
  * Schedules the emission of the value or completion of the wrapped Mono via
@@ -70,6 +71,7 @@ static final class PublishOnSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return future == Disposables.DISPOSED;
 			if (key == ScannableAttr.PARENT) return s;
@@ -117,6 +119,7 @@ public void onComplete() {
 			}
 		}
 
+		@Nullable
 		Disposable schedule() {
 			if (future == null) {
 				Disposable c = scheduler.schedule(this);

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduce.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Aggregates the source items with an aggregator function and returns the last result.
@@ -61,6 +62,7 @@ static final class ReduceSubscriber<T> extends Operators.MonoSubscriber<T, T> {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoReduceSeed.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Aggregates the source values with the help of an accumulator
@@ -80,6 +81,7 @@ static final class ReduceSeedSubscriber<T, R> extends Operators.MonoSubscriber<T
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -28,6 +28,7 @@
 import reactor.core.Exceptions;
 import reactor.core.Scannable;
 import reactor.util.concurrent.QueueSupplier;
+import javax.annotation.Nullable;
 
 import static reactor.core.publisher.Operators.cancelledSubscription;
 
@@ -98,6 +99,7 @@ public Subscriber<? super Boolean> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return cancelled;
 
@@ -296,6 +298,7 @@ static final class EqualSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.ACTUAL) return parent;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Expects and emits a single item from the source or signals
@@ -43,7 +44,7 @@ final class MonoSingle<T> extends MonoSource<T, T> implements Fuseable {
 	}
 
 	MonoSingle(Flux<? extends T> source,
-			T defaultValue,
+			@Nullable T defaultValue,
 			boolean completeOnEmpty) {
 		super(source);
 		this.defaultValue = completeOnEmpty ? defaultValue :
@@ -68,6 +69,7 @@ static final class SingleSubscriber<T> extends Operators.MonoSubscriber<T, T>  {
 		boolean done;
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.function.LongConsumer;
 
 import reactor.core.Disposable;
+import javax.annotation.Nullable;
 
 /**
  * Wrapper API around an actual downstream Subscriber
@@ -45,7 +46,7 @@ public interface MonoSink<T> {
 	 *
 	 * @param value the value to complete with
 	 */
-	void success(T value);
+	void success(@Nullable T value);
 
 	/**
 	 * Terminate with the give exception

File: reactor-core/src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * A decorating {@link Mono} {@link Publisher} that exposes {@link Mono} API over an arbitrary {@link Publisher}
@@ -86,6 +86,7 @@ public String toString() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) {
 				return source;

File: reactor-core/src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Collects the values from the source sequence into a {@link java.util.stream.Collector}
@@ -94,6 +95,7 @@ static final class StreamCollectorSubscriber<T, A, R>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.TERMINATED) return done;
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOn.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import javax.annotation.Nullable;
 
 /**
  * Subscribes to the upstream Mono on the specified Scheduler and makes sure
@@ -84,6 +85,7 @@ static final class SubscribeOnSubscriber<T>
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == BooleanAttr.CANCELLED) return s == Operators.cancelledSubscription();
 			if (key == ScannableAttr.PARENT) return s;

File: reactor-core/src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -23,6 +23,7 @@
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledEmpty;
 import reactor.core.publisher.FluxSubscribeOnValue.ScheduledScalar;
 import reactor.core.scheduler.Scheduler;
+import javax.annotation.Nullable;
 
 /**
  * Mono indicating a scalar/empty source that subscribes on the specified scheduler.
@@ -35,7 +36,7 @@ final class MonoSubscribeOnValue<T> extends Mono<T> {
 
 	final Scheduler scheduler;
 
-	MonoSubscribeOnValue(T value, Scheduler scheduler) {
+	MonoSubscribeOnValue(@Nullable T value, Scheduler scheduler) {
 		this.value = value;
 		this.scheduler = Objects.requireNonNull(scheduler, "scheduler");
 	}

File: reactor-core/src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import javax.annotation.Nullable;
 
 /**
  * Take the very last value from a Publisher source and and emit that one.
@@ -54,7 +55,7 @@ static final class TakeLastOneSubscriber<T>
 		Subscription s;
 
 		TakeLastOneSubscriber(Subscriber<? super T> actual,
-				T defaultValue,
+				@Nullable T defaultValue,
 				boolean mustEmit) {
 			super(actual);
 			this.defaultValue = defaultValue;
@@ -74,6 +75,7 @@ public void onSubscribe(Subscription s) {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 

File: reactor-core/src/main/java/reactor/core/publisher/MonoThenIgnore.java
Patch:
@@ -27,7 +27,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-
+import javax.annotation.Nullable;
 
 /**
  * Concatenates a several Mono sources with a final Mono source by
@@ -196,6 +196,7 @@ static final class ThenIgnoreInner implements InnerConsumer<Object> {
         }
 
 	    @Override
+        @Nullable
 	    public Object scanUnsafe(Attr key) {
             if (key == ScannableAttr.PARENT) return s;
             if (key == ScannableAttr.ACTUAL) return parent;
@@ -250,6 +251,7 @@ static final class ThenAcceptInner<T> implements InnerConsumer<T> {
         }
 
         @Override
+        @Nullable
         public Object scanUnsafe(Attr key) {
             if (key == ScannableAttr.PARENT) return s;
             if (key == ScannableAttr.ACTUAL) return parent;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelArraySource.java
Patch:
@@ -28,6 +28,7 @@ final class ParallelArraySource<T> extends ParallelFlux<T> {
 	final Publisher<T>[] sources;
 	
 	ParallelArraySource(Publisher<T>[] sources) {
+		//noinspection ConstantConditions
 		if (sources == null || sources.length == 0) {
 			throw new IllegalArgumentException("Zero publishers not supported");
 		}

File: reactor-core/src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Reduce the sequence of values in each 'rail' to a single value.
@@ -48,6 +49,7 @@ final class ParallelCollect<T, C> extends ParallelFlux<C> implements Scannable,
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
 import reactor.core.publisher.FluxConcatMap.ErrorMode;
+import javax.annotation.Nullable;
 
 /**
  * Concatenates the generated Publishers on each rail.
@@ -56,6 +57,7 @@ final class ParallelConcatMap<T, R> extends ParallelFlux<R> implements Scannable
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFilter.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Filters each 'rail' of the source ParallelFlux with a predicate function.
@@ -37,6 +38,7 @@ final class ParallelFilter<T> extends ParallelFlux<T> implements Scannable{
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Flattens the generated Publishers on each rail.
@@ -61,6 +62,7 @@ final class ParallelFlatMap<T, R> extends ParallelFlux<R> implements Scannable{
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Hides the identities of the upstream Publisher object and its Subscription as well.
@@ -44,6 +45,7 @@ public int parallelism() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -23,8 +23,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
-
-
+import javax.annotation.Nullable;
 
 /**
  * Exposes the 'rails' as individual GroupedFlux instances, keyed by the rail index (zero based).
@@ -60,6 +59,7 @@ public void subscribe(Subscriber<? super GroupedFlux<Integer, T>> s) {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();
@@ -113,6 +113,7 @@ public Subscriber<? super T> actual() {
 		}
 
 		@Override
+		@Nullable
 		public Object scanUnsafe(Attr key) {
 			if (key == ScannableAttr.PARENT) return s;
 			if (key == LongAttr.REQUESTED_FROM_DOWNSTREAM) return requested;

File: reactor-core/src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Execute a Consumer in each 'rail' for the current element passing through.
@@ -64,6 +65,7 @@ public int getPrefetch() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelMap.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Maps each 'rail' of the source ParallelFlux with a mapper function.
@@ -38,6 +39,7 @@ final class ParallelMap<T, R> extends ParallelFlux<R> implements Scannable {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Scannable;
+import javax.annotation.Nullable;
 
 /**
  * Reduce the sequence of values in each 'rail' to a single value.
@@ -49,6 +50,7 @@ final class ParallelReduceSeed<T, R> extends ParallelFlux<R> implements
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Scannable.Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -23,6 +23,7 @@
 import reactor.core.Scannable;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
+import javax.annotation.Nullable;
 
 /**
  * Ensures each 'rail' from upstream runs on a Worker from a Scheduler.
@@ -50,6 +51,7 @@ final class ParallelRunOn<T> extends ParallelFlux<T> implements Scannable, Fusea
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return source;
 		if (key == IntAttr.PREFETCH) return getPrefetch();

File: reactor-core/src/main/java/reactor/core/publisher/SerializedSubscriber.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import javax.annotation.Nullable;
 
 /**
  * Subscriber that makes sure signals are delivered sequentially in case the onNext, onError or onComplete methods are
@@ -236,6 +237,7 @@ public Subscriber<? super T> actual() {
 	}
 
 	@Override
+	@Nullable
 	public Object scanUnsafe(Attr key) {
 		if (key == ScannableAttr.PARENT) return s;
 		if (key == ThrowableAttr.ERROR) return error;

File: reactor-core/src/main/java/reactor/core/publisher/SignalType.java
Patch:
@@ -16,6 +16,7 @@
 
 package reactor.core.publisher;
 
+
 /**
  * Reactive Stream signal types
  */

File: reactor-core/src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -332,7 +332,7 @@ public static Scheduler newSingle(ThreadFactory threadFactory) {
 	 * the error has been passed to the thread uncaughtErrorHandler, which is not the
 	 * case when a fatal error occurs (see {@link Exceptions#throwIfJvmFatal(Throwable)}).
 	 *
-	 * @param c the new hook to set, or null to ignore (default).
+	 * @param c the new hook to set.
 	 */
 	public static void onHandleError(BiConsumer<Thread, ? super Throwable> c) {
 		log.info("Hooking new default: onHandleError");

File: reactor-core/src/main/java/reactor/util/Logger.java
Patch:
@@ -15,8 +15,6 @@
  */
 package reactor.util;
 
-import java.util.logging.Level;
-
 /**
  * Logger interface designed for internal Reactor usage.
  */

File: reactor-core/src/main/java/reactor/util/function/Tuple3.java
Patch:
@@ -33,7 +33,7 @@ public class Tuple3<T1, T2, T3> extends Tuple2<T1, T2> {
 
 	final T3 t3;
 
-	Tuple3(T1 t1, T2 t2, T3 t3) {
+	Tuple3(@Nullable T1 t1, @Nullable T2 t2, @Nullable T3 t3) {
 		super(t1, t2);
 		this.t3 = t3;
 	}
@@ -43,6 +43,7 @@ public class Tuple3<T1, T2, T3> extends Tuple2<T1, T2> {
 	 *
 	 * @return The third object
 	 */
+	@Nullable
 	public T3 getT3() {
 		return t3;
 	}
@@ -68,7 +69,7 @@ public Object[] toArray() {
 	}
 
 	@Override
-	public boolean equals(Object o) {
+	public boolean equals(@Nullable Object o) {
 		if (this == o) return true;
 		if (!(o instanceof Tuple3)) return false;
 		if (!super.equals(o)) return false;

File: reactor-core/src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -57,6 +57,7 @@
 import reactor.test.StepVerifier;
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.util.function.Tuple2;
+import reactor.util.lang.NonNullApi;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -66,7 +67,7 @@
  * @author Stephane Maldini
  * @author Simon Baslé
  */
-
+@NonNullApi
 public class GuideTests {
 
 	@Test
@@ -866,7 +867,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single(GuideTests.java:824)\n");
+						.hasMessageEndingWith("Flux.single(GuideTests.java:825)\n");
 			});
 		}
 	}

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -18,7 +18,6 @@
 
 import java.time.Duration;
 import java.util.Collection;
-import java.util.List;
 import java.util.Objects;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
@@ -167,7 +166,7 @@ static <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T
 	 */
 	static <T> FirstStep<T> withVirtualTime(Supplier<? extends Publisher<? extends T>> scenarioSupplier,
 			long n) {
-		return withVirtualTime(scenarioSupplier, () -> VirtualTimeScheduler.getOrSet(), n);
+		return withVirtualTime(scenarioSupplier, VirtualTimeScheduler::getOrSet, n);
 	}
 
 	/**

File: reactor-test/src/main/java/reactor/test/StepVerifierOptions.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.function.Supplier;
 
 import reactor.test.scheduler.VirtualTimeScheduler;
+import javax.annotation.Nullable;
 
 /**
  * Options for a {@link StepVerifier}, including the initial request amount,
@@ -98,6 +99,7 @@ public StepVerifierOptions virtualTimeSchedulerSupplier(Supplier<? extends Virtu
 	 * {@link StepVerifier} receiving these options.
 	 *
 	 */
+	@Nullable
 	public Supplier<? extends VirtualTimeScheduler> getVirtualTimeSchedulerSupplier() {
 		return vtsLookup;
 	}

File: reactor-test/src/main/java/reactor/test/publisher/DefaultTestPublisher.java
Patch:
@@ -28,6 +28,7 @@
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Operators;
+import javax.annotation.Nullable;
 
 /**
  * A default implementation of a {@link TestPublisher}.
@@ -328,7 +329,7 @@ public DefaultTestPublisher<T> assertNoRequestOverflow() {
 	}
 
 	@Override
-	public DefaultTestPublisher<T> next(T t) {
+	public DefaultTestPublisher<T> next(@Nullable T t) {
 		if (!violations.contains(Violation.ALLOW_NULL)) {
 			Objects.requireNonNull(t, "emitted values must be non-null");
 		}

File: reactor-test/src/main/java/reactor/test/scheduler/VirtualTimeScheduler.java
Patch:
@@ -31,6 +31,7 @@
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
 import reactor.util.concurrent.QueueSupplier;
+import javax.annotation.Nullable;
 
 /**
  * A {@link Scheduler} that uses a virtual clock, allowing to manipulate time
@@ -470,7 +471,7 @@ public void dispose() {
 		}
 	}
 
-	static boolean replace(AtomicReference<Disposable> ref, Disposable c) {
+	static boolean replace(AtomicReference<Disposable> ref, @Nullable Disposable c) {
 		for (; ; ) {
 			Disposable current = ref.get();
 			if (current == CANCELLED) {

File: reactor-test/src/main/java/reactor/test/StepVerifier.java
Patch:
@@ -807,7 +807,7 @@ interface FirstStep<T> extends Step<T> {
 		/**
 		 * Expect the source {@link Publisher} to NOT run with Reactor Fusion flow
 		 * optimization. It will check if publisher is {@link Fuseable} or
-		 * subscription is a {@link Fuseable.QueueSubscription}.
+		 * subscription is a {@link reactor.core.Fuseable.QueueSubscription}.
 		 *
 		 * @return this builder
 		 *

File: src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -567,7 +567,7 @@ public void syncFusionMapToNullFilter() {
 	public void asyncFusionMapToNull() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor<Integer> up = UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build();
+		UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build();
 		up.onNext(1);
 		up.onNext(2);
 		up.onComplete();
@@ -586,7 +586,7 @@ public void asyncFusionMapToNullFilter() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build();
+				UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build();
 		up.onNext(1);
 		up.onNext(2);
 		up.onComplete();

File: src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -180,7 +180,7 @@ public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
 
 		up.filter(v -> (v & 1) == 0)
 		  .subscribe(ts);
@@ -200,7 +200,7 @@ public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
 
 		Flux.just(1)
 		    .hide()
@@ -226,7 +226,7 @@ public void asyncFusionBackpressured2() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
 
 		Flux.just(1)
 		    .hide()

File: src/test/java/reactor/core/publisher/FluxMapTest.java
Patch:
@@ -145,7 +145,7 @@ public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
 
 		up.map(v -> v + 1)
 		  .subscribe(ts);
@@ -165,7 +165,7 @@ public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
+				UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
 
 		Flux.just(1)
 		    .hide()

File: src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -489,7 +489,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build()
+		UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build()
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -736,7 +736,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build()
+		UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(2).get()).build()
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -147,7 +147,7 @@ public void subsequentSumAsync() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(16).get()).build();
+				UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(16).get()).build();
 
 		up.publish(o -> zip((Object[] a) -> (Integer) a[0] + (Integer) a[1], o, o.skip(1)))
 		  .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -157,7 +157,7 @@ public void normalAsyncFused() {
 		AssertSubscriber<Integer> ts1 = AssertSubscriber.create();
 		AssertSubscriber<Integer> ts2 = AssertSubscriber.create();
 
-		UnicastProcessor<Integer> up = UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(8).get()).build();
+		UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(8).get()).build();
 		up.onNext(1);
 		up.onNext(2);
 		up.onNext(3);
@@ -196,7 +196,7 @@ public void normalBackpressuredAsyncFused() {
 		AssertSubscriber<Integer> ts1 = AssertSubscriber.create(0);
 		AssertSubscriber<Integer> ts2 = AssertSubscriber.create(0);
 
-		UnicastProcessor<Integer> up = UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(8).get()).build();
+		UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(QueueSupplier.<Integer>get(8).get()).build();
 		up.onNext(1);
 		up.onNext(2);
 		up.onNext(3);

File: src/test/java/reactor/core/publisher/UnicastProcessorTest.java
Patch:
@@ -32,7 +32,7 @@ public class UnicastProcessorTest {
     @Test
     public void secondSubscriberRejectedProperly() {
 
-        UnicastProcessor<Integer> up = UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
+        UnicastProcessor<Integer> up = UnicastProcessor.<Integer>builder().queue(new ConcurrentLinkedQueue<>()).build();
 
         up.subscribe();
 

File: src/test/java/reactor/core/publisher/scenarios/BurstyWorkQueueProcessorTests.java
Patch:
@@ -61,7 +61,7 @@ public void setup() {
 	@Test
 	@Ignore
 	public void test() throws Exception {
-		processor = WorkQueueProcessor.Builder.create().name("test-processor").bufferSize(RINGBUFFER_SIZE).build();
+		processor = WorkQueueProcessor.builder().name("test-processor").bufferSize(RINGBUFFER_SIZE).build();
 
 		Flux
 				.create((emitter) -> burstyProducer(emitter, PRODUCED_MESSAGES_COUNT, BURST_SIZE))

File: src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -84,7 +84,7 @@ public void testMerge1ToN() throws Exception {
 	public Flux<SensorData> sensorOdd() {
 		if (sensorOdd == null) {
 			// this is the stream we publish odd-numbered events to
-			this.sensorOdd = TopicProcessor.Builder.<SensorData>create().name("odd").build();
+			this.sensorOdd = TopicProcessor.<SensorData>builder().name("odd").build();
 
 			// add substream to "master" list
 			//allSensors().add(sensorOdd.reduce(this::computeMin).timeout(1000));
@@ -96,7 +96,7 @@ public Flux<SensorData> sensorOdd() {
 	public Flux<SensorData> sensorEven() {
 		if (sensorEven == null) {
 			// this is the stream we publish even-numbered events to
-			this.sensorEven = TopicProcessor.Builder.<SensorData>create().name("even").build();
+			this.sensorEven = TopicProcessor.<SensorData>builder().name("even").build();
 
 			// add substream to "master" list
 			//allSensors().add(sensorEven.reduce(this::computeMin).timeout(1000));

File: src/test/java/reactor/core/publisher/scenarios/ConsistentProcessorTests.java
Patch:
@@ -136,8 +136,8 @@ public Set<Integer> findDuplicates(List<Integer> listContainingDuplicates) {
 	}
 
 	private void setupPipeline() {
-		processor = TopicProcessor.Builder.<String>create().autoCancel(false).build();
-		workProcessor = WorkQueueProcessor.Builder.<String>create().autoCancel(false).build();
+		processor = TopicProcessor.<String>builder().autoCancel(false).build();
+		workProcessor = WorkQueueProcessor.<String>builder().autoCancel(false).build();
 		processor.subscribe(workProcessor);
 	}
 

File: src/test/java/reactor/core/publisher/scenarios/FizzBuzzTests.java
Patch:
@@ -78,7 +78,7 @@ public void indexBugTest() throws InterruptedException {
 
 		//this line causes an java.lang.ArrayIndexOutOfBoundsException unless there is a break point in ZipAction
 		// .createSubscriber()
-		TopicProcessor<String> ring = TopicProcessor.Builder.<String>create().name("test").bufferSize(1024).build();
+		TopicProcessor<String> ring = TopicProcessor.<String>builder().name("test").bufferSize(1024).build();
 
 //        EmitterProcessor<String> ring = EmitterProcessor.create();
 

File: src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -29,7 +29,7 @@ public class EmitterProcessorVerification extends AbstractProcessorVerification
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
-		return EmitterProcessor.Builder.<Long>create().bufferSize(bufferSize).build();
+		return EmitterProcessor.<Long>builder().bufferSize(bufferSize).build();
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java
Patch:
@@ -43,7 +43,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 		Flux<String> otherStream = Flux.just("test", "test2", "test3");
 		System.out.println("Providing new downstream");
 		FluxProcessor<Integer, Integer> p =
-				WorkQueueProcessor.Builder.<Integer>create().name("fluxion-raw-fork").bufferSize(bufferSize).build();
+				WorkQueueProcessor.<Integer>builder().name("fluxion-raw-fork").bufferSize(bufferSize).build();
 
 		cumulated.set(0);
 		cumulatedJoin.set(0);
@@ -63,7 +63,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 						                          combinator))
 				                          .doOnNext(this::monitorThreadUse))
 				 .doOnNext(array -> cumulatedJoin.getAndIncrement())
-				 .subscribeWith(TopicProcessor.Builder.<Integer>create().name("fluxion-raw-join").bufferSize(bufferSize).build())
+				 .subscribeWith(TopicProcessor.<Integer>builder().name("fluxion-raw-join").bufferSize(bufferSize).build())
 				 .doOnError(Throwable::printStackTrace)
 				 .awaitOnSubscribe());
 	}

File: src/test/java/reactor/core/publisher/tck/TopicProcessorVerification.java
Patch:
@@ -27,7 +27,7 @@ public class TopicProcessorVerification extends AbstractProcessorVerification {
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
-		return TopicProcessor.Builder.<Long>create().name("rb-async").bufferSize(bufferSize).build();
+		return TopicProcessor.<Long>builder().name("rb-async").bufferSize(bufferSize).build();
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/WorkQueueProcessorVerification.java
Patch:
@@ -28,7 +28,7 @@ public class WorkQueueProcessorVerification extends AbstractProcessorVerificatio
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
 		System.out.println("new processor");
-		return  WorkQueueProcessor.Builder.<Long>create().name("rb-work").bufferSize(bufferSize).build();
+		return  WorkQueueProcessor.<Long>builder().name("rb-work").bufferSize(bufferSize).build();
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/MonoZipTest.java
Patch:
@@ -34,9 +34,8 @@ public void normal() {
 
 	@Test
 	public void normalIterable() {
-		StepVerifier.create(Mono.zip(args -> (int) args[0] + (int) args[1],
-				Arrays.asList(Mono.just(1),
-				Mono.just(2))))
+		StepVerifier.create(Mono.zip(Arrays.asList(Mono.just(1), Mono.just(2)),
+				args -> (int) args[0] + (int) args[1]))
 		            .expectNext(3)
 		            .verifyComplete();
 	}

File: src/main/java/reactor/core/publisher/InnerProducer.java
Patch:
@@ -35,8 +35,8 @@ interface InnerProducer<O>
 	Subscriber<? super O> actual();
 
 	@Override
-	default Object scan(Attr key){
-		if(key == Attr.ACTUAL){
+	default Object scanUnsafe(Attr key){
+		if (key == ScannableAttr.ACTUAL) {
 			return actual();
 		}
 		return null;

File: src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -86,9 +86,8 @@ public String toString() {
 	}
 
 	@Override
-	public Object scan(Scannable.Attr key) {
-		switch (key){
-			case PARENT:
+	public Object scanUnsafe(Attr key) {
+		if (key == ScannableAttr.PARENT) {
 				return source;
 		}
 		return null;

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1925,7 +1925,7 @@ public final T blockFirst(Duration timeout) {
 
 	/**
 	 * Subscribe to this {@link Flux} and <strong>block indefinitely</strong>
-	 * until the upstream signals its first value or completes. Returns that value,
+	 * until the upstream signals its last value or completes. Returns that value,
 	 * or null if the Flux completes empty. In case the Flux errors, the original
 	 * exception is thrown (wrapped in a {@link RuntimeException} if it was a checked
 	 * exception).
@@ -1944,7 +1944,7 @@ public final T blockLast() {
 
 	/**
 	 * Subscribe to this {@link Flux} and <strong>block</strong> until the upstream
-	 * signals its first value, completes or a timeout expires. Returns that value,
+	 * signals its last value, completes or a timeout expires. Returns that value,
 	 * or null if the Flux completes empty. In case the Flux errors, the original
 	 * exception is thrown (wrapped in a {@link RuntimeException} if it was a checked
 	 * exception). If the provided timeout expires,a {@link RuntimeException} is thrown.

File: src/test/java/reactor/core/SequentialDisposableTest.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *        http://www.apache.org/licenses/LICENSE-2.0
+ *       http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -24,8 +24,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.junit.MockitoJUnitRunner;
-import reactor.core.Disposable;
-import reactor.core.Disposables;
 import reactor.core.Disposables.SequentialDisposable;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3520,7 +3520,7 @@ public final Flux<T> doOnTerminate(Runnable onTerminate) {
 	}
 
 	/**
-	 * Add behavior (side-effect) triggered <strong>after</strong>the {@link Flux} terminates for any reason,
+	 * Add behavior (side-effect) triggered <strong>after</strong> the {@link Flux} terminates for any reason,
 	 * including cancellation. The terminating event ({@link SignalType#ON_COMPLETE},
 	 * {@link SignalType#ON_ERROR} and {@link SignalType#CANCEL}) is passed to the consumer,
 	 * which is executed after the signal has been passed downstream.

File: src/test/java/reactor/core/publisher/FluxBufferTimeOrSizeTest.java
Patch:
@@ -56,4 +56,5 @@ public void bufferWithTimeoutAccumulateOnTimeOrSize2() {
 		            .assertNext(s -> assertThat(s).containsExactly(6))
 		            .verifyComplete();
 	}
+
 }
\ No newline at end of file

File: src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -278,8 +278,8 @@ public void sinkApiErrorAfterErrorBubblesAndDrops() {
 		});
 
 		Assertions.assertThatExceptionOfType(RuntimeException.class)
-		          .isThrownBy(secondIsError::subscribe)
-		          .matches(Exceptions::isBubbling)
+		          .isThrownBy(() -> secondIsError.subscribe(v -> {}, e -> {}))
+		          .matches(Exceptions::isBubbling, "exception is bubbling")
 		          .satisfies(e -> assertThat(Exceptions.unwrap(e)).hasMessage("boom2"));
 
 		StepVerifier.create(secondIsError)

File: src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -319,10 +319,11 @@ public void bufferWillAcumulateMultipleListsOfValues() {
 		//non overlapping buffers
 		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.create();
 
-		Mono<List<List<Integer>>> res = numbers.buffer(boundaryFlux)
+		MonoProcessor<List<List<Integer>>> res = numbers.buffer(boundaryFlux)
 		                                       .buffer()
 		                                       .publishNext()
-		                                       .subscribe();
+		                                       .toProcessor();
+		res.subscribe();
 
 		numbers.onNext(1);
 		numbers.onNext(2);

File: src/test/java/reactor/core/publisher/FluxBufferWhenTest.java
Patch:
@@ -138,10 +138,11 @@ public void bufferWillAcumulateMultipleListsOfValuesOverlap() {
 		//"overlapping buffers"
 		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.create();
 
-		Mono<List<List<Integer>>> res = numbers.bufferWhen(bucketOpening, u -> boundaryFlux )
+		MonoProcessor<List<List<Integer>>> res = numbers.bufferWhen(bucketOpening, u -> boundaryFlux )
 		                                       .buffer()
 		                                       .publishNext()
-		                                       .subscribe();
+		                                       .toProcessor();
+		res.subscribe();
 
 		numbers.onNext(1);
 		numbers.onNext(2);

File: src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -223,11 +223,12 @@ public void windowWillAcumulateMultipleListsOfValues() {
 		//non overlapping buffers
 		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.create();
 
-		Mono<List<List<Integer>>> res = numbers.window(boundaryFlux)
+		MonoProcessor<List<List<Integer>>> res = numbers.window(boundaryFlux)
 		                                       .concatMap(Flux::buffer)
 		                                       .buffer()
 		                                       .publishNext()
-		                                       .subscribe();
+		                                       .toProcessor();
+		res.subscribe();
 
 		numbers.onNext(1);
 		numbers.onNext(2);

File: src/test/java/reactor/core/publisher/FluxWindowWhenTest.java
Patch:
@@ -175,11 +175,12 @@ public void windowWillAcumulateMultipleListsOfValuesOverlap() {
 		//"overlapping buffers"
 		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.create();
 
-		Mono<List<List<Integer>>> res = numbers.windowWhen(bucketOpening, u -> boundaryFlux )
+		MonoProcessor<List<List<Integer>>> res = numbers.windowWhen(bucketOpening, u -> boundaryFlux )
 		                                       .flatMap(Flux::buffer)
 		                                       .buffer()
 		                                       .publishNext()
-		                                       .subscribe();
+		                                       .toProcessor();
+		res.subscribe();
 
 		numbers.onNext(1);
 		numbers.onNext(2);

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1406,11 +1406,12 @@ public void multiplexUsingDispatchersAndSplit() throws Exception {
 
 		final Semaphore doneSemaphore = new Semaphore(0);
 
-		final Mono<List<String>> listPromise = joinStream.flatMap(Flux::fromIterable)
+		final MonoProcessor<List<String>> listPromise = joinStream.flatMap(Flux::fromIterable)
 		                                                 .log("resultStream")
 		                                                 .collectList()
 		                                                 .doOnTerminate((v, e) -> doneSemaphore.release())
-		                                                 .subscribe();
+		                                                 .toProcessor();
+		listPromise.subscribe();
 
 		forkEmitterProcessor.onNext(1);
 		forkEmitterProcessor.onNext(2);

File: src/test/java/reactor/core/publisher/FluxConcatMapTest.java
Patch:
@@ -564,7 +564,7 @@ public void syncFusionMapToNullFilter() {
 	public void asyncFusionMapToNull() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor<Integer> up = UnicastProcessor.create(QueueSupplier.<Integer>get(2).get());
+		UnicastProcessor<Integer> up = UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build();
 		up.onNext(1);
 		up.onNext(2);
 		up.onComplete();
@@ -583,7 +583,7 @@ public void asyncFusionMapToNullFilter() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(QueueSupplier.<Integer>get(2).get());
+				UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build();
 		up.onNext(1);
 		up.onNext(2);
 		up.onComplete();

File: src/test/java/reactor/core/publisher/FluxFilterTest.java
Patch:
@@ -173,7 +173,7 @@ public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
+				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
 
 		up.filter(v -> (v & 1) == 0)
 		  .subscribe(ts);
@@ -193,7 +193,7 @@ public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
+				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
 
 		Flux.just(1)
 		    .hide()
@@ -219,7 +219,7 @@ public void asyncFusionBackpressured2() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
+				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
 
 		Flux.just(1)
 		    .hide()

File: src/test/java/reactor/core/publisher/FluxMapTest.java
Patch:
@@ -138,7 +138,7 @@ public void asyncFusion() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
+				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
 
 		up.map(v -> v + 1)
 		  .subscribe(ts);
@@ -158,7 +158,7 @@ public void asyncFusionBackpressured() {
 		AssertSubscriber<Object> ts = AssertSubscriber.create(1);
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(new ConcurrentLinkedQueue<>());
+				UnicastProcessor.Builder.<Integer>create().queue(new ConcurrentLinkedQueue<>()).build();
 
 		Flux.just(1)
 		    .hide()

File: src/test/java/reactor/core/publisher/FluxPeekFuseableTest.java
Patch:
@@ -488,7 +488,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.create(QueueSupplier.<Integer>get(2).get())
+		UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build()
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -734,7 +734,7 @@ public void syncFusionAvailable() {
 	public void asyncFusionAvailable() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		UnicastProcessor.create(QueueSupplier.<Integer>get(2).get())
+		UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(2).get()).build()
 		                .doOnNext(v -> {
 		                })
 		                .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -149,7 +149,7 @@ public void subsequentSumAsync() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		UnicastProcessor<Integer> up =
-				UnicastProcessor.create(QueueSupplier.<Integer>get(16).get());
+				UnicastProcessor.Builder.<Integer>create().queue(QueueSupplier.<Integer>get(16).get()).build();
 
 		up.publish(o -> zip((Object[] a) -> (Integer) a[0] + (Integer) a[1], o, o.skip(1)))
 		  .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxZipTest.java
Patch:
@@ -62,13 +62,13 @@ protected List<Scenario<String, String>> scenarios_errorFromUpstreamFailure() {
 	/*@Test
 	public void constructors() {
 		ConstructorTestBuilder ctb = new ConstructorTestBuilder(FluxZip.class);
-		
+
 		ctb.addRef("sources", new Publisher[0]);
 		ctb.addRef("sourcesIterable", Collections.emptyList());
 		ctb.addRef("queueSupplier", (Supplier<Queue<Object>>)() -> new ConcurrentLinkedQueue<>());
 		ctb.addInt("prefetch", 1, Integer.MAX_VALUE);
 		ctb.addRef("zipper", (Function<Object[], Object>)v -> v);
-		
+
 		ctb.test();
 	}
 	*/

File: src/test/java/reactor/core/publisher/scenarios/BurstyWorkQueueProcessorTests.java
Patch:
@@ -61,7 +61,7 @@ public void setup() {
 	@Test
 	@Ignore
 	public void test() throws Exception {
-		processor = WorkQueueProcessor.create("test-processor", RINGBUFFER_SIZE);
+		processor = WorkQueueProcessor.Builder.create().name("test-processor").bufferSize(RINGBUFFER_SIZE).build();
 
 		Flux
 				.create((emitter) -> burstyProducer(emitter, PRODUCED_MESSAGES_COUNT, BURST_SIZE))

File: src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -84,7 +84,7 @@ public void testMerge1ToN() throws Exception {
 	public Flux<SensorData> sensorOdd() {
 		if (sensorOdd == null) {
 			// this is the stream we publish odd-numbered events to
-			this.sensorOdd = TopicProcessor.create("odd");
+			this.sensorOdd = TopicProcessor.Builder.<SensorData>create().name("odd").build();
 
 			// add substream to "master" list
 			//allSensors().add(sensorOdd.reduce(this::computeMin).timeout(1000));
@@ -96,7 +96,7 @@ public Flux<SensorData> sensorOdd() {
 	public Flux<SensorData> sensorEven() {
 		if (sensorEven == null) {
 			// this is the stream we publish even-numbered events to
-			this.sensorEven = TopicProcessor.create("even");
+			this.sensorEven = TopicProcessor.Builder.<SensorData>create().name("even").build();
 
 			// add substream to "master" list
 			//allSensors().add(sensorEven.reduce(this::computeMin).timeout(1000));

File: src/test/java/reactor/core/publisher/scenarios/ConsistentProcessorTests.java
Patch:
@@ -136,8 +136,8 @@ public Set<Integer> findDuplicates(List<Integer> listContainingDuplicates) {
 	}
 
 	private void setupPipeline() {
-		processor = TopicProcessor.create(false);
-		workProcessor = WorkQueueProcessor.create(false);
+		processor = TopicProcessor.Builder.<String>create().autoCancel(false).build();
+		workProcessor = WorkQueueProcessor.Builder.<String>create().autoCancel(false).build();
 		processor.subscribe(workProcessor);
 	}
 

File: src/test/java/reactor/core/publisher/scenarios/FizzBuzzTests.java
Patch:
@@ -78,7 +78,7 @@ public void indexBugTest() throws InterruptedException {
 
 		//this line causes an java.lang.ArrayIndexOutOfBoundsException unless there is a break point in ZipAction
 		// .createSubscriber()
-		TopicProcessor<String> ring = TopicProcessor.create("test", 1024);
+		TopicProcessor<String> ring = TopicProcessor.Builder.<String>create().name("test").bufferSize(1024).build();
 
 //        EmitterProcessor<String> ring = EmitterProcessor.create();
 

File: src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -29,7 +29,7 @@ public class EmitterProcessorVerification extends AbstractProcessorVerification
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
-		return EmitterProcessor.create(bufferSize);
+		return EmitterProcessor.Builder.<Long>create().bufferSize(bufferSize).build();
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java
Patch:
@@ -43,7 +43,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 		Flux<String> otherStream = Flux.just("test", "test2", "test3");
 		System.out.println("Providing new downstream");
 		FluxProcessor<Integer, Integer> p =
-				WorkQueueProcessor.create("fluxion-raw-fork", bufferSize);
+				WorkQueueProcessor.Builder.<Integer>create().name("fluxion-raw-fork").bufferSize(bufferSize).build();
 
 		cumulated.set(0);
 		cumulatedJoin.set(0);
@@ -63,7 +63,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 						                          combinator))
 				                          .doOnNext(this::monitorThreadUse))
 				 .doOnNext(array -> cumulatedJoin.getAndIncrement())
-				 .subscribeWith(TopicProcessor.create("fluxion-raw-join", bufferSize))
+				 .subscribeWith(TopicProcessor.Builder.<Integer>create().name("fluxion-raw-join").bufferSize(bufferSize).build())
 				 .doOnError(Throwable::printStackTrace)
 				 .awaitOnSubscribe());
 	}

File: src/test/java/reactor/core/publisher/tck/TopicProcessorVerification.java
Patch:
@@ -27,7 +27,7 @@ public class TopicProcessorVerification extends AbstractProcessorVerification {
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
-		return TopicProcessor.create("rb-async", bufferSize);
+		return TopicProcessor.Builder.<Long>create().name("rb-async").bufferSize(bufferSize).build();
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/WorkQueueProcessorVerification.java
Patch:
@@ -28,7 +28,7 @@ public class WorkQueueProcessorVerification extends AbstractProcessorVerificatio
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
 		System.out.println("new processor");
-		return  WorkQueueProcessor.create("rb-work", bufferSize);
+		return  WorkQueueProcessor.Builder.<Long>create().name("rb-work").bufferSize(bufferSize).build();
 	}
 
 	@Override

File: src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -190,7 +190,7 @@ public Disposable schedule(Runnable task, long delay, TimeUnit unit) {
 			try {
 				Future<?> f;
 				if (delay <= 0L) {
-					f = exec.submit(task);
+					f = exec.submit(sr);
 				}
 				else {
 					f = exec.schedule(sr, delay, unit);

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5151,7 +5151,8 @@ public final Flux<T> repeat(long numRepeat, BooleanSupplier predicate) {
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.6.RELEASE/src/docs/marble/repeatwhen.png" alt="">
 	 *
 	 * @param repeatFactory the {@link Function} that returns the associated {@link Publisher}
-	 * companion, given a {@link Flux} that signals each onComplete as a 0-based incrementing {@link Long}.
+	 * companion, given a {@link Flux} that signals each onComplete as a {@link Long}
+	 * representing the number of source elements emitted in the latest attempt.
 	 *
 	 * @return a {@link Flux} that repeats on onComplete when the companion {@link Publisher} produces an
 	 * onNext signal

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2351,7 +2351,8 @@ public final Flux<T> repeat(long numRepeat, BooleanSupplier predicate) {
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.6.RELEASE/src/docs/marble/repeatwhen.png" alt="">
 	 *
 	 * @param repeatFactory the {@link Function} that returns the associated {@link Publisher}
-	 * companion, given a {@link Flux} that signals each onComplete as a 0-based incrementing {@link Long}.
+	 * companion, given a {@link Flux} that signals each onComplete as a {@link Long}
+	 * representing the number of source elements emitted in the latest attempt (0 or 1).
 	 *
 	 * @return a {@link Flux} that repeats on onComplete when the companion {@link Publisher} produces an
 	 * onNext signal

File: src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -191,7 +191,7 @@ public T next() {
 				if (v == null) {
 					run();
 
-					throw new IllegalStateException("Queue empty?!");
+					throw new IllegalStateException("Queue is empty: Expected one element to be available from the Reactive Streams source.");
 				}
 
 				long p = produced + 1;
@@ -221,7 +221,7 @@ public void onNext(T t) {
 				Operators.terminate(S, this);
 
 				onError(Operators.onOperatorError(null,
-						Exceptions.failWithOverflow("Queue is full?!"),
+						Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL),
 						t));
 			}
 			else {

File: src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -313,7 +313,7 @@ void innerValue(int index, T value) {
 							new SourceAndArray(subscribers[index], os.clone());
 
 					if (!queue.offer(sa)) {
-						innerError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!")));
+						innerError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL)));
 						return;
 					}
 

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -236,7 +236,7 @@ public void onNext(T t) {
 				drain();
 			}
 			else if (!queue.offer(t)) {
-				onError(Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t));
+				onError(Operators.onOperatorError(s, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 			}
 			else {
 				drain();
@@ -579,7 +579,7 @@ public void onNext(T t) {
 				drain();
 			}
 			else if (!queue.offer(t)) {
-				onError(Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t));
+				onError(Operators.onOperatorError(s, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 			}
 			else {
 				drain();

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -760,7 +760,7 @@ void innerError(FlatMapInner<R> inner, Throwable e) {
 
 		boolean failOverflow(R v, Subscription toCancel){
 			Throwable e = Operators.onOperatorError(toCancel,
-					Exceptions.failWithOverflow("Scalar queue full?!"),
+					Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL),
 					v);
 
 			if (!Exceptions.addThrowable(ERROR, this, e)) {

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -234,7 +234,7 @@ else if (m == Fuseable.ASYNC) {
 		public void onNext(T t) {
 			if (fusionMode != Fuseable.ASYNC) {
 				if (!queue.offer(t)) {
-					onError(Operators.onOperatorError(s,Exceptions.failWithOverflow("Queue is full?!")));
+					onError(Operators.onOperatorError(s,Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL)));
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -669,7 +669,7 @@ public void onNext(V t) {
 			Subscriber<? super V> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!"), t));
+				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 				return;
 			}
 			if (outputFused) {

File: src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -300,7 +300,7 @@ void innerNext(MergeSequentialInner<R> inner, R value) {
 			}
 			else {
 				inner.cancel();
-				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow("Queue is full?!"), value));
+				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), value));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -247,7 +247,7 @@ public void onNext(T t) {
 
 			if (!queue.offer(t)) {
 				Throwable ex = Operators.onOperatorError(s,
-						Exceptions.failWithOverflow("Queue is full?!"),
+						Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL),
 						t);
 				if (!Exceptions.addThrowable(ERROR, this, ex)) {
 					Operators.onErrorDropped(ex);

File: src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -254,7 +254,7 @@ public void onNext(T t) {
 			if (sourceMode != Fuseable.ASYNC) {
 				if (!queue.offer(t)) {
 					onError(Operators.onOperatorError(s,
-							Exceptions.failWithOverflow("Queue full?!"),
+							Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL),
 							t));
 					return;
 				}

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -224,7 +224,7 @@ public void onNext(T t) {
 			}
 			if (!queue.offer(t)) {
 				error = Operators.onOperatorError(s,
-						Exceptions.failWithOverflow("Queue is full?!"),
+						Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL),
 						t);
 				done = true;
 			}
@@ -711,7 +711,7 @@ public void onNext(T t) {
 				return;
 			}
 			if (!queue.offer(t)) {
-				error = Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t);
+				error = Operators.onOperatorError(s, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t);
 				done = true;
 			}
 			if (trySchedule() == Scheduler.REJECTED) {

File: src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -202,7 +202,7 @@ void offerNewWindow(T key, T emitInNewWindow) {
 				window = g;
 
 				if (!queue.offer(g)) {
-					onError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!"), emitInNewWindow));
+					onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), emitInNewWindow));
 					return;
 				}
 				drain();
@@ -720,7 +720,7 @@ public void onNext(T t) {
 			Subscriber<? super T> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!"), t));
+				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 				return;
 			}
 			if (enableOperatorFusion) {

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -864,7 +864,7 @@ else if (m == Fuseable.ASYNC) {
 		public void onNext(T t) {
 			if (sourceMode != ASYNC) {
 				if (!queue.offer(t)) {
-					onError(Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t));
+					onError(Operators.onOperatorError(s, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -330,7 +330,7 @@ public void onSubscribe(Subscription s) {
 		public void onNext(T t) {
 			if (!queue.offer(t)) {
 				onError(Operators.onOperatorError(cachedSubscription, Exceptions
-						.failWithOverflow("Queue is full?!"), t));
+						.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 				return;
 			}
 			parent.drain();

File: src/main/java/reactor/core/publisher/ParallelMergeSequential.java
Patch:
@@ -183,7 +183,7 @@ void onNext(MergeSequentialInner<T> inner, T value) {
 					Queue<T> q = inner.getQueue(queueSupplier);
 
 					if(!q.offer(value)){
-						onError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!"), value));
+						onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), value));
 						return;
 					}
 				}
@@ -194,7 +194,7 @@ void onNext(MergeSequentialInner<T> inner, T value) {
 				Queue<T> q = inner.getQueue(queueSupplier);
 
 				if(!q.offer(value)){
-					onError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!"), value));
+					onError(Operators.onOperatorError(this, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), value));
 					return;
 				}
 

File: src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -228,7 +228,7 @@ public void onNext(T t) {
 			}
 			if (sourceMode == Fuseable.NONE) {
 				if (!queue.offer(t)) {
-					onError(Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t));
+					onError(Operators.onOperatorError(s, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t));
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -46,7 +46,6 @@ public interface FluxSink<T> {
      * Try emitting, might throw an unchecked exception.
      * @see Subscriber#onNext(Object)
      * @param t the value to emit, not null
-     * Will return this sink from 3.1 (now void)
      */
     FluxSink<T> next(T t);
 

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -331,9 +331,9 @@ public void testMultiReceiver() throws Exception {
 		try {
 
 			ConnectableFlux<?> t = Flux.empty()
-			    .then(() -> {
+			    .then(Mono.defer(() -> {
 				    throw new RuntimeException();
-			    }).flux().publish();
+			    })).flux().publish();
 
 			t.map(d -> d).subscribe(null,
 					e -> Assert.assertTrue(e.getSuppressed()[0].getMessage().contains

File: src/test/java/reactor/core/publisher/FluxConcatArrayTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -212,14 +212,14 @@ public void thenManyThenMany(){
 
 	@Test
 	public void thenManySupplier(){
-		StepVerifier.create(Flux.just(1, 2, 3).thenMany(() -> Flux.just("test", "test2")))
+		StepVerifier.create(Flux.just(1, 2, 3).thenMany(Flux.defer(() -> Flux.just("test", "test2"))))
 		            .expectNext("test", "test2")
 		            .verifyComplete();
 	}
 
 	@Test
 	public void thenManyError(){
-		StepVerifier.create(Flux.error(new Exception("test")).thenMany(() -> Flux.just(4, 5, 6)))
+		StepVerifier.create(Flux.error(new Exception("test")).thenMany(Flux.just(4, 5, 6)))
 	                .verifyErrorMessage("test");
 	}
 

File: src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -111,7 +111,7 @@ public void testDoOnEachSignalToSubscriber() {
 	@Test
 	public void testMonoThenManySupplier() {
 		AssertSubscriber<String> ts = AssertSubscriber.create();
-		Flux<String> test = Mono.just(1).thenMany(() -> Flux.just("A", "B"));
+		Flux<String> test = Mono.just(1).thenMany(Flux.defer(() -> Flux.just("A", "B")));
 
 		test.subscribe(ts);
 		ts.assertValues("A", "B");
@@ -147,7 +147,7 @@ public void promiseOnAfter() throws Exception {
 			return "hello";
 		})
 		               .subscribeOn(Schedulers.parallel())
-		               .then(() -> Mono.just("world"))
+		               .then(Mono.just("world"))
 		               .block();
 		assertThat("Alternate mono not seen", h, is("world"));
 	}

File: src/main/java/reactor/core/publisher/FluxBufferWhen.java
Patch:
@@ -46,7 +46,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxBufferStartEnd<T, U, V, C extends Collection<? super T>>
+final class FluxBufferWhen<T, U, V, C extends Collection<? super T>>
 		extends FluxSource<T, C> {
 
 	final Publisher<U> start;
@@ -57,7 +57,7 @@ final class FluxBufferStartEnd<T, U, V, C extends Collection<? super T>>
 
 	final Supplier<? extends Queue<C>> queueSupplier;
 
-	FluxBufferStartEnd(Flux<? extends T> source,
+	FluxBufferWhen(Flux<? extends T> source,
 			Publisher<U> start,
 			Function<? super U, ? extends Publisher<V>> end,
 			Supplier<C> bufferSupplier,

File: src/main/java/reactor/core/publisher/FluxWindowWhen.java
Patch:
@@ -42,7 +42,7 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxWindowStartEnd<T, U, V> extends FluxSource<T, Flux<T>> {
+final class FluxWindowWhen<T, U, V> extends FluxSource<T, Flux<T>> {
 
 	final Publisher<U> start;
 
@@ -52,7 +52,7 @@ final class FluxWindowStartEnd<T, U, V> extends FluxSource<T, Flux<T>> {
 
 	final Supplier<? extends Queue<T>> processorQueueSupplier;
 
-	FluxWindowStartEnd(Flux<? extends T> source,
+	FluxWindowWhen(Flux<? extends T> source,
 			Publisher<U> start,
 			Function<? super U, ? extends Publisher<V>> end,
 			Supplier<? extends Queue<Object>> drainQueueSupplier,

File: src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -775,7 +775,7 @@ private void printAndAssert(Throwable t, boolean checkForAssemblySuppressed) {
 				assertThat(withSuppressed.getSuppressed()).hasSize(1);
 				assertThat(withSuppressed.getSuppressed()[0])
 						.hasMessageStartingWith("\nAssembly trace from producer [reactor.core.publisher.MonoSingle] :")
-						.hasMessageEndingWith("Flux.single(GuideTests.java:719)\n");
+						.hasMessageEndingWith("Flux.single(GuideTests.java:733)\n");
 			});
 		}
 	}

File: src/main/java/reactor/core/publisher/FluxOnErrorResume.java
Patch:
@@ -31,11 +31,11 @@
  *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxResume<T> extends FluxSource<T, T> {
+final class FluxOnErrorResume<T> extends FluxSource<T, T> {
 
 	final Function<? super Throwable, ? extends Publisher<? extends T>> nextFactory;
 
-	FluxResume(Flux<? extends T> source,
+	FluxOnErrorResume(Flux<? extends T> source,
 			Function<? super Throwable, ? extends Publisher<? extends T>> nextFactory) {
 		super(source);
 		this.nextFactory = Objects.requireNonNull(nextFactory, "nextFactory");

File: src/main/java/reactor/core/publisher/MonoOnErrorResume.java
Patch:
@@ -28,11 +28,11 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoSwitchOnError<T> extends MonoSource<T, T> {
+final class MonoOnErrorResume<T> extends MonoSource<T, T> {
 
 	final Function<? super Throwable, ? extends Publisher<? extends T>> nextFactory;
 
-	MonoSwitchOnError(Mono<? extends T> source,
+	MonoOnErrorResume(Mono<? extends T> source,
 						   Function<? super Throwable, ? extends Mono<? extends T>>
 								   nextFactory) {
 		super(source);
@@ -41,6 +41,6 @@ final class MonoSwitchOnError<T> extends MonoSource<T, T> {
 
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		source.subscribe(new FluxResume.ResumeSubscriber<>(s, nextFactory));
+		source.subscribe(new FluxOnErrorResume.ResumeSubscriber<>(s, nextFactory));
 	}
 }

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -155,7 +155,7 @@ public void verboseExtension() {
 				new String[]{"FluxJust: 1", "{ \"operator\" : \"MapFuseable\" }: 2",
 						"{ \"operator\" : \"PeekFuseable\" }! false",
 						"{ \"operator\" : \"CollectList\" }! true", "MonoJust: [2]",
-						"{ \"operator\" : \"SwitchOnError\" }: [2]"});
+						"{ \"operator\" : \"OnErrorResume\" }: [2]"});
 
 		q.clear();
 
@@ -172,7 +172,7 @@ public void verboseExtension() {
 				new String[]{"FluxJust: 1", "{ \"operator\" : \"MapFuseable\" }: 2",
 						"{ \"operator\" : \"PeekFuseable\" }! false",
 						"{ \"operator\" : \"CollectList\" }! false", "MonoJust: [2]",
-						"{ \"operator\" : \"SwitchOnError\" }: [2]"});
+						"{ \"operator\" : \"OnErrorResume\" }: [2]"});
 
 		q.clear();
 

File: src/main/java/reactor/core/publisher/MonoSwitchIfEmpty.java
Patch:
@@ -25,11 +25,11 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoOtherwiseIfEmpty<T> extends MonoSource<T, T> {
+final class MonoSwitchIfEmpty<T> extends MonoSource<T, T> {
 
     final Mono<? extends T> other;
 
-	public MonoOtherwiseIfEmpty(Mono<? extends T> source, Mono<? extends T> other) {
+	public MonoSwitchIfEmpty(Mono<? extends T> source, Mono<? extends T> other) {
 		super(source);
 		this.other = Objects.requireNonNull(other, "other");
 	}

File: src/main/java/reactor/core/publisher/MonoSwitchOnError.java
Patch:
@@ -28,11 +28,11 @@
  * @param <T> the value type
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoOtherwise<T> extends MonoSource<T, T> {
+final class MonoSwitchOnError<T> extends MonoSource<T, T> {
 
 	final Function<? super Throwable, ? extends Publisher<? extends T>> nextFactory;
 
-	MonoOtherwise(Mono<? extends T> source,
+	MonoSwitchOnError(Mono<? extends T> source,
 						   Function<? super Throwable, ? extends Mono<? extends T>>
 								   nextFactory) {
 		super(source);

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -47,7 +47,7 @@ public interface FluxSink<T> {
      * @param t the value to emit, not null
      * Will return this sink from 3.1 (now void)
      */
-    void next(T t);
+    FluxSink<T> next(T t);
 
 	/**
 	 * The current outstanding request amount.

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -528,6 +528,7 @@ public static <F> boolean set(AtomicReferenceFieldUpdater<F, Subscription> field
 	 * @return true if successful, false if the target was not empty or has been cancelled
 	 */
 	public static <F> boolean setOnce(AtomicReferenceFieldUpdater<F, Subscription> field, F instance, Subscription s) {
+		Objects.requireNonNull(s, "subscription");
 		Subscription a = field.get(instance);
 		if (a == CancelledSubscription.INSTANCE) {
 			s.cancel();

File: src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -314,10 +314,10 @@ public void bufferWillSubdivideAnInputFluxTime2() {
 	@Test
 	public void bufferWillAcumulateMultipleListsOfValues() {
 		//given: "a source and a collected flux"
-		EmitterProcessor<Integer> numbers = EmitterProcessor.<Integer>create().connect();
+		EmitterProcessor<Integer> numbers = EmitterProcessor.create();
 
 		//non overlapping buffers
-		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.<Integer>create().connect();
+		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.create();
 
 		Mono<List<List<Integer>>> res = numbers.buffer(boundaryFlux)
 		                                       .buffer()

File: src/test/java/reactor/core/publisher/FluxPublishMulticastTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -191,7 +191,7 @@ public void cancelComposes2() {
 		sp.publish(o -> Flux.<Integer>empty())
 		  .subscribe(ts);
 
-		Assert.assertFalse("Still subscribed?", sp.downstreamCount() == 0);
+		Assert.assertFalse("Still subscribed?", sp.downstreamCount() == 1);
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,7 +34,6 @@ public void constructors() {
 	@Test
 	public void normal() {
 		EmitterProcessor<Integer> e = EmitterProcessor.create();
-		e.connect();
 
 		Flux<Integer> p = e.publish().refCount();
 		
@@ -75,7 +74,6 @@ public void normal() {
 	@Test
 	public void normalTwoSubscribers() {
 		EmitterProcessor<Integer> e = EmitterProcessor.create();
-		e.connect();
 
 		Flux<Integer> p = e.publish().refCount(2);
 		

File: src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -218,10 +218,10 @@ public void windowWillSubdivideAnInputFluxTime() {
 	@Test
 	public void windowWillAcumulateMultipleListsOfValues() {
 		//given: "a source and a collected flux"
-		EmitterProcessor<Integer> numbers = EmitterProcessor.<Integer>create().connect();
+		EmitterProcessor<Integer> numbers = EmitterProcessor.create();
 
 		//non overlapping buffers
-		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.<Integer>create().connect();
+		EmitterProcessor<Integer> boundaryFlux = EmitterProcessor.create();
 
 		Mono<List<List<Integer>>> res = numbers.window(boundaryFlux)
 		                                       .concatMap(Flux::buffer)

File: src/test/java/reactor/core/publisher/FluxZipTest.java
Patch:
@@ -432,8 +432,8 @@ public void pairWise2() {
 	public void multipleStreamValuesCanBeZipped() {
 //		"Multiple Stream"s values can be zipped"
 //		given: "source composables to merge, buffer and tap"
-		EmitterProcessor<Integer> source1 = EmitterProcessor.<Integer>create().connect();
-		EmitterProcessor<Integer> source2 = EmitterProcessor.<Integer>create().connect();
+		EmitterProcessor<Integer> source1 = EmitterProcessor.create();
+		EmitterProcessor<Integer> source2 = EmitterProcessor.create();
 		Flux<Integer> zippedFlux = Flux.zip(source1, source2, (t1, t2) -> t1 + t2);
 		AtomicReference<Integer> tap = new AtomicReference<>();
 		zippedFlux.subscribe(it -> tap.set(it));

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -534,7 +534,7 @@ public static <F> boolean setOnce(AtomicReferenceFieldUpdater<F, Subscription> f
 			return false;
 		}
 		if (a != null) {
-			a.cancel();
+			s.cancel();
 			reportSubscriptionSet();
 			return false;
 		}

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -280,7 +280,7 @@ public void testTraceComposed() throws Exception {
 		Hooks.onOperator(hooks -> hooks.operatorStacktrace());
 		try {
 			Mono.just(1)
-			    .then(d ->
+			    .flatMap(d ->
 				    Mono.error(new RuntimeException())
 			    )
 			    .filter(d -> true)
@@ -293,7 +293,7 @@ public void testTraceComposed() throws Exception {
 			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains
 					("HooksTest.java:"));
 			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains("|_\tMono" +
-					".then" +
+					".flatMap" +
 					"(HooksTest.java:"));
 			return;
 		}

File: src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -79,10 +79,10 @@ public void normal() {
 
 	Flux<Integer> flatMapScenario() {
 		return Flux.interval(Duration.ofSeconds(3))
-		    .flatMap(v -> Flux.fromIterable(Arrays.asList("A"))
+		           .flatMap(v -> Flux.fromIterable(Arrays.asList("A"))
 		                      .flatMap(w -> Mono.fromCallable(() -> Arrays.asList(1, 2))
 		                                        .subscribeOn(Schedulers.parallel())
-		                                        .flatMap(Flux::fromIterable))).log();
+		                                        .flatMapMany(Flux::fromIterable))).log();
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxMapSignalTest.java
Patch:
@@ -116,7 +116,7 @@ public void flatMapSignalError() {
 	@Test
 	public void flatMapSignal2() {
 		StepVerifier.create(Mono.just(1)
-		                        .flatMap(d -> Flux.just(d * 2),
+		                        .flatMapMany(d -> Flux.just(d * 2),
 				                        e -> Flux.just(99),
 				                        () -> Flux.just(10)))
 		            .expectNext(2, 10)

File: src/test/java/reactor/core/publisher/MonoFilterTest.java
Patch:
@@ -146,7 +146,7 @@ public void asyncFusionBackpressured() {
 
 		Mono.just(1)
 		    .hide()
-		    .then(w -> up.filter(v -> (v & 1) == 0))
+		    .flatMap(w -> up.filter(v -> (v & 1) == 0))
 		    .subscribe(ts);
 
 		up.onNext(2);

File: src/test/java/reactor/core/publisher/MonoProcessorTest.java
Patch:
@@ -184,7 +184,7 @@ public void MonoProcessoThenFulfill() {
 
 		mp.onNext(1);
 
-		MonoProcessor<Integer> mp2 = mp.then(s -> Mono.just(s * 2))
+		MonoProcessor<Integer> mp2 = mp.flatMap(s -> Mono.just(s * 2))
 		                               .subscribe();
 
 		assertThat(mp2.isTerminated()).isTrue();

File: src/test/java/reactor/core/publisher/MonoPublishMulticastTest.java
Patch:
@@ -89,12 +89,12 @@ public void cancelComposes2() {
 
     @Test
     public void syncCancelBeforeComplete() {
-        assertThat(Mono.just(Mono.just(1).publish(v -> v)).flatMap(v -> v).blockLast()).isEqualTo(1);
+        assertThat(Mono.just(Mono.just(1).publish(v -> v)).flatMapMany(v -> v).blockLast()).isEqualTo(1);
     }
 
     @Test
     public void normalCancelBeforeComplete() {
-        assertThat(Mono.just(Mono.just(1).hide().publish(v -> v)).flatMap(v -> v).blockLast()).isEqualTo(1);
+        assertThat(Mono.just(Mono.just(1).hide().publish(v -> v)).flatMapMany(v -> v).blockLast()).isEqualTo(1);
     }
 
 }

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -428,7 +428,7 @@ public void analyticsTest() throws Exception {
 								  .flatMap(w -> w.count().map(c -> Tuples.of(w.key(), c)))
 		                          .log("elapsed")
 		                          .collectSortedList((a, b) -> a.getT1().compareTo(b.getT1()))
-		                          .flatMap(Flux::fromIterable)
+		                          .flatMapMany(Flux::fromIterable)
 		                          .reduce(-1L, (acc, next) -> acc > 0l ? ((next.getT1() + acc) / 2) : next.getT1())
 		                          .log("reduced-elapsed")
 		                          .cache();

File: src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -158,7 +158,7 @@ public void promiseDelays() throws Exception {
 		                             .log("time1")
 		                             .map(d -> "Spring wins")
 		                             .or(Mono.delay(Duration.ofMillis(2000)).log("time2").map(d -> "Spring Reactive"))
-		                             .then(t -> Mono.just(t+ " world"))
+		                             .flatMap(t -> Mono.just(t+ " world"))
 		                             .elapsed()
 		                             .block();
 		assertThat("Alternate mono not seen", h.getT2(), is("Spring Reactive world"));

File: src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java
Patch:
@@ -66,7 +66,7 @@ public void sampleTest() throws Exception {
 		         .flatMap(s -> s.groupBy(w -> w)
 		                       .flatMap(w -> w.count().map(c -> Tuples.of(w.key(), c)))
 		                       .collectSortedList((a, b) -> -a.getT2().compareTo(b.getT2()))
-		                        .flatMap(Flux::fromIterable)
+		                        .flatMapMany(Flux::fromIterable)
 		                       .take(10)
 		                       .doAfterTerminate(() -> LOG.info("------------------------ window terminated" +
 						      "----------------------"))

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -6282,7 +6282,7 @@ public final Flux<Flux<T>> window(Duration timespan) {
 	/**
 	 * Split this {@link Flux} sequence into multiple {@link Flux} delimited by the given {@code timeshift}
 	 * period, starting from the first item.
-	 * Each {@link Flux} bucket will onComplete after {@code timespan} period has elpased.
+	 * Each {@link Flux} bucket will onComplete after {@code timespan} period has elapsed.
 	 *
 	 * <p>
 	 * When timeshift > timespan : dropping windows

File: src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -73,7 +73,7 @@ public static <E> DirectProcessor<E> create() {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -64,7 +64,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 

File: src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -65,7 +65,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 

File: src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -54,7 +54,7 @@ final class FluxBufferBoundary<T, U, C extends Collection<? super T>>
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -70,7 +70,7 @@ public enum Mode {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return 1; //this operator changes the downstream request to 1 in the source
 	}
 

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -70,7 +70,7 @@ final class FluxBufferStartEnd<T, U, V, C extends Collection<? super T>>
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -86,7 +86,7 @@ final class FluxCombineLatest<T, R> extends Flux<R> implements Fuseable {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return bufferSize;
 	}
 

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -103,7 +103,7 @@ static <T, R> Subscriber<T> subscriber(Subscriber<? super R> s,
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -41,7 +41,7 @@ final class FluxDelaySubscription<T, U> extends FluxSource<T, T> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -81,7 +81,7 @@ final class FluxFlatMap<T, R> extends FluxSource<T, R> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -62,7 +62,7 @@ final class FluxFlattenIterable<T, R> extends FluxSource<T, R> implements Fuseab
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -87,7 +87,7 @@ public void subscribe(Subscriber<? super GroupedFlux<K, V>> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -61,7 +61,7 @@ public void subscribe(Subscriber<? super O> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxOnBackpressureBufferStrategy.java
Patch:
@@ -59,7 +59,7 @@ public void subscribe(Subscriber<? super O> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -49,7 +49,7 @@ final class FluxOnBackpressureDrop<T> extends FluxSource<T, T> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -41,7 +41,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -126,7 +126,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -66,7 +66,7 @@ final class FluxPublishMulticast<T, R> extends FluxSource<T, R> implements Fusea
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -63,7 +63,7 @@ final class FluxPublishOn<T> extends FluxSource<T, T> implements Fuseable {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -55,7 +55,7 @@ final class FluxRefCount<T> extends Flux<T> implements Scannable, Fuseable {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 	

File: src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -68,7 +68,7 @@ final class FluxReplay<T> extends ConnectableFlux<T> implements Scannable, Fusea
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return history;
 	}
 

File: src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -53,7 +53,7 @@ final class FluxSample<T, U> extends FluxSource<T, T> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -60,7 +60,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -56,7 +56,7 @@ final class FluxSampleTimeout<T, U> extends FluxSource<T, T> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -67,7 +67,7 @@ final class FluxSwitchMap<T, R> extends FluxSource<T, R> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxTake.java
Patch:
@@ -57,7 +57,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -36,7 +36,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -42,7 +42,7 @@ final class FluxTakeUntilOther<T, U> extends FluxSource<T, T> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -57,7 +57,7 @@ final class FluxWindowBoundary<T, U> extends FluxSource<T, Flux<T>> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -94,7 +94,7 @@ public void subscribe(Subscriber<? super GroupedFlux<T, T>> s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/FluxWindowStartEnd.java
Patch:
@@ -67,7 +67,7 @@ final class FluxWindowStartEnd<T, U, V> extends FluxSource<T, Flux<T>> {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -101,7 +101,7 @@ <U> FluxZip(Publisher<? extends T> p1,
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -59,7 +59,7 @@ public Object scan(Attr key) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -67,7 +67,7 @@ public Object scan(Attr key) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelFlatMap.java
Patch:
@@ -72,7 +72,7 @@ public Object scan(Attr key) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -34,7 +34,7 @@ final class ParallelFluxHide<T> extends ParallelFlux<T> implements Scannable{
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 

File: src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -58,7 +58,7 @@ final class ParallelFluxOnAssembly<T> extends ParallelFlux<T>
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 

File: src/main/java/reactor/core/publisher/ParallelLog.java
Patch:
@@ -59,7 +59,7 @@ public int parallelism() {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 

File: src/main/java/reactor/core/publisher/ParallelMergeSort.java
Patch:
@@ -50,7 +50,7 @@ final class ParallelMergeSort<T> extends Flux<T> implements Scannable {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -84,7 +84,7 @@ public int parallelism() {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return source.getPrefetch();
 	}
 

File: src/main/java/reactor/core/publisher/ParallelReduceSeed.java
Patch:
@@ -60,7 +60,7 @@ public Object scan(Scannable.Attr key) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -86,7 +86,7 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -58,7 +58,7 @@ final class ParallelSource<T> extends ParallelFlux<T> implements Scannable {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return prefetch;
 	}
 

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -421,7 +421,7 @@ else if (Operators.validate(subscription, s)) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -610,7 +610,6 @@ public static <E> TopicProcessor<E> share(ExecutorService service,
 	 * internally on each subscription.
 	 * @param service A provided ExecutorService to manage threading infrastructure
 	 * @param requestTaskExecutor A provided ExecutorService to manage threading infrastructure.
-	 * @param service A provided ExecutorService to manage threading infrastructure
 	 * @param bufferSize A Backlog Size to mitigate slow subscribers
 	 * @param strategy A RingBuffer WaitStrategy to use instead of the default
 	 * blocking wait strategy.

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -293,7 +293,7 @@ public void onSubscribe(Subscription s) {
 	}
 
 	@Override
-	public long getPrefetch() {
+	public int getPrefetch() {
 		return Integer.MAX_VALUE;
 	}
 

File: src/test/java/reactor/core/publisher/FluxCreateTest.java
Patch:
@@ -46,7 +46,7 @@ public class FluxCreateTest {
 	public void normalBuffered() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 		Flux<Integer> source = Flux.<Signal<Integer>>create(e -> {
-			e.serialize().next(Signal.next(1));
+			e.next(Signal.next(1));
 			e.next(Signal.next(2));
 			e.next(Signal.next(3));
 			e.next(Signal.complete());

File: src/test/java/reactor/core/publisher/FluxProcessorTest.java
Patch:
@@ -121,10 +121,11 @@ public void testSubmitSession() throws Exception {
 		Scheduler scheduler = Schedulers.parallel();
 		processor.publishOn(scheduler)
 		         .delaySubscription(Duration.ofMillis(1000))
+		         .limitRate(1)
 		                                    .subscribe(d -> {
 			         count.incrementAndGet();
 			         latch.countDown();
-		         }, 1);
+		         });
 
 		BlockingSink<Integer> session = processor.connectSink();
 		long emission = session.submit(1);
@@ -189,7 +190,7 @@ public void testEmitter2() throws Throwable {
 			processor.publishOn(c)
 			         .doOnComplete(latch::countDown)
 			         .doOnNext(d -> latch.countDown())
-			         .subscribe(Integer.MAX_VALUE);
+			         .subscribe();
 		}
 
 		BlockingSink<Integer> session = processor.connectSink();

File: src/test/java/reactor/core/publisher/loop/FluxPublishOnLoop.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -116,7 +116,7 @@ public void crossRangePerfDefaultLoop2() {
 		for (int j = 1; j < 256; j *= 2) {
 
 			Flux<Integer> source = Flux.range(1, count)
-			                           .flatMap(v -> Flux.range(v, 2), false, 128, j)
+			                           .flatMap(v -> Flux.range(v, 2), 128, j)
 			                           .publishOn(scheduler);
 
 			StepVerifier.Step<Integer> v = StepVerifier.create(source)

File: src/main/java/reactor/core/publisher/MonoFilterWhen.java
Patch:
@@ -208,7 +208,7 @@ public Object scan(Attr key) {
 				case PARENT:
 					return upstream;
 				case TERMINATED:
-					return asyncFilter != null ? super.scan(Attr.TERMINATED) : asyncFilter.scan(Attr.TERMINATED);
+					return asyncFilter != null ? asyncFilter.scan(Attr.TERMINATED) : super.scan(Attr.TERMINATED);
 				default: //CANCELLED, PREFETCH
 					return super.scan(key);
 			}

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -284,7 +284,7 @@ static long getAndSub(RingBuffer.Sequence sequence, long toSub) {
 	}
 
 	@Override
-	public Object upstream() {
+	public Subscription upstream() {
 		return upstreamSubscription;
 	}
 

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -795,7 +795,7 @@ public Object scan(Attr key) {
 		}
 
 		@Override
-		public Object upstream() {
+		public Subscription upstream() {
 			return s;
 		}
 
@@ -908,7 +908,7 @@ public Object scan(Attr key) {
 		}
 
 		@Override
-		public Object downstream() {
+		public Subscriber<? super O> downstream() {
 			return actual();
 		}
 

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -426,7 +426,7 @@ public int requestFusion(int requestedMode) {
 	}
 
 	@Override
-	public Object downstream() {
+	public Subscriber<? super T> downstream() {
 		return actual;
 	}
 

File: src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -81,7 +81,7 @@ Flux<Integer> flatMapScenario() {
 		return Flux.interval(Duration.ofSeconds(3))
 		    .flatMap(v -> Flux.fromIterable(Arrays.asList("A"))
 		                      .flatMap(w -> Mono.fromCallable(() -> Arrays.asList(1, 2))
-		                                        .subscribeOn(Schedulers.timer())
+		                                        .subscribeOn(Schedulers.parallel())
 		                                        .flatMap(Flux::fromIterable))).log();
 	}
 

File: src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -295,7 +295,7 @@ public void fluxPropagatesErrorUsingAwait2() {
 
 	Flux<?> scenario_timeoutThrown3() {
 		return Flux.never()
-		           .timeout(Duration.ofMillis(500), Schedulers.timer());
+		           .timeout(Duration.ofMillis(500), Schedulers.parallel());
 	}
 
 	@Test

File: src/test/java/reactor/core/scheduler/TimedSchedulerTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,14 +31,13 @@ public class TimedSchedulerTest extends AbstractSchedulerTest {
 
 	@Override
 	protected Scheduler scheduler() {
-		return Schedulers.timer();
+		return Schedulers.newTimer("test-timer");
 	}
 
 	@Test
 	public void supportedStart() throws Exception {
 		Scheduler scheduler = Schedulers.timer();
 		scheduler.start();
-		scheduler.dispose();
 	}
 
 	@Test

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -627,7 +627,7 @@ public void clear() {
 		public boolean isEmpty() {
 			Iterator<? extends R> it = current;
 			if (it != null) {
-				return it.hasNext();
+				return !it.hasNext();
 			}
 			return queue.isEmpty(); // estimate
 		}

File: src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -65,7 +65,7 @@ public long getPrefetch() {
 	}
 
 	static final class SampleFirstMain<T, U>
-			implements InnerOperator<T, T>, InnerProducer<T> {
+			implements InnerOperator<T, T> {
 
 		final Function<? super T, ? extends Publisher<U>> throttler;
 		final Subscriber<? super T>                       actual;

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -1131,7 +1131,7 @@ public SubscriberAdapter(Subscriber<? super O> subscriber) {
 		}
 
 		@Override
-		public Object downstream() {
+		public Subscriber<? super O> downstream() {
 			return actual();
 		}
 

File: src/main/java/reactor/adapter/JdkFlowAdapter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/reactor/core/publisher/DrainUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -45,7 +45,7 @@ abstract class DrainUtils {
 	 * @param isCancelled callback to detect cancellation
 	 * @return true if the state indicates a completion state.
 	 */
-	public static <T, F> boolean postCompleteRequest(long n,
+	static <T, F> boolean postCompleteRequest(long n,
 			Subscriber<? super T> actual,
 			Queue<T> queue,
 			AtomicLongFieldUpdater<F> field,
@@ -97,7 +97,7 @@ static <T, F> boolean postCompleteDrain(long n,
 // TODO enable fast-path
 //        if (n == -1 || n == Long.MAX_VALUE) {
 //            for (;;) {
-//                if (isCancelled.getAsBoolean()) {
+//                if (isDisposed.getAsBoolean()) {
 //                    break;
 //                }
 //

File: src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 
+
 /**
  * For each subscriber, a Supplier is invoked and the returned value emitted.
  *

File: src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,6 @@
 
 import java.util.concurrent.Callable;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
@@ -41,7 +40,7 @@ final class FluxCallableOnAssembly<T> extends FluxSource<T, T>
 
 	final AssemblySnapshotException stacktrace;
 
-	FluxCallableOnAssembly(Publisher<? extends T> source) {
+	FluxCallableOnAssembly(Flux<? extends T> source) {
 		super(source);
 		this.stacktrace = new AssemblySnapshotException();
 	}

File: src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,7 +21,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxDistinct.DistinctFuseableSubscriber;
@@ -43,7 +42,7 @@ final class FluxDistinctFuseable<T, K, C extends Collection<? super K>>
 
 	final Supplier<C> collectionSupplier;
 
-	FluxDistinctFuseable(Publisher<? extends T> source,
+	FluxDistinctFuseable(Flux<? extends T> source,
 			Function<? super T, ? extends K> keyExtractor,
 			Supplier<C> collectionSupplier) {
 		super(source);

File: src/main/java/reactor/core/publisher/FluxTakeFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxTake.TakeFuseableSubscriber;
@@ -33,7 +32,7 @@ final class FluxTakeFuseable<T> extends FluxSource<T, T> implements Fuseable {
 
 	final long n;
 
-	FluxTakeFuseable(Publisher<? extends T> source, long n) {
+	FluxTakeFuseable(Flux<? extends T> source, long n) {
 		super(source);
 		if (n < 0) {
 			throw new IllegalArgumentException("n >= 0 required but it was " + n);

File: src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 
@@ -27,7 +26,7 @@
  */
 final class FluxTakeLastOne<T> extends FluxSource<T, T> implements Fuseable {
 
-	FluxTakeLastOne(Publisher<? extends T> source) {
+	FluxTakeLastOne(Flux<? extends T> source) {
 		super(source);
 	}
 

File: src/main/java/reactor/core/publisher/MonoAwaitOnSubscribe.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 
 /**
@@ -33,7 +32,7 @@
  */
 final class MonoAwaitOnSubscribe<T> extends MonoSource<T, T> {
 
-	public MonoAwaitOnSubscribe(Publisher<? extends T> source) {
+	MonoAwaitOnSubscribe(Mono<? extends T> source) {
 		super(source);
 	}
 	

File: src/main/java/reactor/core/publisher/MonoCancelOn.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,14 @@
 
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.scheduler.Scheduler;
 
 final class MonoCancelOn<T> extends MonoSource<T, T> {
 
 	final Scheduler scheduler;
 
-	public MonoCancelOn(Publisher<T> source, Scheduler scheduler) {
+	MonoCancelOn(Mono<T> source, Scheduler scheduler) {
 		super(source);
 		this.scheduler = scheduler;
 	}

File: src/main/java/reactor/core/publisher/MonoDefaultIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@
 
 import java.util.Objects;
 
-import org.reactivestreams.*;
+import org.reactivestreams.Subscriber;
 
 /**
  * Emits a default value if the wrapped Mono is empty.
@@ -27,7 +27,7 @@
 final class MonoDefaultIfEmpty<T> extends MonoSource<T, T> {
     final T defaultValue;
 
-    public MonoDefaultIfEmpty(Publisher<? extends T> source, T defaultValue) {
+    MonoDefaultIfEmpty(Mono<? extends T> source, T defaultValue) {
         super(source);
         this.defaultValue = Objects.requireNonNull(defaultValue, "defaultValue");
     }

File: src/main/java/reactor/core/publisher/MonoDelaySubscription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +32,7 @@ final class MonoDelaySubscription<T, U> extends MonoSource<T, T> {
 
 	final Publisher<U> other;
 
-	public MonoDelaySubscription(Publisher<? extends T> source, Publisher<U> other) {
+	MonoDelaySubscription(Mono<? extends T> source, Publisher<U> other) {
 		super(source);
 		this.other = Objects.requireNonNull(other, "other");
 	}

File: src/main/java/reactor/core/publisher/MonoDematerialize.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,15 +15,14 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 
 /**
  * @author Stephane Maldini
  */
 final class MonoDematerialize<T> extends MonoSource<Signal<T>, T> {
 
-	public MonoDematerialize(Publisher<Signal<T>> source) {
+	MonoDematerialize(Mono<Signal<T>> source) {
 		super(source);
 	}
 

File: src/main/java/reactor/core/publisher/MonoDetach.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 
 /**
@@ -29,7 +28,7 @@
  */
 final class MonoDetach<T> extends MonoSource<T, T> {
 
-	public MonoDetach(Publisher<? extends T> source) {
+	MonoDetach(Mono<? extends T> source) {
 		super(source);
 	}
 

File: src/main/java/reactor/core/publisher/MonoElapsed.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
@@ -29,7 +28,7 @@ final class MonoElapsed<T> extends MonoSource<T, Tuple2<Long, T>> implements Fus
 
 	final Scheduler scheduler;
 
-	MonoElapsed(Publisher<T> source, Scheduler scheduler) {
+	MonoElapsed(Mono<T> source, Scheduler scheduler) {
 		super(source);
 		this.scheduler = scheduler;
 	}

File: src/main/java/reactor/core/publisher/MonoHide.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.*;
+import org.reactivestreams.Subscriber;
 
 /**
  * Wraps another Publisher/Mono and hides its identity, including its
@@ -29,7 +29,7 @@
  */
 final class MonoHide<T> extends MonoSource<T, T> {
 
-    public MonoHide(Publisher<? extends T> source) {
+    MonoHide(Mono<? extends T> source) {
         super(source);
     }
     

File: src/main/java/reactor/core/publisher/MonoOtherwise.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +32,7 @@ final class MonoOtherwise<T> extends MonoSource<T, T> {
 
 	final Function<? super Throwable, ? extends Publisher<? extends T>> nextFactory;
 
-	public MonoOtherwise(Publisher<? extends T> source,
+	MonoOtherwise(Mono<? extends T> source,
 						   Function<? super Throwable, ? extends Mono<? extends T>>
 								   nextFactory) {
 		super(source);

File: src/main/java/reactor/core/publisher/MonoOtherwiseIfEmpty.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,6 @@
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
@@ -48,7 +47,7 @@ final class MonoPeekFuseable<T> extends MonoSource<T, T>
 
 	final Runnable onCancelCall;
 
-	public MonoPeekFuseable(Publisher<? extends T> source,
+	MonoPeekFuseable(Mono<? extends T> source,
 			Consumer<? super Subscription> onSubscribeCall,
 			Consumer<? super T> onNextCall,
 			Consumer<? super Throwable> onErrorCall,

File: src/main/java/reactor/core/publisher/MonoRetryPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,6 @@
 import java.util.Objects;
 import java.util.function.Predicate;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 
 /**
@@ -33,7 +32,7 @@ final class MonoRetryPredicate<T> extends MonoSource<T, T> {
 
 	final Predicate<Throwable> predicate;
 
-	public MonoRetryPredicate(Publisher<? extends T> source,
+	MonoRetryPredicate(Mono<? extends T> source,
 			Predicate<Throwable> predicate) {
 		super(source);
 		this.predicate = Objects.requireNonNull(predicate, "predicate");

File: src/main/java/reactor/core/publisher/MonoRetryWhen.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,7 +38,7 @@ final class MonoRetryWhen<T> extends MonoSource<T, T> {
 	final Function<? super Flux<Throwable>, ? extends Publisher<?>>
 			whenSourceFactory;
 
-	public MonoRetryWhen(Publisher<? extends T> source,
+	MonoRetryWhen(Mono<? extends T> source,
 			Function<? super Flux<Throwable>, ? extends Publisher<?>> whenSourceFactory) {
 		super(source);
 		this.whenSourceFactory =

File: src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.reactivestreams.Subscriber;
 
+
 /**
  * Executes the runnable whenever a Subscriber subscribes to this Mono.
  */

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5166,7 +5166,6 @@ public final Flux<T> publishOn(Scheduler scheduler, int prefetch) {
 	 *
 	 * @return a {@link Flux} producing asynchronously
 	 */
-	//TODO as part of #435 but separate from #480, switch to prefix-based (note that would change the current default of delayError = true)
 	public final Flux<T> publishOn(Scheduler scheduler, boolean delayError, int prefetch) {
 		if (this instanceof Callable) {
 			if (this instanceof Fuseable.ScalarCallable) {

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -543,7 +543,7 @@ static final class RequestTask implements Runnable {
 		@Override
 		public void run() {
 			final long bufferSize = prefetch;
-			final long limit = bufferSize - Math.max(bufferSize >> 2, 1);
+			final long limit = bufferSize == 1 ? bufferSize : bufferSize - Math.max(bufferSize >> 2, 1);
 			long cursor = -1;
 			try {
 				spinObserver.run();

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1245,7 +1245,7 @@ public final Mono<T> awaitOnSubscribe() {
 	 * @return T the result
 	 */
 	public T block() {
-		BlockingFirstSubscriber<T> subscriber = new BlockingFirstSubscriber<>();
+		BlockingMonoSubscriber<T> subscriber = new BlockingMonoSubscriber<>();
 		subscribe(subscriber);
 		return subscriber.blockingGet();
 	}
@@ -1267,7 +1267,7 @@ public T block() {
 	 * @return T the result
 	 */
 	public T block(Duration timeout) {
-		BlockingFirstSubscriber<T> subscriber = new BlockingFirstSubscriber<>();
+		BlockingMonoSubscriber<T> subscriber = new BlockingMonoSubscriber<>();
 		subscribe(subscriber);
 		return subscriber.blockingGet(timeout.toMillis(), TimeUnit.MILLISECONDS);
 	}
@@ -2782,7 +2782,7 @@ public final Disposable subscribe(Consumer<? super T> consumer,
 			Consumer<? super Throwable> errorConsumer,
 			Runnable completeConsumer,
 			Consumer<? super Subscription> subscriptionConsumer) {
-		return subscribeWith(new LambdaFirstSubscriber<>(consumer, errorConsumer,
+		return subscribeWith(new LambdaMonoSubscriber<>(consumer, errorConsumer,
 				completeConsumer, subscriptionConsumer));
 	}
 

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -295,7 +295,7 @@ public final void onNext(O value) {
 		if(value != null) {
 			finalState = STATE_SUCCESS_VALUE;
 			this.value = value;
-			if (s != null) {
+			if (s != null && !(source instanceof Mono)) {
 				s.cancel();
 			}
 		}

File: src/test/java/reactor/core/publisher/BlockingIterableTest.java
Patch:
@@ -23,8 +23,6 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.function.Supplier;
 
 import org.junit.Assert;
 import org.junit.Test;

File: src/main/java/reactor/core/publisher/BaseSubscriber.java
Patch:
@@ -176,7 +176,9 @@ public final void onError(Throwable t) {
 			hookOnError(t);
 		}
 		catch (Throwable e) {
-			e.addSuppressed(t);
+			if (e != t) {
+				e.addSuppressed(t);
+			}
 			Operators.onErrorDropped(e);
 		}
 		finally {

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -70,7 +70,9 @@ static <E> Flux<E> coldSource(RingBuffer<Slot<E>> ringBuffer, Throwable t, Throw
 		});
 		if (error != null) {
 			if (t != null) {
-				t.addSuppressed(error);
+				if (t != error) {
+					t.addSuppressed(error);
+				}
 				return concat(bufferIterable, Flux.error(t));
 			}
 			return concat(bufferIterable, Flux.error(error));

File: src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -410,7 +410,7 @@ final void fail(Throwable t) {
 				t.addSuppressed(new OnAssemblyException(getStacktrace(parent,
 						snapshotStack), parent));
 			}
-			else if(snapshotStack.checkpointed){
+			else if(snapshotStack.checkpointed && t != snapshotStack){
 				t.addSuppressed(snapshotStack);
 			}
 

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -86,7 +86,9 @@ public void onError(Throwable t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				Throwable _t = Operators.onOperatorError(e);
-				_t.addSuppressed(t);
+				if (_t != t) {
+					_t.addSuppressed(t);
+				}
 				subscriber.onError(_t);
 				return;
 			}

File: src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -93,7 +93,7 @@ public void subscribe(Subscriber<? super T> s) {
 				resourceCleanup.accept(resource);
 			}
 			catch (Throwable ex) {
-				ex.addSuppressed(Operators.onOperatorError(ex));
+				ex.addSuppressed(Operators.onOperatorError(e));
 				e = ex;
 			}
 

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -274,7 +274,7 @@ public static long multiplyCap(long a, long b) {
 	 * @param root the optional root cause to suppress
 	 */
 	public static void onErrorDropped(Throwable e, Throwable root) {
-		if(root != null) {
+		if(root != null && root != e) {
 			e.addSuppressed(root);
 		}
 		onErrorDropped(e);

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -217,7 +217,7 @@ else if (m == Fuseable.ASYNC) {
 
 				actual.onSubscribe(this);
 
-				s.request(prefetch);
+				s.request(prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : prefetch);
 			}
 		}
 
@@ -530,7 +530,7 @@ else if (m == Fuseable.ASYNC) {
 
 				actual.onSubscribe(this);
 
-				s.request(prefetch);
+				s.request(prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : prefetch);
 			}
 		}
 

File: src/main/java/reactor/util/function/Tuple2.java
Patch:
@@ -49,7 +49,7 @@ public class Tuple2<T1, T2> implements Iterable<Object>, Serializable {
 	/**
 	 * Type-safe way to get the fist object of this {@link Tuples}.
 	 *
-	 * @return The second object
+	 * @return The first object
 	 */
 	public T1 getT1() {
 		return t1;

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -3829,7 +3829,7 @@ public final <R> Flux<R> flatMap(Function<? super T, ? extends Publisher<? exten
 	 * arbitrary prefetch size to the merged {@link Iterable}.
 	 *
 	 * <p>
-	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.5.RELEASE/src/docs/marble/flatmapsequential.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.5.RELEASE/src/docs/marble/concatmap.png" alt="">
 	 *
 	 * @param mapper the {@link Function} to transform input sequence into N sequences {@link Iterable}
 	 * @param <R> the merged output sequence type
@@ -3846,7 +3846,7 @@ public final <R> Flux<R> flatMapIterable(Function<? super T, ? extends Iterable<
 	 * arbitrary prefetch size to the merged {@link Iterable}.
 	 *
 	 * <p>
-	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.5.RELEASE/src/docs/marble/flatmapsequential.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.5.RELEASE/src/docs/marble/concatmap.png" alt="">
 	 *
 	 * @param mapper the {@link Function} to transform input sequence into N sequences {@link Iterable}
 	 * @param prefetch the maximum in-flight elements from each inner {@link Iterable} sequence

File: src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java
Patch:
@@ -23,7 +23,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.scheduler.TimedScheduler;
+import reactor.core.scheduler.Scheduler;
 
 /**
  * @author Stephane Maldini
@@ -35,7 +35,7 @@ final class FluxBufferTimeOrSize<T, C extends Collection<? super T>> extends Flu
 	public FluxBufferTimeOrSize(Publisher<T> source,
 			int maxSize,
 			long timespan,
-			TimedScheduler timer,
+			Scheduler timer,
 			Supplier<C> bufferSupplier) {
 		super(source, maxSize, timespan, timer);
 		this.bufferSupplier = Objects.requireNonNull(bufferSupplier, "bufferSupplier");
@@ -58,7 +58,7 @@ final static class BufferAction<T, C extends Collection<? super T>> extends Batc
 		public BufferAction(Subscriber<? super C> actual,
 				int maxSize,
 				long timespan,
-				TimedScheduler.TimedWorker timer,
+				Scheduler.Worker timer,
 				Supplier<C> bufferSupplier) {
 			super(actual, maxSize, false, timespan, timer);
 			this.bufferSupplier = bufferSupplier;

File: src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -34,7 +34,7 @@
 import reactor.core.Producer;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
-import reactor.core.scheduler.TimedScheduler;
+import reactor.core.scheduler.Scheduler;
 import reactor.util.concurrent.QueueSupplier;
 
 /**
@@ -47,7 +47,7 @@ final class FluxReplay<T> extends ConnectableFlux<T>
 	final Publisher<T>   source;
 	final int            history;
 	final long           ttl;
-	final TimedScheduler scheduler;
+	final Scheduler scheduler;
 
 	volatile ReplaySubscriber<T> connection;
 	@SuppressWarnings("rawtypes")
@@ -59,7 +59,7 @@ final class FluxReplay<T> extends ConnectableFlux<T>
 	FluxReplay(Publisher<T> source,
 			int history,
 			long ttl,
-			TimedScheduler scheduler) {
+			Scheduler scheduler) {
 		this.source = Objects.requireNonNull(source, "source");
 		this.history = history;
 		if(history < 0){

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -25,7 +25,6 @@
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
-import reactor.core.scheduler.TimedScheduler;
 
 /**
  * Emits a single 0L value delayed by some time amount with a help of
@@ -35,13 +34,13 @@
  */
 final class MonoDelay extends Mono<Long> {
 
-	final TimedScheduler timedScheduler;
+	final Scheduler timedScheduler;
 
 	final long delay;
 
 	final TimeUnit unit;
 
-	MonoDelay(long delay, TimeUnit unit, TimedScheduler timedScheduler) {
+	MonoDelay(long delay, TimeUnit unit, Scheduler timedScheduler) {
 		this.delay = delay;
 		this.unit = Objects.requireNonNull(unit, "unit");
 		this.timedScheduler = Objects.requireNonNull(timedScheduler, "timedScheduler");

File: src/main/java/reactor/core/publisher/MonoElapsed.java
Patch:
@@ -19,17 +19,17 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
-import reactor.core.scheduler.TimedScheduler;
+import reactor.core.scheduler.Scheduler;
 import reactor.util.function.Tuple2;
 
 /**
  * @author Stephane Maldini
  */
 final class MonoElapsed<T> extends MonoSource<T, Tuple2<Long, T>> implements Fuseable {
 
-	final TimedScheduler scheduler;
+	final Scheduler scheduler;
 
-	MonoElapsed(Publisher<T> source, TimedScheduler scheduler) {
+	MonoElapsed(Publisher<T> source, Scheduler scheduler) {
 		super(source);
 		this.scheduler = scheduler;
 	}

File: src/main/java/reactor/core/scheduler/ImmediateScheduler.java
Patch:
@@ -21,6 +21,9 @@
  * Executes tasks on the caller's thread immediately.
  * <p>
  * Use the ImmediateScheduler.instance() to get a shared, stateless instance of this scheduler.
+ * This scheduler is NOT time-capable (can't schedule with delay / periodically).
+ *
+ * @author Stephane Maldini
  */
 final class ImmediateScheduler implements Scheduler {
 

File: src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -25,13 +25,13 @@
 import org.junit.Before;
 import org.junit.Test;
 import reactor.core.scheduler.Schedulers;
-import reactor.core.scheduler.TimedScheduler;
+import reactor.core.scheduler.Scheduler;
 import reactor.test.StepVerifier;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxIntervalTest {
 
-	TimedScheduler exec;
+	Scheduler exec;
 
 	@Before
 	public void before() {

File: src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -69,7 +69,8 @@ public void failTime(){
 
 	@Before
 	public void vtsStart() {
-		vts = VirtualTimeScheduler.getOrSet(false);
+		//delayElements (notably) now uses parallel() so VTS must be enabled everywhere
+		vts = VirtualTimeScheduler.getOrSet(true);
 	}
 
 	@After

File: src/test/java/reactor/core/publisher/FluxSubscribeOnCallableTest.java
Patch:
@@ -49,11 +49,11 @@ public void normal() {
 	public void normalBackpressured() {
 		StepVerifier.withVirtualTime(() -> Mono.fromCallable(() -> 1)
 		                                       .flux()
-		                                       .subscribeOn(
-				Schedulers.single()), 0)
+		                                       .subscribeOn(Schedulers.single()), 0)
 		            .expectSubscription()
 		            .expectNoEvent(Duration.ofSeconds(1))
 		            .thenRequest(1)
+		            .thenAwait()
 		            .expectNext(1)
 		            .expectComplete()
 		            .verify();
@@ -93,6 +93,7 @@ public void normalBackpressuredFused() {
 			            .size()).isEqualTo(1);
 		            })
 		            .thenRequest(1)
+		            .thenAwait()
 		            .expectNext(1)
 		            .expectComplete()
 		            .verify();

File: src/test/java/reactor/core/publisher/MonoSubscribeOnCallableTest.java
Patch:
@@ -39,6 +39,7 @@ public void normalBackpressured() {
 		            .expectSubscription()
 		            .expectNoEvent(Duration.ofSeconds(1))
 		            .thenRequest(1)
+		            .thenAwait()
 		            .expectNext(1)
 		            .expectComplete()
 		            .verify();

File: src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java
Patch:
@@ -37,8 +37,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
+import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
-import reactor.core.scheduler.TimedScheduler;
 import reactor.test.StepVerifier;
 import reactor.util.Logger;
 import reactor.util.Loggers;
@@ -153,7 +153,7 @@ public void forkJoinPoolWorkQueueRejectsSubscribers() {
 	public void highRate() throws Exception {
 		WorkQueueProcessor<String> queueProcessor =
 				WorkQueueProcessor.share("Processor", 256, liteBlocking());
-		TimedScheduler timer = Schedulers.newTimer("Timer");
+		Scheduler timer = Schedulers.newTimer("Timer");
 		queueProcessor.bufferTimeout(32, Duration.ofMillis(2), timer)
 		              .subscribe(new Subscriber<List<String>>() {
 			              int counter;

File: src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -209,8 +209,8 @@ public void request(long n) {
         public void cancel() {
             if (STATE.getAndSet(this, HAS_REQUEST_HAS_VALUE) != HAS_REQUEST_HAS_VALUE) {
                 value = null;
+                disposeResource(true);
             }
-			disposeResource(true);
         }
 
 		void disposeResource(boolean isCancel) {

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -319,10 +319,10 @@ void disposeResource(boolean isCancel) {
 			if (d != CANCELLED) {
 				d = DISPOSABLE.getAndSet(this, CANCELLED);
 				if (d != null && d != CANCELLED) {
-					d.dispose();
 					if (isCancel && d instanceof SinkDisposable) {
 						((SinkDisposable) d).cancel();
 					}
+					d.dispose();
 				}
 			}
 		}

File: src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -170,7 +170,7 @@ public MonoSink<T> onDispose(Disposable d) {
 		@Deprecated
 		@Override
 		public void setCancellation(Cancellation c) {
-			onDispose(new Disposable() {
+			onCancel(new Disposable() {
 				@Override
 				public void dispose() {
 					c.dispose();
@@ -218,10 +218,10 @@ void disposeResource(boolean isCancel) {
 			if (d != Flux.CANCELLED) {
 				d = DISPOSABLE.getAndSet(this, Flux.CANCELLED);
 				if (d != null && d != Flux.CANCELLED) {
-					d.dispose();
 					if (isCancel && d instanceof SinkDisposable) {
 						((SinkDisposable) d).cancel();
 					}
+					d.dispose();
 				}
 			}
 		}

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2178,6 +2178,7 @@ public final Mono<Signal<T>> materialize() {
 
 	/**
 	 * Merge emissions of this {@link Mono} with the provided {@link Publisher}.
+	 * The element from the Mono may be interleaved with the elements of the Publisher.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.5.RELEASE/src/docs/marble/merge1.png" alt="">

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -518,7 +518,7 @@ public static <T> Flux<T> concatDelayError(Publisher<? extends T>... sources) {
      *     // with cancellation support:
      *
      *     button.addActionListener(al);
-     *     emitter.onTerminate(() -> {
+     *     emitter.onDispose(() -> {
      *         button.removeListener(al);
      *     });
      * });
@@ -552,7 +552,7 @@ public static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter) {
      *     // with cancellation support:
      *
      *     button.addActionListener(al);
-     *     emitter.onTerminate(() -> {
+     *     emitter.onDispose(() -> {
      *         button.removeListener(al);
      *     });
      * }, FluxSink.OverflowStrategy.LATEST);

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -76,11 +76,11 @@ public interface FluxSink<T> {
 	/**
 	 * Associates a disposable resource with this FluxSink
 	 * that will be disposed on the first terminate signal which may be
-	 * a cancel or complete signal.
+	 * a cancel, complete or error signal.
 	 * @param d the disposable callback to use
 	 * @return the {@link FluxSink} with resource to be disposed on first terminate signal
 	 */
-	FluxSink<T> onTerminate(Disposable d);
+	FluxSink<T> onDispose(Disposable d);
 
 
     /**

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -116,7 +116,7 @@ public abstract class Mono<T> implements Publisher<T> {
 	 *     
 	 *     client.addListener(listener);
 	 *     
-	 *     sink.onTerminate(() -&gt; client.removeListener(listener));
+	 *     sink.onDispose(() -&gt; client.removeListener(listener));
 	 * });
 	 * </code></pre>
 	 * Note that this works only with single-value emitting listeners. Otherwise,
@@ -148,7 +148,7 @@ public abstract class Mono<T> implements Publisher<T> {
      *     // with cancellation support:
      *     
      *     AutoCloseable cancel = client.call("query", callback);
-     *     sink.onTerminate(() -> {
+     *     sink.onDispose(() -> {
      *         try {
      *             cancel.close();
      *         } catch (Exception ex) {

File: src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -150,7 +150,7 @@ public MonoSink<T> onCancel(Disposable d) {
 		}
 
 		@Override
-		public MonoSink<T> onTerminate(Disposable d) {
+		public MonoSink<T> onDispose(Disposable d) {
 			if (d != null) {
 				SinkDisposable sd = new SinkDisposable(d, null);
 				if (!DISPOSABLE.compareAndSet(this, null, sd)) {
@@ -170,7 +170,7 @@ public MonoSink<T> onTerminate(Disposable d) {
 		@Deprecated
 		@Override
 		public void setCancellation(Cancellation c) {
-			onTerminate(new Disposable() {
+			onDispose(new Disposable() {
 				@Override
 				public void dispose() {
 					c.dispose();

File: src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -61,12 +61,12 @@ public interface MonoSink<T> {
 
 	/**
 	 * Associates a disposable resource with this MonoSink that will be disposed on the
-	 * first terminate signal which may be a cancel or complete signal.
+	 * first terminate signal which may be a cancel, complete or error signal.
 	 *
 	 * @param d the disposable callback to use
 	 * @return the {@link MonoSink} with resource to be disposed on first terminate signal
 	 */
-	MonoSink<T> onTerminate(Disposable d);
+	MonoSink<T> onDispose(Disposable d);
 
     /**
      * Sets a cancellation callback triggered by

File: src/test/java/reactor/core/publisher/FluxCancelOnTest.java
Patch:
@@ -34,7 +34,7 @@ public void cancelOnDedicatedScheduler() throws Exception {
 		Schedulers.single().schedule(() -> threadHash.set(Thread.currentThread()));
 
 		Flux.create(sink -> {
-			sink.onTerminate(() -> {
+			sink.onDispose(() -> {
 				if (threadHash.compareAndSet(Thread.currentThread(), null)) {
 					latch.countDown();
 				}

File: src/test/java/reactor/core/publisher/MonoCancelOnTest.java
Patch:
@@ -34,7 +34,7 @@ public void cancelOnDedicatedScheduler() throws Exception {
 		Schedulers.single().schedule(() -> threadHash.set(Thread.currentThread()));
 
 		Mono.create(sink -> {
-			sink.onTerminate(() -> {
+			sink.onDispose(() -> {
 				if (threadHash.compareAndSet(Thread.currentThread(), null)) {
 					latch.countDown();
 				}

File: src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -58,6 +58,7 @@ public Void block() {
 
     @Override
     public Void call() throws Exception {
+        run.run();
         return null;
     }
 }

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -408,7 +408,7 @@ void drainAsync() {
 						}
 
 						boolean d = done;
-						boolean empty = q.isEmpty();
+						boolean empty = q.isEmpty() && it == null;
 
 						if (d && empty) {
 							current = null;

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -116,7 +116,7 @@ public abstract class Mono<T> implements Publisher<T> {
 	 *     
 	 *     client.addListener(listener);
 	 *     
-	 *     sink.setCancellation(() -&gt; client.removeListener(listener));
+	 *     sink.onTerminate(() -&gt; client.removeListener(listener));
 	 * });
 	 * </code></pre>
 	 * Note that this works only with single-value emitting listeners. Otherwise,
@@ -148,7 +148,7 @@ public abstract class Mono<T> implements Publisher<T> {
      *     // with cancellation support:
      *     
      *     AutoCloseable cancel = client.call("query", callback);
-     *     sink.setCancellation(() -> {
+     *     sink.onTerminate(() -> {
      *         try {
      *             cancel.close();
      *         } catch (Exception ex) {

File: src/test/java/reactor/core/publisher/FluxCancelOnTest.java
Patch:
@@ -34,7 +34,7 @@ public void cancelOnDedicatedScheduler() throws Exception {
 		Schedulers.single().schedule(() -> threadHash.set(Thread.currentThread()));
 
 		Flux.create(sink -> {
-			sink.setCancellation(() -> {
+			sink.onTerminate(() -> {
 				if (threadHash.compareAndSet(Thread.currentThread(), null)) {
 					latch.countDown();
 				}

File: src/test/java/reactor/core/publisher/MonoCancelOnTest.java
Patch:
@@ -34,7 +34,7 @@ public void cancelOnDedicatedScheduler() throws Exception {
 		Schedulers.single().schedule(() -> threadHash.set(Thread.currentThread()));
 
 		Mono.create(sink -> {
-			sink.setCancellation(() -> {
+			sink.onTerminate(() -> {
 				if (threadHash.compareAndSet(Thread.currentThread(), null)) {
 					latch.countDown();
 				}

File: src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.core.publisher;
 
+import java.time.Duration;
+
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
@@ -60,7 +62,7 @@ public Object call() {
 	}
 
 	@Override
-	public Object blockMillis(long m) {
+	public Object block(Duration m) {
 		return null;
 	}
 

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.publisher;
 
+import java.time.Duration;
 import java.util.Objects;
 import java.util.function.Supplier;
 
@@ -42,7 +43,7 @@ public Throwable getError() {
 	}
 
 	@Override
-	public T blockMillis(long m) {
+	public T block(Duration m) {
 		throw Exceptions.propagate(getError());
 	}
 

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.publisher;
 
+import java.time.Duration;
 import java.util.Objects;
 
 import org.reactivestreams.Subscriber;
@@ -40,7 +41,7 @@ public T call() {
 	}
 
 	@Override
-	public T blockMillis(long m) {
+	public T block(Duration m) {
 		return value;
 	}
 

File: src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -16,6 +16,7 @@
 
 package reactor.core.publisher;
 
+import java.time.Duration;
 import java.util.Objects;
 import java.util.concurrent.Callable;
 
@@ -44,7 +45,7 @@ public void subscribe(Subscriber<? super Void> s) {
     }
     
     @Override
-    public Void blockMillis(long m) {
+    public Void block(Duration m) {
         run.run();
         return null;
     }

File: src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -297,7 +297,7 @@ public void bufferWillSubdivideAnInputFluxTime() {
 	Flux<List<Integer>> scenario_bufferWillSubdivideAnInputFluxTime2() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
 		           .delayElements(Duration.ofMillis(99))
-		           .bufferMillis(200);
+		           .buffer(Duration.ofMillis(200));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxBufferStartEndTest.java
Patch:
@@ -180,7 +180,7 @@ public void bufferWillSubdivideAnInputFluxOverlapTime() {
 	Flux<List<Integer>> scenario_bufferWillSubdivideAnInputFluxOverlapTime2() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
 		           .delayElements(Duration.ofMillis(99))
-		           .bufferMillis(300L, 200L);//FIXME review signature
+		           .buffer(Duration.ofMillis(300L), Duration.ofMillis(200L));
 	}
 
 	@Test
@@ -197,7 +197,7 @@ public void bufferWillSubdivideAnInputFluxOverlapTime2() {
 	Flux<List<Integer>> scenario_bufferWillSubdivideAnInputFluxSameTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
 		           .delayElements(Duration.ofMillis(99))
-		           .bufferMillis(300L, 300L);
+		           .buffer(Duration.ofMillis(300L), Duration.ofMillis(300L));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxBufferTimeOrSizeTest.java
Patch:
@@ -28,7 +28,7 @@ public class FluxBufferTimeOrSizeTest {
 	Flux<List<Integer>> scenario_bufferWithTimeoutAccumulateOnTimeOrSize() {
 		return Flux.range(1, 6)
 		           .delayElements(Duration.ofMillis(300))
-		           .buffer(5, Duration.ofMillis(2000));
+		           .bufferTimeout(5, Duration.ofMillis(2000));
 	}
 
 	@Test
@@ -44,7 +44,7 @@ public void bufferWithTimeoutAccumulateOnTimeOrSize() {
 	Flux<List<Integer>> scenario_bufferWithTimeoutAccumulateOnTimeOrSize2() {
 		return Flux.range(1, 6)
 		           .delayElements(Duration.ofMillis(300))
-		           .bufferMillis(5, 2000);
+		           .bufferTimeout(5, Duration.ofMillis(2000));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxCacheTest.java
Patch:
@@ -31,7 +31,7 @@ public void cacheFlux() {
 			VirtualTimeScheduler vts = VirtualTimeScheduler.getOrSet(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
-			                                         .delayElementsMillis(1000)
+			                                         .delayElements(Duration.ofMillis(1000))
 			                                         .cache()
 			                                         .elapsed();
 
@@ -60,7 +60,7 @@ public void cacheFluxTTL() {
 			VirtualTimeScheduler vts = VirtualTimeScheduler.getOrSet(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
-			                                         .delayElementsMillis(1000)
+			                                         .delayElements(Duration.ofMillis(1000))
 			                                         .cache(Duration.ofMillis(2000))
 			                                         .elapsed();
 
@@ -88,7 +88,7 @@ public void cacheFluxHistoryTTL() {
 			VirtualTimeScheduler vts = VirtualTimeScheduler.getOrSet(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
-			                                         .delayElementsMillis(1000)
+			                                         .delayElements(Duration.ofMillis(1000))
 			                                         .cache(2, Duration.ofMillis(2000))
 			                                         .elapsed();
 

File: src/test/java/reactor/core/publisher/FluxDelaySubscriptionTest.java
Patch:
@@ -194,7 +194,7 @@ public void delayedTrigger() {
 
 	Flux<Integer> scenario_delayedTrigger2(){
 		return Flux.just(1)
-		           .delaySubscriptionMillis(50);
+		           .delaySubscription(Duration.ofMillis(50));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxFlatMapTest.java
Patch:
@@ -910,7 +910,7 @@ public void delayedBackpressuredScalar() {
 	Flux<Integer> scenario_backpressuredThenCancel() {
 		return Flux.just(1, 2, 3)
 		           .flatMap(f -> Flux.range(1, 10)
-		                             .delayElementsMillis(10L))
+		                             .delayElements(Duration.ofMillis(10L)))
 		           .hide();
 	}
 

File: src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -51,7 +51,7 @@ public void normal() {
 			ts.values()
 			  .add(System.currentTimeMillis());
 
-			Flux.intervalMillis(100, 100, exec)
+			Flux.interval(Duration.ofMillis(100), Duration.ofMillis(100), exec)
 			    .take(5)
 			    .map(v -> System.currentTimeMillis())
 			    .subscribe(ts);
@@ -124,7 +124,7 @@ public void normal3() {
 	}
 
 	Flux<Long> scenario4(){
-		return Flux.intervalMillis(500, 1000);
+		return Flux.interval(Duration.ofMillis(500), Duration.ofMillis(1000));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxMergeSequentialTest.java
Patch:
@@ -646,8 +646,8 @@ public void mergeSequentialLargeUnorderedEach100() {
 		long count = Flux.range(0, 500)
 		                 .flatMapSequential(i -> {
 			                 //ensure each pack of 100 is delayed in inverse order
-			                 long sleep = 600 - i % 100;
-			                 return Mono.delayMillis(sleep)
+			                 Duration sleep = Duration.ofMillis(600 - i % 100);
+			                 return Mono.delay(sleep)
 			                            .then(Mono.just(i))
 			                            .subscribeOn(scheduler);
 		                 })

File: src/test/java/reactor/core/publisher/FluxProcessorTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.publisher;
 
+import java.time.Duration;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -146,8 +147,8 @@ public void testSubmitSession() throws Exception {
 		CountDownLatch latch = new CountDownLatch(1);
 		Scheduler scheduler = Schedulers.parallel();
 		processor.publishOn(scheduler)
-		         .delaySubscriptionMillis(1000)
-		         .subscribe(d -> {
+		         .delaySubscription(Duration.ofMillis(1000))
+		                                    .subscribe(d -> {
 			         count.incrementAndGet();
 			         latch.countDown();
 		         }, 1);

File: src/test/java/reactor/core/publisher/FluxSampleFirstTest.java
Patch:
@@ -160,7 +160,7 @@ public void throttlerReturnsNull() {
 
 	Flux<Integer> scenario_sampleFirstTime(){
 		return Flux.range(1, 10)
-	        .delayElementsMillis(200)
+	        .delayElements(Duration.ofMillis(200))
 	        .sampleFirst(Duration.ofSeconds(1));
 	}
 

File: src/test/java/reactor/core/publisher/FluxSampleTimeoutTest.java
Patch:
@@ -129,7 +129,7 @@ public void throttlerReturnsNull() {
 
 	Flux<Integer> scenario_sampleTimeoutTime(){
 		return Flux.range(1, 10)
-		           .delayElementsMillis(300)
+		           .delayElements(Duration.ofMillis(300))
 		           .sampleTimeout(d -> Mono.delay(Duration.ofMillis(100*d)), 1);
 	}
 
@@ -142,7 +142,7 @@ public void sampleTimeoutTime(){
 	}
 	Flux<Integer> scenario_sampleTimeoutTime2(){
 		return Flux.range(1, 10)
-		           .delayElementsMillis(300)
+		           .delayElements(Duration.ofMillis(300))
 		           .sampleTimeout(d -> Mono.delay(Duration.ofMillis(100*d)), Integer.MAX_VALUE);
 	}
 

File: src/test/java/reactor/core/publisher/FluxSkipUntilOtherTest.java
Patch:
@@ -224,7 +224,7 @@ public void aFluxCanBeSkippedByTime(){
 
 	Flux<Integer> scenario_aFluxCanBeSkippedByTime2(){
 		return Flux.range(0, 1000)
-		           .skipMillis(2000);
+		           .skip(Duration.ofMillis(2000));
 	}
 
 	@Test
@@ -236,7 +236,7 @@ public void aFluxCanBeSkippedByTime2(){
 
 	Flux<Integer> scenario_aFluxCanBeSkippedByTimeZero(){
 		return Flux.range(0, 1000)
-		           .skipMillis(0);
+		           .skip(Duration.ofMillis(0));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxTakeUntilOtherTest.java
Patch:
@@ -168,7 +168,7 @@ public void aFluxCanBeLimitedByTime(){
 
 	Flux<Integer> scenario_aFluxCanBeLimitedByTime2(){
 		return Flux.range(0, 1000)
-		           .takeMillis(2000);
+		           .take(Duration.ofMillis(2000));
 	}
 
 	@Test
@@ -180,7 +180,7 @@ public void aFluxCanBeLimitedByTime2(){
 	}
 	@Test
 	public void aFluxCanBeLimitedByTime3(){
-		StepVerifier.create(Flux.range(0, 1000).takeMillis(0L))
+		StepVerifier.create(Flux.range(0, 1000).take(Duration.ofMillis(0L)))
 		            .thenAwait(Duration.ofSeconds(2))
 		            .verifyComplete();
 	}

File: src/test/java/reactor/core/publisher/FluxTimeoutTest.java
Patch:
@@ -270,7 +270,7 @@ public void fluxPropagatesErrorUsingAwait() {
 	}
 
 	Flux<Integer> scenario_timeoutCanBeBoundWithCallback2() {
-		return Flux.<Integer>never().timeoutMillis(500, Flux.just(-5));
+		return Flux.<Integer>never().timeout(Duration.ofMillis(500), Flux.just(-5));
 	}
 
 	@Test
@@ -283,7 +283,7 @@ public void timeoutCanBeBoundWithCallback2() {
 
 	Flux<?> scenario_timeoutThrown2() {
 		return Flux.never()
-		           .timeoutMillis(500);
+		           .timeout(Duration.ofMillis(500));
 	}
 
 	@Test
@@ -295,7 +295,7 @@ public void fluxPropagatesErrorUsingAwait2() {
 
 	Flux<?> scenario_timeoutThrown3() {
 		return Flux.never()
-		           .timeoutMillis(500, Schedulers.timer());
+		           .timeout(Duration.ofMillis(500), Schedulers.timer());
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxWindowTimeOrSizeTest.java
Patch:
@@ -28,7 +28,7 @@ public class FluxWindowTimeOrSizeTest {
 	Flux<List<Integer>> scenario_windowWithTimeoutAccumulateOnTimeOrSize() {
 		return Flux.range(1, 6)
 		           .delayElements(Duration.ofMillis(300))
-		           .window(5, Duration.ofMillis(2000))
+		           .windowTimeout(5, Duration.ofMillis(2000))
 		           .concatMap(Flux::buffer);
 	}
 
@@ -45,7 +45,7 @@ public void windowWithTimeoutAccumulateOnTimeOrSize() {
 	Flux<List<Integer>> scenario_windowWithTimeoutAccumulateOnTimeOrSize2() {
 		return Flux.range(1, 6)
 		           .delayElements(Duration.ofMillis(300))
-		           .windowMillis(5, 2000)
+		           .windowTimeout(5, Duration.ofMillis(2000))
 		           .concatMap(Flux::buffer);
 	}
 

File: src/test/java/reactor/core/publisher/MonoDelayElementTest.java
Patch:
@@ -85,7 +85,7 @@ public void cancelBeforeNext() {
 		AtomicBoolean emitted = new AtomicBoolean();
 		AtomicBoolean cancelled = new AtomicBoolean();
 
-		Mono<Long> source = Mono.delayMillis(1000, vts);
+		Mono<Long> source = Mono.delay(Duration.ofMillis(1000), vts);
 
 		StepVerifier.withVirtualTime(
 				() -> new MonoDelayElement<>(source, 2, TimeUnit.SECONDS, vts)
@@ -224,7 +224,7 @@ public void monoApiTestDuration() {
 
 	@Test
 	public void monoApiTestMillis() {
-		StepVerifier.withVirtualTime(() -> Mono.just("foo").delayElementMillis(5000L))
+		StepVerifier.withVirtualTime(() -> Mono.just("foo").delayElement(Duration.ofMillis(5000L)))
 		            .expectSubscription()
 		            .expectNoEvent(Duration.ofSeconds(5))
 		            .expectNext("foo")
@@ -236,7 +236,7 @@ public void monoApiTestMillisAndTimer() {
 		VirtualTimeScheduler vts = VirtualTimeScheduler.create();
 
 		StepVerifier.withVirtualTime(
-				() -> Mono.just("foo").delayElementMillis(5000L, vts),
+				() -> Mono.just("foo").delayElement(Duration.ofMillis(5000L), vts),
 				() -> vts, Long.MAX_VALUE)
 		            .expectSubscription()
 		            .expectNoEvent(Duration.ofSeconds(5))

File: src/test/java/reactor/core/publisher/MonoDelaySubscriptionTest.java
Patch:
@@ -63,7 +63,7 @@ public void delayedTrigger() {
 
 	Mono<Integer> scenario_delayedTrigger2(){
 		return Mono.just(1)
-		           .delaySubscriptionMillis(50);
+		           .delaySubscription(Duration.ofMillis(50));
 	}
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -144,7 +144,7 @@ public void someEmpty() {
 	@Test//(timeout = 5000)
 	public void all2NonEmpty() {
 		Assert.assertEquals(Tuples.of(0L, 0L),
-				Mono.when(Mono.delayMillis(150), Mono.delayMillis(250))
+				Mono.when(Mono.delay(Duration.ofMillis(150)), Mono.delay(Duration.ofMillis(250)))
 				    .block());
 	}
 

File: src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package reactor.core.publisher;
 
+import java.time.Duration;
 import java.util.List;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
@@ -153,7 +154,7 @@ public void highRate() throws Exception {
 		WorkQueueProcessor<String> queueProcessor =
 				WorkQueueProcessor.share("Processor", 256, liteBlocking());
 		TimedScheduler timer = Schedulers.newTimer("Timer");
-		queueProcessor.bufferMillis(32, 2, timer)
+		queueProcessor.bufferTimeout(32, Duration.ofMillis(2), timer)
 		              .subscribe(new Subscriber<List<String>>() {
 			              int counter;
 

File: src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.publisher.scenarios;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
@@ -153,10 +154,10 @@ public void promiseOnAfter() throws Exception {
 
 	@Test
 	public void promiseDelays() throws Exception {
-		Tuple2<Long, String> h = Mono.delayMillis(3000)
+		Tuple2<Long, String> h = Mono.delay(Duration.ofMillis(3000))
 		                             .log("time1")
 		                             .map(d -> "Spring wins")
-		                             .or(Mono.delayMillis(2000).log("time2").map(d -> "Spring Reactive"))
+		                             .or(Mono.delay(Duration.ofMillis(2000)).log("time2").map(d -> "Spring Reactive"))
 		                             .then(t -> Mono.just(t+ " world"))
 		                             .elapsed()
 		                             .block();

File: src/test/java/reactor/core/publisher/tck/FluxBlackboxProcessorVerification.java
Patch:
@@ -58,7 +58,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                          .map(integer -> -integer)
 				                          .filter(integer -> integer <= 0)
 				                          .map(integer -> -integer)
-				                          .buffer(batch, Duration.ofMillis(50))
+				                          .bufferTimeout(batch, Duration.ofMillis(50))
 				                          .flatMap(Flux::fromIterable)
 				                          .flatMap(i -> Flux.zip(Flux.just(i), otherStream, combinator))
 				 )

File: src/test/java/reactor/core/publisher/tck/FluxWithProcessorVerification.java
Patch:
@@ -55,7 +55,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                          .map(integer -> -integer)
 				                          .filter(integer -> integer <= 0)
 				                          .map(integer -> -integer)
-				                          .buffer(batch, Duration.ofMillis(50))
+				                          .bufferTimeout(batch, Duration.ofMillis(50))
 				                          .flatMap(Flux::fromIterable)
 				                          .doOnNext(array -> cumulated.getAndIncrement())
 				                          .flatMap(i -> Flux.zip(Flux.just(i),

File: src/test/java/reactor/guide/GuideTests.java
Patch:
@@ -396,7 +396,7 @@ public void errorHandlingIntervalMillisNotContinued() throws InterruptedExceptio
 		VirtualTimeScheduler.set(virtualTimeScheduler);
 
 		Flux<String> flux =
-		Flux.intervalMillis(250)
+		Flux.interval(Duration.ofMillis(250))
 		    .map(input -> {
 			    if (input < 3) return "tick " + input;
 			    throw new RuntimeException("boom");
@@ -423,7 +423,7 @@ public void errorHandlingIntervalMillisRetried() throws InterruptedException {
 		VirtualTimeScheduler.set(virtualTimeScheduler);
 
 		Flux<Tuple2<Long,String>> flux =
-		Flux.intervalMillis(250)
+		Flux.interval(Duration.ofMillis(250))
 		    .map(input -> {
 			    if (input < 3) return "tick " + input;
 			    throw new RuntimeException("boom");
@@ -491,7 +491,7 @@ public void errorHandlingRetryWhenExponential() {
 							if (index < 4) return index;
 							else throw Exceptions.propagate(error);
 						})
-						.flatMap(index -> Mono.delayMillis(index * 100)) // <3>
+						.flatMap(index -> Mono.delay(Duration.ofMillis(index * 100))) // <3>
 						.doOnNext(s -> System.out.println("retried at " + LocalTime.now())) // <4>
 				);
 

File: src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 import reactor.core.Disposable;
+import reactor.test.StepVerifier;
 import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.concurrent.QueueSupplier;
@@ -417,5 +418,4 @@ public void fusedMapInvalid() {
 		.assertError(NullPointerException.class)
 		.assertNotComplete();
 	}
-
 }

File: src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -333,6 +333,9 @@ static Publisher<?> getParentOrThis(Publisher<?> parent) {
 		for (; ; ) {
 			if (next instanceof Receiver) {
 				Receiver r = (Receiver) next;
+				if (!(r.upstream() instanceof Publisher)){
+					break;
+				}
 				next = r.upstream();
 				if (next instanceof AssemblyOp) {
 					continue;

File: src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -32,7 +32,7 @@
  */
 final class MonoNext<T> extends MonoSource<T, T> {
 
-	public MonoNext(Publisher<? extends T> source) {
+	MonoNext(Publisher<? extends T> source) {
 		super(source);
 	}
 
@@ -55,7 +55,7 @@ static final class NextSubscriber<T>
 		static final AtomicIntegerFieldUpdater<NextSubscriber> WIP =
 				AtomicIntegerFieldUpdater.newUpdater(NextSubscriber.class, "wip");
 
-		public NextSubscriber(Subscriber<? super T> actual) {
+		NextSubscriber(Subscriber<? super T> actual) {
 			this.actual = actual;
 		}
 

File: src/test/java/reactor/guide/GuideDebuggingExtraTests.java
Patch:
@@ -46,7 +46,7 @@ public void debuggingActivatedWithDeepTraceback() {
 			String debugStack = sw.toString();
 
 			assertThat(debugStack)
-					.endsWith("Error has been observed by the following operators, starting from the origin :\n"
+					.endsWith("Error has been observed by the following operator(s):\n"
 							+ "\t|_\tFlux.map(FakeRepository.java:27)\n"
 							+ "\t|_\tFlux.map(FakeRepository.java:28)\n"
 							+ "\t|_\tFlux.filter(FakeUtils1.java:29)\n"

File: src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -20,6 +20,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Disposable;
 import reactor.core.Fuseable;
+import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
 
 /**
  * Captures the current stacktrace when this connectable publisher is created and
@@ -44,11 +45,11 @@ final class ConnectableFluxOnAssembly<T> extends ConnectableFlux<T> implements
 
 	final ConnectableFlux<T> source;
 
-	final Exception stacktrace;
+	final AssemblySnapshotException stacktrace;
 
 	ConnectableFluxOnAssembly(ConnectableFlux<T> source) {
 		this.source = source;
-		this.stacktrace = new Exception();
+		this.stacktrace = new AssemblySnapshotException();
 	}
 	
 	@Override

File: src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -21,6 +21,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
+import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
 
 /**
  * Captures the current stacktrace when this publisher is created and makes it
@@ -38,11 +39,11 @@
 final class FluxCallableOnAssembly<T> extends FluxSource<T, T>
 		implements Fuseable, Callable<T>, AssemblyOp {
 
-	final Exception stacktrace;
+	final AssemblySnapshotException stacktrace;
 
 	FluxCallableOnAssembly(Publisher<? extends T> source) {
 		super(source);
-		this.stacktrace = new Exception();
+		this.stacktrace = new AssemblySnapshotException();
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
+import reactor.core.publisher.FluxOnAssembly.AssemblySnapshotException;
 
 /**
  * Captures the current stacktrace when this publisher is created and makes it
@@ -40,11 +41,11 @@
 final class MonoCallableOnAssembly<T> extends MonoSource<T, T>
 		implements Callable<T>, AssemblyOp {
 
-	final Exception stacktrace;
+	final AssemblySnapshotException stacktrace;
 
 	MonoCallableOnAssembly(Publisher<? extends T> source) {
 		super(source);
-		this.stacktrace = new Exception();
+		this.stacktrace = new AssemblySnapshotException();
 	}
 
 	@Override

File: src/main/java/reactor/util/Logger.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.util;
 
+import java.util.logging.Level;
+
 /**
  * Logger interface designed for internal Reactor usage.
  */

File: src/main/java/reactor/core/publisher/WorkQueueProcessor.java
Patch:
@@ -792,7 +792,7 @@ public void run() {
 
 					}
 					catch (InterruptedException | RuntimeException ce) {
-						if (Exceptions.isCancel(ce) || isCancelled()){
+						if (Exceptions.isCancel(ce)){
 							reschedule(event);
 							break;
 						}

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -154,7 +154,7 @@ static boolean waitRequestOrTerminalEvent(LongSupplier pendingRequest,
 				barrier.waitFor(waitedSequence, waiter);
 
 				if (!isRunning.get()) {
-					throw Exceptions.failWithCancel();
+					WaitStrategy.alert();
 				}
 				LockSupport.parkNanos(1L);
 			}
@@ -165,7 +165,7 @@ static boolean waitRequestOrTerminalEvent(LongSupplier pendingRequest,
 		}
 
 		catch (Exception e) {
-			if (WaitStrategy.isAlert(e) || Exceptions.isCancel(e)) {
+			if (!isRunning.get() || WaitStrategy.isAlert(e)) {
 				return false;
 			}
 			throw e;

File: src/main/java/reactor/core/publisher/FluxHide.java
Patch:
@@ -31,7 +31,7 @@
  */
 final class FluxHide<T> extends FluxSource<T, T> {
 
-	public FluxHide(Publisher<? extends T> source) {
+	FluxHide(Publisher<? extends T> source) {
 		super(source);
 	}
 

File: src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -55,10 +55,10 @@ final class FluxScan<T> extends FluxSource<T, T> {
 
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		source.subscribe(new AccumulateSubscriber<>(s, accumulator));
+		source.subscribe(new ScanSubscriber<>(s, accumulator));
 	}
 
-	static final class AccumulateSubscriber<T>
+	static final class ScanSubscriber<T>
 			implements Subscriber<T>, Receiver, Producer, Loopback, Subscription,
 			           Trackable {
 		final Subscriber<? super T> actual;
@@ -71,7 +71,7 @@ static final class AccumulateSubscriber<T>
 
 		boolean done;
 
-		public AccumulateSubscriber(Subscriber<? super T> actual, BiFunction<T, ? super T, T> accumulator) {
+		ScanSubscriber(Subscriber<? super T> actual, BiFunction<T, ? super T, T> accumulator) {
 			this.actual = actual;
 			this.accumulator = accumulator;
 		}

File: src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -73,7 +73,7 @@ public final Publisher<? extends I> upstream() {
 	}
 
 	static final class FuseableFluxSource<I> extends FluxSource<I, I> implements Fuseable{
-		public FuseableFluxSource(Publisher<? extends I> source) {
+		FuseableFluxSource(Publisher<? extends I> source) {
 			super(source);
 		}
 	}

File: src/main/java/reactor/core/publisher/MonoDelayElement.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Cancellation;
+import reactor.core.Receiver;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.TimedScheduler;
 
@@ -56,7 +57,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	static final class MonoDelayElementSubscriber<T> extends Operators.MonoSubscriber<T,T>
-			implements Subscription  {
+			implements Subscription, Receiver {
 
 		final long delay;
 		final TimedScheduler scheduler;
@@ -67,7 +68,7 @@ static final class MonoDelayElementSubscriber<T> extends Operators.MonoSubscribe
 		volatile Cancellation task;
 		volatile boolean done;
 
-		public MonoDelayElementSubscriber(Subscriber<? super T> actual, TimedScheduler scheduler,
+		MonoDelayElementSubscriber(Subscriber<? super T> actual, TimedScheduler scheduler,
 				long delay, TimeUnit unit) {
 			super(actual);
 			this.scheduler = scheduler;

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -162,7 +162,7 @@ else if(subscription == null) {
 			try {
 				long endState = waitStrategy.waitFor(STATE_SUCCESS_VALUE, this,	() -> {
 					if (delay < System.nanoTime()) {
-						throw Exceptions.failWithCancel();
+						WaitStrategy.alert();
 					}
 				});
 
@@ -179,7 +179,7 @@ else if(subscription == null) {
 				throw new IllegalStateException("Mono has been cancelled");
 			}
 			catch (RuntimeException ce) {
-				if(Exceptions.isCancel(ce)) {
+				if(WaitStrategy.isAlert(ce)) {
 					cancel();
 					throw new IllegalStateException("Timeout on Mono blocking read");
 				}

File: src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -79,7 +79,7 @@ public final Publisher<? extends I> upstream() {
 	}
 
 	static final class FuseableMonoSource<I> extends MonoSource<I, I> implements Fuseable{
-		public FuseableMonoSource(Publisher<? extends I> source) {
+		FuseableMonoSource(Publisher<? extends I> source) {
 			super(source);
 		}
 	}

File: src/main/java/reactor/core/publisher/ParallelFlux.java
Patch:
@@ -1055,7 +1055,7 @@ public long getPrefetch() {
 	 */
 	@Override
 	public final void subscribe(Subscriber<? super T> s) {
-		sequential().subscribe(s);
+		sequential().subscribe(new FluxHide.SuppressFuseableSubscriber<>(s));
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -520,7 +520,7 @@ static final class UnboundedReplayBuffer<T> implements ReplayBuffer<T> {
 		volatile boolean done;
 		Throwable error;
 
-		public UnboundedReplayBuffer(int batchSize) {
+		UnboundedReplayBuffer(int batchSize) {
 			this.batchSize = batchSize;
 			Object[] n = new Object[batchSize + 1];
 			this.tail = n;
@@ -730,6 +730,7 @@ public T poll(ReplaySubscription<T> rs) {
 			if (tailIndex == batchSize) {
 				node = (Object[]) node[tailIndex];
 				tailIndex = 0;
+				rs.node(node);
 			}
 			@SuppressWarnings("unchecked") T v = (T) node[tailIndex];
 			rs.index(index + 1);

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -443,7 +443,7 @@ public Throwable getError() {
 	}
 
 	@Override
-	public Object downstream() {
+	public Subscriber<? super T> downstream() {
 		return actual;
 	}
 

File: src/main/java/reactor/util/concurrent/WaitStrategy.java
Patch:
@@ -162,9 +162,11 @@ public static WaitStrategy sleeping() {
     /**
      * Throw a signal singleton exception that can be checked against
      * {@link #isAlert(Throwable)}
+     * @deprecated duplicate to {@link #alert()}
      */
+    @Deprecated
     public static void throwAlert() {
-	    throw AlertException.INSTANCE;
+	    alert();
     }
 
     /**

File: src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -25,10 +25,11 @@
 import org.junit.Test;
 import reactor.core.Fuseable;
 import reactor.test.StepVerifier;
+import reactor.test.publisher.FluxOperatorTest;
 import reactor.test.scheduler.VirtualTimeScheduler;
 import reactor.util.function.Tuple2;
 
-public class FluxReplayTest extends AbstractFluxOperatorTest<String, String> {
+public class FluxReplayTest extends FluxOperatorTest<String, String> {
 
 	@Override
 	protected Scenario<String, String> defaultScenarioOptions(Scenario<String, String> defaultOptions) {
@@ -37,7 +38,7 @@ protected Scenario<String, String> defaultScenarioOptions(Scenario<String, Strin
 	}
 
 	@Override
-	protected List<Scenario<String, String>> scenarios_threeNextAndComplete() {
+	protected List<Scenario<String, String>> scenarios_operatorSuccess() {
 		return Arrays.asList(
 				scenario(f -> f.replay().autoConnect()),
 

File: src/test/java/reactor/guide/FakeRepository.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package reactor.misc;
+package reactor.guide;
 
 import reactor.core.publisher.Flux;
 

File: src/test/java/reactor/guide/FakeUtils1.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package reactor.misc;
+package reactor.guide;
 
 import java.util.function.Function;
 

File: src/test/java/reactor/guide/FakeUtils2.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package reactor.misc;
+package reactor.guide;
 
 import java.util.function.Function;
 

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -56,7 +56,7 @@ final class FluxBufferStartEnd<T, U, V, C extends Collection<? super T>>
 
 	final Supplier<? extends Queue<C>> queueSupplier;
 
-	public FluxBufferStartEnd(Publisher<? extends T> source,
+	FluxBufferStartEnd(Publisher<? extends T> source,
 			Publisher<U> start,
 			Function<? super U, ? extends Publisher<V>> end,
 			Supplier<C> bufferSupplier,
@@ -145,7 +145,7 @@ static final class BufferStartEndMainSubscriber<T, U, V, C extends Collection<?
 				AtomicIntegerFieldUpdater.newUpdater(BufferStartEndMainSubscriber.class,
 						"open");
 
-		public BufferStartEndMainSubscriber(Subscriber<? super C> actual,
+		BufferStartEndMainSubscriber(Subscriber<? super C> actual,
 				Supplier<C> bufferSupplier,
 				Queue<C> queue,
 				Function<? super U, ? extends Publisher<V>> end) {

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -449,7 +449,7 @@ static final class BufferAsyncSink<T> extends BaseSink<T> {
 		static final AtomicIntegerFieldUpdater<BufferAsyncSink> WIP =
 				AtomicIntegerFieldUpdater.newUpdater(BufferAsyncSink.class, "wip");
 
-		public BufferAsyncSink(Subscriber<? super T> actual, int capacityHint) {
+		 BufferAsyncSink(Subscriber<? super T> actual, int capacityHint) {
 			super(actual);
 			this.queue = QueueSupplier.<T>unbounded(capacityHint).get();
 		}

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -143,7 +143,7 @@ static final class GroupByMain<T, K, V>
 
 		volatile boolean enableAsyncFusion;
 
-		public GroupByMain(Subscriber<? super GroupedFlux<K, V>> actual,
+		GroupByMain(Subscriber<? super GroupedFlux<K, V>> actual,
 				Queue<GroupedFlux<K, V>> queue,
 				Supplier<? extends Queue<V>> groupQueueSupplier,
 				int prefetch,
@@ -695,7 +695,7 @@ public void onNext(V t) {
 			Subscriber<? super V> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow("Queue is full?!"), t));
+				onError(Operators.onOperatorError(this, Exceptions.failWithOverflow("Queue is full?!"), t));
 				return;
 			}
 			if (outputFused) {

File: src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -135,7 +135,7 @@ static final class IterableSubscription<T>
 
 		T current;
 
-		public IterableSubscription(Subscriber<? super T> actual,
+		IterableSubscription(Subscriber<? super T> actual,
 				Iterator<? extends T> iterator) {
 			this.actual = actual;
 			this.iterator = iterator;
@@ -303,7 +303,7 @@ public long requestedFromDownstream() {
 
 		@Override
 		public void clear() {
-			// no op
+			state = STATE_NO_NEXT;
 		}
 
 		@Override
@@ -559,7 +559,7 @@ public long requestedFromDownstream() {
 
 		@Override
 		public void clear() {
-			// no op
+			state = STATE_NO_NEXT;
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -268,7 +268,7 @@ public void innerNext(MergeSequentialInner<R> inner, R value) {
 			}
 			else {
 				inner.cancel();
-				innerError(inner, Exceptions.failWithOverflow());
+				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow("Queue is full?!"), value));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/FluxWindow.java
Patch:
@@ -137,7 +137,7 @@ static final class WindowExactSubscriber<T>
 
 		boolean done;
 
-		public WindowExactSubscriber(Subscriber<? super Flux<T>> actual,
+		WindowExactSubscriber(Subscriber<? super Flux<T>> actual,
 				int size,
 				Supplier<? extends Queue<T>> processorQueueSupplier) {
 			this.actual = actual;

File: src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -44,7 +44,7 @@ final class FluxWindowBoundary<T, U> extends FluxSource<T, Flux<T>> {
 
 	final Supplier<? extends Queue<Object>> drainQueueSupplier;
 
-	public FluxWindowBoundary(Publisher<? extends T> source, Publisher<U> other,
+	FluxWindowBoundary(Publisher<? extends T> source, Publisher<U> other,
 			Supplier<? extends Queue<T>> processorQueueSupplier,
 			Supplier<? extends Queue<Object>> drainQueueSupplier) {
 		super(source);

File: src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -46,7 +46,7 @@ final class FluxWithLatestFrom<T, U, R> extends FluxSource<T, R> {
 
 	final BiFunction<? super T, ? super U, ? extends R> combiner;
 
-	public FluxWithLatestFrom(Publisher<? extends T> source,
+	FluxWithLatestFrom(Publisher<? extends T> source,
 			Publisher<? extends U> other,
 			BiFunction<? super T, ? super U, ? extends R> combiner) {
 		super(source);
@@ -94,7 +94,7 @@ static final class WithLatestFromSubscriber<T, U, R>
 
 		volatile U otherValue;
 
-		public WithLatestFromSubscriber(Subscriber<? super R> actual,
+		WithLatestFromSubscriber(Subscriber<? super R> actual,
 				BiFunction<? super T, ? super U, ? extends R> combiner) {
 			this.actual = actual;
 			this.combiner = combiner;
@@ -238,7 +238,7 @@ static final class WithLatestFromOtherSubscriber<U> implements Subscriber<U> {
 
 		final WithLatestFromSubscriber<?, U, ?> main;
 
-		public WithLatestFromOtherSubscriber(WithLatestFromSubscriber<?, U, ?> main) {
+		 WithLatestFromOtherSubscriber(WithLatestFromSubscriber<?, U, ?> main) {
 			this.main = main;
 		}
 

File: src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -79,7 +79,7 @@ static final class EqualCoordinator<T> implements Subscription {
 		static final AtomicIntegerFieldUpdater<EqualCoordinator> WIP =
 				AtomicIntegerFieldUpdater.newUpdater(EqualCoordinator.class, "wip");
 
-		public EqualCoordinator(Subscriber<? super Boolean> actual, int bufferSize,
+		EqualCoordinator(Subscriber<? super Boolean> actual, int bufferSize,
 				Publisher<? extends T> first, Publisher<? extends T> second,
 				BiPredicate<? super T, ? super T> comparer) {
 			this.actual = actual;
@@ -270,7 +270,7 @@ static final class EqualSubscriber<T>
 				AtomicReferenceFieldUpdater.newUpdater(EqualSubscriber.class,
 						Subscription.class, "subscription");
 
-		public EqualSubscriber(EqualCoordinator<T> parent, int bufferSize) {
+		EqualSubscriber(EqualCoordinator<T> parent, int bufferSize) {
 			this.parent = parent;
 			this.bufferSize = bufferSize;
 			this.queue = QueueSupplier.<T>get(bufferSize).get();

File: src/main/java/reactor/util/concurrent/SpscArrayQueue.java
Patch:
@@ -37,7 +37,7 @@ final class SpscArrayQueue<T> extends SpscArrayQueueP3<T> implements Queue<T> {
 	/** */
 	private static final long serialVersionUID = 494623116936946976L;
 
-	public SpscArrayQueue(int capacity) {
+	SpscArrayQueue(int capacity) {
 		super(QueueSupplier.ceilingNextPowerOfTwo(capacity));
 	}
 	

File: src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -117,8 +117,9 @@ public void dispose() {
 	@Override
 	public Disposable schedule(Runnable task) {
 		try {
-			Future<?> f = executor.submit(task);
-			return () -> f.cancel(executor == TERMINATED);
+			return new ExecutorServiceScheduler.DisposableFuture(
+					executor.submit(task),
+					false);
 		}
 		catch (RejectedExecutionException ex) {
 			return REJECTED;

File: src/test/java/reactor/core/publisher/AbstractFluxOperatorTest.java
Patch:
@@ -307,7 +307,7 @@ public final void assertPrePostState() {
 				})
 				                                                .as(scenario.body());
 
-				if (source.getPrefetch() != UNSPECIFIED) {
+				if (source.getPrefetch() != UNSPECIFIED && scenario.prefetch() != UNSPECIFIED) {
 					assertThat(Math.min(source.getPrefetch(), Integer.MAX_VALUE)).isEqualTo(scenario.prefetch());
 				}
 
@@ -674,7 +674,7 @@ protected RuntimeException exception() {
 		return new RuntimeException("test");
 	}
 
-	protected Flux<I> finiteSourceOrDefault(Scenario<I, O> scenario) {
+	final Flux<I> finiteSourceOrDefault(Scenario<I, O> scenario) {
 		Flux<I> source = scenario != null ? scenario.finiteFlux() : null;
 		if (source == null) {
 			return Flux.just(item(0), item(1), item(2));

File: src/test/java/reactor/core/scheduler/ExecutorServiceInterruptSchedulerTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.scheduler;
 
+import java.util.concurrent.Executors;
 import java.util.concurrent.ForkJoinPool;
 
 import org.junit.Test;
@@ -26,7 +27,7 @@ public class ExecutorServiceInterruptSchedulerTest extends AbstractSchedulerTest
 
 	@Override
 	protected Scheduler scheduler() {
-		return Schedulers.fromExecutorService(ForkJoinPool.commonPool(), true);
+		return Schedulers.fromExecutorService(Executors.newSingleThreadExecutor(), true);
 	}
 
 	@Override

File: src/test/java/reactor/core/scheduler/ExecutorServiceSchedulerTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.scheduler;
 
+import java.util.concurrent.Executors;
 import java.util.concurrent.ForkJoinPool;
 
 import org.junit.Test;
@@ -26,7 +27,7 @@ public class ExecutorServiceSchedulerTest extends AbstractSchedulerTest {
 
 	@Override
 	protected Scheduler scheduler() {
-		return Schedulers.fromExecutor(ForkJoinPool.commonPool());
+		return Schedulers.fromExecutor(Executors.newSingleThreadExecutor());
 	}
 
 	@Override

File: src/test/java/reactor/core/scheduler/ElasticSchedulerTest.java
Patch:
@@ -55,9 +55,9 @@ public void eviction() throws Exception {
 			Disposable d = (Disposable)s.schedule(() -> Flux.never().blockFirst());
 			assertThat(d.isDisposed()).isFalse();
 			d.dispose();
-			while(((ElasticScheduler)s).cache.isEmpty());
+			while(((ElasticScheduler)s).cache.peek() == null);
 
-			while(!((ElasticScheduler)s).cache.isEmpty()){
+			while(((ElasticScheduler)s).cache.peek() != null){
 				((ElasticScheduler)s).eviction();
 			}
 		}

File: src/main/java/reactor/core/publisher/MonoElapsed.java
Patch:
@@ -29,7 +29,7 @@ final class MonoElapsed<T> extends MonoSource<T, Tuple2<Long, T>> implements Fus
 
 	final TimedScheduler scheduler;
 
-	public MonoElapsed(Publisher<T> source, TimedScheduler scheduler) {
+	MonoElapsed(Publisher<T> source, TimedScheduler scheduler) {
 		super(source);
 		this.scheduler = scheduler;
 	}

File: src/main/java/reactor/core/scheduler/SingleWorkerScheduler.java
Patch:
@@ -29,7 +29,7 @@ final class SingleWorkerScheduler implements Scheduler, Executor {
 
     final Worker main;
     
-    public SingleWorkerScheduler(Scheduler actual) {
+    SingleWorkerScheduler(Scheduler actual) {
         this.main = actual.createWorker();
     }
 

File: src/test/java/reactor/core/publisher/AbstractFluxOperatorTest.java
Patch:
@@ -395,6 +395,9 @@ public final void errorWithUserProvidedCallback() {
 				verifier = step -> {
 					try {
 						step.verifyErrorMessage(m);
+//						step.expectErrorMessage(m)
+//						.verifyThenAssertThat()
+//						.hasOperatorErrorWithMessage(m);
 					}
 					catch (Exception e) {
 						e.printStackTrace();

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -7318,4 +7318,7 @@ static <A, B> BiFunction<A, B, Tuple2<A, B>> tuple2Function() {
 	static final Function        HASHCODE_EXTRACTOR      = Object::hashCode;
 	@SuppressWarnings("rawtypes")
     static final Function        IDENTITY_FUNCTION       = Function.identity();
+
+	static final Disposable CANCELLED = () -> {
+	};
 }

File: src/main/java/reactor/core/publisher/FluxBufferTimeOrSize.java
Patch:
@@ -87,7 +87,8 @@ public void nextCallback(T value) {
 			synchronized (this) {
 				C v = values;
 				if(v == null) {
-					v = bufferSupplier.get();
+					v = Objects.requireNonNull(bufferSupplier.get(),
+							"The bufferSupplier returned a null buffer");
 					values = v;
 				}
 				v.add(value);

File: src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -49,7 +49,7 @@ public void subscribe(Subscriber<? super T> s) {
 
 		Cancellation f = scheduler.schedule(parent);
 		if (f == Scheduler.REJECTED) {
-			if(parent.state != FluxSubscribeOnCallable.CallableSubscribeOnSubscription.CANCELLED) {
+			if(parent.state != FluxSubscribeOnCallable.CallableSubscribeOnSubscription.HAS_CANCELLED) {
 				s.onError(Operators.onRejectedExecution());
 			}
 		}

File: src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -48,7 +48,7 @@ public void subscribe(Subscriber<? super T> s) {
 			s.onSubscribe(parent);
 			Cancellation f = scheduler.schedule(parent);
 			if (f == Scheduler.REJECTED) {
-				if(parent.future != ScheduledEmpty.CANCELLED) {
+				if(parent.future != Flux.CANCELLED) {
 					s.onError(Operators.onRejectedExecution());
 				}
 			}

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -905,7 +905,7 @@ public final void complete(O v) {
 					return;
 				}
 
-				// if state is >= CANCELLED or bit zero is set (*_HAS_VALUE) case, return
+				// if state is >= HAS_CANCELLED or bit zero is set (*_HAS_VALUE) case, return
 				if ((state & ~HAS_REQUEST_NO_VALUE) != 0) {
 					return;
 				}

File: src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -36,7 +36,7 @@ final class ParallelGroup<T> extends Flux<GroupedFlux<Integer, T>> implements Fu
 
 	final ParallelFlux<? extends T> source;
 
-	public ParallelGroup(ParallelFlux<? extends T> source) {
+	ParallelGroup(ParallelFlux<? extends T> source) {
 		this.source = source;
 	}
 	

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -364,7 +364,8 @@ public void subscribe(Subscriber<? super T> s) {
 				drain();
 			}
 		} else {
-			Operators.error(s, new IllegalStateException("This processor allows only a single Subscriber"));
+			Operators.error(s, new IllegalStateException("UnicastProcessor " +
+					"allows only a single Subscriber"));
 		}
 	}
 

File: src/test/java/reactor/core/publisher/FluxCacheTest.java
Patch:
@@ -28,7 +28,7 @@ public class FluxCacheTest {
 	@Test
 	public void cacheFlux() {
 		try {
-			VirtualTimeScheduler vts = VirtualTimeScheduler.enable(false);
+			VirtualTimeScheduler vts = VirtualTimeScheduler.getOrSet(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
 			                                         .delayElementsMillis(1000)
@@ -57,7 +57,7 @@ public void cacheFlux() {
 	@Test
 	public void cacheFluxTTL() {
 		try {
-			VirtualTimeScheduler vts = VirtualTimeScheduler.enable(false);
+			VirtualTimeScheduler vts = VirtualTimeScheduler.getOrSet(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
 			                                         .delayElementsMillis(1000)
@@ -85,7 +85,7 @@ public void cacheFluxTTL() {
 	@Test
 	public void cacheFluxHistoryTTL() {
 		try {
-			VirtualTimeScheduler vts = VirtualTimeScheduler.enable(false);
+			VirtualTimeScheduler vts = VirtualTimeScheduler.getOrSet(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
 			                                         .delayElementsMillis(1000)

File: src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
+import org.reactivestreams.Subscription;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.StepVerifier;
 
@@ -50,6 +51,7 @@ public void cancellation() {
 		AtomicInteger cancelled = new AtomicInteger();
 		StepVerifier.create(Mono.create(s -> s.setCancellation(cancelled::getAndIncrement)))
 		            .thenAwait()
+		            .consumeSubscriptionWith(Subscription::cancel)
 		            .thenCancel()
 		            .verify();
 		assertThat(cancelled.get()).isEqualTo(1);

File: src/test/java/reactor/core/publisher/MonoDelayElementTest.java
Patch:
@@ -161,7 +161,7 @@ public void onNextOnDisposedSchedulerThrows() {
 		catch (Throwable e) {
 			Throwable t = Exceptions.unwrap(e);
 
-			assertThat(t).isNotEqualTo(e)
+			assertThat(t).isEqualTo(e)
 		                 .isInstanceOf(RejectedExecutionException.class)
 		                 .hasMessage("Scheduler unavailable");
 

File: src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -103,11 +103,11 @@ public void onNext(T t) {
 				actual.onNext(v);
 			}
 			if(stop){
-				s.cancel();
 				if(error != null){
 					onError(Operators.onOperatorError(s, error, t));
 					return;
 				}
+				s.cancel();
 				onComplete();
 			}
 			else if(v == null){
@@ -135,11 +135,11 @@ public boolean tryOnNext(T t) {
 				actual.onNext(v);
 			}
 			if(stop){
-				s.cancel();
 				if(error != null){
 					onError(Operators.onOperatorError(s, error, t));
 				}
 				else {
+					s.cancel();
 					onComplete();
 				}
 				return true;

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -45,7 +45,7 @@ final class FluxCreate<T> extends Flux<T> {
 
 	final OverflowStrategy backpressure;
 
-	public FluxCreate(Consumer<? super FluxSink<T>> source,
+	FluxCreate(Consumer<? super FluxSink<T>> source,
 			FluxSink.OverflowStrategy backpressure) {
 		this.source = Objects.requireNonNull(source, "source");
 		this.backpressure = Objects.requireNonNull(backpressure, "backpressure");

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -30,7 +30,7 @@ final class MonoJust<T>
 
 	final T value;
 
-	public MonoJust(T value) {
+	MonoJust(T value) {
 		this.value = Objects.requireNonNull(value, "value");
 	}
 

File: src/main/java/reactor/core/publisher/SerializedSubscriber.java
Patch:
@@ -55,7 +55,7 @@ final class SerializedSubscriber<T> implements Subscriber<T>, Subscription, Rece
 
 	Subscription s;
 
-	public SerializedSubscriber(Subscriber<? super T> actual) {
+	SerializedSubscriber(Subscriber<? super T> actual) {
 		this.actual = actual;
 	}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2399,7 +2399,7 @@ public final <E> Mono<E> collect(Supplier<E> containerSupplier, BiConsumer<E, ?
 	 * @return a {@link Mono} sequence of the collected value on complete
 	 *
 	 */
-	public final <R, A> Mono<R> collect(Collector<T, A, R> collector) {
+	public final <R, A> Mono<R> collect(Collector<? super T, A, ? extends R> collector) {
 		return Mono.onAssembly(new MonoStreamCollector<>(this, collector));
 	}
 

File: src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -513,7 +513,7 @@ public void clear() {
 		public boolean isEmpty() {
 			State<T> p = parent;
 			if(p != null) {
-				p.buffer.isEmpty(this);
+				return p.buffer.isEmpty(this);
 			}
 			return true;
 		}
@@ -522,7 +522,7 @@ public boolean isEmpty() {
 		public int size() {
 			State<T> p = parent;
 			if(p != null) {
-				p.buffer.size(this);
+				return p.buffer.size(this);
 			}
 			return 0;
 		}

File: src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -222,7 +222,7 @@ public void onNext(T t) {
 			if (!queue.offer(t)) {
 				Operators.terminate(S, this);
 				
-				onError(Exceptions.failWithOverflow("Queue full?!"));
+				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow("Queue is full?!"), t));
 			} else {
 				signalConsumer();
 			}

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -208,7 +208,7 @@ else if (m == Fuseable.ASYNC) {
 		public void onNext(T t) {
 			if (fusionMode != Fuseable.ASYNC) {
 				if (!queue.offer(t)) {
-					onError(Exceptions.failWithOverflow("Queue is full?!"));
+					onError(Operators.onOperatorError(s,Exceptions.failWithOverflow("Queue is full?!")));
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -707,7 +707,7 @@ public void onNext(V t) {
 			Subscriber<? super V> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(Exceptions.failWithOverflow("The queue is full"));
+				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow("Queue is full?!"), t));
 				return;
 			}
 			if (outputFused) {

File: src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -225,7 +225,7 @@ public void onNext(T t) {
 			}
 			
 			if (!queue.offer(t)) {
-				Throwable ex = Exceptions.failWithOverflow("Queue full?!");
+				Throwable ex = Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t);
 				if (!Exceptions.addThrowable(ERROR, this, ex)) {
 					Operators.onErrorDropped(ex);
 					return;

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -765,9 +765,7 @@ public void onNext(T t) {
 				return;
 			}
 			if (!queue.offer(t)) {
-				s.cancel();
-
-				error = Exceptions.failWithOverflow("Queue is full?!");
+				error = Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t);
 				done = true;
 			}
 			if (trySchedule() == Scheduler.REJECTED) {

File: src/main/java/reactor/core/publisher/FluxWindowPredicate.java
Patch:
@@ -737,7 +737,7 @@ public void onNext(T t) {
 			Subscriber<? super T> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(Exceptions.failWithOverflow("The queue is full"));
+				onError(Operators.onOperatorError(null, Exceptions.failWithOverflow("Queue is full?!"), t));
 				return;
 			}
 			if (enableOperatorFusion) {

File: src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -292,7 +292,8 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (!queue.offer(t)) {
-				onError(Exceptions.failWithOverflow("Queue full?!"));
+				onError(Operators.onOperatorError(cachedSubscription, Exceptions
+						.failWithOverflow("Queue is full?!"), t));
 				return;
 			}
 			parent.drain();

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -307,7 +307,8 @@ public void onNext(T t) {
 		}
 
 		if (!queue.offer(t)) {
-			Throwable ex = Exceptions.failWithOverflow();
+			Throwable ex = Operators.onOperatorError(null,
+					Exceptions.failWithOverflow(), t);
 			if(onOverflow != null) {
 				try {
 					onOverflow.accept(t);

File: src/main/java/reactor/core/publisher/FluxWindowOnCancel.java
Patch:
@@ -100,7 +100,6 @@ public void onNext(T t) {
 				Operators.onNextDropped(t);
 				return;
 			}
-
 			UnicastProcessor<T> w = window;
 			if (w == null || w.cancelled) {
 				WIP.getAndIncrement(this);
@@ -120,6 +119,7 @@ public void onError(Throwable t) {
 				Operators.onErrorDropped(t);
 				return;
 			}
+			done = true;
 			Processor<T, T> w = window;
 			if (w != null) {
 				window = null;
@@ -134,7 +134,7 @@ public void onComplete() {
 			if (done) {
 				return;
 			}
-
+			done = true;
 			Processor<T, T> w = window;
 			if (w != null) {
 				window = null;

File: src/test/java/reactor/core/publisher/AbstractFluxOperatorTest.java
Patch:
@@ -717,7 +717,8 @@ final StepVerifier.Step<O> operatorErrorSourceVerifierTryNext(Scenario<I, O> sce
 
 	final StepVerifier.Step<O> operatorErrorSourceVerifier(Scenario<I, O> scenario) {
 		TestPublisher<I> ts =
-				TestPublisher.createNoncompliant(TestPublisher.Violation.CLEANUP_ON_TERMINATE);
+				TestPublisher.createNoncompliant(TestPublisher.Violation
+						.CLEANUP_ON_TERMINATE, TestPublisher.Violation.REQUEST_OVERFLOW);
 		AtomicBoolean nextDropped = new AtomicBoolean();
 
 		Hooks.onNextDropped(d -> {

File: src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -305,6 +305,7 @@ static <T> void afterCompleteWithFailure(SignalPeek<T> parent,
 			Operators.onErrorDropped(e);
 		}
 		catch (Throwable t) {
+			t = Exceptions.unwrap(t);
 			if(e != t) {
 				t.addSuppressed(e);
 			}
@@ -343,6 +344,7 @@ static <T> void afterErrorWithFailure(SignalPeek<T> parent,
 			Operators.onErrorDropped(_e);
 		}
 		catch (Throwable t) {
+			t = Exceptions.unwrap(t);
 			if(_e != t) {
 				t.addSuppressed(_e);
 			}

File: src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -45,10 +45,10 @@ final class FluxSkipUntil<T> extends FluxSource<T, T> {
 
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		source.subscribe(new SkipWhileSubscriber<>(s, predicate));
+		source.subscribe(new SkipUntilSubscriber<>(s, predicate));
 	}
 
-	static final class SkipWhileSubscriber<T>
+	static final class SkipUntilSubscriber<T>
 			implements ConditionalSubscriber<T>, Receiver, Producer, Loopback,
 			           Subscription, Trackable {
 		final Subscriber<? super T> actual;
@@ -61,7 +61,7 @@ static final class SkipWhileSubscriber<T>
 
 		boolean skipped;
 
-		SkipWhileSubscriber(Subscriber<? super T> actual, Predicate<? super T> predicate) {
+		SkipUntilSubscriber(Subscriber<? super T> actual, Predicate<? super T> predicate) {
 			this.actual = actual;
 			this.predicate = predicate;
 		}

File: src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -27,7 +27,7 @@
  */
 final class FluxTakeLastOne<T> extends FluxSource<T, T> implements Fuseable {
 
-	public FluxTakeLastOne(Publisher<? extends T> source) {
+	FluxTakeLastOne(Publisher<? extends T> source) {
 		super(source);
 	}
 

File: src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -212,7 +212,7 @@ final OperatorHook<T> doOnSignal(
 				}
 			}
 			else if (publisher instanceof ParallelFlux){
-				Publisher<T> _p = new ParallelUnorderedPeek<>((ParallelFlux<T>) publisher,
+				Publisher<T> _p = new ParallelPeek<>((ParallelFlux<T>) publisher,
 						onNextCall, null, onErrorCall, onCompleteCall,
 						onAfterTerminateCall, onSubscribeCall, onRequestCall,
 						onCancelCall);

File: src/main/java/reactor/core/publisher/ParallelArraySource.java
Patch:
@@ -24,10 +24,10 @@
  * 
  * @param <T> the value type
  */
-final class ParallelUnorderedFrom<T> extends ParallelFlux<T> {
+final class ParallelArraySource<T> extends ParallelFlux<T> {
 	final Publisher<T>[] sources;
 	
-	public ParallelUnorderedFrom(Publisher<T>[] sources) {
+	public ParallelArraySource(Publisher<T>[] sources) {
 		this.sources = sources;
 	}
 	

File: src/main/java/reactor/core/publisher/ParallelConcatMap.java
Patch:
@@ -28,7 +28,7 @@
  * @param <T> the input value type
  * @param <R> the output value type
  */
-final class ParallelUnorderedConcatMap<T, R> extends ParallelFlux<R> {
+final class ParallelConcatMap<T, R> extends ParallelFlux<R> {
 
 	final ParallelFlux<T> source;
 	
@@ -40,7 +40,7 @@ final class ParallelUnorderedConcatMap<T, R> extends ParallelFlux<R> {
 	
 	final ErrorMode errorMode;
 
-	public ParallelUnorderedConcatMap(
+	public ParallelConcatMap(
 			ParallelFlux<T> source,
 			Function<? super T, ? extends Publisher<? extends R>> mapper, 
 					Supplier<? extends Queue<T>> queueSupplier,

File: src/main/java/reactor/core/publisher/ParallelFilter.java
Patch:
@@ -24,13 +24,13 @@
  *
  * @param <T> the input value type
  */
-final class ParallelUnorderedFilter<T> extends ParallelFlux<T> {
+final class ParallelFilter<T> extends ParallelFlux<T> {
 
 	final ParallelFlux<T> source;
 	
 	final Predicate<? super T> predicate;
 	
-	public ParallelUnorderedFilter(ParallelFlux<T> source, Predicate<? super T> predicate) {
+	public ParallelFilter(ParallelFlux<T> source, Predicate<? super T> predicate) {
 		this.source = source;
 		this.predicate = predicate;
 	}

File: src/main/java/reactor/core/publisher/ParallelJoin.java
Patch:
@@ -29,12 +29,12 @@
  *
  * @param <T> the value type
  */
-final class ParallelUnorderedJoin<T> extends Flux<T> {
+final class ParallelJoin<T> extends Flux<T> {
 	final ParallelFlux<? extends T> source;
 	final int prefetch;
 	final Supplier<Queue<T>> queueSupplier;
 	
-	public ParallelUnorderedJoin(ParallelFlux<? extends T> source, int prefetch, Supplier<Queue<T>> queueSupplier) {
+	public ParallelJoin(ParallelFlux<? extends T> source, int prefetch, Supplier<Queue<T>> queueSupplier) {
 		this.source = source;
 		this.prefetch = prefetch;
 		this.queueSupplier = queueSupplier;

File: src/main/java/reactor/core/publisher/ParallelMap.java
Patch:
@@ -25,13 +25,13 @@
  * @param <T> the input value type
  * @param <R> the output value type
  */
-final class ParallelUnorderedMap<T, R> extends ParallelFlux<R> {
+final class ParallelMap<T, R> extends ParallelFlux<R> {
 
 	final ParallelFlux<T> source;
 	
 	final Function<? super T, ? extends R> mapper;
 	
-	public ParallelUnorderedMap(ParallelFlux<T> source, Function<? super T, ? extends R> mapper) {
+	public ParallelMap(ParallelFlux<T> source, Function<? super T, ? extends R> mapper) {
 		this.source = source;
 		this.mapper = mapper;
 	}

File: src/main/java/reactor/core/publisher/ParallelPeek.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @param <T> the value type
  */
-final class ParallelUnorderedPeek<T> extends ParallelFlux<T> implements SignalPeek<T>{
+final class ParallelPeek<T> extends ParallelFlux<T> implements SignalPeek<T>{
 
 	final ParallelFlux<T> source;
 	
@@ -39,7 +39,7 @@ final class ParallelUnorderedPeek<T> extends ParallelFlux<T> implements SignalPe
 	final LongConsumer onRequest;
 	final Runnable onCancel;
 
-	public ParallelUnorderedPeek(ParallelFlux<T> source,
+	public ParallelPeek(ParallelFlux<T> source,
 			Consumer<? super T> onNext,
 			Consumer<? super T> onAfterNext,
 			Consumer<? super Throwable> onError,

File: src/main/java/reactor/core/publisher/ParallelRunOn.java
Patch:
@@ -29,7 +29,7 @@
  *
  * @param <T> the value type
  */
-final class ParallelUnorderedRunOn<T> extends ParallelFlux<T> implements Fuseable {
+final class ParallelRunOn<T> extends ParallelFlux<T> implements Fuseable {
 	final ParallelFlux<? extends T> source;
 	
 	final Scheduler scheduler;
@@ -38,7 +38,7 @@ final class ParallelUnorderedRunOn<T> extends ParallelFlux<T> implements Fuseabl
 
 	final Supplier<Queue<T>> queueSupplier;
 	
-	public ParallelUnorderedRunOn(ParallelFlux<? extends T> parent,
+	public ParallelRunOn(ParallelFlux<? extends T> parent,
 			Scheduler scheduler, int prefetch, Supplier<Queue<T>> queueSupplier) {
 		this.source = parent;
 		this.scheduler = scheduler;

File: src/main/java/reactor/core/publisher/ParallelSource.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @param <T> the value type
  */
-final class ParallelUnorderedSource<T> extends ParallelFlux<T> {
+final class ParallelSource<T> extends ParallelFlux<T> {
 	final Publisher<? extends T> source;
 	
 	final int parallelism;
@@ -42,7 +42,7 @@ final class ParallelUnorderedSource<T> extends ParallelFlux<T> {
 	
 	final Supplier<Queue<T>> queueSupplier;
 
-	public ParallelUnorderedSource(Publisher<? extends T> source, int parallelism, int prefetch, Supplier<Queue<T>> queueSupplier) {
+	public ParallelSource(Publisher<? extends T> source, int parallelism, int prefetch, Supplier<Queue<T>> queueSupplier) {
 		this.source = source;
 		this.parallelism = parallelism;
 		this.prefetch = prefetch;

File: src/test/java/reactor/core/publisher/scenarios/AbstractReactorTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2016 Pivotal Software Inc, All Rights Reserved.
+ * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package reactor.core.publisher;
+package reactor.core.publisher.scenarios;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;

File: src/test/java/reactor/core/publisher/scenarios/BurstyWorkQueueProcessorTests.java
Patch:
@@ -111,7 +111,7 @@ public Runnable burstyProducerRunnable(final FluxSink<Object> emitter, int count
 			burstSize) {
 		return () -> {
 
-			// Let's start with some messages to keep the ringbuffer from going total empty
+			// Let's start with some messages to keep the ringbuffer scenario going total empty
 			for (int i = 0; i < INITAL_MESSAGES_COUNT; ++i) {
 				emitter.next("initial" + i);
 			}

File: src/test/java/reactor/core/publisher/scenarios/FizzBuzzTests.java
Patch:
@@ -23,7 +23,6 @@
 
 import org.junit.Assert;
 import org.junit.Test;
-import reactor.core.publisher.AbstractReactorTest;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.TopicProcessor;

File: src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java
Patch:
@@ -23,7 +23,6 @@
 import org.junit.Test;
 import reactor.core.Disposable;
 import reactor.util.Loggers;
-import reactor.core.publisher.AbstractReactorTest;
 import reactor.core.publisher.Flux;
 import reactor.util.function.Tuples;
 

File: src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -168,7 +168,7 @@ public void testUncaughtHookNotCalledWhenThreadDeath() {
 		AtomicBoolean handled = new AtomicBoolean(false);
 		AtomicReference<String> failure = new AtomicReference<>(null);
 		Thread.setDefaultUncaughtExceptionHandler((t, e) -> failure.set("unexpected call to default" +
-				" UncaughtExceptionHandler from " + t.getName() + ": " + e));
+				" UncaughtExceptionHandler scenario " + t.getName() + ": " + e));
 		Schedulers.onHandleError((t, e) -> {
 			handled.set(true);
 			failure.set("Fatal JVM error was unexpectedly handled in " + t.getName() + ": " + e);

File: src/test/java/reactor/test/subscriber/AssertSubscriber.java
Patch:
@@ -57,7 +57,7 @@
  * {@code await*()} methods to wait for the data to assert.
  *
  * <p> You can extend this class but only the onNext, onError and onComplete can be overridden.
- * You can call {@link #request(long)} and {@link #cancel()} from any thread or from within
+ * You can call {@link #request(long)} and {@link #cancel()} scenario any thread or scenario within
  * the overridable methods but you should avoid calling the assertXXX methods asynchronously.
  *
  * <p>Usage:
@@ -955,7 +955,7 @@ public final long requestedFromDownstream() {
 	}
 
 	/**
-	 * Setup what fusion mode should be requested from the incoming
+	 * Setup what fusion mode should be requested scenario the incoming
 	 * Subscription if it happens to be QueueSubscription
 	 * @param requestMode the mode to request, see Fuseable constants
 	 * @return this
@@ -1006,7 +1006,7 @@ protected final void requestDeferred() {
 	}
 
 	/**
-	 * Atomically sets the single subscription and requests the missed amount from it.
+	 * Atomically sets the single subscription and requests the missed amount scenario it.
 	 *
 	 * @param s
 	 * @return false if this arbiter is cancelled or there was a subscription already set

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -165,7 +165,7 @@ static <T, R> boolean trySubscribeScalarMap(Publisher<? extends T> source,
 				}
 
 				if (v != null) {
-					s.onSubscribe(new Operators.ScalarSubscription<>(s, v));
+					s.onSubscribe(Operators.scalarSubscription(s, v));
 				}
 				else {
 					Operators.complete(s);

File: src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -57,7 +57,7 @@ public void subscribe(Subscriber<? super Integer> s) {
 			return;
 		} else
 		if (st + 1 == en) {
-			s.onSubscribe(new Operators.ScalarSubscription<>(s, (int)st));
+			s.onSubscribe(Operators.scalarSubscription(s, (int)st));
 			return;
 		}
 		

File: src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -240,7 +240,7 @@ public boolean isStarted() {
 
 		@Override
 		public long requestedFromDownstream() {
-			return requested - produced;
+			return requested;
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -145,7 +145,7 @@ public void onNext(T t) {
                 if (v == null) {
                     actual.onComplete();
                 } else {
-                    onSubscribeInner(new Operators.ScalarSubscription<>(actual, v));
+                    onSubscribeInner(Operators.scalarSubscription(actual, v));
                 }
                 
                 return;

File: src/main/java/reactor/core/publisher/MonoHandleFuseable.java
Patch:
@@ -37,7 +37,7 @@ final class MonoHandleFuseable<T, R> extends MonoSource<T, R>
 
 	final BiConsumer<? super T, SynchronousSink<R>> handler;
 
-	public MonoHandleFuseable(Publisher<? extends T> source, BiConsumer<? super T, SynchronousSink<R>> handler) {
+	MonoHandleFuseable(Publisher<? extends T> source, BiConsumer<? super T, SynchronousSink<R>> handler) {
 		super(source);
 		this.handler = Objects.requireNonNull(handler, "handler");
 	}

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -51,7 +51,7 @@ public T block() {
 
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		s.onSubscribe(new Operators.ScalarSubscription<>(s, value));
+		s.onSubscribe(Operators.scalarSubscription(s, value));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -401,7 +401,7 @@ public void subscribe(final Subscriber<? super O> subscriber) {
 				return;
 			}
 			else if (endState == STATE_SUCCESS_VALUE) {
-				subscriber.onSubscribe(new Operators.ScalarSubscription<>(subscriber, value));
+				subscriber.onSubscribe(Operators.scalarSubscription(subscriber, value));
 				return;
 			}
 			else if (endState == STATE_ERROR) {

File: src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -34,7 +34,7 @@ final class MonoSubscribeOnValue<T> extends Mono<T> {
 	
 	final Scheduler scheduler;
 
-	public MonoSubscribeOnValue(T value, 
+	MonoSubscribeOnValue(T value,
 			Scheduler scheduler) {
 		this.value = value;
 		this.scheduler = Objects.requireNonNull(scheduler, "scheduler");

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -1597,7 +1597,7 @@ static final class ScalarSubscription<T>
 		static final AtomicIntegerFieldUpdater<ScalarSubscription> ONCE =
 				AtomicIntegerFieldUpdater.newUpdater(ScalarSubscription.class, "once");
 
-		public ScalarSubscription(Subscriber<? super T> actual, T value) {
+		ScalarSubscription(Subscriber<? super T> actual, T value) {
 			this.value = Objects.requireNonNull(value, "value");
 			this.actual = Objects.requireNonNull(actual, "actual");
 		}

File: src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java
Patch:
@@ -89,7 +89,7 @@ static final class ExecutorServiceWorker implements Worker {
 
 		OpenHashSet<ScheduledRunnable> tasks;
 
-		public ExecutorServiceWorker(ExecutorService executor, boolean interruptOnCancel) {
+		ExecutorServiceWorker(ExecutorService executor, boolean interruptOnCancel) {
 			this.executor = executor;
 			this.interruptOnCancel = interruptOnCancel;
 			this.tasks = new OpenHashSet<>();
@@ -183,7 +183,7 @@ static final class ScheduledRunnable
 		static final AtomicReferenceFieldUpdater<ScheduledRunnable, Thread> CURRENT =
 				AtomicReferenceFieldUpdater.newUpdater(ScheduledRunnable.class, Thread.class, "current");
 
-		public ScheduledRunnable(Runnable task, ExecutorServiceWorker parent) {
+		ScheduledRunnable(Runnable task, ExecutorServiceWorker parent) {
 			this.task = task;
 			this.parent = parent;
 		}

File: src/main/java/reactor/util/concurrent/QueueSupplier.java
Patch:
@@ -279,7 +279,7 @@ public <T1> T1[] toArray(T1[] a) {
         private static final long serialVersionUID = -6079491923525372331L;
 	}
 
-	static class QueueIterator<T> implements Iterator<T> {
+	static final class QueueIterator<T> implements Iterator<T> {
 
 		final Queue<T> queue;
 

File: src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -151,12 +151,11 @@ protected List<Scenario<String, String>> scenarios_errorInOperatorCallback() {
 
 				Scenario.from(f -> f.doOnCancel(() -> {
 					throw exception();
-				})
-				                    .take(1).take(0), Fuseable.NONE, step -> {
+				}), Fuseable.NONE, Flux.never(), step -> {
 						//fixme Support bubbled error verification in reactor-test
 						Hooks.onErrorDropped(d -> assertTrue(d.getMessage(), d.getMessage()
 						                                                      .equals("test")));
-						step.verifyErrorMessage("test");
+						step.consumeSubscriptionWith(Subscription::cancel).verifyErrorMessage("test");
 				}));
 	}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4064,7 +4064,7 @@ public final Flux<T> mapError(Function<? super Throwable, ? extends Throwable> m
 
 	/**
 	 * Transform the error emitted by this {@link Flux} by applying a function if the
-	 * error matches the given type, otherwise let the error flows.
+	 * error matches the given type, otherwise let the error flow.
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/maperror.png" alt="">
 	 * <p>
@@ -4083,7 +4083,7 @@ public final <E extends Throwable> Flux<T> mapError(Class<E> type,
 
 	/**
 	 * Transform the error emitted by this {@link Flux} by applying a function if the
-	 * error matches the given predicate, otherwise let the error flows.
+	 * error matches the given predicate, otherwise let the error flow.
 	 * <p>
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/maperror.png"

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2012,7 +2012,7 @@ public final Mono<T> mapError(Function<Throwable, ? extends Throwable> mapper) {
 
 	/**
 	 * Transform the error emitted by this {@link Mono} by applying a function if the
-	 * error matches the given type, otherwise let the error flows.
+	 * error matches the given type, otherwise let the error flow.
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/maperror.png" alt="">
 	 * <p>
@@ -2031,7 +2031,7 @@ public final <E extends Throwable> Mono<T> mapError(Class<E> type,
 
 	/**
 	 * Transform the error emitted by this {@link Mono} by applying a function if the
-	 * error matches the given predicate, otherwise let the error flows.
+	 * error matches the given predicate, otherwise let the error flow.
 	 * <p>
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/maperror.png"

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -369,7 +369,7 @@ public static Throwable onOperatorError(Subscription subscription, Throwable
 				Hooks.onOperatorErrorHook;
 		if (hook == null) {
 			if (dataSignal != null) {
-				if (dataSignal instanceof Throwable) {
+				if (dataSignal != t && dataSignal instanceof Throwable) {
 					t.addSuppressed((Throwable) dataSignal);
 				}
 				//do not wrap original value to avoid strong references

File: src/test/java/reactor/core/publisher/FluxThenManyTest.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * @author Stephane Maldini
  */
-public class FluxThenMany {
+public class FluxThenManyTest {
 
 	@Test
 	public void testThenManySameType() throws InterruptedException {

File: src/test/java/reactor/core/publisher/FluxRepeatWhenTest.java
Patch:
@@ -147,7 +147,7 @@ public void repeaterErrorsInResponse() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
 		Flux.range(1, 2)
-		    .repeatWhen(v -> new FluxMap<>(v, a -> {
+		    .repeatWhen(v -> v.map(a -> {
 			    throw new RuntimeException("forced failure");
 		    }))
 		    .subscribe(ts);

File: src/test/java/reactor/core/publisher/FluxRetryWhenTest.java
Patch:
@@ -148,7 +148,7 @@ public void whenFactoryReturnsNull() {
 	public void retryErrorsInResponse() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 
-		rangeError.retryWhen(v -> new FluxMap<>(v, a -> {
+		rangeError.retryWhen(v -> v.map(a -> {
 			throw new RuntimeException("forced failure");
 		}))
 		          .subscribe(ts);

File: src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -241,7 +241,7 @@ public boolean tryOnNext(T t) {
 				v = mapper.apply(t);
 			} catch (Throwable e) {
 				done = true;
-				onError(Operators.onOperatorError(s, e, t));
+				actual.onError(Operators.onOperatorError(s, e, t));
 				return true;
 			}
 

File: src/test/java/reactor/core/publisher/FluxTakeTest.java
Patch:
@@ -170,7 +170,6 @@ public void cancel() {
 	}
 
 	@Test
-	@Ignore //FIXME when reactor-test is sync
 	public void takeFusedBackpressured() {
 		UnicastProcessor<String> up = UnicastProcessor.create();
 		StepVerifier.create(up.take(3), 0)
@@ -309,7 +308,7 @@ public void failNextIfTerminatedTakeConditional() {
 		Hooks.resetOnNextDropped();
 	}
 
-	@Test
+	@Test // fixme when we have a fuseable testPublisher or an improved hide operator
 	@SuppressWarnings("unchecked")
 	public void failNextIfTerminatedTakeSourceConditional() {
 		Hooks.onNextDropped(t -> assertThat(t).isEqualTo(1));
@@ -361,7 +360,6 @@ public void takeFusedSync() {
 	}
 
 	@Test
-	@Ignore //FIXME when reactor-test is sync
 	public void takeFusedAsync() {
 		UnicastProcessor<String> up = UnicastProcessor.create();
 		StepVerifier.create(up.take(2))

File: src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -318,8 +318,8 @@ public void singleSchedulerPipelining() throws Exception {
 
 			dispatcher.schedule(() -> { t2[0] = Thread.currentThread(); cdl.countDown(); });
 
-			if (!cdl.await(5, TimeUnit.MILLISECONDS)) {
-				Assert.fail("ringBufferDispatcher timed out");
+			if (!cdl.await(5, TimeUnit.SECONDS)) {
+				Assert.fail("single timed out");
 			}
 
 			Assert.assertNotSame(t1, t2[0]);

File: src/test/java/reactor/core/publisher/FluxBufferBoundaryTest.java
Patch:
@@ -246,7 +246,7 @@ public void bufferSupplierReturnsNUll() {
 
 	Flux<List<Integer>> scenario_bufferWillSubdivideAnInputFluxTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
-		           .delay(Duration.ofMillis(99))
+		           .delayElements(Duration.ofMillis(99))
 		           .buffer(Duration.ofMillis(200));
 	}
 
@@ -263,7 +263,7 @@ public void bufferWillSubdivideAnInputFluxTime() {
 
 	Flux<List<Integer>> scenario_bufferWillSubdivideAnInputFluxTime2() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
-		           .delay(Duration.ofMillis(99))
+		           .delayElements(Duration.ofMillis(99))
 		           .bufferMillis(200);
 	}
 

File: src/test/java/reactor/core/publisher/FluxBufferTimeOrSizeTest.java
Patch:
@@ -27,7 +27,7 @@ public class FluxBufferTimeOrSizeTest {
 
 	Flux<List<Integer>> scenario_bufferWithTimeoutAccumulateOnTimeOrSize() {
 		return Flux.range(1, 6)
-		           .delay(Duration.ofMillis(300))
+		           .delayElements(Duration.ofMillis(300))
 		           .buffer(5, Duration.ofMillis(2000));
 	}
 
@@ -43,7 +43,7 @@ public void bufferWithTimeoutAccumulateOnTimeOrSize() {
 
 	Flux<List<Integer>> scenario_bufferWithTimeoutAccumulateOnTimeOrSize2() {
 		return Flux.range(1, 6)
-		           .delay(Duration.ofMillis(300))
+		           .delayElements(Duration.ofMillis(300))
 		           .bufferMillis(5, 2000);
 	}
 

File: src/test/java/reactor/core/publisher/FluxCacheTest.java
Patch:
@@ -31,7 +31,7 @@ public void cacheFlux() {
 			VirtualTimeScheduler vts = VirtualTimeScheduler.enable(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
-			                                         .delayMillis(1000)
+			                                         .delayElementsMillis(1000)
 			                                         .cache()
 			                                         .elapsed();
 
@@ -60,7 +60,7 @@ public void cacheFluxTTL() {
 			VirtualTimeScheduler vts = VirtualTimeScheduler.enable(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
-			                                         .delayMillis(1000)
+			                                         .delayElementsMillis(1000)
 			                                         .cache(Duration.ofMillis(2000))
 			                                         .elapsed();
 
@@ -88,7 +88,7 @@ public void cacheFluxHistoryTTL() {
 			VirtualTimeScheduler vts = VirtualTimeScheduler.enable(false);
 
 			Flux<Tuple2<Long, Integer>> source = Flux.just(1, 2, 3)
-			                                         .delayMillis(1000)
+			                                         .delayElementsMillis(1000)
 			                                         .cache(2, Duration.ofMillis(2000))
 			                                         .elapsed();
 

File: src/test/java/reactor/core/publisher/FluxFlatMapTest.java
Patch:
@@ -902,7 +902,7 @@ public void delayedBackpressuredScalar() {
 	Flux<Integer> scenario_backpressuredThenCancel() {
 		return Flux.just(1, 2, 3)
 		           .flatMap(f -> Flux.range(1, 10)
-		                             .delayMillis(10L))
+		                             .delayElementsMillis(10L))
 		           .hide();
 	}
 

File: src/test/java/reactor/core/publisher/FluxSampleFirstTest.java
Patch:
@@ -160,7 +160,7 @@ public void throttlerReturnsNull() {
 
 	Flux<Integer> scenario_sampleFirstTime(){
 		return Flux.range(1, 10)
-	        .delayMillis(200)
+	        .delayElementsMillis(200)
 	        .sampleFirst(Duration.ofSeconds(1));
 	}
 

File: src/test/java/reactor/core/publisher/FluxSampleTimeoutTest.java
Patch:
@@ -129,7 +129,7 @@ public void throttlerReturnsNull() {
 
 	Flux<Integer> scenario_sampleTimeoutTime(){
 		return Flux.range(1, 10)
-		           .delayMillis(300)
+		           .delayElementsMillis(300)
 		           .sampleTimeout(d -> Mono.delay(Duration.ofMillis(100*d)), 1);
 	}
 
@@ -142,7 +142,7 @@ public void sampleTimeoutTime(){
 	}
 	Flux<Integer> scenario_sampleTimeoutTime2(){
 		return Flux.range(1, 10)
-		           .delayMillis(300)
+		           .delayElementsMillis(300)
 		           .sampleTimeout(d -> Mono.delay(Duration.ofMillis(100*d)), Integer.MAX_VALUE);
 	}
 

File: src/test/java/reactor/core/publisher/FluxWindowBoundaryTest.java
Patch:
@@ -199,7 +199,7 @@ public void otherError() {
 
 	Flux<List<Integer>> scenario_windowWillSubdivideAnInputFluxTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
-		           .delay(Duration.ofMillis(99))
+		           .delayElements(Duration.ofMillis(99))
 		           .window(Duration.ofMillis(200))
 		           .concatMap(Flux::buffer);
 	}

File: src/test/java/reactor/core/publisher/FluxWindowStartEndTest.java
Patch:
@@ -202,7 +202,7 @@ public void windowWillAcumulateMultipleListsOfValuesOverlap() {
 
 	Flux<List<Integer>> scenario_windowWillSubdivideAnInputFluxOverlapTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
-		           .delay(Duration.ofMillis(99))
+		           .delayElements(Duration.ofMillis(99))
 		           .window(Duration.ofMillis(300), Duration.ofMillis(200))
 		           .concatMap(Flux::buffer);
 	}
@@ -221,7 +221,7 @@ public void windowWillSubdivideAnInputFluxOverlapTime() {
 
 	Flux<List<Integer>> scenario_windowWillSubdivideAnInputFluxSameTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
-		           .delay(Duration.ofMillis(99))
+		           .delayElements(Duration.ofMillis(99))
 		           .window(Duration.ofMillis(300), Duration.ofMillis(300))
 		           .concatMap(Flux::buffer);
 	}
@@ -238,7 +238,7 @@ public void windowWillSubdivideAnInputFluxSameTime() {
 
 	Flux<List<Integer>> scenario_windowWillSubdivideAnInputFluxGapTime() {
 		return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
-		           .delay(Duration.ofMillis(99))
+		           .delayElements(Duration.ofMillis(99))
 		           .window(Duration.ofMillis(200), Duration.ofMillis(300))
 		           .concatMap(Flux::buffer);
 	}

File: src/test/java/reactor/core/publisher/FluxWindowTimeOrSizeTest.java
Patch:
@@ -27,7 +27,7 @@ public class FluxWindowTimeOrSizeTest {
 
 	Flux<List<Integer>> scenario_windowWithTimeoutAccumulateOnTimeOrSize() {
 		return Flux.range(1, 6)
-		           .delay(Duration.ofMillis(300))
+		           .delayElements(Duration.ofMillis(300))
 		           .window(5, Duration.ofMillis(2000))
 		           .concatMap(Flux::buffer);
 	}
@@ -44,7 +44,7 @@ public void windowWithTimeoutAccumulateOnTimeOrSize() {
 
 	Flux<List<Integer>> scenario_windowWithTimeoutAccumulateOnTimeOrSize2() {
 		return Flux.range(1, 6)
-		           .delay(Duration.ofMillis(300))
+		           .delayElements(Duration.ofMillis(300))
 		           .windowMillis(5, 2000)
 		           .concatMap(Flux::buffer);
 	}

File: src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -339,8 +339,8 @@ public void sampleCombineLatestTest() throws Exception {
 		CountDownLatch latch = new CountDownLatch(elements / 2 - 2);
 
 		Flux.combineLatest(
-				sensorOdd().cache().delay(Duration.ofMillis(100)),
-				sensorEven().cache().delay(Duration.ofMillis(200)),
+				sensorOdd().cache().delayElements(Duration.ofMillis(100)),
+				sensorEven().cache().delayElements(Duration.ofMillis(200)),
 				this::computeMin)
 		                        .log("combineLatest")
 		                        .subscribe(i -> latch.countDown(), null, latch::countDown);

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -89,7 +89,7 @@ public static <T> long addAndGet(AtomicLongFieldUpdater<T> updater,
 			}
 			long u = addCap(r, n);
 			if (updater.compareAndSet(instance, r, u)) {
-				return r;
+				return u;
 			}
 		}
 	}

File: src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -721,7 +721,7 @@ private void validateSubscribers(int size) {
 		for (int i = 0; i < subs.length; i++) {
 			subs[i] = new BaseSubscriber<Integer>() {
 				@Override
-				protected void hookOnSubscribe(Subscription subscription) { request(Integer.MAX_VALUE); }
+				protected void hookOnSubscribe(Subscription subscription) { request(Long.MAX_VALUE); }
 
 				@Override
 				protected void hookOnNext(Integer value) { }
@@ -980,7 +980,7 @@ public void testPublisherSubscribeUsesSequential() {
 		pf.subscribe(new BaseSubscriber<Integer>() {
 			@Override
 			protected void hookOnSubscribe(Subscription subscription) {
-				request(Integer.MAX_VALUE);
+				request(Long.MAX_VALUE);
 			}
 
 			@Override

File: src/main/java/reactor/core/scheduler/RejectedDisposable.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * @author Stephan Maldini
  */
-public class RejectedDisposable implements Disposable {
+final class RejectedDisposable implements Disposable {
 
 	@Override
 	public void dispose() {

File: src/main/java/reactor/core/MultiProducer.java
Patch:
@@ -42,7 +42,7 @@ default long downstreamCount() {
 	 * @return Has any Subscriber attached to this multi-producer ?
 	 */
 	default boolean hasDownstreams() {
-		return downstreamCount() != 0;
+		return downstreamCount() > 0;
 	}
 
 }

File: src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -44,11 +44,11 @@ final class ConnectableFluxOnAssembly<T> extends ConnectableFlux<T> implements
 
 	final ConnectableFlux<T> source;
 
-	final String stacktrace;
+	final Exception stacktrace;
 
 	public ConnectableFluxOnAssembly(ConnectableFlux<T> source, boolean trace) {
 		this.source = source;
-		this.stacktrace = trace ? FluxOnAssembly.takeStacktrace(source) : null;
+		this.stacktrace = trace ? new Exception() : null;
 	}
 	
 	@Override

File: src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -38,11 +38,11 @@
 final class FluxCallableOnAssembly<T> extends FluxSource<T, T>
 		implements Fuseable, Callable<T>, AssemblyOp {
 
-	final String stacktrace;
+	final Exception stacktrace;
 
 	public FluxCallableOnAssembly(Publisher<? extends T> source, boolean trace) {
 		super(source);
-		this.stacktrace = trace ? FluxOnAssembly.takeStacktrace(source) : null;
+		this.stacktrace = trace ? new Exception() : null;
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -39,11 +39,12 @@
 final class MonoCallableOnAssembly<T> extends MonoSource<T, T>
 		implements Fuseable, Callable<T>, AssemblyOp {
 
-	final String                                                                   stacktrace;
+	final Exception
+			stacktrace;
 
 	public MonoCallableOnAssembly(Publisher<? extends T> source, boolean trace) {
 		super(source);
-		this.stacktrace = trace ? FluxOnAssembly.takeStacktrace(source) : null;
+		this.stacktrace = trace ? new Exception() : null;
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -35,11 +35,11 @@
  */
 final class MonoOnAssembly<T> extends MonoSource<T, T> implements Fuseable, AssemblyOp {
 
-	final String                                                                   stacktrace;
+	final Exception stacktrace;
 
 	public MonoOnAssembly(Publisher<? extends T> source, boolean trace) {
 		super(source);
-		this.stacktrace = trace ? FluxOnAssembly.takeStacktrace(source) : null;
+		this.stacktrace = trace ? new Exception() : null;
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -38,11 +38,11 @@ final class ParallelFluxOnAssembly<T> extends ParallelFlux<T>
 
 	final ParallelFlux<T>                                                          source;
 
-	final String stacktrace;
+	final Exception stacktrace;
 
 	public ParallelFluxOnAssembly(ParallelFlux<T> source, boolean trace) {
 		this.source = source;
-		this.stacktrace = trace ? FluxOnAssembly.takeStacktrace(source) : null;
+		this.stacktrace = trace ? new Exception() : null;
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/SignalLogger.java
Patch:
@@ -82,7 +82,7 @@ public SignalLogger(Publisher<IN> source,
 		this.fuseable = source instanceof Fuseable;
 
 		if(correlateStack){
-			operatorLine = FluxOnAssembly.extract(FluxOnAssembly.takeStacktrace(null),false);
+			operatorLine = FluxOnAssembly.extract(FluxOnAssembly.takeStacktrace(null, new Exception()),false);
 		}
 		else{
 			operatorLine = null;

File: src/test/java/reactor/core/publisher/BlockingTests.java
Patch:
@@ -77,7 +77,7 @@ public void blockingLast() {
 
 	@Test
 	public void blockingLast2() {
-		Assert.assertEquals((Integer) 1,
+		Assert.assertEquals((Integer) 10,
 				Flux.range(1, 10)
 				    .publishOn(scheduler)
 				    .blockLast(Duration.ofSeconds(10)));

File: src/test/java/reactor/core/publisher/FluxCombineLatestTest.java
Patch:
@@ -89,7 +89,6 @@ public void combineLatest() {
 	@Test
 	public void combineLatestEmpty() {
 		StepVerifier.create(Flux.combineLatest(obj -> (int) obj[0]))
-		            .expectNext(1)
 		            .verifyComplete();
 	}
 

File: src/test/java/reactor/core/publisher/FluxFromTest.java
Patch:
@@ -56,7 +56,6 @@ public void fluxJust() {
 	@Test
 	public void fluxEmpty() {
 		StepVerifier.create(Mono.empty().flux())
-		            .expectNext(1)
 		            .verifyComplete();
 	}
 }
\ No newline at end of file

File: src/test/java/reactor/core/publisher/FluxEmptyTest.java
Patch:
@@ -16,10 +16,13 @@
 package reactor.core.publisher;
 
 import org.junit.Test;
+import reactor.test.StepVerifier;
 
 public class FluxEmptyTest {
 
 	@Test
 	public void normal() {
+		StepVerifier.create(Flux.empty())
+	                .verifyComplete();
 	}
 }
\ No newline at end of file

File: src/test/java/reactor/core/publisher/FluxErrorTest.java
Patch:
@@ -16,10 +16,13 @@
 package reactor.core.publisher;
 
 import org.junit.Test;
+import reactor.test.StepVerifier;
 
 public class FluxErrorTest {
 
 	@Test
 	public void normal() {
+		StepVerifier.create(Flux.error(new Exception("test")))
+		            .verifyErrorMessage("test");
 	}
 }
\ No newline at end of file

File: src/test/java/reactor/core/publisher/FluxProcessorTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class FluxProcessorTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxReplayTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class FluxReplayTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxSkipUntilTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class FluxSkipUntilTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxTakeLastOneTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class FluxTakeLastOneTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxTakeUntilTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class FluxTakeUntilTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/FluxWindowOnCancelTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXE implement
 public class FluxWindowOnCancelTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoCreateTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoCreateTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoDeferTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoDeferTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoDelayTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoDelayTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoElapsedTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoElapsedTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoEmptyTest.java
Patch:
@@ -16,10 +16,13 @@
 package reactor.core.publisher;
 
 import org.junit.Test;
+import reactor.test.StepVerifier;
 
 public class MonoEmptyTest {
 
 	@Test
 	public void normal() {
+		StepVerifier.create(Mono.empty())
+		            .verifyComplete();
 	}
 }
\ No newline at end of file

File: src/test/java/reactor/core/publisher/MonoErrorTest.java
Patch:
@@ -16,10 +16,13 @@
 package reactor.core.publisher;
 
 import org.junit.Test;
+import reactor.test.StepVerifier;
 
 public class MonoErrorTest {
 
 	@Test
 	public void normal() {
+		StepVerifier.create(Mono.error(new Exception("test")))
+		            .verifyErrorMessage("test");
 	}
 }
\ No newline at end of file

File: src/test/java/reactor/core/publisher/MonoIgnoreThenTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoIgnoreThenTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoPeekTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoPeekTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoRetryPredicateTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoRetryPredicateTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoRetryWhenTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoRetryWhenTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoSubscribeOnValueTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoSubscribeOnValueTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoTakeLastOneTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoTakeLastOneTest {
 
 	@Test

File: src/test/java/reactor/core/publisher/MonoToCompletableFutureTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME implement
 public class MonoToCompletableFutureTest {
 
 	@Test

File: src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -99,7 +99,7 @@ public void subscribe(Subscriber<? super R> s) {
             a = sources;
             n = a.length;
         } else {
-            a = new Mono[8];
+            a = new Publisher[8];
 	        for (Publisher<?> m : sourcesIterable) {
 		        if (n == a.length) {
 	                Publisher<?>[] b = new Publisher[n + (n >> 2)];

File: src/test/java/reactor/core/publisher/MonoUsingTest.java
Patch:
@@ -49,6 +49,7 @@ public void normal() {
 		AtomicInteger cleanup = new AtomicInteger();
 
 		Mono.using(() -> 1, r -> Mono.just(1), cleanup::set, false)
+		    .doAfterTerminate((v, e) ->  Assert.assertEquals(0, cleanup.get()))
 		    .subscribe(ts);
 
 		ts.assertValues(1)
@@ -64,7 +65,8 @@ public void normalEager() {
 
 		AtomicInteger cleanup = new AtomicInteger();
 
-		Mono.using(() -> 1, r -> Mono.just(1), cleanup::set, true)
+		Mono.using(() -> 1, r -> Mono.just(1), cleanup::set)
+		    .doAfterTerminate((v, e) ->  Assert.assertEquals(0, cleanup.get()))
 		    .subscribe(ts);
 
 		ts.assertValues(1)
@@ -214,5 +216,4 @@ public void subscriberCancels() {
 
 		Assert.assertEquals(1, cleanup.get());
 	}
-
 }

File: src/test/java/reactor/core/publisher/MonoFirstTest.java
Patch:
@@ -93,7 +93,7 @@ public void pairWiseIterable() {
 		Assert.assertTrue(f instanceof MonoFirst);
 		MonoFirst<Integer> s = (MonoFirst<Integer>) f;
 		Assert.assertTrue(s.array != null);
-		Assert.assertTrue(s.array.length == 3);
+		Assert.assertTrue(s.array.length == 2);
 
 		f.subscribeWith(AssertSubscriber.create())
 		 .assertValues(1)

File: src/test/java/reactor/core/scheduler/SchedulersTest.java
Patch:
@@ -26,12 +26,10 @@
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
-import org.assertj.core.api.Assertions;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Ignore;
 import org.junit.Test;
-import reactor.core.Cancellation;
 import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.publisher.DirectProcessor;

File: src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java
Patch:
@@ -41,8 +41,8 @@ final class ExecutorServiceScheduler implements Scheduler {
 	final ExecutorService executor;
 	final boolean interruptOnCancel;
 
-	public ExecutorServiceScheduler(ExecutorService executor, boolean interruptOnCancel) {
-		this.executor = executor;
+	public ExecutorServiceScheduler(ExecutorService executorService, boolean interruptOnCancel) {
+		this.executor = Schedulers.decorateExecutorService("ExecutorService", () -> executorService);
 		this.interruptOnCancel = interruptOnCancel;
 	}
 
@@ -77,7 +77,7 @@ public void dispose() {
 		if(interruptOnCancel) {
 			executor.submit(EMPTY).cancel(true);
 		}
-		Schedulers.executorServiceShutdown(executor, "ExecutorService");
+		Schedulers.executorServiceShutdown(executor,"ExecutorService");
 	}
 
 	static final class ExecutorServiceWorker implements Worker {

File: src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -34,7 +34,9 @@ public interface MonoSink<T> {
     /**
      * Complete with the given value.
      * <p>Calling this method multiple times or after the other
-     * terminating methods has no effect.
+     * terminating methods has no effect. Calling this method with
+     * a {@code null} value will be silently accepted as a call to
+     * {@link #success()} by standard implementations.
      * @param value the value to complete with
      */
     void success(T value);

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -1049,7 +1049,7 @@ public void onSubscribe(Subscription s) {
 				if (s instanceof Fuseable.QueueSubscription) {
 					@SuppressWarnings("unchecked") Fuseable.QueueSubscription<R> f =
 							(Fuseable.QueueSubscription<R>) s;
-					int m = f.requestFusion(Fuseable.ANY);
+					int m = f.requestFusion(Fuseable.ANY | Fuseable.THREAD_BARRIER);
 					if (m == Fuseable.SYNC) {
 						sourceMode = Fuseable.SYNC;
 						queue = f;

File: src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -487,7 +487,7 @@ public void onSubscribe(Subscription s) {
 					@SuppressWarnings("unchecked")
 					QueueSubscription<R> qs = (QueueSubscription<R>) s;
 
-					int m = qs.requestFusion(Fuseable.ANY);
+					int m = qs.requestFusion(Fuseable.ANY | Fuseable.THREAD_BARRIER);
 					if (m == Fuseable.SYNC) {
 						fusionMode = m;
 						queue = qs;

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -861,7 +861,7 @@ public static <T1, T2> Mono<Tuple2<T1, T2>> whenDelayError(Mono<? extends T1> p1
 	 */
 	@SuppressWarnings({ "unchecked", "rawtypes" })
 	public static <T1, T2, T3> Mono<Tuple3<T1, T2, T3>> whenDelayError(Mono<? extends T1> p1, Mono<? extends T2> p2, Mono<? extends T3> p3) {
-		return onAssembly(new MonoWhen(true, a -> Tuples.fromArray((Object[])a), p2, p3));
+		return onAssembly(new MonoWhen(true, a -> Tuples.fromArray((Object[])a), p1, p2, p3));
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -51,6 +51,7 @@ public MonoSequenceEqual(Publisher<? extends T> first, Publisher<? extends T> se
 	@Override
 	public void subscribe(Subscriber<? super Boolean> s) {
 		EqualCoordinator<T> ec = new EqualCoordinator<>(s, bufferSize, first, second, comparer);
+		s.onSubscribe(ec);
 		ec.subscribe();
 	}
 

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Disposable;
+import reactor.core.Cancellation;
 
 /**
  * Wrapper API around a downstream Subscriber for emitting any number of
@@ -70,7 +70,7 @@ public interface FluxSink<T> {
      * via {@link org.reactivestreams.Subscription#cancel()}.
      * @param c the cancellation callback to use
      */
-    void setCancellation(Disposable c);
+    void setCancellation(Cancellation c);
 
 	/**
 	 * Enumeration for backpressure handling.

File: src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import reactor.core.Disposable;
+import reactor.core.Cancellation;
 
 /**
  * Wrapper API around an actual downstream Subscriber
@@ -53,5 +53,5 @@ public interface MonoSink<T> {
      * <p>Calling this method more than once has no effect.
      * @param c the cancellation callback
      */
-    void setCancellation(Disposable c);
+    void setCancellation(Cancellation c);
 }

File: src/main/java/reactor/core/Cancellation.java
Patch:
@@ -18,8 +18,11 @@
 /**
  * Indicates that a task or resource can be cancelled/disposed.
  * <p>Call to the dispose method is/should be idempotent.
+ *
+ * @deprecated use {@link Disposable}, will be removed in 3.1.0
  */
 @FunctionalInterface
+@Deprecated
 public interface Cancellation {
     /**
      * Cancel or dispose the underlying task or resource.

File: src/main/java/reactor/core/publisher/BlockingSingleSubscriber.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Exceptions;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
@@ -30,7 +30,7 @@
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 abstract class BlockingSingleSubscriber<T> extends CountDownLatch
-implements Subscriber<T>, Cancellation, Trackable, Receiver {
+implements Subscriber<T>, Disposable, Trackable, Receiver {
 
     T value;
     Throwable error;

File: src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.function.Consumer;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Fuseable;
 
 /**
@@ -57,7 +57,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	@Override
-	public void connect(Consumer<? super Cancellation> cancelSupport) {
+	public void connect(Consumer<? super Disposable> cancelSupport) {
 		source.connect(cancelSupport);
 	}
 

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -324,15 +324,15 @@ final public boolean alive() {
 	}
 
 	/**
-	 * Block until all submitted tasks have completed, then do a normal {@code EventLoopProcessor.shutdown()}.
+	 * Block until all submitted tasks have completed, then do a normal {@code EventLoopProcessor.dispose()}.
 	 * @return if the underlying executor terminated and false if the timeout elapsed before termination
 	 */
 	public final boolean awaitAndShutdown() {
 		return awaitAndShutdown(-1, TimeUnit.SECONDS);
 	}
 
 	/**
-	 * Block until all submitted tasks have completed, then do a normal {@code EventLoopProcessor#shutdown()}.
+	 * Block until all submitted tasks have completed, then do a normal {@code EventLoopProcessor#dispose()}.
 	 * @param timeout the timeout value
 	 * @param timeUnit the unit for timeout
      * @return if the underlying executor terminated and false if the timeout elapsed before termination

File: src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -35,7 +35,7 @@ final class FluxAutoConnect<T> extends Flux<T>
 
 	final ConnectableFlux<? extends T> source;
 
-	final Consumer<? super Cancellation> cancelSupport;
+	final Consumer<? super Disposable> cancelSupport;
 
 	volatile int remaining;
 	@SuppressWarnings("rawtypes")
@@ -44,7 +44,7 @@ final class FluxAutoConnect<T> extends Flux<T>
 
 
 	public FluxAutoConnect(ConnectableFlux<? extends T> source,
-			int n, Consumer<? super Cancellation> cancelSupport) {
+			int n, Consumer<? super Disposable> cancelSupport) {
 		if (n <= 0) {
 			throw new IllegalArgumentException("n > required but it was " + n);
 		}

File: src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.function.Consumer;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
 
@@ -36,7 +36,7 @@ final class FluxAutoConnectFuseable<T> extends Flux<T>
 
 	final ConnectableFlux<? extends T> source;
 
-	final Consumer<? super Cancellation> cancelSupport;
+	final Consumer<? super Disposable> cancelSupport;
 
 	volatile int remaining;
 	@SuppressWarnings("rawtypes")
@@ -45,7 +45,7 @@ final class FluxAutoConnectFuseable<T> extends Flux<T>
 
 
 	public FluxAutoConnectFuseable(ConnectableFlux<? extends T> source,
-			int n, Consumer<? super Cancellation> cancelSupport) {
+			int n, Consumer<? super Disposable> cancelSupport) {
 		if (n <= 0) {
 			throw new IllegalArgumentException("n > required but it was " + n);
 		}

File: src/main/java/reactor/core/publisher/FluxBatch.java
Patch:
@@ -272,7 +272,7 @@ void checkedCancel() {
 		}
 
 		void doTerminate() {
-			timer.shutdown();
+			timer.dispose();
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -921,10 +921,10 @@ void innerComplete(FlatMapInner<R> inner) {
 						return;
 					}
 
+					s.request(1);
 					if (WIP.decrementAndGet(this) != 0) {
 						drainLoop();
 					}
-					s.request(1);
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -111,7 +111,7 @@ public void request(long n) {
 		public void cancel() {
 			if (!cancelled) {
 				cancelled = true;
-				worker.shutdown();
+				worker.dispose();
 			}
 		}
 	}

File: src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -28,7 +28,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.MultiProducer;
 import reactor.core.Producer;
@@ -90,7 +90,7 @@ State<T> newState() {
 	}
 
 	@Override
-	public void connect(Consumer<? super Cancellation> cancelSupport) {
+	public void connect(Consumer<? super Disposable> cancelSupport) {
 		boolean doConnect;
 		State<T> s;
 		for (; ; ) {
@@ -145,7 +145,7 @@ public Object upstream() {
 	}
 
 	static final class State<T>
-			implements Subscriber<T>, Receiver, MultiProducer, Trackable, Cancellation {
+			implements Subscriber<T>, Receiver, MultiProducer, Trackable, Disposable {
 
 		final FluxReplay<T>                   parent;
 		final ReplayProcessor.ReplayBuffer<T> buffer;

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -17,7 +17,7 @@
 package reactor.core.publisher;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 
 /**
  * Wrapper API around a downstream Subscriber for emitting any number of
@@ -70,7 +70,7 @@ public interface FluxSink<T> {
      * via {@link org.reactivestreams.Subscription#cancel()}.
      * @param c the cancellation callback to use
      */
-    void setCancellation(Cancellation c);
+    void setCancellation(Disposable c);
 
 	/**
 	 * Enumeration for backpressure handling.

File: src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -25,7 +25,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Exceptions;
 
 /**
@@ -103,7 +103,7 @@ public void subscribe(Subscriber<? super Flux<T>> s) {
 	}
 
 	static final class WindowBoundaryMain<T, U>
-			implements Subscriber<T>, Subscription, Cancellation {
+			implements Subscriber<T>, Subscription, Disposable {
 
 		final Subscriber<? super Flux<T>> actual;
 

File: src/main/java/reactor/core/publisher/FluxWindowOnCancel.java
Patch:
@@ -27,7 +27,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.MultiProducer;
 import reactor.core.Producer;
 import reactor.core.Receiver;
@@ -56,7 +56,7 @@ public void subscribe(Subscriber<? super Flux<T>> s) {
 	}
 
 	static final class WindowOnCancelSubscriber<T>
-			implements Subscriber<T>, Subscription, Cancellation, Producer,
+			implements Subscriber<T>, Subscription, Disposable, Producer,
 			           MultiProducer, Receiver, Trackable {
 
 		final Subscriber<? super Flux<T>> actual;

File: src/main/java/reactor/core/publisher/FluxWindowStartEnd.java
Patch:
@@ -28,7 +28,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Exceptions;
 
 /**
@@ -94,7 +94,7 @@ public void subscribe(Subscriber<? super Flux<T>> s) {
 	}
 	
 	static final class WindowStartEndMainSubscriber<T, U, V>
-	implements Subscriber<T>, Subscription, Cancellation {
+	implements Subscriber<T>, Subscription, Disposable {
 		
 		final Subscriber<? super Flux<T>> actual;
 		

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -30,7 +30,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.core.Fuseable;
 import reactor.core.MultiReceiver;
 import reactor.core.Producer;
@@ -427,7 +427,7 @@ void cancelAll() {
 	}
 
 	static final class ZipSingleSubscriber<T>
-			implements Subscriber<T>, Trackable, Cancellation, Receiver {
+			implements Subscriber<T>, Trackable, Disposable, Receiver {
 
 		final ZipSingleCoordinator<T, ?> parent;
 

File: src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -101,7 +101,7 @@ public void onError(Throwable t) {
 		@Override
 		public void onComplete() {
 			if (value == null) {
-				if (schedule() == Scheduler.REJECTED) {
+				if (schedule() == Scheduler.REJECTED && future != CANCELLED) {
 					throw Operators.onRejectedExecution();
 				}
 			}

File: src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -15,7 +15,7 @@
  */
 package reactor.core.publisher;
 
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 
 /**
  * Wrapper API around an actual downstream Subscriber
@@ -53,5 +53,5 @@ public interface MonoSink<T> {
      * <p>Calling this method more than once has no effect.
      * @param c the cancellation callback
      */
-    void setCancellation(Cancellation c);
+    void setCancellation(Disposable c);
 }

File: src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -16,12 +16,10 @@
 package reactor.core.publisher;
 
 import java.util.Objects;
-import java.util.concurrent.RejectedExecutionException;
 
 import org.reactivestreams.Subscriber;
 
 import reactor.core.Cancellation;
-import reactor.core.Exceptions;
 import reactor.core.publisher.FluxSubscribeOnValue.*;
 import reactor.core.scheduler.Scheduler;
 
@@ -50,7 +48,9 @@ public void subscribe(Subscriber<? super T> s) {
 			s.onSubscribe(parent);
 			Cancellation f = scheduler.schedule(parent);
 			if (f == Scheduler.REJECTED) {
-				throw Operators.onRejectedExecution();
+				if(parent.future != ScheduledEmpty.CANCELLED) {
+					s.onError(Operators.onRejectedExecution());
+				}
 			}
 			else {
 				parent.setFuture(f);

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -571,7 +571,7 @@ public static boolean validate(long n) {
 	/**
 	 * Return a wrapped {@link RejectedExecutionException} which can be thrown by the
 	 * operator. That denotes that an execution was rejected by a
-	 * {@link reactor.core.scheduler.Scheduler} due to shutdown.
+	 * {@link reactor.core.scheduler.Scheduler} due to dispose.
 	 * <p>
 	 * Wrapping is done by calling both {@link Exceptions#bubble(Throwable)} and
 	 * {@link #onOperatorError(Subscription, Throwable, Object)}.
@@ -584,7 +584,7 @@ public static RuntimeException onRejectedExecution() {
 	/**
 	 * Return a wrapped {@link RejectedExecutionException} which can be thrown by the
 	 * operator. That denotes that an execution was rejected by a
-	 * {@link reactor.core.scheduler.Scheduler} due to shutdown.
+	 * {@link reactor.core.scheduler.Scheduler} due to dispose.
 	 * <p>
 	 * Wrapping is done by calling both {@link Exceptions#bubble(Throwable)} and
 	 * {@link #onOperatorError(Subscription, Throwable, Object)} (with the passed

File: src/main/java/reactor/core/publisher/ParallelUnorderedRunOn.java
Patch:
@@ -62,7 +62,8 @@ public void subscribe(Subscriber<? super T>[] subscribers) {
 			
 			Worker w = scheduler.createWorker();
 
-			Subscriber<T> parent = new FluxPublishOn.PublishOnSubscriber<>(a, w, true,
+			Subscriber<T> parent = new FluxPublishOn.PublishOnSubscriber<>(a,
+					scheduler, w, true,
 					prefetch, queueSupplier);
 			parents[i] = parent;
 		}

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -132,7 +132,7 @@ public void parallelModeFused() {
 			}
 			finally {
 				Hooks.resetOnOperator();
-				scheduler.shutdown();
+				scheduler.dispose();
 			}
 
 	}

File: src/test/java/reactor/core/publisher/AbstractReactorTest.java
Patch:
@@ -43,8 +43,8 @@ public static void loadEnv() {
 
 	@AfterClass
 	public static void closeEnv() {
-		ioGroup.shutdown();
-		asyncGroup.shutdown();
+		ioGroup.dispose();
+		asyncGroup.dispose();
 	}
 
 	static {

File: src/test/java/reactor/core/publisher/FluxAutoConnectTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxAutoConnectTest {
@@ -40,7 +40,7 @@ public void connectImmediately() {
 		EmitterProcessor<Integer> e = EmitterProcessor.create();
 		e.connect();
 		
-		AtomicReference<Cancellation> cancel = new AtomicReference<>();
+		AtomicReference<Disposable> cancel = new AtomicReference<>();
 		
 		e.publish().autoConnect(0, cancel::set);
 		
@@ -56,7 +56,7 @@ public void connectAfterMany() {
 		EmitterProcessor<Integer> e = EmitterProcessor.create();
 		e.connect();
 		
-		AtomicReference<Cancellation> cancel = new AtomicReference<>();
+		AtomicReference<Disposable> cancel = new AtomicReference<>();
 		
 		Flux<Integer> p = e.publish().autoConnect(2, cancel::set);
 		

File: src/test/java/reactor/core/publisher/FluxIntervalTest.java
Patch:
@@ -40,7 +40,7 @@ public void before() {
 
 	@After
 	public void after() {
-		exec.shutdown();
+		exec.dispose();
 	}
 
 	@Test
@@ -73,7 +73,7 @@ public void normal() {
 
 		}
 		finally {
-			exec.shutdown();
+			exec.dispose();
 		}
 	}
 

File: src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.test.subscriber.AssertSubscriber;
 import reactor.util.concurrent.QueueSupplier;
 
@@ -321,7 +321,7 @@ public void disconnect() {
 		
 		p.subscribe(ts);
 
-		Cancellation r = p.connect();
+		Disposable r = p.connect();
 				
 		e.onNext(1);
 		e.onNext(2);
@@ -346,7 +346,7 @@ public void disconnectBackpressured() {
 		
 		p.subscribe(ts);
 
-		Cancellation r = p.connect();
+		Disposable r = p.connect();
 				
 		r.dispose();
 		

File: src/test/java/reactor/core/publisher/FluxRefCountTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.test.subscriber.AssertSubscriber;
 
 public class FluxRefCountTest {
@@ -155,7 +155,7 @@ public void upstreamCompletesTwoSubscribers() {
 	public void subscribersComeAndGoBelowThreshold() {
 		Flux<Integer> p = Flux.range(1, 5).publish().refCount(2);
 
-		Cancellation r = p.subscribe();
+		Disposable r = p.subscribe();
 		r.dispose();
 		p.subscribe().dispose();
 		p.subscribe().dispose();

File: src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -101,7 +101,7 @@ public void parallelMode() {
 				  .assertNoError();
 			}
 			finally {
-				scheduler.shutdown();
+				scheduler.dispose();
 			}
 		}
 
@@ -135,7 +135,7 @@ public void parallelModeFused() {
 				  .assertNoError();
 			}
 			finally {
-				scheduler.shutdown();
+				scheduler.dispose();
 			}
 		}
 
@@ -188,7 +188,7 @@ public void parallelReduceFull() {
 					ts.assertValues(e);
 				}
 				finally {
-					scheduler.shutdown();
+					scheduler.dispose();
 				}
 			}
 		}

File: src/test/java/reactor/core/publisher/TopicProcessorTest.java
Patch:
@@ -170,7 +170,7 @@ public void testForceShutdownAfterShutdown() throws InterruptedException {
 	@Test
 	public void testShutdown() {
 		for (int i = 0; i < 1000; i++) {
-			TopicProcessor<?> dispatcher = TopicProcessor.create("rb-test-shutdown", 16);
+			TopicProcessor<?> dispatcher = TopicProcessor.create("rb-test-dispose", 16);
 			dispatcher.awaitAndShutdown();
 		}
 	}

File: src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java
Patch:
@@ -196,7 +196,7 @@ public void onSubscribe(Subscription s) {
 		finally {
 			logger.debug("Finishing");
 			emitter.finish();
-			timer.shutdown();
+			timer.dispose();
 		}
 		TimeUnit.SECONDS.sleep(1);
 	}

File: src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -112,7 +112,7 @@ public void tesSubmitSession() throws Exception {
 		latch.await(5, TimeUnit.SECONDS);
 		Assert.assertTrue("latch : " + count, count.get() == 1);
 		Assert.assertTrue("time : " + emission, emission >= 0);
-		scheduler.shutdown();
+		scheduler.dispose();
 	}
 
 	@Test
@@ -146,7 +146,7 @@ public void testEmitter() throws Throwable {
 
 		boolean waited = latch.await(5, TimeUnit.SECONDS);
 		Assert.assertTrue( "latch : " + latch.getCount(), waited);
-		c.shutdown();
+		c.dispose();
 	}
 
 	public Flux<SensorData> sensorOdd() {
@@ -272,7 +272,7 @@ public void sampleZipTest3() throws Exception {
 		    .subscribe(sensorDataProcessor);
 
 		awaitLatch(null, latch);
-		scheduler.shutdown();
+		scheduler.dispose();
 	}
 
 	private void awaitLatch(Publisher<?> tail, CountDownLatch latch) throws Exception {

File: src/test/java/reactor/core/publisher/scenarios/PopularTagTests.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.CountDownLatch;
 
 import org.junit.Test;
-import reactor.core.Cancellation;
+import reactor.core.Disposable;
 import reactor.util.Loggers;
 import reactor.core.publisher.AbstractReactorTest;
 import reactor.core.publisher.Flux;
@@ -53,7 +53,7 @@ public class PopularTagTests extends AbstractReactorTest {
 	public void sampleTest() throws Exception {
 		CountDownLatch latch = new CountDownLatch(1);
 
-		Cancellation top10every1second =
+		Disposable top10every1second =
 		  Flux.fromIterable(PULP_SAMPLE)
 		         .publishOn(asyncGroup)
 		         .flatMap(samuelJackson ->
@@ -89,7 +89,7 @@ private void simulateLatency() {
 		}
 	}
 
-	private void awaitLatch(Cancellation tail, CountDownLatch latch) throws Exception {
+	private void awaitLatch(Disposable tail, CountDownLatch latch) throws Exception {
 		if (!latch.await(10, SECONDS)) {
 			throw new Exception("Never completed: (" + latch.getCount() + ")");
 		}

File: src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -61,7 +61,7 @@ public void test2() throws Exception {
 		    .assertComplete()
 		    .assertValueCount(3);
 
-		s.shutdown();
+		s.dispose();
 	}
 
 

File: src/test/java/reactor/core/publisher/tck/FluxBlackboxProcessorVerification.java
Patch:
@@ -63,7 +63,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                          .flatMap(i -> Flux.zip(Flux.just(i), otherStream, combinator))
 				 )
 				 .publishOn(sharedGroup)
-				 .doAfterTerminate(asyncGroup::shutdown)
+				 .doAfterTerminate(asyncGroup::dispose)
 				 .doOnError(Throwable::printStackTrace)
 				.awaitOnSubscribe());
 	}
@@ -135,7 +135,7 @@ public static void setupGlobal(){
 
 	@AfterClass
 	public static void tearDownGlobal(){
-		sharedGroup.shutdown();
+		sharedGroup.dispose();
 	}
 
 	@Override

File: src/test/java/reactor/core/scheduler/ProcessorsSpecTest.java
Patch:
@@ -42,7 +42,7 @@ public void ringBufferDispatcher() throws Exception {
             
             Assert.assertNotEquals(t1, t2[0]);
         } finally {
-            dispatcher.shutdown();
+            dispatcher.dispose();
         }
     }
 }

File: src/main/java/reactor/core/publisher/MonoFirst.java
Patch:
@@ -165,6 +165,4 @@ public void subscribe(Subscriber<? super T> s) {
 		coordinator.subscribe(a, n, s);
 	}
 
-	//TODO the ambAdditionalSource optimization from FluxFirstEmitting could also be applied
-
 }
\ No newline at end of file

File: src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -54,6 +54,9 @@ public static <T> void subscribe(Callable<T> callable,
 		s.onSubscribe(parent);
 
 		Cancellation f = scheduler.schedule(parent);
+		if (f == Scheduler.REJECTED) {
+			throw Operators.onRejectedExecution();
+		}
 
 		parent.setMainFuture(f);
 	}

File: src/main/java/reactor/core/publisher/MonoSubscribeOnValue.java
Patch:
@@ -50,8 +50,7 @@ public void subscribe(Subscriber<? super T> s) {
 			s.onSubscribe(parent);
 			Cancellation f = scheduler.schedule(parent);
 			if (f == Scheduler.REJECTED) {
-				throw Exceptions.bubble(new RejectedExecutionException(
-						"Scheduler unavailable"));
+				throw Operators.onRejectedExecution();
 			}
 			else {
 				parent.setFuture(f);

File: src/test/java/reactor/core/publisher/MonoDematerializeTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package reactor.core.publisher;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import reactor.test.subscriber.AssertSubscriber;
 
@@ -112,8 +113,8 @@ public void errorAfterSingleSignal() {
 		  .assertNotComplete();
 	}
 
-	//@Test
-	//TODO
+	@Test
+	@Ignore("use virtual time?")
 	public void neverEnding() {
 		AssertSubscriber<Integer> ts = AssertSubscriber.create();
 

File: src/test/java/reactor/core/publisher/WorkQueueProcessorTest.java
Patch:
@@ -265,7 +265,7 @@ public void singleThreadWorkQueueDoesntRejectsSubscribers() {
 			fail("expected 3rd next to time out as newSingleThreadExecutor cannot be introspected");
 		}
 		catch (Throwable e) {
-			assertTrue("expected AlertException", WaitStrategy.isAlert(e));
+			assertTrue("expected AlertException, got " + e, WaitStrategy.isAlert(e));
 		}
 	}
 

File: src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -222,7 +222,7 @@ public void onNext(T t) {
 			if (!queue.offer(t)) {
 				Operators.terminate(S, this);
 				
-				onError(new IllegalStateException("Queue full?!"));
+				onError(Exceptions.failWithOverflow("Queue full?!"));
 			} else {
 				signalConsumer();
 			}

File: src/main/java/reactor/core/publisher/DirectProcessor.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Processor;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.MultiProducer;
 import reactor.core.Producer;
 import reactor.core.Receiver;
@@ -306,7 +307,7 @@ void onNext(T value) {
 				return;
 			}
 			parent.remove(this);
-			actual.onError(new IllegalStateException("Can't deliver value due to lack of requests"));
+			actual.onError(Exceptions.failWithOverflow("Can't deliver value due to lack of requests"));
 		}
 
 		void onError(Throwable e) {

File: src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 
 /**
  * Buffers elements into custom collections where the buffer boundary is signalled
@@ -255,7 +256,7 @@ boolean emit(C b) {
 			} else {
 				cancel();
 				
-				actual.onError(new IllegalStateException("Could not emit buffer due to lack of requests"));
+				actual.onError(Exceptions.failWithOverflow("Could not emit buffer due to lack of requests"));
 
 				return false;
 			}

File: src/main/java/reactor/core/publisher/FluxBufferPredicate.java
Patch:
@@ -29,6 +29,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Fuseable.ConditionalSubscriber;
 import reactor.core.Trackable;
 
@@ -296,8 +297,7 @@ boolean emit(C b) {
 				return requested > 0;
 			}
 			cancel();
-			actual.onError(new IllegalStateException(
-					"Could not emit buffer due to lack of requests"));
+			actual.onError(Exceptions.failWithOverflow("Could not emit buffer due to lack of requests"));
 			return false;
 		}
 

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -285,8 +285,7 @@ boolean emit(C b) {
 			}
 			else {
 
-				actual.onError(new IllegalStateException(
-						"Could not emit buffer due to lack of requests"));
+				actual.onError(Exceptions.failWithOverflow("Could not emit buffer due to lack of requests"));
 
 				return false;
 			}
@@ -435,7 +434,7 @@ void drain() {
 							REQUESTED.decrementAndGet(this);
 						}
 					} else {
-						anyError(new IllegalStateException("Could not emit buffer due to lack of requests"));
+						anyError(Exceptions.failWithOverflow("Could not emit buffer due to lack of requests"));
 					}
 				}
 				

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -221,7 +221,7 @@ public void onNext(T t) {
 			} else
 			if (!queue.offer(t)) {
 				s.cancel();
-				onError(new IllegalStateException("Queue full?!"));
+				onError(Exceptions.failWithOverflow("Queue full?!"));
 			} else {
 				drain();
 			}
@@ -535,7 +535,7 @@ public void onNext(T t) {
 			} else
 			if (!queue.offer(t)) {
 				s.cancel();
-				onError(new IllegalStateException("Queue full?!"));
+				onError(Exceptions.failWithOverflow("Queue full?!"));
 			} else {
 				drain();
 			}

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -206,7 +206,7 @@ public void onSubscribe(Subscription s) {
 		public void onNext(T t) {
 			if (fusionMode != Fuseable.ASYNC) {
 				if (!queue.offer(t)) {
-					onError(new IllegalStateException("Queue is full?!"));
+					onError(Exceptions.failWithOverflow("Queue is full?!"));
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -696,7 +696,7 @@ public void onNext(V t) {
 			Subscriber<? super V> a = actual;
 
 			if (!queue.offer(t)) {
-				onError(new IllegalStateException("The queue is full"));
+				onError(Exceptions.failWithOverflow("The queue is full"));
 				return;
 			}
 			if (enableOperatorFusion) {

File: src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.scheduler.TimedScheduler;
 import reactor.core.scheduler.TimedScheduler.TimedWorker;
 
@@ -94,7 +95,7 @@ public void run() {
 				} else {
 					cancel();
 					
-					s.onError(new IllegalStateException("Could not emit value " + count + " due to lack of requests"));
+					s.onError(Exceptions.failWithOverflow("Could not emit value " + count + " due to lack of requests"));
 				}
 			}
 		}

File: src/main/java/reactor/core/publisher/FluxJoin.java
Patch:
@@ -349,7 +349,7 @@ void drain() {
 							else {
 								Exceptions.addThrowable(ERROR,
 										this,
-										new IllegalStateException("Could not " + "emit value due to lack of requests"));
+										Exceptions.failWithOverflow("Could not " + "emit value due to lack of requests"));
 								q.clear();
 								cancelAll();
 								errorAll(a);
@@ -442,7 +442,7 @@ else if (mode == RIGHT_VALUE) {
 							else {
 								Exceptions.addThrowable(ERROR,
 										this,
-										new IllegalStateException(("Could not emit " + "value due to lack of requests")));
+										Exceptions.failWithOverflow("Could not emit " + "value due to lack of requests"));
 								q.clear();
 								cancelAll();
 								errorAll(a);

File: src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -233,7 +233,7 @@ public void onNext(T t) {
 			}
 			
 			if (!queue.offer(t)) {
-				Throwable ex = new IllegalStateException("Queue full?!");
+				Throwable ex = Exceptions.failWithOverflow("Queue full?!");
 				if (!Exceptions.addThrowable(ERROR, this, ex)) {
 					Operators.onErrorDropped(ex);
 					return;

File: src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -26,6 +26,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 
 /**
@@ -216,7 +217,7 @@ public void onNext(T t) {
 			if (sourceMode != Fuseable.ASYNC) {
 				if (!queue.offer(t)) {
 					onError(Operators.onOperatorError(s,
-							new IllegalStateException("Queue full?!"),
+							Exceptions.failWithOverflow("Queue full?!"),
 							t));
 					return;
 				}

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -252,8 +252,7 @@ public void onNext(T t) {
 				return;
 			}
 			if (!queue.offer(t)) {
-				error = Operators.onOperatorError(s, new IllegalStateException
-						("Queue is full?!"), t);
+				error = Operators.onOperatorError(s, Exceptions.failWithOverflow("Queue is full?!"), t);
 				done = true;
 			}
 			if (trySchedule() == Scheduler.REJECTED) {
@@ -798,7 +797,7 @@ public void onNext(T t) {
 			if (!queue.offer(t)) {
 				s.cancel();
 				
-				error = new IllegalStateException("Queue is full?!");
+				error = Exceptions.failWithOverflow("Queue is full?!");
 				done = true;
 			}
 			if (trySchedule() == Scheduler.REJECTED) {

File: src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 
 /**
  * Samples the main source and emits its latest value whenever the other Publisher
@@ -212,7 +213,7 @@ public void onNext(U t) {
 
 				m.cancel();
 
-				m.actual.onError(new IllegalStateException("Can't signal value due to lack of requests"));
+				m.actual.onError(Exceptions.failWithOverflow("Can't signal value due to lack of requests"));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -267,7 +267,7 @@ void drain() {
 							
 							q.clear();
 							
-							Throwable e = new IllegalStateException("Could not emit value due to lack of requests");
+							Throwable e = Exceptions.failWithOverflow("Could not emit value due to lack of requests");
 							Exceptions.addThrowable(ERROR, this, e);
 							e = Exceptions.terminate(ERROR, this);
 							

File: src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -336,7 +336,7 @@ void drain() {
 								cancelMain();
 								boundary.cancel();
 								
-								a.onError(new IllegalStateException("Could not create new window due to lack of requests"));
+								a.onError(Exceptions.failWithOverflow("Could not create new window due to lack of requests"));
 								return;
 							}
 						}
@@ -361,7 +361,7 @@ boolean emit(UnicastProcessor<T> w) {
 			} else {
 				cancel();
 
-				actual.onError(new IllegalStateException("Could not emit buffer due to lack of requests"));
+				actual.onError(Exceptions.failWithOverflow("Could not emit buffer due to lack of requests"));
 
 				return false;
 			}

File: src/main/java/reactor/core/publisher/FluxWindowStartEnd.java
Patch:
@@ -401,7 +401,7 @@ void drain() {
 										REQUESTED.decrementAndGet(this);
 									}
 								} else {
-									Exceptions.addThrowable(ERROR, this, new IllegalStateException("Could not emit window due to lack of requests"));
+									Exceptions.addThrowable(ERROR, this, Exceptions.failWithOverflow("Could not emit window due to lack of requests"));
 									continue;
 								}
 								

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Cancellation;
+import reactor.core.Exceptions;
 import reactor.core.scheduler.TimedScheduler;
 
 /**
@@ -92,7 +93,7 @@ public void run() {
 					s.onError(Operators.onOperatorError(t));
 				}
 			} else {
-				s.onError(new IllegalStateException("Could not emit value due to lack of requests"));
+				s.onError(Exceptions.failWithOverflow("Could not emit value due to lack of requests"));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/MonoSequenceEqual.java
Patch:
@@ -289,7 +289,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (!queue.offer(t)) {
-				onError(new IllegalStateException("Queue full?!"));
+				onError(Exceptions.failWithOverflow("Queue full?!"));
 				return;
 			}
 			parent.drain();

File: src/main/java/reactor/core/publisher/ParallelUnorderedSource.java
Patch:
@@ -24,6 +24,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 
+import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 
 /**
@@ -208,7 +209,7 @@ public void onNext(T t) {
 			if (sourceMode == Fuseable.NONE) {
 				if (!queue.offer(t)) {
 					cancel();
-					onError(new IllegalStateException("Queue is full?"));
+					onError(Exceptions.failWithOverflow("Queue is full?"));
 					return;
 				}
 			}

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1105,7 +1105,7 @@ public final <T2, O> Mono<O> and(Mono<? extends T2> other, BiFunction<?
 
 	/**
 	 * Wait for the result from this mono, use it to create a second mono via the
-	 * provided {@param rightGenerator} function and combine both results into a {@link Tuple2}.
+	 * provided {@code rightGenerator} function and combine both results into a {@link Tuple2}.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/and.png" alt="">
@@ -1121,8 +1121,8 @@ public final <T2> Mono<Tuple2<T, T2>> and(Function<T, Mono<? extends T2>> rightG
 
 	/**
 	 * Wait for the result from this mono, use it to create a second mono via the
-	 * provided {@param rightGenerator} function and combine both results into an arbitrary
-	 * {@code O} object, as defined by the provided {@param combinator} function.
+	 * provided {@code rightGenerator} function and combine both results into an arbitrary
+	 * {@code O} object, as defined by the provided {@code combinator} function.
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/and.png" alt="">

File: src/test/java/reactor/core/publisher/MonoPublishOnTest.java
Patch:
@@ -266,13 +266,13 @@ public void rejectedExecutionExceptionOnErrorSignalExecutorService()
 	}
 
 	@Test
-	public void rejectedExecutionSubsribeExecutorScheduler() {
+	public void rejectedExecutionSubscribeExecutorScheduler() {
 		CountDownLatch latch = new CountDownLatch(1);
 		ExecutorService executor = new ThreadPoolExecutor(1,
 				1,
 				0L,
 				MILLISECONDS,
-				new SynchronousQueue(),
+				new SynchronousQueue<>(),
 				new AbortPolicy());
 
 		try {
@@ -310,7 +310,7 @@ public void rejectedExecutionSubsribeExecutorServiceScheduler() {
 				1,
 				0L,
 				MILLISECONDS,
-				new SynchronousQueue(),
+				new SynchronousQueue<>(),
 				new AbortPolicy());
 
 		try {

File: src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -125,7 +125,8 @@ public void testEmitter() throws Throwable {
 		Scheduler c = Schedulers.single();
 		for (int i = 0; i < subs; i++) {
 			processor.publishOn(c)
-			         .subscribe(d -> latch.countDown(), null, latch::countDown, 1);
+			         .limitRate(1)
+			         .subscribe(d -> latch.countDown(), null, latch::countDown);
 		}
 
 		BlockingSink<Integer> session = processor.connectSink();

File: src/main/java/reactor/core/publisher/FluxDistinct.java
Patch:
@@ -36,7 +36,7 @@
  * filters out duplicates.
  *
  * @param <T> the source value type
- * @param <K> the key extacted from the source value to be used for duplicate testing
+ * @param <K> the key extracted from the source value to be used for duplicate testing
  * @param <C> the collection type whose add() method is used for testing for duplicates
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */

File: src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -30,7 +30,7 @@
  * filters out duplicates.
  *
  * @param <T> the source value type
- * @param <K> the key extacted from the source value to be used for duplicate testing
+ * @param <K> the key extracted from the source value to be used for duplicate testing
  * @param <C> the collection type whose add() method is used for testing for duplicates
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */

File: src/main/java/reactor/core/publisher/Signal.java
Patch:
@@ -15,7 +15,6 @@
  */
 package reactor.core.publisher;
 
-import java.io.Serializable;
 import java.util.Objects;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
@@ -72,15 +71,15 @@ public static <T> Signal<T> next(T t) {
 
 	/**
 	 * @param o is the given object a complete {@link Signal}
-	 * @return true if completition signal
+	 * @return true if completion signal
 	 */
 	public static boolean isComplete(Object o){
 		return o == ON_COMPLETE;
 	}
 
 	/**
 	 * @param o is the given object a complete {@link Signal}
-	 * @return true if completition signal
+	 * @return true if completion signal
 	 */
 	public static boolean isError(Object o){
 		return o instanceof Signal && ((Signal)o).getType() == SignalType.ON_ERROR;

File: src/main/java/reactor/core/scheduler/Scheduler.java
Patch:
@@ -18,7 +18,7 @@
 import reactor.core.Cancellation;
 
 /**
- * Provides an abstract asychronous boundary to operators.
+ * Provides an abstract asynchronous boundary to operators.
  */
 public interface Scheduler {
 	/**

File: src/main/java/reactor/core/scheduler/TimedScheduler.java
Patch:
@@ -20,7 +20,7 @@
 import reactor.core.Cancellation;
 
 /**
- * Provides an abstract, timed asychronous boundary to operators.
+ * Provides an abstract, timed asynchronous boundary to operators.
  */
 public interface TimedScheduler extends Scheduler {
 	

File: src/main/java/reactor/util/concurrent/WaitStrategy.java
Patch:
@@ -188,7 +188,7 @@ public void signalAllWhenBlocking() {
     /**
      * Wait for the given sequence to be available.  It is possible for this method to return a value
      * less than the sequence number supplied depending on the implementation of the WaitStrategy.  A common
-     * use for this is to signal a timeout.  Any EventProcessor that is using a WaitStragegy to get notifications
+     * use for this is to signal a timeout.  Any EventProcessor that is using a WaitStrategy to get notifications
      * about message becoming available should remember to handle this case.
      *
      * @param sequence to be waited on.

File: src/main/java/reactor/util/function/Tuple2.java
Patch:
@@ -27,7 +27,7 @@
  * A tuple that holds two values
  *
  * @param <T1> The type of the first value held by this tuple
- * @param <T2> The type of the second balue held by this tuple
+ * @param <T2> The type of the second value held by this tuple
  * @author Jon Brisbin
  * @author Stephane Maldini
  */
@@ -36,8 +36,8 @@ public class Tuple2<T1, T2> implements Iterable, Serializable {
 
 	/** */
     private static final long serialVersionUID = 4839927936743208499L;
-    
-    final T1 t1;
+
+	final T1 t1;
 	final T2 t2;
 
 	Tuple2(T1 t1, T2 t2) {

File: src/test/java/reactor/core/publisher/tck/EmitterProcessorVerification.java
Patch:
@@ -20,13 +20,12 @@
 import org.reactivestreams.Processor;
 import org.testng.annotations.AfterClass;
 import reactor.core.publisher.EmitterProcessor;
-import reactor.core.publisher.FluxProcessor;
 
 /**
  * @author Stephane Maldini
  */
 @org.testng.annotations.Test
-public class EmitterProcessorVerficiation extends AbstractProcessorVerification {
+public class EmitterProcessorVerification extends AbstractProcessorVerification {
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {

File: src/test/java/reactor/test/subscriber/AssertSubscriber.java
Patch:
@@ -319,7 +319,7 @@ public final AssertSubscriber<T> assertContainValues(Set<? extends T> expectedVa
 				T t2 = expected.next();
 				if (!values.contains(t2)) {
 					throw new AssertionError("The element is not contained in the " +
-							"received resuls" +
+							"received results" +
 							" = " + valueAndClass(t2), null);
 				}
 			}
@@ -955,7 +955,7 @@ public final long requestedFromDownstream() {
 	}
 
 	/**
-	 * Setup what fusion mode should be requested from the incomining
+	 * Setup what fusion mode should be requested from the incoming
 	 * Subscription if it happens to be QueueSubscription
 	 * @param requestMode the mode to request, see Fuseable constants
 	 * @return this

File: src/main/java/reactor/core/publisher/MonoPublishOn.java
Patch:
@@ -89,7 +89,7 @@ public void onNext(T t) {
 			value = t;
 			if(schedule() == Scheduler.REJECTED){
 				throw Exceptions.bubble(Operators.onOperatorError(this,
-						new RejectedExecutionException("Scheduler unavailable")));
+						new RejectedExecutionException("Scheduler unavailable"), t));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/Operators.java
Patch:
@@ -286,7 +286,7 @@ public static void onErrorDropped(Throwable e, Throwable root) {
 	}
 
 	/**
-	 * Take an unsignalled exception that is masking anowher one due to callback failure.
+	 * Take an unsignalled exception that is masking another one due to callback failure.
 	 *
 	 * @param e the exception to handle
 	 */

File: src/main/java/reactor/core/Exceptions.java
Patch:
@@ -37,6 +37,7 @@ public abstract class Exceptions {
 	 * A singleton instance of a Throwable indicating a terminal state for exceptions,
 	 * don't leak this!
 	 */
+	@SuppressWarnings("ThrowableInstanceNeverThrown")
 	public static final Throwable TERMINATED = new Throwable("No further exceptions");
 
 	/**
@@ -317,6 +318,7 @@ public synchronized Throwable fillInStackTrace() {
 	 */
 	static final class CancelException extends BubblingException {
 
+		@SuppressWarnings("ThrowableInstanceNeverThrown")
 		public static final CancelException INSTANCE = new CancelException();
 
 		private CancelException() {

File: src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -37,9 +37,6 @@
  * </ul>
  * 
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class ConnectableFluxOnAssembly<T> extends ConnectableFlux<T> implements

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.reactivestreams.Processor;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.MultiProducer;

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -550,6 +550,7 @@ public void run() {
 				upstream.request(bufferSize);
 
 				long c;
+				//noinspection InfiniteLoopStatement
 				for (; ; ) {
 					c = cursor + limit;
 					cursor = waitStrategy.waitFor(c, readCount, spinObserver);

File: src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -31,9 +31,6 @@
  * Emits the contents of a wrapped (shared) array.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxArray<T> 

File: src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -28,9 +28,6 @@
  * subscribed.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxAutoConnect<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -29,9 +29,6 @@
  * subscribed.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxAutoConnectFuseable<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxAwaitOnSubscribe.java
Patch:
@@ -20,9 +20,6 @@
  * runs into a half-prepared state. This can happen with non Rx mentality based Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  * @since 3.0
  */

File: src/main/java/reactor/core/publisher/FluxBatch.java
Patch:
@@ -59,7 +59,8 @@ final Subscriber<? super V> prepareSub(Subscriber<? super V> actual) {
 
 	static abstract class BatchAction<T, V> extends Operators.SubscriberAdapter<T, V> {
 
-		static final Exception FAILED_SATE =
+		@SuppressWarnings("ThrowableInstanceNeverThrown")
+		static final Exception FAILED_SATE             =
 				new RuntimeException("Failed Subscriber") {
 					/** */
 					private static final long serialVersionUID = 7503907754069414227L;

File: src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -36,9 +36,6 @@
  *
  * @param <T> the source value type
  * @param <C> the buffer collection type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxBuffer<T, C extends Collection<? super T>> extends FluxSource<T, C> {

File: src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -32,9 +32,6 @@
  * @param <T> the source value type
  * @param <U> the element type of the boundary publisher (irrelevant)
  * @param <C> the output collection type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxBufferBoundary<T, U, C extends Collection<? super T>>

File: src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -33,9 +33,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxCallableOnAssembly<T> extends FluxSource<T, T>

File: src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -30,9 +30,6 @@
  * Concatenates a fixed array of Publishers' values.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxConcatArray<T> 
@@ -130,6 +127,7 @@ public <V> FluxConcatArray<V> concatAdditionalIgnoredLast(Publisher<? extends V>
 			source) {
 		int n = array.length;
 		Publisher<? extends V>[] newArray = new Publisher[n + 1];
+		//noinspection SuspiciousSystemArraycopy
 		System.arraycopy(array, 0, newArray, 0, n);
 		newArray[n - 1] = new MonoIgnoreThen<>(newArray[n - 1]);
 		newArray[n] = source;

File: src/main/java/reactor/core/publisher/FluxConcatIterable.java
Patch:
@@ -27,9 +27,6 @@
  * Concatenates a fixed array of Publishers' values.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxConcatIterable<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -18,7 +18,6 @@
 
 import java.util.Objects;
 import java.util.Queue;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReference;
@@ -135,7 +134,7 @@ public void next(T t) {
 			}
 			else {
 				Queue<T> q = queue;
-				synchronized (q) {
+				synchronized (this) {
 					q.offer(t);
 				}
 				if (WIP.getAndIncrement(this) != 0) {
@@ -583,7 +582,7 @@ static final class LatestAsyncSink<T> extends BaseSink<T> {
 
 		public LatestAsyncSink(Subscriber<? super T> actual) {
 			super(actual);
-			this.queue = new AtomicReference<T>();
+			this.queue = new AtomicReference<>();
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -26,9 +26,6 @@
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDefer<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -28,9 +28,6 @@
  *
  * @param <T> the main source value type
  * @param <U> the other source type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDelaySubscription<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxDetach.java
Patch:
@@ -11,9 +11,6 @@
  * wit non Rx mentality based Publishers.
  * 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDetach<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -32,9 +32,6 @@
  *
  * @param <T> the value type
  * @param <K> the key type used for comparing subsequent elements
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDistinctUntilChanged<T, K> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -24,9 +24,6 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance any.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxEmpty

File: src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -27,9 +27,6 @@
  * Emits a constant or generated Throwable instance to Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxError<T>

File: src/main/java/reactor/core/publisher/FluxFilter.java
Patch:
@@ -34,9 +34,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFilter<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxFilterFuseable.java
Patch:
@@ -31,9 +31,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFilterFuseable<T> extends FluxSource<T, T>

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -35,9 +35,6 @@
  * Concatenates values from Iterable sequences generated via a mapper function.
  * @param <T> the input value type
  * @param <R> the value type of the iterables and the result type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFlattenIterable<T, R> extends FluxSource<T, R> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -36,9 +36,6 @@
  *
  * @param <T> the value type emitted
  * @param <S> the custom state per subscriber
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxGenerate<T, S> 

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -42,9 +42,6 @@
  * @param <T> the source value type
  * @param <K> the key value type
  * @param <V> the group item value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxGroupBy<T, K, V> extends FluxSource<T, GroupedFlux<K, V>>

File: src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -51,9 +51,6 @@
  * indicate the duration of the values of the {@code right} Publisher
  * @param <R> type that a function that takes an item emitted by each Publisher and
  * returns the value to be emitted by the resulting Publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  * @since 3.0
  */

File: src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -21,7 +21,6 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import java.util.function.Function;
 
 import reactor.core.Fuseable;
 import reactor.core.Loopback;

File: src/main/java/reactor/core/publisher/FluxHide.java
Patch:
@@ -24,9 +24,6 @@
  * as well. 
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxHide<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -27,9 +27,6 @@
 /**
  * Periodically emits an ever increasing long value either via a ScheduledExecutorService
  * or a custom async callback function
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxInterval extends Flux<Long> {

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
-import reactor.core.Loopback;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
 

File: src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -33,9 +33,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxMap<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxMapFuseable.java
Patch:
@@ -34,9 +34,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxMapFuseable<T, R> extends FluxSource<T, R>

File: src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -34,9 +34,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @author Stephane Maldini
  */
 final class FluxMapSignal<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxMerge.java
Patch:
@@ -30,9 +30,6 @@
 /**
  * Merges a fixed array of Publishers.
  * @param <T> the element type of the publishers
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxMerge<T> extends Flux<T> implements MultiReceiver, Trackable {

File: src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -166,7 +166,7 @@ public void onNext(T t) {
 				return;
 			}
 
-			MergeSequentialInner<R> inner = new MergeSequentialInner<R>(this, prefetch);
+			MergeSequentialInner<R> inner = new MergeSequentialInner<>(this, prefetch);
 
 			if (cancelled) {
 				return;

File: src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -24,9 +24,7 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxNever 

File: src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -39,9 +39,6 @@
  * Crashes by the lambdas are ignored.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPeek<T> extends FluxSource<T, T> implements SignalPeek<T> {

File: src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -36,9 +36,6 @@
  * Crashes by the lambdas are ignored.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPeekFuseable<T> extends FluxSource<T, T> implements Fuseable,

File: src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -41,9 +41,6 @@
  * A connectable publisher which shares an underlying source and dispatches source values to subscribers in a backpressure-aware
  * manner. 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPublish<T> extends ConnectableFlux<T>

File: src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -35,9 +35,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the output value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPublishMulticast<T, R> extends FluxSource<T, R> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -37,9 +37,6 @@
  * Emits events on a different thread specified by a scheduler callback.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPublishOn<T> extends FluxSource<T, T> implements Loopback, Fuseable {

File: src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -24,9 +24,7 @@
 
 /**
  * Emits a range of integer values.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRange extends Flux<Integer>

File: src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -35,9 +35,6 @@
  * to it and disconnects once all Subscribers cancelled their Subscriptions.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRefCount<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxRepeat.java
Patch:
@@ -27,9 +27,6 @@
  * The times == Long.MAX_VALUE is treated as infinite repeat.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRepeat<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -27,9 +27,6 @@
  * completion of the previous subscription.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRepeatPredicate<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -39,9 +39,6 @@
 
 /**
  * @param <T>
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxReplay<T> extends ConnectableFlux<T>

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -28,9 +28,6 @@
  * a function for the particular failure exception.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxResume<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRetry.java
Patch:
@@ -12,9 +12,6 @@
  * The times == Long.MAX_VALUE is treated as infinite retry.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRetry<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -27,9 +27,6 @@
  * completion of the previous subscription.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRetryPredicate<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -37,9 +37,6 @@
  * 
  * @param <T> the input and output value type
  * @param <U> the value type of the sampler (irrelevant)
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSample<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -32,9 +32,6 @@
  *
  * @param <T> the source and output value type
  * @param <U> the value type of the publisher signalling the end of the throttling duration
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSampleFirst<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -34,9 +34,6 @@
  *
  * @param <T> the source value type
  * @param <U> the value type of the duration publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSampleTimeout<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -42,9 +42,6 @@
  * </code></pre>
  *
  * @param <T> the input and accumulated value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxScan<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -43,9 +43,6 @@
  *
  * @param <T> the source value type
  * @param <R> the aggregate type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxScanSeed<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -69,7 +69,7 @@ public interface FluxSink<T> {
      * Associate a cancellation-based resource with this FluxSink
      * that will be disposed in case the downstream cancels the sequence
      * via {@link org.reactivestreams.Subscription#cancel()}.
-     * @param c
+     * @param c the cancellation callback to use
      */
     void setCancellation(Cancellation c);
 

File: src/main/java/reactor/core/publisher/FluxSkip.java
Patch:
@@ -28,9 +28,6 @@
  * Skips the first N elements from a reactive stream.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkip<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipLast.java
Patch:
@@ -28,9 +28,6 @@
  * Skips the last N elements from the source stream.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkipLast<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -32,9 +32,6 @@
  * true for the value.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkipUntil<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -28,9 +28,6 @@
  *
  * @param <T> the value type of the main Publisher
  * @param <U> the value type of the other Publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxSkipUntilOther<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -32,9 +32,6 @@
  * true for the value.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkipWhile<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -27,9 +27,6 @@
  * Emits the contents of a Stream source.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxStream<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -33,9 +33,6 @@
  * ExecutorService.
  * 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSubscribeOn<T> extends FluxSource<T, T> implements Loopback {

File: src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -30,9 +30,6 @@
  * Executes a Callable and emits its value on the given Scheduler.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxSubscribeOnCallable<T> extends Flux<T> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -32,9 +32,6 @@
  * Publisher indicating a scalar/empty source that subscribes on the specified scheduler.
  * 
  * @param <T>
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxSubscribeOnValue<T> extends Flux<T> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxSwitchIfEmpty.java
Patch:
@@ -25,9 +25,6 @@
  * Switches to another source if the first source turns out to be empty.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSwitchIfEmpty<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -23,9 +23,6 @@
  * Emits the last N values the source emitted before its completion.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeLastOne<T> extends FluxSource<T, T> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -12,9 +12,6 @@
  *
  * @param <T> the value type of the main Publisher
  * @param <U> the value type of the other Publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeUntilOther<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -31,9 +31,6 @@
  * true for the values (checked before each value is delivered).
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeWhile<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -18,9 +18,6 @@
  * @param <T> the main source type
  * @param <U> the value type for the timeout for the very first item
  * @param <V> the value type for the timeout for the subsequent items
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTimeout<T, U, V> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -40,9 +40,6 @@
  *
  * @param <T> the value type streamed
  * @param <S> the resource type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxUsing<T, S> extends Flux<T> implements Receiver, Fuseable {

File: src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -34,9 +34,6 @@
  * 
  * @param <T> the input value type
  * @param <U> the boundary publisher's type (irrelevant)
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWindowBoundary<T, U> extends FluxSource<T, Flux<T>> {

File: src/main/java/reactor/core/publisher/FluxWindowStartEnd.java
Patch:
@@ -38,9 +38,6 @@
  * @param <T> the source value type
  * @param <U> the window starter value type
  * @param <V> the window end value type (irrelevant)
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWindowStartEnd<T, U, V> extends FluxSource<T, Flux<T>> {

File: src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -36,9 +36,6 @@
  * @param <T> the main source type
  * @param <U> the alternate source type
  * @param <R> the output type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWithLatestFrom<T, U, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -165,6 +165,7 @@ void handleIterableMode(Subscriber<? super R> s, Iterable<? extends Publisher<?
 					System.arraycopy(scalars, 0, b, 0, n);
 
 					Publisher<T>[] c = new Publisher[b.length];
+					//noinspection SuspiciousSystemArraycopy
 					System.arraycopy(srcs, 0, c, 0, n);
 
 					scalars = b;
@@ -179,6 +180,7 @@ void handleIterableMode(Subscriber<? super R> s, Iterable<? extends Publisher<?
 					System.arraycopy(scalars, 0, b, 0, n);
 
 					Publisher<T>[] c = new Publisher[b.length];
+					//noinspection SuspiciousSystemArraycopy
 					System.arraycopy(srcs, 0, c, 0, n);
 
 					scalars = b;

File: src/main/java/reactor/core/publisher/FluxZipIterable.java
Patch:
@@ -34,9 +34,6 @@
  * @param <T> the main source value type
  * @param <U> the iterable source value type
  * @param <R> the result type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxZipIterable<T, U, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2105,7 +2105,7 @@ public final Mono<T> onTerminateDetach() {
 	 * consume it as many times as necessary without causing multiple subscriptions
 	 * to the upstream.
 	 *
-	 * @param transform
+	 * @param transform the tranformation function
 	 * @param <R> the output value type
 	 *
 	 * @return a new {@link Mono}

File: src/main/java/reactor/core/publisher/MonoAwaitOnSubscribe.java
Patch:
@@ -28,9 +28,6 @@
  * runs into a half-prepared state. This can happen with non Rx mentality based Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  * @since 3.0
  */

File: src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -34,9 +34,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class MonoCallableOnAssembly<T> extends MonoSource<T, T>

File: src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -26,9 +26,6 @@
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoDefer<T>

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -28,9 +28,6 @@
  * Emits a single 0L value delayed by some time amount with a help of
  * a ScheduledExecutorService instance or a generic function callback that
  * wraps other form of async-delayed execution of tasks.
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoDelay extends Mono<Long> {

File: src/main/java/reactor/core/publisher/MonoDelaySubscription.java
Patch:
@@ -26,9 +26,6 @@
  *
  * @param <T> the main source value type
  * @param <U> the other source type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoDelaySubscription<T, U> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -25,9 +25,7 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance any.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoEmpty 

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -26,9 +26,6 @@
  * Emits a constant or generated Throwable instance to Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoError<T> extends Mono<T> implements Trackable {

File: src/main/java/reactor/core/publisher/MonoFilter.java
Patch:
@@ -28,9 +28,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoFilter<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoFilterFuseable.java
Patch:
@@ -26,9 +26,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoFilterFuseable<T> extends MonoSource<T, T>

File: src/main/java/reactor/core/publisher/MonoHandle.java
Patch:
@@ -20,7 +20,6 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import java.util.function.Function;
 
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxHandleFuseable.HandleFuseableSubscriber;

File: src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -25,9 +25,6 @@
  * Ignores normal values and passes only the terminal signals along.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoIgnoreThen<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Objects;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
 

File: src/main/java/reactor/core/publisher/MonoMap.java
Patch:
@@ -28,9 +28,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoMap<T, R> extends MonoSource<T, R> {

File: src/main/java/reactor/core/publisher/MonoMapFuseable.java
Patch:
@@ -29,9 +29,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoMapFuseable<T, R> extends MonoSource<T, R>

File: src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -23,9 +23,7 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoNever

File: src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -28,9 +28,6 @@
  * Emits a single item at most from the source.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoNext<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -31,9 +31,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class MonoOnAssembly<T> extends MonoSource<T, T> implements Fuseable, AssemblyOp {

File: src/main/java/reactor/core/publisher/MonoOtherwise.java
Patch:
@@ -26,9 +26,6 @@
  * a function for the particular failure exception.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoOtherwise<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoOtherwiseIfEmpty.java
Patch:
@@ -23,9 +23,6 @@
  * Switches to another source if the first source turns out to be empty.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoOtherwiseIfEmpty<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoPeek.java
Patch:
@@ -33,9 +33,6 @@
  * Peeks out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoPeek<T> extends MonoSource<T, T> implements SignalPeek<T> {

File: src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -28,9 +28,6 @@
  * Peeks out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  *
  */

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -561,13 +561,13 @@ public void subscribe(Subscriber s) {
 	@SuppressWarnings("rawtypes")
     final static AtomicIntegerFieldUpdater<MonoProcessor>              STATE     =
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "state");
-    @SuppressWarnings("rawtypes")
+	@SuppressWarnings("rawtypes")
 	final static AtomicIntegerFieldUpdater<MonoProcessor>              WIP       =
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "wip");
-    @SuppressWarnings("rawtypes")
+	@SuppressWarnings("rawtypes")
 	final static AtomicIntegerFieldUpdater<MonoProcessor>              CONNECTED       =
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "connected");
-    @SuppressWarnings("rawtypes")
+	@SuppressWarnings("rawtypes")
 	final static AtomicReferenceFieldUpdater<MonoProcessor, Processor> PROCESSOR =
 		    AtomicReferenceFieldUpdater.newUpdater(MonoProcessor.class, Processor.class,
 				    "processor");

File: src/main/java/reactor/core/publisher/MonoRetry.java
Patch:
@@ -25,9 +25,6 @@
  * The times == Long.MAX_VALUE is treated as infinite retry.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoRetry<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoRetryPredicate.java
Patch:
@@ -27,9 +27,6 @@
  * the previous subscription.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoRetryPredicate<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -21,7 +21,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.Exceptions;
 
 /**
  * A decorating {@link Mono} {@link Publisher} that exposes {@link Mono} API over an arbitrary {@link Publisher}

File: src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -28,9 +28,6 @@
  * Executes a Callable and emits its value on the given Scheduler.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class MonoSubscribeOnCallable<T> extends Mono<T> implements Fuseable {

File: src/main/java/reactor/core/publisher/MonoTimeout.java
Patch:
@@ -30,9 +30,6 @@
  * @param <T> the main source type
  * @param <U> the value type for the timeout for the very first item
  * @param <V> the value type for the timeout for the subsequent items
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoTimeout<T, U, V> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -38,9 +38,6 @@
  *
  * @param <T> the value type streamed
  * @param <S> the resource type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoUsing<T, S> extends Mono<T> implements Receiver, Fuseable {

File: src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -31,9 +31,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class ParallelFluxOnAssembly<T> extends ParallelFlux<T>

File: src/main/java/reactor/core/publisher/ParallelUnorderedPeek.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: src/main/java/reactor/core/publisher/ParallelUnorderedRunOn.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import java.util.Queue;
-import java.util.concurrent.atomic.*;
 import java.util.function.Supplier;
 
 import org.reactivestreams.*;

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -96,10 +96,10 @@ public static <E> ReplayProcessor<E> create() {
 	}
 
 	/**
-	 * Create a new {@link ReplayProcessor} using {@link QueueSupplier#SMALL_BUFFER_SIZE} backlog size, blockingWait
+	 * Create a new {@link ReplayProcessor} using a provided backlog size, blockingWait
 	 * Strategy and auto-cancel.
 	 *
-	 * @param historySize
+	 * @param historySize the backlog size, ie. maximum items retained
 	 *
 	 * @param <E> Type of processed signals
 	 * @return a fresh processor
@@ -109,7 +109,7 @@ public static <E> ReplayProcessor<E> create(int historySize) {
 	}
 
 	/**
-	 * Create a new {@link ReplayProcessor} using {@link QueueSupplier#SMALL_BUFFER_SIZE} backlog size, blockingWait
+	 * Create a new {@link ReplayProcessor} using a provided backlog size, blockingWait
 	 * Strategy and auto-cancel.
 	 *
 	 * @param historySize maximum items retained if bounded, or link size if unbounded

File: src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -17,7 +17,6 @@
 package reactor.core.publisher;
 
 import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.security.AccessController;
@@ -675,7 +674,7 @@ abstract class RingBufferProducer {
 	 * Create with the specified buffer size and wait strategy.
 	 *
 	 * @param bufferSize The total number of entries, must be a positive power of 2.
-	 * @param waitStrategy
+	 * @param waitStrategy The {@link WaitStrategy} to use.
 	 * @param spinObserver
 	 */
 	public RingBufferProducer(int bufferSize, WaitStrategy waitStrategy, Runnable spinObserver) {
@@ -819,7 +818,7 @@ public RingBuffer.Reader newBarrier() {
 	/**
 	 * Publishes a sequence. Call when the event has been filled.
 	 *
-	 * @param sequence
+	 * @param sequence the sequence number to be published
 	 */
 	public abstract void publish(long sequence);
 

File: src/main/java/reactor/core/publisher/SignalPeek.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import java.util.function.Consumer;
-import java.util.function.Function;
 import java.util.function.LongConsumer;
 
 import org.reactivestreams.Publisher;

File: src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -45,7 +45,7 @@ public interface SynchronousSink<T> {
 	 *
 	 * @param t the value to emit, not null
 	 *
-	 * @throws RuntimeException
+	 * @throws RuntimeException in case of unchecked error during the emission
 	 * @see Subscriber#onNext(Object)
 	 */
 	void next(T t);

File: src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -25,11 +25,8 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import reactor.core.Cancellation;
-import reactor.core.Exceptions;
 import reactor.util.concurrent.OpenHashSet;
 
-import static reactor.core.Exceptions.unwrap;
-
 /**
  * Scheduler that hosts a fixed pool of single-threaded ExecutorService-based workers
  * and is suited for parallel work.

File: src/main/java/reactor/util/concurrent/WaitStrategy.java
Patch:
@@ -255,6 +255,7 @@ public void signalAllWhenBlocking()
             }
         }
 
+        @SuppressWarnings("UnusedAssignment") //for availableSequence
         @Override
         public long waitFor(long sequence, LongSupplier cursorSequence, Runnable barrier)
                 throws InterruptedException
@@ -344,6 +345,7 @@ public void signalAllWhenBlocking()
             }
         }
 
+        @SuppressWarnings("UnusedAssignment") //for availableSequence
         @Override
         public long waitFor(long sequence, LongSupplier cursorSequence, Runnable barrier)
                 throws InterruptedException

File: src/main/java/reactor/core/Exceptions.java
Patch:
@@ -37,6 +37,7 @@ public abstract class Exceptions {
 	 * A singleton instance of a Throwable indicating a terminal state for exceptions,
 	 * don't leak this!
 	 */
+	@SuppressWarnings("ThrowableInstanceNeverThrown")
 	public static final Throwable TERMINATED = new Throwable("No further exceptions");
 
 	/**
@@ -317,6 +318,7 @@ public synchronized Throwable fillInStackTrace() {
 	 */
 	static final class CancelException extends BubblingException {
 
+		@SuppressWarnings("ThrowableInstanceNeverThrown")
 		public static final CancelException INSTANCE = new CancelException();
 
 		private CancelException() {

File: src/main/java/reactor/core/publisher/FluxBatch.java
Patch:
@@ -59,7 +59,8 @@ final Subscriber<? super V> prepareSub(Subscriber<? super V> actual) {
 
 	static abstract class BatchAction<T, V> extends Operators.SubscriberAdapter<T, V> {
 
-		static final Exception FAILED_SATE =
+		@SuppressWarnings("ThrowableInstanceNeverThrown")
+		static final Exception FAILED_SATE             =
 				new RuntimeException("Failed Subscriber") {
 					/** */
 					private static final long serialVersionUID = 7503907754069414227L;

File: src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -127,6 +127,7 @@ public <V> FluxConcatArray<V> concatAdditionalIgnoredLast(Publisher<? extends V>
 			source) {
 		int n = array.length;
 		Publisher<? extends V>[] newArray = new Publisher[n + 1];
+		//noinspection SuspiciousSystemArraycopy
 		System.arraycopy(array, 0, newArray, 0, n);
 		newArray[n - 1] = new MonoIgnoreThen<>(newArray[n - 1]);
 		newArray[n] = source;

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -63,7 +63,7 @@ public static <T, R> Subscriber<T> subscriber(Subscriber<? super R> s, Function<
 			super T, ? extends Publisher<? extends R>> mapper,
 			Supplier<? extends Queue<T>> queueSupplier,
 			int prefetch, ErrorMode errorMode) {
-		Subscriber<T> parent = null;
+		Subscriber<T> parent;
 		switch (errorMode) {
 			case BOUNDARY:
 				parent = new ConcatMapDelayed<>(s, mapper, queueSupplier, prefetch,
@@ -99,7 +99,7 @@ public void subscribe(Subscriber<? super R> s) {
 			return;
 		}
 		
-		Subscriber<T> parent = null;
+		Subscriber<T> parent;
 		switch (errorMode) {
 		case BOUNDARY:
 			parent = new ConcatMapDelayed<>(s, mapper, queueSupplier, prefetch, false);

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -165,6 +165,7 @@ void handleIterableMode(Subscriber<? super R> s, Iterable<? extends Publisher<?
 					System.arraycopy(scalars, 0, b, 0, n);
 
 					Publisher<T>[] c = new Publisher[b.length];
+					//noinspection SuspiciousSystemArraycopy
 					System.arraycopy(srcs, 0, c, 0, n);
 
 					scalars = b;
@@ -179,6 +180,7 @@ void handleIterableMode(Subscriber<? super R> s, Iterable<? extends Publisher<?
 					System.arraycopy(scalars, 0, b, 0, n);
 
 					Publisher<T>[] c = new Publisher[b.length];
+					//noinspection SuspiciousSystemArraycopy
 					System.arraycopy(srcs, 0, c, 0, n);
 
 					scalars = b;

File: src/main/java/reactor/util/concurrent/WaitStrategy.java
Patch:
@@ -255,6 +255,7 @@ public void signalAllWhenBlocking()
             }
         }
 
+        @SuppressWarnings("UnusedAssignment") //for availableSequence
         @Override
         public long waitFor(long sequence, LongSupplier cursorSequence, Runnable barrier)
                 throws InterruptedException
@@ -344,6 +345,7 @@ public void signalAllWhenBlocking()
             }
         }
 
+        @SuppressWarnings("UnusedAssignment") //for availableSequence
         @Override
         public long waitFor(long sequence, LongSupplier cursorSequence, Runnable barrier)
                 throws InterruptedException

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -134,7 +134,7 @@ public void next(T t) {
 			}
 			else {
 				Queue<T> q = queue;
-				synchronized (q) {
+				synchronized (this) {
 					q.offer(t);
 				}
 				if (WIP.getAndIncrement(this) != 0) {

File: src/main/java/reactor/core/publisher/ConnectableFluxOnAssembly.java
Patch:
@@ -37,9 +37,6 @@
  * </ul>
  * 
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class ConnectableFluxOnAssembly<T> extends ConnectableFlux<T> implements

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4248,7 +4248,7 @@ public final ConnectableFlux<T> publish(int prefetch) {
 	 * consume it as many times as necessary without causing multiple subscriptions
 	 * to the upstream.
 	 *
-	 * @param transform
+	 * @param transform the transformation function
 	 * @param <R> the output value type
 	 *
 	 * @return a new {@link Flux}
@@ -4263,8 +4263,8 @@ public final <R> Flux<R> publish(Function<? super Flux<T>, ? extends Publisher<?
 	 * consume it as many times as necessary without causing multiple subscriptions
 	 * to the upstream.
 	 *
-	 * @param transform
-	 * @param prefetch
+	 * @param transform the transformation function
+	 * @param prefetch the request size
 	 * @param <R> the output value type
 	 *
 	 * @return a new {@link Flux}

File: src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -31,9 +31,6 @@
  * Emits the contents of a wrapped (shared) array.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxArray<T> 

File: src/main/java/reactor/core/publisher/FluxAutoConnect.java
Patch:
@@ -28,9 +28,6 @@
  * subscribed.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxAutoConnect<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxAutoConnectFuseable.java
Patch:
@@ -29,9 +29,6 @@
  * subscribed.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxAutoConnectFuseable<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxAwaitOnSubscribe.java
Patch:
@@ -20,9 +20,6 @@
  * runs into a half-prepared state. This can happen with non Rx mentality based Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  * @since 3.0
  */

File: src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -36,9 +36,6 @@
  *
  * @param <T> the source value type
  * @param <C> the buffer collection type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxBuffer<T, C extends Collection<? super T>> extends FluxSource<T, C> {

File: src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -32,9 +32,6 @@
  * @param <T> the source value type
  * @param <U> the element type of the boundary publisher (irrelevant)
  * @param <C> the output collection type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxBufferBoundary<T, U, C extends Collection<? super T>>

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -41,9 +41,6 @@
  * @param <U> the value type of the publisher opening the buffers
  * @param <V> the value type of the publisher closing the individual buffers
  * @param <C> the collection type that holds the buffered values
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxBufferStartEnd<T, U, V, C extends Collection<? super T>>

File: src/main/java/reactor/core/publisher/FluxCallableOnAssembly.java
Patch:
@@ -33,9 +33,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxCallableOnAssembly<T> extends FluxSource<T, T>

File: src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -40,9 +40,6 @@
  *
  * @param <T> the value type of the sources
  * @param <R> the result type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxCombineLatest<T, R> 

File: src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -30,9 +30,6 @@
  * Concatenates a fixed array of Publishers' values.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxConcatArray<T> 

File: src/main/java/reactor/core/publisher/FluxConcatIterable.java
Patch:
@@ -27,9 +27,6 @@
  * Concatenates a fixed array of Publishers' values.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxConcatIterable<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -35,9 +35,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the output value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxConcatMap<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -26,9 +26,6 @@
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDefer<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -28,9 +28,6 @@
  *
  * @param <T> the main source value type
  * @param <U> the other source type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDelaySubscription<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxDetach.java
Patch:
@@ -11,9 +11,6 @@
  * wit non Rx mentality based Publishers.
  * 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDetach<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -32,9 +32,6 @@
  *
  * @param <T> the value type
  * @param <K> the key type used for comparing subsequent elements
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDistinctUntilChanged<T, K> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxEmpty.java
Patch:
@@ -24,9 +24,6 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance any.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxEmpty

File: src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -27,9 +27,6 @@
  * Emits a constant or generated Throwable instance to Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxError<T>

File: src/main/java/reactor/core/publisher/FluxFilter.java
Patch:
@@ -34,9 +34,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFilter<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxFilterFuseable.java
Patch:
@@ -31,9 +31,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFilterFuseable<T> extends FluxSource<T, T>

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -35,9 +35,6 @@
  * Concatenates values from Iterable sequences generated via a mapper function.
  * @param <T> the input value type
  * @param <R> the value type of the iterables and the result type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFlattenIterable<T, R> extends FluxSource<T, R> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -36,9 +36,6 @@
  *
  * @param <T> the value type emitted
  * @param <S> the custom state per subscriber
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxGenerate<T, S> 

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -42,9 +42,6 @@
  * @param <T> the source value type
  * @param <K> the key value type
  * @param <V> the group item value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxGroupBy<T, K, V> extends FluxSource<T, GroupedFlux<K, V>>

File: src/main/java/reactor/core/publisher/FluxGroupJoin.java
Patch:
@@ -51,9 +51,6 @@
  * indicate the duration of the values of the {@code right} Publisher
  * @param <R> type that a function that takes an item emitted by each Publisher and
  * returns the value to be emitted by the resulting Publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  * @since 3.0
  */

File: src/main/java/reactor/core/publisher/FluxHide.java
Patch:
@@ -24,9 +24,6 @@
  * as well. 
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxHide<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxInterval.java
Patch:
@@ -27,9 +27,6 @@
 /**
  * Periodically emits an ever increasing long value either via a ScheduledExecutorService
  * or a custom async callback function
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxInterval extends Flux<Long> {

File: src/main/java/reactor/core/publisher/FluxMap.java
Patch:
@@ -33,9 +33,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxMap<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxMapFuseable.java
Patch:
@@ -34,9 +34,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxMapFuseable<T, R> extends FluxSource<T, R>

File: src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -34,9 +34,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @author Stephane Maldini
  */
 final class FluxMapSignal<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxMerge.java
Patch:
@@ -30,9 +30,6 @@
 /**
  * Merges a fixed array of Publishers.
  * @param <T> the element type of the publishers
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxMerge<T> extends Flux<T> implements MultiReceiver, Trackable {

File: src/main/java/reactor/core/publisher/FluxNever.java
Patch:
@@ -24,9 +24,7 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxNever 

File: src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -45,9 +45,6 @@
  * </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxOnAssembly<T> extends FluxSource<T, T> implements Fuseable, AssemblyOp {

File: src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -39,9 +39,6 @@
  * Crashes by the lambdas are ignored.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPeek<T> extends FluxSource<T, T> implements SignalPeek<T> {

File: src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -36,9 +36,6 @@
  * Crashes by the lambdas are ignored.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPeekFuseable<T> extends FluxSource<T, T> implements Fuseable,

File: src/main/java/reactor/core/publisher/FluxPublish.java
Patch:
@@ -41,9 +41,6 @@
  * A connectable publisher which shares an underlying source and dispatches source values to subscribers in a backpressure-aware
  * manner. 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPublish<T> extends ConnectableFlux<T>

File: src/main/java/reactor/core/publisher/FluxPublishMulticast.java
Patch:
@@ -35,9 +35,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the output value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPublishMulticast<T, R> extends FluxSource<T, R> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -37,9 +37,6 @@
  * Emits events on a different thread specified by a scheduler callback.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxPublishOn<T> extends FluxSource<T, T> implements Loopback, Fuseable {

File: src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -24,9 +24,7 @@
 
 /**
  * Emits a range of integer values.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRange extends Flux<Integer>

File: src/main/java/reactor/core/publisher/FluxRefCount.java
Patch:
@@ -35,9 +35,6 @@
  * to it and disconnects once all Subscribers cancelled their Subscriptions.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRefCount<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxRepeat.java
Patch:
@@ -27,9 +27,6 @@
  * The times == Long.MAX_VALUE is treated as infinite repeat.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRepeat<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -27,9 +27,6 @@
  * completion of the previous subscription.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRepeatPredicate<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -32,9 +32,6 @@
  * attempt is suppressed and any terminal signal will terminate the main source with the same signal immediately.
  *
  * @param <T> the source value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRepeatWhen<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxReplay.java
Patch:
@@ -39,9 +39,6 @@
 
 /**
  * @param <T>
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxReplay<T> extends ConnectableFlux<T>

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -28,9 +28,6 @@
  * a function for the particular failure exception.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxResume<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRetry.java
Patch:
@@ -12,9 +12,6 @@
  * The times == Long.MAX_VALUE is treated as infinite retry.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRetry<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -27,9 +27,6 @@
  * completion of the previous subscription.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRetryPredicate<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -32,9 +32,6 @@
  * attempt is suppressed and any terminal signal will terminate the main source with the same signal immediately.
  *
  * @param <T> the source value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxRetryWhen<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -37,9 +37,6 @@
  * 
  * @param <T> the input and output value type
  * @param <U> the value type of the sampler (irrelevant)
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSample<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -32,9 +32,6 @@
  *
  * @param <T> the source and output value type
  * @param <U> the value type of the publisher signalling the end of the throttling duration
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSampleFirst<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -34,9 +34,6 @@
  *
  * @param <T> the source value type
  * @param <U> the value type of the duration publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSampleTimeout<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -42,9 +42,6 @@
  * </code></pre>
  *
  * @param <T> the input and accumulated value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxScan<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxScanSeed.java
Patch:
@@ -43,9 +43,6 @@
  *
  * @param <T> the source value type
  * @param <R> the aggregate type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxScanSeed<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -69,7 +69,7 @@ public interface FluxSink<T> {
      * Associate a cancellation-based resource with this FluxSink
      * that will be disposed in case the downstream cancels the sequence
      * via {@link org.reactivestreams.Subscription#cancel()}.
-     * @param c
+     * @param c the cancellation callback to use
      */
     void setCancellation(Cancellation c);
 

File: src/main/java/reactor/core/publisher/FluxSkip.java
Patch:
@@ -28,9 +28,6 @@
  * Skips the first N elements from a reactive stream.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkip<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipLast.java
Patch:
@@ -28,9 +28,6 @@
  * Skips the last N elements from the source stream.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkipLast<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -32,9 +32,6 @@
  * true for the value.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkipUntil<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipUntilOther.java
Patch:
@@ -28,9 +28,6 @@
  *
  * @param <T> the value type of the main Publisher
  * @param <U> the value type of the other Publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxSkipUntilOther<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -32,9 +32,6 @@
  * true for the value.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSkipWhile<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -27,9 +27,6 @@
  * Emits the contents of a Stream source.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxStream<T> extends Flux<T>

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -33,9 +33,6 @@
  * ExecutorService.
  * 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSubscribeOn<T> extends FluxSource<T, T> implements Loopback {

File: src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -30,9 +30,6 @@
  * Executes a Callable and emits its value on the given Scheduler.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxSubscribeOnCallable<T> extends Flux<T> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxSubscribeOnValue.java
Patch:
@@ -32,9 +32,6 @@
  * Publisher indicating a scalar/empty source that subscribes on the specified scheduler.
  * 
  * @param <T>
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxSubscribeOnValue<T> extends Flux<T> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxSwitchIfEmpty.java
Patch:
@@ -25,9 +25,6 @@
  * Switches to another source if the first source turns out to be empty.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSwitchIfEmpty<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -33,9 +33,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the output value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxSwitchMap<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -30,9 +30,6 @@
  * Emits the last N values the source emitted before its completion.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeLast<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -23,9 +23,6 @@
  * Emits the last N values the source emitted before its completion.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeLastOne<T> extends FluxSource<T, T> implements Fuseable {

File: src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -17,9 +17,6 @@
  * (checked after each value has been delivered).
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeUntil<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTakeUntilOther.java
Patch:
@@ -12,9 +12,6 @@
  *
  * @param <T> the value type of the main Publisher
  * @param <U> the value type of the other Publisher
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeUntilOther<T, U> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -31,9 +31,6 @@
  * true for the values (checked before each value is delivered).
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeWhile<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -18,9 +18,6 @@
  * @param <T> the main source type
  * @param <U> the value type for the timeout for the very first item
  * @param <V> the value type for the timeout for the subsequent items
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTimeout<T, U, V> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxUsing.java
Patch:
@@ -40,9 +40,6 @@
  *
  * @param <T> the value type streamed
  * @param <S> the resource type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxUsing<T, S> extends Flux<T> implements Receiver, Fuseable {

File: src/main/java/reactor/core/publisher/FluxWindow.java
Patch:
@@ -39,9 +39,6 @@
  * Splits the source sequence into possibly overlapping publishers.
  * 
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class FluxWindow<T> extends FluxSource<T, Flux<T>> {

File: src/main/java/reactor/core/publisher/FluxWindowBoundary.java
Patch:
@@ -34,9 +34,6 @@
  * 
  * @param <T> the input value type
  * @param <U> the boundary publisher's type (irrelevant)
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWindowBoundary<T, U> extends FluxSource<T, Flux<T>> {

File: src/main/java/reactor/core/publisher/FluxWindowOnCancel.java
Patch:
@@ -37,9 +37,6 @@
  * Splits the source sequence into possibly overlapping publishers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWindowOnCancel<T> extends FluxSource<T, Flux<T>> {

File: src/main/java/reactor/core/publisher/FluxWindowStartEnd.java
Patch:
@@ -38,9 +38,6 @@
  * @param <T> the source value type
  * @param <U> the window starter value type
  * @param <V> the window end value type (irrelevant)
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWindowStartEnd<T, U, V> extends FluxSource<T, Flux<T>> {

File: src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -36,9 +36,6 @@
  * @param <T> the main source type
  * @param <U> the alternate source type
  * @param <R> the output type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxWithLatestFrom<T, U, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxZipIterable.java
Patch:
@@ -34,9 +34,6 @@
  * @param <T> the main source value type
  * @param <U> the iterable source value type
  * @param <R> the result type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxZipIterable<T, U, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2105,7 +2105,7 @@ public final Mono<T> onTerminateDetach() {
 	 * consume it as many times as necessary without causing multiple subscriptions
 	 * to the upstream.
 	 *
-	 * @param transform
+	 * @param transform the tranformation function
 	 * @param <R> the output value type
 	 *
 	 * @return a new {@link Mono}

File: src/main/java/reactor/core/publisher/MonoAwaitOnSubscribe.java
Patch:
@@ -28,9 +28,6 @@
  * runs into a half-prepared state. This can happen with non Rx mentality based Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  * @since 3.0
  */

File: src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -34,9 +34,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class MonoCallableOnAssembly<T> extends MonoSource<T, T>

File: src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -26,9 +26,6 @@
  * Defers the creation of the actual Publisher the Subscriber will be subscribed to.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoDefer<T>

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -28,9 +28,6 @@
  * Emits a single 0L value delayed by some time amount with a help of
  * a ScheduledExecutorService instance or a generic function callback that
  * wraps other form of async-delayed execution of tasks.
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoDelay extends Mono<Long> {

File: src/main/java/reactor/core/publisher/MonoDelaySubscription.java
Patch:
@@ -26,9 +26,6 @@
  *
  * @param <T> the main source value type
  * @param <U> the other source type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoDelaySubscription<T, U> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -25,9 +25,7 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance any.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoEmpty 

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -26,9 +26,6 @@
  * Emits a constant or generated Throwable instance to Subscribers.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoError<T> extends Mono<T> implements Trackable {

File: src/main/java/reactor/core/publisher/MonoFilter.java
Patch:
@@ -28,9 +28,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoFilter<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoFilterFuseable.java
Patch:
@@ -26,9 +26,6 @@
  * Filters out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoFilterFuseable<T> extends MonoSource<T, T>

File: src/main/java/reactor/core/publisher/MonoIgnoreThen.java
Patch:
@@ -25,9 +25,6 @@
  * Ignores normal values and passes only the terminal signals along.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoIgnoreThen<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoMap.java
Patch:
@@ -28,9 +28,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoMap<T, R> extends MonoSource<T, R> {

File: src/main/java/reactor/core/publisher/MonoMapFuseable.java
Patch:
@@ -29,9 +29,6 @@
  * 
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoMapFuseable<T, R> extends MonoSource<T, R>

File: src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -23,9 +23,7 @@
  * <p>
  * This Publisher is effectively stateless and only a single instance exists.
  * Use the {@link #instance()} method to obtain a properly type-parametrized view of it.
- */
-
-/**
+ *
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoNever

File: src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -28,9 +28,6 @@
  * Emits a single item at most from the source.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoNext<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoOnAssembly.java
Patch:
@@ -31,9 +31,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class MonoOnAssembly<T> extends MonoSource<T, T> implements Fuseable, AssemblyOp {

File: src/main/java/reactor/core/publisher/MonoOtherwise.java
Patch:
@@ -26,9 +26,6 @@
  * a function for the particular failure exception.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoOtherwise<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoOtherwiseIfEmpty.java
Patch:
@@ -23,9 +23,6 @@
  * Switches to another source if the first source turns out to be empty.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoOtherwiseIfEmpty<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoPeek.java
Patch:
@@ -33,9 +33,6 @@
  * Peeks out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoPeek<T> extends MonoSource<T, T> implements SignalPeek<T> {

File: src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -28,9 +28,6 @@
  * Peeks out values that make a filter function return false.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  *
  */

File: src/main/java/reactor/core/publisher/MonoRetry.java
Patch:
@@ -25,9 +25,6 @@
  * The times == Long.MAX_VALUE is treated as infinite retry.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoRetry<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoRetryPredicate.java
Patch:
@@ -27,9 +27,6 @@
  * the previous subscription.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoRetryPredicate<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoRetryWhen.java
Patch:
@@ -31,9 +31,6 @@
  * signal immediately.
  *
  * @param <T> the source value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoRetryWhen<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoSubscribeOnCallable.java
Patch:
@@ -28,9 +28,6 @@
  * Executes a Callable and emits its value on the given Scheduler.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class MonoSubscribeOnCallable<T> extends Mono<T> implements Fuseable {

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -27,9 +27,6 @@
  * Executes a Supplier function and emits a single value to each individual Subscriber.
  *
  * @param <T> the returned value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoSupplier<T> 

File: src/main/java/reactor/core/publisher/MonoTimeout.java
Patch:
@@ -30,9 +30,6 @@
  * @param <T> the main source type
  * @param <U> the value type for the timeout for the very first item
  * @param <V> the value type for the timeout for the subsequent items
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoTimeout<T, U, V> extends MonoSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -38,9 +38,6 @@
  *
  * @param <T> the value type streamed
  * @param <S> the resource type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class MonoUsing<T, S> extends Mono<T> implements Receiver, Fuseable {

File: src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -22,9 +22,6 @@
  * Hides the identities of the upstream Publisher object and its Subscription as well.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class ParallelFluxHide<T> extends ParallelFlux<T> {

File: src/main/java/reactor/core/publisher/ParallelFluxOnAssembly.java
Patch:
@@ -31,9 +31,6 @@
  * methods)</li> <li>Tomcat worker thread entries</li> <li>JUnit setup</li> </ul>
  *
  * @param <T> the value type passing through
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">https://github.com/reactor/reactive-streams-commons</a>
  */
 final class ParallelFluxOnAssembly<T> extends ParallelFlux<T>

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -96,10 +96,10 @@ public static <E> ReplayProcessor<E> create() {
 	}
 
 	/**
-	 * Create a new {@link ReplayProcessor} using {@link QueueSupplier#SMALL_BUFFER_SIZE} backlog size, blockingWait
+	 * Create a new {@link ReplayProcessor} using a provided backlog size, blockingWait
 	 * Strategy and auto-cancel.
 	 *
-	 * @param historySize
+	 * @param historySize the backlog size, ie. maximum items retained
 	 *
 	 * @param <E> Type of processed signals
 	 * @return a fresh processor
@@ -109,7 +109,7 @@ public static <E> ReplayProcessor<E> create(int historySize) {
 	}
 
 	/**
-	 * Create a new {@link ReplayProcessor} using {@link QueueSupplier#SMALL_BUFFER_SIZE} backlog size, blockingWait
+	 * Create a new {@link ReplayProcessor} using a provided backlog size, blockingWait
 	 * Strategy and auto-cancel.
 	 *
 	 * @param historySize maximum items retained if bounded, or link size if unbounded

File: src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -674,7 +674,7 @@ abstract class RingBufferProducer {
 	 * Create with the specified buffer size and wait strategy.
 	 *
 	 * @param bufferSize The total number of entries, must be a positive power of 2.
-	 * @param waitStrategy
+	 * @param waitStrategy The {@link WaitStrategy} to use.
 	 * @param spinObserver
 	 */
 	public RingBufferProducer(int bufferSize, WaitStrategy waitStrategy, Runnable spinObserver) {
@@ -818,7 +818,7 @@ public RingBuffer.Reader newBarrier() {
 	/**
 	 * Publishes a sequence. Call when the event has been filled.
 	 *
-	 * @param sequence
+	 * @param sequence the sequence number to be published
 	 */
 	public abstract void publish(long sequence);
 

File: src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -45,7 +45,7 @@ public interface SynchronousSink<T> {
 	 *
 	 * @param t the value to emit, not null
 	 *
-	 * @throws RuntimeException
+	 * @throws RuntimeException in case of unchecked error during the emission
 	 * @see Subscriber#onNext(Object)
 	 */
 	void next(T t);

File: src/main/java/reactor/adapter/JdkFlowAdapter.java
Patch:
@@ -29,6 +29,7 @@
  * @author Stephane Maldini
  * @author Sebastien Deleuze
  */
+@SuppressWarnings("Since15")
 public abstract class JdkFlowAdapter {
 
 	/**

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.reactivestreams.Processor;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.MultiProducer;

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -550,6 +550,7 @@ public void run() {
 				upstream.request(bufferSize);
 
 				long c;
+				//noinspection InfiniteLoopStatement
 				for (; ; ) {
 					c = cursor + limit;
 					cursor = waitStrategy.waitFor(c, readCount, spinObserver);

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -439,7 +439,6 @@ void drain() {
 						}
 					} else {
 						anyError(new IllegalStateException("Could not emit buffer due to lack of requests"));
-						continue;
 					}
 				}
 				

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -18,7 +18,6 @@
 
 import java.util.Objects;
 import java.util.Queue;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReference;
@@ -583,7 +582,7 @@ static final class LatestAsyncSink<T> extends BaseSink<T> {
 
 		public LatestAsyncSink(Subscriber<? super T> actual) {
 			super(actual);
-			this.queue = new AtomicReference<T>();
+			this.queue = new AtomicReference<>();
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/FluxHandle.java
Patch:
@@ -21,7 +21,6 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import java.util.function.Function;
 
 import reactor.core.Fuseable;
 import reactor.core.Loopback;

File: src/main/java/reactor/core/publisher/FluxHandleFuseable.java
Patch:
@@ -21,7 +21,6 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import java.util.function.Function;
 
 import reactor.core.Exceptions;
 import reactor.core.Fuseable;
@@ -64,7 +63,6 @@ public FluxHandleFuseable(Publisher<? extends T> source,
 	@Override
 	public void subscribe(Subscriber<? super R> s) {
 		if (s instanceof ConditionalSubscriber) {
-			
 			ConditionalSubscriber<? super R> cs = (ConditionalSubscriber<? super R>) s;
 			source.subscribe(new HandleFuseableConditionalSubscriber<>(cs, handler));
 			return;

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
-import reactor.core.Loopback;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
 

File: src/main/java/reactor/core/publisher/FluxMergeSequential.java
Patch:
@@ -166,7 +166,7 @@ public void onNext(T t) {
 				return;
 			}
 
-			MergeSequentialInner<R> inner = new MergeSequentialInner<R>(this, prefetch);
+			MergeSequentialInner<R> inner = new MergeSequentialInner<>(this, prefetch);
 
 			if (cancelled) {
 				return;

File: src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.Map;
 import java.util.Queue;
 import java.util.concurrent.LinkedTransferQueue;
-import java.util.function.Function;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;

File: src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -39,10 +39,10 @@
  */
 final class FluxRepeatWhen<T> extends FluxSource<T, T> {
 
-	final Function<? super Flux<Long>, ? extends Publisher<? extends Object>> whenSourceFactory;
+	final Function<? super Flux<Long>, ? extends Publisher<?>> whenSourceFactory;
 
 	public FluxRepeatWhen(Publisher<? extends T> source,
-							   Function<? super Flux<Long>, ? extends Publisher<? extends Object>> whenSourceFactory) {
+							   Function<? super Flux<Long>, ? extends Publisher<?>> whenSourceFactory) {
 		super(source);
 		this.whenSourceFactory = Objects.requireNonNull(whenSourceFactory, "whenSourceFactory");
 	}

File: src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -438,7 +438,6 @@ public void onSubscribe(Subscription s) {
 				s.cancel();
 				
 				Operators.reportSubscriptionSet();
-				return;
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -22,10 +22,8 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Fuseable;
 import reactor.core.Producer;
 import reactor.core.Receiver;
-import reactor.core.publisher.MonoTakeLastOne.TakeLastOneSubscriber;
 import reactor.core.Trackable;
 
 /**

File: src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -87,8 +87,6 @@ public void onNext(T t) {
 				s.cancel();
 
 				onComplete();
-
-				return;
 			}
 		}
 

File: src/main/java/reactor/core/publisher/FluxWindowOnCancel.java
Patch:
@@ -16,7 +16,7 @@
 
 package reactor.core.publisher;
 
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.Objects;
 import java.util.Queue;
@@ -212,8 +212,8 @@ public Object upstream() {
 
 		@Override
 		public Iterator<?> downstreams() {
-			return Arrays.asList(window)
-			             .iterator();
+			return Collections.singletonList(window)
+			                  .iterator();
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/MonoHandle.java
Patch:
@@ -20,7 +20,6 @@
 
 import java.util.Objects;
 import java.util.function.BiConsumer;
-import java.util.function.Function;
 
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxHandleFuseable.HandleFuseableSubscriber;

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Objects;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
 

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -561,13 +561,13 @@ public void subscribe(Subscriber s) {
 	@SuppressWarnings("rawtypes")
     final static AtomicIntegerFieldUpdater<MonoProcessor>              STATE     =
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "state");
-    @SuppressWarnings("rawtypes")
+	@SuppressWarnings("rawtypes")
 	final static AtomicIntegerFieldUpdater<MonoProcessor>              WIP       =
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "wip");
-    @SuppressWarnings("rawtypes")
+	@SuppressWarnings("rawtypes")
 	final static AtomicIntegerFieldUpdater<MonoProcessor>              CONNECTED       =
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "connected");
-    @SuppressWarnings("rawtypes")
+	@SuppressWarnings("rawtypes")
 	final static AtomicReferenceFieldUpdater<MonoProcessor, Processor> PROCESSOR =
 		    AtomicReferenceFieldUpdater.newUpdater(MonoProcessor.class, Processor.class,
 				    "processor");

File: src/main/java/reactor/core/publisher/MonoRetryWhen.java
Patch:
@@ -38,11 +38,11 @@
  */
 final class MonoRetryWhen<T> extends MonoSource<T, T> {
 
-	final Function<? super Flux<Throwable>, ? extends Publisher<? extends Object>>
+	final Function<? super Flux<Throwable>, ? extends Publisher<?>>
 			whenSourceFactory;
 
 	public MonoRetryWhen(Publisher<? extends T> source,
-			Function<? super Flux<Throwable>, ? extends Publisher<? extends Object>> whenSourceFactory) {
+			Function<? super Flux<Throwable>, ? extends Publisher<?>> whenSourceFactory) {
 		super(source);
 		this.whenSourceFactory =
 				Objects.requireNonNull(whenSourceFactory, "whenSourceFactory");

File: src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -21,7 +21,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.Exceptions;
 
 /**
  * A decorating {@link Mono} {@link Publisher} that exposes {@link Mono} API over an arbitrary {@link Publisher}

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.function.Supplier;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
 

File: src/main/java/reactor/core/publisher/ParallelFluxHide.java
Patch:
@@ -16,9 +16,7 @@
 
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
 
 /**
  * Hides the identities of the upstream Publisher object and its Subscription as well.

File: src/main/java/reactor/core/publisher/ParallelUnorderedPeek.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.function.Consumer;
 import java.util.function.LongConsumer;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: src/main/java/reactor/core/publisher/ParallelUnorderedRunOn.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import java.util.Queue;
-import java.util.concurrent.atomic.*;
 import java.util.function.Supplier;
 
 import org.reactivestreams.*;

File: src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -17,7 +17,6 @@
 package reactor.core.publisher;
 
 import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.security.AccessController;

File: src/main/java/reactor/core/publisher/SignalPeek.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import java.util.function.Consumer;
-import java.util.function.Function;
 import java.util.function.LongConsumer;
 
 import org.reactivestreams.Publisher;

File: src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -25,11 +25,8 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import reactor.core.Cancellation;
-import reactor.core.Exceptions;
 import reactor.util.concurrent.OpenHashSet;
 
-import static reactor.core.Exceptions.unwrap;
-
 /**
  * Scheduler that hosts a fixed pool of single-threaded ExecutorService-based workers
  * and is suited for parallel work.

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2097,7 +2097,7 @@ public final <E extends Throwable> Mono<T> otherwiseReturn(Predicate<? super
 	 * @return a detachable {@link Mono}
 	 */
 	public final Mono<T> onTerminateDetach() {
-		return MonoSource.wrap(new FluxDetach<>(this));
+		return new MonoDetach<>(this);
 	}
 
 	/**

File: src/test/java/reactor/core/publisher/FluxBufferTimeOrSizeTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+//FIXME when virtual time scheduler
 public class FluxBufferTimeOrSizeTest {
 
 	@Test

File: src/main/java/reactor/core/publisher/BlockingSink.java
Patch:
@@ -101,7 +101,7 @@ public static <E> BlockingSink<E> create(Subscriber<? super E> subscriber, boole
 	 * Create a
 	 * {@link BlockingSink} to safely signal a target {@link Subscriber} or {@link org.reactivestreams.Processor}.
 	 *
-	 * The subscriber will be immediately  {@link #start started} via {@link Subscriber#onSubscribe(Subscription)} as the result of
+	 * The actual will be immediately  {@link #start started} via {@link Subscriber#onSubscribe(Subscription)} as the result of
 	 * this call.
 	 *
 	 * @param subscriber the decorated {@link Subscriber}
@@ -173,7 +173,7 @@ public void next(E t) {
 	 * A non-blocking {@link Subscriber#onNext(Object)} that will return a status 
 	 * {@link BlockingSink.Emission}. The status will
 	 * indicate if the decorated
-	 * subscriber is backpressuring this {@link BlockingSink} and if it has previously been terminated successfully or
+	 * actual is backpressuring this {@link BlockingSink} and if it has previously been terminated successfully or
 	 * not.
 	 *
 	 * @param data the data to signal
@@ -328,7 +328,7 @@ public long requestedFromDownstream() {
 	}
 
 	/**
-	 * Subscribe the decorated subscriber
+	 * Subscribe the decorated actual
 	 * {@link Subscriber#onSubscribe(Subscription)}. If called twice, the current {@link BlockingSink} might be
 	 * cancelled as per Reactive Streams Specification enforce.
 	 */

File: src/main/java/reactor/core/publisher/FluxDistinct.java
Patch:
@@ -38,9 +38,6 @@
  * @param <T> the source value type
  * @param <K> the key extacted from the source value to be used for duplicate testing
  * @param <C> the collection type whose add() method is used for testing for duplicates
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDistinct<T, K, C extends Collection<? super K>> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -32,9 +32,6 @@
  * @param <T> the source value type
  * @param <K> the key extacted from the source value to be used for duplicate testing
  * @param <C> the collection type whose add() method is used for testing for duplicates
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxDistinctFuseable<T, K, C extends Collection<? super K>> 

File: src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -32,9 +32,6 @@
  * subscriber which responds first with any signal.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFirstEmitting<T>

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -43,9 +43,6 @@
  *
  * @param <T> the source value type
  * @param <R> the result value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxFlatMap<T, R> extends FluxSource<T, R> {

File: src/main/java/reactor/core/publisher/FluxOnBackpressureDrop.java
Patch:
@@ -31,9 +31,6 @@
  * Drops values if the subscriber doesn't request fast enough.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxOnBackpressureDrop<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -31,9 +31,6 @@
  * if the subscriber can't keep up properly.
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxOnBackpressureLatest<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -61,7 +61,7 @@ public static <T> FluxProcessor<Publisher<? extends T>, T> switchOnNext() {
 	 *
 	 * @param <IN> the receiving type
 	 * @param <OUT> the producing type
-	 * 
+	 *
 	 * @param upstream the upstream subscriber
 	 * @param downstream the downstream publisher
 	 * @return a new blackboxed {@link FluxProcessor}

File: src/main/java/reactor/core/publisher/FluxTake.java
Patch:
@@ -34,9 +34,6 @@
  * signals its first value (which is not not relayed though).
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTake<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxTakeFuseable.java
Patch:
@@ -27,9 +27,6 @@
  * signals its first value (which is not not relayed though).
  *
  * @param <T> the value type
- */
-
-/**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
 final class FluxTakeFuseable<T> extends FluxSource<T, T> implements Fuseable {

File: src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -67,15 +67,12 @@ static final class MonoBufferAllSubscriber<T, C extends Collection<? super T>>
 			extends Operators.MonoSubscriber<T, C>
 			implements Subscriber<T>, Subscription {
 
-		final Subscriber<? super C> actual;
-
 		C collection;
 
 		Subscription s;
 
 		public MonoBufferAllSubscriber(Subscriber<? super C> actual, C collection) {
 			super(actual);
-			this.actual = actual;
 			this.collection = collection;
 		}
 

File: src/main/java/reactor/core/publisher/MonoHasElements.java
Patch:
@@ -53,7 +53,7 @@ public void cancel() {
 		public void onSubscribe(Subscription s) {
 			if (Operators.validate(this.s, s)) {
 				this.s = s;
-				subscriber.onSubscribe(this);
+				actual.onSubscribe(this);
 
 				s.request(Long.MAX_VALUE);
 			}

File: src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -69,7 +69,7 @@ public void onSubscribe(Subscription s) {
 			if (Operators.validate(this.s, s)) {
 				this.s = s;
 
-				subscriber.onSubscribe(this);
+				actual.onSubscribe(this);
 
 				s.request(Long.MAX_VALUE);
 			}
@@ -90,12 +90,12 @@ public void onComplete() {
 						complete(defaultValue);
 					}
 					else {
-						subscriber.onError(Operators.onOperatorError(new NoSuchElementException(
+						actual.onError(Operators.onOperatorError(new NoSuchElementException(
 								"Flux#last() didn't observe any " + "onNext signal")));
 					}
 				}
 				else {
-					subscriber.onComplete();
+					actual.onComplete();
 				}
 				return;
 			}

File: src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -116,8 +116,8 @@ public ParallelCollectSubscriber(Subscriber<? super C> subscriber,
 		public void onSubscribe(Subscription s) {
 			if (Operators.validate(this.s, s)) {
 				this.s = s;
-				
-				subscriber.onSubscribe(this);
+
+				actual.onSubscribe(this);
 				
 				s.request(Long.MAX_VALUE);
 			}
@@ -145,7 +145,7 @@ public void onError(Throwable t) {
 			}
 			done = true;
 			collection = null;
-			subscriber.onError(t);
+			actual.onError(t);
 		}
 		
 		@Override

File: src/main/java/reactor/core/publisher/ParallelReduce.java
Patch:
@@ -114,8 +114,8 @@ public ParallelReduceSubscriber(Subscriber<? super R> subscriber, R initialValue
 		public void onSubscribe(Subscription s) {
 			if (Operators.validate(this.s, s)) {
 				this.s = s;
-				
-				subscriber.onSubscribe(this);
+
+				actual.onSubscribe(this);
 				
 				s.request(Long.MAX_VALUE);
 			}
@@ -154,7 +154,7 @@ public void onError(Throwable t) {
 			}
 			done = true;
 			accumulator = null;
-			subscriber.onError(t);
+			actual.onError(t);
 		}
 		
 		@Override

File: src/main/java/reactor/core/publisher/ParallelReduceFull.java
Patch:
@@ -122,7 +122,7 @@ public void cancel() {
 		void innerError(Throwable ex) {
 			if (ERROR_ONCE.compareAndSet(this, 0, 1)) {
 				cancel();
-				subscriber.onError(ex);
+				actual.onError(ex);
 			} else {
 				Operators.onErrorDropped(ex);
 			}
@@ -159,7 +159,7 @@ void innerComplete(T value) {
 				if (sp != null) {
 					complete(sp.first);
 				} else {
-					subscriber.onComplete();
+					actual.onComplete();
 				}
 			}
 		}

File: src/main/java/reactor/core/publisher/RingBuffer.java
Patch:
@@ -38,6 +38,9 @@
  * Ring based store of reusable entries containing the data representing an event being exchanged between event producer
  * and ringbuffer consumers.
  * @param <E> implementation storing the data for sharing during exchange or parallel coordination of an event.
+ *
+ * This is an adaption of the original LMAX Disruptor RingBuffer code from
+ * https://lmax-exchange.github.io/disruptor/.
  */
 abstract class RingBuffer<E> implements LongSupplier {
 

File: src/test/java/reactor/core/publisher/tck/FluxAndProcessorTests.java
Patch:
@@ -66,8 +66,8 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 		                                                                   .doOnNext(this::monitorThreadUse))
 		                                      .doOnNext(array -> cumulatedJoin.getAndIncrement())
 		                                      .subscribeWith(TopicProcessor.create("fluxion-raw-join", bufferSize))
-		                                      .transform(Flux::from)
-		                                      .doOnError(Throwable::printStackTrace));
+		                                      .doOnError(Throwable::printStackTrace).awaitOnSubscribe())
+				;
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/FluxWithSchedulerTests.java
Patch:
@@ -66,7 +66,8 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				 )
 				 .publishOn(sharedGroup)
 				 .doAfterTerminate(asyncGroup::shutdown)
-				 .doOnError(Throwable::printStackTrace));
+				 .doOnError(Throwable::printStackTrace)
+				.awaitOnSubscribe());
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/SchedulerComputationTests.java
Patch:
@@ -39,7 +39,7 @@ public Processor<Long, Long> createProcessor(int bufferSize) {
 		EmitterProcessor<Long> e = EmitterProcessor.create();
 		return FluxProcessor.wrap(e,
 				e.publishOn(scheduler)
-				 .doAfterTerminate(scheduler::shutdown));
+				 .doAfterTerminate(scheduler::shutdown).awaitOnSubscribe());
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/SchedulerParallelTests.java
Patch:
@@ -43,7 +43,7 @@ public class SchedulerParallelTests extends AbstractProcessorVerification {
 	public Processor<Long, Long> createProcessor(int bufferSize) {
 		EmitterProcessor<Long> e = EmitterProcessor.create();
 		Scheduler s = Schedulers.newSingle("shared-async");
-		return FluxProcessor.wrap(e, e.publishOn(s).doOnComplete(s::shutdown));
+		return FluxProcessor.wrap(e, e.publishOn(s).doOnComplete(s::shutdown).awaitOnSubscribe());
 
 	}
 

File: src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -652,7 +652,7 @@ public void shutdown() {
 		 */
 		@Override
 		public Scheduler get() {
-			return null;
+			return cached;
 		}
 
 		void _shutdown() {

File: src/main/java/reactor/core/publisher/LambdaFirstSubscriber.java
Patch:
@@ -74,8 +74,6 @@ public final void onSubscribe(Subscription s) {
 		if (Operators.validate(subscription, s)) {
 			this.subscription = s;
 			try {
-				//note that unlike in RxJava 2.0.0 an error on accept doesn't trigger
-				// cancellation of s
 				if (subscriptionConsumer != null) {
 					subscriptionConsumer.accept(s);
 				}
@@ -85,6 +83,7 @@ public final void onSubscribe(Subscription s) {
 			}
 			catch (Throwable t) {
 				Exceptions.throwIfFatal(t);
+				s.cancel();
 				onError(t);
 			}
 		}

File: src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -74,8 +74,6 @@ public final void onSubscribe(Subscription s) {
 		if (Operators.validate(subscription, s)) {
 			this.subscription = s;
 			try {
-				//note that unlike in RxJava 2.0.0 an error on accept doesn't trigger
-				// cancellation of s
 				if (subscriptionConsumer != null) {
 					subscriptionConsumer.accept(s);
 				}
@@ -85,6 +83,7 @@ public final void onSubscribe(Subscription s) {
 			}
 			catch (Throwable t) {
 				Exceptions.throwIfFatal(t);
+				s.cancel();
 				onError(t);
 			}
 		}
@@ -142,6 +141,7 @@ public final void onNext(T x) {
 		}
 		catch (Throwable t) {
 			Exceptions.throwIfFatal(t);
+			this.subscription.cancel();
 			onError(t);
 		}
 	}

File: src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -257,7 +257,7 @@ public T poll() {
 					parent.onNextCall().accept(v);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, v));
+					throw Exceptions.propagate(Operators.onOperatorError(s, e, v));
 				}
 			}
 			if (v == null && sourceMode == SYNC) {
@@ -498,7 +498,7 @@ public T poll() {
 					parent.onNextCall().accept(v);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, v));
+					throw Exceptions.propagate(Operators.onOperatorError(s, e, v));
 				}
 			}
 			if (v == null && sourceMode == SYNC) {

File: src/main/java/reactor/core/publisher/FluxPeekFuseable.java
Patch:
@@ -257,7 +257,7 @@ public T poll() {
 					parent.onNextCall().accept(v);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, v));
+					throw Exceptions.propagate(Operators.onOperatorError(s, e, v));
 				}
 			}
 			if (v == null && sourceMode == SYNC) {
@@ -498,7 +498,7 @@ public T poll() {
 					parent.onNextCall().accept(v);
 				}
 				catch (Throwable e) {
-					onError(Operators.onOperatorError(s, e, v));
+					throw Exceptions.propagate(Operators.onOperatorError(s, e, v));
 				}
 			}
 			if (v == null && sourceMode == SYNC) {

File: src/main/java/reactor/adapter/package-info.java
Patch:
@@ -17,8 +17,9 @@
 /**
  * Adapt
  * {@link org.reactivestreams.Publisher} to Java 9+
- * {@link reactor.adapter.JdkFlowAdapter Flow.Publisher}, RxJava1
- * {@link reactor.adapter.RxJava1Adapter Observable, Completable and Single}.
+ * {@link reactor.adapter.JdkFlowAdapter Flow.Publisher}. More adapter can be found
+ * under http://github.com/reactor/reactor-addons/reactor-adapter including RxJava1 and
+ * RxJava2.
  *
  * @author Stephane Maldini
  */

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -89,7 +89,9 @@ public void onError(Throwable t) {
 					p = nextFactory.apply(t);
 				} catch (Throwable e) {
 					Throwable _e = Operators.onOperatorError(e);
-					_e.addSuppressed(t);
+					if(t != _e) {
+					  _e.addSuppressed(t);
+					}
 					subscriber.onError(_e);
 					return;
 				}

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -89,7 +89,9 @@ public void onError(Throwable t) {
 					p = nextFactory.apply(t);
 				} catch (Throwable e) {
 					Throwable _e = Operators.onOperatorError(e);
-					_e.addSuppressed(t);
+					if(t != _e) {
+					  _e.addSuppressed(t);
+					}
 					subscriber.onError(_e);
 					return;
 				}

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1606,7 +1606,8 @@ public final T blockLastMillis(long timeout) {
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/buffer.png"
 	 * alt="">
 	 *
-	 * @return a buffered {@link Mono} of at most one {@link List}
+	 * @return a buffered {@link Flux} of at most one {@link List}
+	 * @see #collectList() for an alternative collecting algorithm returning {@link Mono}
 	 */
     public final Flux<List<T>> buffer() {
 	    return buffer(Integer.MAX_VALUE);

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -108,7 +108,6 @@ public final void cancel() {
 				return;
 			}
 			if (STATE.compareAndSet(this, state, STATE_CANCELLED)) {
-				subscription = Operators.cancelledSubscription();
 				break;
 			}
 			state = this.state;

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1601,7 +1601,7 @@ public final T blockLastMillis(long timeout) {
 	}
 
 	/**
-	 * Collect incoming values into a {@link List} that will be pushed into the returned {@link Mono} on complete only.
+	 * Collect incoming values into a {@link List} that will be pushed into the returned {@link Flux} on complete only.
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/buffer.png"
 	 * alt="">

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1601,7 +1601,7 @@ public final T blockLastMillis(long timeout) {
 	}
 
 	/**
-	 * Collect incoming values into a {@link List} that will be pushed into the returned {@link Mono} on complete only.
+	 * Collect incoming values into a {@link List} that will be pushed into the returned {@link Flux} on complete only.
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/buffer.png"
 	 * alt="">

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1140,15 +1140,13 @@ public void fluxCreateDemoElasticScheduler() throws Exception {
 		Flux.create(
 				sink -> {
 					for (int i = 0; i < inputCount; i++) {
-						logger.info("Injecting {}", i);
 						sink.next(i);
 					}
 					sink.complete();
 				}).
 				    subscribeOn(Schedulers.newSingle("production")).
 				    publishOn(Schedulers.elastic()).
 				    subscribe(i -> {
-					    logger.info("Consuming {}", i);
 					    LockSupport.parkNanos(100L);
 					    latch.countDown();
 				    });

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4483,7 +4483,7 @@ public final Flux<T> sampleFirst(Duration timespan) {
 	 * @return a sampled {@link Flux} by last item observed when the sampler signals
 	 */
 	public final <U> Flux<T> sampleFirst(Function<? super T, ? extends Publisher<U>> samplerFactory) {
-		return onAssembly(new FluxThrottleFirst<>(this, samplerFactory));
+		return onAssembly(new FluxSampleFirst<>(this, samplerFactory));
 	}
 
 	/**
@@ -4530,7 +4530,7 @@ public final Flux<T> sampleMillis(long timespan) {
 	 * @return a sampled {@link Flux} by last single item observed before a companion {@link Publisher} emits
 	 */
 	public final <U> Flux<T> sampleTimeout(Function<? super T, ? extends Publisher<U>> throttlerFactory) {
-		return onAssembly(new FluxThrottleTimeout<>(this,
+		return onAssembly(new FluxSampleTimeout<>(this,
 				throttlerFactory,
 				QueueSupplier.unbounded(QueueSupplier.XS_BUFFER_SIZE)));
 	}
@@ -4556,7 +4556,7 @@ public final <U> Flux<T> sampleTimeout(Function<? super T, ? extends Publisher<U
 		if(maxConcurrency == Integer.MAX_VALUE){
 			return sampleTimeout(throttlerFactory);
 		}
-		return onAssembly(new FluxThrottleTimeout<>(this, throttlerFactory,
+		return onAssembly(new FluxSampleTimeout<>(this, throttlerFactory,
 				QueueSupplier.get(maxConcurrency)));
 	}
 

File: src/main/java/reactor/core/publisher/FluxSampleFirst.java
Patch:
@@ -37,11 +37,11 @@
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxThrottleFirst<T, U> extends FluxSource<T, T> {
+final class FluxSampleFirst<T, U> extends FluxSource<T, T> {
 
 	final Function<? super T, ? extends Publisher<U>> throttler;
 
-	public FluxThrottleFirst(Publisher<? extends T> source,
+	public FluxSampleFirst(Publisher<? extends T> source,
 			Function<? super T, ? extends Publisher<U>> throttler) {
 		super(source);
 		this.throttler = Objects.requireNonNull(throttler, "throttler");

File: src/main/java/reactor/core/publisher/FluxSampleTimeout.java
Patch:
@@ -39,13 +39,13 @@
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxThrottleTimeout<T, U> extends FluxSource<T, T> {
+final class FluxSampleTimeout<T, U> extends FluxSource<T, T> {
 
 	final Function<? super T, ? extends Publisher<U>> throttler;
 	
 	final Supplier<Queue<Object>> queueSupplier;
 
-	public FluxThrottleTimeout(Publisher<? extends T> source,
+	public FluxSampleTimeout(Publisher<? extends T> source,
 			Function<? super T, ? extends Publisher<U>> throttler,
 					Supplier<Queue<Object>> queueSupplier) {
 		super(source);

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -166,7 +166,6 @@ public void onComplete() {
 		@Override
 		public void request(long n) {
 			if (Operators.validate(n)) {
-				Operators.getAndAddCap(REQUESTED, this, n);
 				Subscription s = S.get(this);
 				if (s != null) {
 					requestUpstream(n, s);

File: src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import reactor.core.Cancellation;
-import reactor.core.publisher.Operators;
 import reactor.util.concurrent.OpenHashSet;
 
 /**
@@ -155,7 +154,7 @@ public void run() {
 				try {
 					task.run();
 				} catch (Throwable e) {
-					Operators.onErrorDropped(e);
+					Schedulers.handleError(e);
 				}
 			} finally {
 				for (;;) {

File: src/main/java/reactor/core/publisher/FluxOnBackpressureBuffer.java
Patch:
@@ -34,14 +34,14 @@
 /**
  * @author Stephane Maldini
  */
-final class FluxBackpressureBuffer<O> extends FluxSource<O, O> implements Fuseable {
+final class FluxOnBackpressureBuffer<O> extends FluxSource<O, O> implements Fuseable {
 
 	final Consumer<? super O> onOverflow;
 	final int                 bufferSize;
 	final boolean             unbounded;
 	final boolean             delayError;
 
-	public FluxBackpressureBuffer(Publisher<? extends O> source,
+	public FluxOnBackpressureBuffer(Publisher<? extends O> source,
 			int bufferSize,
 			boolean unbounded,
 			Consumer<? super O> onOverflow) {

File: src/main/java/reactor/core/publisher/FluxOnBackpressureLatest.java
Patch:
@@ -36,9 +36,9 @@
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxLatest<T> extends FluxSource<T, T> {
+final class FluxOnBackpressureLatest<T> extends FluxSource<T, T> {
 
-	public FluxLatest(Publisher<? extends T> source) {
+	public FluxOnBackpressureLatest(Publisher<? extends T> source) {
 		super(source);
 	}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4685,7 +4685,7 @@ public final Mono<T> single() {
 		    Callable<T> thiz = (Callable<T>)this;
 		    return Mono.onAssembly(new MonoCallable<>(thiz));
 	    }
-		return Mono.onAssembly(new MonoSingle<>(this, null, false));
+		return Mono.onAssembly(new MonoSingle<>(this));
 	}
 
 	/**
@@ -4708,7 +4708,7 @@ public final Mono<T> single(T defaultValue) {
 
                 T v = scalarCallable.call();
                 if (v == null) {
-	                return Mono.empty();
+	                return Mono.just(defaultValue);
                 }
                 return Mono.just(v);
             }

File: src/main/java/reactor/core/publisher/FluxTakeLastOne.java
Patch:
@@ -36,7 +36,7 @@ public FluxTakeLastOne(Publisher<? extends T> source) {
 
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		source.subscribe(new MonoTakeLastOne.TakeLastOneSubscriber<>(s, false));
+		source.subscribe(new MonoTakeLastOne.TakeLastOneSubscriber<>(s, null, false));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -51,7 +51,7 @@
  * @author Stephane Maldini
  */
 final class FluxJust<T> extends Flux<T> implements Fuseable.ScalarCallable<T>, Fuseable,
-		Loopback {
+		Receiver {
 
 	final T value;
 
@@ -75,7 +75,7 @@ public void subscribe(final Subscriber<? super T> subscriber) {
 	}
 
 	@Override
-	public Object connectedOutput() {
+	public Object upstream() {
 		return value;
 	}
 

File: src/main/java/reactor/core/publisher/FluxSource.java
Patch:
@@ -62,7 +62,8 @@ public void subscribe(Subscriber<? super O> s) {
 	@Override
 	public String toString() {
 		return "{" +
-				" operator : \"" + super.toString() + "\" " +
+				" operator : \"" + getClass().getSimpleName().replaceAll("Flux","") + "\"" +
+				" " +
 				'}';
 	}
 

File: src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -69,7 +69,8 @@ public void subscribe(Subscriber<? super O> s) {
 	@Override
 	public String toString() {
 		return "{" +
-				" operator : \"" + super.toString() + "\" " +
+				" operator : \"" + getClass().getSimpleName().replaceAll("Mono","") +
+				"\" " +
 				'}';
 	}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -524,7 +524,7 @@ public static <T> Flux<T> concatDelayError(Publisher<? extends T>... sources) {
      * @return a {@link Flux}
      */
     public static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter) {
-	    return onAssembly(new FluxCreate<>(emitter, OverflowStrategy.BUFFER));
+	    return create(emitter, OverflowStrategy.BUFFER);
     }
 
 	/**

File: src/test/java/reactor/core/publisher/FluxYieldTest.java
Patch:
@@ -28,10 +28,12 @@ public void yieldSome() {
         TestSubscriber<Integer> ts = TestSubscriber.create();
         
         Flux<Integer> source = Flux.<Signal<Integer>>create(e -> {
-            e.next(Signal.next(1));
+            e.serialize().next(Signal.next(1));
             e.next(Signal.next(2));
             e.next(Signal.next(3));
             e.next(Signal.complete());
+            System.out.println(e.isCancelled());
+            System.out.println(e.requestedFromDownstream());
         }).dematerialize();
         
         source.subscribe(ts);

File: src/test/java/reactor/core/publisher/tck/FluxAndProcessorTests.java
Patch:
@@ -56,7 +56,6 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                                      next) -> next)
 		                                                                   .map(integer -> -integer)
 		                                                                   .filter(integer -> integer <= 0)
-		                                                                   .every(1)
 		                                                                   .map(integer -> -integer)
 		                                                                   .buffer(batch, Duration.ofMillis(50))
 		                                                                   .flatMap(Flux::fromIterable)

File: src/test/java/reactor/core/publisher/tck/FluxWithSchedulerTests.java
Patch:
@@ -59,7 +59,6 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                          .scan((prev, next) -> next)
 				                          .map(integer -> -integer)
 				                          .filter(integer -> integer <= 0)
-				                          .every(1)
 				                          .map(integer -> -integer)
 				                          .buffer(batch, Duration.ofMillis(50))
 				                          .flatMap(Flux::fromIterable)

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -110,7 +110,7 @@ static Runnable createRequestTask(Subscription upstream,
 
 	/**
 	 * Create a new single producer RingBuffer using the default wait strategy  {@link
-	 * WaitStrategy#busySpin()}. <p>See {@code MultiProducer}.
+	 * WaitStrategy#busySpin()}. <p>See {@code MultiProducerRingBuffer}.
 	 *
 	 * @param <E> the element type
 	 * @param bufferSize number of elements to create within the ring buffer.

File: src/main/java/reactor/util/concurrent/QueueSupplier.java
Patch:
@@ -74,7 +74,7 @@ public static <T> Supplier<Queue<T>> get(int batchSize) {
 		if (batchSize == 1) {
 			return ONE_SUPPLIER;
 		}
-		return new QueueSupplier<>(batchSize);
+		return new QueueSupplier<>(Math.max(8, batchSize));
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5181,6 +5181,9 @@ public final Flux<T> take(Duration timespan) {
 	 *
 	 */
 	public final Flux<T> takeLast(int n) {
+		if(n == 1){
+			return onAssembly(new FluxTakeLastOne<>(this));
+		}
 		return onAssembly(new FluxTakeLast<>(this, n));
 	}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -5181,9 +5181,6 @@ public final Flux<T> take(Duration timespan) {
 	 *
 	 */
 	public final Flux<T> takeLast(int n) {
-		if(n == 1){
-			return onAssembly(new FluxTakeLastOne<>(this));
-		}
 		return onAssembly(new FluxTakeLast<>(this, n));
 	}
 

File: src/main/java/reactor/core/publisher/FluxTakeLast.java
Patch:
@@ -54,7 +54,7 @@ public void subscribe(Subscriber<? super T> s) {
 		if (n == 0) {
 			source.subscribe(new TakeLastZeroSubscriber<>(s));
 		} else if (n == 1) {
-			source.subscribe(new TakeLastOneSubscriber<>(s));
+			source.subscribe(new TakeLastOneSubscriber<>(s, false));
 		} else {
 			source.subscribe(new TakeLastManySubscriber<>(s, n));
 		}

File: src/test/java/reactor/core/publisher/tck/FluxWithSchedulerTests.java
Patch:
@@ -182,7 +182,7 @@ public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferenc
 		AbstractFluxVerification s = new FluxWithSchedulerTests();
 		Processor p = s.createProcessor(256);
 		BlockingSink sess = BlockingSink.create(p);
-		p.subscribe(Subscribers.unbounded());
+		p.subscribe();
 		Nexus nexus = Nexus.create.withSystemStats();
 		nexus.monitor(p);
 		nexus.startAndAwait();

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2531,7 +2531,9 @@ public final Flux<T> concatWith(Publisher<? extends T> other) {
 
 			return fluxConcatArray.concatAdditionalSourceLast(other);
 		}
-		return onAssembly(new FluxConcatArray<>(false, this, other));
+		@SuppressWarnings({ "unchecked" })
+		Flux<T> concat = new FluxConcatArray<>(false, this, other);
+		return onAssembly(concat);
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -319,11 +319,11 @@ public final OperatorHook<T> ifNameContains(String... names){
 		 * @return a logging {@link OperatorHook}
 		 */
 		public OperatorHook<T> log(String category, Level level, SignalType... options){
-			if(this == IGNORE) return this;
 			Objects.requireNonNull(level, "level");
-			SignalLogger peek = new SignalLogger<>(publisher, category, level, options);
+			SignalLogger peek = new SignalLogger<>(publisher, category, level, false,
+					options);
 			return doOnSignal(peek.onSubscribeCall(), peek.onNextCall(), peek
-					.onErrorCall(), peek.onCompleteCall(), peek.onAfterTerminateCall(),
+							.onErrorCall(), peek.onCompleteCall(), peek.onAfterTerminateCall(),
 					peek.onRequestCall(), peek.onCancelCall());
 		}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4489,8 +4489,8 @@ public final Mono<T> single() {
                 return Mono.just(v);
 	        }
 		    @SuppressWarnings("unchecked")
-		    Callable<T> thiz = (Callable<T>)this)
-		    return Mono.onAssembly(new MonoCallable<>(thiz);
+		    Callable<T> thiz = (Callable<T>)this;
+		    return Mono.onAssembly(new MonoCallable<>(thiz));
 	    }
 		return Mono.onAssembly(new MonoSingle<>(this));
 	}
@@ -4520,7 +4520,7 @@ public final Mono<T> singleOrDefault(Supplier<? extends T> defaultSupplier) {
                 return Mono.just(v);
             }
 	        @SuppressWarnings("unchecked")
-	        Callable<T> thiz = (Callable<T>)this)
+	        Callable<T> thiz = (Callable<T>)this;
 	        return Mono.onAssembly(new MonoCallable<>(thiz));
         }
 		return Mono.onAssembly(new MonoSingle<>(this, defaultSupplier));

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1570,7 +1570,7 @@ public final Flux<T> flux() {
 	            return Flux.just(v);
 	        }
 		    @SuppressWarnings("unchecked") Callable<T> thiz = (Callable<T>) this;
-		    return Flux.onAssembly(new FluxCallable<>(thiz);
+		    return Flux.onAssembly(new FluxCallable<>(thiz));
 	    }
 		return FluxSource.wrap(this);
 	}
@@ -1781,7 +1781,7 @@ public final Mono<T> mapError(Function<Throwable, ? extends Throwable> mapper) {
 	public final <E extends Throwable> Mono<T> mapError(Class<E> type,
 			Function<? super E, ? extends Throwable> mapper) {
 		@SuppressWarnings("unchecked")
-		Function<Throwable, Throwable> handler = (Function<Throwable, Throwable>)mapper
+		Function<Throwable, Throwable> handler = (Function<Throwable, Throwable>)mapper;
 		return mapError(type::isInstance, handler);
 	}
 

File: src/main/java/reactor/util/function/Tuples.java
Patch:
@@ -199,7 +199,7 @@ public static <T1, T2, T3, T4, T5, T6, T7, T8> Tuple8<T1, T2, T3, T4, T5, T6, T7
 	 * @return The unchecked conversion function to {@link Tuples}.
 	 */
 	@SuppressWarnings("unchecked")
-	public static Function<Object[], Tuples> fnAny() {
+	public static Function<Object[], Tuple2> fnAny() {
 		return empty;
 	}
 
@@ -211,7 +211,7 @@ public static Function<Object[], Tuples> fnAny() {
 	 *
 	 * @return The unchecked conversion function to R.
 	 */
-	public static <R> Function<Object[], R> fnAny(final Function<Tuples, R> delegate) {
+	public static <R> Function<Object[], R> fnAny(final Function<Tuple2, R> delegate) {
 		return objects -> delegate.apply(Tuples.fnAny().apply(objects));
 	}
 

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -186,6 +186,7 @@ else if(subscription == null) {
 			}
 		}
 		catch (InterruptedException ie) {
+			System.out.println("---------");
 			Thread.currentThread().interrupt();
 
 			throw new IllegalStateException("Thread Interruption on Mono blocking read");

File: src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -132,7 +132,7 @@ ExecutorService pick() {
     public Cancellation schedule(Runnable task) {
         ExecutorService exec = pick();
         Future<?> f = exec.submit(task);
-        return () -> f.cancel(true);
+        return () -> f.cancel(false);
     }
 
     @Override
@@ -290,7 +290,7 @@ public void dispose() {
                         f = FUTURE.getAndSet(this, CANCELLED);
                         if (f != CANCELLED && f != FINISHED) {
                             if (f != null) {
-                                f.cancel(true);
+                                f.cancel(parent.shutdown);
                             }
                             
                             parent.remove(this);
@@ -302,7 +302,7 @@ public void dispose() {
             void setFuture(Future<?> f) {
                 if (future != null || !FUTURE.compareAndSet(this, null, f)) {
                     if (future != FINISHED) {
-                        f.cancel(true);
+                        f.cancel(false);
                     }
                 }
             }

File: src/main/java/reactor/core/publisher/FluxOnAssembly.java
Patch:
@@ -111,6 +111,9 @@ static String takeStacktrace(Publisher<?> source) {
 				if (row.contains("reactor.core.publisher.Mono.onAssembly")) {
 					continue;
 				}
+				if (row.contains("reactor.core.publisher.ParallelFlux.onAssembly")) {
+					continue;
+				}
 				if (row.contains("reactor.core.publisher.SignalLogger")) {
 					continue;
 				}

File: src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -126,6 +126,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
+				Operators.onNextDropped(t);
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/ParallelReduce.java
Patch:
@@ -124,6 +124,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
+				Operators.onNextDropped(t);
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/ParallelReduceFull.java
Patch:
@@ -194,6 +194,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
+				Operators.onNextDropped(t);
 				return;
 			}
 			T v = value;

File: src/main/java/reactor/core/publisher/ParallelUnorderedJoin.java
Patch:
@@ -164,7 +164,9 @@ void onError(Throwable e) {
 		}
 		
 		void onComplete() {
-			DONE.decrementAndGet(this);
+			if(DONE.decrementAndGet(this) < 0){
+				return;
+			}
 			drain();
 		}
 		

File: src/main/java/reactor/core/publisher/ParallelReduce.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T> the input value type
  * @param <R> the result value type
  */
-final class ParallelReduce<T, R> extends ParallelFlux<R> implements Fuseable{
+final class ParallelReduce<T, R> extends ParallelFlux<R> implements Fuseable {
 	
 	final ParallelFlux<? extends T> source;
 	

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -113,7 +113,7 @@ public void verboseExtension() {
 
 		q.clear();
 
-		Hooks.onOperator(hooks -> hooks.log("reactor.", Level.INFO)
+		Hooks.onOperator(hooks -> hooks.log("reactor", Level.INFO, true)
 		                               .doOnEach(d -> q.offer(hooks.publisher() + ": " + d),
 				                               t -> q.offer(hooks.publisher() + "! " +
 						                               (t.getSuppressed().length != 0)),

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -168,7 +168,7 @@ public void testTrace() throws Exception {
 
 	@Test
 	public void testTrace2() throws Exception {
-		Hooks.onOperator(hooks -> hooks.ifName("map")
+		Hooks.onOperator(hooks -> hooks.ifName("map", "filter")
 		                               .operatorStacktrace());
 		try {
 			Mono.just(1)

File: src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -278,6 +278,7 @@ public final OperatorHook<T> ifNameContains(String name){
 		 * @return a logging {@link OperatorHook}
 		 */
 		public OperatorHook<T> log(String category, Level level, SignalType... options){
+			if(this == IGNORE) return this;
 			SignalLogger peek = new SignalLogger<>(publisher, category, level, options);
 			return doOnSignal(peek.onSubscribeCall(), peek.onNextCall(), peek
 					.onErrorCall(), peek.onCompleteCall(), peek.onAfterTerminateCall(),

File: src/main/java/reactor/core/publisher/Hooks.java
Patch:
@@ -270,7 +270,8 @@ public final OperatorHook<T> ifNameContains(String name){
 		 * alt="">
 		 *
 		 * @param category to be mapped into logger configuration (e.g.
-		 * org.springframework.reactor).
+		 * org.springframework.reactor). If category is null, empty or ends with "." like
+		 * "reactor.", a generated operator suffix will complete, e.g. "reactor.Flux.Map".
 		 * @param level the level to enforce for this tracing Flux
 		 * @param options a vararg {@link SignalType} option to filter log messages
 		 *

File: src/main/java/reactor/core/publisher/SignalLogger.java
Patch:
@@ -65,7 +65,7 @@ public SignalLogger(Publisher<IN> source, String category, Level level,
 
 		boolean generated = category == null || category.isEmpty() || category.endsWith(".");
 
-		category = generated && category == null ? "" : category;
+		category = generated && category == null ? "reactor." : category;
 		if (generated) {
 			if (source instanceof Mono) {
 				category += "Mono." + source.getClass()

File: src/test/java/reactor/HooksTest.java
Patch:
@@ -113,7 +113,7 @@ public void verboseExtension() {
 
 		q.clear();
 
-		Hooks.onOperator(hooks -> hooks.log("", Level.INFO)
+		Hooks.onOperator(hooks -> hooks.log("reactor", Level.INFO)
 		                               .doOnEach(d -> q.offer(hooks.publisher() + ": " + d),
 				                               t -> q.offer(hooks.publisher() + "! " +
 						                               (t.getSuppressed().length != 0)),
@@ -130,7 +130,7 @@ public void verboseExtension() {
 
 		q.clear();
 
-		Hooks.onOperator(hooks -> hooks.log("", Level.INFO));
+		Hooks.onOperator(hooks -> hooks.log("reactor", Level.INFO));
 
 		simpleFlux();
 

File: src/main/java/reactor/core/Exceptions.java
Patch:
@@ -186,7 +186,6 @@ public static <T> Throwable terminate(AtomicReferenceFieldUpdater<T, Throwable>
 	 * varieties are as follows:
 	 * <ul>
 	 * <li>{@code BubblingException}</li>
-	 * <li>{@code StackOverflowError}</li>
 	 * <li>{@code VirtualMachineError}</li>
 	 * <li>{@code ThreadDeath}</li>
 	 * <li>{@code LinkageError}</li>
@@ -197,8 +196,6 @@ public static <T> Throwable terminate(AtomicReferenceFieldUpdater<T, Throwable>
 	public static void throwIfFatal(Throwable t) {
 		if (t instanceof BubblingException) {
 			throw (BubblingException) t;
-		} else if (t instanceof StackOverflowError) {
-			throw (StackOverflowError) t;
 		} else if (t instanceof VirtualMachineError) {
 			throw (VirtualMachineError) t;
 		} else if (t instanceof ThreadDeath) {

File: src/main/java/reactor/adapter/RxJava1Adapter.java
Patch:
@@ -313,7 +313,7 @@ public void onSubscribe(Subscription s) {
 			@Override
 			public void onNext(T t) {
 				if (done) {
-					Exceptions.onNextDropped(t);
+					Operators.onNextDropped(t);
 					return;
 				}
 
@@ -335,7 +335,7 @@ public void onNext(T t) {
 			@Override
 			public void onError(Throwable t) {
 				if (done) {
-					Exceptions.onErrorDropped(t);
+					Operators.onErrorDropped(t);
 					return;
 				}
 				done = true;

File: src/main/java/reactor/core/publisher/BlockingSink.java
Patch:
@@ -160,7 +160,7 @@ public void next(E t) {
 			return;
 		}
 		if(emission.isCancelled()){
-			Exceptions.onNextDropped(t);
+			Operators.onNextDropped(t);
 			return;
 		}
 		if(getError() != null){

File: src/main/java/reactor/core/publisher/ConnectableFluxProcess.java
Patch:
@@ -32,7 +32,6 @@
 import reactor.core.Producer;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
-import reactor.core.Exceptions;
 
 /**
  * @param <T>
@@ -167,7 +166,7 @@ boolean tryConnect() {
 		@Override
 		public void onNext(T t) {
 			if(isTerminated()){
-				Exceptions.onNextDropped(t);
+				Operators.onNextDropped(t);
 				return;
 			}
 			processor.onNext(t);
@@ -179,7 +178,7 @@ public void onError(Throwable t) {
 				processor.onError(t);
 			}
 			else {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 			}
 		}
 

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -315,7 +315,7 @@ public void onError(Throwable t) {
 			throw Exceptions.argumentIsNullException();
 		}
 		if (autoCancel && done) {
-			Exceptions.onErrorDropped(t);
+			Operators.onErrorDropped(t);
 		}
 		reportError(t);
 		done = true;
@@ -344,7 +344,7 @@ public void onSubscribe(final Subscription s) {
 				}
 			}
 			catch (Throwable t) {
-				onError(Exceptions.onOperatorError(s, t));
+				onError(Operators.onOperatorError(s, t));
 			}
 		}
 	}

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -461,7 +461,7 @@ final public void onSubscribe(final Subscription s) {
 				}
 			}
 			catch (Throwable t) {
-				onError(Exceptions.onOperatorError(s, t));
+				onError(Operators.onOperatorError(s, t));
 			}
 		}
 	}
@@ -476,7 +476,7 @@ public final void shutdown() {
 			executor.shutdown();
 		}
 		catch (Throwable t) {
-			onError(Exceptions.onOperatorError(t));
+			onError(Operators.onOperatorError(t));
 		}
 	}
 
@@ -572,7 +572,7 @@ public void run() {
 				if(WaitStrategy.isAlert(t)){
 					return;
 				}
-				errorSubscriber.onError(Exceptions.onOperatorError(t));
+				errorSubscriber.onError(Operators.onOperatorError(t));
 			}
 		}
 	}

File: src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.concurrent.Callable;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 
 /**
  * For each subscriber, a Supplier is invoked and the returned value emitted.
@@ -43,7 +42,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             v = callable.call();
         } catch (Throwable ex) {
-            s.onError(Exceptions.onOperatorError(ex));
+            s.onError(Operators.onOperatorError(ex));
             return;
         }
         

File: src/main/java/reactor/core/publisher/FluxConcatArray.java
Patch:
@@ -239,7 +239,7 @@ public void onError(Throwable t) {
 			if (Exceptions.addThrowable(ERROR, this, t)) {
 				onComplete();
 			} else {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 			}
 		}
 

File: src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Receiver;
 
 /**
@@ -53,13 +52,13 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = supplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
 			Operators.error(s,
-					Exceptions.onOperatorError(new NullPointerException(
+					Operators.onOperatorError(new NullPointerException(
 							"The Producer returned by the supplier is null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxDelaySubscription.java
Patch:
@@ -20,7 +20,6 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Exceptions;
 
 /**
  * Delays the subscription to the main source until another Publisher
@@ -97,7 +96,7 @@ public void onNext(U t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 				return;
 			}
 			done = true;

File: src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -22,7 +22,6 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.publisher.FluxDistinct.DistinctFuseableSubscriber;
 
@@ -59,12 +58,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			collection = collectionSupplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 
 		if (collection == null) {
-			Operators.error(s, Exceptions.onOperatorError(new
+			Operators.error(s, Operators.onOperatorError(new
 					NullPointerException("The collectionSupplier returned a null collection")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Exceptions;
 import reactor.core.Trackable;
 
 /**
@@ -76,7 +75,7 @@ public void subscribe(Subscriber<? super T> s) {
 		if (whenRequested) {
 			s.onSubscribe(new ErrorSubscription(s, e));
 		} else {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 		}
 	}
 	

File: src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Producer;
 import reactor.core.Receiver;
@@ -53,7 +52,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			it = iterable.iterator();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 
@@ -82,7 +81,7 @@ static <T> void subscribe(Subscriber<? super T> s, Iterator<? extends T> it) {
 		try {
 			b = it.hasNext();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 		if (!b) {

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -23,7 +23,6 @@
 import reactor.core.Loopback;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
-import reactor.core.Exceptions;
 
 /**
  * A Stream that emits only one value and then complete.
@@ -71,7 +70,7 @@ public void subscribe(final Subscriber<? super T> subscriber) {
 			subscriber.onSubscribe(new WeakScalarSubscription<>(value, subscriber));
 		}
 		catch (Throwable throwable) {
-			subscriber.onError(Exceptions.onOperatorError(throwable));
+			subscriber.onError(Operators.onOperatorError(throwable));
 		}
 	}
 

File: src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 
 /**
  * Repeatedly subscribes to the source if the predicate returns true after
@@ -89,7 +88,7 @@ public void onComplete() {
 			try {
 				b = predicate.getAsBoolean();
 			} catch (Throwable e) {
-				subscriber.onError(Exceptions.onOperatorError(e));
+				subscriber.onError(Operators.onOperatorError(e));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Loopback;
-import reactor.core.Exceptions;
 
 /**
  * Repeats a source when a companion sequence
@@ -68,12 +67,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = whenSourceFactory.apply(other);
 		} catch (Throwable e) {
-			s.onError(Exceptions.onOperatorError(e));
+			s.onError(Operators.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
-			s.onError(Exceptions.onOperatorError(new NullPointerException("The " +
+			s.onError(Operators.onOperatorError(new NullPointerException("The " +
 					"whenSourceFactory returned a null Publisher")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Loopback;
-import reactor.core.Exceptions;
 
 /**
  * Resumes the failed main sequence with another sequence returned by
@@ -89,7 +88,7 @@ public void onError(Throwable t) {
 				try {
 					p = nextFactory.apply(t);
 				} catch (Throwable e) {
-					Throwable _e = Exceptions.onOperatorError(e);
+					Throwable _e = Operators.onOperatorError(e);
 					_e.addSuppressed(t);
 					subscriber.onError(_e);
 					return;

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 
 /**
  * Repeatedly subscribes to the source if the predicate returns true after
@@ -89,7 +88,7 @@ public void onError(Throwable t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				Throwable _t = Exceptions.onOperatorError(e);
+				Throwable _t = Operators.onOperatorError(e);
 				_t.addSuppressed(t);
 				subscriber.onError(_t);
 				return;

File: src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Loopback;
-import reactor.core.Exceptions;
 
 /**
  * retries a source when a companion sequence signals
@@ -71,12 +70,12 @@ static <T> void subscribe(Subscriber<? super T> s, Function<? super
 			p = whenSourceFactory.apply(other);
 		}
 		catch (Throwable e) {
-			s.onError(Exceptions.onOperatorError(e));
+			s.onError(Operators.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
-			s.onError(Exceptions.onOperatorError(new NullPointerException(
+			s.onError(Operators.onOperatorError(new NullPointerException(
 					"The whenSourceFactory returned a null Publisher")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.stream.Stream;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Receiver;
 
 /**
@@ -53,7 +52,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			it = stream.iterator();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -27,7 +27,6 @@
 import reactor.core.Producer;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
-import reactor.core.Exceptions;
 
 /**
  * Subscribes to the source Publisher asynchronously through a scheduler function or
@@ -62,12 +61,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			worker = scheduler.createWorker();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 		
 		if (worker == null) {
-			Operators.error(s, Exceptions.onOperatorError(new
+			Operators.error(s, Operators.onOperatorError(new
 					NullPointerException("The scheduler returned a null Function")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -25,7 +25,6 @@
 import reactor.core.Cancellation;
 import reactor.core.Fuseable;
 import reactor.core.scheduler.Scheduler;
-import reactor.core.Exceptions;
 
 /**
  * Executes a Callable and emits its value on the given Scheduler.
@@ -208,7 +207,7 @@ public void run() {
 				v = callable.call();
 			}
 			catch (Throwable ex) {
-				actual.onError(Exceptions.onOperatorError(this, ex));
+				actual.onError(Operators.onOperatorError(this, ex));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/FluxThrottleFirst.java
Patch:
@@ -142,7 +142,7 @@ public void onNext(T t) {
 					p = throttler.apply(t);
 				} catch (Throwable e) {
 					Operators.terminate(S, this);
-					error(Exceptions.onOperatorError(null, e, t));
+					error(Operators.onOperatorError(null, e, t));
 					return;
 				}
 				
@@ -176,7 +176,7 @@ void error(Throwable e) {
 					handleTermination();
 				}
 			} else {
-				Exceptions.onErrorDropped(e);
+				Operators.onErrorDropped(e);
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/FluxWindowOnCancel.java
Patch:
@@ -31,7 +31,6 @@
 import reactor.core.Producer;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
-import reactor.core.Exceptions;
 
 /**
  * Splits the source sequence into possibly overlapping publishers.
@@ -100,7 +99,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Exceptions.onNextDropped(t);
+				Operators.onNextDropped(t);
 				return;
 			}
 
@@ -142,7 +141,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 				return;
 			}
 			Processor<T, T> w = window;

File: src/main/java/reactor/core/publisher/LambdaSubscriber.java
Patch:
@@ -123,7 +123,7 @@ public final void onError(Throwable t) {
 			errorConsumer.accept(t);
 		}
 		else {
-			Exceptions.onErrorDropped(t);
+			Operators.onErrorDropped(t);
 		}
 	}
 

File: src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.Exceptions;
 
 /**
  * Emits a single boolean true if all values of the source sequence match
@@ -94,7 +93,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				subscriber.onError(Exceptions.onOperatorError(s, e, t));
+				subscriber.onError(Operators.onOperatorError(s, e, t));
 				return;
 			}
 			if (!b) {
@@ -108,7 +107,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 				return;
 			}
 			done = true;

File: src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.Exceptions;
 
 /**
  * Emits a single boolean true if any of the values of the source sequence match
@@ -95,7 +94,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				subscriber.onError(Exceptions.onOperatorError(s, e, t));
+				subscriber.onError(Operators.onOperatorError(s, e, t));
 				return;
 			}
 			if (b) {
@@ -109,7 +108,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 				return;
 			}
 			done = true;

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -65,12 +65,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = callable.call();
 		} catch (Throwable e) {
-			s.onError(Exceptions.onOperatorError(e));
+			s.onError(Operators.onOperatorError(e));
 			return;
 		}
 
 		if (t == null) {
-			s.onError(Exceptions.onOperatorError(new NullPointerException("The " +
+			s.onError(Operators.onOperatorError(new NullPointerException("The " +
 					"callable returned null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 
 /**
@@ -48,12 +47,12 @@ public void subscribe(Subscriber<? super C> s) {
         try {
             collection = collectionSupplier.get();
         } catch (Throwable ex) {
-            Operators.error(s, Exceptions.onOperatorError(ex));
+            Operators.error(s, Operators.onOperatorError(ex));
             return;
         }
         
         if (collection == null) {
-            Operators.error(s, Exceptions.onOperatorError(new NullPointerException
+            Operators.error(s, Operators.onOperatorError(new NullPointerException
                     ("The " +
                     "collectionSupplier " +
                     "returned a null collection")));

File: src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -21,7 +21,6 @@
 import org.reactivestreams.*;
 
 import reactor.core.Cancellation;
-import reactor.core.Exceptions;
 
 /**
  * Wraps a the downstream Subscriber into a single emission object
@@ -46,7 +45,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             callback.accept(emitter);
         } catch (Throwable ex) {
-            emitter.error(Exceptions.onOperatorError(ex));
+            emitter.error(Operators.onOperatorError(ex));
         }
     }
 
@@ -112,7 +111,7 @@ public void error(Throwable e) {
                 cancellation = CANCELLED;
                 actual.onError(e);
             } else {
-                Exceptions.onErrorDropped(e);
+                Operators.onErrorDropped(e);
             }
         }
 

File: src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 import reactor.core.Receiver;
 
 /**
@@ -54,12 +53,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = supplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.onOperatorError(e));
+			Operators.error(s, Operators.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
-			Operators.error(s, Exceptions.onOperatorError(new
+			Operators.error(s, Operators.onOperatorError(new
 					NullPointerException("The Producer returned by the supplier is null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -23,7 +23,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Cancellation;
 import reactor.core.scheduler.TimedScheduler;
-import reactor.core.Exceptions;
 
 /**
  * Emits a single 0L value delayed by some time amount with a help of
@@ -92,7 +91,7 @@ public void run() {
 				}
 				}
 				catch (Throwable t){
-					s.onError(Exceptions.onOperatorError(t));
+					s.onError(Operators.onOperatorError(t));
 				}
 			} else {
 				s.onError(new IllegalStateException("Could not emit value due to lack of requests"));

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -72,7 +72,7 @@ public void subscribe(Subscriber<? super T> s) {
 			e = new NullPointerException("The Throwable returned by the supplier is null");
 		}
 
-		Operators.error(s, Exceptions.onOperatorError(e));
+		Operators.error(s, Operators.onOperatorError(e));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -23,7 +23,6 @@
 import reactor.core.Producer;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
-import reactor.core.Exceptions;
 
 /**
  * Emits a single item at most from the source.
@@ -74,7 +73,7 @@ public void onSubscribe(Subscription s) {
 		@Override
 		public void onNext(T t) {
 			if (done) {
-				Exceptions.onNextDropped(t);
+				Operators.onNextDropped(t);
 				return;
 			}
 
@@ -86,7 +85,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 				return;
 			}
 			done = true;

File: src/main/java/reactor/core/publisher/MonoPeek.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoPeek<T> extends MonoSource<T, T> implements Operators.SignalObserver<T> {
+final class MonoPeek<T> extends MonoSource<T, T> implements SignalPeek<T> {
 
 	final Consumer<? super Subscription> onSubscribeCall;
 
@@ -54,7 +54,7 @@ final class MonoPeek<T> extends MonoSource<T, T> implements Operators.SignalObse
 
 	final Runnable onCancelCall;
 
-	public MonoPeek(Publisher<? extends T> source, Operators.SignalObserver<T> peekHelper) {
+	public MonoPeek(Publisher<? extends T> source, SignalPeek<T> peekHelper) {
 		this(source,
 				peekHelper.onSubscribeCall(),
 				peekHelper.onNextCall(),

File: src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -35,7 +35,7 @@
  *
  */
 final class MonoPeekFuseable<T> extends MonoSource<T, T>
-		implements Fuseable, Operators.SignalObserver<T> {
+		implements Fuseable, SignalPeek<T> {
 
 	final Consumer<? super Subscription> onSubscribeCall;
 
@@ -51,7 +51,7 @@ final class MonoPeekFuseable<T> extends MonoSource<T, T>
 
 	final Runnable onCancelCall;
 
-	public MonoPeekFuseable(Publisher<? extends T> source, Operators.SignalObserver<T> peekHelper) {
+	public MonoPeekFuseable(Publisher<? extends T> source, SignalPeek<T> peekHelper) {
 		this(source,
 				peekHelper.onSubscribeCall(),
 				peekHelper.onNextCall(),

File: src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.Objects;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Exceptions;
 
 /**
  * Executes the runnable whenever a Subscriber subscribes to this Mono.
@@ -37,7 +36,7 @@ public void subscribe(Subscriber<? super Void> s) {
         try {
             run.run();
         } catch (Throwable ex) {
-            Operators.error(s, Exceptions.onOperatorError(ex));
+            Operators.error(s, Operators.onOperatorError(ex));
             return;
         }
         Operators.complete(s);

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.Exceptions;
 
 /**
  * Executes a Supplier function and emits a single value to each individual Subscriber.
@@ -64,12 +63,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = supplier.get();
 		} catch (Throwable e) {
-			s.onError(Exceptions.onOperatorError(e));
+			s.onError(Operators.onOperatorError(e));
 			return;
 		}
 
 		if (t == null) {
-			s.onError(Exceptions.onOperatorError(new NullPointerException("The " +
+			s.onError(Operators.onOperatorError(new NullPointerException("The " +
 					"callable returned null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/MonoToCompletableFuture.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Exceptions;
 
 /**
  * @author Stephane Maldini
@@ -59,7 +58,7 @@ public void onNext(T t) {
 			s.cancel();
 		}
 		else {
-			Exceptions.onNextDropped(t);
+			Operators.onNextDropped(t);
 		}
 	}
 

File: src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -24,7 +24,6 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.Exceptions;
 
 /**
  * Waits for all Mono sources to produce a value or terminate, and if
@@ -191,11 +190,11 @@ void signal() {
 		            r = zipper.apply(o);
 	            }
 	            catch (Throwable t) {
-		            subscriber.onError(Exceptions.onOperatorError(null, t, o));
+		            subscriber.onError(Operators.onOperatorError(null, t, o));
 		            return;
 	            }
 	            if (r == null) {
-		            subscriber.onError(Exceptions.onOperatorError(null,
+		            subscriber.onError(Operators.onOperatorError(null,
 				            new NullPointerException("zipper produced a null value"),
 				            o));
 		            return;

File: src/main/java/reactor/core/publisher/ParallelSortedJoin.java
Patch:
@@ -141,7 +141,7 @@ void innerError(Throwable e) {
 			if (Exceptions.addThrowable(ERROR, this, e)) {
 				drain();
 			} else {
-				Exceptions.onErrorDropped(e);
+				Operators.onErrorDropped(e);
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/ParallelUnorderedJoin.java
Patch:
@@ -159,7 +159,7 @@ void onError(Throwable e) {
 				cancelAll();
 				drain();
 			} else {
-				Exceptions.onErrorDropped(e);
+				Operators.onErrorDropped(e);
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/ParallelUnorderedRunOn.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.*;
 
-import reactor.core.Exceptions;
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Scheduler.Worker;
 
@@ -148,7 +147,7 @@ public void onNext(T t) {
 		@Override
 		public void onError(Throwable t) {
 			if (done) {
-				Exceptions.onErrorDropped(t);
+				Operators.onErrorDropped(t);
 				return;
 			}
 			error = t;

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -29,7 +29,6 @@
 import reactor.core.Producer;
 import reactor.core.Receiver;
 import reactor.core.Trackable;
-import reactor.core.Exceptions;
 import reactor.util.concurrent.QueueSupplier;
 
 /**
@@ -268,7 +267,7 @@ public long getPrefetch() {
 	public void onNext(T t) {
 		Buffer<T> b = buffer;
 		if (b.isDone()) {
-			Exceptions.onNextDropped(t);
+			Operators.onNextDropped(t);
 		} else {
 			b.onNext(t);
 			for (ReplaySubscription<T> rp : subscribers) {
@@ -281,7 +280,7 @@ public void onNext(T t) {
 	public void onError(Throwable t) {
 		Buffer<T> b = buffer;
 		if (b.isDone()) {
-			Exceptions.onErrorDropped(t);
+			Operators.onErrorDropped(t);
 		} else {
 			b.onError(t);
 			

File: src/main/java/reactor/core/publisher/SignalLogger.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @author Stephane Maldini
  */
-final class SignalLogger<IN> implements Operators.SignalObserver<IN> {
+final class SignalLogger<IN> implements SignalPeek<IN> {
 
 	final static int SUBSCRIBE       = 0b010000000;
 	final static int ON_SUBSCRIBE    = 0b001000000;

File: src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -883,7 +883,7 @@ else if (processor.terminated == FORCED_SHUTDOWN) {
 							}
 							continue;
 						}
-						subscriber.onError(Exceptions.onOperatorError(ex));
+						subscriber.onError(Operators.onOperatorError(ex));
 						sequence.set(nextSequence);
 						nextSequence++;
 					}

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -26,7 +26,6 @@
 import reactor.core.Fuseable;
 import reactor.core.Producer;
 import reactor.core.Receiver;
-import reactor.core.Exceptions;
 import reactor.util.concurrent.QueueSupplier;
 
 /**
@@ -288,7 +287,7 @@ public void onNext(T t) {
 	@Override
 	public void onError(Throwable t) {
 		if (done || cancelled) {
-			Exceptions.onErrorDropped(t);
+			Operators.onErrorDropped(t);
 			return;
 		}
 

File: src/main/java/reactor/core/scheduler/ExecutorScheduler.java
Patch:
@@ -25,6 +25,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.core.publisher.Operators;
 import reactor.util.concurrent.OpenHashSet;
 
 /**
@@ -86,7 +87,7 @@ public void run() {
                 }
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                Exceptions.onErrorDropped(e);
+                Operators.onErrorDropped(e);
             }
         }
         
@@ -136,7 +137,7 @@ public void run() {
                 }
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                Exceptions.onErrorDropped(e);
+                Operators.onErrorDropped(e);
             } finally {
                 if (callRemoveOnFinish) {
                     dispose();

File: src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import reactor.core.Cancellation;
-import reactor.core.Exceptions;
+import reactor.core.publisher.Operators;
 import reactor.util.concurrent.OpenHashSet;
 
 /**
@@ -151,7 +151,7 @@ public void run() {
 				try {
 					task.run();
 				} catch (Throwable e) {
-					Exceptions.onErrorDropped(e);
+					Operators.onErrorDropped(e);
 				}
 			} finally {
 				for (;;) {

File: src/main/java/reactor/core/scheduler/ImmediateScheduler.java
Patch:
@@ -17,6 +17,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.core.publisher.Operators;
 
 /**
  * Executes tasks on the caller's thread immediately.
@@ -43,7 +44,7 @@ public Cancellation schedule(Runnable task) {
             task.run();
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            Exceptions.onErrorDropped(ex);
+            Operators.onErrorDropped(ex);
         }
         return EMPTY;
     }
@@ -66,7 +67,7 @@ public Cancellation schedule(Runnable task) {
                 task.run();
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
-                Exceptions.onErrorDropped(ex);
+                Operators.onErrorDropped(ex);
             }
             return EMPTY;
         }

File: src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -26,6 +26,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.core.publisher.Operators;
 import reactor.util.concurrent.OpenHashSet;
 
 /**
@@ -170,7 +171,7 @@ public Cancellation schedule(Runnable task) {
             try {
                 f = exec.submit(pw);
             } catch (RejectedExecutionException ex) {
-                Exceptions.onErrorDropped(ex);
+                Operators.onErrorDropped(ex);
                 return REJECTED;
             }
             
@@ -263,7 +264,7 @@ public void run() {
                         run.run();
                     } catch (Throwable ex) {
                         Exceptions.throwIfFatal(ex);
-                        Exceptions.onErrorDropped(ex);
+                        Operators.onErrorDropped(ex);
                     }
                 } finally {
                     for (;;) {

File: src/main/java/reactor/core/scheduler/SingleTimedScheduler.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import reactor.core.Cancellation;
-import reactor.core.Exceptions;
+import reactor.core.publisher.Operators;
 import reactor.util.concurrent.OpenHashSet;
 
 /**
@@ -264,7 +264,7 @@ public void run() {
                 try {
                     task.run();
                 } catch (Throwable e) {
-                    Exceptions.onErrorDropped(e);
+                    Operators.onErrorDropped(e);
                 }
             } finally {
                 for (;;) {
@@ -383,7 +383,7 @@ public void run() {
                 try {
                     task.run();
                 } catch (Throwable ex) {
-                    Exceptions.onErrorDropped(ex);
+                    Operators.onErrorDropped(ex);
                     for (;;) {
                         Future<?> a = get();
                         if (a == CANCELLED_FUTURE) {

File: src/main/java/reactor/core/scheduler/ElasticScheduler.java
Patch:
@@ -32,6 +32,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.util.concurrent.OpenHashSet;
 
 /**
  * Dynamically creates ExecutorService-based Workers and caches the thread pools, reusing
@@ -253,7 +254,7 @@ public void shutdown() {
             }
             
             if (!set.isEmpty()) {
-                Object[] keys = set.keys;
+                Object[] keys = set.keys();
                 for (Object o : keys) {
                     if (o != null) {
                         ((CachedTask)o).cancelFuture();

File: src/main/java/reactor/core/scheduler/ExecutorScheduler.java
Patch:
@@ -25,6 +25,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.util.concurrent.OpenHashSet;
 
 /**
  * Wraps a java.util.concurrent.Executor and provides the Scheduler API over it.
@@ -217,7 +218,7 @@ public void shutdown() {
             }
 
             if (!list.isEmpty()) {
-                Object[] a = list.keys;
+                Object[] a = list.keys();
                 for (Object o : a) {
                     if (o != null) {
                         ((ExecutorTrackedRunnable) o).dispose();

File: src/main/java/reactor/core/scheduler/ExecutorServiceScheduler.java
Patch:
@@ -23,6 +23,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.util.concurrent.OpenHashSet;
 
 /**
  * A simple {@link Scheduler} which uses a backing {@link ExecutorService} to schedule Runnables for async operators.
@@ -113,7 +114,7 @@ public void shutdown() {
 				}
 
 				if (!coll.isEmpty()) {
-					Object[] a = coll.keys;
+					Object[] a = coll.keys();
 					for (Object o : a) {
 						if (o != null) {
 							((ScheduledRunnable)o).cancelFuture();

File: src/main/java/reactor/core/scheduler/ParallelScheduler.java
Patch:
@@ -26,6 +26,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.util.concurrent.OpenHashSet;
 
 /**
  * Scheduler that hosts a fixed pool of single-threaded ExecutorService-based workers
@@ -196,7 +197,7 @@ public void shutdown() {
             }
             
             if (set != null) {
-                Object[] a = set.keys;
+                Object[] a = set.keys();
                 for (Object o : a) {
                     if (o != null) {
                         ((ParallelWorkerTask)o).cancelFuture();

File: src/main/java/reactor/core/scheduler/SingleScheduler.java
Patch:
@@ -26,6 +26,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.util.concurrent.OpenHashSet;
 
 /**
  * Scheduler that works with a single-threaded ExecutorService and is suited for
@@ -167,7 +168,7 @@ public void shutdown() {
             }
             
             if (set != null && !set.isEmpty()) {
-                Object[] a = set.keys;
+                Object[] a = set.keys();
                 for (Object o : a) {
                     if (o != null) {
                         ((SingleWorkerTask)o).cancelFuture();

File: src/main/java/reactor/core/scheduler/SingleTimedScheduler.java
Patch:
@@ -28,6 +28,7 @@
 
 import reactor.core.Cancellation;
 import reactor.core.Exceptions;
+import reactor.util.concurrent.OpenHashSet;
 
 /**
  * A TimedScheduler with an embedded, single-threaded ScheduledExecutorService,
@@ -213,7 +214,7 @@ public void shutdown() {
             }
             
             if (!set.isEmpty()) {
-                Object[] keys = set.keys;
+                Object[] keys = set.keys();
                 for (Object c : keys) {
                     if (c != null) {
                         ((CancelFuture)c).cancelFuture();

File: src/main/java/reactor/core/publisher/ConnectableFlux.java
Patch:
@@ -78,7 +78,8 @@ public final Flux<T> autoConnect(int minSubscribers, Consumer<? super Cancellati
 			connect(cancelSupport);
 			return this;
 		}
-		return new ConnectableFluxAutoConnect<>(this, minSubscribers, cancelSupport);
+		return onAssembly(new ConnectableFluxAutoConnect<>(this, minSubscribers,
+				cancelSupport));
 	}
 
 	/**
@@ -130,7 +131,7 @@ public final Flux<T> refCount() {
 	 * @return a reference counting {@link Flux}
 	 */
 	public final Flux<T> refCount(int minSubscribers) {
-		return new ConnectableFluxRefCount<>(this, minSubscribers);
+		return onAssembly(new ConnectableFluxRefCount<>(this, minSubscribers));
 	}
 
 	static final Consumer<Cancellation> NOOP_DISCONNECT = runnable -> {

File: src/main/java/reactor/core/publisher/MonoCollectList.java
Patch:
@@ -31,12 +31,12 @@
  * @param <T> the source value type
  * @param <C> the collection type that takes any supertype of T
  */
-final class MonoBufferAll<T, C extends Collection<? super T>> extends MonoSource<T, C>
+final class MonoCollectList<T, C extends Collection<? super T>> extends MonoSource<T, C>
         implements Fuseable {
 
     final Supplier<C> collectionSupplier;
     
-    protected MonoBufferAll(Publisher<? extends T> source, Supplier<C> collectionSupplier) {
+    protected MonoCollectList(Publisher<? extends T> source, Supplier<C> collectionSupplier) {
         super(source);
         this.collectionSupplier = collectionSupplier;
     }

File: src/main/java/reactor/core/publisher/MonoCompletableFuture.java
Patch:
@@ -62,7 +62,7 @@ public void subscribe(Subscriber<? super T> s) {
             } else if (v != null) {
                 sds.complete(v);
             } else {
-                s.onError(new NullPointerException("The future produced a null value"));
+                s.onComplete();
             }
         });
     }

File: src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -103,9 +103,9 @@ public void testTrace2() throws Exception {
 		}
 		catch(Exception e){
 			e.printStackTrace();
-			Assert.assertTrue(e.getSuppressed()[1].getMessage().contains
+			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains
 					("ScatterGatherTests.java:"));
-			Assert.assertTrue(e.getSuppressed()[1].getMessage().contains("|_\tMono.map" +
+			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains("|_\tMono.map" +
 					"(ScatterGatherTests.java:"));
 			return;
 		}

File: src/main/java/reactor/core/publisher/ConnectableFluxPublish.java
Patch:
@@ -212,7 +212,7 @@ public void onSubscribe(Subscription s) {
 				try {
 					queue = parent.queueSupplier.get(); 
 				} catch (Throwable ex) {
-					error = Exceptions.mapOperatorError(s, ex);
+					error = Exceptions.onOperatorError(s, ex);
 					done = true;
 					drain();
 					return;
@@ -418,7 +418,7 @@ void drain() {
 								v = q.poll();
 							} catch (Throwable ex) {
 								Exceptions.addThrowable(ERROR, this, Exceptions
-										.mapOperatorError(s, ex));
+										.onOperatorError(s, ex));
 								d = true;
 								v = null;
 							}
@@ -447,7 +447,7 @@ void drain() {
 								empty = q.isEmpty();
 							} catch (Throwable ex) {
 								Exceptions.addThrowable(ERROR, this, Exceptions
-										.mapOperatorError(s, ex));
+										.onOperatorError(s, ex));
 								d = true;
 								empty = true;
 							}

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -344,7 +344,7 @@ public void onSubscribe(final Subscription s) {
 				}
 			}
 			catch (Throwable t) {
-				onError(Exceptions.mapOperatorError(s, t));
+				onError(Exceptions.onOperatorError(s, t));
 			}
 		}
 	}

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -461,7 +461,7 @@ final public void onSubscribe(final Subscription s) {
 				}
 			}
 			catch (Throwable t) {
-				onError(Exceptions.mapOperatorError(s, t));
+				onError(Exceptions.onOperatorError(s, t));
 			}
 		}
 	}
@@ -476,7 +476,7 @@ public final void shutdown() {
 			executor.shutdown();
 		}
 		catch (Throwable t) {
-			onError(Exceptions.mapOperatorError(t));
+			onError(Exceptions.onOperatorError(t));
 		}
 	}
 
@@ -572,7 +572,7 @@ public void run() {
 				if(WaitStrategy.isAlert(t)){
 					return;
 				}
-				errorSubscriber.onError(Exceptions.mapOperatorError(t));
+				errorSubscriber.onError(Exceptions.onOperatorError(t));
 			}
 		}
 	}

File: src/main/java/reactor/core/publisher/FluxAccumulate.java
Patch:
@@ -103,7 +103,7 @@ public void onNext(T t) {
 					t = accumulator.apply(v, t);
 				}
 				catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e, t));
+					onError(Exceptions.onOperatorError(s, e, t));
 					return;
 				}
 				if (t == null) {

File: src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -136,7 +136,7 @@ public void onNext(T t) {
 				try {
 					b = bufferSupplier.get();
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e, t));
+					onError(Exceptions.onOperatorError(s, e, t));
 					return;
 				}
 
@@ -302,7 +302,7 @@ public void onNext(T t) {
 					b = bufferSupplier.get();
 				}
 				catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e, t));
+					onError(Exceptions.onOperatorError(s, e, t));
 					return;
 				}
 
@@ -502,7 +502,7 @@ public void onNext(T t) {
 				try {
 					b = bufferSupplier.get();
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e, t));
+					onError(Exceptions.onOperatorError(s, e, t));
 					return;
 				}
 

File: src/main/java/reactor/core/publisher/FluxBufferBoundary.java
Patch:
@@ -63,7 +63,7 @@ public void subscribe(Subscriber<? super C> s) {
 		try {
 			buffer = bufferSupplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 		
@@ -192,7 +192,7 @@ void otherNext() {
 			try {
 				c = bufferSupplier.get();
 			} catch (Throwable e) {
-				otherError(Exceptions.mapOperatorError(other, e));
+				otherError(Exceptions.onOperatorError(other, e));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -80,7 +80,7 @@ public void subscribe(Subscriber<? super C> s) {
 		try {
 			q = queueSupplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 		
@@ -314,7 +314,7 @@ void startNext(U u) {
 			try {
 				b = bufferSupplier.get();
 			} catch (Throwable e) {
-				anyError(Exceptions.mapOperatorError(starter, e, u));
+				anyError(Exceptions.onOperatorError(starter, e, u));
 				return;
 			}
 			
@@ -339,7 +339,7 @@ void startNext(U u) {
 			try {
 				p = end.apply(u);
 			} catch (Throwable e) {
-				anyError(Exceptions.mapOperatorError(starter, e, u));
+				anyError(Exceptions.onOperatorError(starter, e, u));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -43,7 +43,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             v = callable.call();
         } catch (Throwable ex) {
-            s.onError(Exceptions.mapOperatorError(ex));
+            s.onError(Exceptions.onOperatorError(ex));
             return;
         }
         

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -58,7 +58,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             emitter.accept(dfe);
         } catch (Throwable ex) {
-            dfe.error(Exceptions.mapOperatorError(ex));
+            dfe.error(Exceptions.onOperatorError(ex));
         }
     }
     

File: src/main/java/reactor/core/publisher/FluxDefer.java
Patch:
@@ -53,13 +53,13 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = supplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
 			Operators.error(s,
-					Exceptions.mapOperatorError(new NullPointerException(
+					Exceptions.onOperatorError(new NullPointerException(
 							"The Producer returned by the supplier is null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxDistinctFuseable.java
Patch:
@@ -59,12 +59,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			collection = collectionSupplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (collection == null) {
-			Operators.error(s, Exceptions.mapOperatorError(new
+			Operators.error(s, Exceptions.onOperatorError(new
 					NullPointerException("The collectionSupplier returned a null collection")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -106,7 +106,7 @@ public boolean tryOnNext(T t) {
 				k = keyExtractor.apply(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 				return true;
 			}
 
@@ -222,7 +222,7 @@ public void onNext(T t) {
 			try {
 				k = keyExtractor.apply(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 				return;
 			}
 
@@ -247,7 +247,7 @@ public boolean tryOnNext(T t) {
 				k = keyExtractor.apply(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 				return true;
 			}
 

File: src/main/java/reactor/core/publisher/FluxDrop.java
Patch:
@@ -134,7 +134,7 @@ public void onNext(T t) {
 				try {
 					onDrop.accept(t);
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e, t));
+					onError(Exceptions.onOperatorError(s, e, t));
 				}
 			}
 		}

File: src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -76,7 +76,7 @@ public void subscribe(Subscriber<? super T> s) {
 		if (whenRequested) {
 			s.onSubscribe(new ErrorSubscription(s, e));
 		} else {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 		}
 	}
 	

File: src/main/java/reactor/core/publisher/FluxFirstEmitting.java
Patch:
@@ -80,7 +80,7 @@ public void subscribe(Subscriber<? super T> s) {
 			try {
 				it = iterable.iterator();
 			} catch (Throwable e) {
-				Operators.error(s, Exceptions.mapOperatorError(e));
+				Operators.error(s, Exceptions.onOperatorError(e));
 				return;
 			}
 
@@ -97,7 +97,7 @@ public void subscribe(Subscriber<? super T> s) {
 				try {
 					b = it.hasNext();
 				} catch (Throwable e) {
-					Operators.error(s, Exceptions.mapOperatorError(e));
+					Operators.error(s, Exceptions.onOperatorError(e));
 					return;
 				}
 
@@ -110,7 +110,7 @@ public void subscribe(Subscriber<? super T> s) {
 				try {
 					p = it.next();
 				} catch (Throwable e) {
-					Operators.error(s, Exceptions.mapOperatorError(e));
+					Operators.error(s, Exceptions.onOperatorError(e));
 					return;
 				}
 

File: src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -74,7 +74,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			state = stateSupplier.call();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 		s.onSubscribe(new GenerateSubscription<>(s, state, generator, stateConsumer));
@@ -204,7 +204,7 @@ void fastPath() {
 				} catch (Throwable e) {
 					cleanup(s);
 
-					actual.onError(Exceptions.mapOperatorError(e));
+					actual.onError(Exceptions.onOperatorError(e));
 					return;
 				}
 				if (terminate || cancelled) {

File: src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			it = iterable.iterator();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 
@@ -82,7 +82,7 @@ static <T> void subscribe(Subscriber<? super T> s, Iterator<? extends T> it) {
 		try {
 			b = it.hasNext();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 		if (!b) {

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -71,7 +71,7 @@ public void subscribe(final Subscriber<? super T> subscriber) {
 			subscriber.onSubscribe(new WeakScalarSubscription<>(value, subscriber));
 		}
 		catch (Throwable throwable) {
-			subscriber.onError(Exceptions.mapOperatorError(throwable));
+			subscriber.onError(Exceptions.onOperatorError(throwable));
 		}
 	}
 

File: src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -89,7 +89,7 @@ public void onComplete() {
 			try {
 				b = predicate.getAsBoolean();
 			} catch (Throwable e) {
-				subscriber.onError(Exceptions.mapOperatorError(e));
+				subscriber.onError(Exceptions.onOperatorError(e));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -68,12 +68,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = whenSourceFactory.apply(other);
 		} catch (Throwable e) {
-			s.onError(Exceptions.mapOperatorError(e));
+			s.onError(Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
-			s.onError(Exceptions.mapOperatorError(new NullPointerException("The " +
+			s.onError(Exceptions.onOperatorError(new NullPointerException("The " +
 					"whenSourceFactory returned a null Publisher")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -89,7 +89,7 @@ public void onError(Throwable t) {
 				try {
 					p = nextFactory.apply(t);
 				} catch (Throwable e) {
-					Throwable _e = Exceptions.mapOperatorError(e);
+					Throwable _e = Exceptions.onOperatorError(e);
 					_e.addSuppressed(t);
 					subscriber.onError(_e);
 					return;

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -89,7 +89,7 @@ public void onError(Throwable t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				Throwable _t = Exceptions.mapOperatorError(e);
+				Throwable _t = Exceptions.onOperatorError(e);
 				_t.addSuppressed(t);
 				subscriber.onError(_t);
 				return;

File: src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -71,12 +71,12 @@ static <T> void subscribe(Subscriber<? super T> s, Function<? super
 			p = whenSourceFactory.apply(other);
 		}
 		catch (Throwable e) {
-			s.onError(Exceptions.mapOperatorError(e));
+			s.onError(Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
-			s.onError(Exceptions.mapOperatorError(new NullPointerException(
+			s.onError(Exceptions.onOperatorError(new NullPointerException(
 					"The whenSourceFactory returned a null Publisher")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -69,7 +69,7 @@ public void subscribe(Subscriber<? super R> s) {
 		try {
 			initialValue = initialSupplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 
@@ -143,7 +143,7 @@ public void onNext(T t) {
 			try {
 				r = accumulator.apply(r, t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -102,7 +102,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 				return;
 			}
 
@@ -132,7 +132,7 @@ public boolean tryOnNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 
 				return true;
 			}

File: src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -102,7 +102,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 
 				return;
 			}
@@ -134,7 +134,7 @@ public boolean tryOnNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 
 				return true;
 			}

File: src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -53,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			it = stream.iterator();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -62,12 +62,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			worker = scheduler.createWorker();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 		
 		if (worker == null) {
-			Operators.error(s, Exceptions.mapOperatorError(new
+			Operators.error(s, Exceptions.onOperatorError(new
 					NullPointerException("The scheduler returned a null Function")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -208,7 +208,7 @@ public void run() {
 				v = callable.call();
 			}
 			catch (Throwable ex) {
-				actual.onError(Exceptions.mapOperatorError(this, ex));
+				actual.onError(Exceptions.onOperatorError(this, ex));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -79,7 +79,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -91,7 +91,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e, t));
+				onError(Exceptions.onOperatorError(s, e, t));
 
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxThrottleFirst.java
Patch:
@@ -142,7 +142,7 @@ public void onNext(T t) {
 					p = throttler.apply(t);
 				} catch (Throwable e) {
 					Operators.terminate(S, this);
-					error(Exceptions.mapOperatorError(null, e, t));
+					error(Exceptions.onOperatorError(null, e, t));
 					return;
 				}
 				

File: src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -134,12 +134,12 @@ public void onNext(T t) {
 			try {
 				p = itemTimeout.apply(t);
 			} catch (Throwable e) {
-				subscriber.onError(Exceptions.mapOperatorError(this, e, t));
+				subscriber.onError(Exceptions.onOperatorError(this, e, t));
 				return;
 			}
 
 			if (p == null) {
-				subscriber.onError(Exceptions.mapOperatorError(this, new
+				subscriber.onError(Exceptions.onOperatorError(this, new
 						NullPointerException("The itemTimeout returned a null " +
 						"Publisher"), t));
 				return;

File: src/main/java/reactor/core/publisher/FluxWindow.java
Patch:
@@ -92,12 +92,12 @@ public void subscribe(Subscriber<? super Flux<T>> s) {
 			try {
 				overflowQueue = overflowQueueSupplier.get();
 			} catch (Throwable e) {
-				Operators.error(s, Exceptions.mapOperatorError(e));
+				Operators.error(s, Exceptions.onOperatorError(e));
 				return;
 			}
 			
 			if (overflowQueue == null) {
-				Operators.error(s, Exceptions.mapOperatorError(new
+				Operators.error(s, Exceptions.onOperatorError(new
 						NullPointerException("The overflowQueueSupplier returned a null queue")));
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -154,12 +154,12 @@ public void onNext(T t) {
 				try {
 					r = combiner.apply(t, u);
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(this, e, t));
+					onError(Exceptions.onOperatorError(this, e, t));
 					return;
 				}
 
 				if (r == null) {
-					onError(Exceptions.mapOperatorError(this, new NullPointerException
+					onError(Exceptions.onOperatorError(this, new NullPointerException
 							("The" +
 							" combiner returned a null value"), t));
 					return;

File: src/main/java/reactor/core/publisher/MonoAggregate.java
Patch:
@@ -86,14 +86,14 @@ public void onNext(T t) {
 				} catch (Throwable ex) {
 					result = null;
 					done = true;
-					subscriber.onError(Exceptions.mapOperatorError(s, ex, t));
+					subscriber.onError(Exceptions.onOperatorError(s, ex, t));
 					return;
 				}
 				
 				if (r == null) {
 					result = null;
 					done = true;
-					subscriber.onError(Exceptions.mapOperatorError(s, new
+					subscriber.onError(Exceptions.onOperatorError(s, new
 							NullPointerException("The aggregator returned a null " +
 							"value"), t));
 					return;

File: src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -94,7 +94,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				subscriber.onError(Exceptions.mapOperatorError(s, e, t));
+				subscriber.onError(Exceptions.onOperatorError(s, e, t));
 				return;
 			}
 			if (!b) {

File: src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -95,7 +95,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				subscriber.onError(Exceptions.mapOperatorError(s, e, t));
+				subscriber.onError(Exceptions.onOperatorError(s, e, t));
 				return;
 			}
 			if (b) {

File: src/main/java/reactor/core/publisher/MonoBufferAll.java
Patch:
@@ -48,12 +48,12 @@ public void subscribe(Subscriber<? super C> s) {
         try {
             collection = collectionSupplier.get();
         } catch (Throwable ex) {
-            Operators.error(s, Exceptions.mapOperatorError(ex));
+            Operators.error(s, Exceptions.onOperatorError(ex));
             return;
         }
         
         if (collection == null) {
-            Operators.error(s, Exceptions.mapOperatorError(new NullPointerException
+            Operators.error(s, Exceptions.onOperatorError(new NullPointerException
                     ("The " +
                     "collectionSupplier " +
                     "returned a null collection")));

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -65,12 +65,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = callable.call();
 		} catch (Throwable e) {
-			s.onError(Exceptions.mapOperatorError(e));
+			s.onError(Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (t == null) {
-			s.onError(Exceptions.mapOperatorError(new NullPointerException("The " +
+			s.onError(Exceptions.onOperatorError(new NullPointerException("The " +
 					"callable returned null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -58,12 +58,12 @@ public void subscribe(Subscriber<? super R> s) {
 		try {
 			container = supplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (container == null) {
-			Operators.error(s, Exceptions.mapOperatorError(new
+			Operators.error(s, Exceptions.onOperatorError(new
 					NullPointerException("The supplier returned a null container")));
 			return;
 		}
@@ -115,7 +115,7 @@ public void onNext(T t) {
 			try {
 				action.accept(value, t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(this, e, t));
+				onError(Exceptions.onOperatorError(this, e, t));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -46,7 +46,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             callback.accept(emitter);
         } catch (Throwable ex) {
-            emitter.error(Exceptions.mapOperatorError(ex));
+            emitter.error(Exceptions.onOperatorError(ex));
         }
     }
 

File: src/main/java/reactor/core/publisher/MonoDefer.java
Patch:
@@ -54,12 +54,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = supplier.get();
 		} catch (Throwable e) {
-			Operators.error(s, Exceptions.mapOperatorError(e));
+			Operators.error(s, Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (p == null) {
-			Operators.error(s, Exceptions.mapOperatorError(new
+			Operators.error(s, Exceptions.onOperatorError(new
 					NullPointerException("The Producer returned by the supplier is null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -92,7 +92,7 @@ public void run() {
 				}
 				}
 				catch (Throwable t){
-					s.onError(Exceptions.mapOperatorError(t));
+					s.onError(Exceptions.onOperatorError(t));
 				}
 			} else {
 				s.onError(new IllegalStateException("Could not emit value due to lack of requests"));

File: src/main/java/reactor/core/publisher/MonoElementAt.java
Patch:
@@ -145,20 +145,20 @@ public void onComplete() {
 			Supplier<? extends T> ds = defaultSupplier;
 
 			if (ds == null) {
-				subscriber.onError(Exceptions.mapOperatorError(new
+				subscriber.onError(Exceptions.onOperatorError(new
 						IndexOutOfBoundsException()));
 			} else {
 				T t;
 
 				try {
 					t = ds.get();
 				} catch (Throwable e) {
-					subscriber.onError(Exceptions.mapOperatorError(e));
+					subscriber.onError(Exceptions.onOperatorError(e));
 					return;
 				}
 
 				if (t == null) {
-					subscriber.onError(Exceptions.mapOperatorError(new
+					subscriber.onError(Exceptions.onOperatorError(new
 							NullPointerException("The defaultSupplier returned a null value")));
 					return;
 				}

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -72,7 +72,7 @@ public void subscribe(Subscriber<? super T> s) {
 			e = new NullPointerException("The Throwable returned by the supplier is null");
 		}
 
-		Operators.error(s, Exceptions.mapOperatorError(e));
+		Operators.error(s, Exceptions.onOperatorError(e));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -125,12 +125,12 @@ public void onNext(T t) {
             try {
                 p = mapper.apply(t);
             } catch (Throwable ex) {
-                actual.onError(Exceptions.mapOperatorError(this, ex, t));
+                actual.onError(Exceptions.onOperatorError(this, ex, t));
                 return;
             }
             
             if (p == null) {
-                actual.onError(Exceptions.mapOperatorError(this, new NullPointerException
+                actual.onError(Exceptions.onOperatorError(this, new NullPointerException
                         ("The mapper returned" +
                         " a null " +
                         "Publisher."), t));
@@ -143,7 +143,7 @@ public void onNext(T t) {
                 try {
                     v = ((Callable<R>)p).call();
                 } catch (Throwable ex) {
-                    actual.onError(Exceptions.mapOperatorError(this, ex, t));
+                    actual.onError(Exceptions.onOperatorError(this, ex, t));
                     return;
                 }
                 

File: src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -37,7 +37,7 @@ public void subscribe(Subscriber<? super Void> s) {
         try {
             run.run();
         } catch (Throwable ex) {
-            Operators.error(s, Exceptions.mapOperatorError(ex));
+            Operators.error(s, Exceptions.onOperatorError(ex));
             return;
         }
         Operators.complete(s);

File: src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -164,20 +164,20 @@ public void onComplete() {
 					try {
 						t = ds.get();
 					} catch (Throwable e) {
-						subscriber.onError(Exceptions.mapOperatorError(this, e));
+						subscriber.onError(Exceptions.onOperatorError(this, e));
 						return;
 					}
 
 					if (t == null) {
-						subscriber.onError(Exceptions.mapOperatorError(this, new
+						subscriber.onError(Exceptions.onOperatorError(this, new
 								NullPointerException("The defaultSupplier returned a " +
 								"null value")));
 						return;
 					}
 
 					complete(t);
 				} else {
-					subscriber.onError(Exceptions.mapOperatorError(this, new
+					subscriber.onError(Exceptions.onOperatorError(this, new
 							NoSuchElementException("Source was empty")));
 				}
 			} else if (c == 1) {

File: src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -61,7 +61,7 @@ public void subscribe(Subscriber<? super R> s) {
 			
 			finisher = collector.finisher();
 		} catch (Throwable ex) {
-			Operators.error(s, Exceptions.mapOperatorError(ex));
+			Operators.error(s, Exceptions.onOperatorError(ex));
 			return;
 		}
 		
@@ -108,7 +108,7 @@ public void onNext(T t) {
 			try {
 				accumulator.accept(container, t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(s, ex, t));
+				onError(Exceptions.onOperatorError(s, ex, t));
 			}
 		}
 		
@@ -138,7 +138,7 @@ public void onComplete() {
 			try {
 				r = finisher.apply(a);
 			} catch (Throwable ex) {
-				subscriber.onError(Exceptions.mapOperatorError(ex));
+				subscriber.onError(Exceptions.onOperatorError(ex));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -64,12 +64,12 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = supplier.get();
 		} catch (Throwable e) {
-			s.onError(Exceptions.mapOperatorError(e));
+			s.onError(Exceptions.onOperatorError(e));
 			return;
 		}
 
 		if (t == null) {
-			s.onError(Exceptions.mapOperatorError(new NullPointerException("The " +
+			s.onError(Exceptions.onOperatorError(new NullPointerException("The " +
 					"callable returned null")));
 			return;
 		}

File: src/main/java/reactor/core/publisher/MonoThenSupply.java
Patch:
@@ -134,7 +134,7 @@ void drain() {
                             try {
                                 v = ((Callable<T>)m).call();
                             } catch (Throwable ex) {
-                                subscriber.onError(Exceptions.mapOperatorError(ex));
+                                subscriber.onError(Exceptions.onOperatorError(ex));
                                 return;
                             }
                             
@@ -156,7 +156,7 @@ void drain() {
                             try {
                                 ((Callable<?>)m).call();
                             } catch (Throwable ex) {
-                                subscriber.onError(Exceptions.mapOperatorError(ex));
+                                subscriber.onError(Exceptions.onOperatorError(ex));
                                 return;
                             }
                             

File: src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -191,11 +191,11 @@ void signal() {
 		            r = zipper.apply(o);
 	            }
 	            catch (Throwable t) {
-		            subscriber.onError(Exceptions.mapOperatorError(null, t, o));
+		            subscriber.onError(Exceptions.onOperatorError(null, t, o));
 		            return;
 	            }
 	            if (r == null) {
-		            subscriber.onError(Exceptions.mapOperatorError(null,
+		            subscriber.onError(Exceptions.onOperatorError(null,
 				            new NullPointerException("zipper produced a null value"),
 				            o));
 		            return;

File: src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -64,7 +64,7 @@ public void subscribe(Subscriber<? super C>[] subscribers) {
 			try {
 				initialValue = initialCollection.get();
 			} catch (Throwable ex) {
-				reportError(subscribers, Exceptions.mapOperatorError(ex));
+				reportError(subscribers, Exceptions.onOperatorError(ex));
 				return;
 			}
 			
@@ -133,7 +133,7 @@ public void onNext(T t) {
 			try {
 				collector.accept(collection, t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(this, ex, t));
+				onError(Exceptions.onOperatorError(this, ex, t));
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/ParallelReduce.java
Patch:
@@ -63,7 +63,7 @@ public void subscribe(Subscriber<? super R>[] subscribers) {
 			try {
 				initialValue = initialSupplier.get();
 			} catch (Throwable ex) {
-				reportError(subscribers, Exceptions.mapOperatorError(ex));
+				reportError(subscribers, Exceptions.onOperatorError(ex));
 				return;
 			}
 			
@@ -133,12 +133,12 @@ public void onNext(T t) {
 			try {
 				v = reducer.apply(accumulator, t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(this, ex, t));
+				onError(Exceptions.onOperatorError(this, ex, t));
 				return;
 			}
 			
 			if (v == null) {
-				onError(Exceptions.mapOperatorError(this, new NullPointerException("The" +
+				onError(Exceptions.onOperatorError(this, new NullPointerException("The" +
 						" reducer returned a null value"), t));
 				return;
 			}

File: src/main/java/reactor/core/publisher/ParallelReduceFull.java
Patch:
@@ -144,7 +144,7 @@ void innerComplete(T value) {
 						try {
 							value = reducer.apply(sp.first, sp.second);
 						} catch (Throwable ex) {
-							innerError(Exceptions.mapOperatorError(this, ex));
+							innerError(Exceptions.onOperatorError(this, ex));
 							return;
 						}
 						
@@ -211,12 +211,12 @@ public void onNext(T t) {
 				try {
 					v = reducer.apply(v, t);
 				} catch (Throwable ex) {
-					onError(Exceptions.mapOperatorError(s, ex, t));
+					onError(Exceptions.onOperatorError(s, ex, t));
 					return;
 				}
 				
 				if (v == null) {
-					onError(Exceptions.mapOperatorError(s, new NullPointerException
+					onError(Exceptions.onOperatorError(s, new NullPointerException
 							("The reducer returned a" +
 							" null " +
 							"value"), t));

File: src/main/java/reactor/core/publisher/ParallelUnorderedFilter.java
Patch:
@@ -108,7 +108,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(s, ex, t));
+				onError(Exceptions.onOperatorError(s, ex, t));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/ParallelUnorderedMap.java
Patch:
@@ -109,12 +109,12 @@ public void onNext(T t) {
 			try {
 				v = mapper.apply(t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(s, ex, t));
+				onError(Exceptions.onOperatorError(s, ex, t));
 				return;
 			}
 			
 			if (v == null) {
-				onError(Exceptions.mapOperatorError(s, new NullPointerException("The " +
+				onError(Exceptions.onOperatorError(s, new NullPointerException("The " +
 						"mapper returned a null value"), t));
 				return;
 			}

File: src/main/java/reactor/core/publisher/ParallelUnorderedSource.java
Patch:
@@ -291,7 +291,7 @@ void drainAsync() {
 						try {
 							v = q.poll();
 						} catch (Throwable ex) {
-							ex = Exceptions.mapOperatorError(s, ex);
+							ex = Exceptions.onOperatorError(s, ex);
 							for (Subscriber<? super T> s : a) {
 								s.onError(ex);
 							}
@@ -365,7 +365,7 @@ void drainSync() {
 					try {
 						empty = q.isEmpty();
 					} catch (Throwable ex) {
-						ex = Exceptions.mapOperatorError(s, ex);
+						ex = Exceptions.onOperatorError(s, ex);
 						for (Subscriber<? super T> s : a) {
 							s.onError(ex);
 						}
@@ -388,7 +388,7 @@ void drainSync() {
 						try {
 							v = q.poll();
 						} catch (Throwable ex) {
-							ex = Exceptions.mapOperatorError(s, ex);
+							ex = Exceptions.onOperatorError(s, ex);
 							for (Subscriber<? super T> s : a) {
 								s.onError(ex);
 							}

File: src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -883,7 +883,7 @@ else if (processor.terminated == FORCED_SHUTDOWN) {
 							}
 							continue;
 						}
-						subscriber.onError(Exceptions.mapOperatorError(ex));
+						subscriber.onError(Exceptions.onOperatorError(ex));
 						sequence.set(nextSequence);
 						nextSequence++;
 					}

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -683,7 +683,7 @@ public static Mono<Void> when(final Iterable<? extends Publisher<Void>> sources)
 	 *
 	 * @return a {@link Mono}.
 	 */
-	public static <R> Mono<R> when(Function<? super Object[], ? extends R> combinator, final Iterable<? extends Mono<?>> monos) {
+	public static <R> Mono<R> when(final Iterable<? extends Mono<?>> monos, Function<? super Object[], ? extends R> combinator) {
 		return onAssembly(new MonoWhen<>(false, combinator, monos));
 	}
 

File: src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -44,7 +44,7 @@
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class FluxPeek<T> extends FluxSource<T, T> implements FluxPeekHelper<T> {
+final class FluxPeek<T> extends FluxSource<T, T> implements PublisherPeek<T> {
 
 	final Consumer<? super Subscription> onSubscribeCall;
 
@@ -96,13 +96,13 @@ static final class PeekSubscriber<T> implements Subscriber<T>, Subscription, Rec
 
 		final Subscriber<? super T> actual;
 
-		final FluxPeekHelper<T> parent;
+		final PublisherPeek<T> parent;
 
 		Subscription s;
 
 		boolean done;
 
-		public PeekSubscriber(Subscriber<? super T> actual, FluxPeekHelper<T> parent) {
+		public PeekSubscriber(Subscriber<? super T> actual, PublisherPeek<T> parent) {
 			this.actual = actual;
 			this.parent = parent;
 		}

File: src/main/java/reactor/core/publisher/MonoPeek.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  */
-final class MonoPeek<T> extends MonoSource<T, T> implements FluxPeekHelper<T> {
+final class MonoPeek<T> extends MonoSource<T, T> implements PublisherPeek<T> {
 
 	final Consumer<? super Subscription> onSubscribeCall;
 

File: src/main/java/reactor/core/publisher/MonoPeekFuseable.java
Patch:
@@ -35,7 +35,7 @@
  *
  */
 final class MonoPeekFuseable<T> extends MonoSource<T, T>
-		implements Fuseable, FluxPeekHelper<T> {
+		implements Fuseable, PublisherPeek<T> {
 
 	final Consumer<? super Subscription> onSubscribeCall;
 

File: src/main/java/reactor/core/publisher/PublisherPeek.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @param <T> the value type of the sequence
  */
-interface FluxPeekHelper<T> {
+interface PublisherPeek<T> {
 	
 	Consumer<? super Subscription> onSubscribeCall();
 

File: src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -103,9 +103,9 @@ public void testTrace2() throws Exception {
 		}
 		catch(Exception e){
 			e.printStackTrace();
-			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains
+			Assert.assertTrue(e.getSuppressed()[1].getMessage().contains
 					("ScatterGatherTests.java:"));
-			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains("|_\tMono.map" +
+			Assert.assertTrue(e.getSuppressed()[1].getMessage().contains("|_\tMono.map" +
 					"(ScatterGatherTests.java:"));
 			return;
 		}

File: src/main/java/reactor/util/concurrent/package-info.java
Patch:
@@ -15,8 +15,8 @@
  */
 
 /**
- * Queue
- * {@link reactor.util.concurrent.QueueSupplier suppliers} and implementation of the bounded hardware friendly {@link reactor.util.concurrent.RingBuffer}.
+ * Queue {@link reactor.util.concurrent.QueueSupplier suppliers} and busy spin utils
+ * {@link reactor.util.concurrent.WaitStrategy}.
  * Used for operational serialization (serializing threads) or buffering (asynchronous boundary).
  *
  * @author Stephane Maldini

File: src/main/java/reactor/core/publisher/BlockingSink.java
Patch:
@@ -209,14 +209,14 @@ public Emission emit(E data) {
 
 	/**
 	 *
-	 * Try calling {@link Subscriber#onError(Throwable)} on the delegate {@link Subscriber}. {@link BlockingSink#fail(Throwable)}
+	 * Try calling {@link Subscriber#onError(Throwable)} on the delegate {@link Subscriber}. {@link BlockingSink#error(Throwable)}
 	 * might fail itself with an
 	 * unchecked exception if an error has already been recorded or it
 	 * has previously been terminated via {@link #cancel()}, {@link #finish()} or {@link #complete()}.
 	 *
 	 * @param error the exception to signal
 	 */
-	public void fail(Throwable error) {
+	public void error(Throwable error) {
 		if (uncaughtException == null) {
 			uncaughtException = error;
 			if(!cancelled) {

File: src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -135,11 +135,11 @@ public void next(T t) {
 				return;
 			}
 			if (hasValue) {
-				fail(new IllegalStateException("More than one call to onNext"));
+				error(new IllegalStateException("More than one call to onNext"));
 				return;
 			}
 			if (t == null) {
-				fail(new NullPointerException("The generator produced a null value"));
+				error(new NullPointerException("The generator produced a null value"));
 				return;
 			}
 			hasValue = true;
@@ -151,7 +151,7 @@ public void next(T t) {
 		}
 
 		@Override
-		public void fail(Throwable e) {
+		public void error(Throwable e) {
 			if (terminate) {
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxSink.java
Patch:
@@ -36,7 +36,7 @@ public interface FluxSink<T> {
      * @see Subscriber#onError(Throwable)
      * @param e the exception to signal, not null
      */
-    void fail(Throwable e);
+    void error(Throwable e);
 
     /**
      * Try emitting, might throw an unchecked exception.

File: src/main/java/reactor/core/publisher/MonoSink.java
Patch:
@@ -29,23 +29,23 @@ public interface MonoSink<T> {
      * <p>Calling this method multiple times or after the other
      * terminating methods has no effect.
      */
-    void complete();
+    void success();
     
     /**
      * Complete with the given value.
      * <p>Calling this method multiple times or after the other
      * terminating methods has no effect.
      * @param value the value to complete with
      */
-    void complete(T value);
+    void success(T value);
     
     /**
      * Terminate with the give exception
      * <p>Calling this method multiple times or after the other
      * terminating methods has no effect.
      * @param e the exception to complete with
      */
-    void fail(Throwable e);
+    void error(Throwable e);
     
     /**
      * Sets a cancellation callback triggered by

File: src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -35,7 +35,7 @@ public interface SynchronousSink<T> {
 	 * @see Subscriber#onError(Throwable)
 	 * @param e the exception to signal, not null
 	 */
-	void fail(Throwable e);
+	void error(Throwable e);
 
 	/**
 	 * Try emitting, might throw an unchecked exception.

File: src/test/java/reactor/core/publisher/FluxGenerateTest.java
Patch:
@@ -76,7 +76,7 @@ public void generateError() {
 		TestSubscriber<Integer> ts = TestSubscriber.create();
 
 		new FluxGenerate<Integer, Void>((s, o) -> {
-			o.fail(new RuntimeException("forced failure"));
+			o.error(new RuntimeException("forced failure"));
 			return s;
 		}).subscribe(ts);
 
@@ -193,8 +193,8 @@ public void generatorMultipleOnErrors() {
 		TestSubscriber<Integer> ts = TestSubscriber.create();
 
 		new FluxGenerate<Integer, Integer>((s, o) -> {
-			o.fail(new RuntimeException("forced failure"));
-			o.fail(new RuntimeException("forced failure"));
+			o.error(new RuntimeException("forced failure"));
+			o.error(new RuntimeException("forced failure"));
 			return s;
 		}).subscribe(ts);
 

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -553,7 +553,8 @@ public void run() {
 				upstream.request(bufferSize - 1);
 
 				for (; ; ) {
-					cursor = waitStrategy.waitFor(cursor + limit, readCount, spinObserver);
+					cursor = cursor + limit;
+					waitStrategy.waitFor(cursor, readCount, spinObserver);
 					if (postWaitCallback != null) {
 						postWaitCallback.accept(cursor);
 					}

File: src/main/java/reactor/core/scheduler/SingleTimedScheduler.java
Patch:
@@ -339,7 +339,9 @@ void setFuture(Future<?> f) {
         
         @Override
         public String toString() {
-            return "TimedScheduledRunnable[cancelled=" + get() + ", task=" + task + "]";
+            return "TimedScheduledRunnable[cancelled=" + (get() == CANCELLED_FUTURE) +
+		            ", task=" + task +
+                    "]";
         }
     }
 

File: src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -141,7 +141,7 @@ public void onNext(T t) {
 			if (p == null) {
 				subscriber.onError(Exceptions.mapOperatorError(this, new
 						NullPointerException("The itemTimeout returned a null " +
-						"Publisher"), t);
+						"Publisher"), t));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -170,7 +170,8 @@ public void onComplete() {
 
 					if (t == null) {
 						subscriber.onError(Exceptions.mapOperatorError(this, new
-								NullPointerException("The defaultSupplier returned a null value"));
+								NullPointerException("The defaultSupplier returned a " +
+								"null value")));
 						return;
 					}
 

File: src/main/java/reactor/core/publisher/FluxAccumulate.java
Patch:
@@ -103,7 +103,7 @@ public void onNext(T t) {
 					t = accumulator.apply(v, t);
 				}
 				catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e));
+					onError(Exceptions.mapOperatorError(s, e, t));
 					return;
 				}
 				if (t == null) {

File: src/main/java/reactor/core/publisher/FluxBuffer.java
Patch:
@@ -136,7 +136,7 @@ public void onNext(T t) {
 				try {
 					b = bufferSupplier.get();
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e));
+					onError(Exceptions.mapOperatorError(s, e, t));
 					return;
 				}
 
@@ -302,7 +302,7 @@ public void onNext(T t) {
 					b = bufferSupplier.get();
 				}
 				catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e));
+					onError(Exceptions.mapOperatorError(s, e, t));
 					return;
 				}
 
@@ -502,7 +502,7 @@ public void onNext(T t) {
 				try {
 					b = bufferSupplier.get();
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e));
+					onError(Exceptions.mapOperatorError(s, e, t));
 					return;
 				}
 

File: src/main/java/reactor/core/publisher/FluxBufferStartEnd.java
Patch:
@@ -314,7 +314,7 @@ void startNext(U u) {
 			try {
 				b = bufferSupplier.get();
 			} catch (Throwable e) {
-				anyError(Exceptions.mapOperatorError(starter, e));
+				anyError(Exceptions.mapOperatorError(starter, e, u));
 				return;
 			}
 			
@@ -339,7 +339,7 @@ void startNext(U u) {
 			try {
 				p = end.apply(u);
 			} catch (Throwable e) {
-				anyError(Exceptions.mapOperatorError(starter, e));
+				anyError(Exceptions.mapOperatorError(starter, e, u));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxCombineLatest.java
Patch:
@@ -437,13 +437,14 @@ void drainAsync() {
 					try {
 						w = combiner.apply(v.array);
 					} catch (Throwable ex) {
-						innerError(Exceptions.mapOperatorError(this, ex));
+						innerError(Exceptions.mapOperatorError(this, ex, v.array));
 						continue;
 					}
 					
 					if (w == null) {
 						innerError(Exceptions.mapOperatorError(this, new
-								NullPointerException("The combiner returned a null value")));
+								NullPointerException("The combiner returned a null " +
+								"value"), v.array));
 						continue;
 					}
 					

File: src/main/java/reactor/core/publisher/FluxDistinctUntilChanged.java
Patch:
@@ -106,7 +106,7 @@ public boolean tryOnNext(T t) {
 				k = keyExtractor.apply(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return true;
 			}
 
@@ -222,7 +222,7 @@ public void onNext(T t) {
 			try {
 				k = keyExtractor.apply(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 
@@ -247,7 +247,7 @@ public boolean tryOnNext(T t) {
 				k = keyExtractor.apply(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return true;
 			}
 

File: src/main/java/reactor/core/publisher/FluxDrop.java
Patch:
@@ -134,7 +134,7 @@ public void onNext(T t) {
 				try {
 					onDrop.accept(t);
 				} catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e));
+					onError(Exceptions.mapOperatorError(s, e, t));
 				}
 			}
 		}

File: src/main/java/reactor/core/publisher/FluxFlattenIterable.java
Patch:
@@ -306,7 +306,7 @@ void drainAsync() {
 						}
 						catch (Throwable exc) {
 							it = null;
-							onError(Exceptions.mapOperatorError(s, exc));
+							onError(Exceptions.mapOperatorError(s, exc, t));
 							continue;
 						}
 						
@@ -479,7 +479,7 @@ void drainSync() {
 						}
 						catch (Throwable exc) {
 							current = null;
-							a.onError(Exceptions.mapOperatorError(s, exc));
+							a.onError(Exceptions.mapOperatorError(s, exc, t));
 							return;
 						}
 

File: src/main/java/reactor/core/publisher/FluxPeek.java
Patch:
@@ -161,7 +161,7 @@ public void onNext(T t) {
 					parent.onNextCall().accept(t);
 				}
 				catch (Throwable e) {
-					onError(Exceptions.mapOperatorError(s, e));
+					onError(Exceptions.mapOperatorError(s, e, t));
 					return;
 				}
 			}
@@ -187,7 +187,7 @@ public void onError(Throwable t) {
 					parent.onAfterTerminateCall().run();
 				}
 				catch (Throwable e) {
-					Throwable _e = Exceptions.mapOperatorError(e);
+					Throwable _e = Exceptions.mapOperatorError(null, e, t);
 					e.addSuppressed(t);
 					if(parent.onErrorCall() != null) {
 						parent.onErrorCall().accept(_e);

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -243,9 +243,8 @@ public void onNext(T t) {
 				return;
 			}
 			if (!queue.offer(t)) {
-				s.cancel();
-				
-				error = new IllegalStateException("Queue is full?!");
+				error = Exceptions.mapOperatorError(s, new IllegalStateException
+						("Queue is full?!"), t);
 				done = true;
 			}
 			trySchedule();

File: src/main/java/reactor/core/publisher/FluxScan.java
Patch:
@@ -143,7 +143,7 @@ public void onNext(T t) {
 			try {
 				r = accumulator.apply(r, t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -102,7 +102,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 
@@ -132,7 +132,7 @@ public boolean tryOnNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 
 				return true;
 			}

File: src/main/java/reactor/core/publisher/FluxSkipWhile.java
Patch:
@@ -102,7 +102,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 
 				return;
 			}
@@ -134,7 +134,7 @@ public boolean tryOnNext(T t) {
 				b = predicate.test(t);
 			}
 			catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 
 				return true;
 			}

File: src/main/java/reactor/core/publisher/FluxSwitchMap.java
Patch:
@@ -181,13 +181,13 @@ public void onNext(T t) {
 			try {
 				p = mapper.apply(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 			
 			if (p == null) {
-				s.cancel();
-				onError(new NullPointerException("The mapper returned a null publisher"));
+				onError(Exceptions.mapOperatorError(s, new NullPointerException("The " +
+						"mapper returned a null publisher"), t));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -79,7 +79,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -91,7 +91,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxThrottleFirst.java
Patch:
@@ -142,7 +142,7 @@ public void onNext(T t) {
 					p = throttler.apply(t);
 				} catch (Throwable e) {
 					Operators.terminate(S, this);
-					error(Exceptions.mapOperatorError(s, e));
+					error(Exceptions.mapOperatorError(null, e, t));
 					return;
 				}
 				

File: src/main/java/reactor/core/publisher/FluxThrottleTimeout.java
Patch:
@@ -171,12 +171,13 @@ public void onNext(T t) {
 			try {
 				p = throttler.apply(t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(s, e));
+				onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 
 			if (p == null) {
-				onError(new NullPointerException("The throttler returned a null publisher"));
+				onError(Exceptions.mapOperatorError(s, new NullPointerException("The " +
+						"throttler returned a null publisher"), t));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -94,7 +94,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				subscriber.onError(Exceptions.mapOperatorError(s, e));
+				subscriber.onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 			if (!b) {

File: src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -95,7 +95,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				subscriber.onError(Exceptions.mapOperatorError(s, e));
+				subscriber.onError(Exceptions.mapOperatorError(s, e, t));
 				return;
 			}
 			if (b) {

File: src/main/java/reactor/core/publisher/MonoCollect.java
Patch:
@@ -115,7 +115,7 @@ public void onNext(T t) {
 			try {
 				action.accept(value, t);
 			} catch (Throwable e) {
-				onError(Exceptions.mapOperatorError(this, e));
+				onError(Exceptions.mapOperatorError(this, e, t));
 			}
 		}
 

File: src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -125,15 +125,15 @@ public void onNext(T t) {
             try {
                 p = mapper.apply(t);
             } catch (Throwable ex) {
-                actual.onError(Exceptions.mapOperatorError(this, ex));
+                actual.onError(Exceptions.mapOperatorError(this, ex, t));
                 return;
             }
             
             if (p == null) {
                 actual.onError(Exceptions.mapOperatorError(this, new NullPointerException
                         ("The mapper returned" +
                         " a null " +
-                        "Publisher.")));
+                        "Publisher."), t));
                 return;
             }
             
@@ -143,7 +143,7 @@ public void onNext(T t) {
                 try {
                     v = ((Callable<R>)p).call();
                 } catch (Throwable ex) {
-                    actual.onError(Exceptions.mapOperatorError(this, ex));
+                    actual.onError(Exceptions.mapOperatorError(this, ex, t));
                     return;
                 }
                 

File: src/main/java/reactor/core/publisher/MonoStreamCollector.java
Patch:
@@ -108,8 +108,7 @@ public void onNext(T t) {
 			try {
 				accumulator.accept(container, t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(s, ex));
-				return;
+				onError(Exceptions.mapOperatorError(s, ex, t));
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -64,12 +64,13 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = supplier.get();
 		} catch (Throwable e) {
-			s.onError(Exceptions.mapOperatorError(sds, e));
+			s.onError(Exceptions.mapOperatorError(e));
 			return;
 		}
 
 		if (t == null) {
-			s.onError(new NullPointerException("The callable returned null"));
+			s.onError(Exceptions.mapOperatorError(new NullPointerException("The " +
+					"callable returned null")));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/OperatorAdapter.java
Patch:
@@ -88,7 +88,7 @@ public final void onNext(I i) {
 			doNext(i);
 		}
 		catch (Throwable throwable) {
-			doOnSubscriberError(Exceptions.mapOperatorError(subscription, throwable));
+			doOnSubscriberError(Exceptions.mapOperatorError(subscription, throwable, i));
 		}
 	}
 

File: src/main/java/reactor/core/publisher/ParallelCollect.java
Patch:
@@ -133,8 +133,7 @@ public void onNext(T t) {
 			try {
 				collector.accept(collection, t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(this, ex));
-				return;
+				onError(Exceptions.mapOperatorError(this, ex, t));
 			}
 		}
 		

File: src/main/java/reactor/core/publisher/ParallelReduce.java
Patch:
@@ -133,13 +133,13 @@ public void onNext(T t) {
 			try {
 				v = reducer.apply(accumulator, t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(this, ex));
+				onError(Exceptions.mapOperatorError(this, ex, t));
 				return;
 			}
 			
 			if (v == null) {
-				cancel();
-				onError(new NullPointerException("The reducer returned a null value"));
+				onError(Exceptions.mapOperatorError(this, new NullPointerException("The" +
+						" reducer returned a null value"), t));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/ParallelUnorderedFilter.java
Patch:
@@ -108,7 +108,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(s, ex));
+				onError(Exceptions.mapOperatorError(s, ex, t));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/ParallelUnorderedMap.java
Patch:
@@ -109,13 +109,13 @@ public void onNext(T t) {
 			try {
 				v = mapper.apply(t);
 			} catch (Throwable ex) {
-				onError(Exceptions.mapOperatorError(s, ex));
+				onError(Exceptions.mapOperatorError(s, ex, t));
 				return;
 			}
 			
 			if (v == null) {
-				cancel();
-				onError(new NullPointerException("The mapper returned a null value"));
+				onError(Exceptions.mapOperatorError(s, new NullPointerException("The " +
+						"mapper returned a null value"), t));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2639,7 +2639,7 @@ public final Flux<T> doOnTerminate(Runnable onTerminate) {
 	 * @return a transforming {@link Flux} that emits tuples of time elapsed in milliseconds and matching data
 	 */
 	public final Flux<Tuple2<Long, T>> elapsed() {
-		return transform(f -> f.map(new Elapsed<>()));
+		return compose(f -> f.map(new Elapsed<>()));
 	}
 
 	/**

File: src/test/java/reactor/core/publisher/FluxPublishTest.java
Patch:
@@ -112,7 +112,7 @@ public void cancelComposes2() {
 	public void pairWise() {
 		TestSubscriber<Tuple2<Integer, Integer>> ts = TestSubscriber.create();
 
-		range(1, 9).compose(o -> zip(o, o.skip(1)))
+		range(1, 9).transform(o -> zip(o, o.skip(1)))
 		           .subscribe(ts);
 
 		ts.assertValues(Tuples.of(1, 2),

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -852,7 +852,7 @@ public void testParallelAsyncStream2() throws InterruptedException {
 			final String source = "ASYNC_TEST " + i;
 
 			Flux.just(source)
-			    .as(operationStream -> operationStream.publishOn(asyncGroup)
+			    .transform(operationStream -> operationStream.publishOn(asyncGroup)
 			                                          .delay(Duration.ofMillis(100))
 			                                          .map(s -> s + " MODIFIED")
 			                                          .map(s -> {

File: src/test/java/reactor/core/publisher/tck/FluxAndProcessorTests.java
Patch:
@@ -67,7 +67,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 		                                                                   .doOnNext(this::monitorThreadUse))
 		                                      .doOnNext(array -> cumulatedJoin.getAndIncrement())
 		                                      .subscribeWith(TopicProcessor.create("fluxion-raw-join", bufferSize))
-		                                      .as(Flux::from)
+		                                      .transform(Flux::from)
 		                                      .doOnError(Throwable::printStackTrace));
 	}
 

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2529,7 +2529,7 @@ public String toString() {
 	 * @see #compose(Function) for deferred composition of {@link Mono} for each {@link Subscriber}
 	 * @see #as for a loose conversion to an arbitrary type
 	 */
-	public final <V> Mono<V> transform(Function<? super Mono<T>, ? extends Mono<V>> transformer) {
+	public final <V> Mono<V> transform(Function<? super Mono<T>, ? extends Publisher<V>> transformer) {
 		return from(transformer.apply(this));
 	}
 

File: src/main/java/reactor/core/publisher/BlockingSink.java
Patch:
@@ -260,7 +260,7 @@ public Emission finish() {
 				return Emission.CANCELLED;
 			}
 			Exceptions.throwIfFatal(t);
-			uncaughtException = t;
+			uncaughtException = Exceptions.unwrap(t);
 			return Emission.FAILED;
 		}
 	}

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -346,9 +346,7 @@ public void onSubscribe(final Subscription s) {
 				}
 			}
 			catch (Throwable t) {
-				Exceptions.throwIfFatal(t);
-				s.cancel();
-				onError(t);
+				onError(Exceptions.mapOperatorError(s, t));
 			}
 		}
 	}

File: src/main/java/reactor/core/publisher/FluxCallable.java
Patch:
@@ -43,8 +43,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             v = callable.call();
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            s.onError(ex);
+            s.onError(Exceptions.mapOperatorError(null, ex));
             return;
         }
         

File: src/main/java/reactor/core/publisher/FluxCreate.java
Patch:
@@ -58,8 +58,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             emitter.accept(dfe);
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            dfe.fail(ex);
+            dfe.fail(Exceptions.mapOperatorError(null, ex));
         }
     }
     

File: src/main/java/reactor/core/publisher/FluxError.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Trackable;
 
 /**
@@ -75,7 +76,7 @@ public void subscribe(Subscriber<? super T> s) {
 		if (whenRequested) {
 			s.onSubscribe(new ErrorSubscription(s, e));
 		} else {
-			Operators.error(s, e);
+			Operators.error(s, Exceptions.mapOperatorError(null, e));
 		}
 	}
 	

File: src/main/java/reactor/core/publisher/FluxGenerate.java
Patch:
@@ -74,7 +74,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			state = stateSupplier.call();
 		} catch (Throwable e) {
-			Operators.error(s, e);
+			Operators.error(s, Exceptions.mapOperatorError(null, e));
 			return;
 		}
 		s.onSubscribe(new GenerateSubscription<>(s, state, generator, stateConsumer));
@@ -204,7 +204,7 @@ void fastPath() {
 				} catch (Throwable e) {
 					cleanup(s);
 
-					actual.onError(e);
+					actual.onError(Exceptions.mapOperatorError(null, e));
 					return;
 				}
 				if (terminate || cancelled) {

File: src/main/java/reactor/core/publisher/FluxIterable.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.Exceptions;
 import reactor.core.Fuseable;
 import reactor.core.Producer;
 import reactor.core.Receiver;
@@ -52,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			it = iterable.iterator();
 		} catch (Throwable e) {
-			Operators.error(s, e);
+			Operators.error(s, Exceptions.mapOperatorError(null, e));
 			return;
 		}
 
@@ -81,7 +82,7 @@ static <T> void subscribe(Subscriber<? super T> s, Iterator<? extends T> it) {
 		try {
 			b = it.hasNext();
 		} catch (Throwable e) {
-			Operators.error(s, e);
+			Operators.error(s, Exceptions.mapOperatorError(null, e));
 			return;
 		}
 		if (!b) {

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -71,8 +71,7 @@ public void subscribe(final Subscriber<? super T> subscriber) {
 			subscriber.onSubscribe(new WeakScalarSubscription<>(value, subscriber));
 		}
 		catch (Throwable throwable) {
-			Exceptions.throwIfFatal(throwable);
-			subscriber.onError(throwable);
+			subscriber.onError(Exceptions.mapOperatorError(null, throwable));
 		}
 	}
 

File: src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -235,9 +235,7 @@ public Object upstream() {
 
 	    void error(Throwable e){
 		    done = true;
-		    s.cancel();
-		    Exceptions.throwIfFatal(e);
-		    actual.onError(Exceptions.unwrap(e));
+		    actual.onError(Exceptions.mapOperatorError(s, e));
 	    }
 	    
 	    @Override

File: src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -89,8 +89,7 @@ public void onComplete() {
 			try {
 				b = predicate.getAsBoolean();
 			} catch (Throwable e) {
-				Exceptions.throwIfFatal(e);
-				subscriber.onError(Exceptions.unwrap(e));
+				subscriber.onError(Exceptions.mapOperatorError(null, e));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -68,13 +68,13 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			p = whenSourceFactory.apply(other);
 		} catch (Throwable e) {
-			Exceptions.throwIfFatal(e);
-			s.onError(Exceptions.unwrap(e));
+			s.onError(Exceptions.mapOperatorError(null, e));
 			return;
 		}
 
 		if (p == null) {
-			s.onError(new NullPointerException("The whenSourceFactory returned a null Publisher"));
+			s.onError(Exceptions.mapOperatorError(null, new NullPointerException("The " +
+					"whenSourceFactory returned a null Publisher")));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -89,9 +89,8 @@ public void onError(Throwable t) {
 				try {
 					p = nextFactory.apply(t);
 				} catch (Throwable e) {
-					Throwable _e = Exceptions.unwrap(e);
+					Throwable _e = Exceptions.mapOperatorError(null, e);
 					_e.addSuppressed(t);
-					Exceptions.throwIfFatal(e);
 					subscriber.onError(_e);
 					return;
 				}

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -89,8 +89,7 @@ public void onError(Throwable t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				Exceptions.throwIfFatal(e);
-				Throwable _t = Exceptions.unwrap(e);
+				Throwable _t = Exceptions.mapOperatorError(null, e);
 				_t.addSuppressed(t);
 				subscriber.onError(_t);
 				return;

File: src/main/java/reactor/core/publisher/FluxStream.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.stream.Stream;
 
 import org.reactivestreams.Subscriber;
+import reactor.core.Exceptions;
 import reactor.core.Receiver;
 
 /**
@@ -52,7 +53,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			it = stream.iterator();
 		} catch (Throwable e) {
-			Operators.error(s, e);
+			Operators.error(s, Exceptions.mapOperatorError(null, e));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -62,13 +62,13 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			worker = scheduler.createWorker();
 		} catch (Throwable e) {
-			Exceptions.throwIfFatal(e);
-			Operators.error(s, e);
+			Operators.error(s, Exceptions.mapOperatorError(null, e));
 			return;
 		}
 		
 		if (worker == null) {
-			Operators.error(s, new NullPointerException("The scheduler returned a null Function"));
+			Operators.error(s, Exceptions.mapOperatorError(null, new
+					NullPointerException("The scheduler returned a null Function")));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/FluxSubscribeOnCallable.java
Patch:
@@ -208,8 +208,7 @@ public void run() {
 				v = callable.call();
 			}
 			catch (Throwable ex) {
-				Exceptions.throwIfFatal(ex);
-				actual.onError(ex);
+				actual.onError(Exceptions.mapOperatorError(this, ex));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -79,9 +79,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				s.cancel();
-				Exceptions.throwIfFatal(e);
-				onError(Exceptions.unwrap(e));
+				onError(Exceptions.mapOperatorError(s, e));
 
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxTakeWhile.java
Patch:
@@ -91,9 +91,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable e) {
-				s.cancel();
-				Exceptions.throwIfFatal(e);
-				onError(Exceptions.unwrap(e));
+				onError(Exceptions.mapOperatorError(s, e));
 
 				return;
 			}

File: src/main/java/reactor/core/publisher/FluxThrottleFirst.java
Patch:
@@ -142,8 +142,7 @@ public void onNext(T t) {
 					p = throttler.apply(t);
 				} catch (Throwable e) {
 					Operators.terminate(S, this);
-					Exceptions.throwIfFatal(e);
-					error(Exceptions.unwrap(e));
+					error(Exceptions.mapOperatorError(s, e));
 					return;
 				}
 				

File: src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -134,9 +134,7 @@ public void onNext(T t) {
 			try {
 				p = itemTimeout.apply(t);
 			} catch (Throwable e) {
-				cancel();
-				Exceptions.throwIfFatal(e);
-				subscriber.onError(Exceptions.unwrap(e));
+				subscriber.onError(Exceptions.mapOperatorError(this, e));
 				return;
 			}
 

File: src/main/java/reactor/core/publisher/FluxWindow.java
Patch:
@@ -92,12 +92,13 @@ public void subscribe(Subscriber<? super Flux<T>> s) {
 			try {
 				overflowQueue = overflowQueueSupplier.get();
 			} catch (Throwable e) {
-				Operators.error(s, e);
+				Operators.error(s, Exceptions.mapOperatorError(null, e));
 				return;
 			}
 			
 			if (overflowQueue == null) {
-				Operators.error(s, new NullPointerException("The overflowQueueSupplier returned a null queue"));
+				Operators.error(s, Exceptions.mapOperatorError(null, new
+						NullPointerException("The overflowQueueSupplier returned a null queue")));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -154,8 +154,7 @@ public void onNext(T t) {
 				try {
 					r = combiner.apply(t, u);
 				} catch (Throwable e) {
-					Exceptions.throwIfFatal(e);
-					onError(Exceptions.unwrap(e));
+					onError(Exceptions.mapOperatorError(this, e));
 					return;
 				}
 

File: src/main/java/reactor/core/publisher/MonoAggregate.java
Patch:
@@ -84,11 +84,9 @@ public void onNext(T t) {
 				try {
 					r = aggregator.apply(r, t);
 				} catch (Throwable ex) {
-					Exceptions.throwIfFatal(ex);
-					s.cancel();
 					result = null;
 					done = true;
-					subscriber.onError(ex);
+					subscriber.onError(Exceptions.mapOperatorError(s, ex));
 					return;
 				}
 				

File: src/main/java/reactor/core/publisher/MonoAll.java
Patch:
@@ -94,9 +94,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				s.cancel();
-				Exceptions.throwIfFatal(e);
-				subscriber.onError(Exceptions.unwrap(e));
+				subscriber.onError(Exceptions.mapOperatorError(s, e));
 				return;
 			}
 			if (!b) {

File: src/main/java/reactor/core/publisher/MonoAny.java
Patch:
@@ -95,9 +95,7 @@ public void onNext(T t) {
 				b = predicate.test(t);
 			} catch (Throwable e) {
 				done = true;
-				s.cancel();
-				Exceptions.throwIfFatal(e);
-				subscriber.onError(Exceptions.unwrap(e));
+				subscriber.onError(Exceptions.mapOperatorError(s, e));
 				return;
 			}
 			if (b) {

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -65,13 +65,13 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = callable.call();
 		} catch (Throwable e) {
-			Exceptions.throwIfFatal(e);
-			s.onError(Exceptions.unwrap(e));
+			s.onError(Exceptions.mapOperatorError(null, e));
 			return;
 		}
 
 		if (t == null) {
-			s.onError(new NullPointerException("The callable returned null"));
+			s.onError(Exceptions.mapOperatorError(null, new NullPointerException("The " +
+					"callable returned null")));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/MonoCallableOrEmpty.java
Patch:
@@ -65,8 +65,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = callable.call();
 		} catch (Throwable e) {
-			Exceptions.throwIfFatal(e);
-			s.onError(Exceptions.unwrap(e));
+			s.onError(Exceptions.mapOperatorError(null, e));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/MonoCreate.java
Patch:
@@ -46,8 +46,7 @@ public void subscribe(Subscriber<? super T> s) {
         try {
             callback.accept(emitter);
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            emitter.fail(ex);
+            emitter.fail(Exceptions.mapOperatorError(null, ex));
         }
     }
 

File: src/main/java/reactor/core/publisher/MonoDelay.java
Patch:
@@ -92,8 +92,7 @@ public void run() {
 				}
 				}
 				catch (Throwable t){
-					Exceptions.throwIfFatal(t);
-					s.onError(t);
+					s.onError(Exceptions.mapOperatorError(null, t));
 				}
 			} else {
 				s.onError(new IllegalStateException("Could not emit value due to lack of requests"));

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -72,7 +72,7 @@ public void subscribe(Subscriber<? super T> s) {
 			e = new NullPointerException("The Throwable returned by the supplier is null");
 		}
 
-		Operators.error(s, e);
+		Operators.error(s, Exceptions.mapOperatorError(null, e));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoRunnable.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Objects;
 
 import org.reactivestreams.Subscriber;
-import rx.exceptions.Exceptions;
+import reactor.core.Exceptions;
 
 /**
  * Executes the runnable whenever a Subscriber subscribes to this Mono.
@@ -37,8 +37,7 @@ public void subscribe(Subscriber<? super Void> s) {
         try {
             run.run();
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            Operators.error(s, ex);
+            Operators.error(s, Exceptions.mapOperatorError(null, ex));
             return;
         }
         Operators.complete(s);

File: src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -164,8 +164,7 @@ public void onComplete() {
 					try {
 						t = ds.get();
 					} catch (Throwable e) {
-						Exceptions.throwIfFatal(e);
-						subscriber.onError(Exceptions.unwrap(e));
+						subscriber.onError(Exceptions.mapOperatorError(this, e));
 						return;
 					}
 

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -64,8 +64,7 @@ public void subscribe(Subscriber<? super T> s) {
 		try {
 			t = supplier.get();
 		} catch (Throwable e) {
-			Exceptions.throwIfFatal(e);
-			s.onError(Exceptions.unwrap(e));
+			s.onError(Exceptions.mapOperatorError(sds, e));
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/ParallelUnorderedFilter.java
Patch:
@@ -108,9 +108,7 @@ public void onNext(T t) {
 			try {
 				b = predicate.test(t);
 			} catch (Throwable ex) {
-				Exceptions.throwIfFatal(ex);
-				cancel();
-				onError(Exceptions.unwrap(ex));
+				onError(Exceptions.mapOperatorError(s, ex));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/ParallelUnorderedMap.java
Patch:
@@ -109,9 +109,7 @@ public void onNext(T t) {
 			try {
 				v = mapper.apply(t);
 			} catch (Throwable ex) {
-				Exceptions.throwIfFatal(ex);
-				cancel();
-				onError(Exceptions.unwrap(ex));
+				onError(Exceptions.mapOperatorError(s, ex));
 				return;
 			}
 			

File: src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -886,8 +886,7 @@ else if (processor.terminated == FORCED_SHUTDOWN) {
 							}
 							continue;
 						}
-						Exceptions.throwIfFatal(ex);
-						subscriber.onError(ex);
+						subscriber.onError(Exceptions.mapOperatorError(null, ex));
 						sequence.set(nextSequence);
 						nextSequence++;
 					}

File: src/main/java/reactor/util/Logger.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.util;
 
 /**
- * Logger interface designed for internal Loggers usage.
+ * Logger interface designed for internal Reactor usage.
  */
 public interface Logger {
 

File: src/main/java/reactor/util/Loggers.java
Patch:
@@ -19,7 +19,8 @@
 import java.util.regex.Matcher;
 
 /**
- * Expose common Loggers runtime properties, methods and internal logger.
+ * Expose static methods to get a logger depending on the environment (SLF4J or
+ * {@link java.util.logging.Logger}).
  */
 public abstract class Loggers {
 

File: src/main/java/reactor/util/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * Miscellaneous utility classes, such as tuples or queue suppliers and implementations.
+ * Miscellaneous utility classes, such as loggers, tuples or queue suppliers and implementations.
  */
 package reactor.util;
\ No newline at end of file

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4115,7 +4115,7 @@ public final Flux<T> scan(BiFunction<T, T, T> accumulator) {
 	 *
 	 */
 	public final <A> Flux<A> scan(A initial, BiFunction<A, ? super T, A> accumulator) {
-		return scanWith(() -> initial, accumulator))
+		return scanWith(() -> initial, accumulator);
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -2249,7 +2249,7 @@ public final Mono<T> subscribeOn(Scheduler scheduler) {
 			}
 			@SuppressWarnings("unchecked")
 			Callable<T> c = (Callable<T>)this;
-			return onAssembly(new MonoSubscribeOnCallable<T>(c,
+			return onAssembly(new MonoSubscribeOnCallable<>(c,
 					scheduler));
 		}
 		return onAssembly(new MonoSubscribeOn<>(this, scheduler));

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1977,7 +1977,7 @@ public final Flux<T> repeat(long numRepeat) {
 	 *
 	 */
 	public final Flux<T> repeat(long numRepeat, BooleanSupplier predicate) {
-		return repeat(Flux.countingBooleanSupplier(predicate, numRepeat));
+		return Flux.defer(() -> repeat(Flux.countingBooleanSupplier(predicate, numRepeat)));
 	}
 
 	/**
@@ -2127,7 +2127,7 @@ public final Mono<T> retry(Predicate<Throwable> retryMatcher) {
 	 *
 	 */
 	public final Mono<T> retry(long numRetries, Predicate<Throwable> retryMatcher) {
-		return retry(Flux.countingPredicate(retryMatcher, numRetries));
+		return defer(() -> retry(Flux.countingPredicate(retryMatcher, numRetries)));
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/EventLoopProcessor.java
Patch:
@@ -34,7 +34,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.MultiProducer;
 import reactor.core.Producer;
-import reactor.core.Reactor;
 import reactor.core.Receiver;
 import reactor.util.Exceptions;
 import reactor.util.concurrent.QueueSupplier;
@@ -295,7 +294,8 @@ static Sequence wrap(Sequence init, Object delegate){
 
 		contextClassLoader = new EventLoopContext();
 
-		String name = threadFactory instanceof Supplier ? ((Supplier)
+		@SuppressWarnings("rawtypes")
+        String name = threadFactory instanceof Supplier ? ((Supplier)
 				threadFactory).get().toString() : null;
 		this.name = null != name ? name : getClass().getSimpleName();
 
@@ -655,7 +655,6 @@ final static class EventLoopFactory
 
 		static final AtomicInteger COUNT = new AtomicInteger();
 
-		private static final long serialVersionUID = -3202326942393105842L;
 		final String  name;
 		final boolean daemon;
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4512,7 +4512,7 @@ public final Cancellation subscribe(Consumer<? super T> consumer,
 					new LambdaSubscriber<>(consumer, errorConsumer, completeConsumer);
 		}
 		else {
-			consumerAction = new BoundedSubscriber<T>((int) c,
+			consumerAction = new BoundedSubscriber<>((int) c,
 					consumer,
 					errorConsumer,
 					completeConsumer);
@@ -4546,7 +4546,7 @@ public final Flux<T> subscribeOn(Scheduler scheduler) {
 			}
 			@SuppressWarnings("unchecked")
 			Callable<T> c = (Callable<T>)this;
-			return onAssembly(new FluxSubscribeOnCallable<T>(c, scheduler));
+			return onAssembly(new FluxSubscribeOnCallable<>(c, scheduler));
 		}
 		return onAssembly(new FluxSubscribeOn<>(this, scheduler));
 	}

File: src/main/java/reactor/core/publisher/FluxBatch.java
Patch:
@@ -109,6 +109,7 @@ public final boolean isFailed() {
 		/**
 		 * @return has this {@link Subscriber} been cancelled
 		 */
+		@Override
 		public final boolean isCancelled() {
 			return terminated == TERMINATED_WITH_CANCEL;
 		}

File: src/main/java/reactor/core/publisher/MonoNever.java
Patch:
@@ -15,7 +15,6 @@
  */
 package reactor.core.publisher;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.Trackable;
 

File: src/main/java/reactor/core/publisher/SynchronousSink.java
Patch:
@@ -16,7 +16,6 @@
 package reactor.core.publisher;
 
 import org.reactivestreams.Subscriber;
-import reactor.core.Trackable;
 
 /**
  * Interface to generate signals to a bridged {@link Subscriber}.

File: src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -29,7 +29,6 @@
 import reactor.core.scheduler.Scheduler;
 import reactor.core.scheduler.Schedulers;
 import reactor.test.TestSubscriber;
-import reactor.core.Reactor;
 
 public class ScatterGatherTests {
 

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -32,7 +32,6 @@
 import reactor.core.Receiver;
 import reactor.core.Trackable;
 import reactor.util.Exceptions;
-import reactor.util.concurrent.RingBuffer;
 import reactor.util.concurrent.WaitStrategy;
 
 /**
@@ -580,7 +579,7 @@ public void subscribe(Subscriber s) {
 			AtomicIntegerFieldUpdater.newUpdater(MonoProcessor.class, "connected");
     @SuppressWarnings("rawtypes")
 	final static AtomicReferenceFieldUpdater<MonoProcessor, Processor> PROCESSOR =
-		    RingBuffer.newAtomicReferenceFieldUpdater(MonoProcessor.class,
+		    AtomicReferenceFieldUpdater.newUpdater(MonoProcessor.class, Processor.class,
 				    "processor");
 	final static int       STATE_CANCELLED         = -1;
 	final static int       STATE_READY             = 0;

File: src/main/java/reactor/core/publisher/WorkQueueProcessor.java
Patch:
@@ -511,8 +511,8 @@ public static <E> WorkQueueProcessor<E> share(ExecutorService executor,
 
 	@SuppressWarnings("rawtypes")
 	final static AtomicReferenceFieldUpdater<WorkQueueProcessor, RingBuffer> RETRY_REF =
-			RingBuffer
-			.newAtomicReferenceFieldUpdater(WorkQueueProcessor.class, "retryBuffer");
+			AtomicReferenceFieldUpdater.newUpdater(WorkQueueProcessor.class,
+					RingBuffer.class, "retryBuffer");
 
 	final WaitStrategy writeWait;
 

File: src/main/java/reactor/test/TestSubscriber.java
Patch:
@@ -37,9 +37,8 @@
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.publisher.Operators;
 import reactor.core.Trackable;
-import reactor.util.concurrent.RingBuffer;
+import reactor.core.publisher.Operators;
 
 /**
  * A Subscriber implementation that hosts assertion tests for its state and allows
@@ -98,7 +97,8 @@ public class TestSubscriber<T>
 
 	@SuppressWarnings("rawtypes")
 	private static final AtomicReferenceFieldUpdater<TestSubscriber, List> NEXT_VALUES =
-			RingBuffer.newAtomicReferenceFieldUpdater(TestSubscriber.class, "values");
+			AtomicReferenceFieldUpdater.newUpdater(TestSubscriber.class, List.class,
+					"values");
 
 	private static final AtomicReferenceFieldUpdater<TestSubscriber, Subscription> S =
 			AtomicReferenceFieldUpdater.newUpdater(TestSubscriber.class, Subscription.class, "s");

File: src/main/java/reactor/util/concurrent/QueueSupplier.java
Patch:
@@ -60,6 +60,7 @@ public static int ceilingNextPowerOfTwo(final int x) {
 	 * @param <T> the reified {@link Queue} generic type
 	 * @return an unbounded or bounded {@link Queue} {@link Supplier}
 	 */
+	@SuppressWarnings("unchecked")
 	public static <T> Supplier<Queue<T>> get(int batchSize) {
 		if (batchSize == Integer.MAX_VALUE) {
 			return CLQ_SUPPLIER;

File: src/main/java/reactor/core/publisher/SignalType.java
Patch:
@@ -20,5 +20,5 @@
  * Reactive Stream notification type
  */
 public enum SignalType {
-	request, onSubscribe, onNext, onError, onComplete, cancel, graph
+	REQUEST, ON_SUBSCRIBE, ON_NEXT, ON_ERROR, ON_COMPLETE, CANCEL, GRAPH
 }

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -33,7 +33,6 @@
 import reactor.core.MultiReceiver;
 import reactor.core.Producer;
 import reactor.core.Receiver;
-import reactor.core.subscriber.ScalarSubscription;
 import reactor.core.subscriber.SubscriberState;
 import reactor.core.subscriber.SubscriptionHelper;
 import reactor.util.Exceptions;
@@ -171,7 +170,7 @@ static <T, R> boolean trySubscribeScalarMap(
 				}
 
 				if (v != null) {
-					s.onSubscribe(new ScalarSubscription<>(s, v));
+					s.onSubscribe(new Operators.ScalarSubscription<>(s, v));
 				} else {
 					SubscriptionHelper.complete(s);
 				}

File: src/main/java/reactor/core/publisher/FluxRange.java
Patch:
@@ -20,7 +20,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Producer;
-import reactor.core.subscriber.ScalarSubscription;
 import reactor.core.subscriber.SubscriberState;
 import reactor.core.subscriber.SubscriptionHelper;
 
@@ -60,7 +59,7 @@ public void subscribe(Subscriber<? super Integer> s) {
 			return;
 		} else
 		if (st + 1 == en) {
-			s.onSubscribe(new ScalarSubscription<>(s, (int)st));
+			s.onSubscribe(new Operators.ScalarSubscription<>(s, (int)st));
 			return;
 		}
 		

File: src/main/java/reactor/core/publisher/MonoFlatMap.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.reactivestreams.*;
 
-import reactor.core.subscriber.ScalarSubscription;
 import reactor.core.subscriber.SubscriptionHelper;
 import reactor.util.*;
 
@@ -151,7 +150,7 @@ public void onNext(T t) {
                 if (v == null) {
                     actual.onComplete();
                 } else {
-                    onSubscribeInner(new ScalarSubscription<>(actual, v));
+                    onSubscribeInner(new Operators.ScalarSubscription<>(actual, v));
                 }
                 
                 return;

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -20,8 +20,6 @@
 import org.reactivestreams.Subscriber;
 import reactor.core.Fuseable;
 import reactor.core.Receiver;
-import reactor.core.subscriber.ScalarSubscription;
-
 
 /**
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
@@ -48,7 +46,7 @@ public T block() {
 
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		s.onSubscribe(new ScalarSubscription<>(s, value));
+		s.onSubscribe(new Operators.ScalarSubscription<>(s, value));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -30,7 +30,6 @@
 import reactor.core.Cancellation;
 import reactor.core.Producer;
 import reactor.core.Receiver;
-import reactor.core.subscriber.ScalarSubscription;
 import reactor.core.subscriber.SubscriberState;
 import reactor.core.subscriber.SubscriptionHelper;
 import reactor.util.Exceptions;
@@ -419,7 +418,7 @@ public void subscribe(final Subscriber<? super O> subscriber) {
 				return;
 			}
 			else if (endState == STATE_SUCCESS_VALUE) {
-				subscriber.onSubscribe(new ScalarSubscription<>(subscriber, value));
+				subscriber.onSubscribe(new Operators.ScalarSubscription<>(subscriber, value));
 				return;
 			}
 			else if (endState == STATE_ERROR) {

File: src/main/java/reactor/test/subscriber/TestSubscriber.java
Patch:
@@ -35,7 +35,9 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.Fuseable;
+import reactor.core.Receiver;
 import reactor.core.subscriber.DeferredSubscription;
+import reactor.core.subscriber.SubscriberState;
 import reactor.core.subscriber.SubscriptionHelper;
 import reactor.util.ReactorProperties;
 
@@ -84,7 +86,7 @@
  * @author Brian Clozel
  */
 public class TestSubscriber<T> extends DeferredSubscription
-		implements Subscriber<T> {
+		implements Subscriber<T>, Subscription, SubscriberState, Receiver {
 
 	/**
 	 * Default timeout for waiting next values to be received

File: src/main/java/reactor/core/subscriber/MultiSubscriptionSubscriber.java
Patch:
@@ -131,7 +131,7 @@ public final void set(Subscription s) {
 		}
 
 		Subscription a = MISSED_SUBSCRIPTION.getAndSet(this, s);
-		if (a != null && shouldCancelCurrent()) {
+		if (a != null) {
 			a.cancel();
 		}
 		drain();

File: src/main/java/reactor/core/subscriber/SubscriberState.java
Patch:
@@ -21,7 +21,8 @@
 public interface SubscriberState {
 
 	/**
-	 * FIXME
+	 * Returned value when a given component does not provide access to the requested
+	 * trait
 	 */
 	long UNSPECIFIED = -1L;
 

File: src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -55,7 +55,7 @@ public MonoCallableOnAssembly(Publisher<? extends T> source) {
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public T block(long timeout) {
+	public T blockMillis(long timeout) {
 		try {
 			return ((Callable<T>)source).call();
 		} catch (Throwable e) {

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -148,7 +148,7 @@ public long expectedFromUpstream() {
 	 * not completed
 	 */
 	@Override
-	public O block(long timeout) {
+	public O blockMillis(long timeout) {
 		try {
 			if (!isPending()) {
 				return peek();

File: src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -46,7 +46,7 @@ public void someEmpty() {
     @Test//(timeout = 5000)
     public void all2NonEmpty() {
         Assert.assertEquals(Tuple.of(0L, 0L), 
-                Mono.when(Mono.delay(150), Mono.delay(250)).block()
+                Mono.when(Mono.delayMillis(150), Mono.delayMillis(250)).block()
         );
     }
     

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1134,7 +1134,7 @@ public void delayEach() throws InterruptedException {
 		CountDownLatch latch = new CountDownLatch(3);
 
 		Flux.range(1, 3)
-		       .delay(1)
+		       .delayMillis(1000)
 		       .log("delay")
 		       .subscribe(t -> latch.countDown());
 

File: src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -70,10 +70,10 @@ public void promiseOnAfter() throws Exception {
 
 	@Test
 	public void promiseDelays() throws Exception {
-		Tuple2<Long, String> h = Mono.delay(3000)
+		Tuple2<Long, String> h = Mono.delayMillis(3000)
 		                             .log("time1")
 		                             .map(d -> "Spring wins")
-		                             .or(Mono.delay(2000).log("time2").map(d -> "Spring Reactive"))
+		                             .or(Mono.delayMillis(2000).log("time2").map(d -> "Spring Reactive"))
 		                             .then(t -> Mono.just(t+ " world"))
 		                             .elapsed()
 		                             .block();

File: src/main/java/reactor/core/publisher/MonoCallableOnAssembly.java
Patch:
@@ -55,7 +55,7 @@ public MonoCallableOnAssembly(Publisher<? extends T> source) {
 
 	@Override
 	@SuppressWarnings("unchecked")
-	public T block(long timeout) {
+	public T blockMillis(long timeout) {
 		try {
 			return ((Callable<T>)source).call();
 		} catch (Throwable e) {

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -148,7 +148,7 @@ public long expectedFromUpstream() {
 	 * not completed
 	 */
 	@Override
-	public O block(long timeout) {
+	public O blockMillis(long timeout) {
 		try {
 			if (!isPending()) {
 				return peek();

File: src/test/java/reactor/core/publisher/MonoWhenTest.java
Patch:
@@ -46,7 +46,7 @@ public void someEmpty() {
     @Test//(timeout = 5000)
     public void all2NonEmpty() {
         Assert.assertEquals(Tuple.of(0L, 0L), 
-                Mono.when(Mono.delay(150), Mono.delay(250)).block()
+                Mono.when(Mono.delayMillis(150), Mono.delayMillis(250)).block()
         );
     }
     

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1134,7 +1134,7 @@ public void delayEach() throws InterruptedException {
 		CountDownLatch latch = new CountDownLatch(3);
 
 		Flux.range(1, 3)
-		       .delay(1)
+		       .delayMillis(1000)
 		       .log("delay")
 		       .subscribe(t -> latch.countDown());
 

File: src/test/java/reactor/core/publisher/scenarios/MonoTests.java
Patch:
@@ -70,10 +70,10 @@ public void promiseOnAfter() throws Exception {
 
 	@Test
 	public void promiseDelays() throws Exception {
-		Tuple2<Long, String> h = Mono.delay(3000)
+		Tuple2<Long, String> h = Mono.delayMillis(3000)
 		                             .log("time1")
 		                             .map(d -> "Spring wins")
-		                             .or(Mono.delay(2000).log("time2").map(d -> "Spring Reactive"))
+		                             .or(Mono.delayMillis(2000).log("time2").map(d -> "Spring Reactive"))
 		                             .then(t -> Mono.just(t+ " world"))
 		                             .elapsed()
 		                             .block();

File: src/test/java/reactor/core/publisher/scenarios/ScatterGatherTests.java
Patch:
@@ -104,9 +104,9 @@ public void testTrace2() throws Exception {
 		catch(Exception e){
 			e.printStackTrace();
 			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains
-					("ScatterGatherTests.java:95"));
+					("ScatterGatherTests.java:96"));
 			Assert.assertTrue(e.getSuppressed()[0].getMessage().contains("|_\tMono.map" +
-					"(ScatterGatherTests.java:95)"));
+					"(ScatterGatherTests.java:96)"));
 			return;
 		}
 		finally {

File: src/main/java/reactor/core/util/package-info.java
Patch:
@@ -17,7 +17,7 @@
 /**
  * Core utility functions to work with Reactive components, specifically:
  * {@link org.reactivestreams.Subscription}, {@link reactor.core.util.BackpressureUtils backpressure}, {@link reactor.core.util.Logger logging}, {@link reactor.core.util.Exceptions Exception} handling,
- * {@link reactor.core.util.ReactiveStateUtils traits} or the {@link reactor.core.util.PlatformDependent environment}
+ * or the {@link reactor.core.util.PlatformDependent environment}
  * settings.
  *
  * @author Stephane Maldini

File: src/test/java/reactor/core/publisher/scenarios/CombinationTests.java
Patch:
@@ -236,7 +236,6 @@ public void sampleConcatTest() throws Exception {
 		Publisher<SensorData> p = Flux.concat(sensorEven(), sensorOdd())
 		                              .log("concat");
 
-		//System.out.println(tail.debug());
 		generateData(elements);
 
 		awaitLatch(p, latch);

File: src/main/java/reactor/core/publisher/ConnectableFluxProcess.java
Patch:
@@ -35,7 +35,7 @@
  * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  * @since 2.5
  */
-final class ConnectableFluxProcess<T, U> extends ConnectableFlux<U> implements Receiver, Producer {
+final class ConnectableFluxProcess<T, U> extends ConnectableFlux<U> implements Producer {
 
 	final Publisher<T>												 source;
 	final Supplier<? extends Processor<? super T, ? extends T>>		processorSupplier;

File: src/main/java/reactor/core/publisher/ConnectableFluxPublish.java
Patch:
@@ -52,7 +52,7 @@
  * @since 2.5
  */
 final class ConnectableFluxPublish<T> extends ConnectableFlux<T>
-		implements Receiver, Loopback, Backpressurable {
+		implements Loopback, Backpressurable {
 	/** The source observable. */
 	final Publisher<? extends T> source;
 	

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -528,7 +528,7 @@ static final class UnicastGroupedFlux<K, V> extends GroupedFlux<K, V>
 		final int limit;
 
 		@Override
-		public K getId() {
+		public K key() {
 			return key;
 		}
 		

File: src/main/java/reactor/core/publisher/GroupedFlux.java
Patch:
@@ -27,6 +27,5 @@ public abstract class GroupedFlux<K, V> extends Flux<V> {
 	 * Return defined identifier
 	 * @return defined identifier
 	 */
-	@Override
-	public abstract K getId();
+	public abstract K key();
 }

File: src/main/java/reactor/core/publisher/ParallelGroup.java
Patch:
@@ -83,7 +83,7 @@ public ParallelInnerGroup(int key) {
         }
         
         @Override
-        public Integer getId() {
+        public Integer key() {
             return key;
         }
         

File: src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -463,7 +463,8 @@ public static TimedScheduler newTimer(String name, int resolution) {
 	 * @return a new {@link TimedScheduler}
 	 */
 	public static TimedScheduler newTimer(String name, int resolution, int bufferSize) {
-		HashWheelTimer t = new HashWheelTimer(name, resolution, bufferSize, WaitStrategy.parking(), null);
+		HashWheelTimer t = new HashWheelTimer(name, resolution, bufferSize,
+				WaitStrategy.sleeping(), null);
 		t.start();
 		return t;
 	}

File: src/main/java/reactor/core/queue/SpscLinkedArrayQueue.java
Patch:
@@ -99,8 +99,8 @@ public T poll() {
             a = b;
             consumerArray = b;
         }
-        CONSUMER_INDEX.lazySet(this, ci + 1);
         a.lazySet(offset, null);
+        CONSUMER_INDEX.lazySet(this, ci + 1);
         
         return (T)o;
     }

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -504,9 +504,11 @@ void drainFused(ReplaySubscription<T> rp) {
 					return;
 				}
 
+				boolean d = done;
+
 				a.onNext(null);
 
-				if (done) {
+				if (d) {
 					Throwable ex = error;
 					if (ex != null) {
 						a.onError(ex);

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -150,7 +150,7 @@ public T poll() {
 
 		@Override
 		public boolean isEmpty() {
-			return !terminado;
+			return terminado;
 		}
 
 		@Override

File: src/test/java/reactor/core/publisher/ParallelFluxTest.java
Patch:
@@ -180,7 +180,6 @@ public void parallelReduceFull() {
 					    .parallel(i)
 					    .runOn(scheduler)
 					    .reduce((a, b) -> a + b)
-					    .log()
 					    .subscribe(ts);
 
 					ts.await(Duration.ofSeconds(500));

File: src/main/java/reactor/core/publisher/FluxRepeatPredicate.java
Patch:
@@ -32,7 +32,7 @@
  */
 
 /**
- * {@see <a href='https://github.com/reactor/reactive-streams-commons'>Reactive-Streams-Commons</a>}
+ * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  * @since 2.5
  */
 final class FluxRepeatPredicate<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/FluxRetryPredicate.java
Patch:
@@ -32,7 +32,7 @@
  */
 
 /**
- * {@see <a href='https://github.com/reactor/reactive-streams-commons'>Reactive-Streams-Commons</a>}
+ * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  * @since 2.5
  */
 final class FluxRetryPredicate<T> extends FluxSource<T, T> {

File: src/main/java/reactor/core/publisher/MonoRetryPredicate.java
Patch:
@@ -30,7 +30,7 @@
  */
 
 /**
- * {@see <a href='https://github.com/reactor/reactive-streams-commons'>Reactive-Streams-Commons</a>}
+ * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
  * @since 2.5
  */
 final class MonoRetryPredicate<T> extends MonoSource<T, T> {

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -132,7 +132,7 @@ public class TestSubscriber<T> extends DeferredSubscription implements Subscribe
 	 * Create a new {@link TestSubscriber} that requests an unbounded number of elements.
 	 * <p>Be sure at least a publisher has subscribed to it via {@link Publisher#subscribe(Subscriber)}
 	 * before use assert methods.
-	 * @see TestSubscriber#subscribe(Publisher)
+	 * @see #subscribe(Publisher)
 	 */
 	public static <T> TestSubscriber<T> create() {
 		return new TestSubscriber<>();
@@ -144,7 +144,7 @@ public static <T> TestSubscriber<T> create() {
 	 * <p>Be sure at least a publisher has subscribed to it via {@link Publisher#subscribe(Subscriber)}
 	 * before use assert methods.
 	 * @param n Number of elements to request (can be 0 if you want no initial demand).
-	 * @see TestSubscriber{@link #subscribe(Publisher, long)}
+	 * @see #subscribe(Publisher, long)
 	 */
 	public static <T> TestSubscriber<T> create(long n) {
 		return new TestSubscriber<>(n);

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1916,7 +1916,7 @@ public final Mono<T> otherwiseReturn(final T fallback) {
 	 * Fallback to the given value if an error of a given type is observed on this
 	 * {@link Flux}
 	 * <p>
-	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/onerrorreturn.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/otherwisereturn.png" alt="">
 	 * @param type the error type to match
 	 * @param fallbackValue alternate value on fallback
 	 * @param <E> the error type
@@ -1933,7 +1933,7 @@ public final <E extends Throwable> Mono<T> otherwiseReturn(Class<E> type,
 	 * observed on this
 	 * {@link Flux}
 	 * <p>
-	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/onerrorreturn.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/otherwisereturn.png" alt="">
 	 * @param predicate the error predicate to match
 	 * @param fallbackValue alternate value on fallback
 	 * @param <E> the error type

File: src/main/java/reactor/core/scheduler/Schedulers.java
Patch:
@@ -59,8 +59,8 @@ public class Schedulers {
 	public static Scheduler computation() {
 		return managedSchedulers.computeIfAbsent(COMPUTATION, k -> new ManagedScheduler(k,
 						newComputation(k,
-								Runtime.getRuntime()
-								       .availableProcessors(),
+								(Runtime.getRuntime()
+								        .availableProcessors() + 1) / 2,
 								true)));
 	}
 

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -303,7 +303,7 @@ public final TestSubscriber<T> assertError(Class<? extends Throwable> clazz) {
 			Throwable e = errors.get(0);
 			if (!clazz.isInstance(e)) {
 				throw new AssertionError("Error class incompatible: expected = " +
-						clazz.getSimpleName() + ", actual = " + clazz, null);
+						clazz + ", actual = " + e, null);
 			}
 		}
 		if (s > 1) {

File: src/test/java/reactor/core/test/TestSubscriberTests.java
Patch:
@@ -115,6 +115,8 @@ public void assertError() {
 		}
 		catch (AssertionError e) {
 			Assert.assertNotNull(e);
+			Assert.assertEquals("Error class incompatible: expected = class java.io.IOException, " +
+								"actual = java.lang.IllegalStateException", e.getMessage());
 		}
 		catch(Throwable e) {
 			Assert.fail();

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -525,7 +525,7 @@ public final TestSubscriber<T> awaitAndAssertNextValuesWith(Consumer<T>... expec
 					valueCount - nextValueAssertedCount,
 					expectedValueCount,
 					valuesTimeout.toMillis());
-		}, () -> valueCount == (nextValueAssertedCount + expectedValueCount));
+		}, () -> valueCount >= (nextValueAssertedCount + expectedValueCount));
 		List<T> nextValuesSnapshot;
 		List<T> empty = new ArrayList<>();
 		for(;;){
@@ -534,7 +534,7 @@ public final TestSubscriber<T> awaitAndAssertNextValuesWith(Consumer<T>... expec
 				break;
 			}
 		}
-		if (nextValuesSnapshot.size() != expectedValueCount) {
+		if (nextValuesSnapshot.size() < expectedValueCount) {
 			throw new AssertionError(String.format("Expected %d number of signals but received %d",
 					expectedValueCount,
 					nextValuesSnapshot.size()));

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -86,8 +86,7 @@
  * @see Flux
  * @since 2.5
  */
-public abstract class Mono<T> implements Publisher<T>, Backpressurable, Introspectable,
-                                         Completable {
+public abstract class Mono<T> implements Publisher<T>, Backpressurable, Introspectable {
 
 	static final Mono<?> NEVER = MonoSource.from(FluxNever.instance());
 

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.Objects;
 import java.util.concurrent.Callable;
-import java.util.function.Supplier;
 
 import org.reactivestreams.Subscriber;
 

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -33,7 +33,7 @@
  * @since 2.5
  */
 final class MonoError<T> 
-extends Mono<T> {
+extends Mono<T> implements reactor.core.state.Completable {
 
 	final Supplier<? extends Throwable> supplier;
 

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -57,7 +57,8 @@
  */
 public final class MonoProcessor<O> extends Mono<O>
 		implements Processor<O, O>, Cancellation, Subscription, Cancellable, Receiver, Producer,
-		           Prefetchable, MonoEmitter<O>, LongSupplier {
+		           Prefetchable, MonoEmitter<O>, LongSupplier,
+		           reactor.core.state.Completable {
 
 	/**
 	 * Create a {@link MonoProcessor} that will eagerly request 1 on {@link #onSubscribe(Subscription)}, cache and emit

File: src/main/java/reactor/core/publisher/MonoUsing.java
Patch:
@@ -17,16 +17,13 @@
 
 import java.util.Objects;
 import java.util.concurrent.Callable;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Consumer;
 import java.util.function.Function;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
 import reactor.core.flow.Fuseable;
 import reactor.core.flow.Receiver;
-import reactor.core.util.BackpressureUtils;
 import reactor.core.util.EmptySubscription;
 import reactor.core.util.Exceptions;
 

File: src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -21,9 +21,7 @@
 
 import org.reactivestreams.*;
 
-import reactor.core.flow.Fuseable;
 import reactor.core.subscriber.DeferredScalarSubscriber;
-import reactor.core.tuple.*;
 import reactor.core.util.*;
 
 /**

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1802,7 +1802,8 @@ public final Flux<List<T>> buffer(int maxSize, final Duration timespan, final Ti
 	 * @return a replaying {@link Flux}
 	 */
 	public final Flux<T> cache() {
-		return cache(getPrefetchOrDefault(PlatformDependent.SMALL_BUFFER_SIZE));
+		return process(ReplayProcessor.create(PlatformDependent.SMALL_BUFFER_SIZE, true))
+				.autoConnect();
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -117,8 +117,8 @@ public static <E> ReplayProcessor<E> create(int historySize) {
 	 * Create a new {@link ReplayProcessor} using {@link PlatformDependent#SMALL_BUFFER_SIZE} backlog size, blockingWait
 	 * Strategy and auto-cancel.
 	 *
-	 * @param historySize
-	 * @param  unbounded
+	 * @param historySize maximum items retained if bounded, or link size if unbounded
+	 * @param  unbounded true if "unlimited" data store must be supplied
 	 *
 	 * @param <E> Type of processed signals
 	 * @return a fresh processor

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -1076,7 +1076,7 @@ public void shouldCorrectlyDispatchBatchedTimeout() throws InterruptedException
 		             .partition(parallelStreams)
 		             .log("batched-inner")
 		             .subscribe(innerStream -> innerStream.publishOn(asyncGroup)
-		                                                .doOnError(Exception.class, Throwable::printStackTrace)
+		                                                .doOnError(Throwable::printStackTrace)
 		                                                .subscribe(i -> latch.countDown()));
 
 		streamBatcher.onNext(12);

File: src/test/java/reactor/core/publisher/tck/FluxAndProcessorTests.java
Patch:
@@ -65,7 +65,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 		                                      .doOnNext(array -> cumulatedJoin.getAndIncrement())
 		                                      .subscribeWith(TopicProcessor.create("fluxion-raw-join", bufferSize))
 		                                      .as(Flux::from)
-		                                      .doOnError(Throwable.class, Throwable::printStackTrace));
+		                                      .doOnError(Throwable::printStackTrace));
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/tck/FluxWithSchedulerTests.java
Patch:
@@ -70,7 +70,7 @@ public Processor<Integer, Integer> createProcessor(int bufferSize) {
 				                          .flatMap(i -> Flux.zip(Flux.just(i), otherStream, combinator))
 				 )
 				 .publishOn(sharedGroup)
-				 .doOnError(Throwable.class, Throwable::printStackTrace));
+				 .doOnError(Throwable::printStackTrace));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2572,7 +2572,7 @@ public final Flux<T> everyFirst(int batchSize) {
 	 *
 	 */
 	public final Mono<Boolean> exists(Predicate<? super T> predicate) {
-		return new MonoAny<>(this, predicate);
+		return new MonoExist<>(this, predicate);
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/MonoExist.java
Patch:
@@ -41,11 +41,11 @@
  * {@see https://github.com/reactor/reactive-streams-commons}
  * @since 2.5
  */
-final class MonoAny<T> extends MonoSource<T, Boolean> implements Fuseable {
+final class MonoExist<T> extends MonoSource<T, Boolean> implements Fuseable {
 
 	final Predicate<? super T> predicate;
 
-	public MonoAny(Publisher<? extends T> source, Predicate<? super T> predicate) {
+	public MonoExist(Publisher<? extends T> source, Predicate<? super T> predicate) {
 		super(source);
 		this.predicate = Objects.requireNonNull(predicate, "predicate");
 	}

File: src/test/java/reactor/core/publisher/MonoCountTest.java
Patch:
@@ -29,7 +29,7 @@ public void sourceNull() {
 	public void normal() {
 		TestSubscriber<Long> ts = new TestSubscriber<>();
 
-		new MonoCount<>(new FluxRange(1, 10)).subscribe(ts);
+		Flux.range(1, 10).count().subscribe(ts);
 
 		ts.assertValues(10L)
 		  .assertComplete()
@@ -39,7 +39,7 @@ public void normal() {
 	public void normalBackpressured() {
 		TestSubscriber<Long> ts = new TestSubscriber<>(0);
 
-		new MonoCount<>(new FluxRange(1, 10)).subscribe(ts);
+		Flux.range(1, 10).count().subscribe(ts);
 
 		ts.assertNoValues()
 		  .assertNotComplete()

File: src/main/java/reactor/core/publisher/MonoThenApply.java
Patch:
@@ -208,7 +208,7 @@ public void onNext(R t) {
             @Override
             public void onError(Throwable t) {
                 if (done) {
-                    Exceptions.onNextDropped(t);
+                    Exceptions.onErrorDropped(t);
                     return;
                 }
                 done = true;

File: src/main/java/reactor/core/scheduler/GlobalTimer.java
Patch:
@@ -39,7 +39,7 @@ public static Timer globalOrNew() {
 		Timer timer = context.timer;
 
 		if (timer == null) {
-			timer = new Timer(50, 64, WaitStrategy.sleeping());
+			timer = new Timer(50, 64, WaitStrategy.parking());
 			timer.start();
 		}
 		return timer;
@@ -56,7 +56,7 @@ static final class GlobalContext{
 	static final GlobalContext context = new GlobalContext();
 
 	GlobalTimer() {
-		super("global-timer", 50, DEFAULT_WHEEL_SIZE, WaitStrategy.sleeping(), null);
+		super("global-timer", 50, DEFAULT_WHEEL_SIZE, WaitStrategy.parking(), null);
 	}
 
 	void _cancel() {

File: src/main/java/reactor/core/scheduler/Timer.java
Patch:
@@ -119,7 +119,7 @@ public static Timer create(int resolution, int bufferSize) {
 	 *                   return a new {@link Timer}
 	 */
 	public static Timer create(String name, int resolution, int bufferSize) {
-		Timer timer = new Timer(name, resolution, bufferSize, WaitStrategy.sleeping(), null);
+		Timer timer = new Timer(name, resolution, bufferSize, WaitStrategy.parking(), null);
 		timer.start();
 		return timer;
 	}

File: src/main/java/reactor/core/publisher/MonoThenApply.java
Patch:
@@ -195,6 +195,7 @@ public void onNext(R t) {
                     Exceptions.onNextDropped(t);
                     return;
                 }
+                done = true;
                 this.parent.complete(t);
             }
 

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -85,7 +85,8 @@ public class TestSubscriber<T> extends DeferredSubscription implements Subscribe
 
 	volatile List<T> values = new LinkedList<>();
 
-	private static final AtomicReferenceFieldUpdater<TestSubscriber, List> NEXT_VALUES =
+	@SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<TestSubscriber, List> NEXT_VALUES =
 			PlatformDependent.newAtomicReferenceFieldUpdater(TestSubscriber.class, "values");
 
 	final List<Throwable> errors = new LinkedList<>();

File: src/main/java/reactor/core/publisher/MonoThenApply.java
Patch:
@@ -50,7 +50,7 @@ public MonoThenApply(Publisher<? extends T> source, Function<? super T, ? extend
 	@Override
 	public void subscribe(Subscriber<? super R> s) {
 
-		if (FluxFlatMap.trySubscribeScalarMap(source, s, mapper)) {
+		if (FluxFlatMap.trySubscribeScalarMap(source, s, mapper, true)) {
 			return;
 		}
 

File: src/main/java/reactor/core/publisher/FluxConcatMap.java
Patch:
@@ -82,8 +82,8 @@ public FluxConcatMap(Publisher<? extends T> source,
 	
 	@Override
 	public void subscribe(Subscriber<? super R> s) {
-		
-		if (FluxFlatMap.trySubscribeScalarMap(source, s, mapper)) {
+
+		if (FluxFlatMap.trySubscribeScalarMap(source, s, mapper, false)) {
 			return;
 		}
 		

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4268,9 +4268,7 @@ public Stream<T> stream(int batchSize) {
 	 * @return a {@link Cancellation} task to execute to dispose and cancel the underlying {@link Subscription}
 	 */
 	public final Cancellation subscribe() {
-		LambdaSubscriber<T> s = new LambdaSubscriber<>();
-		subscribe(s);
-		return s;
+		return subscribe(null, null, null);
 	}
 
 

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.Objects;
 
 import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
 import reactor.core.flow.Fuseable;
 import reactor.core.flow.Loopback;
 import reactor.core.flow.Receiver;
@@ -57,7 +56,6 @@ final class FluxJust<T> extends Flux<T> implements Fuseable.ScalarCallable<T>, F
 
 	final T value;
 
-	@SuppressWarnings("unchecked")
 	public FluxJust(T value) {
 		this.value = Objects.requireNonNull(value, "value");
 	}
@@ -88,7 +86,7 @@ public Object connectedOutput() {
 		return value;
 	}
 
-	static final class WeakScalarSubscription<T> implements QueueSubscription, Receiver, Completable {
+	static final class WeakScalarSubscription<T> implements QueueSubscription<T>, Receiver, Completable {
 
 		boolean terminado;
 		final T                     value;

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -166,10 +166,10 @@ public void subscribe(Subscriber<? super T> s) {
 		if (add(rp)) {
 			if (rp.cancelled) {
 				remove(rp);
+				return;
 			}
-		} else {
-			buffer.drain(rp);
 		}
+		buffer.drain(rp);
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -210,7 +210,7 @@ public void callbackError(){
 		Throwable err = new Exception("test");
 
 		new FluxPeek<>(new FluxJust<>(1),
-				null, d -> Exceptions.propagate(err),
+				null, d -> {throw Exceptions.propagate(err);},
 				null,
 				null,
 				null,
@@ -225,7 +225,7 @@ public void callbackError(){
 
 		try {
 			new FluxPeek<>(new FluxJust<>(1),
-					null, d -> Exceptions.bubble(err),
+					null, d -> {throw Exceptions.bubble(err);},
 					null,
 					null,
 					null,

File: src/main/java/reactor/core/publisher/MonoSingle.java
Patch:
@@ -182,8 +182,7 @@ public void onComplete() {
 					subscriber.onError(new NoSuchElementException("Source was empty"));
 				}
 			} else if (c == 1) {
-				subscriber.onNext(value);
-				subscriber.onComplete();
+				complete(value);
 			}
 		}
 

File: src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @param <T> the source value types
  */
-final class MonoWhen<T> extends Mono<T[]> implements Fuseable {
+final class MonoWhen<T> extends Mono<T[]>  {
 
     final boolean delayError;
     

File: src/main/java/reactor/core/publisher/MonoSupplier.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Subscriber;
 
+import reactor.core.flow.Fuseable;
 import reactor.core.flow.Receiver;
 import reactor.core.subscriber.DeferredScalarSubscriber;
 import reactor.core.util.Exceptions;
@@ -37,7 +38,7 @@
  */
 final class MonoSupplier<T> 
 extends Mono<T>
-		implements Receiver, Callable<T> {
+		implements Receiver, Callable<T>, Fuseable {
 
 	final Supplier<? extends T> supplier;
 

File: src/main/java/reactor/core/publisher/MonoTakeLastOne.java
Patch:
@@ -16,20 +16,21 @@
 package reactor.core.publisher;
 
 import org.reactivestreams.*;
+import reactor.core.flow.Fuseable;
 
 /**
  * Take the very last value from a Publisher source and and emit that one.
  *
  * @param <T> the value type
  */
-final class MonoTakeLastOne<T> extends MonoSource<T, T> {
+final class MonoTakeLastOne<T> extends MonoSource<T, T> implements Fuseable {
 
     public MonoTakeLastOne(Publisher<? extends T> source) {
         super(source);
     }
 
     @Override
     public void subscribe(Subscriber<? super T> s) {
-        source.subscribe(new FluxTakeLast.TakeLastOneSubscriber<>(s));
+        source.subscribe(new FluxTakeLastOne.TakeLastOneSubscriber<>(s));
     }
 }

File: src/main/java/reactor/core/scheduler/GlobalTimer.java
Patch:
@@ -94,8 +94,8 @@ static Timer get() {
 		while (null == t) {
 				t = new GlobalTimer();
 				if (!GLOBAL_TIMER.compareAndSet(context, null, t)) {
-					t = context.timer;
 					t._cancel();
+					t = context.timer;
 				}
 				else{
 					t.start();

File: src/main/java/reactor/core/scheduler/Timer.java
Patch:
@@ -274,6 +274,9 @@ public long getPeriod() {
 	@Override
 	public void shutdown() {
 		this.loop.interrupt();
+		if(executor instanceof ExecutorService){
+			((ExecutorService)executor).shutdown();
+		}
 	}
 
 	/**

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -733,8 +733,8 @@ public final TestSubscriber<T> assertFusionMode(int expectedMode) {
 	 * @return this
 	 */
 	public final TestSubscriber<T> assertFusionEnabled() {
-		if (establishedFusionMode == Fuseable.SYNC
-				|| establishedFusionMode == Fuseable.ASYNC) {
+		if (establishedFusionMode != Fuseable.SYNC
+				&& establishedFusionMode != Fuseable.ASYNC) {
 			throw new AssertionError("Fusion was not enabled");
 		}
 		return this;

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -602,7 +602,7 @@ public BoundedBuffer(int limit) {
 
 		@Override
 		public int capacity() {
-			return size;
+			return limit;
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/ReplayProcessor.java
Patch:
@@ -365,7 +365,7 @@ public UnboundedBuffer(int batchSize) {
 
 		@Override
 		public int capacity() {
-			return size;
+			return batchSize;
 		}
 
 		@Override

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2529,7 +2529,7 @@ public final Flux<T> doOnTerminate(Runnable onTerminate) {
 
 	/**
 	 * Map this {@link Flux} sequence into {@link reactor.core.tuple.Tuple2} of T1 {@link Long} timemillis and T2
-	 * {@link T} associated data. The timemillis corresponds to the elapsed time between the subscribe and the first
+	 * {@code T} associated data. The timemillis corresponds to the elapsed time between the subscribe and the first
 	 * next signal OR between two next signals.
 	 *
 	 * <p>
@@ -4701,7 +4701,7 @@ public final <U, V> Flux<T> timeout(Publisher<U> firstTimeout,
 
 	/**
 	 * Emit a {@link reactor.core.tuple.Tuple2} pair of T1 {@link Long} current system time in
-	 * millis and T2 {@link T} associated data for each item from this {@link Flux}
+	 * millis and T2 {@code T} associated data for each item from this {@link Flux}
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/timestamp.png" alt="">

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1352,7 +1352,7 @@ public final Mono<T> doOnTerminate(BiConsumer<? super T, Throwable> onTerminate)
 
 	/**
 	 * Map this {@link Mono} sequence into {@link reactor.core.tuple.Tuple2} of T1 {@link Long} timemillis and T2
-	 * {@link T} associated data. The timemillis corresponds to the elapsed time between the subscribe and the first
+	 * {@code T} associated data. The timemillis corresponds to the elapsed time between the subscribe and the first
 	 * next signal.
 	 *
 	 * <p>
@@ -2572,7 +2572,7 @@ public final <U> Mono<T> timeout(Publisher<U> firstTimeout, Mono<? extends T> fa
 
 	/**
 	 * Emit a {@link reactor.core.tuple.Tuple2} pair of T1 {@link Long} current system time in
-	 * millis and T2 {@link T} associated data for the eventual item from this {@link Mono}
+	 * millis and T2 {@code T} associated data for the eventual item from this {@link Mono}
 	 *
 	 * <p>
 	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/timestamp1.png" alt="">

File: src/main/java/reactor/core/publisher/UnicastProcessor.java
Patch:
@@ -22,6 +22,7 @@
 
 import reactor.core.flow.*;
 import reactor.core.queue.QueueSupplier;
+import reactor.core.scheduler.Scheduler;
 import reactor.core.state.*;
 import reactor.core.util.*;
 
@@ -60,7 +61,7 @@ public static <T> UnicastProcessor<T> create() {
 	 * @return a serializing {@link FluxProcessor}
 	 */
 	public static <T> UnicastProcessor<T> create(Queue<T> queue) {
-		return create(queue, null);
+		return create(queue, () -> {});
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/package-info.java
Patch:
@@ -30,7 +30,9 @@
  * {@link org.reactivestreams.Processor} extending {@link reactor.core.publisher.FluxProcessor} are available:
  * <ul>
  *         <li>A synchronous/non-opinionated pub-sub replaying capable event emitter :
- *         {@link reactor.core.publisher.EmitterProcessor} and {@link reactor.core.publisher.EmitterProcessor#replay}</li>
+ *         {@link reactor.core.publisher.EmitterProcessor},
+ *         {@link reactor.core.publisher.ReplayProcessor} and </li>
+ *         {@link reactor.core.publisher.UnicastProcessor}</li>
  *          </li>
  *         <li>A dedicated parallel pub-sub event buffering broadcaster :
  *         {@link reactor.core.publisher.TopicProcessor}</li>

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1908,7 +1908,7 @@ public final <R, A> Mono<R> collect(Collector<T, A, R> collector) {
 	public final <V> Flux<V> compose(Function<? super Flux<T>, ?
 			extends Publisher<V>>
 			transformer) {
-		return as(flux -> defer(() -> transformer.apply(flux)));
+		return defer(() -> transformer.apply(this));
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/MonoSingleEmitter.java
Patch:
@@ -22,8 +22,7 @@
 
 import reactor.core.flow.Cancellation;
 import reactor.core.subscriber.SingleEmitter;
-import reactor.core.util.BackpressureUtils;
-import rx.exceptions.Exceptions;
+import reactor.core.util.*;
 
 /**
  * Wraps a the downstream Subscriber into a single emission object
@@ -114,6 +113,8 @@ public void error(Throwable e) {
             if (STATE.getAndSet(this, HAS_REQUEST_HAS_VALUE) != HAS_REQUEST_HAS_VALUE) {
                 cancellation = CANCELLED;
                 actual.onError(e);
+            } else {
+                Exceptions.onErrorDropped(e);
             }
         }
 

File: src/main/java/reactor/core/flow/Fuseable.java
Patch:
@@ -196,6 +196,7 @@ default int requestFusion(int requestedMode) {
 	 * @param <T> the value type returned
 	 */
 	interface ScalarCallable<T> extends Callable<T> {
-
+        @Override
+        T call();
 	}
 }
\ No newline at end of file

File: src/main/java/reactor/core/publisher/FluxJust.java
Patch:
@@ -62,7 +62,7 @@ public FluxJust(T value) {
 	}
 
 	@Override
-	public T call() throws Exception {
+	public T call() {
 		return value;
 	}
 

File: src/main/java/reactor/core/publisher/MonoEmpty.java
Patch:
@@ -60,7 +60,7 @@ public static <T> Mono<T> instance() {
 	}
 
 	@Override
-	public Object call() throws Exception {
+	public Object call() {
 		return null; /* Scalar optimizations on empty */
 	}
 

File: src/main/java/reactor/core/publisher/MonoJust.java
Patch:
@@ -38,7 +38,7 @@ public MonoJust(T value) {
 	}
 
 	@Override
-	public T call() throws Exception {
+	public T call() {
 		return value;
 	}
 

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -256,8 +256,8 @@ public void promiseErrorCountCannotExceedOne() {
 		Throwable error = new Exception();
 		try {
 			deferred.onError(error);
-			fail();
 			deferred.onNext(error);
+			fail();
 		}
 		catch (Exceptions.UpstreamException ise) {
 			// Swallow
@@ -271,8 +271,8 @@ public void promiseAcceptCountAndErrorCountCannotExceedOneInTotal() {
 		Throwable error = new Exception();
 		try {
 			deferred.onError(error);
-			fail();
 			deferred.onNext("alpha");
+			fail();
 		}
 		catch (Exceptions.ReactiveException ise) {
 		}

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1835,7 +1835,7 @@ public final Mono<T> repeatWhenEmpty(int maxRepeat, Function<Flux<Long>, ? exten
 					.apply(o
 						.takeWhile(e -> !nonEmpty.get())
 						.zipWith(iterations, 1, (c, i) -> i)))
-				.single();
+				.next();
 		});
 	}
 

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -980,7 +980,7 @@ public static <T> Flux<T> onErrorResumeWith(
 	 * @param <T> {@link Subscriber} type target
 	 * @return a {@link Flux} handling error if exceptions match otherwise an rejected Flux
 	 */
-	public final Flux<T> onErrorResumeWith(
+	public static <T> Flux<T> onErrorResumeWith(
 			Class<? extends Throwable> errorType,
 			Publisher<? extends T> source,
 			Supplier<Publisher<? extends T>> fallback) {

File: src/test/java/reactor/core/publisher/FluxMapSignalTest.java
Patch:
@@ -20,7 +20,6 @@
 import reactor.core.test.TestSubscriber;
 
 public class FluxMapSignalTest {
-
     @Test
     public void completeOnlyBackpressured() {
         TestSubscriber<Integer> ts = new TestSubscriber<>(0L);
@@ -56,4 +55,5 @@ public void errorOnlyBackpressured() {
         .assertNoError()
         .assertComplete();
     }
+
 }

File: src/main/java/reactor/core/publisher/MonoWhen.java
Patch:
@@ -165,7 +165,7 @@ void signal() {
                 subscriber.onError(compositeError);
             } else
             if (error != null) {
-                subscriber.onError(compositeError);
+                subscriber.onError(error);
             } else
             if (hasEmpty) {
                 subscriber.onComplete();

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -578,7 +578,7 @@ public static <T1, T2, T3, T4, T5, T6> Mono<Tuple6<T1, T2, T3, T4, T5, T6>> when
 	 */
 	@SafeVarargs
 	@SuppressWarnings({"unchecked","varargs"})
-	private static <T> Mono<T[]> when(Mono<? extends T>... monos) {
+	public static <T> Mono<T[]> when(Mono<? extends T>... monos) {
 		return new MonoWhen<>(monos).map(v -> (T[])v.toArray());
 	}
 

File: src/test/java/reactor/core/publisher/scenarios/FluxTests.java
Patch:
@@ -774,7 +774,7 @@ public void shouldNotFlushStreamOnTimeoutPrematurely() throws Exception {
 
 		assertEquals(NUM_MESSAGES, messagesProcessed);
 		assertTrue("Less than 90% (" + NUM_MESSAGES / BATCH_SIZE * TOLERANCE +
-						") of the batches are matching the buffer() size: " + batchesDistribution.get(BATCH_SIZE),
+						") of the batches are matching the buffer size: " + batchesDistribution.get(BATCH_SIZE),
 				NUM_MESSAGES / BATCH_SIZE * TOLERANCE >= batchesDistribution.get(BATCH_SIZE) * TOLERANCE);
 	}
 

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -582,7 +582,7 @@ private static <T> Mono<T[]> when(Mono<? extends T>... monos) {
      */
 	@SafeVarargs
 	@SuppressWarnings({"unchecked","varargs"})
-	private static <T> Mono<T[]> when(T defaultValue, Mono<? extends T>... monos) {
+	private static <T> Mono<T[]> whenDefault(T defaultValue, Mono<? extends T>... monos) {
 	    Mono<T>[] newMonos = new Mono[monos.length];
 	    for (int i = 0; i < monos.length; i++) {
 	        newMonos[i] = ((Mono<T>)monos[i]).defaultIfEmpty(defaultValue);
@@ -644,7 +644,7 @@ public static <T> Mono<T[]> when(final Iterable<? extends Mono<? extends T>> mon
      * @return a {@link Mono}.
      */
     @SuppressWarnings("unchecked")
-    public static <T> Mono<T[]> when(T defaultValue, final Iterable<? extends Mono<? extends T>> monos) {
+    public static <T> Mono<T[]> whenDefault(T defaultValue, final Iterable<? extends Mono<? extends T>> monos) {
         return zip(array -> (T[])array, new MapIterable<>(monos, m -> ((Mono<T>)m).defaultIfEmpty(defaultValue)));
     }
 

File: src/main/java/reactor/core/publisher/FluxPublishOn.java
Patch:
@@ -81,7 +81,7 @@ public FluxPublishOn(
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
 		
-		if (source instanceof Supplier) {
+		if (source instanceof Fuseable.ScalarSupplier) {
 			FluxSubscribeOn.scalarScheduleOn(source, s, scheduler);
 			return;
 		}

File: src/main/java/reactor/core/publisher/FluxSubscribeOn.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.Objects;
 import java.util.concurrent.atomic.*;
-import java.util.function.Supplier;
 
 import org.reactivestreams.*;
 
@@ -50,7 +49,7 @@ public FluxSubscribeOn(
 
 	public static <T> void scalarScheduleOn(Publisher<? extends T> source, Subscriber<? super T> s, Scheduler scheduler) {
 		@SuppressWarnings("unchecked")
-		Supplier<T> supplier = (Supplier<T>) source;
+		Fuseable.ScalarSupplier<T> supplier = (Fuseable.ScalarSupplier<T>) source;
 		
 		T v = supplier.get();
 		
@@ -66,7 +65,7 @@ public static <T> void scalarScheduleOn(Publisher<? extends T> source, Subscribe
 	
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
-		if (source instanceof Supplier) {
+		if (source instanceof Fuseable.ScalarSupplier) {
 			scalarScheduleOn(source, s, scheduler);
 			return;
 		}

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -4545,7 +4545,7 @@ public final Mono<List<T>> toList() {
                 
                 T v = scalarSupplier.get();
                 if (v == null) {
-                    return Mono.empty();
+                    return new MonoSupplier<>(LIST_SUPPLIER);
                 }
                 
                 return Mono.just(v).map(u -> {

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1500,7 +1500,7 @@ public final Mono<Void> after() {
 	 */
 	@SuppressWarnings("unchecked")
 	public final <V> Flux<V> after(Publisher<V> other) {
-		return after(() -> other);
+		return (Flux<V>)concat(this, other);
 	}
 
 	/**
@@ -1517,7 +1517,7 @@ public final <V> Flux<V> after(Publisher<V> other) {
 	 */
 	@SuppressWarnings("unchecked")
 	public final <V> Flux<V> after(Supplier<? extends Publisher<V>> afterSupplier) {
-		return flatMap(null, null, afterSupplier);
+		return (Flux<V>)concat(this, defer(afterSupplier));
 	}
 
 	/**

File: src/main/java/reactor/core/scheduler/Timer.java
Patch:
@@ -404,7 +404,7 @@ public Cancellation schedule(Runnable task, long delay, TimeUnit unit) {
 			if (isInterrupted() || !isAlive()) {
 				throw Exceptions.failWithCancel();
 			}
-			long delayMs = unit.convert(delay, TimeUnit.MILLISECONDS);
+			long delayMs = TimeUnit.MILLISECONDS.convert(delay, unit);
 
 			if (delay != 0) {
 				checkResolution(delayMs, resolution);
@@ -427,8 +427,8 @@ public Cancellation schedulePeriodically(Runnable task, long initialDelay, long
 			if (isInterrupted() || !isAlive()) {
 				throw Exceptions.failWithCancel();
 			}
-			long periodMs = unit.convert(period, TimeUnit.MILLISECONDS);
-			long initialDelayMs = unit.convert(initialDelay, TimeUnit.MILLISECONDS);
+			long periodMs = TimeUnit.MILLISECONDS.convert(period, unit);
+			long initialDelayMs = TimeUnit.MILLISECONDS.convert(initialDelay, unit);
 
 			if (initialDelay != 0) {
 				checkResolution(initialDelayMs, resolution);

File: src/main/java/reactor/core/scheduler/Timer.java
Patch:
@@ -262,7 +262,7 @@ public Cancellation schedule(Runnable task, long delay, TimeUnit unit) {
 
 	@Override
 	public Cancellation schedulePeriodically(Runnable task, long initialDelay, long period, TimeUnit unit) {
-		return null;
+		return loop.schedulePeriodically(task, initialDelay, period, unit);
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2739,7 +2739,7 @@ public final <R> Flux<R> flatMap(Function<? super T, ? extends Publisher<? exten
 
 	/**
 	 * Transform the items emitted by this {@link Flux} into {@link Iterable}, then flatten the elements from those by
-	 * merging them into a single {@link Flux}, so that they may interleave. The prefetch argument allows to give an
+	 * merging them into a single {@link Flux}. The prefetch argument allows to give an
 	 * arbitrary prefetch size to the merged {@link Iterable}.
 	 *
 	 * <p>
@@ -2757,7 +2757,7 @@ public final <R> Flux<R> flatMapIterable(Function<? super T, ? extends Iterable<
 
 	/**
 	 * Transform the items emitted by this {@link Flux} into Publishers, then flatten the emissions from those by
-	 * merging them into a single {@link Flux}, so that they may interleave. The prefetch argument allows to give an
+	 * merging them into a single {@link Flux}. The prefetch argument allows to give an
 	 * arbitrary prefetch size to the merged {@link Iterable}.
 	 *
 	 * <p>

File: src/test/java/reactor/core/publisher/tck/SchedulerGroupAsyncTests.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.Test;
 import org.reactivestreams.Processor;
 import org.testng.SkipException;
+import reactor.core.publisher.EmitterProcessor;
 import reactor.core.publisher.FluxProcessor;
 import reactor.core.publisher.SchedulerGroup;
 import reactor.core.scheduler.Scheduler;

File: src/test/java/reactor/core/publisher/tck/SchedulerGroupIOTests.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.Processor;
 import org.testng.SkipException;
+import reactor.core.publisher.EmitterProcessor;
 import reactor.core.publisher.FluxProcessor;
 import reactor.core.publisher.SchedulerGroup;
 import reactor.core.scheduler.Scheduler;

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -83,7 +83,7 @@ public T get() {
 		try {
 			return callable.call();
 		} catch (Throwable e) {
-			throw Exceptions.propagate(e);
+			throw Exceptions.bubble(e);
 		}
 	}
 }

File: src/main/java/reactor/core/publisher/MonoError.java
Patch:
@@ -57,7 +57,7 @@ public Throwable getError() {
 
 	@Override
 	public T get() {
-		throw Exceptions.fail(getError());
+		throw Exceptions.propagate(getError());
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -136,7 +136,7 @@ else if(subscription == null) {
 						if (error instanceof RuntimeException) {
 							throw (RuntimeException) error;
 						}
-						throw Exceptions.fail(error);
+						throw Exceptions.propagate(error);
 					case STATE_COMPLETE_NO_VALUE:
 						return null;
 				}

File: src/main/java/reactor/core/scheduler/Timer.java
Patch:
@@ -315,7 +315,7 @@ public long period() {
 
 	static void checkResolution(long time, long resolution) {
 		if (time % resolution != 0) {
-			throw Exceptions.failUpstream(new IllegalArgumentException(
+			throw Exceptions.bubble(new IllegalArgumentException(
 					"Period must be a multiple of Timer resolution (e.g. period % resolution == 0 ). " +
 							"Resolution for this Timer is: " + resolution + "ms"
 			));

File: src/test/java/reactor/core/publisher/FluxPeekTest.java
Patch:
@@ -198,7 +198,7 @@ public void callbackError(){
 
 		new FluxPeek<>(new FluxJust<>(1),
 				null,
-				d -> { throw Exceptions.fail(err); },
+				d -> { throw Exceptions.propagate(err); },
 				null,
 				null,
 				null,
@@ -214,7 +214,7 @@ public void callbackError(){
 		try {
 			new FluxPeek<>(new FluxJust<>(1),
 					null,
-					d -> { throw Exceptions.failUpstream(err); },
+					d -> { throw Exceptions.bubble(err); },
 					null,
 					null,
 					null,

File: src/test/java/reactor/core/publisher/tck/SchedulerGroupIOTests.java
Patch:
@@ -66,7 +66,7 @@ public void simpleTest() throws Exception {
 				Thread.sleep(1000);
 			}
 			catch(InterruptedException ie){
-				throw Exceptions.fail(ie);
+				throw Exceptions.propagate(ie);
 			}
 		};
 		r.schedule(() -> c.accept("Hello World!"));

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -142,15 +142,15 @@ else if(subscription == null) {
 				}
 				if (delay < System.currentTimeMillis()) {
 					cancel();
-					throw Exceptions.failWithCancel();
+					throw new IllegalStateException("Timeout on Mono blocking read");
 				}
 				Thread.sleep(1);
 			}
 		}
 		catch (InterruptedException ie) {
 			Thread.currentThread().interrupt();
 
-			throw Exceptions.failWithCancel();
+			throw new IllegalStateException("Thread Interruption on Mono blocking read");
 		}
 	}
 

File: src/main/java/reactor/core/tuple/Tuple2.java
Patch:
@@ -92,7 +92,7 @@ public boolean equals(Object o) {
 
 		Tuple2 tuple2 = (Tuple2) o;
 
-		return t1 != null ? t1.equals(tuple2.t1) : tuple2.t1 == null &&
+		return (t1 != null ? t1.equals(tuple2.t1) : tuple2.t1 == null) &&
 				t2 != null ? t2.equals(tuple2.t2) : tuple2.t2 == null;
 
 	}

File: src/main/java/reactor/core/tuple/Tuple2.java
Patch:
@@ -107,7 +107,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return super.toString() +
-		  (t2 != null ? "," + t2.toString() : "");
+		return (t1 != null ? t1.toString() + "," : "") + (t2 != null ? t2.toString() : "");
 	}
 }

File: src/main/java/reactor/core/publisher/FluxLatest.java
Patch:
@@ -177,7 +177,7 @@ void drain() {
 					a.onNext(v);
 
 					if (r != Long.MAX_VALUE) {
-						REQUESTED.decrementAndGet(this);
+						r = REQUESTED.decrementAndGet(this);
 					}
 				}
 

File: src/main/java/reactor/core/converter/FlowPublisherConverter.java
Patch:
@@ -56,8 +56,8 @@ public void subscribe(Flow.Subscriber<? super Object> subscriber) {
 	@Override
 	@SuppressWarnings("unchecked")
 	public Flux toPublisher(Object o) {
-		final Flow.Publisher<?> pub = (Flow.Publisher<?>) o;
-		if (Flow.Publisher.class.isAssignableFrom(o.getClass())) {
+		if (o instanceof Flow.Publisher) {
+			final Flow.Publisher<?> pub = (Flow.Publisher<?>) o;
 			return new Flux<Object>() {
 				@Override
 				public void subscribe(final Subscriber<? super Object> s) {

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -39,7 +39,6 @@
 import reactor.core.state.Completable;
 import reactor.core.state.Introspectable;
 import reactor.core.subscriber.ConsumerSubscriber;
-import reactor.core.subscriber.Subscribers;
 import reactor.core.timer.Timer;
 import reactor.core.tuple.Tuple;
 import reactor.core.tuple.Tuple2;

File: src/main/java/reactor/core/tuple/Tuple.java
Patch:
@@ -489,6 +489,7 @@ public static <T1, T2, T3, T4, T5, T6, T7, T8> Function<Object[], Tuple8<T1, T2,
 	 * @param <T5> The type of the fifth value.
 	 * @param <T6> The type of the sixth value.
 	 * @param <T7> The type of the seventh value.
+     * @param <T8> The type of the eighth value.
 	 * @param <R> The type of the return value.
 	 *
 	 * @return The unchecked conversion function to {@link Tuple8}.

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -553,7 +553,7 @@ public static <T> Flux<T> empty() {
 	 * @return a new failed {@link Flux}
 	 */
 	public static <T> Flux<T> error(Throwable error) {
-		return Mono.<T>error(error).flux();
+		return error(error, false);
 	}
 
 	/**
@@ -4339,7 +4339,7 @@ public final Mono<List<T>> toSortedList() {
 	 */
 	@SuppressWarnings("unchecked")
 	public final Mono<List<T>> toSortedList(Comparator<? super T> comparator) {
-		return collect(() -> new PriorityQueue<>(comparator), PriorityQueue::add).map(q -> {
+		return collect(() -> new PriorityQueue<T>(comparator), PriorityQueue::add).map(q -> {
 			PriorityQueue<T> temp = new PriorityQueue<T>( q );
 			List<T> res = new ArrayList<T>(q.size());
 

File: src/test/java/reactor/core/converter/RxJavaCompletableTests.java
Patch:
@@ -54,7 +54,7 @@ public void completableWithErrorIntoMono() throws Exception {
 
     @Test
     public void shouldConvertAMonoIntoCompletable() throws Exception {
-        Completable completable = converter.fromPublisher(Mono.just(1));
+        Completable completable = Mono.just(1).as(Completable.class);
         Throwable maybeErrors = completable.get();
         assertThat(maybeErrors, is(nullValue()));
     }

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -173,7 +173,7 @@ public static <E> EmitterProcessor<E> replay(int historySize, int concurrency, b
 	 * (buffer and history size of 1).
 	 *
 	 * <p>
-	 * <img height="384" width="639" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/replaylast.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/replaylast.png" alt="">
 	 *
 	 * @param <T>  the relayed type
 	 *
@@ -189,7 +189,7 @@ public static <T> EmitterProcessor<T> replayLast() {
 	 * cancel upstream if {@link Subscription} has been set. The last emitted item will be replayable to late {@link Subscriber} (buffer and history size of 1).
 	 *
 	 * <p>
-	 * <img height="384" width="639" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/replaylastd.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/replaylastd.png" alt="">
 	 *
 	 * @param value a default value to start the sequence with
 	 * @param <T> the relayed type

File: src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -146,7 +146,7 @@ public static <IN, OUT> FluxProcessor<IN, OUT> create(final Subscriber<IN> upstr
 	 * {@link Subscriber} is slower.
 	 *
 	 * <p>
-	 * <img height="384" width="639" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/serialize.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/serialize.png" alt="">
 	 *
 	 * @param <T> the relayed type
 	 * @return a serializing {@link FluxProcessor}

File: src/main/java/reactor/core/subscriber/Subscribers.java
Patch:
@@ -52,7 +52,7 @@ public enum Subscribers{
 	 * onNext, request N x 0.75.
 	 *
 	 * <p>
-	 * <img height="384" width="639" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/consume.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/consume.png" alt="">
 	 *
 	 * @param prefetch the in-flight capacity used to request source {@link Publisher}
 	 * @param callback an onNext {@link Consumer} callback
@@ -69,7 +69,7 @@ public static <T> ConsumerSubscriber<T> bounded(int prefetch, Consumer<? super T
 	 * onNext, request N x 0.75.
 	 *
 	 * <p>
-	 * <img height="384" width="639" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/consume.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/consume.png" alt="">
 	 *
 	 * @param prefetch the in-flight capacity used to request source {@link Publisher}
 	 * @param callback an onNext {@link Consumer} callback
@@ -300,7 +300,7 @@ public static <T, C> Subscriber<T> create(Function<? super Subscription, C> subs
 	 * {@link Subscriber} is slower.
 	 *
 	 * <p>
-	 * <img height="384" width="639" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/serialize.png" alt="">
+	 * <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/serialize.png" alt="">
 	 *
 	 * @param <T> the relayed type
 	 * @return a serializing {@link Subscriber}

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -30,6 +30,7 @@
 import reactor.core.state.Introspectable;
 import reactor.core.state.Prefetchable;
 import reactor.core.util.BackpressureUtils;
+import reactor.core.util.CancelledSubscription;
 import reactor.core.util.EmptySubscription;
 import reactor.core.util.Exceptions;
 import reactor.core.util.PlatformDependent;
@@ -82,6 +83,7 @@ public final void cancel() {
 				return;
 			}
 			if (STATE.compareAndSet(this, state, STATE_CANCELLED)) {
+				subscription = CancelledSubscription.INSTANCE;
 				break;
 			}
 			state = this.state;

File: src/main/java/reactor/core/publisher/MonoProcessor.java
Patch:
@@ -134,6 +134,7 @@ public O get(long timeout) {
 						return null;
 				}
 				if (delay < System.currentTimeMillis()) {
+					cancel();
 					Exceptions.failWithCancel();
 				}
 				Thread.sleep(1);

File: src/main/java/reactor/core/publisher/FluxBatch.java
Patch:
@@ -23,6 +23,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.state.Introspectable;
 import reactor.core.state.Pausable;
 import reactor.core.state.Requestable;
 
@@ -80,7 +81,7 @@ protected final Subscriber<? super V> prepareSub(Subscriber<? super V> actual) {
 	}
 
 	static protected abstract class BatchAction<T, V> extends SubscriberBarrier<T, V>
-			implements Requestable {
+			implements Requestable, Introspectable {
 
 		protected final static int NOT_TERMINATED = 0;
 		protected final static int TERMINATED_WITH_SUCCESS = 1;

File: src/main/java/reactor/core/publisher/FluxGroupBy.java
Patch:
@@ -36,6 +36,7 @@
 import reactor.core.state.Backpressurable;
 import reactor.core.state.Cancellable;
 import reactor.core.state.Completable;
+import reactor.core.state.Introspectable;
 import reactor.core.state.Prefetchable;
 import reactor.core.state.Requestable;
 import reactor.core.util.BackpressureUtils;
@@ -107,7 +108,7 @@ public void subscribe(Subscriber<? super GroupedFlux<K, V>> s) {
 	
 	static final class GroupByMain<T, K, V> implements Subscriber<T>,
 	                                                   QueueSubscription<GroupedFlux<K, V>>, MultiProducer, Backpressurable, Producer, Requestable,
-	                                                   Failurable, Cancellable, Completable, Receiver {
+	                                                   Cancellable, Completable, Receiver, Introspectable {
 
 		final Function<? super T, ? extends K> keySelector;
 		

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1337,7 +1337,7 @@ public final <V> Flux<V> after(Supplier<? extends Publisher<V>> afterSupplier) {
 	 */
 	@SuppressWarnings("unchecked")
 	public final <V> Flux<V> after(Supplier<? extends Publisher<V>> afterSupplier, boolean runOnError) {
-		return flatMap(null, throwable -> !runOnError ? null :
+		return flatMap(null, !runOnError ? null : throwable ->
 				concat(afterSupplier.get(), Flux.<V>error(throwable)),
 				afterSupplier);
 	}

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -701,7 +701,8 @@ public final <V> Mono<V> after(final Supplier<? extends Mono<V>> sourceSupplier)
 	 */
 	public final <V> Mono<V> after(final Supplier<? extends Mono<V>> sourceSupplier, boolean runOnError) {
 		return MonoSource.wrap(after().flatMap(null,
-				throwable -> !runOnError ? null : Flux.concat(sourceSupplier.get(), Mono.<V>error(throwable)),
+				!runOnError ? null : throwable -> Flux.concat(sourceSupplier.get(), Mono
+						.<V>error(throwable)),
 				sourceSupplier));
 	}
 

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -38,7 +38,7 @@
 import reactor.core.state.Introspectable;
 import reactor.core.state.Prefetchable;
 import reactor.core.state.Requestable;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.EmptySubscription;
 import reactor.core.util.Exceptions;

File: src/main/java/reactor/core/publisher/FluxBatch.java
Patch:
@@ -26,7 +26,7 @@
 import reactor.core.state.Failurable;
 import reactor.core.state.Pausable;
 import reactor.core.state.Requestable;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.subscriber.SubscriberBarrier;
 import reactor.core.timer.Timer;
 import reactor.core.util.BackpressureUtils;

File: src/main/java/reactor/core/publisher/FluxProcessor.java
Patch:
@@ -27,7 +27,7 @@
 import reactor.core.flow.Producer;
 import reactor.core.flow.Receiver;
 import reactor.core.state.Backpressurable;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.subscriber.SignalEmitter;
 import reactor.core.util.Assert;
 import reactor.core.util.BackpressureUtils;

File: src/main/java/reactor/core/publisher/FluxRepeatWhen.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.flow.Loopback;
 import reactor.core.subscriber.MultiSubscriptionSubscriber;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.DeferredSubscription;
 import reactor.core.util.EmptySubscription;
 import reactor.core.util.Exceptions;

File: src/main/java/reactor/core/publisher/FluxRetryWhen.java
Patch:
@@ -24,7 +24,7 @@
 import org.reactivestreams.Subscription;
 import reactor.core.flow.Loopback;
 import reactor.core.subscriber.MultiSubscriptionSubscriber;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.DeferredSubscription;
 import reactor.core.util.EmptySubscription;
 import reactor.core.util.Exceptions;

File: src/main/java/reactor/core/publisher/FluxSample.java
Patch:
@@ -22,7 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.CancelledSubscription;
 

File: src/main/java/reactor/core/publisher/FluxSkipUntil.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.CancelledSubscription;
 import reactor.core.util.EmptySubscription;

File: src/main/java/reactor/core/publisher/FluxTakeUntil.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.CancelledSubscription;
 import reactor.core.util.EmptySubscription;

File: src/main/java/reactor/core/publisher/FluxTimeout.java
Patch:
@@ -25,7 +25,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.subscriber.MultiSubscriptionSubscriber;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.CancelledSubscription;
 import reactor.core.util.EmptySubscription;

File: src/main/java/reactor/core/publisher/FluxWithLatestFrom.java
Patch:
@@ -22,7 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import reactor.core.subscriber.SerializedSubscriber;
+
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.CancelledSubscription;
 import reactor.core.util.EmptySubscription;

File: src/main/java/reactor/core/state/Cancellable.java
Patch:
@@ -24,5 +24,7 @@ public interface Cancellable {
 	/**
 	 * @return has the downstream "cancelled" and interrupted its consuming ?
 	 */
-	boolean isCancelled();
+	default boolean isCancelled(){
+		return false;
+	}
 }

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -2783,7 +2783,6 @@ public final Flux<Flux<T>> nest() {
 	 * <p>
 	 * <img width="500" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/next.png" alt="">
 	 * <p>
-	 * If the sequence emits more than 1 data, emit {@link ArrayIndexOutOfBoundsException}.
 	 *
 	 * @return a new {@link Mono}
 	 */

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -699,7 +699,7 @@ public final <V> Mono<V> after(final Supplier<? extends Mono<V>> sourceSupplier)
 	 */
 	public final Mono<T> cache() {
 		return MonoSource.wrap(Flux.from(this)
-		                           .publish()
+		                           .multicast(EmitterProcessor.replay(1))
 		                           .autoConnect());
 	}
 

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1251,13 +1251,13 @@ public final Mono<T> repeatUntilNext(Function<Flux<Long>, ? extends Publisher<?>
 	 */
 	public final Mono<T> repeatUntilNext(int maxRepeat, Function<Flux<Long>, ? extends Publisher<?>> repeatFactory) {
 		if (maxRepeat != Integer.MAX_VALUE) {
-			Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L);
+			Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> { return v != 0L; });
 			return MonoSource.wrap(new FluxRepeatWhen<T>(this,
 					skip.andThen(flux -> flux.zipWith(Flux.range(0, maxRepeat), (a, b) -> b)
 					                         .map(a -> (long)a))
 					    .andThen(repeatFactory)));
 		}
-		Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L).scan(0L, (v, acc) -> acc++);
+		Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> { return v != 0L; }).scan(0L, (v, acc) -> acc++);
 		return MonoSource.wrap(new FluxRepeatWhen<T>(this, skip.andThen(repeatFactory)));
 	}
 

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -551,11 +551,12 @@ void drainLoop() {
 
 			for (;;) {
 
+				boolean d = done;
+
 				FlatMapInner<R>[] as = subscribers;
 
 				int n = as.length;
 
-				boolean d = done;
 				Queue<R> sq = scalarQueue;
 
 				if (checkTerminated(d, n == 0 && (sq == null || sq.isEmpty()), a)) {

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -1243,7 +1243,7 @@ public final Mono<T> repeatUntilNext(Function<Flux<Long>, ? extends Publisher<?>
 	 *
 	 * @param maxRepeat the maximum repeat number of time (infinite if {@code Integer.MAX_VALUE})
 	 * @param repeatFactory the
-	 * {@link Function} providing a {@link Flux} signalling the current number of repeat on onComplete and returning a {@link Publisher} companion.
+	 * {@link Function} providing a {@link Flux} signalling the current repeat index from 0 on onComplete and returning a {@link Publisher} companion.
 	 *
 	 * @return an eventually repeated {@link Mono} on onComplete when the companion {@link Publisher} produces an
 	 * onNext signal
@@ -1253,11 +1253,11 @@ public final Mono<T> repeatUntilNext(int maxRepeat, Function<Flux<Long>, ? exten
 		if (maxRepeat != Integer.MAX_VALUE) {
 			Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L);
 			return MonoSource.wrap(new FluxRepeatWhen<T>(this,
-					skip.andThen(flux -> flux.zipWith(Flux.range(1, maxRepeat), (a, b) -> b)
+					skip.andThen(flux -> flux.zipWith(Flux.range(0, maxRepeat), (a, b) -> b)
 					                         .map(a -> (long)a))
 					    .andThen(repeatFactory)));
 		}
-		Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L);
+		Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L).scan(0L, (v, acc) -> acc++);
 		return MonoSource.wrap(new FluxRepeatWhen<T>(this, skip.andThen(repeatFactory)));
 	}
 

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -290,7 +290,6 @@ public static <T> Mono<T> fromCompletableFuture(CompletableFuture<? extends T> c
 	}
 
 
-
 	/**
 	 * Build a {@link Mono} that will only emit the result of the future and then complete.
 	 * The future will be polled for an unbounded amount of time on request().
@@ -1255,7 +1254,7 @@ public final Mono<T> repeatUntilNext(int maxRepeat, Function<Flux<Long>, ? exten
 			Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L);
 			return MonoSource.wrap(new FluxRepeatWhen<T>(this,
 					skip.andThen(flux -> flux.zipWith(Flux.range(1, maxRepeat), (a, b) -> b)
-					                         .cast(Long.class))
+					                         .map(a -> (long)a))
 					    .andThen(repeatFactory)));
 		}
 		Function<Flux<Long>, Flux<Long>> skip = f -> f.takeUntil(v -> v != 0L);

File: src/main/java/reactor/core/publisher/BlockingIterable.java
Patch:
@@ -76,7 +76,7 @@ public Iterator<T> iterator() {
 	 * @return a {@link Stream} of unknown size with onClose attached to {@link Subscription#cancel()}
 	 */
 	public Stream<T> stream() {
-		BlockingIterable.SubscriberIterator<T> it = createIterator();
+		SubscriberIterator<T> it = createIterator();
 		source.subscribe(it);
 
 		Spliterator<T> sp = Spliterators.spliteratorUnknownSize(it, 0);

File: src/main/java/reactor/core/publisher/FluxTap.java
Patch:
@@ -139,8 +139,8 @@ public void onComplete() {
 		}
 	}
 
-	static final class TapFuseable<O> extends Fuseable.SynchronousSubscription<O>
-			implements Subscriber<O>, Receiver, Producer {
+	static final class TapFuseable<O>
+			implements Subscriber<O>, Receiver, Producer, Fuseable.SynchronousSubscription<O> {
 		final Subscriber<? super O> actual;
 		final FluxTap<O>            parent;
 

File: src/main/java/reactor/core/flow/Fuseable.java
Patch:
@@ -183,10 +183,10 @@ default boolean retainAll(Collection<?> c) {
 	 *
 	 * @param <T> the content value type
 	 */
-	abstract class SynchronousSubscription<T> implements QueueSubscription<T>, Queue<T> {
+	interface SynchronousSubscription<T> extends QueueSubscription<T>, Queue<T> {
 
 		@Override
-		public int requestFusion(int requestedMode) {
+		default int requestFusion(int requestedMode) {
 			return Fuseable.SYNC;
 		}
 

File: src/main/java/reactor/core/publisher/FluxArray.java
Patch:
@@ -60,8 +60,7 @@ public void subscribe(Subscriber<? super T> s) {
 	}
 
 	static final class ArraySubscription<T>
-			extends SynchronousSubscription<T>
-	  implements Producer, Requestable, Cancellable, MultiReceiver {
+	  implements Producer, Requestable, Cancellable, MultiReceiver, SynchronousSubscription<T> {
 		final Subscriber<? super T> actual;
 
 		final T[] array;

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -457,7 +457,7 @@ final void drainLoop() {
 						q = emitBuffer;
 					}
 					innerSequence = is.pollCursor;
-					if (innerSequence != null && r > 0) {
+					if (!is.unbounded && innerSequence != null && r > 0) {
 						_r = r;
 
 						boolean unbounded = _r == Long.MAX_VALUE;
@@ -521,7 +521,8 @@ final void drainLoop() {
 
 	final void checkTerminal(EmitterSubscriber<T> is, Sequence innerSequence, long r) {
 		Throwable e = error;
-		if ((e != null && r == 0) || innerSequence == null || innerSequence.getAsLong() >= emitBuffer.getCursor()) {
+		if ((e != null && r == 0) || innerSequence == null || is.unbounded || innerSequence.getAsLong() >= emitBuffer.getCursor
+				()) {
 			removeInner(is, EMPTY);
 			if (!is.done) {
 				if (e == null) {

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -234,7 +234,7 @@ public static <T> Mono<T> error(Throwable error) {
 	 * @return the next item emitted as a {@link Mono}
 	 */
 	@SuppressWarnings("unchecked")
-	public static <T> Mono<T> from(Publisher<T> source) {
+	public static <T> Mono<T> from(Publisher<? extends T> source) {
 		if (source == null) {
 			return empty();
 		}

File: src/test/java/reactor/core/tuple/TupleTests.java
Patch:
@@ -24,9 +24,6 @@
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 
-/**
- * @author Jon Brisbin
- */
 public class TupleTests {
 
 	@Test

File: src/main/java/reactor/core/util/Exceptions.java
Patch:
@@ -353,7 +353,7 @@ public static TimerOverflowException get() {
 		}
 
 		private TimerOverflowException() {
-			super("The subscriber has not requested for the timer signals, consider Stream#onBackpressureDrop or any " +
+			super("The subscriber has not requested for the timer signals, consider Fluxion#onBackpressureDrop or any" +
 					"unbounded subscriber");
 		}
 

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -472,7 +472,7 @@ public static <T1, T2, T3, T4, T5, T6> Mono<Tuple6<T1, T2, T3, T4, T5, T6>> when
 	@SafeVarargs
 	@SuppressWarnings({"unchecked","varargs"})
 	private static <T> Mono<T[]> when(Mono<? extends T>... monos) {
-		return when(Function.identity(), monos);
+		return when(array -> (T[])array, monos);
 	}
 
 	/**
@@ -510,7 +510,7 @@ private static <T, V> Mono<V> when(Function<? super Object[], ? extends V> combi
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T> Mono<T[]> when(final Iterable<? extends Mono<? extends T>> monos) {
-		return when(Function.identity(), monos);
+		return when(array -> (T[])array, monos);
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/Flux.java
Patch:
@@ -1096,12 +1096,12 @@ public final Flux<T> defaultIfEmpty(T defaultV) {
 	 * <p>
 	 * {@code flux.dispatchOn(WorkQueueProcessor.create()).subscribe(Subscribers.unbounded()) }
 	 *
-	 * @param schedulers a checked factory for {@link Consumer} of {@link Runnable}
+	 * @param scheduler a checked factory for {@link Consumer} of {@link Runnable}
 	 *
 	 * @return a {@link Flux} consuming asynchronously
 	 */
-	public final Flux<T> dispatchOn(Callable<? extends Consumer<Runnable>> schedulers) {
-		return dispatchOn(this, schedulers, true, PlatformDependent.XS_BUFFER_SIZE, QueueSupplier.<T>xs());
+	public final Flux<T> dispatchOn(Callable<? extends Consumer<Runnable>> scheduler) {
+		return dispatchOn(this, scheduler, true, PlatformDependent.XS_BUFFER_SIZE, QueueSupplier.<T>xs());
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/MonoSource.java
Patch:
@@ -15,6 +15,8 @@
  */
 package reactor.core.publisher;
 
+import java.util.Objects;
+
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.flow.Fuseable;
@@ -52,7 +54,7 @@ public static <I> Mono<I> wrap(Publisher<? extends I> source){
 	}
 
 	protected MonoSource(Publisher<? extends I> source) {
-		this.source = source;
+		this.source = Objects.requireNonNull(source);
 	}
 
 	/**

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -51,7 +51,7 @@
  * {@code
  * TestSubscriber<String> ts = new TestSubscriber<>();
  * Publisher<String> publisher = new FooPublisher<>();
- * ts.bindTo(publisher).assertValue("ABC", "DEF").assertComplete();
+ * ts.bindTo(publisher).assertValues("ABC", "DEF").assertComplete();
  * }
  * </pre>
  *

File: src/test/java/reactor/core/converter/CompletableFutureTests.java
Patch:
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package reactor.core.publisher;
+package reactor.core.converter;
 
 import java.util.concurrent.CompletableFuture;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;
 import org.reactivestreams.tck.TestEnvironment;
 import org.testng.annotations.Test;
-import reactor.core.converter.DependencyUtils;
 
 /**
  * @author Stephane Maldini

File: src/test/java/reactor/core/converter/Jdk9PublisherTests.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package reactor.core.publisher;
+package reactor.core.converter;
 
 import java.util.concurrent.SubmissionPublisher;
 import java.util.concurrent.TimeUnit;
@@ -24,7 +24,6 @@
 import org.testng.SkipException;
 import org.testng.annotations.BeforeTest;
 import org.testng.annotations.Test;
-import reactor.core.converter.DependencyUtils;
 import reactor.core.timer.Timer;
 
 /**

File: src/test/java/reactor/core/converter/RxJavaPublisherTests.java
Patch:
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package reactor.core.publisher;
+package reactor.core.converter;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;
 import org.reactivestreams.tck.TestEnvironment;
 import org.testng.annotations.Test;
-import reactor.core.converter.DependencyUtils;
 import rx.Observable;
 
 /**

File: src/test/java/reactor/core/converter/RxJavaSinglePublisherTests.java
Patch:
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package reactor.core.publisher;
+package reactor.core.converter;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.tck.PublisherVerification;
 import org.reactivestreams.tck.TestEnvironment;
 import org.testng.annotations.Test;
-import reactor.core.converter.DependencyUtils;
 import rx.Single;
 
 /**

File: src/main/java/reactor/core/publisher/TopicProcessor.java
Patch:
@@ -740,7 +740,7 @@ public long get() {
 								minimum.get() :
 								ringBuffer.getMinimumGatingSequence(minimum);
 					}
-				}, readWait, this, ringBuffer)).start();
+				}, readWait, this, (int)ringBuffer.getCapacity())).start();
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/WorkQueueProcessor.java
Patch:
@@ -633,7 +633,7 @@ public void run() {
 			public long get() {
 				return ringBuffer.getMinimumGatingSequence();
 			}
-		}, readWait, this, ringBuffer)).start();
+		}, readWait, this, (int)ringBuffer.getCapacity())).start();
 	}
 
 	@Override

File: src/test/java/reactor/core/publisher/EmitterProcessorTests.java
Patch:
@@ -30,7 +30,7 @@ public class EmitterProcessorTests extends AbstractProcessorVerification {
 	public Processor<Long, Long> createProcessor(int bufferSize) {
 		FluxProcessor<Long, Long> p = EmitterProcessor.<Long>create(bufferSize);
 
-		return FluxProcessor.blackbox(p, x -> x.log("emitter"));
+		return FluxProcessor.create(p, p.log("emitter"));
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/EmitterProcessor.java
Patch:
@@ -724,7 +724,7 @@ void start() {
 								cursor - Math.min(parent.replay, cursor % ringBuffer.getCapacity())));
 					}
 					else {
-						startTracking(Math.max(0L, ringBuffer.getMinimumGatingSequence()));
+						startTracking(Math.max(0L, ringBuffer.getMinimumGatingSequence() + 1L));
 					}
 				}
 

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -422,7 +422,7 @@ public final TestSubscriber<T> assertValueSequence(Iterable<? extends T> expecte
 				T t1 = actual.next();
 				T t2 = expected.next();
 				if (!Objects.equals(t1, t2)) {
-					throw new AssertionError("The " + i + " th elements differ: expected = " + valueAndClass(t2) + ", actual = "
+					throw new AssertionError("The element with index " + i + " does not match: expected = " + valueAndClass(t2) + ", actual = "
 					  + valueAndClass(
 					  t1), null);
 				}

File: src/main/java/reactor/core/publisher/ProcessorGroup.java
Patch:
@@ -95,6 +95,8 @@ public class ProcessorGroup
 	                                                            .availableProcessors(), 4);
 
 	/**
+	 *
+	 *
 	 * @param name
 	 * @param bufferSize
 
@@ -611,7 +613,7 @@ public Consumer<Runnable> call(boolean tailRecurse) throws Exception {
 	 * Create a {@link Processor} dispatching {@link Subscriber#onNext(Object)},
 	 * {@link Subscriber#onError(Throwable)} and {@link Subscriber#onComplete()} asynchronously using
 	 * this {@link ProcessorGroup}. This will increment the reference count of this {@link ProcessorGroup} and
-	 * further condition its shutdown (when the processor is terminated).
+	 * will further condition its shutdown (when the processor is terminated).
 	 *
 	 * The returned {@link FluxProcessor} offers {@link Flux} API and will only support at most one {@link Subscriber}.
 	 */

File: src/test/java/reactor/core/publisher/ConsistentProcessorTests.java
Patch:
@@ -33,12 +33,12 @@
 import org.reactivestreams.Processor;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.timer.Timer;
 
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.notNullValue;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
-import reactor.core.timer.Timer;
 
 /**
  * @author Stephane Maldini
@@ -137,8 +137,8 @@ public Set<Integer> findDuplicates(List<Integer> listContainingDuplicates) {
 	}
 
 	private void setupPipeline() {
-		processor = ProcessorTopic.create(false);
-		workProcessor = ProcessorWorkQueue.create(false);
+		processor = TopicProcessor.create(false);
+		workProcessor = WorkQueueProcessor.create(false);
 		processor.subscribe(workProcessor);
 	}
 

File: src/test/java/reactor/core/publisher/ProcessorEmitterDemandTests.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @author Anatoly Kadyshev
  */
-public class ProcessorEmitterDemandTests {
+public class ReplayProcessorDemandTests {
 
 	static final List<String> DATA     = new ArrayList<>();
 	static final int          MAX_SIZE = 100;

File: src/test/java/reactor/core/publisher/ProcessorEmitterTests.java
Patch:
@@ -24,7 +24,7 @@
  * @author Stephane Maldini
  */
 @org.testng.annotations.Test
-public class ProcessorEmitterTests extends AbstractProcessorVerification {
+public class ReplayProcessorTests extends AbstractProcessorVerification {
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {

File: src/test/java/reactor/core/publisher/ProcessorTopicTests.java
Patch:
@@ -22,7 +22,7 @@
  * @author Stephane Maldini
  */
 @org.testng.annotations.Test
-public class ProcessorTopicTests extends AbstractProcessorVerification {
+public class TopicProcessorTests extends AbstractProcessorVerification {
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
@@ -43,7 +43,7 @@ public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo
 	@Test
 	public void testShutdown() {
 		for (int i = 0; i < 1000; i++) {
-			ProcessorExecutor dispatcher = Processors.topic("rb-test-shutdown", 16);
+			ExecutorProcessor dispatcher = Processors.topic("rb-test-shutdown", 16);
 			dispatcher.awaitAndShutdown();
 		}
 	}
@@ -57,7 +57,7 @@ public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() t
 	@Ignore
 	public void extra_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall()
 			throws InterruptedException {
-		ProcessorTopic<String> processor = ProcessorTopic.create();
+		TopicProcessor<String> processor = TopicProcessor.create();
 		Publisher<String> publisher = Subscriber::onComplete;
 		publisher.subscribe(processor);
 

File: src/test/java/reactor/core/publisher/ProcessorWorkQueueTests.java
Patch:
@@ -28,7 +28,7 @@
  * @author Stephane Maldini
  */
 @org.testng.annotations.Test
-public class ProcessorWorkQueueTests extends AbstractProcessorVerification {
+public class WorkQueueProcessorTests extends AbstractProcessorVerification {
 
 	@Override
 	public Processor<Long, Long> createProcessor(int bufferSize) {
@@ -97,7 +97,7 @@ public void mustImmediatelyPassOnOnErrorEventsReceivedFromItsUpstreamToItsDownst
 	}
 
 	/*public static void main() {
-		final ProcessorWorkQueue<Long> processor = ProcessorWorkQueue.<Long>create("some-test");
+		final WorkQueueProcessor<Long> processor = WorkQueueProcessor.<Long>create("some-test");
 
 		Publisher<Long> pub = PublisherFactory.create(
 		  c -> {

File: src/main/java/reactor/core/util/BackpressureUtils.java
Patch:
@@ -425,7 +425,7 @@ public static <F> boolean replace(AtomicReferenceFieldUpdater<F, Subscription> f
 	 *
 	 */
 	public static void reportSubscriptionSet() {
-		throw Exceptions.argumentIsNullException();
+		throw Exceptions.duplicateOnSubscribeException();
 	}
 
 	/**

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -29,6 +29,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import reactor.core.subscriber.DeferredSubscriptionSubscriber;
 import reactor.core.util.Assert;
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.PlatformDependent;
@@ -63,7 +64,7 @@
  * @author Brian Clozel
  * @since 2.5
  */
-public class TestSubscriber<T> extends SubscriberDeferredSubscription<T, T> {
+public class TestSubscriber<T> extends DeferredSubscriptionSubscriber<T, T> {
 
 	/**
 	 * Default timeout in seconds for waiting next values to be received

File: src/main/java/reactor/core/publisher/FluxAmb.java
Patch:
@@ -26,7 +26,7 @@
 import reactor.core.flow.MultiReceiver;
 import reactor.core.state.Cancellable;
 import reactor.core.state.Introspectable;
-import reactor.core.subscriber.SubscriberDeferredSubscription;
+import reactor.core.subscriber.DeferredSubscriptionSubscriber;
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.EmptySubscription;
 
@@ -268,7 +268,7 @@ public long upstreamCount() {
 		}
 	}
 
-	static final class AmbSubscriber<T> extends SubscriberDeferredSubscription<T, T>
+	static final class AmbSubscriber<T> extends DeferredSubscriptionSubscriber<T, T>
 			implements Introspectable {
 		final AmbCoordinator<T> parent;
 

File: src/main/java/reactor/core/publisher/FluxResume.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.flow.Loopback;
-import reactor.core.subscriber.SubscriberMultiSubscription;
+import reactor.core.subscriber.MultiSubscriptionSubscriber;
 import reactor.core.util.Exceptions;
 import reactor.fn.Function;
 
@@ -74,7 +74,7 @@ public void subscribe(Subscriber<? super T> s) {
 		source.subscribe(new ResumeSubscriber<>(s, nextFactory));
 	}
 
-	static final class ResumeSubscriber<T> extends SubscriberMultiSubscription<T, T>
+	static final class ResumeSubscriber<T> extends MultiSubscriptionSubscriber<T, T>
 			implements Loopback {
 
 		final Function<? super Throwable, ? extends Publisher<? extends T>> nextFactory;

File: src/main/java/reactor/core/publisher/FluxSwitchIfEmpty.java
Patch:
@@ -20,7 +20,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import reactor.core.flow.Loopback;
-import reactor.core.subscriber.SubscriberMultiSubscription;
+import reactor.core.subscriber.MultiSubscriptionSubscriber;
 
 /**
  * Switches to another source if the first source turns out to be empty.
@@ -50,7 +50,7 @@ public void subscribe(Subscriber<? super T> s) {
 		source.subscribe(parent);
 	}
 
-	static final class SwitchIfEmptySubscriber<T> extends SubscriberMultiSubscription<T, T>
+	static final class SwitchIfEmptySubscriber<T> extends MultiSubscriptionSubscriber<T, T>
 			implements Loopback {
 
 		final Publisher<? extends T> other;

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -36,7 +36,7 @@
 import reactor.core.state.Introspectable;
 import reactor.core.state.Prefetchable;
 import reactor.core.state.Requestable;
-import reactor.core.subscriber.SubscriberDeferredScalar;
+import reactor.core.subscriber.DeferredScalarSubscriber;
 import reactor.core.util.BackpressureUtils;
 import reactor.core.util.CancelledSubscription;
 import reactor.core.util.EmptySubscription;
@@ -216,7 +216,7 @@ void handleBoth(Subscriber<? super R> s, Publisher<? extends T>[] srcs, Object[]
 				
 				coordinator.subscribe(n, sc, srcs);
 			} else {
-				SubscriberDeferredScalar<R, R> sds = new SubscriberDeferredScalar<>(s);
+				DeferredScalarSubscriber<R, R> sds = new DeferredScalarSubscriber<>(s);
 
 				s.onSubscribe(sds);
 				
@@ -258,7 +258,7 @@ public long upstreamCount() {
 		return sources == null ? -1 : sources.length;
 	}
 
-	static final class ZipSingleCoordinator<T, R> extends SubscriberDeferredScalar<R, R>
+	static final class ZipSingleCoordinator<T, R> extends DeferredScalarSubscriber<R, R>
 			implements MultiReceiver, Backpressurable {
 
 		final Function<? super Object[], ? extends R> zipper;

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -17,11 +17,10 @@
 
 import java.util.Objects;
 import java.util.concurrent.Callable;
-import reactor.fn.Supplier;
 
 import org.reactivestreams.Subscriber;
 import reactor.core.flow.Receiver;
-import reactor.core.subscriber.SubscriberDeferredScalar;
+import reactor.core.subscriber.DeferredScalarSubscriber;
 import reactor.core.util.Exceptions;
 
 /**
@@ -54,7 +53,7 @@ public Object upstream() {
 	@Override
 	public void subscribe(Subscriber<? super T> s) {
 
-		SubscriberDeferredScalar<T, T> sds = new SubscriberDeferredScalar<>(s);
+		DeferredScalarSubscriber<T, T> sds = new DeferredScalarSubscriber<>(s);
 
 		s.onSubscribe(sds);
 

File: src/main/java/reactor/core/subscriber/DeferredSubscriptionSubscriber.java
Patch:
@@ -30,7 +30,7 @@
  * @param <I> the input value type
  * @param <O> the output value type
  */
-public class SubscriberDeferredSubscription<I, O>
+public class DeferredSubscriptionSubscriber<I, O>
 		extends DeferredSubscription
 implements Subscription, Subscriber<I>, Producer {
 
@@ -41,7 +41,7 @@ public class SubscriberDeferredSubscription<I, O>
 	 * 
 	 * @param subscriber the actual subscriber
 	 */
-	public SubscriberDeferredSubscription(Subscriber<? super O> subscriber) {
+	public DeferredSubscriptionSubscriber(Subscriber<? super O> subscriber) {
 		this.subscriber = Objects.requireNonNull(subscriber, "subscriber");
 	}
 
@@ -52,7 +52,7 @@ public SubscriberDeferredSubscription(Subscriber<? super O> subscriber) {
 	 * @param initialRequest
 	 * @throws IllegalArgumentException if initialRequest is negative
 	 */
-	public SubscriberDeferredSubscription(Subscriber<? super O> subscriber, long initialRequest) {
+	public DeferredSubscriptionSubscriber(Subscriber<? super O> subscriber, long initialRequest) {
 		if (initialRequest < 0) {
 			throw new IllegalArgumentException("initialRequest >= required but it was " + initialRequest);
 		}

File: src/main/java/reactor/core/publisher/ProcessorTopic.java
Patch:
@@ -764,12 +764,12 @@ public long remainingCapacity() {
 
 	@Override
 	public Iterator<?> downstreams() {
-		return Arrays.asList(ringBuffer.getSequencer().getGatingSequences()).iterator();
+		return Arrays.asList(ringBuffer.getSequenceReceivers()).iterator();
 	}
 
 	@Override
 	public long downstreamCount() {
-		return ringBuffer.getSequencer().getGatingSequences().length - (isStarted() ? 1 : 0);
+		return ringBuffer.getSequenceReceivers().length - (isStarted() ? 1 : 0);
 	}
 
 	/**

File: src/main/java/reactor/core/publisher/ProcessorWorkQueue.java
Patch:
@@ -691,12 +691,12 @@ RingBuffer<Slot<E>> retryBuffer() {
 
 	@Override
 	public Iterator<?> downstreams() {
-		return Arrays.asList(ringBuffer.getSequencer().getGatingSequences()).iterator();
+		return Arrays.asList(ringBuffer.getSequenceReceivers()).iterator();
 	}
 
 	@Override
 	public long downstreamCount() {
-		return ringBuffer.getSequencer().getGatingSequences().length - 1;
+		return ringBuffer.getSequenceReceivers().length - 1;
 	}
 
 	/**

File: src/main/java/reactor/core/converter/CompletableFutureConverter.java
Patch:
@@ -56,7 +56,7 @@ static public <T> CompletableFuture<T> fromSingle(Publisher<T> o) {
 	}
 
 	@SuppressWarnings("unchecked")
-	static public <T> Publisher<T> from(CompletableFuture<T> o) {
+	static public <T> Mono<T> from(CompletableFuture<T> o) {
 		return INSTANCE.toPublisher(o);
 	}
 

File: src/main/java/reactor/core/converter/RxJava1SingleConverter.java
Patch:
@@ -37,7 +37,7 @@ static public <T> Single<T> from(Publisher<T> o) {
 	}
 
 	@SuppressWarnings("unchecked")
-	static public <T> Publisher<T> from(Single<T> o) {
+	static public <T> Mono<T> from(Single<T> o) {
 		return INSTANCE.toPublisher(o);
 	}
 

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -153,6 +153,7 @@ void handleIterableMode(Subscriber<? super R> s, Iterable<? extends Publisher<?
 				}
 				srcs[n] = p;
 			}
+			n++;
 		}
 		
 		if (n == 0) {
@@ -205,7 +206,7 @@ void handleArrayMode(Subscriber<? super R> s, Publisher<? extends T>[] srcs) {
 	}
 
 	void handleBoth(Subscriber<? super R> s, Publisher<? extends T>[] srcs, Object[] scalars, int n, int sc) {
-		if (scalars != null) {
+		if (sc != 0) {
 			if (n != sc) {
 				ZipSingleCoordinator<T, R> coordinator = 
 						new ZipSingleCoordinator<>(s, scalars, n, zipper);

File: src/test/java/reactor/core/test/TestSubscriberTests.java
Patch:
@@ -68,14 +68,14 @@ public void assertValuesWithFailure() {
 		ts.assertValuesWith(value -> Assert.assertEquals("foo", value), value -> Assert.assertEquals("foo", value));
 	}
 
-	@Test(expected = AssertionError.class)
+	@Test
 	public void assertValueSequence() {
 		TestSubscriber<String> ts = new TestSubscriber<>();
 		Flux.just("foo", "bar").subscribe(ts);
 		ts.assertValueSequence(Arrays.asList("foo", "bar"));
 	}
 
-	@Test
+	@Test(expected = AssertionError.class)
 	public void assertValueSequenceFailure() {
 		TestSubscriber<String> ts = new TestSubscriber<>();
 		Flux.just("foo", "bar").subscribe(ts);

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -548,7 +548,9 @@ void drainLoop() {
 								r = REQUESTED.addAndGet(this, -e);
 							}
 							e = 0L;
+							again = true;
 						}
+						
 					}
 
 					if (r != 0L) {

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -554,7 +554,7 @@ public long getCapacity() {
 		public long getPending() {
 			int nonEmpties = 0;
 			for(int i =0; i < subscribers.length; i++){
-				if(subscribers[i].queue != null && subscribers[i].queue .isEmpty()){
+				if(subscribers[i].queue != null && !subscribers[i].queue .isEmpty()){
 					nonEmpties++;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -554,7 +554,7 @@ public long getCapacity() {
 		public long getPending() {
 			int nonEmpties = 0;
 			for(int i =0; i < subscribers.length; i++){
-				if(!subscribers[i].queue.isEmpty()){
+				if(subscribers[i].queue != null && subscribers[i].queue .isEmpty()){
 					nonEmpties++;
 				}
 			}

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -261,7 +261,7 @@ public ZipSingleCoordinator(Subscriber<? super R> subscriber, Object[] scalars,
 		}
 		
 		void subscribe(int n, int sc, Publisher<? extends T>[] sources) {
-			WIP.lazySet(this, sc);
+			WIP.lazySet(this, n - sc);
 			ZipSingleSubscriber<T>[] a = subscribers;
 			for (int i = 0; i < n; i++) {
 				if (wip <= 0 || isCancelled()) {

File: src/main/java/reactor/core/test/TestSubscriber.java
Patch:
@@ -388,6 +388,8 @@ public final TestSubscriber<T> assertNoValues() {
 	 * @param expectedValues the values to assert
 	 * @see #configureValuesStorage(boolean)
 	 */
+	@SafeVarargs
+	@SuppressWarnings("varargs")
 	public final TestSubscriber<T> assertValues(T... expectedValues) {
 		return assertValueSequence(Arrays.asList(expectedValues));
 	}
@@ -399,6 +401,7 @@ public final TestSubscriber<T> assertValues(T... expectedValues) {
 	 * exception (like an {@link AssertionError}) if the value is not valid.
 	 * @see #configureValuesStorage(boolean)
 	 */
+	@SafeVarargs
 	public final TestSubscriber<T> assertValuesWith(Consumer<T>... expectations) {
 		if (!valuesStorage) {
 			throw new IllegalStateException("Using assertNoValues() requires enabling values storage");

File: src/main/java/reactor/core/publisher/ProcessorGroup.java
Patch:
@@ -999,13 +999,13 @@ protected void doStart(final Subscriber<? super V> subscriber) {
 				@Override
 				public void run() {
 					Subscriber subscriber = WorkProcessorBarrier.this.subscriber;
+					if(subscriber != null) {
+						subscriber.onSubscribe(WorkProcessorBarrier.this);
+					}
 					if(source != null) {
 						source.subscribe(WorkProcessorBarrier.this);
 					}
 
-					if(subscriber != null) {
-						subscriber.onSubscribe(WorkProcessorBarrier.this);
-					}
 				}
 			});
 		}

File: src/main/java/reactor/core/publisher/ProcessorWorkQueue.java
Patch:
@@ -698,7 +698,7 @@ public long downstreamsCount() {
 	 * @param <T> event implementation storing the data for sharing during exchange or
 	 * parallel coordination of an event.
 	 */
-	private final static class QueueSubscriberLoop<T>
+	final static class QueueSubscriberLoop<T>
 			implements Runnable, Subscribable, Backpressurable, Completable, Cancellable, Introspectable,
 			           Requestable, Subscription, Publishable {
 

File: src/main/java/reactor/core/publisher/Mono.java
Patch:
@@ -437,7 +437,7 @@ public final <V> Mono<V> after(final Supplier<? extends Mono<V>> sourceSupplier)
 		return new MonoBarrier<>(after().flatMap(null, new Function<Throwable, Publisher<? extends V>>() {
 			@Override
 			public Publisher<? extends V> apply(Throwable throwable) {
-				return Flux.concat(sourceSupplier.get(), error(throwable));
+				return Flux.concat(sourceSupplier.get(), Mono.<V>error(throwable));
 			}
 		}, sourceSupplier));
 	}

File: src/main/java/reactor/core/publisher/MonoResult.java
Patch:
@@ -24,7 +24,6 @@
 import reactor.core.subscription.CancelledSubscription;
 import reactor.core.support.Exceptions;
 import reactor.core.support.ReactiveState;
-import reactor.core.support.SignalType;
 import reactor.core.support.internal.PlatformDependent;
 
 /**

File: src/main/java/reactor/core/publisher/ProcessorGroup.java
Patch:
@@ -37,7 +37,6 @@
 import reactor.core.support.Exceptions;
 import reactor.core.support.Logger;
 import reactor.core.support.ReactiveState;
-import reactor.core.support.SignalType;
 import reactor.fn.BiConsumer;
 import reactor.fn.Consumer;
 import reactor.fn.Supplier;

File: src/main/java/reactor/core/publisher/SignalType.java
Patch:
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package reactor.core.support;
+package reactor.core.publisher;
 
 /**
  * @author Stephane Maldini
  */
-public enum SignalType {
+enum SignalType {
 	NEXT, ERROR, COMPLETE, SUBSCRIPTION
 }

File: src/main/java/reactor/core/queue/disruptor/MultiProducerSequencer.java
Patch:
@@ -19,7 +19,7 @@
 
 import reactor.core.support.Exceptions;
 import reactor.core.support.WaitStrategy;
-import reactor.core.support.internal.PlatformDependent0;
+import reactor.core.support.internal.PlatformDependent;
 import sun.misc.Unsafe;
 
 /**
@@ -32,7 +32,7 @@
  */
 final class MultiProducerSequencer extends Sequencer
 {
-    private static final Unsafe UNSAFE = PlatformDependent0.getUnsafe();
+    private static final Unsafe UNSAFE = PlatformDependent.getUnsafe();
     private static final long   BASE   = UNSAFE.arrayBaseOffset(int[].class);
     private static final long   SCALE  = UNSAFE.arrayIndexScale(int[].class);
 

File: src/main/java/reactor/core/queue/disruptor/UnsafeRingBuffer.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.queue.disruptor;
 
 import reactor.core.support.Exceptions;
-import reactor.core.support.internal.PlatformDependent0;
+import reactor.core.support.internal.PlatformDependent;
 import reactor.fn.Supplier;
 import sun.misc.Unsafe;
 
@@ -30,7 +30,7 @@ abstract class RingBufferFields<E> extends reactor.core.queue.disruptor.RingBuff
     private static final int  BUFFER_PAD;
     private static final long REF_ARRAY_BASE;
     private static final int  REF_ELEMENT_SHIFT;
-    private static final Unsafe UNSAFE = PlatformDependent0.getUnsafe();
+    private static final Unsafe UNSAFE = PlatformDependent.getUnsafe();
 
     static {
         final int scale = UNSAFE.arrayIndexScale(Object[].class);

File: src/main/java/reactor/core/queue/disruptor/UnsafeSequence.java
Patch:
@@ -16,7 +16,7 @@
 package reactor.core.queue.disruptor;
 
 import reactor.core.support.ReactiveState;
-import reactor.core.support.internal.PlatformDependent0;
+import reactor.core.support.internal.PlatformDependent;
 import reactor.fn.LongSupplier;
 import sun.misc.Unsafe;
 
@@ -51,7 +51,7 @@ final class UnsafeSequence extends reactor.core.queue.disruptor.RhsPadding
 
     static
     {
-        UNSAFE = PlatformDependent0.getUnsafe();
+        UNSAFE = PlatformDependent.getUnsafe();
         try
         {
             VALUE_OFFSET = UNSAFE.objectFieldOffset(Value.class.getDeclaredField("value"));

File: src/main/java/reactor/core/publisher/MonoNext.java
Patch:
@@ -33,7 +33,7 @@
  * {@see https://github.com/reactor/reactive-streams-commons}
  * @since 2.5
  */
-public final class MonoNext<T> extends Mono.MonoBarrier<T, T> {
+final class MonoNext<T> extends Mono.MonoBarrier<T, T> {
 
 	public MonoNext(Publisher<? extends T> source) {
 		super(source);

File: src/main/java/reactor/core/converter/RxJava1Converter.java
Patch:
@@ -22,7 +22,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.publisher.Flux;
-import reactor.core.publisher.FluxJust;
 import reactor.core.subscription.BackpressureUtils;
 import reactor.core.subscription.EmptySubscription;
 import reactor.core.support.Exceptions;
@@ -68,7 +67,7 @@ public void call(final rx.Subscriber<? super Object> subscriber) {
 	public Flux toPublisher(Object o) {
 		final Observable<Object> obs = (Observable<Object>) o;
 		if (ScalarSynchronousObservable.class.isAssignableFrom(obs.getClass())) {
-			return new FluxJust<>(((ScalarSynchronousObservable) obs).get());
+			return Flux.just(((ScalarSynchronousObservable) obs).get());
 		}
 		return new Flux<Object>() {
 			@Override

File: src/main/java/reactor/core/timer/HashWheelTimer.java
Patch:
@@ -524,7 +524,9 @@ public void request(long n) {
 			if (BackpressureUtils.checkRequest(n, delegate)) {
 				for(;;) {
 					if (STATUS.compareAndSet(this, STATUS_READY, STATUS_REQUESTED) ||
-							STATUS.compareAndSet(this, STATUS_PAUSED, STATUS_PAUSED_REQUESTED)){
+							STATUS.compareAndSet(this, STATUS_PAUSED, STATUS_PAUSED_REQUESTED) ||
+							status > STATUS_PAUSED ||
+							isCancelled()){
 						break;
 					}
 				}

File: src/main/java/reactor/core/timer/HashWheelTimer.java
Patch:
@@ -181,6 +181,7 @@ else if (r.ready()) {
 								}
 								throw re;
 							}
+
 							registrations.remove(r);
 
 							if (r.asInterval() != null) {

File: src/main/java/reactor/Flux.java
Patch:
@@ -268,7 +268,7 @@ public static <T, C> Flux<T> create(Consumer<SubscriberWithContext<T, C>> reques
 	public static <T, C> Flux<T> create(final Consumer<SubscriberWithContext<T, C>> requestConsumer,
 			Function<Subscriber<? super T>, C> contextFactory,
 			Consumer<C> shutdownConsumer) {
-		return FluxFactory.create(requestConsumer, contextFactory, shutdownConsumer);
+		return FluxFactory.createForEach(requestConsumer, contextFactory, shutdownConsumer);
 	}
 
 	/**
@@ -824,8 +824,9 @@ public final <V, P extends Publisher<V>> P as(Function<? super Flux<T>, P> trans
 	 *
 	 * @return a new {@link Mono}
 	 */
+	@SuppressWarnings("unchecked")
 	public final Mono<Void> after() {
-		return new MonoIgnoreElements<>(this);
+		return (Mono<Void>)new MonoIgnoreElements<>(this);
 	}
 
 	/**

File: src/main/java/reactor/core/error/CancelException.java
Patch:
@@ -22,7 +22,7 @@
  *
  * @author Stephane Maldini
  */
-public final class CancelException extends ReactorFatalException {
+public final class CancelException extends Exceptions.UpstreamException {
 	public static final CancelException INSTANCE = new CancelException();
 
 	private CancelException() {

File: src/main/java/reactor/core/processor/EmitterProcessor.java
Patch:
@@ -26,8 +26,8 @@
 import org.reactivestreams.Subscription;
 import reactor.Flux;
 import reactor.core.error.CancelException;
+import reactor.core.error.Exceptions;
 import reactor.core.error.InsufficientCapacityException;
-import reactor.core.error.ReactorFatalException;
 import reactor.core.subscription.EmptySubscription;
 import reactor.core.support.BackpressureUtils;
 import reactor.core.support.ReactiveState;
@@ -230,7 +230,7 @@ else if(poll == null){
 	public void onError(Throwable t) {
 		super.onError(t);
 		if (autoCancel && done) {
-			throw ReactorFatalException.create(t);
+			Exceptions.onErrorDropped(t);
 		}
 		reportError(t);
 		done = true;

File: src/main/java/reactor/core/publisher/FluxFactory.java
Patch:
@@ -91,9 +91,9 @@ public static <T, C> Flux<T> generate(BiConsumer<Long, SubscriberWithContext<T,
 	 *
 	 * @return a fresh Reactive Streams publisher ready to be subscribed
 	 */
-	public static <T, C> Flux<T> create(Consumer<SubscriberWithContext<T, C>> requestConsumer,
+	public static <T, C> Flux<T> createForEach(Consumer<SubscriberWithContext<T, C>> requestConsumer,
 			Function<Subscriber<? super T>, C> contextFactory) {
-		return create(requestConsumer, contextFactory, null);
+		return createForEach(requestConsumer, contextFactory, null);
 	}
 
 	/**
@@ -113,7 +113,7 @@ public static <T, C> Flux<T> create(Consumer<SubscriberWithContext<T, C>> reques
 	 *
 	 * @return a fresh Reactive Streams publisher ready to be subscribed
 	 */
-	public static <T, C> Flux<T> create(final Consumer<SubscriberWithContext<T, C>> requestConsumer,
+	public static <T, C> Flux<T> createForEach(final Consumer<SubscriberWithContext<T, C>> requestConsumer,
 			Function<Subscriber<? super T>, C> contextFactory,
 			Consumer<C> shutdownConsumer) {
 		Assert.notNull(requestConsumer, "A data producer must be provided");

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -26,7 +26,6 @@
 import org.reactivestreams.Subscription;
 import reactor.Flux;
 import reactor.core.error.Exceptions;
-import reactor.core.error.ReactorFatalException;
 import reactor.core.subscriber.BaseSubscriber;
 import reactor.core.subscriber.SubscriberWithDemand;
 import reactor.core.subscription.EmptySubscription;
@@ -394,7 +393,7 @@ public Throwable getError() {
 
 		void reportError(Throwable t) {
 			if (!ERROR.compareAndSet(this, null, t)) {
-				throw ReactorFatalException.create(t);
+				Exceptions.onErrorDropped(t);
 			}
 		}
 

File: src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -15,8 +15,6 @@
  */
 package reactor.core.publisher;
 
-import java.util.Objects;
-
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -210,7 +208,8 @@ public Object upstream() {
 	    void error(Throwable e){
 		    done = true;
 		    s.cancel();
-		    actual.onError(e);
+		    Exceptions.throwIfFatal(e);
+		    actual.onError(Exceptions.unwrap(e));
 	    }
     }
 }
\ No newline at end of file

File: src/main/java/reactor/core/publisher/FluxZip.java
Patch:
@@ -30,7 +30,6 @@
 import org.reactivestreams.Subscription;
 import reactor.Flux;
 import reactor.core.error.Exceptions;
-import reactor.core.error.ReactorFatalException;
 import reactor.core.subscriber.BaseSubscriber;
 import reactor.core.subscription.EmptySubscription;
 import reactor.core.support.BackpressureUtils;
@@ -266,7 +265,7 @@ public void cancel() {
 
 		void reportError(Throwable throwable) {
 			if (!ERROR.compareAndSet(this, null, throwable)) {
-				throw ReactorFatalException.create(throwable);
+				Exceptions.onErrorDropped(throwable);
 			}
 			actual.onError(throwable);
 		}

File: src/main/java/reactor/core/publisher/ForEachSequencer.java
Patch:
@@ -25,7 +25,7 @@
 import reactor.fn.Function;
 
 /**
- * Simple iterating consumer for {@link FluxFactory#create(Consumer, Function)} and its alias
+ * Simple iterating consumer for {@link FluxFactory#createForEach(Consumer, Function)} and its alias
  *
  * @param <T>
  *

File: src/main/java/reactor/core/subscriber/ConsumerSubscriber.java
Patch:
@@ -19,7 +19,6 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import reactor.core.error.Exceptions;
-import reactor.core.error.ReactorFatalException;
 import reactor.core.support.BackpressureUtils;
 import reactor.core.support.ReactiveState;
 import reactor.fn.Consumer;
@@ -133,7 +132,7 @@ protected void doError(Throwable t) {
 			errorConsumer.accept(t);
 		}
 		else {
-			throw ReactorFatalException.create(t);
+			Exceptions.onErrorDropped(t);
 		}
 	}
 

File: src/main/java/reactor/core/subscriber/SubscriberWithSubscriptionContext.java
Patch:
@@ -20,7 +20,6 @@
 import org.reactivestreams.Subscription;
 import reactor.core.error.CancelException;
 import reactor.core.error.Exceptions;
-import reactor.core.error.ReactorFatalException;
 import reactor.core.subscription.SubscriptionWithContext;
 import reactor.core.support.Assert;
 import reactor.core.support.BackpressureUtils;
@@ -133,7 +132,7 @@ public void onError(Throwable t) {
 			errorConsumer.accept(t, subscriptionWithContext != null ? subscriptionWithContext.context() : null);
 		}
 		else {
-			throw ReactorFatalException.create(t);
+			Exceptions.onErrorDropped(t);
 		}
 	}
 

File: src/main/java/reactor/core/subscription/ReactiveSession.java
Patch:
@@ -27,7 +27,6 @@
 import reactor.core.error.CancelException;
 import reactor.core.error.Exceptions;
 import reactor.core.error.InsufficientCapacityException;
-import reactor.core.error.ReactorFatalException;
 import reactor.core.support.BackpressureUtils;
 import reactor.core.support.ReactiveState;
 import reactor.core.timer.TimeUtils;
@@ -388,7 +387,7 @@ public void onNext(E e) {
 				actual.onError(uncaughtException);
 				return;
 			}
-			throw ReactorFatalException.create(new IllegalStateException("Cached error cannot be null"));
+			throw new IllegalStateException("Cached error cannot be null");
 		}
 	}
 

File: src/main/java/reactor/core/timer/TimeUtils.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import reactor.core.error.ReactorFatalException;
+import reactor.core.error.Exceptions;
 import reactor.core.support.WaitStrategy;
 import reactor.core.support.internal.PlatformDependent;
 import reactor.core.support.rb.disruptor.Sequence;
@@ -109,7 +109,7 @@ Timer getTimer() {
 
 	public static void checkResolution(long time, long resolution) {
 		if (time % resolution != 0) {
-			throw ReactorFatalException.create(new IllegalArgumentException(
+			Exceptions.failUpstream(new IllegalArgumentException(
 			  "Period must be a multiple of Timer resolution (e.g. period % resolution == 0 ). " +
 				"Resolution for this Timer is: " + resolution + "ms"
 			));

File: src/test/java/reactor/core/processor/AbstractProcessorVerification.java
Patch:
@@ -96,12 +96,12 @@ public Processor<Long, Long> createIdentityProcessor(int bufferSize) {
 
 	/*@Override
 	public Publisher<Long> createHelperPublisher(long elements) {
-		return Publishers.log(super.createHelperPublisher(elements), "publisher");
+		return Flux.log(super.createHelperPublisher(elements), "publisher");
 	}*/
 
 	/*@Override
 	public Publisher<Long> createHelperPublisher(long elements) {
-		return Publishers.<Long, AtomicLong>create(
+		return Flux.<Long, AtomicLong>create(
 		  (s) -> {
 			  long cursor = s.context().getAndIncrement();
 			  if (cursor < elements) {

File: src/test/java/reactor/core/processor/ProcessorGroupWorkTests.java
Patch:
@@ -21,7 +21,7 @@
 import org.reactivestreams.Processor;
 import org.testng.SkipException;
 import reactor.Processors;
-import reactor.core.error.ReactorFatalException;
+import reactor.core.error.Exceptions;
 import reactor.core.support.Assert;
 import reactor.fn.BiConsumer;
 import reactor.fn.Consumer;
@@ -64,7 +64,7 @@ public void simpleTest() throws Exception {
 				Thread.sleep(1000);
 			}
 			catch(InterruptedException ie){
-				throw ReactorFatalException.create(ie);
+				Exceptions.fail(ie);
 			}
 		};
 		r.accept("Hello World!", c);

File: src/test/java/reactor/core/publisher/CombinationTests.java
Patch:
@@ -74,7 +74,7 @@ public Consumer<Object> loggingConsumer() {
 	public void testMerge1ToN() throws Exception {
 		final int n = 1000;
 
-		Stream<Integer> stream = Publishers.merge(Publishers.map(Publishers.just(1), i -> Streams.range(0, n)));
+		Stream<Integer> stream = Flux.merge(Flux.map(Flux.just(1), i -> Streams.range(0, n)));
 
 		final CountDownLatch latch = new CountDownLatch(n);
 		awaitLatch(stream.consume(integer -> latch.countDown()), latch);

File: src/main/java/reactor/core/support/QueueSupplier.java
Patch:
@@ -58,7 +58,7 @@ public static <T> Supplier<Queue<T>> get(long batchSize){
 	@Override
 	public Queue<T> get() {
 
-		if(batchSize > Integer.MAX_VALUE){
+		if(batchSize > 10_000_000){
 			return new ConcurrentLinkedQueue<>();
 		}
 		else if(batchSize == 1){

File: src/main/java/reactor/core/support/rb/disruptor/RingBuffer.java
Patch:
@@ -551,6 +551,7 @@ static final class SPSCQueue<T>  extends WriteQueue<T> {
 			super(buffer);
 			this.pollCursor = Sequencer.newSequence(startingSequence);
 			buffer.addGatingSequence(pollCursor);
+			this.pollCursor.set(startingSequence);
 		}
 
 		@Override

File: src/main/java/reactor/core/support/QueueSupplier.java
Patch:
@@ -42,7 +42,7 @@ public final class QueueSupplier<T> implements Supplier<Queue<T>> {
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T> Supplier<Queue<T>> get(long batchSize){
-		if(batchSize > Integer.MAX_VALUE){
+		if(batchSize > 10_000_000){
 			return (Supplier<Queue<T>>)CLQ_SUPPLIER;
 		}
 		if(batchSize == 1){

File: src/main/java/reactor/core/timer/HashWheelTimer.java
Patch:
@@ -226,7 +226,8 @@ public HashWheelSubscription interval(Subscriber<? super Long> consumer,
 			long period,
 			TimeUnit timeUnit,
 			long delayInMilliseconds) {
-		return schedule(TimeUnit.MILLISECONDS.convert(period, timeUnit), delayInMilliseconds, consumer);
+		long ms = TimeUnit.MILLISECONDS.convert(period, timeUnit);
+		return schedule(ms, delayInMilliseconds == -1 ? ms : delayInMilliseconds, consumer);
 	}
 
 	@Override

File: src/main/java/reactor/core/publisher/MonoCallable.java
Patch:
@@ -72,6 +72,6 @@ public void subscribe(Subscriber<? super T> s) {
             return;
         }
 
-        sds.set(t);
+        sds.complete(t);
     }
 }
\ No newline at end of file

File: src/main/java/reactor/core/subscriber/SubscriberDeferredScalar.java
Patch:
@@ -133,7 +133,7 @@ public void setValue(O value) {
 		this.value = value;
 	}
 
-	public final void set(O value) {
+	public final void complete(O value) {
 		Objects.requireNonNull(value);
 		for (; ; ) {
 			int s = getState();

File: src/main/java/reactor/core/support/BackpressureUtils.java
Patch:
@@ -314,7 +314,7 @@ public static long getAndSub(Sequence sequence, long toSub) {
 		do {
 			r = sequence.get();
 			if (r == 0 || r == Long.MAX_VALUE) {
-				return 0;
+				return r;
 			}
 			u = subOrZero(r, toSub);
 		} while (!sequence.compareAndSet(r, u));

File: src/main/java/reactor/core/support/ReactiveStateUtils.java
Patch:
@@ -321,6 +321,8 @@ public static String getName(Object o) {
 				o.toString() : o.getClass()
 				                .getSimpleName());
 
+		name = name.replaceAll("Mono|Flux|Stream|Subscriber","");
+
 		return name.isEmpty() ? "anonymous" : name;
 	}
 

File: src/main/java/reactor/fn/tuple/Tuple.java
Patch:
@@ -33,9 +33,9 @@
 @SuppressWarnings({"rawtypes"})
 public class Tuple implements Iterable, Serializable {
 
-	private static final long     serialVersionUID = 8777121214502020843L;
-	private static final Object[] emptyArray       = new Object[0];
-	private static final Tuple    empty            = new Tuple(0);
+	static final long     serialVersionUID = 8777121214502020843L;
+	static final Object[] emptyArray       = new Object[0];
+	static final Tuple    empty            = new Tuple(0);
 
 
 	protected final int size;

File: src/main/java/reactor/Flux.java
Patch:
@@ -768,7 +768,7 @@ public final <V, P extends Publisher<V>> P as(Function<? super Flux<T>, P> trans
 	 * Return a {@code Mono<Void>} that completes when this {@link Flux} completes.
 	 * This will actively ignore the sequence and only replay completion or error signals.
 	 *
-	 * @return a new {@link Flux}
+	 * @return a new {@link Mono}
 	 */
 	public final Mono<Void> after() {
 		return new MonoIgnoreElements<>(this);
@@ -1099,7 +1099,7 @@ public final Flux<T> mergeWith(Publisher<? extends T> source) {
 	 *
 	 * If the sequence emits more than 1 data, emit {@link ArrayIndexOutOfBoundsException}.
 	 *
-	 * @return a new {@link Flux}
+	 * @return a new {@link Mono}
 	 */
 	public final Mono<T> next() {
 		return new MonoNext<>(this);

File: src/main/java/reactor/core/support/QueueSupplier.java
Patch:
@@ -64,6 +64,6 @@ public Queue<T> get() {
 		else if(batchSize == 1){
 			return new ArrayBlockingQueue<>(1);
 		}
-		return RingBuffer.newWriteQueue(RingBuffer.<T>createSingleProducer((int) batchSize));
+		return RingBuffer.newSequencedQueue(RingBuffer.<T>createSingleProducer((int) batchSize));
 	}
 }

File: src/main/java/reactor/core/support/rb/disruptor/RingBuffer.java
Patch:
@@ -58,7 +58,7 @@ public static final class Slot<T> {
 	 * @param <T>
 	 * @return
 	 */
-	public static  <T> Queue<T> newWriteQueue(RingBuffer<Slot<T>> buffer){
+	public static  <T> Queue<T> newWriteOnlyQueue(RingBuffer<Slot<T>> buffer){
 		return new WriteQueue<>(buffer);
 	}
 

File: src/main/java/reactor/core/support/QueueSupplier.java
Patch:
@@ -62,8 +62,8 @@ public Queue<T> get() {
 			return new ConcurrentLinkedQueue<>();
 		}
 		else if(batchSize == 1){
-			return new ArrayBlockingQueue<T>(1);
+			return new ArrayBlockingQueue<>(1);
 		}
-		return RingBuffer.newWriteQueue(RingBuffer.createSingleProducer((int) batchSize));
+		return RingBuffer.newWriteQueue(RingBuffer.<T>createSingleProducer((int) batchSize));
 	}
 }

File: src/test/java/reactor/core/processor/AbstractProcessorVerification.java
Patch:
@@ -56,7 +56,7 @@ public ExecutorService publisherExecutorService() {
 	}
 
 	public AbstractProcessorVerification() {
-		super(new TestEnvironment(500));
+		super(new TestEnvironment(500, true));
 	}
 
 	@BeforeClass

File: src/main/java/reactor/core/support/rb/RingBufferSubscriberUtils.java
Patch:
@@ -125,8 +125,6 @@ else if (task.type == SignalType.ERROR) {
 
 	}
 
-	public static final Object CLEANED = new Object();
-
 	public static <T> boolean waitRequestOrTerminalEvent(LongSupplier pendingRequest,
 			RingBuffer<MutableSignal<T>> ringBuffer, SequenceBarrier barrier,
 			Subscriber<? super T> subscriber, AtomicBoolean isRunning,

File: src/main/java/reactor/core/support/BackpressureUtils.java
Patch:
@@ -314,7 +314,7 @@ public static long getAndSub(Sequence sequence, long toSub) {
 		do {
 			r = sequence.get();
 			if (r == 0 || r == Long.MAX_VALUE) {
-				return r;
+				return 0;
 			}
 			u = subOrZero(r, toSub);
 		} while (!sequence.compareAndSet(r, u));

File: src/test/java/reactor/core/processor/ProcessorGroupWorkTests.java
Patch:
@@ -45,10 +45,10 @@ public long maxSupportedSubscribers() {
 
 	//@Test
 	public void simpleTestC() throws Exception {
-		for(int i = 0; i < 1000; i++){
-			System.out.println("new test "+i);
+		//for(int i = 0; i < 1000; i++){
+//			System.out.println("new test "+i);
 			simpleTest();
-		}
+		//}
 	}
 	@Override
 	public void simpleTest() throws Exception {

File: src/main/java/reactor/core/publisher/FluxMapSignal.java
Patch:
@@ -152,6 +152,7 @@ public void onError(Throwable t) {
 	        }
 
 	        actual.onNext(v);
+	        actual.onComplete();
         }
 
         @Override
@@ -183,6 +184,7 @@ public void onComplete() {
 	        }
 
 	        actual.onNext(v);
+	        actual.onComplete();
         }
 
         @Override

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -272,7 +272,7 @@ void tryEmit(V value) {
 					if (r != Long.MAX_VALUE) {
 						REQUESTED.decrementAndGet(this);
 					}
-					if (maxConcurrency != Integer.MAX_VALUE && !isCancelled() && ++lastRequest == limit) {
+					if (maxConcurrency != Integer.MAX_VALUE && !isTerminated() && ++lastRequest == limit) {
 						lastRequest = 0;
 						subscription.request(limit);
 					}

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -581,7 +581,7 @@ void drainLoop() {
 					lastId = inner[j].id;
 				}
 
-				if (replenishMain != 0L && !d) {
+				if (replenishMain != 0L && !isTerminated()) {
 					subscription.request(maxConcurrency == 1 ? 1 : replenishMain);
 				}
 				if (innerCompleted) {

File: src/main/java/reactor/core/publisher/FluxFlatMap.java
Patch:
@@ -581,7 +581,7 @@ void drainLoop() {
 					lastId = inner[j].id;
 				}
 
-				if (replenishMain != 0L && !isCancelled()) {
+				if (replenishMain != 0L && !d) {
 					subscription.request(maxConcurrency == 1 ? 1 : replenishMain);
 				}
 				if (innerCompleted) {

