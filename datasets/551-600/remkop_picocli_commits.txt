File: picocli-shell-jline3/src/main/java/picocli/shell/jline3/PicocliCommands.java
Patch:
@@ -3,6 +3,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -170,7 +171,7 @@ public void complete(LineReader reader, ParsedLine commandLine, List<Candidate>
             String word = commandLine.word();
             List<String> words = commandLine.words();
             CommandLine sub = findSubcommandLine(words, commandLine.wordIndex());
-            if (sub == null) {
+            if (sub == null || sub.getCommandSpec().usageMessage().hidden()) {
                 return;
             }
             if (word.startsWith("-")) {
@@ -192,9 +193,9 @@ public void complete(LineReader reader, ParsedLine commandLine, List<Candidate>
                     }
                 }
             } else {
-                addCandidates(candidates, sub.getSubcommands().keySet());
                 for (CommandLine s : sub.getSubcommands().values()) {
                     if (!s.getCommandSpec().usageMessage().hidden()) {
+                        addCandidates(candidates, Collections.singletonList(s.getCommandSpec().name()));
                         addCandidates(candidates, Arrays.asList(s.getCommandSpec().aliases()));
                     }
                 }

File: picocli-codegen/src/test/java/picocli/codegen/docgen/manpage/Issue2145.java
Patch:
@@ -18,7 +18,7 @@ static class Documentation {
 
     @Test
     public void testManPageGenAsSubcommand() {
-        int result = new CommandLine(new Documentation()).execute("gen-manpage", "-dout", "-v");
+        int result = new CommandLine(new Documentation()).execute("gen-manpage", "-dbuild", "-v");
         assertEquals(0, result);
     }
 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -14910,7 +14910,7 @@ private boolean booleanValue(ArgSpec argSpec, Object value) {
             }
             String stringValue = String.valueOf(value);
             if (empty(stringValue) || "null".equals(stringValue) || "Optional.empty".equals(value)) { return false; }
-            ITypeConverter<?> converter = getTypeConverter(new Class<?>[]{Boolean.class}, argSpec, 0);
+            ITypeConverter<?> converter = getTypeConverter(argSpec.auxiliaryTypes(), argSpec, 0);
             return (Boolean) tryConvert(argSpec, -1, converter, stringValue, 0);
         }
 

File: src/test/java/picocli/CommandMethodTest.java
Patch:
@@ -449,6 +449,8 @@ public CompactFields run(
             return ret;
         }
     }
+
+    @Ignore("This is no longer true after the fix for #2149") // TODO DELETME?
     @Test
     public void testAnnotateMethod_matchesAnnotatedClass() throws Exception {
         setTraceLevel(CommandLine.TraceLevel.OFF);

File: src/test/java/picocli/ModelPositionalParamSpecTest.java
Patch:
@@ -301,7 +301,6 @@ public void testPositionalParamSpecEquals() {
                 .index("1..3");
 
         PositionalParamSpec p1 = positional.build();
-        assertEquals(p1, p1);
         assertEquals(p1, positional.build());
         assertNotEquals(p1, positional.arity("2").build());
         assertNotEquals(p1, positional.arity("1").hideParamSyntax(false).build());

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -355,7 +355,6 @@ public void testGroupSpecEquals() {
         ArgGroupSpec.Builder builder = ArgGroupSpec.builder();
         builder.addArg(OPTION);
         ArgGroupSpec a = builder.build();
-        assertEquals(a, a);
         assertNotSame(a, ArgGroupSpec.builder().addArg(OPTION).build());
         assertEquals(a, ArgGroupSpec.builder().addArg(OPTION).build());
 

File: src/test/java/picocli/ModelArgSpecTest.java
Patch:
@@ -171,7 +171,6 @@ public void testArgSpecEquals() {
                 .scopeType(CommandLine.ScopeType.INHERIT);
 
         PositionalParamSpec p1 = positional.build();
-        assertEquals(p1, p1);
         assertEquals(p1, positional.build());
         assertNotEquals(p1, positional.arity("2").build());
         assertNotEquals(p1, positional.arity("1").hideParamSyntax(false).build());

File: src/test/java/picocli/ModelOptionSpecTest.java
Patch:
@@ -366,7 +366,6 @@ public void testOptionSpecEquals() {
                 .order(123);
 
         OptionSpec p1 = option.build();
-        assertEquals(p1, p1);
         assertEquals(p1, option.build());
         assertNotEquals(p1, option.arity("2").build());
         assertNotEquals(p1, option.arity("1").hideParamSyntax(false).build());
@@ -443,7 +442,6 @@ public void testUsageSplitEquals() {
             .order(123);
 
         OptionSpec p1 = option.build();
-        assertEquals(p1, p1);
         assertEquals(p1, option.build());
         assertNotEquals(p1, option.splitRegexSynopsisLabel("\\\\?").build());
     }

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -47,6 +47,7 @@
 import static org.junit.Assert.*;
 import static picocli.ArgGroupTest.CommandMethodsWithGroupsAndMixins.InvokedSub.withMixin;
 
+@SuppressWarnings("EqualsHashCode") // https://errorprone.info/bugpattern/EqualsHashCode
 public class ArgGroupTest {
     @Rule
     public final ProvideSystemProperty ansiOFF = new ProvideSystemProperty("picocli.ansi", "false");

File: src/test/java/picocli/CompletionCandidatesTest.java
Patch:
@@ -248,7 +248,7 @@ class App {
         assertNull(candidates);
     }
 
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "ReturnValueIgnored"}) // iterable.iterator() https://errorprone.info/bugpattern/ReturnValueIgnored
     @Test(expected = UnsupportedOperationException.class)
     public void testNoCompletionCandidatesThrowsUnsupportedOperation() throws Exception {
         Class<Iterable<String>> c = (Class<Iterable<String>>) Class.forName("picocli.CommandLine$NoCompletionCandidates");

File: src/test/java/picocli/ExecuteLegacyTest.java
Patch:
@@ -408,8 +408,8 @@ public void run() {
         new CommandLine(new App()).parseWithHandlers(new RunFirst().andExit(23),
                                                     defaultExceptionHandler().andExit(25));
         assertEquals(format("" +
-                "blah%n",
-                "<main command>"), systemErrRule.getLog());
+                "blah%n"
+                ), systemErrRule.getLog());
     }
 
     @SuppressWarnings("deprecation")

File: src/test/java/picocli/TypeConversionTest.java
Patch:
@@ -192,7 +192,7 @@ public void testTypeConversionSucceedsForValidInput() throws Exception {
                 "-Pattern", "a*b", //
                 "-UUID", "c7d51423-bf9d-45dd-a30d-5b16fafe42e2", //
                 "-Currency", "EUR",
-                "-tz", "Japan/Tokyo",
+                "-tz", "Asia/Tokyo",
                 "-byteOrder", "LITTLE_ENDIAN",
                 "-Class", "java.lang.String",
                 "-NetworkInterface", "127.0.0.0",
@@ -233,7 +233,7 @@ public void testTypeConversionSucceedsForValidInput() throws Exception {
         assertEquals("Pattern", Pattern.compile("a*b").pattern(), bean.aPatternField.pattern());
         assertEquals("UUID", UUID.fromString("c7d51423-bf9d-45dd-a30d-5b16fafe42e2"), bean.anUUIDField);
         assertEquals("Currency", Currency.getInstance("EUR"), bean.aCurrencyField);
-        assertEquals("TimeZone", TimeZone.getTimeZone("Japan/Tokyo"), bean.aTimeZone);
+        assertEquals("TimeZone", TimeZone.getTimeZone("Asia/Tokyo"), bean.aTimeZone);
         assertEquals("ByteOrder", ByteOrder.LITTLE_ENDIAN, bean.aByteOrder);
         assertEquals("Class", String.class, bean.aClass);
         assertEquals("NetworkInterface", NetworkInterface.getByInetAddress(InetAddress.getByName("127.0.0.0")), bean.aNetInterface);

File: picocli-shell-jline3/src/main/java/picocli/shell/jline3/PicocliCommands.java
Patch:
@@ -280,7 +280,7 @@ public List<String> commandInfo(String command) {
 
     // For JLine >= 3.16.0
     @Override
-    public Object invoke(CommandRegistry.CommandSession session, String command, Object[] args) throws Exception {
+    public Object invoke(CommandRegistry.CommandSession session, String command, Object... args) throws Exception {
         List<String> arguments = new ArrayList<>();
         arguments.add( command );
         arguments.addAll( Arrays.stream( args ).map( Object::toString ).collect( Collectors.toList() ) );

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -785,7 +785,7 @@ private static String generatePositionalParamsCases(List<PositionalParamSpec> po
             int max = param.index().max();
             if (param.completionCandidates() != null) {
                 buff.append(format("%s    %s (( currIndex >= %d && currIndex <= %d )); then\n", indent, ifOrElif, min, max));
-                buff.append(format("%s      positionals=$( compReplyArray \"${%s_pos_param_args[@]}\" )\n", indent, paramName, currWord));
+                buff.append(format("%s      positionals=$( compReplyArray \"${%s_pos_param_args[@]}\" )\n", indent, paramName));
             } else if (type.equals(File.class) || "java.nio.file.Path".equals(type.getName())) {
                 buff.append(format("%s    %s (( currIndex >= %d && currIndex <= %d )); then\n", indent, ifOrElif, min, max));
                 buff.append(format("%s      local IFS=$'\\n'\n", indent));
@@ -829,7 +829,7 @@ private static String generateOptionsCases(List<OptionSpec> argOptionFields, Str
             if (option.completionCandidates() != null) {
                 buff.append(format("%s    %s)\n", indent, concat("|", option.names()))); // "    -u|--timeUnit)\n"
                 buff.append(format("%s      local IFS=$'\\n'\n", indent));
-                buff.append(format("%s      COMPREPLY=( $( compReplyArray \"${%s_option_args[@]}\" ) )\n", indent, bashify(option.paramLabel()), currWord));
+                buff.append(format("%s      COMPREPLY=( $( compReplyArray \"${%s_option_args[@]}\" ) )\n", indent, bashify(option.paramLabel())));
                 buff.append(format("%s      return $?\n", indent));
                 buff.append(format("%s      ;;\n", indent));
             } else if (type.equals(File.class) || "java.nio.file.Path".equals(type.getName())) {

File: picocli-shell-jline3/src/test/java/picocli/shell/jline3/example/Example.java
Patch:
@@ -1,6 +1,7 @@
 package picocli.shell.jline3.example;
 
 import org.fusesource.jansi.AnsiConsole;
+import org.jline.builtins.ConfigurationPath;
 import org.jline.console.SystemRegistry;
 import org.jline.console.impl.Builtins;
 import org.jline.console.impl.SystemRegistryImpl;

File: picocli-shell-jline3/src/test/java/picocli/shell/jline3/example/Example.java
Patch:
@@ -134,7 +134,7 @@ public static void main(String[] args) {
         try {
             Supplier<Path> workDir = () -> Paths.get(System.getProperty("user.dir"));
             // set up JLine built-in commands
-            Builtins builtins = new Builtins(workDir, null, null);
+            Builtins builtins = new Builtins(workDir, new ConfigurationPath(workDir.get(), workDir.get()), null);
             builtins.rename(Builtins.Command.TTOP, "top");
             builtins.alias("zle", "widget");
             builtins.alias("bindkey", "keymap");

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -14153,6 +14153,7 @@ private int applyOption(ArgSpec argSpec,
 
             if (argSpec.parameterConsumer() != null) {
                 argSpec.parameterConsumer().consumeParameters(args, argSpec, commandSpec);
+                addToInitialized(argSpec, initialized);
                 return args.size() - originalSize;
             }
             boolean consumeOnlyOne = commandSpec.parser().aritySatisfiedByAttachedOptionParam() && lookBehind.isAttached();

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -17845,9 +17845,9 @@ static boolean calcTTY() {
                     if (console == null) {
                         return false;
                     }
-                    try {
+                    try { // [#2083][#2084] Java 22 update
                         Method isTerminal = Class.forName("java.io.Console").getDeclaredMethod("isTerminal");
-                        return (boolean) isTerminal.invoke(console);
+                        return (Boolean) isTerminal.invoke(console);
                     } catch (NoSuchMethodException e) {
                         return true;
                     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -9526,6 +9526,7 @@ abstract static class Builder<T extends Builder<T>> {
                     setter = original.setter;
                     scope = original.scope;
                     scopeType = original.scopeType;
+                    mapFallbackValue = original.mapFallbackValue;
                     originalDefaultValue = original.originalDefaultValue;
                     originalMapFallbackValue = original.originalMapFallbackValue;
                 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -18487,7 +18487,7 @@ public static class TypeConversionException extends PicocliException {
     /** Exception indicating something went wrong while parsing command line options. */
     public static class ParameterException extends PicocliException {
         private static final long serialVersionUID = 1477112829129763139L;
-        private final CommandLine commandLine;
+        protected final CommandLine commandLine;
         private ArgSpec argSpec = null;
         private String value = null;
 
@@ -18659,7 +18659,7 @@ public boolean printSuggestions(PrintWriter writer) {
             if (!suggestions.isEmpty()) {
                 writer.println(isUnknownOption()
                         ? "Possible solutions: " + str(suggestions)
-                        : "Did you mean: " + str(suggestions).replace(", ", " or ") + "?");
+                        : "Did you mean: " + this.commandLine.commandSpec.name + " " + str(suggestions).replace(", ", " or ") + "?");
                 writer.flush();
             }
             return !suggestions.isEmpty();

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/DynamicProxyConfigGenerator.java
Patch:
@@ -58,7 +58,7 @@ public class DynamicProxyConfigGenerator {
             },
             footerHeading = "%nExample%n",
             footer = {
-                "  java -cp \"myapp.jar;picocli-4.7.3-SNAPSHOT.jar;picocli-codegen-4.7.3-SNAPSHOT.jar\" " +
+                "  java -cp \"myapp.jar;picocli-4.7.3.jar;picocli-codegen-4.7.3.jar\" " +
                         "picocli.codegen.aot.graalvm.DynamicProxyConfigGenerator my.pkg.MyClass"
             },
             mixinStandardHelpOptions = true, version = "picocli-codegen gen-proxy-config " + CommandLine.VERSION)

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/JniConfigGenerator.java
Patch:
@@ -31,7 +31,7 @@ public class JniConfigGenerator {
             },
             footerHeading = "%nExample%n",
             footer = {
-                    "  java -cp \"myapp.jar;picocli-4.7.3-SNAPSHOT.jar;picocli-codegen-4.7.3-SNAPSHOT.jar\" " +
+                    "  java -cp \"myapp.jar;picocli-4.7.3.jar;picocli-codegen-4.7.3.jar\" " +
                             "picocli.codegen.aot.graalvm.JniConfigGenerator my.pkg.MyClass"
             },
             mixinStandardHelpOptions = true, sortOptions = false,

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ReflectionConfigGenerator.java
Patch:
@@ -95,7 +95,7 @@ public class ReflectionConfigGenerator {
             },
             footerHeading = "%nExample%n",
             footer = {
-                    "  java -cp \"myapp.jar;picocli-4.7.3-SNAPSHOT.jar;picocli-codegen-4.7.3-SNAPSHOT.jar\" " +
+                    "  java -cp \"myapp.jar;picocli-4.7.3.jar;picocli-codegen-4.7.3.jar\" " +
                             "picocli.codegen.aot.graalvm.ReflectionConfigGenerator my.pkg.MyClass"
             },
             mixinStandardHelpOptions = true, sortOptions = false,

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ResourceConfigGenerator.java
Patch:
@@ -54,7 +54,7 @@ public class ResourceConfigGenerator {
             },
             footerHeading = "%nExample%n",
             footer = {
-                    "  java -cp \"myapp.jar;picocli-4.7.3-SNAPSHOT.jar;picocli-codegen-4.7.3-SNAPSHOT.jar\" " +
+                    "  java -cp \"myapp.jar;picocli-4.7.3.jar;picocli-codegen-4.7.3.jar\" " +
                             "picocli.codegen.aot.graalvm.ResourceConfigGenerator my.pkg.MyClass"
             },
             mixinStandardHelpOptions = true, version = "picocli-codegen gen-resource-config " + CommandLine.VERSION)

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -190,7 +190,7 @@ private void verboseDetailed(String message, Object... params) {
                     "",
                     "Example",
                     "-------",
-                    "  java -Duser.language=de -cp \"myapp.jar;picocli-4.7.3-SNAPSHOT.jar;picocli-codegen-4.7.3-SNAPSHOT.jar\" " +
+                    "  java -Duser.language=de -cp \"myapp.jar;picocli-4.7.3.jar;picocli-codegen-4.7.3.jar\" " +
                             "picocli.codegen.docgen.manpage.ManPageGenerator my.pkg.MyClass"
             }
     )

File: picocli-tests-java567/src/test/java/picocli/AutoCompleteSystemExitTest.java
Patch:
@@ -86,8 +86,9 @@ public class AutoCompleteSystemExitTest {
         "%n" +
         "Example%n" +
         "-------%n" +
-        "  java -cp \"myapp.jar;picocli-4.7.2-SNAPSHOT.jar\" \\%n" +
-        "              picocli.AutoComplete my.pkg.MyClass%n");
+        "  java -cp \"myapp.jar;picocli-%s.jar\" \\%n" +
+        "              picocli.AutoComplete my.pkg.MyClass%n",
+        CommandLine.VERSION);
 
     private String expectedCompletionScriptForAutoCompleteApp() {
         return String.format("" +

File: picocli-tests-java9plus/src/test/java/picocli/AutoCompleteSystemExitTest.java
Patch:
@@ -74,8 +74,9 @@ public class AutoCompleteSystemExitTest {
         "%n" +
         "Example%n" +
         "-------%n" +
-        "  java -cp \"myapp.jar;picocli-4.7.2-SNAPSHOT.jar\" \\%n" +
-        "              picocli.AutoComplete my.pkg.MyClass%n");
+        "  java -cp \"myapp.jar;picocli-%s.jar\" \\%n" +
+        "              picocli.AutoComplete my.pkg.MyClass%n",
+        CommandLine.VERSION);
 
     private String expectedCompletionScriptForAutoCompleteApp() {
         return String.format("" +

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -116,7 +116,7 @@ private static boolean syspropDefinedAndNotFalse(String key) {
                     "",
                     "Example",
                     "-------",
-                    "  java -cp \"myapp.jar;picocli-4.7.3-SNAPSHOT.jar\" \\",
+                    "  java -cp \"myapp.jar;picocli-4.7.3.jar\" \\",
                     "              picocli.AutoComplete my.pkg.MyClass"
             },
             exitCodeListHeading = "%nExit Codes:%n",

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -138,7 +138,7 @@ class App {
     }
     @Test
     public void testVersion() {
-        assertEquals("4.7.3-SNAPSHOT", CommandLine.VERSION);
+        assertEquals("4.7.3", CommandLine.VERSION);
     }
     @Test
     public void testArrayPositionalParametersAreReplacedNotAppendedTo() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -14551,7 +14551,8 @@ private List<Object> consumeArguments(ArgSpec argSpec,
             String fallback = consumed == 0 && argSpec.isOption() && !OptionSpec.DEFAULT_FALLBACK_VALUE.equals(((OptionSpec) argSpec).fallbackValue())
                     ? ((OptionSpec) argSpec).fallbackValue()
                     : null;
-            if (fallback != null && (args.isEmpty() || !varargCanConsumeNextValue(argSpec, args.peek())
+            boolean hasFallback = fallback != null || (argSpec.isOption() && Option.NULL_VALUE.equals(((OptionSpec) argSpec).originalFallbackValue));
+            if (hasFallback && (args.isEmpty() || !varargCanConsumeNextValue(argSpec, args.peek())
                     || (!canConsumeOneArgument(argSpec, lookBehind, alreadyUnquoted, arity, consumed, args.peek(), argDescription)))) {
                 args.push(fallback);
             }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -7536,7 +7536,7 @@ boolean resemblesOption(String arg) {
                 if (arg == null) { return false; }
                 Tracer tracer = tracer();
                 if (arg.length() == 1) {
-                    if (tracer != null && tracer.isDebug()) {tracer.debug("Single-character arguments that don't match known options are considered positional parameters", arg);}
+                    if (tracer != null && tracer.isDebug()) {tracer.debug("Single-character arguments that don't match known options are considered positional parameters: %s", arg);}
                     return false;
                 }
                 try { Long.decode(arg);        return false; } catch (NumberFormatException nan) {} // negative numbers are not unknown options

File: picocli-tests-java9plus/src/test/java/picocli/AutoCompleteSystemExitTest.java
Patch:
@@ -512,11 +512,11 @@ private String expectedCompletionScriptForNonDefault() {
 
     @BeforeAll
     static void disableAnsi() {
-        // Clear the globally cached jansiConsole value that might
+        // Clear the globally cached jansiInstalled value that might
         // have been set in a previous test to force the
         // Ansi#isJansiConsoleInstalled method to recalculate
         // the cached value.
-        Ansi.jansiConsole = null;
+        Ansi.jansiInstalled = null;
     }
 
     @Test

File: src/test/java/picocli/ModelTransformerTest.java
Patch:
@@ -36,7 +36,7 @@ public CommandLine.Model.CommandSpec transform(CommandLine.Model.CommandSpec com
     public void testUsage() {
         StringWriter sw = new StringWriter();
         // Explicitly disable Ansi to make sure that the cached isJansiConsoleInstalled
-        // value doesn't inadvertently cause the usage help to be enabled.
+        // value doesn't inadvertently cause the usage help to enable ansi.
         new CommandLine(new MyCommand()).usage(new PrintWriter(sw), Ansi.OFF);
         String expected = String.format("" +
             "Usage: mycmd [-hV] [COMMAND]%n" +

File: src/test/java/picocli/I18nTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package picocli;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.contrib.java.lang.system.ProvideSystemProperty;
@@ -774,6 +775,7 @@ public void testTracingWithResourceBundle() {
 
         String expected = String.format("" +
                 "[picocli DEBUG] Creating CommandSpec for picocli.I18nCommand@6bcae9 with factory picocli.CommandLine$DefaultFactory%n" +
+                "[picocli DEBUG] Messages: Loading ResourceBundle[base=picocli.SharedMessages]...%n" +
                 "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'i18n-top' (command 'i18n-top' (user object: picocli.I18nCommand@6bcae9))%n" +
                 "[picocli DEBUG] Creating CommandSpec for class picocli.CommandLine$HelpCommand with factory picocli.CommandLine$DefaultFactory%n" +
                 "[picocli DEBUG] Adding subcommand 'help' to 'i18n-top'%n" +
@@ -786,6 +788,7 @@ public void testTracingWithResourceBundle() {
                 "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'i18n-sub' (command 'i18n-sub' (user object: class picocli.I18nSubcommand))%n" +
                 "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'help' (command 'help' (user object: class picocli.CommandLine$HelpCommand))%n" +
                 "[picocli DEBUG] Creating CommandSpec for class picocli.I18nSubcommand2 with factory picocli.CommandLine$DefaultFactory%n" +
+                "[picocli DEBUG] Messages: Loading ResourceBundle[base=picocli.ResourceBundlePropagationTest]...%n" +
                 "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.ResourceBundlePropagationTest] for command 'sub2' (command 'sub2' (user object: class picocli.I18nSubcommand2))%n" +
                 "[picocli DEBUG] Creating CommandSpec for class picocli.CommandLine$HelpCommand with factory picocli.CommandLine$DefaultFactory%n" +
                 "[picocli DEBUG] Adding subcommand 'help' to 'sub2'%n" +

File: picocli-tests-jpms-modules/app-it/src/test/java/picocli/test_jpms/modular_app/it/ResourceBundleTest.java
Patch:
@@ -7,7 +7,7 @@
 
 
 public class ResourceBundleTest {
-    public static void main(String... args) {
+    public static void main(String... args) throws Exception {
         new ResourceBundleTest().testLoadBundleModular();
     }
 

File: picocli-codegen/src/test/java/picocli/codegen/docgen/manpage/ManPageGeneratorTest.java
Patch:
@@ -210,7 +210,6 @@ class MyApp {
         assertEquals(expected, sw.toString());
     }
 
-    @Ignore("[#1930] - needs test fixes for #1896 changes")
     @Test
     public void testHiddenOptions() throws IOException {
 
@@ -288,7 +287,6 @@ private String readAndClose(InputStream in) throws IOException {
         }
     }
 
-    @Ignore("[#1930] - needs test fixes for #1896 changes")
     @Test
     public void testEndOfOptionsWithoutOptions() throws IOException {
 
@@ -458,7 +456,6 @@ public Integer call() throws Exception {
         }
     }
 
-    @Ignore("[#1930] - needs test fixes for #1896 changes")
     @Test
     public void testNamelessCommand() throws IOException {
         File outdir = new File(System.getProperty("java.io.tmpdir"), "manpage" + System.currentTimeMillis());

File: picocli-annotation-processing-tests/src/test/resources/generated/picocli/examples/PopulateFlagsMain.java
Patch:
@@ -10,7 +10,7 @@ private static class Options {
         private boolean buffered;
 
         @Option(names = "-o")
-        private boolean overwriteOutput; // TODO = true;
+        private boolean overwriteOutput;
 
         @Option(names = "-v")
         private boolean verbose;

File: picocli-annotation-processing-tests/src/test/resources/generated/picocli/issue769/SubCommand.java
Patch:
@@ -6,6 +6,5 @@
 
 @Command(name = "SubCommand")
 class SubCommand {
-    @Mixin
-    MyMixin someMixin;
+    @Mixin MyMixin someMixin;
 }

File: src/test/java/picocli/HelpSubCommandTest.java
Patch:
@@ -511,7 +511,6 @@ static class ImportCommand implements Runnable {
         @Parameters(arity = "1..*")
         public List<String> files;
 
-        @Override
         public void run() {
             System.out.println("ImportCommand.run()");
         }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -16340,7 +16340,8 @@ public String commandList() {
          * @since 4.4 */
         public String commandList(Map<String, Help> subcommands) {
             if (subcommands.isEmpty()) { return ""; }
-            int commandLength = maxLength(subcommands.keySet());
+            int maxCommandLength = width() / 2;
+            int commandLength = Math.min(maxLength(subcommands.keySet()), maxCommandLength);
             Help.TextTable textTable = Help.TextTable.forColumns(colorScheme().ansi(),
                     new Help.Column(commandLength + 2, 2, Help.Column.Overflow.SPAN),
                     new Help.Column(width() - (commandLength + 2), 2, Help.Column.Overflow.WRAP));

File: picocli-examples/src/main/java/picocli/examples/defaultprovider/SimpleDefaultProviderDemo.java
Patch:
@@ -32,7 +32,7 @@ public void run() {
     }
 
     public static void main(String[] args) {
-        new CommandLine(new SimplePropertyDefaultProviderDemo()).execute(args);
+        new CommandLine(new SimpleDefaultProviderDemo()).execute(args);
     }
 }
 

File: picocli-examples/src/main/java/picocli/examples/defaultprovider/SimplePropertyDefaultProviderDemo.java
Patch:
@@ -15,7 +15,7 @@
 
 @Command(name = "demo", mixinStandardHelpOptions = true, version = "3.9.3",
         description = "Demonstrate parsing & type conversion",
-        defaultValueProvider = PropertyDefaultProvider.class)
+        defaultValueProvider = SimpleDefaultProvider.class)
 public class SimplePropertyDefaultProviderDemo implements Runnable { // ...
 
     @Option(names = "-x", description = "Print count. ${DEFAULT-VALUE} by default.")

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -4,6 +4,7 @@
 import picocli.CommandLine.Command;
 import picocli.CommandLine.IFactory;
 import picocli.CommandLine.Mixin;
+import picocli.CommandLine.Model;
 import picocli.CommandLine.Model.ArgGroupSpec;
 import picocli.CommandLine.Model.CommandSpec;
 import picocli.CommandLine.Model.IAnnotatedElement;
@@ -179,7 +180,7 @@ private static String stacktrace(Exception e) {
     }
 
     private boolean tryProcess(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-
+        Model.Messages.loadBundles = false;
         new AnnotationValidator(processingEnv).validateAnnotations(roundEnv);
 
         Context context = new Context();

File: src/test/java/picocli/Issue1767.java
Patch:
@@ -20,13 +20,12 @@ public class Issue1767 {
     static class TestCommand implements Callable<Integer> {
         @ArgGroup TestArgGroup testArgGroup;
         @Spec CommandSpec spec;
-        
+
         public static class TestArgGroup {
             @Option(names = "-r")
             public Integer option1;
         }
 
-        @Override
         public Integer call() throws Exception {
             Integer value = spec.options().get(0).getValue();
             return value==null ? 0 : value;

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -432,7 +432,7 @@ private static class CommandDescriptor {
             + "# Example usage:\n"
             + "# local options=(\"foo\", \"bar\", \"baz\")\n"
             + "# local IFS=$'\\n'\n"
-            + "# COMPREPLY=$(compReplyArray \"${options[@]}\")\n" +
+            + "# COMPREPLY=($(compReplyArray \"${options[@]}\"))\n" +
             "function compReplyArray() {\n" +
             "  declare -a options\n" +
             "  options=(\"$@\")\n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -7010,7 +7010,7 @@ public CommandSpec addMixin(String name, CommandSpec mixin) {
                 mixins.put(interpolator.interpolate(name), mixin);
 
                 initName(interpolator.interpolateCommandName(mixin.name()));
-                // TODO initAliases(mixin.aliases()); // should we?
+                initAliases(mixin.aliases()); // should we?
                 // TODO initCommandHierarchyWithResourceBundle(mixin.usageMessage().messages().resourceBundleBaseName(), );
                 initFrom(mixin);
 
@@ -7455,6 +7455,7 @@ public void updateCommandAttributes(Command cmd, IFactory factory) {
                 }
             }
 
+            void initAliases(String[] aliases)          { if (aliases != null) { this.aliases.addAll(Arrays.asList(aliases));}}
             void initName(String value)                 { if (initializable(name, value, DEFAULT_COMMAND_NAME))                           {name = value;} }
             void initHelpCommand(boolean value)         { if (initializable(isHelpCommand, value, DEFAULT_IS_HELP_COMMAND))               {isHelpCommand = value;} }
             void initVersion(String[] value)            { if (initializable(version, value, UsageMessageSpec.DEFAULT_MULTI_LINE))         {version = value.clone();} }

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -642,7 +642,7 @@ private static String generateFunctionForCommand(String functionName, String com
                 "    local positionals=\"\"\n" +
                 "%s" +
                 "    local IFS=$'\\n'\n" +
-                "    COMPREPLY=( $(compgen -W \"${commands// /$'\n'}${IFS}${positionals}\" -- \"${curr_word}\") )\n" +
+                "    COMPREPLY=( $(compgen -W \"${commands// /$'\\n'}${IFS}${positionals}\" -- \"${curr_word}\") )\n" +
                 "  fi\n" +
                 "}\n";
 

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -641,7 +641,8 @@ private static String generateFunctionForCommand(String functionName, String com
                 "  else\n" +
                 "    local positionals=\"\"\n" +
                 "%s" +
-                "    COMPREPLY=( $(compgen -W \"${commands} ${positionals}\" -- \"${curr_word}\") )\n" +
+                "    local IFS=$'\\n'\n" +
+                "    COMPREPLY=( $(compgen -W \"${commands// /$'\n'}${IFS}${positionals}\" -- \"${curr_word}\") )\n" +
                 "  fi\n" +
                 "}\n";
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -834,7 +834,7 @@ public CommandLine setOptionsCaseInsensitive(boolean newValue) {
     }
 
     /** Returns whether abbreviation of subcommands should be allowed when matching subcommands. The default is {@code false}.
-     * @return {@code true} if subcommands can be matched when they are abbrevations of the {@code getCommandName()} value of a registered one, {@code false} otherwise.
+     * @return {@code true} if subcommands can be matched when they are abbreviations of the {@code getCommandName()} value of a registered one, {@code false} otherwise.
      *       For example, if true, for a subcommand with name {@code helpCommand}, inputs like {@code h}, {@code h-c} and {@code hC} are all recognized.
      * @since 4.4 */
     public boolean isAbbreviatedSubcommandsAllowed() {
@@ -860,7 +860,7 @@ public CommandLine setAbbreviatedSubcommandsAllowed(boolean newValue) {
     }
 
     /** Returns whether abbreviation of option names should be allowed when matching options. The default is {@code false}.
-     * @return {@code true} if options can be matched when they are abbrevations of the {@code names()} value of a registered one, {@code false} otherwise.
+     * @return {@code true} if options can be matched when they are abbreviations of the {@code names()} value of a registered one, {@code false} otherwise.
      *       For example, if true, for a subcommand with name {@code --helpMe}, inputs like {@code --h}, {@code --h-m} and {@code --hM} are all recognized.
      * @since 4.4 */
     public boolean isAbbreviatedOptionsAllowed() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -11737,7 +11737,7 @@ static CommandSpec extractCommandSpec(Object command, IFactory factory, boolean
 
                 CommandUserObject userObject = CommandUserObject.create(command, factory);
                 t.debug("Creating CommandSpec for %s with factory %s", userObject, factory.getClass().getName());
-                CommandSpec result = CommandSpec.wrapWithoutInspection(userObject);
+                CommandSpec result = CommandSpec.wrapWithoutInspection(userObject, factory);
 
                 boolean hasCommandAnnotation = false;
                 if (userObject.isMethod()) {

File: src/test/java/picocli/Issue1741.java
Patch:
@@ -1,6 +1,5 @@
 package picocli;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Parameters;
@@ -32,7 +31,6 @@ void enter(@Parameters(arity = "1") String sentenceType,
         }
     }
 
-    @Ignore
     @Test
     public void testIssue1741_subcommandAddedProgrammatically() {
         CommandLine commandLine = getTestCommandLine(new ParentTestCommand(), new TestCommand(), CommandLine.defaultFactory());

File: src/test/java/picocli/Issue1741.java
Patch:
@@ -8,7 +8,7 @@
 import static org.junit.Assert.*;
 import static picocli.CommandLine.ScopeType.INHERIT;
 
-public class Issue1471 {
+public class Issue1741 {
     public CommandLine getTestCommandLine(ParentTestCommand parentCommand, TestCommand testCommand, CommandLine.IFactory factory) {
         CommandLine commandLine = new CommandLine(parentCommand, factory);
         commandLine.addSubcommand(testCommand);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10339,6 +10339,8 @@ public static class ArgGroupSpec implements IOrdered {
                 headingKey       = NO_HEADING_KEY.equals(builder.headingKey) ? null : builder.headingKey;
                 exclusive        = builder.exclusive && builder.validate; // non-validating groups cannot be exclusive: https://github.com/remkop/picocli/issues/810
                 multiplicity     = builder.multiplicity;
+                if (multiplicity.max() <= 0) { throw new InitializationException("ArgGroup must have multiplicity that allows at least one occurrence, but had multiplicity=" + multiplicity); }
+
                 validate         = builder.validate;
                 order            = builder.order;
                 typeInfo         = builder.typeInfo;

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -500,7 +500,7 @@ static void genOptions(PrintWriter pw, CommandSpec spec) {
         IParameterRenderer parameterRenderer = spec.commandLine().getHelp().createDefaultParameterRenderer();
 
         List<ArgGroupSpec> groups = optionListGroups(spec);
-        for (ArgGroupSpec group : groups) { options.removeAll(group.options()); }
+        for (ArgGroupSpec group : groups) { options.removeAll(group.allOptionsNested()); }
 
         if (options.isEmpty() && !spec.usageMessage().showEndOfOptionsDelimiterInUsageHelp()) {
             pw.printf("// tag::picocli-generated-man-section-options[]%n");
@@ -534,12 +534,12 @@ static void genOptions(PrintWriter pw, CommandSpec spec) {
             String heading = makeHeading(group.heading(), "Options Group");
             pw.printf("== %s%n", COLOR_SCHEME.text(heading));
 
-            for (PositionalParamSpec positional : group.positionalParameters()) {
+            for (PositionalParamSpec positional : group.allPositionalParametersNested()) {
                 if (!positional.hidden()) {
                     writePositional(pw, positional, parameterRenderer, paramLabelRenderer);
                 }
             }
-            List<OptionSpec> groupOptions = new ArrayList<OptionSpec>(group.options());
+            List<OptionSpec> groupOptions = new ArrayList<OptionSpec>(group.allOptionsNested());
             if (optionSort != null) {
                 Collections.sort(groupOptions, optionSort);
             }

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -314,7 +314,7 @@ private static class CommandDescriptor {
             "# =======================\n" +
             "#\n" +
             "# Bash completion support for the `%1$s` command,\n" +
-            "# generated by [picocli](http://picocli.info/) version %2$s.\n" +
+            "# generated by [picocli](https://picocli.info/) version %2$s.\n" +
             "#\n" +
             "# Installation\n" +
             "# ------------\n" +

File: picocli-examples/src/main/java/picocli/examples/typeconverter/InetSocketAddressConverterDemo.java
Patch:
@@ -2,7 +2,7 @@
  * Picocli: Custom converter demo
  * Explanation: <a href="https://picocli.info/#_handling_invalid_input">Picocli user manual</a>
  * Discussion: <a href="https://github.com/remkop/picocli/issues/972">GitHub issue</a>
- * Origin of source code: <a href="https://github.com/remkop/picocli/tree/master/picocli-examples/src/main/java/picocli/examples/typeconverter">GitHub</a>
+ * Origin of source code: <a href="https://github.com/remkop/picocli/tree/main/picocli-examples/src/main/java/picocli/examples/typeconverter">GitHub</a>
  * @author Remko Popma
  */
 package picocli.examples.typeconverter;

File: src/test/java/picocli/AtFileTest.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.Set;
 
 import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.*;
 import static picocli.CommandLine.Model.UsageMessageSpec.SECTION_KEY_AT_FILE_PARAMETER;
 import static picocli.CommandLine.Model.UsageMessageSpec.SECTION_KEY_COMMAND_LIST_HEADING;

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package picocli;
 
+import org.hamcrest.MatcherAssert;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.contrib.java.lang.system.Assertion;
@@ -55,6 +56,7 @@
 import static java.lang.String.format;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.*;
 
 /**
@@ -1286,7 +1288,7 @@ class App {
             @Option(names = "-B") Boolean object;
         }
         String actual = AutoComplete.bash("booltest", new CommandLine(new App()));
-        assertThat(actual, containsString("local flag_opts=\"-b -B\""));
+        MatcherAssert.assertThat(actual, containsString("local flag_opts=\"-b -B\""));
     }
 
     @Test

File: src/test/java/picocli/ExecuteTest.java
Patch:
@@ -50,6 +50,7 @@
 import static java.lang.String.format;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.startsWith;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.*;
 import static picocli.CommandLine.*;
 import static picocli.CommandLine.Model.UsageMessageSpec.keyValuesMap;

File: src/test/java/picocli/GenericTest.java
Patch:
@@ -80,6 +80,7 @@ class NoConverterApp {
         }
         @SuppressWarnings("rawtypes")
         class GenericConverter implements ITypeConverter<GenericValue> {
+            @SuppressWarnings("unchecked")
             public GenericValue convert(String value) throws Exception {
                 return new GenericValue("abc");
             }

File: src/test/java/picocli/InteractiveArgTest.java
Patch:
@@ -20,6 +20,7 @@
 import static java.lang.String.format;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.not;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.*;
 
 public class InteractiveArgTest {

File: src/test/java/picocli/TestUtil.java
Patch:
@@ -24,6 +24,7 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -160,9 +161,7 @@ private static String stripAnsiTraceOnce(String original, String prefix, String
     }
 
     public static <T> Set<T> setOf(T... elements) {
-        Set<T> result = new HashSet<T>();
-        for (T t : elements) { result.add(t); }
-        return result;
+        return new HashSet<T>(Arrays.asList(elements));
     }
 
     public static <K, V> Map<K, V> mapOf(K k1, V v1) {

File: src/test/java/picocli/ModelCommandSpecTest.java
Patch:
@@ -385,13 +385,13 @@ class Sample {
 
         List<CommandLine> parsed2 = new CommandLine(new Sample()).parse("--foo");// specified without value
         OptionSpec option2 = parsed2.get(0).getCommandSpec().optionsMap().get("--foo");
-        assertEquals("optional option is fallback when specified without args", new Integer(123), option2.getValue());
+        assertEquals("optional option is fallback when specified without args", Integer.valueOf(123), option2.getValue());
         assertEquals("optional option string fallback value when specified without args", "123", option2.stringValues().get(0));
         assertEquals("optional option typed value when specified without args", 123, option2.typedValues().get(0));
 
         List<CommandLine> parsed3 = new CommandLine(new Sample()).parse("--foo", "999");// specified with value
         OptionSpec option3 = parsed3.get(0).getCommandSpec().optionsMap().get("--foo");
-        assertEquals("optional option is empty string when specified with args", new Integer(999), option3.getValue());
+        assertEquals("optional option is empty string when specified with args", Integer.valueOf(999), option3.getValue());
         assertEquals("optional option string value when specified with args", "999", option3.stringValues().get(0));
         assertEquals("optional option typed value when specified with args", 999, option3.typedValues().get(0));
     }
@@ -429,7 +429,7 @@ class Sample {
         Sample sample = new Sample();
         List<CommandLine> parsed3 = new CommandLine(sample).parse("--foo", "-x");// specified without value
         OptionSpec option3 = parsed3.get(0).getCommandSpec().optionsMap().get("--foo");
-        assertEquals("optional option is fallback typed value when specified without args", new Long(-1L), option3.getValue());
+        assertEquals("optional option is fallback typed value when specified without args", Long.valueOf(-1L), option3.getValue());
         assertEquals("optional option fallback string value when specified without args", "-1", option3.stringValues().get(0));
         assertEquals("optional option fallback typed value when specified without args", -1L, option3.typedValues().get(0));
         assertEquals(Long.valueOf(-1L), sample.foo);

File: src/test/java/picocli/ModelFieldBindingTest.java
Patch:
@@ -40,7 +40,7 @@ public void testFieldBindingGetterGivesValue() throws Exception {
         f.setAccessible(true);
 
         FieldBinding binding = new FieldBinding(new ModelMethodBindingBean(), f);
-        assertEquals("initial value", new Integer(7), binding.get());
+        assertEquals("initial value", Integer.valueOf(7), binding.get());
     }
 
     @Test
@@ -53,7 +53,7 @@ public void testFieldBindingSetterModifiesValue() throws Exception {
 
         binding.set(987);
         assertEquals(987, value.publicGetX());
-        assertEquals(new Integer(987), binding.get());
+        assertEquals(Integer.valueOf(987), binding.get());
     }
 
     @Test

File: src/test/java/picocli/ModelMethodBindingTest.java
Patch:
@@ -78,7 +78,7 @@ public void testGetReturnsLastSetValue_ForSetterMethod() throws Exception {
 
         binding.set(41);
         assertEquals(41, bean.publicGetX());
-        assertEquals(new Integer(41), binding.get());
+        assertEquals(Integer.valueOf(41), binding.get());
     }
 
     @Test
@@ -103,7 +103,7 @@ public void testSetInvokesMethod_ForSetterMethod() throws Exception {
 
         binding.set(987);
         assertEquals(987, value.publicGetX());
-        assertEquals(new Integer(987), binding.get());
+        assertEquals(Integer.valueOf(987), binding.get());
     }
 
     @Test

File: src/test/java/picocli/ModelCommandSpecTest.java
Patch:
@@ -385,13 +385,13 @@ class Sample {
 
         List<CommandLine> parsed2 = new CommandLine(new Sample()).parse("--foo");// specified without value
         OptionSpec option2 = parsed2.get(0).getCommandSpec().optionsMap().get("--foo");
-        assertEquals("optional option is fallback when specified without args", 123, option2.getValue());
+        assertEquals("optional option is fallback when specified without args", new Integer(123), option2.getValue());
         assertEquals("optional option string fallback value when specified without args", "123", option2.stringValues().get(0));
         assertEquals("optional option typed value when specified without args", 123, option2.typedValues().get(0));
 
         List<CommandLine> parsed3 = new CommandLine(new Sample()).parse("--foo", "999");// specified with value
         OptionSpec option3 = parsed3.get(0).getCommandSpec().optionsMap().get("--foo");
-        assertEquals("optional option is empty string when specified with args", 999, option3.getValue());
+        assertEquals("optional option is empty string when specified with args", new Integer(999), option3.getValue());
         assertEquals("optional option string value when specified with args", "999", option3.stringValues().get(0));
         assertEquals("optional option typed value when specified with args", 999, option3.typedValues().get(0));
     }
@@ -429,7 +429,7 @@ class Sample {
         Sample sample = new Sample();
         List<CommandLine> parsed3 = new CommandLine(sample).parse("--foo", "-x");// specified without value
         OptionSpec option3 = parsed3.get(0).getCommandSpec().optionsMap().get("--foo");
-        assertEquals("optional option is fallback typed value when specified without args", -1L, option3.getValue());
+        assertEquals("optional option is fallback typed value when specified without args", new Long(-1L), option3.getValue());
         assertEquals("optional option fallback string value when specified without args", "-1", option3.stringValues().get(0));
         assertEquals("optional option fallback typed value when specified without args", -1L, option3.typedValues().get(0));
         assertEquals(Long.valueOf(-1L), sample.foo);

File: src/test/java/picocli/ModelFieldBindingTest.java
Patch:
@@ -40,7 +40,7 @@ public void testFieldBindingGetterGivesValue() throws Exception {
         f.setAccessible(true);
 
         FieldBinding binding = new FieldBinding(new ModelMethodBindingBean(), f);
-        assertEquals("initial value", 7, binding.get());
+        assertEquals("initial value", new Integer(7), binding.get());
     }
 
     @Test
@@ -53,7 +53,7 @@ public void testFieldBindingSetterModifiesValue() throws Exception {
 
         binding.set(987);
         assertEquals(987, value.publicGetX());
-        assertEquals(987, binding.get());
+        assertEquals(new Integer(987), binding.get());
     }
 
     @Test

File: src/test/java/picocli/ModelMethodBindingTest.java
Patch:
@@ -78,7 +78,7 @@ public void testGetReturnsLastSetValue_ForSetterMethod() throws Exception {
 
         binding.set(41);
         assertEquals(41, bean.publicGetX());
-        assertEquals(41, binding.get());
+        assertEquals(new Integer(41), binding.get());
     }
 
     @Test
@@ -103,7 +103,7 @@ public void testSetInvokesMethod_ForSetterMethod() throws Exception {
 
         binding.set(987);
         assertEquals(987, value.publicGetX());
-        assertEquals(987, binding.get());
+        assertEquals(new Integer(987), binding.get());
     }
 
     @Test

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -18183,17 +18183,17 @@ private Tracer() {}
         public boolean isOff()  { return level== TraceLevel.OFF; }
         /** Prints the specified message if the current trace level is WARN or higher.
          * @param msg the message to print; may use {@link String#format(String, Object...)} syntax
-         * @param params – Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero.
+         * @param params Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero.
          * @see Formatter */
         public void warn (String msg, Object... params) { TraceLevel.WARN.print(this, msg, params); }
         /** Prints the specified message if the current trace level is INFO or higher.
          * @param msg the message to print; may use {@link String#format(String, Object...)} syntax
-         * @param params – Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero.
+         * @param params Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero.
          * @see Formatter */
         public void info (String msg, Object... params) { TraceLevel.INFO.print(this, msg, params); }
         /** Prints the specified message if the current trace level is DEBUG or higher.
          * @param msg the message to print; may use {@link String#format(String, Object...)} syntax
-         * @param params – Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero.
+         * @param params Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero.
          * @see Formatter */
         public void debug(String msg, Object... params) { TraceLevel.DEBUG.print(this, msg, params); }
         public String toString() { return "Tracer[" + level + "]"; }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5218,6 +5218,7 @@ public interface IParameterPreprocessor {
          *             Implementations may modify this map to communicate back to the picocli parser.
          *             Supported values:
          *             <table>
+         *               <caption>Supported values in the info Map</caption>
          *               <tr>
          *                 <th>key</th><th>valid values</th><th>type</th>
          *               </tr>
@@ -5246,7 +5247,7 @@ public interface IParameterPreprocessor {
          *                 <td>java.lang.Boolean</td>
          *               </tr>
          *             </table>
-         * @returns true if the preprocessor consumed the parameter
+         * @return true if the preprocessor consumed the parameter
          *          and picocli should skip further processing of the stack for this option or positional parameter;
          *          false if picocli should continue processing the stack for this option or positional parameter
          * @throws ParameterException if the user input is invalid

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -17497,7 +17497,7 @@ public Builder(ColorScheme existing) {
                 }
                 /** Returns the {@code Ansi} setting of this color scheme builder. */
                 public Ansi ansi() { return ansi; }
-                /** Returns the {@code Ansi} setting of this color scheme builder. */
+                /** Set the {@code Ansi} setting of this color scheme builder. */
                 public ColorScheme.Builder ansi(Ansi ansi) { this.ansi = Assert.notNull(ansi, "ansi"); return this; }
                 /** Returns the registered styles for commands in this color scheme builder. */
                 public List<IStyle> commandStyles()     { return commandStyles; }
@@ -17797,7 +17797,7 @@ public static IStyle bg(String str) {
                 }
                 /** Parses the specified comma-separated sequence of style descriptors and returns the associated
                  *  styles. For each markup, strings starting with {@code "bg("} are delegated to
-                 *  {@link #bg(String)}, others are delegated to {@link #bg(String)}.
+                 *  {@link #bg(String)}, others are delegated to {@link #fg(String)}.
                  * @param commaSeparatedCodes one or more descriptors, e.g. {@code "bg(blue),underline,red"}
                  * @return an array with all styles for the specified descriptors
                  */

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15009,7 +15009,7 @@ static class AutoHelpMixin {
      * and a {@code COMMAND} positional parameter with {@code descriptionKey = "helpCommand.command"}.
      * @since 3.0
      */
-    @Command(name = "help", header = "Displays help information about the specified command",
+    @Command(name = "help", header = "Display help information about the specified command.",
             synopsisHeading = "%nUsage: ", helpCommand = true,
             description = {"%nWhen no COMMAND is given, the usage help for the main command is displayed.",
                     "If a COMMAND is specified, the help for that command is shown.%n"})

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -1614,7 +1614,7 @@ public void run() { }
                 "      --apples=<apples>%n" +
                 "      --bbb=<b>%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         assertEquals(expectedUsage, cmd.getUsageMessage(CommandLine.Help.Ansi.OFF));
 
         StringWriter sw = new StringWriter();

File: src/test/java/picocli/Demo.java
Patch:
@@ -486,7 +486,7 @@ public void testUsageMainCommand()  {
             "Commands:%n" +
             "%n" +
             "The most commonly used git commands are:%n" +
-            "  help      Displays help information about the specified command%n" +
+            "  help      Display help information about the specified command.%n" +
             "  status    Show the working tree status.%n" +
             "  commit    Record changes to the repository.%n" +
             "  add       Add file contents to the index.%n" +
@@ -510,7 +510,7 @@ public void testUsageMainCommand()  {
             "Commands:%n" +
             "%n" +
             "The most commonly used git commands are:%n" +
-            "  \u001B[1mhelp\u001B[21m\u001B[0m      Displays help information about the specified command%n" +
+            "  \u001B[1mhelp\u001B[21m\u001B[0m      Display help information about the specified command.%n" +
             "  \u001B[1mstatus\u001B[21m\u001B[0m    Show the working tree status.%n" +
             "  \u001B[1mcommit\u001B[21m\u001B[0m    Record changes to the repository.%n" +
             "  \u001B[1madd\u001B[21m\u001B[0m       Add file contents to the index.%n" +

File: src/test/java/picocli/HelpTest.java
Patch:
@@ -3295,7 +3295,7 @@ public void testAutoHelpMixinUsageHelpSubcommandOnAppWithoutSubcommands() {
                 "  -h, --help      Show this help message and exit.%n" +
                 "  -V, --version   Print version information and exit.%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         assertEquals(expected, baos.toString());
     }
 
@@ -3315,7 +3315,7 @@ class App implements Runnable{ public void run(){}}
                 "  -h, --help      Show this help message and exit.%n" +
                 "  -V, --version   Print version information and exit.%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         assertEquals(expected, sw.toString());
     }
 
@@ -5118,7 +5118,7 @@ class MyTool {
         String expected = String.format("" +
                 "Usage: <main class> [COMMAND]%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         String actual = new CommandLine(new MyTool()).getUsageMessage();
         assertEquals(expected, actual);
     }

File: src/test/java/picocli/InterpolatedModelTest.java
Patch:
@@ -72,7 +72,7 @@ class App {
                 "OPTION HEADING%n" +
                 "  -x+ <x>   option description%n" +
                 "SUBCOMMANDS HEADING%n" +
-                "  help  Displays help information about the specified command%n" +
+                "  help  Display help information about the specified command.%n" +
                 "FOOTER HEADING%n" +
                 "FOOTER 1%n" +
                 "and FOOTER 2%n");
@@ -138,7 +138,7 @@ class App {
                 "OPTION HEADING%n" +
                 "  -x+ <x>   option description%n" +
                 "SUBCOMMANDS HEADING%n" +
-                "  help  Displays help information about the specified command%n" +
+                "  help  Display help information about the specified command.%n" +
                 "FOOTER HEADING%n" +
                 "FOOTER 1%n" +
                 "and FOOTER 2%n");

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -1614,7 +1614,7 @@ public void run() { }
                 "      --apples=<apples>%n" +
                 "      --bbb=<b>%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         assertEquals(expectedUsage, cmd.getUsageMessage(CommandLine.Help.Ansi.OFF));
 
         StringWriter sw = new StringWriter();

File: src/test/java/picocli/Demo.java
Patch:
@@ -486,7 +486,7 @@ public void testUsageMainCommand()  {
             "Commands:%n" +
             "%n" +
             "The most commonly used git commands are:%n" +
-            "  help      Displays help information about the specified command%n" +
+            "  help      Display help information about the specified command.%n" +
             "  status    Show the working tree status.%n" +
             "  commit    Record changes to the repository.%n" +
             "  add       Add file contents to the index.%n" +
@@ -510,7 +510,7 @@ public void testUsageMainCommand()  {
             "Commands:%n" +
             "%n" +
             "The most commonly used git commands are:%n" +
-            "  \u001B[1mhelp\u001B[21m\u001B[0m      Displays help information about the specified command%n" +
+            "  \u001B[1mhelp\u001B[21m\u001B[0m      Display help information about the specified command.%n" +
             "  \u001B[1mstatus\u001B[21m\u001B[0m    Show the working tree status.%n" +
             "  \u001B[1mcommit\u001B[21m\u001B[0m    Record changes to the repository.%n" +
             "  \u001B[1madd\u001B[21m\u001B[0m       Add file contents to the index.%n" +

File: src/test/java/picocli/HelpTest.java
Patch:
@@ -3295,7 +3295,7 @@ public void testAutoHelpMixinUsageHelpSubcommandOnAppWithoutSubcommands() {
                 "  -h, --help      Show this help message and exit.%n" +
                 "  -V, --version   Print version information and exit.%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         assertEquals(expected, baos.toString());
     }
 
@@ -3315,7 +3315,7 @@ class App implements Runnable{ public void run(){}}
                 "  -h, --help      Show this help message and exit.%n" +
                 "  -V, --version   Print version information and exit.%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         assertEquals(expected, sw.toString());
     }
 
@@ -5118,7 +5118,7 @@ class MyTool {
         String expected = String.format("" +
                 "Usage: <main class> [COMMAND]%n" +
                 "Commands:%n" +
-                "  help  Displays help information about the specified command%n");
+                "  help  Display help information about the specified command.%n");
         String actual = new CommandLine(new MyTool()).getUsageMessage();
         assertEquals(expected, actual);
     }

File: src/test/java/picocli/InterpolatedModelTest.java
Patch:
@@ -72,7 +72,7 @@ class App {
                 "OPTION HEADING%n" +
                 "  -x+ <x>   option description%n" +
                 "SUBCOMMANDS HEADING%n" +
-                "  help  Displays help information about the specified command%n" +
+                "  help  Display help information about the specified command.%n" +
                 "FOOTER HEADING%n" +
                 "FOOTER 1%n" +
                 "and FOOTER 2%n");
@@ -138,7 +138,7 @@ class App {
                 "OPTION HEADING%n" +
                 "  -x+ <x>   option description%n" +
                 "SUBCOMMANDS HEADING%n" +
-                "  help  Displays help information about the specified command%n" +
+                "  help  Display help information about the specified command.%n" +
                 "FOOTER HEADING%n" +
                 "FOOTER 1%n" +
                 "and FOOTER 2%n");

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15009,7 +15009,7 @@ static class AutoHelpMixin {
      * and a {@code COMMAND} positional parameter with {@code descriptionKey = "helpCommand.command"}.
      * @since 3.0
      */
-    @Command(name = "help", header = "Displays help information about the specified command",
+    @Command(name = "help", header = "Display help information about the specified command.",
             synopsisHeading = "%nUsage: ", helpCommand = true,
             description = {"%nWhen no COMMAND is given, the usage help for the main command is displayed.",
                     "If a COMMAND is specified, the help for that command is shown.%n"})

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15371,8 +15371,9 @@ public String synopsis(int synopsisHeadingLength) {
             Comparator<OptionSpec> sortStrategy = commandSpec.usageMessage().sortSynopsis()
                 ? createShortOptionArityAndNameComparator() // alphabetic sort
                 : createOrderComparatorIfNecessary(commandSpec.options()); // explicit sort
+            boolean clusterBooleanOptions = commandSpec.parser().posixClusteredShortOptionsAllowed();
             return commandSpec.usageMessage().abbreviateSynopsis() ? abbreviatedSynopsis()
-                    : detailedSynopsis(synopsisHeadingLength, sortStrategy, true);
+                    : detailedSynopsis(synopsisHeadingLength, sortStrategy, clusterBooleanOptions);
         }
 
         /** Generates a generic synopsis like {@code <command name> [OPTIONS] [PARAM1 [PARAM2]...]}, omitting parts

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13329,7 +13329,7 @@ private boolean applyDefault(IDefaultValueProvider defaultValueProvider, ArgSpec
             // Default value provider return value is only used if provider exists and if value
             // is not null otherwise the original default or initial value are used
             String fromProvider = defaultValueProvider == null ? null : defaultValueProvider.defaultValue(arg);
-            String defaultValue = fromProvider == null ? arg.defaultValue() : fromProvider;
+            String defaultValue = fromProvider == null ? arg.defaultValue() : arg.interpolate(fromProvider);
             String provider = defaultValueProvider == null ? "" : (" from " + defaultValueProvider.toString());
 
             if (defaultValue != null && !ArgSpec.NULL_VALUE.equals(defaultValue)) {

File: src/test/java/picocli/ModelTypedMemberTest.java
Patch:
@@ -1,5 +1,6 @@
 package picocli;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.contrib.java.lang.system.ProvideSystemProperty;
@@ -21,6 +22,7 @@ public class ModelTypedMemberTest {
     @Rule
     public final ProvideSystemProperty ansiOFF = new ProvideSystemProperty("picocli.ansi", "false");
 
+    @Ignore("No longer expected to fail after [#1396][#1401]")
     @Test
     public void testInferTypes() {
         class App {

File: src/test/java/picocli/GenericTest.java
Patch:
@@ -83,7 +83,7 @@ class GenericConverter implements ITypeConverter<GenericValue> {
 
             @Override
             public GenericValue convert(String value) throws Exception {
-                return new GenericValue<>("abc");
+                return new GenericValue("abc");
             }
         }
         NoConverterApp app = new NoConverterApp();

File: src/test/java/picocli/Issue1528.java
Patch:
@@ -12,15 +12,13 @@ public class Issue1528 {
 
     @Command(name = "main", subcommands = SubCommand.class)
     static class MainCommand implements Callable<Integer> {
-        @Override
         public Integer call() throws Exception {
             return null;
         }
     }
 
     @Command(name = "sub")
     static class SubCommand implements Callable<Integer> {
-        @Override
         public Integer call() throws Exception {
             return null;
         }

File: src/test/java/picocli/Issue1565HideParamOnUnknownOption.java
Patch:
@@ -34,9 +34,9 @@ static class Issue1565 {
      * when an unknown option was specified.
      * <p>
      * Example: when the end user entered `mycommand --passworf=TOPSECRET`, then the
-     * default handler would show a message saying "Unknown option: '----passworf=TOPSECRET'".
+     * default handler would show a message saying "Unknown option: '--passworf=TOPSECRET'".
      * </p><p>
-     * Instead, this handler shows the message "Unknown option: '----passworf'".
+     * Instead, this handler shows the message "Unknown option: '--passworf'".
      * </p><p>
      * Other than that, this handler behaves identical to the picocli built-in default
      * parameter exception handler, except that the built-in exception handler also

File: picocli-annotation-processing-tests/src/test/java/picocli/annotation/processing/tests/Issue1440Test.java
Patch:
@@ -11,7 +11,7 @@
 import static com.google.testing.compile.Compiler.javac;
 
 public class Issue1440Test {
-    @Ignore("https://github.com/remkop/picocli/issues/1440")
+    //@Ignore("https://github.com/remkop/picocli/issues/1440")
     @Test
     public void testIssue1440() {
         Processor processor = new AnnotatedCommandSourceGeneratorProcessor();

File: picocli-annotation-processing-tests/src/test/resources/picocli/issue1440inheritedoptions/Command2.java
Patch:
@@ -5,7 +5,7 @@
 import picocli.CommandLine.Model.CommandSpec;
 import picocli.CommandLine.Spec;
 
-@Command(name = "Command1", subcommands =  CommandLine.HelpCommand.class,
+@Command(name = "Command2", subcommands =  CommandLine.HelpCommand.class,
     description = "Command 1 description")
 class Command2 {
     @Spec

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -18415,7 +18415,7 @@ public boolean equals(Object o) {
                     return false;
                 }
                 MatchResult<?> p = (MatchResult<?>) o;
-                return fullName.equals(p.fullName) && Objects.equals(value, p.value);
+                return fullName.equals(p.fullName) && (hasValue() ? value.equals(p.value) : value == p.value);
             }
 
             @Override

File: picocli-annotation-processing-tests/src/test/java/picocli/Issue1420Test.java
Patch:
@@ -1,5 +1,6 @@
 package picocli;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import picocli.CommandLine.ArgGroup;
 import picocli.CommandLine.Command;
@@ -43,7 +44,7 @@ private static class ExclusiveOptions {
 }
 
 
-
+@Ignore
 /**
  * JUnit testing class for issue 1420
  */

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10230,7 +10230,7 @@ int localPositionalParamCount() {
                 int result = 0;
                 for (ArgSpec arg : args) {
                     if (arg.isPositional()) {
-                        result += ((PositionalParamSpec) arg).capacity().min();
+                        result += ((PositionalParamSpec) arg).capacity().max();
                     }
                 }
                 return result;

File: src/test/java/picocli/HelpSubCommandTest.java
Patch:
@@ -346,13 +346,13 @@ class App implements Runnable{ public void run(){}}
         String expected = String.format("" +
                 "Displays help information about the specified command%n" +
                 "%n" +
-                "Usage: <main class> help [-h] [COMMAND...]%n" +
+                "Usage: <main class> help [-h] [COMMAND]%n" +
                 "%n" +
                 "When no COMMAND is given, the usage help for the main command is displayed.%n" +
                 "If a COMMAND is specified, the help for that command is shown.%n" +
                 "%n" +
-                "      [COMMAND...]   The COMMAND to display the usage help message for.%n" +
-                "  -h, --help         Show usage help for the help command and exit.%n");
+                "      [COMMAND]   The COMMAND to display the usage help message for.%n" +
+                "  -h, --help      Show usage help for the help command and exit.%n");
         assertEquals(expected, sw.toString());
 
         sw = new StringWriter();

File: picocli-annotation-processing-tests/src/test/java/picocli/annotation/processing/tests/YamlAssert.java
Patch:
@@ -11,7 +11,9 @@
 
 import static com.google.testing.compile.Compiler.javac;
 import static org.hamcrest.CoreMatchers.*;
-import static org.junit.Assert.*;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public final class YamlAssert {
     private YamlAssert() {

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -557,7 +557,7 @@ private TypedMember extractTypedMember(Element element, String annotation) {
             return new TypedMember((ExecutableElement) element, AbstractCommandSpecProcessor.this);
         }
         error(element, "Can only process %s annotations on fields, " +
-                "methods and method parameters, not on %s", annotation, element.getKind());
+                "methods and @Command-annotated method parameters, not on %s", annotation, element.getKind());
         return null;
     }
 

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -296,7 +296,7 @@ private static class CommandDescriptor {
         final String parentWithoutTopLevelCommand;
         final String commandName;
         final CommandLine commandLine;
-        
+
         CommandDescriptor(String functionName, String parentWithoutTopLevelCommand, String commandName, CommandLine commandLine) {
             this.functionName = functionName;
             this.parentWithoutTopLevelCommand = parentWithoutTopLevelCommand;
@@ -719,6 +719,7 @@ private static String generatePositionalParamsCases(List<PositionalParamSpec> po
                 buff.append(format("%s      positionals=$( compgen -W \"$%s_pos_param_args\" -- \"%s\" )\n", indent, paramName, currWord));
             } else if (type.equals(File.class) || "java.nio.file.Path".equals(type.getName())) {
                 buff.append(format("%s    %s (( currIndex >= %d && currIndex <= %d )); then\n", indent, ifOrElif, min, max));
+                buff.append(format("%s      local IFS=$'\\n'\n", indent));
                 buff.append(format("%s      compopt -o filenames\n", indent));
                 buff.append(format("%s      positionals=$( compgen -f -- \"%s\" ) # files\n", indent, currWord));
             } else if (type.equals(InetAddress.class)) {
@@ -763,6 +764,7 @@ private static String generateOptionsCases(List<OptionSpec> argOptionFields, Str
                 buff.append(format("%s      ;;\n", indent));
             } else if (type.equals(File.class) || "java.nio.file.Path".equals(type.getName())) {
                 buff.append(format("%s    %s)\n", indent, concat("|", option.names()))); // "    -f|--file)\n"
+                buff.append(format("%s      local IFS=$'\\n'\n", indent));
                 buff.append(format("%s      compopt -o filenames\n", indent));
                 buff.append(format("%s      COMPREPLY=( $( compgen -f -- \"%s\" ) ) # files\n", indent, currWord));
                 buff.append(format("%s      return $?\n", indent));

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -779,6 +779,7 @@ private String expectedCompletionScriptForAutoCompleteApp() {
                 "      return\n" +
                 "      ;;\n" +
                 "    -o|--completionScript)\n" +
+                "      local IFS=$'\\n'\n" +
                 "      compopt -o filenames\n" +
                 "      COMPREPLY=( $( compgen -f -- \"${curr_word}\" ) ) # files\n" +
                 "      return $?\n" +

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -903,7 +904,7 @@ private static boolean isPicocliModelObject(Object obj) {
     }
 
     private static void filterAndTrimMatchingPrefix(String prefix, List<CharSequence> candidates) {
-        List<CharSequence> replace = new ArrayList<CharSequence>();
+        Set<CharSequence> replace = new HashSet<CharSequence>();
         for (CharSequence seq : candidates) {
             if (seq.toString().startsWith(prefix)) {
                 replace.add(seq.subSequence(prefix.length(), seq.length()));

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -556,7 +556,7 @@ private TypedMember extractTypedMember(Element element, String annotation) {
         } else if (element.getKind() == ElementKind.METHOD) {
             return new TypedMember((ExecutableElement) element, AbstractCommandSpecProcessor.this);
         }
-        error(element, "Cannot only process %s annotations on fields, " +
+        error(element, "Can only process %s annotations on fields, " +
                 "methods and method parameters, not on %s", annotation, element.getKind());
         return null;
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10118,10 +10118,11 @@ public static class ArgGroupSpec implements IOrdered {
                 if (exclusive) {
                     String modifiedArgs = ""; String sep = "";
                     for (ArgSpec arg : args) {
+                        boolean reserved = arg.required();
                         if (!arg.required()) {
                             modifiedArgs += sep + (arg.isOption() ? ((OptionSpec) arg).longestName() : (arg.paramLabel() + "[" + ((PositionalParamSpec) arg).index() + "]"));
                             sep = ",";
-                            arg.required = true;
+                            arg.required = reserved;
                         }
                     }
                     if (modifiedArgs.length() > 0) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -8787,7 +8787,7 @@ private String[] expandVariables(String[] desc) {
             /** Returns the root option or positional parameter (on the parent command), if this option or positional parameter was inherited;
              * or {@code null} if it was not.
              * @see Option#scope()
-             * @since 4.6.3-SNAPSHOT */
+             * @since 4.6.0 */
             public ArgSpec root() { return root; }
 
             /** Returns the type to convert the option or positional parameter to before {@linkplain #setValue(Object) setting} the value.
@@ -9425,7 +9425,7 @@ private static String inferLabel(String label, String fieldName, ITypeInfo typeI
                 /** Returns the root option or positional parameter (on the parent command), if this option or positional parameter was inherited;
                  * or {@code null} if it was not.
                  * @see Option#scope()
-                 * @since 4.6.3-SNAPSHOT */
+                 * @since 4.6.0 */
                 public ArgSpec root() { return root; }
 
                 /** Returns the type to convert the option or positional parameter to before {@linkplain #setValue(Object) setting} the value.
@@ -9568,7 +9568,7 @@ private static String inferLabel(String label, String fieldName, ITypeInfo typeI
 
                 /**
                  * Sets the root object for this inherited option, and returns this builder.
-                 * @since 4.6.3-SNAPSHOT */
+                 * @since 4.6.0 */
                 public T root(ArgSpec root)                  { this.root = root ; return self(); }
 
                 /** Sets the type to convert the option or positional parameter to before {@linkplain #setValue(Object) setting} the value, and returns this builder.

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/JniConfigGenerator.java
Patch:
@@ -20,7 +20,7 @@ public class JniConfigGenerator {
                     "accessed reflectively from native code.",
                     "The generated JSON file can be passed to the `-H:JNIConfigurationFiles=/path/to/jni-config.json` " +
                     "option of the `native-image` GraalVM utility.",
-                    "See https://github.com/oracle/graal/blob/master/substratevm/JNI.md"},
+                    "See https://www.graalvm.org/reference-manual/native-image/JNI/"},
             exitCodeListHeading = "%nExit Codes (if enabled with `--exit`)%n",
             exitCodeList = {
                     "0:Successful program execution.",

File: picocli-examples/src/main/java/picocli/examples/defaultprovider/TwoPass.java
Patch:
@@ -60,7 +60,7 @@ public void run() {
         }
     }
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws IOException {
         File path = createExampleProfileFile();
 
         args = ("--profile=" + path.getAbsolutePath() + " -b123 --long-option USER-SPECIFIED").split(" ");

File: picocli-examples/src/main/java/picocli/examples/atfile/AtFileGenerator.java
Patch:
@@ -119,7 +119,7 @@ private String quoteAndEscapeBackslashes(String original) {
         return result;
     }
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws IOException {
         if (args.length > 0) {
             System.exit(new CommandLine(new AtFileGenerator()).execute(args));
         } else {

File: src/test/java/picocli/ArityTest.java
Patch:
@@ -1662,7 +1662,7 @@ class App {
             new CommandLine(new App()).parseArgs("--implicit=false --explicit=false".split(" "));
             fail("--explicit option should not accept parameters");
         } catch (ParameterException ex) {
-            assertEquals("option '--explicit' (<explicit>) should be specified without 'false' parameter", ex.getMessage());
+            assertEquals("option '--explicit' should be specified without 'false' parameter", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -1916,7 +1916,7 @@ class App {
             CommandLine.populateCommand(new App(), "-v", "-v");
             fail("expected exception");
         } catch (OverwrittenOptionException ex) {
-            assertEquals("option '-v' (<bool>) should be specified only once", ex.getMessage());
+            assertEquals("option '-v' should be specified only once", ex.getMessage());
         }
     }
 
@@ -1936,7 +1936,7 @@ class App {
             CommandLine.populateCommand(new App(), "-v", "--verbose");
             fail("expected exception");
         } catch (OverwrittenOptionException ex) {
-            assertEquals("option '--verbose' (<bool>) should be specified only once", ex.getMessage());
+            assertEquals("option '--verbose' should be specified only once", ex.getMessage());
         }
     }
 

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -560,7 +560,8 @@ private static void generateFunctionCallsToArrContains(StringBuilder buff,
             int count = functionCalls.size();
             CommandSpec spec = descriptor.commandLine.getCommandSpec();
             String full = spec.qualifiedName(" ");
-            String withoutTopLevelCommand = full.substring(spec.root().name().length() + 1).replace(spec.name(), descriptor.commandName);
+            String withoutTopLevelCommand = full.substring(spec.root().name().length() + 1,
+                    full.length() - spec.name().length()) + descriptor.commandName;
 
             functionCalls.add(format("  if CompWordsContainsArray \"${cmds%2$d[@]}\"; then %1$s; return $?; fi\n", descriptor.functionName, count));
             buff.append(      format("  local cmds%2$d=(%1$s)\n", withoutTopLevelCommand, count));

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -6412,7 +6412,7 @@ public CommandSpec addSubcommand(String name, CommandSpec subcommand) {
              */
             public CommandSpec addSubcommand(String name, CommandLine subCommandLine) {
                 CommandSpec subSpec = subCommandLine.getCommandSpec();
-                String actualName = interpolator.interpolateCommandName(validateSubcommandName(name, subSpec));
+                String actualName = validateSubcommandName(interpolator.interpolateCommandName(name), subSpec);
                 Tracer t = new Tracer();
                 if (t.isDebug()) {t.debug("Adding subcommand '%s' to '%s'%n", actualName, this.qualifiedName());}
                 String previousName = commands.getCaseSensitiveKey(actualName);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -6412,7 +6412,7 @@ public CommandSpec addSubcommand(String name, CommandSpec subcommand) {
              */
             public CommandSpec addSubcommand(String name, CommandLine subCommandLine) {
                 CommandSpec subSpec = subCommandLine.getCommandSpec();
-                String actualName = validateSubcommandName(name, subSpec);
+                String actualName = interpolator.interpolateCommandName(validateSubcommandName(name, subSpec));
                 Tracer t = new Tracer();
                 if (t.isDebug()) {t.debug("Adding subcommand '%s' to '%s'%n", actualName, this.qualifiedName());}
                 String previousName = commands.getCaseSensitiveKey(actualName);
@@ -6422,7 +6422,7 @@ public CommandSpec addSubcommand(String name, CommandLine subCommandLine) {
                 subSpec.parent(this);
                 for (String alias : subSpec.aliases()) {
                     if (t.isDebug()) {t.debug("Adding alias '%s' for '%s'%n", (parent == null ? "" : parent.qualifiedName() + " ") + alias, this.qualifiedName());}
-                    previous = commands.put(alias, subCommandLine);
+                    previous = commands.put(interpolator.interpolate(alias), subCommandLine);
                     if (previous != null && previous != subCommandLine) { throw new DuplicateNameException("Alias '" + alias + "' for subcommand '" + actualName + "' is already used by another subcommand of '" + this.name() + "'"); }
                 }
                 subSpec.initCommandHierarchyWithResourceBundle(resourceBundleBaseName(), resourceBundle());

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -560,7 +560,7 @@ private static void generateFunctionCallsToArrContains(StringBuilder buff,
             int count = functionCalls.size();
             CommandSpec spec = descriptor.commandLine.getCommandSpec();
             String full = spec.qualifiedName(" ");
-            String withoutTopLevelCommand = full.substring(spec.root().name().length() + 1);
+            String withoutTopLevelCommand = full.substring(spec.root().name().length() + 1).replace(spec.name(), descriptor.commandName);
 
             functionCalls.add(format("  if CompWordsContainsArray \"${cmds%2$d[@]}\"; then %1$s; return $?; fi\n", descriptor.functionName, count));
             buff.append(      format("  local cmds%2$d=(%1$s)\n", withoutTopLevelCommand, count));

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13292,7 +13292,7 @@ private void processArguments(List<CommandLine> parsedCommands,
                         tracer.debug("Subcommand '%s' has been matched before. Making a copy...%n", subcommand.getCommandName());
                         subcommand = subcommand.copy();
                         subcommand.getCommandSpec().parent(commandSpec.parent()); // hook it up with its parent
-                        inheritedInitialized = new LinkedHashSet<>(inheritedInitialized);
+                        inheritedInitialized = new LinkedHashSet<ArgSpec>(inheritedInitialized);
                     }
                     processSubcommand(subcommand, getParent().interpreter.parseResultBuilder, parsedCommands, args, required, inheritedInitialized, originalArgs, nowProcessing, separator, arg);
                     continue;

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13287,12 +13287,14 @@ private void processArguments(List<CommandLine> parsedCommands,
                 if (commandSpec.parent() != null && commandSpec.parent().subcommandsRepeatable() && commandSpec.parent().subcommands().containsKey(arg)) {
                     tracer.debug("'%s' is a repeatable subcommand of %s%n", arg, commandSpec.parent().qualifiedName());// #454 repeatable subcommands
                     CommandLine subcommand = commandSpec.parent().subcommands().get(arg);
+                    Set<ArgSpec> inheritedInitialized = initialized;
                     if (subcommand.interpreter.parseResultBuilder != null) {
                         tracer.debug("Subcommand '%s' has been matched before. Making a copy...%n", subcommand.getCommandName());
                         subcommand = subcommand.copy();
                         subcommand.getCommandSpec().parent(commandSpec.parent()); // hook it up with its parent
+                        inheritedInitialized = new LinkedHashSet<>(inheritedInitialized);
                     }
-                    processSubcommand(subcommand, getParent().interpreter.parseResultBuilder, parsedCommands, args, required, initialized, originalArgs, nowProcessing, separator, arg);
+                    processSubcommand(subcommand, getParent().interpreter.parseResultBuilder, parsedCommands, args, required, inheritedInitialized, originalArgs, nowProcessing, separator, arg);
                     continue;
                 }
 

File: src/test/java/picocli/InheritedOptionTest.java
Patch:
@@ -558,7 +558,6 @@ class Example { }
         new CommandLine(new Example()); // succeeds without error
     }
 
-    @Ignore("Needs fix for #1319")
     @Test
     public void testIssue1319() {
         @Command(scope = CommandLine.ScopeType.INHERIT

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -6937,7 +6937,8 @@ public Set<String> names() {
             public List<ArgSpec> args() { return Collections.unmodifiableList(args); }
             Object[] commandMethodParamValues() {
                 Object[] values = new Object[methodParams.length];
-                int argIndex = mixins.containsKey(AutoHelpMixin.KEY) ? 2 : 0;
+                CommandSpec autoHelpMixin = mixins.get(AutoHelpMixin.KEY);
+                int argIndex = autoHelpMixin == null || autoHelpMixin.inherited() ? 0 : 2;
                 for (int i = 0; i < methodParams.length; i++) {
                     if (methodParams[i].isAnnotationPresent(Mixin.class)) {
                         String name = methodParams[i].getAnnotation(Mixin.class).name();
@@ -7156,6 +7157,7 @@ public CommandSpec negatableOptionTransformer(INegatableOptionTransformer newVal
             public CommandSpec mixinStandardHelpOptions(boolean newValue) {
                 if (newValue) {
                     CommandSpec mixin = CommandSpec.forAnnotatedObject(new AutoHelpMixin(), new DefaultFactory());
+                    mixin.inherited = this.inherited();
                     addMixin(AutoHelpMixin.KEY, mixin);
                 } else {
                     CommandSpec helpMixin = mixins.remove(AutoHelpMixin.KEY);

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/DefaultValueProviderMetaData.java
Patch:
@@ -32,7 +32,7 @@ public DefaultValueProviderMetaData(TypeMirror typeMirror) {
     /**
      * Sets the specified {@code CommandSpec}'s
      * {@linkplain CommandSpec#defaultValueProvider(CommandLine.IDefaultValueProvider) default value provider}
-     * to an {@code DefaultValueProviderMetaData} instance if the annotation attribute was present on the
+     * to a {@code DefaultValueProviderMetaData} instance if the annotation attribute was present on the
      * specified {@code Command} annotation.
      *
      * @param result the command spec to initialize

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/VersionProviderMetaData.java
Patch:
@@ -30,7 +30,7 @@ public VersionProviderMetaData(TypeMirror typeMirror) {
     /**
      * Sets the specified {@code CommandSpec}'s
      * {@linkplain CommandSpec#versionProvider(picocli.CommandLine.IVersionProvider)}  version provider}
-     * to an {@code VersionProviderMetaData} instance if the annotation attribute was present on the
+     * to a {@code VersionProviderMetaData} instance if the annotation attribute was present on the
      * specified {@code Command} annotation.
      *
      * @param result the command spec to initialize

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2100,7 +2100,7 @@ private static int handleUnhandled(Exception ex, CommandLine cmd, int defaultExi
     }
 
     /**
-     * Convert an {@code Throwable} to a {@code String} , with message and stack traces extracted and colored
+     * Convert a {@code Throwable} to a {@code String} , with message and stack traces extracted and colored
      * according to {@code ColorScheme}.
      * @param t the {@code Throwable} to be converted
      * @param existingColorScheme the {@code ColorScheme} to use
@@ -5644,7 +5644,7 @@ private static Range parameterCapacity(Range arity, Range index) {
             return Range.valueOf(arity.min * index.size() + ".." + arity.max * index.size());
         }
 
-        /** Leniently parses the specified String as an {@code Range} value and return the result. A range string can
+        /** Leniently parses the specified String as a {@code Range} value and return the result. A range string can
          * be a fixed integer value or a range of the form {@code MIN_VALUE + ".." + MAX_VALUE}. If the
          * {@code MIN_VALUE} string is not numeric, the minimum is zero. If the {@code MAX_VALUE} is not numeric, the
          * range is taken to be variable and the maximum is {@code Integer.MAX_VALUE}.

File: src/test/java/picocli/ParameterPreprocessorTest.java
Patch:
@@ -53,7 +53,7 @@ enum Editor { defaultEditor, eclipse, idea, netbeans }
         Editor editor = Editor.defaultEditor;
 
         static class MyPreprocessor implements CommandLine.IParameterPreprocessor {
-            public boolean preprocess(Stack<String> args, CommandSpec commandSpec, ArgSpec argSpec, Map<String, String> info) {
+            public boolean preprocess(Stack<String> args, CommandSpec commandSpec, ArgSpec argSpec, Map<String, Object> info) {
                 Edit edit = commandSpec.commandLine().getCommand();
                 if (edit.file != null) { // positional parameter has already been populated
                     return false; // any subsequent arg is not the positional parameter, so must be a param for --open
@@ -112,7 +112,7 @@ static class Blah {
     }
 
     static class MyLazyPreProcessor implements CommandLine.IParameterPreprocessor {
-        public boolean preprocess(Stack<String> args, CommandSpec commandSpec, ArgSpec argSpec, Map<String, String> info) {
+        public boolean preprocess(Stack<String> args, CommandSpec commandSpec, ArgSpec argSpec, Map<String, Object> info) {
             Blah blah = commandSpec.commandLine().getCommand();
             //noinspection unchecked
             blah.args = (Stack<String>) args.clone();
@@ -169,7 +169,7 @@ static class Group {
         }
 
         static class TestPreprocessor implements CommandLine.IParameterPreprocessor {
-            public boolean preprocess(Stack<String> args, CommandSpec commandSpec, ArgSpec argSpec, Map<String, String> info) {
+            public boolean preprocess(Stack<String> args, CommandSpec commandSpec, ArgSpec argSpec, Map<String, Object> info) {
                 argSpec.setValue(args.pop());
                 return true;
             }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13846,7 +13846,7 @@ private int addUserInputToList(ArgSpec argSpec, List<Object> result, int consume
             char[] input = readUserInput(argSpec);
             String inputString = new String(input);
             if (tracer.isInfo()) {
-                String value = argSpec.echo() ? input + " (interactive value)" : "*** (masked interactive value)";
+                String value = argSpec.echo() ? inputString + " (interactive value)" : "*** (masked interactive value)";
                 tracer.info("Adding %s to %s for %s on %s%n", value, argSpec.toString(), argDescription, argSpec.scopeString());
             }
             String maskedValue = getMaskedValue(argSpec, inputString);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4687,7 +4687,7 @@ enum Target {
 
         /** Returns transformer for command
          * @since 4.6 */
-        Class<? extends IModelTransformer> modelTransformer() default NoOpModelTransforemer.class;
+        Class<? extends IModelTransformer> modelTransformer() default NoOpModelTransformer.class;
     }
     /** A {@code Command} may define one or more {@code ArgGroups}: a group of options, positional parameters or a mixture of the two.
      * Groups can be used to:
@@ -4839,7 +4839,7 @@ public interface IModelTransformer {
         CommandSpec transform(CommandSpec commandSpec);
     }
 
-    private static class NoOpModelTransforemer implements IModelTransformer {
+    private static class NoOpModelTransformer implements IModelTransformer {
         public CommandSpec transform(CommandSpec commandSpec) { return commandSpec; }
     }
 
@@ -7013,7 +7013,7 @@ void initDefaultValueProvider(Class<? extends IDefaultValueProvider> value, IFac
             void initExitCodeOnExecutionException(int exitCode) { if (initializable(exitCodeOnExecutionException, exitCode, ExitCode.SOFTWARE)) { exitCodeOnExecutionException = exitCode; } }
             void updateName(String value)                   { if (isNonDefault(value, DEFAULT_COMMAND_NAME))                {name = value;} }
             void updateModelTransformer(Class<? extends IModelTransformer> value) {
-                if (isNonDefault(value, NoOpModelTransforemer.class)) { this.modelTransformer = DefaultFactory.create(defaultFactory(), value); }
+                if (isNonDefault(value, NoOpModelTransformer.class)) { this.modelTransformer = DefaultFactory.create(defaultFactory(), value); }
             }
             void updateHelpCommand(boolean value)           { if (isNonDefault(value, DEFAULT_IS_HELP_COMMAND))             {isHelpCommand = value;} }
             void updateSubcommandsRepeatable(boolean value) { if (isNonDefault(value, DEFAULT_SUBCOMMANDS_REPEATABLE))      {subcommandsRepeatable = value;} }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -6990,9 +6990,8 @@ public void updateCommandAttributes(Command cmd, IFactory factory) {
 
                 updateScopeType(cmd.scope());
 
-                updateModelTransformer(cmd.modelTransformer());
-
                 if (factory != null) {
+                    updateModelTransformer(cmd.modelTransformer());
                     updateVersionProvider(cmd.versionProvider(), factory);
                     initDefaultValueProvider(cmd.defaultValueProvider(), factory);
                 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -11075,6 +11075,7 @@ static CommandSpec extractCommandSpec(Object command, IFactory factory, boolean
                             result.updateCommandAttributes(cmd, factory);
                             injectSpecIntoVersionProvider(result, cmd, factory);
                             mixinStandardHelpOptions |= cmd.mixinStandardHelpOptions();
+                            hasCommandAnnotation = true;
                         }
                         initSubcommands(cmd, cls, result, factory, originalHierarchy); // after adding options
                         initMethodSubcommands(cls, result, factory); // regardless of @Command annotation. NOTE: after adding options

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4667,7 +4667,7 @@ enum Target {
         ScopeType scope() default ScopeType.LOCAL;
 
 
-        /** Returns preprocessor for subcommands ( definition should be expanded when definition of class expands )
+        /** Returns preprocessor for command spec
          * @since 4.6 */
         Class<? extends IPreprocessor> preprocessor() default NoOpPreprocessor.class;
     }
@@ -4815,8 +4815,8 @@ private static class NoVersionProvider implements IVersionProvider {
      * @since X.X */
     public interface IPreprocessor {
         /**
-         * Returns command line after doing preprocessing.
-         * @return preprocessed CommandLine
+         * Returns CommandSpec after doing preprocessing.
+         * @return preprocessed CommandSpec
          */
         CommandSpec preprocess(CommandSpec commandSpec);
     }

File: picocli-shell-jline3/src/test/java/picocli/shell/jline3/example/Example.java
Patch:
@@ -155,7 +155,7 @@ public static void main(String[] args) {
                         .variable(LineReader.LIST_MAX, 50)   // max tab completion candidates
                         .build();
                 builtins.setLineReader(reader);
-                factory.setLineReader((LineReaderImpl) reader);
+                factory.setTerminal(terminal);
                 TailTipWidgets widgets = new TailTipWidgets(reader, systemRegistry::commandDescription, 5, TailTipWidgets.TipType.COMPLETER);
                 widgets.enable();
                 KeyMap<Binding> keyMap = reader.getKeyMaps().get("main");

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15473,7 +15473,7 @@ private Layout createLayout(int longOptionsColumnWidth, ColorScheme aColorScheme
          * @since 4.6 */
         public int calcLongOptionColumnWidth(List<OptionSpec> options, List<PositionalParamSpec> positionals, ColorScheme aColorScheme) {
             int max = 0;
-            IOptionRenderer optionRenderer = new DefaultOptionRenderer(false, " ");
+            IOptionRenderer optionRenderer = createDefaultOptionRenderer();
             boolean cjk = commandSpec.usageMessage().adjustLineBreaksForWideCJKCharacters();
             int longOptionsColWidth = commandSpec.usageMessage().longOptionsMaxWidth() + 1; // add 1 space for indentation
             for (OptionSpec option : options) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -11026,11 +11026,11 @@ static CommandSpec extractCommandSpec(Object command, IFactory factory, boolean
                     injectSpecIntoVersionProvider(result, cmd, factory);
                     result.setAddMethodSubcommands(false); // method commands don't have method subcommands
                     hasCommandAnnotation = true;
-                    initFromMethodParameters(userObject, method, result, null, factory);
                     initSubcommands(cmd, null, result, factory, new Stack<Class<?>>()); // after adding options
+                    result.mixinStandardHelpOptions(cmd.mixinStandardHelpOptions()); // do this last
+                    initFromMethodParameters(userObject, method, result, null, factory);
                     // set command name to method name, unless @Command#name is set
                     result.initName(((Method)command).getName());
-                    result.mixinStandardHelpOptions(cmd.mixinStandardHelpOptions()); // do this last
                 } else {
                     Stack<Class<?>> hierarchy = new Stack<Class<?>>();
                     Class<?> cls = userObject.getType();
@@ -11050,9 +11050,9 @@ static CommandSpec extractCommandSpec(Object command, IFactory factory, boolean
                             hasCommandAnnotation = true;
                             mixinStandardHelpOptions |= cmd.mixinStandardHelpOptions();
                         }
-                        hasCommandAnnotation |= initFromAnnotatedFields(userObject, cls, result, null, factory, null);
                         initSubcommands(cmd, cls, result, factory, originalHierarchy); // after adding options
                         initMethodSubcommands(cls, result, factory); // regardless of @Command annotation. NOTE: after adding options
+                        hasCommandAnnotation |= initFromAnnotatedFields(userObject, cls, result, null, factory, null);
                     }
                     result.mixinStandardHelpOptions(mixinStandardHelpOptions); //#377 Standard help options should be added last
                 }

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/DynamicProxyConfigGenerator.java
Patch:
@@ -30,7 +30,7 @@
  * This allows picocli-based native image applications that use {@code @Command}-annotated interfaces with
  * {@code @Option} and {@code @Parameters}-annotated methods to define options and positional parameters.
  * </p><p>
- * Alternatively, the generated <a href="https://github.com/oracle/graal/blob/master/substratevm/Configuration.md">configuration</a>
+ * Alternatively, the generated <a href="https://github.com/oracle/graal/blob/master/substratevm/BuildConfiguration.md">configuration</a>
  * files can be supplied to the {@code native-image} tool by placing them in a
  * {@code META-INF/native-image/} directory on the class path, for example, in a JAR file used in the image build.
  * This directory (or any of its subdirectories) is searched for files with the names {@code jni-config.json},

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ReflectionConfigGenerator.java
Patch:
@@ -54,7 +54,7 @@
  * option of the {@code native-image} <a href="https://www.graalvm.org/docs/reference-manual/aot-compilation/">GraalVM utility</a>.
  * This allows picocli-based applications to be compiled to a native image.
  * </p><p>
- * Alternatively, the generated <a href="https://github.com/oracle/graal/blob/master/substratevm/Configuration.md">configuration</a>
+ * Alternatively, the generated <a href="https://github.com/oracle/graal/blob/master/substratevm/BuildConfiguration.md">configuration</a>
  * files can be supplied to the {@code native-image} tool by placing them in a
  * {@code META-INF/native-image/} directory on the class path, for example, in a JAR file used in the image build.
  * This directory (or any of its subdirectories) is searched for files with the names {@code jni-config.json},

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ResourceConfigGenerator.java
Patch:
@@ -26,7 +26,7 @@
  * option of the {@code native-image} <a href="https://www.graalvm.org/docs/reference-manual/aot-compilation/">GraalVM utility</a>.
  * This allows picocli-based native image applications to access these resources.
  * </p><p>
- * Alternatively, the generated <a href="https://github.com/oracle/graal/blob/master/substratevm/Configuration.md">configuration</a>
+ * Alternatively, the generated <a href="https://github.com/oracle/graal/blob/master/substratevm/BuildConfiguration.md">configuration</a>
  * files can be supplied to the {@code native-image} tool by placing them in a
  * {@code META-INF/native-image/} directory on the class path, for example, in a JAR file used in the image build.
  * This directory (or any of its subdirectories) is searched for files with the names {@code jni-config.json},

File: src/test/java/picocli/SubcommandTests.java
Patch:
@@ -2736,7 +2736,6 @@ class InhSub {
         assertEquals("An inheritable parameter rooted in a subcommand's root was not itself!", subParamRooted, subsubParamFromSub.root());
     }
 
-    @Ignore("requires #1183")
     @Test
     public void testIssue1183_HelpWithSubcommandWithRequiredOptions() {
         @Command(name = "app", mixinStandardHelpOptions = true)

File: src/test/java/picocli/SubcommandTests.java
Patch:
@@ -2492,7 +2492,6 @@ static class Sub {
         public String opt = "opt";
     }
 
-    @Ignore("Requires fix for https://github.com/remkop/picocli/issues/1250")
     @Test
     public void testInheritedParameter() {
         CommandLine cli = new CommandLine(new InhRoot());

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10111,7 +10111,7 @@ public MethodParam(Method method, int paramIndex) {
             public Method getDeclaringExecutable() { return method; }
             @Override public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
                 for (Annotation annotation : getDeclaredAnnotations()) {
-                    if (annotationClass.isAssignableFrom(annotation.getClass())) { return annotationClass.cast(annotation); }
+                    if (annotationClass.isAssignableFrom(annotation.annotationType())) { return annotationClass.cast(annotation); }
                 }
                 return null;
             }
@@ -17626,7 +17626,7 @@ private static boolean matchKeyChunks(List<String> abbreviatedKeyChunks, List<St
             for (int i = matchCount, lastMatchChunk = matchCount; i < abbreviatedKeyChunks.size(); i++, matchCount++) {
                 boolean found = false;
                 for (int j = lastMatchChunk; j < keyChunks.size(); j++) {
-                    if (found = startsWith(keyChunks.get(j), abbreviatedKeyChunks.get(i), caseInsensitive)) {
+                    if ((found = startsWith(keyChunks.get(j), abbreviatedKeyChunks.get(i), caseInsensitive))) {
                         lastMatchChunk = j + 1;
                         break;
                     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15107,13 +15107,13 @@ public int calcLongOptionColumnWidth(List<OptionSpec> options, List<PositionalPa
                 int len = cjk ? values[0][3].getCJKAdjustedLength() : values[0][3].length;
                 if (len < longOptionsColWidth) { max = Math.max(max, len); }
             }
-            List<PositionalParamSpec> positionalParamSpecs = new ArrayList<PositionalParamSpec>(positionals); // iterate in declaration order
+            List<PositionalParamSpec> positionalsWithAtFile = new ArrayList<PositionalParamSpec>(positionals); // iterate in declaration order
             if (hasAtFileParameter()) {
-                positionalParamSpecs.add(0, AT_FILE_POSITIONAL_PARAM);
+                positionalsWithAtFile.add(0, AT_FILE_POSITIONAL_PARAM);
                 AT_FILE_POSITIONAL_PARAM.messages(commandSpec.usageMessage().messages());
             }
             //IParameterRenderer paramRenderer = new DefaultParameterRenderer(false, " ");
-            for (PositionalParamSpec positionalParamSpecs : positionals) {
+            for (PositionalParamSpec positional : positionalsWithAtFile) {
                 if (positional.hidden()) { continue; }
                 //Text[][] values = paramRenderer.render(positional, parameterLabelRenderer(), colorScheme); // values[0][3]; //
                 Text label = parameterLabelRenderer().renderParameterLabel(positional, aColorScheme.ansi(), aColorScheme.parameterStyles);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15107,13 +15107,13 @@ public int calcLongOptionColumnWidth(List<OptionSpec> options, List<PositionalPa
                 int len = cjk ? values[0][3].getCJKAdjustedLength() : values[0][3].length;
                 if (len < longOptionsColWidth) { max = Math.max(max, len); }
             }
-            List<PositionalParamSpec> positionals = new ArrayList<PositionalParamSpec>(positionalParamSpecs); // iterate in declaration order
+            List<PositionalParamSpec> positionalParamSpecs = new ArrayList<PositionalParamSpec>(positionals); // iterate in declaration order
             if (hasAtFileParameter()) {
-                positionals.add(0, AT_FILE_POSITIONAL_PARAM);
+                positionalParamSpecs.add(0, AT_FILE_POSITIONAL_PARAM);
                 AT_FILE_POSITIONAL_PARAM.messages(commandSpec.usageMessage().messages());
             }
             //IParameterRenderer paramRenderer = new DefaultParameterRenderer(false, " ");
-            for (PositionalParamSpec positional : positionals) {
+            for (PositionalParamSpec positionalParamSpecs : positionals) {
                 if (positional.hidden()) { continue; }
                 //Text[][] values = paramRenderer.render(positional, parameterLabelRenderer(), colorScheme); // values[0][3]; //
                 Text label = parameterLabelRenderer().renderParameterLabel(positional, aColorScheme.ansi(), aColorScheme.parameterStyles);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -11975,7 +11975,7 @@ boolean canMatchPositionalParam(PositionalParamSpec positionalParam) {
                 int localPosition = accumulatedPosition - startPosition;
                 if (mayCreateNewMatch) {
                     int positionalParamCount = positionalParam.group().localPositionalParamCount();
-                    localPosition %= positionalParamCount;
+                    if (positionalParamCount != 0) { localPosition %= positionalParamCount; } // #1213 prevent ArithmeticException: / by zero
                 }
                 return positionalParam.index().contains(localPosition) && !lastMatch().hasMatchedValueAtPosition(positionalParam, accumulatedPosition);
             }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13413,6 +13413,9 @@ private boolean isOption(String arg) {
             if (commandSpec.optionsMap().containsKey(arg)) { // -v or -f or --file (not attached to param or other option)
                 return true;
             }
+            if (commandSpec.negatedOptionsByNameMap.containsKey(arg)) { // negated option like --no-verbose
+                return true;
+            }
             // [#828] Subcommands should not be parsed as option values for options with optional parameters.
             if (commandSpec.subcommands().containsKey(arg)) {
                 return true;

File: picocli-examples/src/main/java/picocli/examples/subcommands/SubCmdsViaMethods.java
Patch:
@@ -14,15 +14,15 @@ public class SubCmdsViaMethods implements Runnable {
     @Spec CommandSpec spec;
     
     @Command(name = "country", description = "Resolve ISO country code (ISO-3166-1, Alpha-2 code)")
-    void country(@Parameters(arity = "1..*", paramLabel = "<country code 1> <country code 2>",
+    void country(@Parameters(arity = "1..*", paramLabel = "<country code>",
                  description = "country code(s) to be resolved") String[] countryCodes) {
         for (String code : countryCodes) {
             System.out.println(String.format("%s: %s", code.toUpperCase(), new Locale("", code).getDisplayCountry()));
         }
     }
 
     @Command(name = "language", description = "Resolve ISO language code (ISO 639-1 or -2, two/three letters)")
-    void language(@Parameters(arity = "1..*", paramLabel = "<language code 1> <language code 2>",
+    void language(@Parameters(arity = "1..*", paramLabel = "<language code>",
                   description = "language code(s) to be resolved") String[] languageCodes) {
         for (String code : languageCodes) {
             System.out.println(String.format("%s: %s", code.toLowerCase(), new Locale(code).getDisplayLanguage()));

File: picocli-examples/src/main/java/picocli/examples/subcommands/SubcommandDemo.java
Patch:
@@ -35,7 +35,7 @@ public void run() { }
     @Command(name = "country", description = "Resolve ISO country code (ISO-3166-1, Alpha-2 code)")
     static class Subcommand1 implements Runnable {
 
-        @Parameters(arity = "1..*", paramLabel = "<country1> <country2>", description = "country code(s) to be resolved")
+        @Parameters(arity = "1..*", paramLabel = "<country code>", description = "country code(s) to be resolved")
         private String[] countryCodes;
 
         @Override
@@ -49,7 +49,7 @@ public void run() {
     @Command(name = "language", description = "Resolve ISO language code (ISO 639-1 or -2, two/three letters)")
     static class Subcommand2 implements Runnable {
 
-        @Parameters(arity = "1..*", paramLabel = "<code> <code2>", description = "language code(s) to be resolved")
+        @Parameters(arity = "1..*", paramLabel = "<language code>", description = "language code(s) to be resolved")
         private String[] languageCodes;
 
         @Override

File: picocli-shell-jline3/src/main/java/picocli/shell/jline3/PicocliCommands.java
Patch:
@@ -190,7 +190,7 @@ public List<String> commandInfo(String command) {
         return out;
     }
 
-    @Override
+    // @Override This method was removed in JLine 3.16.0; keep it in case this component is used with an older version of JLine
     public Object execute(CommandRegistry.CommandSession session, String command, String[] args) throws Exception {
         List<String> arguments = new ArrayList<>();
         arguments.add(command);
@@ -209,7 +209,7 @@ public Map<String, String> commandAliases() {
         return aliasCommand;
     }
 
-    @Override
+    // @Override This method was removed in JLine 3.16.0; keep it in case this component is used with an older version of JLine
     public CmdDesc commandDescription(String command) {
         return null;
     }

File: picocli-shell-jline3/src/test/java/picocli/shell/jline3/example/Example.java
Patch:
@@ -199,6 +199,8 @@ public static void main(String[] args) {
             }
         } catch (Throwable t) {
             t.printStackTrace();
+        } finally {
+            AnsiConsole.systemUninstall();
         }
     }
 }

File: picocli-examples/src/main/java/picocli/examples/parseresult/ParseResultDemo.java
Patch:
@@ -33,7 +33,7 @@ public void run() {
         String[] options = {"x", "y"};
         for (String name : options) {
             System.out.printf("%s was specified: %s%n", name, pr.hasMatchedOption(name));
-            System.out.printf("%s=%s (-1 means this option was not matched on command line)%n", name, pr.matchedOptionValue("x", -1));
+            System.out.printf("%s=%s (-1 means this option was not matched on command line)%n", name, pr.matchedOptionValue(name, -1));
             System.out.printf("%s=%s (arg value or default)%n", name, spec.findOption(name).getValue());
             System.out.println();
         }

File: picocli-annotation-processing-tests/src/test/java/picocli/annotation/processing/tests/Issue1151Test.java
Patch:
@@ -29,7 +29,6 @@ public void testIssue1151() {
     }
 
 
-    @Ignore("Requires fix for https://github.com/remkop/picocli/issues/1151")
     @Test
     public void testGenerateReflectConfigIssue1151() {
         NativeImageConfigGeneratorProcessor processor = new NativeImageConfigGeneratorProcessor();

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ReflectionConfigGenerator.java
Patch:
@@ -187,6 +187,7 @@ static final class Visitor {
                 List.class.getName(),
                 Set.class.getName(),
                 Map.class.getName(),
+                Class.class.getName(), Class[].class.getName(), Class[].class.getCanonicalName(), "java.lang.Class<?>", "java.lang.Class<?>[]",
                 "java.lang.reflect.Executable", // addMethod("getParameters")
                 "java.lang.reflect.Parameter", // addMethod("getName");
                 "org.fusesource.jansi.AnsiConsole", // addField("out", false);

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/CompletionCandidatesMetaData.java
Patch:
@@ -41,7 +41,7 @@ public static Iterable<String> extract(Element element) {
                 for (ExecutableElement attribute : elementValues.keySet()) {
                     if ("completionCandidates".equals(attribute.getSimpleName().toString())) {
                         AnnotationValue typeMirror = elementValues.get(attribute);
-                        return new CompletionCandidatesMetaData((TypeMirror) typeMirror);
+                        return new CompletionCandidatesMetaData((TypeMirror) typeMirror.getValue());
                     }
                 }
             }
@@ -72,7 +72,7 @@ public TypeElement getTypeElement() {
     /** Always returns {@code null}. */
     @Override
     public Iterator<String> iterator() {
-        return null;
+        throw new UnsupportedOperationException("Cannot instantiate " + typeMirror + " at compile time.");
     }
 
     /**

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13427,7 +13427,7 @@ private Object tryConvert(ArgSpec argSpec, int index, ITypeConverter<?> converte
                 return converter.convert(value);
             } catch (TypeConversionException ex) {
                 String msg = String.format("Invalid value for %s: %s", optionDescription("", argSpec, index), ex.getMessage());
-                throw new ParameterException(CommandLine.this, msg, argSpec, value);
+                throw new ParameterException(CommandLine.this, msg, ex, argSpec, value);
             } catch (Exception other) {
                 String desc = optionDescription("", argSpec, index);
                 String msg = String.format("Invalid value for %s: cannot convert '%s' to %s (%s)", desc, value, type.getSimpleName(), other);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3682,7 +3682,7 @@ public enum ScopeType {
          * Also, embedded {@code %n} newline markers are converted to actual newlines.
          * </p>
          * @return the description of this option
-         * @see <a href="https://picocli.info/#_variable_interpolation">Variable Interpolation</a> section of the user manual
+         * @see <a href="https://picocli.info/#_variable_interpolation">Variable Interpolation section of the user manual</a>
          */
         String[] description() default {};
 
@@ -3967,7 +3967,7 @@ public enum ScopeType {
          * Also, embedded {@code %n} newline markers are converted to actual newlines.
          * </p>
          * @return the description of the parameter(s)
-         * @see <a href="https://picocli.info/#_variable_interpolation">Variable Interpolation</a> section of the user manual
+         * @see <a href="https://picocli.info/#_variable_interpolation">Variable Interpolation section of the user manual</a>
          */
         String[] description() default {};
 
@@ -15757,7 +15757,7 @@ public static TextTable forColumnWidths(ColorScheme colorScheme, int... columnWi
              * @param columns columns to construct this TextTable with
              * @since 4.2 */
             public static TextTable forColumns(ColorScheme colorScheme, Column... columns) { return new TextTable(colorScheme, columns); }
-            /** @deprecated use {@link TextTable#TextTable(picocli.CommandLine.Help.ColorScheme, picocli.CommandLine.Help.Column[])} instead */
+            /** @deprecated use {@link picocli.CommandLine.Help.TextTable#TextTable(picocli.CommandLine.Help.ColorScheme, picocli.CommandLine.Help.Column[])}  instead */
             @Deprecated protected TextTable(Ansi ansi, Column[] columns) { this(Help.defaultColorScheme(ansi), columns); }
             protected TextTable(ColorScheme colorScheme, Column[] columns) {
                 this.colorScheme = Assert.notNull(colorScheme, "ansi");

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -1738,7 +1738,7 @@ private String getCompletionScriptTextWithHidden(String commandName) {
                 "function _complete_%1$s() {\n" +
                 "  local cmds0=(help)\n" +
                 "\n" +
-                "  if CompWordsContainsArray \"${cmds0[@]}\"; then _picocli_CompletionDemo_help; return $?; fi\n" +
+                "  if CompWordsContainsArray \"${cmds0[@]}\"; then _picocli_%1$s_help; return $?; fi\n" +
                 "\n" +
                 "  # No subcommands were specified; generate completions for the top-level command.\n" +
                 "  _picocli_%1$s; return $?;\n" +
@@ -1750,9 +1750,9 @@ private String getCompletionScriptTextWithHidden(String commandName) {
                 "  local curr_word=${COMP_WORDS[COMP_CWORD]}\n" +
                 "  local prev_word=${COMP_WORDS[COMP_CWORD-1]}\n" +
                 "\n" +
-                "  local commands=\"generate-completion help\"\n" +
+                "  local commands=\"help\"\n" + // NOTE: no generate-completion: this command is hidden
                 "  local flag_opts=\"\"\n" +
-                "  local arg_opts=\"--apples --bbb\"\n" +
+                "  local arg_opts=\"--apples --bbb\"\n" + // NOTE: no --aaa: this option is hidden
                 "\n" +
                 "  compopt +o default\n" +
                 "\n" +

File: src/test/java/picocli/ArityTest.java
Patch:
@@ -769,7 +769,7 @@ class App {
             CommandLine.populateCommand(new App(),  "-Long", "-boolean");
             fail("should fail");
         } catch (CommandLine.ParameterException ex) {
-            assertEquals("Invalid value for option '-Long': '-boolean' is not a long", ex.getMessage());
+            assertEquals("Expected parameter for option '-Long' but found '-boolean'", ex.getMessage());
         }
     }
     /** see <a href="https://github.com/remkop/picocli/issues/279">issue #279</a>  */

File: src/test/java/picocli/LenientParsingTest.java
Patch:
@@ -190,7 +190,7 @@ class App {
         cmd.getCommandSpec().parser().collectErrors(true);
         cmd.parseArgs("-Long", "-boolean");
         assertEquals(1, cmd.getParseResult().errors().size());
-        assertEquals("Invalid value for option '-Long': '-boolean' is not a long", cmd.getParseResult().errors().get(0).getMessage());
+        assertEquals("Expected parameter for option '-Long' but found '-boolean'", cmd.getParseResult().errors().get(0).getMessage());
     }
     @Test
     public void testBooleanOptionsArity0_nFailsIfAttachedParamNotABoolean() { // ignores varargs

File: src/test/java/picocli/UnmatchedOptionTest.java
Patch:
@@ -115,16 +115,14 @@ class App {
         assertArrayEquals(new String[]{"4", "5"}, app.y);
     }
 
-    @Ignore
     @Test
     public void testSingleValueOptionDoesNotConsumeActualOption() {
         class App {
             @Option(names = "-x") int x;
             @Option(names = "-y") String y;
         }
 
-        //FIXME
-        expect(new App(), "Missing required parameter for option '-x' (<x>)", MissingParameterException.class, "-y", "-x");
+        expect(new App(), "Expected parameter for option '-y' but found '-x'", MissingParameterException.class, "-y", "-x");
     }
 
     @Test

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -90,7 +90,7 @@ public class ManPageGenerator implements Callable<Integer> {
     @Spec CommandSpec spec;
 
     /**
-     * Invokes {@link #generateManPage(Config, CommandSpec...)} to generate man pages for
+     * Invokes {@link #generateManPage(Config, CommandLine.Model.CommandSpec...)} to generate man pages for
      * all non-hidden commands in the hierarchy from the top-level command down.
      * This method is only called when this class is used as a subcommand.
      * @return an exit code indicating success or failure, as follows:
@@ -215,7 +215,7 @@ public Integer call() throws Exception {
     }
 
     /**
-     * Invokes {@link #generateManPage(Config, CommandSpec...)} to generate man pages for
+     * Invokes {@link #generateManPage(Config, CommandLine.Model.CommandSpec...)} to generate man pages for
      * the user-specified {@code @Command}-annotated classes.
      * <p>
      *     If the {@code --exit} option is specified, {@code System.exit} is invoked

File: picocli-shell-jline3/src/main/java/picocli/shell/jline3/PicocliCommands.java
Patch:
@@ -149,7 +149,7 @@ private CommandLine findSubcommandLine(CommandLine cmdline, String command) {
 
     /**
      *
-     * @param command
+     * @param args
      * @return command description for JLine TailTipWidgets to be displayed in terminal status bar.
      */
     @Override

File: src/test/java/picocli/TestUtil.java
Patch:
@@ -137,13 +137,14 @@ public static String stripAnsiTrace(String original) {
     private static String stripAnsiTraceOnce(String original, String prefix, String prefix2, String suffix, String replacement) {
         int pos = original.indexOf(prefix);
         if (pos > 0) {
+            int endPos = pos;
             if (prefix2 != null) { // this allows us to skip over any intermediate closing brackets ')' in the "ANSI is disabled by default" line (https://github.com/remkop/picocli/issues/1103#issuecomment-640204473)
                 int pos2 = original.indexOf(prefix2, pos);
                 if (pos2 > 0) {
-                    pos = pos2;
+                    endPos = pos2;
                 }
             }
-            int to = original.indexOf(suffix, pos);
+            int to = original.indexOf(suffix, endPos);
             return original.substring(0, pos) + replacement + original.substring(to);
         }
         return original;

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -344,8 +344,9 @@ private static boolean mkdirs(Config config, File directory) {
     }
 
     private static String makeFileName(CommandSpec spec) {
-        String result = spec.qualifiedName("-") + ".adoc";
-        return result.replaceAll("\\s", "_");
+        return (spec.qualifiedName("-") + ".adoc")
+                .replaceAll("\\s", "_")
+                .replace("<main_class>", "main_class");
     }
 
     private static void generateSingleManPage(CommandSpec spec, File manpage) throws IOException {

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -42,6 +42,7 @@
  */
 @Command(name = "gen-manpage",
         version = "${COMMAND-FULL-NAME} " + CommandLine.VERSION,
+        helpCommand = true, // don't validate required options and positional parameters of the parent command
         showAtFileInUsageHelp = true,
         mixinStandardHelpOptions = true,
         sortOptions = false,

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5753,7 +5753,7 @@ private CommandSpec(CommandUserObject userObject) {
 
             private CommandSpec copy() {
                 Object obj = userObject.type == null ? userObject.instance : userObject.type;
-                CommandSpec result = obj == null ? CommandSpec.create() : CommandSpec.forAnnotatedObject(obj);
+                CommandSpec result = obj == null ? CommandSpec.create() : CommandSpec.forAnnotatedObject(obj, userObject.factory);
                 result.commandLine = commandLine;
                 result.parent = parent;
                 result.methodParams = methodParams;

File: picocli-shell-jline3/src/test/java/picocli/shell/jline3/example/Example.java
Patch:
@@ -175,8 +175,7 @@ public static void main(String[] args) {
                     .build();
             builtins.setLineReader(reader);
             commands.setReader(reader);
-            TailTipWidgets ttw = new TailTipWidgets(reader, systemRegistry::commandDescription, 5, TipType.COMPLETER);
-            ttw.setDescriptionCache(false);
+            new TailTipWidgets(reader, systemRegistry::commandDescription, 5, TipType.COMPLETER);
             KeyMap<Binding> keyMap = reader.getKeyMaps().get("main");
             keyMap.bind(new Reference("tailtip-toggle"), KeyMap.alt("s"));
 
@@ -195,7 +194,6 @@ public static void main(String[] args) {
                 } catch (EndOfFileException e) {
                     return;
                 } catch (Exception e) {
-                    e.printStackTrace();
                     systemRegistry.trace(e);
                 }
             }

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -387,7 +387,7 @@ static void genOptions(PrintWriter pw, CommandSpec spec) {
         List<ArgGroupSpec> groups = optionListGroups(spec);
         for (ArgGroupSpec group : groups) { options.removeAll(group.options()); }
 
-        if (options.isEmpty()) {
+        if (options.isEmpty() && !spec.usageMessage().showEndOfOptionsDelimiterInUsageHelp()) {
             return;
         }
         pw.printf("// tag::picocli-generated-man-section-options[]%n");

File: picocli-codegen/src/test/java/picocli/codegen/docgen/manpage/ManPageGeneratorTest.java
Patch:
@@ -230,7 +230,7 @@ class MyApp {
         assertEquals(expected, sw.toString());
     }
 
-    @Ignore // test case for https://github.com/remkop/picocli/issues/1077
+//    @Ignore // test case for https://github.com/remkop/picocli/issues/1077
     @Test
     public void testEndOfOptions() throws IOException {
 

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -464,7 +464,7 @@ private static void writePositional(PrintWriter pw, PositionalParamSpec position
     }
 
     static void genPositionalArgs(PrintWriter pw, CommandSpec spec) {
-        List<PositionalParamSpec> positionals = new ArrayList<>(spec.positionalParameters());
+        List<PositionalParamSpec> positionals = new ArrayList<PositionalParamSpec>(spec.positionalParameters());
         // remove hidden params
         for (Iterator<PositionalParamSpec> iter = positionals.iterator(); iter.hasNext();) {
             if (iter.next().hidden()) { iter.remove(); }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10845,6 +10845,7 @@ private static void validateInjectSpec(TypedMember member) {
                     throw new InitializationException("@picocli.CommandLine.Spec annotation is only supported on fields of type " + CommandSpec.class.getName());
                 }
             }
+            @SuppressWarnings("unchecked") //warning: [unchecked] Possible heap pollution from parameterized vararg type Class<? extends Annotation>
             private static void assertNoDuplicateAnnotations(TypedMember member, Class<? extends Annotation> myAnnotation, Class<? extends Annotation>... forbidden) {
                 for (Class<? extends Annotation> annotation : forbidden) {
                     if (member.isAnnotationPresent(annotation)) {

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -1068,7 +1068,7 @@ public void testDebugOutputForDoubleDashSeparatesPositionalParameters() throws E
                         "[picocli DEBUG] Creating CommandSpec for picocli.CommandLineTest$CompactFields@20f5239f with factory picocli.CommandLine$DefaultFactory%n" +
                         "[picocli INFO] Picocli version: %3$s%n" +
                         "[picocli INFO] Parsing 6 command line args [-oout, --, -r, -v, p1, p2]%n" +
-                        "[picocli DEBUG] Parser configuration: posixClusteredShortOptionsAllowed=true, stopAtPositional=false, stopAtUnmatched=false, separator=null, overwrittenOptionsAllowed=false, unmatchedArgumentsAllowed=false, expandAtFiles=true, atFileCommentChar=#, useSimplifiedAtFiles=false, endOfOptionsDelimiter=--, limitSplit=false, aritySatisfiedByAttachedOptionParam=false, toggleBooleanFlags=false, unmatchedOptionsArePositionalParams=false, collectErrors=false,caseInsensitiveEnumValuesAllowed=false, trimQuotes=false, splitQuotedStrings=false%n" +
+                        "[picocli DEBUG] Parser configuration: optionsCaseInsensitive=false, subcommandsCaseInsensitive=false, abbreviatedOptionsAllowed=false, abbreviatedSubcommandsAllowed=false, aritySatisfiedByAttachedOptionParam=false, atFileCommentChar=#, caseInsensitiveEnumValuesAllowed=false, collectErrors=false, endOfOptionsDelimiter=--, expandAtFiles=true, limitSplit=false, overwrittenOptionsAllowed=false, posixClusteredShortOptionsAllowed=true, separator=null, splitQuotedStrings=false, stopAtPositional=false, stopAtUnmatched=false, toggleBooleanFlags=false, trimQuotes=false, unmatchedArgumentsAllowed=false, unmatchedOptionsArePositionalParams=false, useSimplifiedAtFiles=false%n" +
                         "[picocli DEBUG] (ANSI is disabled by default: ...)%n" +
                         "[picocli DEBUG] Initializing command 'null' (user object: picocli.CommandLineTest$CompactFields@20f5239f): 3 options, 1 positional parameters, 0 required, 0 groups, 0 subcommands.%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.CommandLineTest$CompactFields.verbose of type boolean to false.%n" +
@@ -2042,7 +2042,7 @@ public void testTracingDebugWithSubCommands() throws Exception {
                         "[picocli DEBUG] Adding subcommand 'tag' to 'git'%n" +
                         "[picocli INFO] Picocli version: %3$s%n" +
                         "[picocli INFO] Parsing 8 command line args [--git-dir=/home/rpopma/picocli, commit, -m, \"Fixed typos\", --, src1.java, src2.java, src3.java]%n" +
-                        "[picocli DEBUG] Parser configuration: posixClusteredShortOptionsAllowed=true, stopAtPositional=false, stopAtUnmatched=false, separator=null, overwrittenOptionsAllowed=false, unmatchedArgumentsAllowed=false, expandAtFiles=true, atFileCommentChar=#, useSimplifiedAtFiles=false, endOfOptionsDelimiter=--, limitSplit=false, aritySatisfiedByAttachedOptionParam=false, toggleBooleanFlags=false, unmatchedOptionsArePositionalParams=false, collectErrors=false,caseInsensitiveEnumValuesAllowed=false, trimQuotes=false, splitQuotedStrings=false%n" +
+                        "[picocli DEBUG] Parser configuration: optionsCaseInsensitive=false, subcommandsCaseInsensitive=false, abbreviatedOptionsAllowed=false, abbreviatedSubcommandsAllowed=false, aritySatisfiedByAttachedOptionParam=false, atFileCommentChar=#, caseInsensitiveEnumValuesAllowed=false, collectErrors=false, endOfOptionsDelimiter=--, expandAtFiles=true, limitSplit=false, overwrittenOptionsAllowed=false, posixClusteredShortOptionsAllowed=true, separator=null, splitQuotedStrings=false, stopAtPositional=false, stopAtUnmatched=false, toggleBooleanFlags=false, trimQuotes=false, unmatchedArgumentsAllowed=false, unmatchedOptionsArePositionalParams=false, useSimplifiedAtFiles=false%n" +
                         "[picocli DEBUG] (ANSI is disabled by default: ...)%n" +
                         "[picocli DEBUG] Initializing command 'git' (user object: picocli.Demo$Git@75d4a5c2): 3 options, 0 positional parameters, 0 required, 0 groups, 12 subcommands.%n" +
                         "[picocli DEBUG] Set initial value for field java.io.File picocli.Demo$Git.gitDir of type class java.io.File to null.%n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -17207,7 +17207,7 @@ public static String match(Set<String> set, String abbreviation, boolean caseIns
             }
             if (candidates.size() > 1) {
                 String str = candidates.toString();
-                throw new IllegalArgumentException(abbreviation + " is not unique: it matches '" +
+                throw new IllegalArgumentException("'" + abbreviation + "' is not unique: it matches '" +
                         str.substring(1, str.length() - 1).replace(", ", "', '") + "'");
             }
             return candidates.isEmpty() ? abbreviation : candidates.get(0); // return the original if no match found

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -17240,8 +17240,9 @@ private static boolean startsWith(String str, String prefix, boolean caseInsensi
         }
 
         private static boolean isNonAlphabetic(String str) {
-            for (int i = 0; i < str.length(); i++) {
-                if (Character.isLetterOrDigit(str.codePointAt(i))) { return false; }
+            for (int i = 0, codepoint; i < str.length(); i += Character.charCount(codepoint)) {
+                codepoint = str.codePointAt(i);
+                if (Character.isLetterOrDigit(codepoint)) { return false; }
             }
             return true;
         }

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -3948,8 +3948,7 @@ public int asCommand() {
 
         String content = new String(output.toByteArray(), "UTF-8")
                 .replaceAll("\r\n", "\n"); // Normalize line endings.
-        assertEquals("IllegalArgumentException: h is not unique: it matches 'hello', 'help' while processing argument at or before arg[0] 'h' in [h]: "
-                + "java.lang.IllegalArgumentException: h is not unique: it matches 'hello', 'help'\n"
+        assertEquals("Error: h is not unique: it matches 'hello', 'help'\n"
                 + "Usage: <main class> [COMMAND]\n"
                 + "Commands:\n"
                 + "  another-style\n"
@@ -4010,7 +4009,7 @@ class App {
 
         String content = new String(output.toByteArray(), "UTF-8")
                 .replaceAll("\r\n", "\n"); // Normalize line endings.
-        assertEquals("IllegalArgumentException: -h is not unique: it matches '-H', '--help', '--hello' while processing argument at or before arg[0] '-h' in [-h]: java.lang.IllegalArgumentException: -h is not unique: it matches '-H', '--help', '--hello'\n"
+        assertEquals("Error: -h is not unique: it matches '-H', '--help', '--hello'\n"
                 + "Usage: <main class> [-H] [--[no-]another-style] [--[no-]cammelCaseOption]\n"
                 + "                    [--hello] [--version]\n"
                 + "      --[no-]another-style\n"

File: src/main/java/picocli/NameMatcher.java
Patch:
@@ -33,7 +33,8 @@ private static String makeCanonical(String str) {
         }
         if (str.startsWith("-") && str.length() > 1) {
             int codepoint = str.codePointAt(1);
-            return ((char) Character.toUpperCase(codepoint)) + str.substring(1 + Character.charCount(codepoint));
+            char[] uppercase = Character.toChars(Character.toUpperCase(codepoint));
+            return new String(uppercase) + str.substring(1 + Character.charCount(codepoint));
         }
         return str;
     }
@@ -47,8 +48,7 @@ static String match(Set<String> set, String abbreviation) {
         next_key:
         for (String key : set) {
             List<String> keyChunks = splitIntoChunks(key);
-            if (abbreviatedKeyChunks.size() <= keyChunks.size() && keyChunks.get(0)
-                    .startsWith(abbreviatedKeyChunks.get(0))) { // first chunk must match
+            if (abbreviatedKeyChunks.size() <= keyChunks.size() && keyChunks.get(0).startsWith(abbreviatedKeyChunks.get(0))) { // first chunk must match
                 int matchCount = 1;
                 int keyChunk = 1;
                 for (int i = 1; i < abbreviatedKeyChunks.size(); i++) {

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -115,7 +115,7 @@ private void verboseDetailed(String message, Object... params) {
             footerHeading = "%nConverting to Man Page Format%n%n",
             footer = {"Use the `asciidoctor` tool to convert the generated AsciiDoc files to man pages in roff format:",
                     "",
-                    "`asciidoctor --backend=manpage --source-dir=SOURCE_DIR --destination-dir=DESTINATION` ",
+                    "`asciidoctor --backend=manpage --source-dir=SOURCE_DIR --destination-dir=DESTINATION *.adoc`",
                     "",
                     "Point the SOURCE_DIR to either the `--outdir` directory or the `--template-dir` directory. Use some other directory as the DESTINATION.",
                     "See https://asciidoctor.org/docs/user-manual/#man-pages",

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -205,7 +205,7 @@ private boolean checkExists(final File file) {
      * This class can be used as a subcommand for the top-level command in your application.
      * Users can then install completion for the top-level command by running the following command:
      * </p><pre>
-     * source &lt;(top-level-command [sub-commands] generate-completion)
+     * source &lt;(top-level-command [sub-command] generate-completion)
      * </pre>
      * @since 4.1
      */

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -7912,7 +7912,7 @@ private <T extends Builder<T>> ArgSpec(Builder<T> builder) {
                 description = builder.description == null ? new String[0] : builder.description;
                 descriptionKey = builder.descriptionKey;
                 splitRegex = builder.splitRegex == null ? "" : builder.splitRegex;
-                splitRegexSynopsisLabel = builder.splitRegex == null ? "" : builder.splitRegexSynopsisLabel;
+                splitRegexSynopsisLabel = builder.splitRegexSynopsisLabel == null ? "" : builder.splitRegexSynopsisLabel;
                 paramLabel = empty(builder.paramLabel) ? "PARAM" : builder.paramLabel;
                 hideParamSyntax = builder.hideParamSyntax;
                 converters = builder.converters == null ? new ITypeConverter<?>[0] : builder.converters;

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -12785,7 +12785,7 @@ private int applyValuesToMapField(ArgSpec argSpec,
             ITypeConverter<?> keyConverter   = getTypeConverter(classes[0], argSpec, 0);
             ITypeConverter<?> valueConverter = getTypeConverter(classes[1], argSpec, 1);
             @SuppressWarnings("unchecked") Map<Object, Object> map = (Map<Object, Object>) argSpec.getValue();
-            if (map == null || (!map.isEmpty() && !initialized.contains(argSpec))) {
+            if (map == null || !initialized.contains(argSpec)) {
                 tracer.debug("Initializing binding for %s on %s with empty %s%n", optionDescription("", argSpec, 0), argSpec.scopeString(), argSpec.type().getSimpleName());
                 map = createMap(argSpec.type()); // map class
                 argSpec.setValue(map);
@@ -12969,7 +12969,7 @@ private int applyValuesToCollectionField(ArgSpec argSpec,
             Class<?> type = argSpec.auxiliaryTypes()[0];
             int pos = getPosition(argSpec);
             List<Object> converted = consumeArguments(argSpec, negated, lookBehind, alreadyUnquoted, alreadyUnquoted, arity, args, type, argDescription);
-            if (collection == null || (!collection.isEmpty() && !initialized.contains(argSpec))) {
+            if (collection == null ||  !initialized.contains(argSpec))  {
                 tracer.debug("Initializing binding for %s on %s with empty %s%n", optionDescription("", argSpec, 0), argSpec.scopeString(), argSpec.type().getSimpleName());
                 collection = createCollection(argSpec.type(), type); // collection type, element type
                 argSpec.setValue(collection);

File: src/test/java/picocli/TypeConversionTest.java
Patch:
@@ -917,7 +917,7 @@ public void testListOptionParametersAreReusedIfNonNull() {
         params.timeUnitList = list;
         new CommandLine(params).parseArgs("-timeUnitList", "SECONDS", "MICROSECONDS", "SECONDS");
         assertEquals(Arrays.asList(SECONDS, MICROSECONDS, SECONDS), params.timeUnitList);
-        assertSame(list, params.timeUnitList);
+        assertNotSame(list, params.timeUnitList);
     }
     @Test
     public void testConcreteCollectionParametersAreInstantiatedIfNull() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -12706,7 +12706,7 @@ private int applyValuesToMapField(ArgSpec argSpec,
             ITypeConverter<?> keyConverter   = getTypeConverter(classes[0], argSpec, 0);
             ITypeConverter<?> valueConverter = getTypeConverter(classes[1], argSpec, 1);
             @SuppressWarnings("unchecked") Map<Object, Object> map = (Map<Object, Object>) argSpec.getValue();
-            if (map == null || (!map.isEmpty() && !initialized.contains(argSpec))) {
+            if (map == null || !initialized.contains(argSpec)) {
                 tracer.debug("Initializing binding for %s on %s with empty %s%n", optionDescription("", argSpec, 0), argSpec.scopeString(), argSpec.type().getSimpleName());
                 map = createMap(argSpec.type()); // map class
                 argSpec.setValue(map);
@@ -12890,7 +12890,7 @@ private int applyValuesToCollectionField(ArgSpec argSpec,
             Class<?> type = argSpec.auxiliaryTypes()[0];
             int pos = getPosition(argSpec);
             List<Object> converted = consumeArguments(argSpec, negated, lookBehind, alreadyUnquoted, alreadyUnquoted, arity, args, type, argDescription);
-            if (collection == null || (!collection.isEmpty() && !initialized.contains(argSpec))) {
+            if (collection == null ||  !initialized.contains(argSpec))  {
                 tracer.debug("Initializing binding for %s on %s with empty %s%n", optionDescription("", argSpec, 0), argSpec.scopeString(), argSpec.type().getSimpleName());
                 collection = createCollection(argSpec.type(), type); // collection type, element type
                 argSpec.setValue(collection);

File: src/test/java/picocli/TypeConversionTest.java
Patch:
@@ -917,7 +917,7 @@ public void testListOptionParametersAreReusedIfNonNull() {
         params.timeUnitList = list;
         new CommandLine(params).parseArgs("-timeUnitList", "SECONDS", "MICROSECONDS", "SECONDS");
         assertEquals(Arrays.asList(SECONDS, MICROSECONDS, SECONDS), params.timeUnitList);
-        assertSame(list, params.timeUnitList);
+        assertNotSame(list, params.timeUnitList);
     }
     @Test
     public void testConcreteCollectionParametersAreInstantiatedIfNull() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -6059,7 +6059,7 @@ public CommandSpec addOption(OptionSpec option) {
                     if (existing != null) { /* was: && !existing.equals(option)) {*/ // since 4.0 ArgGroups: an option cannot be in multiple groups
                         throw DuplicateOptionAnnotationsException.create(existingName, option, existing);
                     }
-                    // #1022 checks if negated option exists with the same name
+                    // #1022 checks if negated options exist with the same name
                     String existingNegatedName = negatedOptionsByNameMap.getCaseSensitiveKey(name);
                     OptionSpec existingNegated = negatedOptionsByNameMap.get(name);
                     if (existingNegated != null && existingNegated != option) {
@@ -6116,7 +6116,7 @@ private void resetNegativeOptionNames() {
             }
 
             private void validateNegativeOptions() {
-                // #1022 checks if negated option exists with the same name, after activate case-insensitivity
+                // #1022 checks if negated options exist with the same name, after changing negatableOptionTransformer
                 for (Map.Entry<String, OptionSpec> negatedOptionEntry : negatedOptionsByNameMap.entrySet()) {
                     String negatedOptionName = negatedOptionEntry.getKey();
                     OptionSpec negatedOption = negatedOptionEntry.getValue();

File: src/test/java/picocli/NegatableOptionTest.java
Patch:
@@ -456,7 +456,7 @@ class NegOptDupli {
             fail("Expected Exception");
         } catch (CommandLine.DuplicateOptionAnnotationsException ex) {
             String cls = NegOptDupli.class.getName();
-            assertEquals("Option name '--verbose' is used by both field boolean " + cls + ".noVerbose and field boolean " + cls + ".verbose", ex.getMessage());
+            assertEquals("Option name '--no-verbose' is used by both field boolean " + cls + ".noVerbose and field boolean " + cls + ".verbose", ex.getMessage());
         }
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -6005,7 +6005,7 @@ public CommandSpec addOption(OptionSpec option) {
                     String existingNegatedName = optionsByNameMap.getCaseSensitiveKey(negatedName);
                     OptionSpec existingNegated = negatedOptionsByNameMap.get(negatedName);
                     if (existingNegated == null) { existingNegated = optionsByNameMap.get(negatedName); }
-                    if (existingNegated != null) {
+                    if (existingNegated != null && existingNegated != option && existingNegated.negatable()) {
                         throw DuplicateOptionAnnotationsException.create(existingNegatedName, option, existingNegated);
                     }
                     if (name.length() == 2 && name.startsWith("-")) { posixOptionsByKeyMap.put(name.charAt(1), option); }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -16657,6 +16657,7 @@ public boolean printSuggestions(PrintWriter writer) {
                 writer.println(isUnknownOption()
                         ? "Possible solutions: " + str(suggestions)
                         : "Did you mean: " + str(suggestions).replace(", ", " or ") + "?");
+                writer.flush();
             }
             return !suggestions.isEmpty();
         }

File: src/test/java/picocli/HelpTest.java
Patch:
@@ -4530,7 +4530,7 @@ public void testParameterListHeading_NonEmpty() {
         class A { }
 
         String actual = new Help(new A()).parameterListHeading();
-        String expected = String.format("      [@<filename>...]   One or more argument files containing options.%n");
+        String expected = String.format("Parameters:%n");
         assertEquals(expected, actual);
     }
 

File: src/test/java/picocli/HelpTest.java
Patch:
@@ -4530,7 +4530,7 @@ public void testParameterListHeading_NonEmpty() {
         class A { }
 
         String actual = new Help(new A()).parameterListHeading();
-        String expected = String.format("      [@<filename>...]   One or more argument files containing options.%n");
+        String expected = String.format("Parameters:%n");
         assertEquals(expected, actual);
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -14114,6 +14114,7 @@ private int calcLongOptionColumnWidth() {
             boolean cjk = commandSpec.usageMessage().adjustLineBreaksForWideCJKCharacters();
             int longOptionsColWidth = commandSpec.usageMessage().longOptionsMaxWidth() + 1; // add 1 space for indentation
             for (OptionSpec option : commandSpec.options()) {
+                if (option.hidden()) { continue; }
                 Text[][] values = optionRenderer.render(option, parameterLabelRenderer(), colorScheme);
                 int len = cjk ? values[0][3].getCJKAdjustedLength() : values[0][3].length;
                 if (len < longOptionsColWidth) { max = Math.max(max, len); }
@@ -14125,6 +14126,7 @@ private int calcLongOptionColumnWidth() {
             }
             //IParameterRenderer paramRenderer = new DefaultParameterRenderer(false, " ");
             for (PositionalParamSpec positional : positionals) {
+                if (positional.hidden()) { continue; }
                 //Text[][] values = paramRenderer.render(positional, parameterLabelRenderer(), colorScheme); // values[0][3]; //
                 Text label = parameterLabelRenderer().renderParameterLabel(positional, colorScheme.ansi(), colorScheme.parameterStyles);
                 int len = cjk ? label.getCJKAdjustedLength() : label.length;

File: src/test/java/picocli/CaseAwareLinkedMapTest.java
Patch:
@@ -197,7 +197,7 @@ public void testInconvertibleClass() {
             map.getCaseSensitiveKey(dummy);
             fail("Expected exception");
         } catch (UnsupportedOperationException ex) {
-            assertEquals("Unsupported case-conversion for class class java.lang.Object", ex.getMessage());
+            assertEquals("Unsupported case-conversion for key class java.lang.Object", ex.getMessage());
         }
     }
 }

File: picocli-examples/src/main/java/picocli/examples/casesensitivity/CaseInsensitiveDemo.java
Patch:
@@ -23,7 +23,7 @@ public void run() {
 
     public static void main(String... args){
         new CommandLine(new CaseInsensitiveDemo())
-                .setOptionsCaseInsensitive(true)     // accepts `-H`, `--nAmE`
+                .setOptionsCaseInsensitive(true)     // accepts `-N`, `--nAmE`
                 .setSubcommandsCaseInsensitive(true) // accepts `gREET`, `GREET`
                 .execute(args);
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5869,7 +5869,7 @@ public CommandSpec addSubcommand(String name, CommandLine subCommandLine) {
                 for (String alias : subSpec.aliases()) {
                     if (t.isDebug()) {t.debug("Adding alias '%s' for '%s'%n", (parent == null ? "" : parent.qualifiedName() + " ") + alias, this.qualifiedName());}
                     previous = commands.put(alias, subCommandLine);
-                    if (previous != null && previous != subCommandLine) { throw new InitializationException("Alias '" + alias + "' for subcommand '" + previousName + "' is already used by another subcommand of '" + this.name() + "'"); }
+                    if (previous != null && previous != subCommandLine) { throw new InitializationException("Alias '" + alias + "' for subcommand '" + actualName + "' is already used by another subcommand of '" + this.name() + "'"); }
                 }
                 subSpec.initCommandHierarchyWithResourceBundle(resourceBundleBaseName(), resourceBundle());
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5755,14 +5755,14 @@ protected CommandSpec commandLine(CommandLine commandLine) {
             /** Initializes the usageMessage specification for this command from the specified settings and returns this commandSpec.*/
             public CommandSpec usageMessage(UsageMessageSpec settings) { usageMessage.initFrom(settings, this); return this; }
 
-            /** Returns whether the subcommands is case-insensitive.
+            /** Returns whether the subcommands are case-insensitive.
              * @since 4.3 */
             public boolean caseInsensitiveSubcommands() { return commands.isCaseInsensitive(); }
             /** Sets the case-insensitivity of subcommands.
              * @since 4.3 */
             public CommandSpec caseInsensitiveSubcommands(boolean caseInsensitiveSubcommands) { commands.setCaseInsensitive(caseInsensitiveSubcommands);  return this; }
 
-            /** Returns whether the options is case-insensitive.
+            /** Returns whether the options are case-insensitive.
              * @since 4.3 */
             public boolean caseInsensitiveOptions() { return optionsByNameMap.isCaseInsensitive(); }
             /** Sets the case-insensitivity of options.

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -813,7 +813,7 @@ public CommandLine setCaseInsensitiveCommands(boolean newValue) {
      * @return {@code true} if options can be specified that don't match the {@code names()} value of the registered ones, {@code false} otherwise;
      * e.g., for an option of names -h, inputs like -h and -H are both recognized as it if {@code true}.
      * @since 4.3 */
-    public boolean isCaseInsensitiveOptions() { return getCommandSpec().caseInsensitive(); }
+    public boolean isCaseInsensitiveOptions() { return getCommandSpec().caseInsensitiveOptions(); }
 
     /** Sets whether the command should be case-insensitive in options. The default is {@code false}.
      * When set to true, for example, for an option of names -h, inputs like -h and -H are both recognized as it if {@code true}.

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5421,10 +5421,10 @@ private static class LinkedCaseAwareMap<K, V> extends AbstractMap<K, V> {
             private boolean caseInsensitive = false;
 
             /**
-             * Constructs an empty LinkedCaseAwareMap instance with {@link java.util.Locale#getDefault}.
+             * Constructs an empty LinkedCaseAwareMap instance with {@link java.util.Locale#ENGLISH}.
              */
             public LinkedCaseAwareMap() {
-                this(Locale.getDefault());
+                this(ENGLISH);
             }
 
             /**

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5479,10 +5479,10 @@ public boolean isEmpty() {
 
             public boolean containsKey(Object key) {
                 if (key != null && caseInsensitive) {
-                    if (!(key instanceof String)) {
+                    if (!isCaseConvertible(key.getClass())) {
                         return false;
                     }
-                    return keyMap.containsKey(((String) key).toLowerCase(locale));
+                    return keyMap.containsKey(toLowerCase(key));
                 } else {
                     return targetMap.containsKey(key);
                 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5406,14 +5406,14 @@ public boolean isCaseInsensitive() {
 
             /** Sets the case-insensitivity of the map. */
             public void setCaseInsensitive(boolean caseInsensitive) {
-                if (caseInsensitive) {
+                if (!isCaseInsensitive() && caseInsensitive) {
                     for (K key : targetMap.keySet()) {
                         K duplicatedKey = keyMap.put(toLowerCase(key), key);
                         if (duplicatedKey != null) {
                             throw new IllegalStateException("Duplicated keys: " + duplicatedKey + " and " + key);
                         }
                     }
-                } else {
+                } else if (isCaseInsensitive()) {
                     keyMap.clear();
                 }
                 this.caseInsensitive = caseInsensitive;

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -342,7 +342,7 @@ public void testGroupSpecToString() {
         builder.addSubgroup(ArgGroupSpec.builder().addSubgroup(b).addArg(OPTION_A).build());
         builder.addArg(PositionalParamSpec.builder().index("0..1").paramLabel("FILE").build());
 
-        String expected2 = "ArgGroup[exclusive=false, multiplicity=1, validate=false, order=123, args=[params[0..1]=FILE], headingKey='my headingKey', heading='my heading'," +
+        String expected2 = "ArgGroup[exclusive=false, multiplicity=1, validate=false, order=123, args=[FILE], headingKey='my headingKey', heading='my heading'," +
                 " subgroups=[ArgGroup[exclusive=true, multiplicity=0..1, validate=true, order=-1, args=[-a], headingKey=null, heading=null," +
                 " subgroups=[ArgGroup[exclusive=true, multiplicity=0..1, validate=true, order=-1, args=[-x], headingKey=null, heading=null, subgroups=[]]]" +
                 "]]" +

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -339,7 +339,7 @@ public void testAutoCompleteRequiresCommandLineFQCN() {
         exit.expectSystemExitWithStatus(AutoComplete.EXIT_CODE_INVALID_INPUT);
         exit.checkAssertionAfterwards(new Assertion() {
             public void checkAssertion() {
-                String expected = String.format("Missing required parameter: <commandLineFQCN>%n") + AUTO_COMPLETE_APP_USAGE;
+                String expected = String.format("Missing required parameter: '<commandLineFQCN>'%n") + AUTO_COMPLETE_APP_USAGE;
                 assertEquals(expected, systemErrRule.getLog());
             }
         });
@@ -350,7 +350,7 @@ public void checkAssertion() {
     @Test
     public void testAutoCompleteRequiresCommandLineFQCN_NoSystemExit() {
         AutoComplete.main();
-        String expected = String.format("Missing required parameter: <commandLineFQCN>%n") + AUTO_COMPLETE_APP_USAGE;
+        String expected = String.format("Missing required parameter: '<commandLineFQCN>'%n") + AUTO_COMPLETE_APP_USAGE;
         assertEquals(expected, systemErrRule.getLog());
     }
 

File: src/test/java/picocli/CommandMethodTest.java
Patch:
@@ -114,7 +114,7 @@ public void testAnnotateMethod_unannotatedPositional() throws Exception {
             CommandLine.populateCommand(m);
             fail("Missing required field should have thrown exception");
         } catch (MissingParameterException ex) {
-            assertEquals("Missing required parameter: <arg0>", ex.getMessage());
+            assertEquals("Missing required parameter: '<arg0>'", ex.getMessage());
         }
 
         // test execute
@@ -403,7 +403,7 @@ public void testAnnotateMethod_annotated() throws Exception {
             CommandLine.populateCommand(m, "0");
             fail("Missing required option should have thrown exception");
         } catch (MissingParameterException ex) {
-            assertEquals("Missing required option '-b=<arg1>'", ex.getMessage());
+            assertEquals("Missing required option: '-b=<arg1>'", ex.getMessage());
         }
 
         // test execute

File: src/test/java/picocli/HelpTest.java
Patch:
@@ -3380,7 +3380,7 @@ public void run() { }
                 .execute(args);
 
         String expected = format("" +
-                "Missing required parameter: FILES%n" +
+                "Missing required parameter: 'FILES'%n" +
                 "Usage: <main class> FILES...%n" +
                 "      FILES...   List of files%n");
         assertEquals(expected, sw.toString());
@@ -3405,7 +3405,7 @@ public void run() { }
                 .execute(args);
 
         String expected = format("" +
-                "Missing required parameter: FILES%n" +
+                "Missing required parameter: 'FILES'%n" +
                 "Usage: <main class> [-v] FILES...%n" +
                 "      FILES...   List of files%n" +
                 "  -v             Print output%n");

File: src/test/java/picocli/InterpolatedModelTest.java
Patch:
@@ -280,7 +280,7 @@ class Issue676 {
             cmd.parseArgs();
             fail("Expected exception");
         } catch (MissingParameterException ex) {
-            assertEquals("Missing required option '--mypath=<path>'", ex.getMessage());
+            assertEquals("Missing required option: '--mypath=<path>'", ex.getMessage());
         }
 
         System.setProperty("MYPATH", "abc");

File: src/test/java/picocli/ModelCommandSpecTest.java
Patch:
@@ -101,7 +101,7 @@ public void testVersionHelp_helpCommand() {
         try {
             commandLine.parseArgs();
         } catch (MissingParameterException ex) {
-            assertEquals("Missing required option '-x=PARAM'", ex.getMessage());
+            assertEquals("Missing required option: '-x=PARAM'", ex.getMessage());
             assertEquals(1, ex.getMissing().size());
             assertSame(ex.getMissing().get(0).toString(), parent.posixOptionsMap().get('x'), ex.getMissing().get(0));
         }

File: src/test/java/picocli/RangeTest.java
Patch:
@@ -592,7 +592,7 @@ class UnanchoredAfterOpenEndedIndex {
             CommandLine.populateCommand(new UnanchoredAfterOpenEndedIndex(), "a", "b", "c");
             fail("Expected exception");
         } catch (CommandLine.MissingParameterException ex) {
-            assertEquals("Missing required parameter: <last>", ex.getMessage());
+            assertEquals("Missing required parameter: '<last>'", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -1893,6 +1893,7 @@ public void testTracingDebugWithSubCommands() throws Exception {
                         "[picocli INFO] Setting field java.io.File picocli.Demo$Git.gitDir to '%2$s' (was 'null') for option --git-dir%n" +
                         "[picocli DEBUG] [1] Processing argument 'commit'. Remainder=[-m, \"Fixed typos\", --, src1.java, src2.java, src3.java]%n" +
                         "[picocli DEBUG] Found subcommand 'commit' (command 'git-commit' (user object: picocli.Demo$GitCommit@22ff4249))%n" +
+                        "[picocli DEBUG] Checking required args for parent command 'git' (user object: picocli.Demo$Git@00000000)...%n" +
                         "[picocli DEBUG] Initializing command 'git-commit' (user object: picocli.Demo$GitCommit@22ff4249): 8 options, 1 positional parameters, 0 required, 0 groups, 0 subcommands.%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.Demo$GitCommit.all of type boolean to false.%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.Demo$GitCommit.patch of type boolean to false.%n" +

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -608,7 +608,7 @@ private static String generateFunctionForCommand(String functionName, String com
         Set<String> subCommands = commandLine.getSubcommands().keySet();
         // If the command is a HelpCommand, append parent subcommands to the autocompletion list.
         if (commandLine.getParent() != null && commandLine.getCommand() instanceof HelpCommand) {
-            subCommands = new HashSet<String>(subCommands);
+            subCommands = new LinkedHashSet<String>(subCommands);
             for (CommandLine subCommandLine : commandLine.getParent().getSubcommands().values()) {
                 if (!subCommandLine.getCommandSpec().usageMessage().hidden()) { // #887 skip hidden subcommands
                     subCommands.add(subCommandLine.getCommandName());

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -3389,7 +3389,7 @@ static class GeneralOptions {
         }
     }
 
-    @Ignore("Requires fix for https://github.com/remkop/picocli/issues/988")
+//    @Ignore("Requires fix for https://github.com/remkop/picocli/issues/988")
     @Test //https://github.com/remkop/picocli/issues/988
     public void testIssue988OptionGroupSectionsShouldIncludeSubgroupOptions() {
         String expected = String.format("" +

File: src/test/java/picocli/CommandMethodTest.java
Patch:
@@ -556,11 +556,12 @@ static class UnAnnotatedClassWithoutAnnotatedFields {
 
     @Test
     public void testMethodCommandsAreNotSubcommandsOfNonAnnotatedClass() {
+        Object userObject = new UnAnnotatedClassWithoutAnnotatedFields();
         try {
-            new CommandLine(new UnAnnotatedClassWithoutAnnotatedFields());
+            new CommandLine(userObject);
             fail("expected exception");
         } catch (CommandLine.InitializationException ex) {
-            assertEquals("picocli.CommandMethodTest$UnAnnotatedClassWithoutAnnotatedFields " +
+            assertEquals(userObject + " " +
                             "is not a command: it has no @Command, @Option, " +
                             "@Parameters or @Unmatched annotations", ex.getMessage());
         }

File: src/test/java/picocli/ModelCommandSpecTest.java
Patch:
@@ -487,11 +487,12 @@ public void testMixinStandardHelpOptions_SettingToFalseRemovesHelpOptions() {
 
     @Test
     public void testCommandSpec_forAnnotatedObject_requiresPicocliAnnotation() {
+        Object userObject = new Object();
         try {
-            CommandSpec.forAnnotatedObject(new Object());
+            CommandSpec.forAnnotatedObject(userObject);
             fail("Expected error");
         } catch (InitializationException ok) {
-            assertEquals("java.lang.Object is not a command: it has no @Command, @Option, @Parameters or @Unmatched annotations", ok.getMessage());
+            assertEquals(userObject + " is not a command: it has no @Command, @Option, @Parameters or @Unmatched annotations", ok.getMessage());
         }
     }
 

File: src/test/java/picocli/SubcommandTests.java
Patch:
@@ -563,7 +563,7 @@ class MissingCommandAnnotation { public MissingCommandAnnotation() {} }
             new CommandLine(new MainCommand(), new InnerClassFactory(this));
             fail("Expected exception");
         } catch (InitializationException ex) {
-            String expected = String.format("%s is not a command: it has no @Command, @Option, @Parameters or @Unmatched annotations", MissingCommandAnnotation.class.getName());
+            String expected = String.format("%s is not a command: it has no @Command, @Option, @Parameters or @Unmatched annotations", MissingCommandAnnotation.class.toString());
             assertEquals(expected, ex.getMessage());
         }
     }

File: src/test/java/picocli/AtFileTest.java
Patch:
@@ -756,7 +756,6 @@ class A {
         assertEquals(expected, actual);
     }
 
-    @Ignore("Requires #984 Parameters heading not shown when `@filename` is the only parameter")
     @Test
     public void testAtFileParameterListHeadingShownIfNoOtherPositionalParameters() {
         @Command(name = "A", mixinStandardHelpOptions = true,

File: src/test/java/picocli/SubcommandTests.java
Patch:
@@ -2195,7 +2195,7 @@ static class SubSub990 {
         @Option(names = "-c") int c = -33;
     }
 
-    @Ignore("Needs fix for https://github.com/remkop/picocli/issues/990")
+    //@Ignore("Needs fix for https://github.com/remkop/picocli/issues/990")
     @Test // https://github.com/remkop/picocli/issues/990
     public void testIssue990_OptionsInSubcommandsNotResetToTheirInitialValue() {
         CommandLine cmd = new CommandLine(new Top990());

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5026,7 +5026,7 @@ private static Range parameterIndex(IAnnotatedElement member) {
             if (member.isMethodParameter()) {
                 int min = member.getMethodParamPosition();
                 int max = member.isMultiValue() ? Integer.MAX_VALUE : min;
-                return new Range(min, max, member.isMultiValue(), false, "");
+                return new Range(min, max, member.isMultiValue(), false, null);
             }
             return Range.valueOf("*"); // the default
         }

File: picocli-examples/src/main/java/picocli/examples/typeconverter/InetSocketAddressConverterDemo.java
Patch:
@@ -11,7 +11,7 @@ public class InetSocketAddressConverterDemo {
 
     static class InetSocketAddressConverter implements ITypeConverter<InetSocketAddress> {
         @Override
-        public InetSocketAddress convert(String value) throws Exception {
+        public InetSocketAddress convert(String value) {
             int pos = value.lastIndexOf(':');
             if (pos < 0) {
                 //throw new IllegalArgumentException("Invalid format: must be 'host:port' but was '" + value + "'");

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13142,7 +13142,6 @@ public Help(Object command, Ansi ansi) {
          * @param colorScheme the color scheme to use */
         public Help(CommandSpec commandSpec, ColorScheme colorScheme) {
             this.commandSpec = Assert.notNull(commandSpec, "commandSpec");
-            commandSpec.userObject(); // #690 ensure the user object is instantiated
             this.aliases = new ArrayList<String>(Arrays.asList(commandSpec.aliases()));
             this.aliases.add(0, commandSpec.name());
             this.colorScheme = new ColorScheme.Builder(colorScheme).applySystemProperties().build();

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/processor/AbstractGenerator.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.Map;
 
 abstract class AbstractGenerator implements IGenerator {
-    public static final String OPTION_QUIET = "quiet";
+    public static final String OPTION_VERBOSE = "verbose";
     protected final ProcessingEnvironment processingEnv;
     private final String fileName;
     private final String disableKey;
@@ -63,7 +63,7 @@ protected String generateConfig(Map<Element, CommandLine.Model.CommandSpec> allC
      * @param msg the info message
      */
     protected void logInfo(String msg) {
-        if (!processingEnv.getOptions().containsKey("quiet")) {
+        if (processingEnv.getOptions().containsKey(OPTION_VERBOSE)) {
             processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, getClass().getSimpleName() + " " + msg);
         }
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -12113,7 +12113,7 @@ private boolean canConsumeOneMapArgument(ArgSpec argSpec, LookBehind lookBehind,
                 }
                 return true;
             } catch (PicocliException ex) {
-                tracer.debug("$s cannot be assigned to %s: type conversion fails: %s.%n", arg, argDescription, ex.getMessage());
+                tracer.debug("%s cannot be assigned to %s: type conversion fails: %s.%n", arg, argDescription, ex.getMessage());
                 return false;
             }
         }
@@ -12341,7 +12341,7 @@ private boolean canConsumeOneArgument(ArgSpec argSpec, LookBehind lookBehind, bo
                 }
                 return true;
             } catch (PicocliException ex) {
-                tracer.debug("$s cannot be assigned to %s: type conversion fails: %s.%n", arg, argDescription, ex.getMessage());
+                tracer.debug("%s cannot be assigned to %s: type conversion fails: %s.%n", arg, argDescription, ex.getMessage());
                 return false;
             }
         }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10175,15 +10175,15 @@ public <T> T set(T value) throws PicocliException {
                     currentValue = value;
                     return result;
                 } catch (InvocationTargetException ex) {
-                    if (ex.getCause() instanceof PicocliException) { throw (PicocliException) ex.getCause(); }
-                    throw createParameterException(value, ex.getCause());
+                    if (ex.getTargetException() instanceof PicocliException) { throw (PicocliException) ex.getTargetException(); }
+                    throw createParameterException(value, ex.getTargetException());
                 } catch (Exception ex) {
                     throw createParameterException(value, ex);
                 }
             }
             private ParameterException createParameterException(Object value, Throwable t) {
                 CommandLine cmd = spec.commandLine() == null ? new CommandLine(spec) : spec.commandLine();
-                return new ParameterException(cmd, "Could not invoke " + method + " with " + value, t);
+                return new ParameterException(cmd, "Could not invoke " + method + " with " + value + " (" + t + ")", t);
             }
             public String toString() {
                 return String.format("%s(%s)", getClass().getSimpleName(), method);

File: src/test/java/picocli/OptionMethodImplTest.java
Patch:
@@ -234,7 +234,7 @@ class App {
             assertNotNull(ex.getCause());
             assertTrue(ex.getCause() instanceof IllegalArgumentException);
             assertEquals("Boo!", ex.getCause().getMessage());
-            assertEquals("Could not invoke public void picocli.OptionMethodImplTest$1App.jvmException(java.lang.String) with abc", ex.getMessage());
+            assertEquals("Could not invoke public void picocli.OptionMethodImplTest$1App.jvmException(java.lang.String) with abc (java.lang.IllegalArgumentException: Boo!)", ex.getMessage());
         }
     }
 

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/JniConfigGenerator.java
Patch:
@@ -3,6 +3,7 @@
 import picocli.CommandLine;
 import picocli.CommandLine.Command;
 import picocli.CommandLine.Mixin;
+import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 import picocli.codegen.aot.graalvm.ReflectionConfigGenerator.ReflectedClass;
 

File: src/test/java/picocli/ExecuteLegacyTest.java
Patch:
@@ -488,7 +488,7 @@ static class MyRunnable implements Runnable {
             "Usage: @|bold mycmd|@ [@|yellow -hV|@] [@|yellow -x|@=@|italic <option>|@]%n" +
             "  @|yellow -h|@, @|yellow --help|@      Show this help message and exit.%n" +
             "  @|yellow -V|@, @|yellow --version|@   Print version information and exit.%n" +
-            "  @|yellow -x|@=@|italic <|@@|italic option>|@     this is an option%n")).toString();
+            "  @|yellow -x|@=@|italic <option>|@     this is an option%n")).toString();
 
     @Test
     public void testCall1WithInvalidInput() {

File: src/test/java/picocli/ExecuteTest.java
Patch:
@@ -372,7 +372,7 @@ static class MyRunnable implements Runnable {
             "Usage: @|bold mycmd|@ [@|yellow -hV|@] [@|yellow -x|@=@|italic <option>|@]%n" +
             "  @|yellow -h|@, @|yellow --help|@      Show this help message and exit.%n" +
             "  @|yellow -V|@, @|yellow --version|@   Print version information and exit.%n" +
-            "  @|yellow -x|@=@|italic <|@@|italic option>|@     this is an option%n")).toString();
+            "  @|yellow -x|@=@|italic <option>|@     this is an option%n")).toString();
 
     @Test
     public void testExecuteWithInvalidInput() {

File: src/test/java/picocli/HelpAnsiTest.java
Patch:
@@ -200,7 +200,7 @@ class Args {
         String expected = String.format("" +
                 "Usage: @|reverse <main class>|@ [@|bg_magenta -x|@=@|bg_yellow <options>|@]... [@|bg_cyan <params>|@...]%n" +
                 "      [@|bg_cyan <params>|@...]   param desc%n" +
-                "  @|bg_magenta -x|@=@|bg_yellow <|@@|bg_yellow options>|@        option desc%n");
+                "  @|bg_magenta -x|@=@|bg_yellow <options>|@        option desc%n");
         assertEquals(Ansi.ON.new Text(expected).toString(), actual);
     }
 

File: src/test/java/picocli/HelpTest.java
Patch:
@@ -2967,7 +2967,7 @@ class App {
         String expected = Help.Ansi.ON.string(String.format("" +
                 "Usage: @|bg_cyan <main class>|@ [@|green -hV|@] [@|green -f|@=@|magenta ARCHIVE|@] @|bg_white POSITIONAL|@%n" +
                 "@|bg_white  |@     @|bg_white POSITIONAL|@   positional arg%n" +
-                "  @|green -f|@=@|magenta A|@@|magenta RCHIVE|@       the archive file%n" +
+                "  @|green -f|@=@|magenta ARCHIVE|@       the archive file%n" +
                 "  @|green -h|@, @|green --help|@       Show this help message and exit.%n" +
                 "  @|green -V|@, @|green --version|@    Print version information and exit.%n"));
         assertEquals(expected, baos.toString());

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -203,10 +203,10 @@ private boolean checkExists(final File file) {
     @Command(name = "generate-completion", version = "generate-completion " + CommandLine.VERSION,
             mixinStandardHelpOptions = true,
             description = {
-                "Generate bash/zsh completion script for ${PARENT-COMMAND-NAME}.",
-                "Run the following command to give `${PARENT-COMMAND-NAME}` TAB completion in the current shell:",
+                "Generate bash/zsh completion script for ${PARENT-COMMAND-NAME:-the parent command of this command}.",
+                "Run the following command to give `${PARENT-COMMAND-NAME:-$PARENTCOMMAND}` TAB completion in the current shell:",
                 "",
-                "source <(${PARENT-COMMAND-NAME} ${COMMAND-NAME})",
+                "  source <(${PARENT-COMMAND-NAME:-$PARENTCOMMAND} ${COMMAND-NAME})",
                 ""},
             optionListHeading = "Options:%n",
             helpCommand = true

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -1362,7 +1362,7 @@ public void testGenerateCompletionUsageMessage() {
                 "Generate bash/zsh completion script for myapp.%n" +
                 "Run the following command to give `myapp` TAB completion in the current shell:%n" +
                 "%n" +
-                "source <(myapp generate-completion)%n" +
+                "  source <(myapp generate-completion)%n" +
                 "%n" +
                 "Options:%n" +
                 "  -h, --help      Show this help message and exit.%n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -8847,7 +8847,9 @@ private Text rawSynopsisUnitText(Help.ColorScheme colorScheme, Set<ArgSpec> outp
             private Text concatOptionText(Text text, Help.ColorScheme colorScheme, OptionSpec option) {
                 if (!option.hidden()) {
                     Text name = option.negatable()
-                            ? colorScheme.optionText(option.commandSpec.negatableOptionTransformer().makeSynopsis(option.shortestName(), option.commandSpec))
+                            ? colorScheme.optionText(
+                                    (option.commandSpec == null ? RegexTransformer.createDefault() : option.commandSpec.negatableOptionTransformer())
+                                            .makeSynopsis(option.shortestName(), option.commandSpec))
                             : colorScheme.optionText(option.shortestName());
                     Text param = createLabelRenderer(option.commandSpec).renderParameterLabel(option, colorScheme.ansi(), colorScheme.optionParamStyles);
                     text = text.concat(open(option)).concat(name).concat(param).concat(close(option));

File: picocli-codegen/src/test/java/picocli/codegen/docgen/manpage/ManPageGeneratorTest.java
Patch:
@@ -56,7 +56,7 @@ class MyApp {
 
         StringWriter sw = new StringWriter();
         PrintWriter pw = new PrintWriter(sw); //System.out, true
-        ManPageGenerator.generateSingleManPage(pw, new CommandLine(new MyApp()).getCommandSpec());
+        ManPageGenerator.writeSingleManPage(pw, new CommandLine(new MyApp()).getCommandSpec());
         pw.flush();
 
         String expected = read("/myapp.manpage.adoc");
@@ -130,7 +130,7 @@ public void setVerbosity(boolean[] verbosity) {
         }
         StringWriter sw = new StringWriter();
         PrintWriter pw = new PrintWriter(sw); //System.out, true
-        ManPageGenerator.generateSingleManPage(pw, new CommandLine(new ImportCommand()).getCommandSpec());
+        ManPageGenerator.writeSingleManPage(pw, new CommandLine(new ImportCommand()).getCommandSpec());
         pw.flush();
 
         String expected = read("/import.manpage.txt");

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -1008,6 +1008,7 @@ static class Graph {
         private List<Integer>[] adjacencyList; // Adjacency List
 
         //Constructor
+        @SuppressWarnings("unchecked")
         Graph(int vertexCount) {
             this.vertexCount = vertexCount;
             adjacencyList = new LinkedList[vertexCount];

File: picocli-codegen/src/main/java/picocli/codegen/docgen/manpage/ManPageGenerator.java
Patch:
@@ -380,6 +380,7 @@ public static String[] longestFirst(String[] names) {
     /** Sorts {@code OptionSpec} instances by their name in case-insensitive alphabetic order. If an option has
      * multiple names, the shortest name is used for the sorting. Help options follow non-help options. */
     static class SortByShortestOptionNameAlphabetically implements Comparator<OptionSpec> {
+        @SuppressWarnings("deprecation")
         public int compare(OptionSpec o1, OptionSpec o2) {
             if (o1 == null) { return 1; } else if (o2 == null) { return -1; } // options before params
             String[] names1 = ShortestFirst.sort(o1.names());

File: picocli-examples/src/main/java/picocli/examples/customhelp/EnvironmentVariablesSection.java
Patch:
@@ -73,7 +73,7 @@ public EnvironmentVariablesRenderer(Map<String, String> env) {
     public String render(CommandLine.Help help) {
         if (env.isEmpty()) { return ""; }
         int keyLength = maxLength(env.keySet());
-        TextTable textTable = TextTable.forColumns(help.ansi(),
+        TextTable textTable = TextTable.forColumns(help.colorScheme(),
                 new Column(keyLength + 3, 2, Column.Overflow.SPAN),
                 new Column(width(help) - (keyLength + 3), 2, Column.Overflow.WRAP));
         textTable.setAdjustLineBreaksForWideCJKCharacters(adjustCJK(help));

File: picocli-examples/src/main/java/picocli/examples/customhelp/ShowCommandHierarchy.java
Patch:
@@ -54,7 +54,7 @@ public String render(Help help) {
 
         // prepare layout: two columns
         // the left column overflows, the right column wraps if text is too long
-        TextTable textTable = TextTable.forColumns(help.ansi(),
+        TextTable textTable = TextTable.forColumns(help.colorScheme(),
                 new Column(15, 2, Overflow.SPAN),
                 new Column(spec.usageMessage().width() - 15, 2, Overflow.WRAP));
         textTable.setAdjustLineBreaksForWideCJKCharacters(spec.usageMessage().adjustLineBreaksForWideCJKCharacters());

File: src/test/java/picocli/CustomLayoutDemo.java
Patch:
@@ -155,6 +155,7 @@ public void layout(ArgSpec arg, Text[][] values) {
                 }
             }
         }
+        @SuppressWarnings("deprecation")
         TextTable textTable = TextTable.forColumns(ansi,
                 new Column(5, 2, TRUNCATE), // values should fit
                 new Column(30, 2, SPAN), // overflow into adjacent columns
@@ -242,6 +243,7 @@ class Netstat {
         sb.append(help.header()).append(help.detailedSynopsis(0, null, false));
         sb.append(System.getProperty("line.separator"));
 
+        @SuppressWarnings("deprecation")
         TextTable textTable = TextTable.forColumns(ansi,
                 new Column(15, 2, TRUNCATE),
                 new Column(65, 1, WRAP));

File: src/test/java/picocli/HelpAnsiTest.java
Patch:
@@ -477,6 +477,7 @@ public void testTextConstructorWithStyle() {
 
     @Test
     public void testTextApply() {
+        @SuppressWarnings("deprecation")
         Ansi.Text txt = Ansi.ON.apply("--p", Arrays.<Ansi.IStyle>asList(Ansi.Style.fg_red, Ansi.Style.bold));
         assertEquals(Ansi.ON.new Text("@|fg(red),bold --p|@"), txt);
     }

File: src/test/java/picocli/TextTableTest.java
Patch:
@@ -45,8 +45,8 @@ public void addRowValues_nulls()
     assertEquals(" key\n                value\n", normalizeNewlines(textTable));
   }
 
-  private CommandLine.Help.TextTable emptyTable()
-  {
+  @SuppressWarnings("deprecation")
+  private CommandLine.Help.TextTable emptyTable() {
     return forColumns(CommandLine.Help.Ansi.OFF,
                       new CommandLine.Help.Column(15, 1, SPAN),
                       new CommandLine.Help.Column(65, 1, WRAP));

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15277,7 +15277,9 @@ public void getStyledChars(int from, int length, Text destination, int offset) {
                         destination.length = offset;
                     }
                     for (StyledSection section : sections) {
-                        destination.sections.add(section.withStartIndex(section.startIndex - from + destination.length));
+                        if ((section.startIndex - from) + section.length >= 0) {
+                            destination.sections.add(section.withStartIndex(section.startIndex - from + destination.length));
+                        }
                     }
                     destination.plain.append(plain.toString().substring(from, from + length));
                     destination.length = destination.plain.length();

File: src/test/java/picocli/Demo.java
Patch:
@@ -639,7 +639,7 @@ public void testUsageSubCommandCommit() {
             "Record changes to the repository.%n" +
             "%n" +
             "@|bold git-commit|@ [@|yellow -ap|@] [@|yellow -c|@=@|italic <commit>|@] [@|yellow -C|@=@|italic <commit>|@] [@|yellow -F|@=@|italic <file>|@] [@|yellow --fixup|@=@|italic <commit>|@]%n" +
-            " @|italic         |@  [@|yellow --squash|@=@|italic <commit>|@] [@|yellow -m|@=@|italic <msg>|@]... [@|yellow <files>|@...]%n" +
+            "           [@|yellow --squash|@=@|italic <commit>|@] [@|yellow -m|@=@|italic <msg>|@]... [@|yellow <files>|@...]%n" +
             "%n" +
             "@|bold,underline Description:|@%n" +
             "%n" +

File: src/test/java/picocli/HelpAnsiTest.java
Patch:
@@ -423,9 +423,9 @@ class App {
         CommandLine.Help help = new CommandLine.Help(new App(), Ansi.ON);
         assertEquals(Ansi.ON.new Text(String.format(
                 "@|bold <best-app-ever>|@ [@|yellow --another-long-option-name|@=@|italic ^[<another-long-option-value>]|@]%n" +
-                        "@|italic               |@  [@|yellow --fourth-long-option-name|@=@|italic <fourth-long-option-value>|@]%n" +
-                        "@|italic               |@  [@|yellow --long-option@-name|@=@|italic <long-option-valu@@e>|@]%n" +
-                        "@|italic               |@  [@|yellow --third-long-option-name|@=@|italic <third-long-option-value>|@]%n")),
+                        "                [@|yellow --fourth-long-option-name|@=@|italic <fourth-long-option-value>|@]%n" +
+                        "                [@|yellow --long-option@-name|@=@|italic <long-option-valu@@e>|@]%n" +
+                        "                [@|yellow --third-long-option-name|@=@|italic <third-long-option-value>|@]%n")),
                 help.synopsis(0));
     }
 

File: picocli-codegen/src/test/java/picocli/codegen/docgen/manpage/ManPageGeneratorTest.java
Patch:
@@ -48,7 +48,7 @@ class MyApp {
 
         StringWriter sw = new StringWriter();
         PrintWriter pw = new PrintWriter(sw); //System.out, true
-        ManPageGenerator.generateManPage(pw, new CommandLine(new MyApp()).getCommandSpec());
+        ManPageGenerator.generateSingleManPage(pw, new CommandLine(new MyApp()).getCommandSpec());
         pw.flush();
 
         assertEquals(read("/myapp.manpage.adoc"), sw.toString());

File: picocli-codegen/src/main/java/picocli/codegen/util/OutputFileMixin.java
Patch:
@@ -8,8 +8,8 @@
 
 public class OutputFileMixin {
 
-    @Option(names = {"-o", "--output"}, description = "Output file to write the configuration to. " +
-            "If not specified, the configuration is written to the standard output stream.")
+    @Option(names = {"-o", "--output"}, description = "Output file to write the result to. " +
+            "If not specified, the output is written to the standard output stream.")
     File outputFile;
 
     public void write(String text) throws IOException {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -8932,7 +8932,7 @@ ParseResult.GroupValidationResult validateArgs(CommandLine commandLine, Collecti
                 missing.removeAll(matchedArgs);
                 intersection.retainAll(found);
                 int presentCount = intersection.size();
-                boolean haveMissing = !missing.isEmpty();
+                boolean haveMissing = !missing.isEmpty() && !exclusive();
                 boolean someButNotAllSpecified = haveMissing && !intersection.isEmpty();
                 String exclusiveElements = ArgSpec.describe(intersection);
                 String requiredElements = ArgSpec.describe(requiredArgs());

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -9797,6 +9797,7 @@ static CommandSpec extractCommandSpec(Object command, IFactory factory, boolean
                 if (userObject.isMethod()) {
                     Method method = (Method) command;
                     t.debug("Using method %s as command %n", method);
+                    method.setAccessible(true);
                     Command cmd = method.getAnnotation(Command.class);
                     result.updateCommandAttributes(cmd, factory);
                     injectSpecIntoVersionProvider(result, cmd, factory);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13257,6 +13257,7 @@ protected Text createDetailedSynopsisPositionalsText(Collection<ArgSpec> done) {
             List<PositionalParamSpec> positionals = new ArrayList<PositionalParamSpec>(commandSpec.positionalParameters()); // iterate in declaration order
             if (commandSpec.parser.expandAtFiles() && commandSpec.usageMessage.showAtFileInUsageHelp()) {
                 positionals.add(0, AT_FILE_POSITIONAL_PARAM);
+                AT_FILE_POSITIONAL_PARAM.messages(commandSpec.usageMessage().messages());
             }
             positionals.removeAll(done);
             for (PositionalParamSpec positionalParam : positionals) {
@@ -13352,6 +13353,7 @@ private int calcLongOptionColumnWidth() {
             List<PositionalParamSpec> positionals = new ArrayList<PositionalParamSpec>(commandSpec.positionalParameters()); // iterate in declaration order
             if (commandSpec.parser.expandAtFiles() && commandSpec.usageMessage.showAtFileInUsageHelp()) {
                 positionals.add(0, AT_FILE_POSITIONAL_PARAM);
+                AT_FILE_POSITIONAL_PARAM.messages(commandSpec.usageMessage().messages());
             }
             //IParameterRenderer paramRenderer = new DefaultParameterRenderer(false, " ");
             for (PositionalParamSpec positional : positionals) {
@@ -13429,6 +13431,7 @@ public String parameterList(Layout layout, IParamLabelRenderer paramLabelRendere
             List<PositionalParamSpec> positionals = new ArrayList<PositionalParamSpec>(commandSpec.positionalParameters());
             if (commandSpec.parser.expandAtFiles() && commandSpec.usageMessage.showAtFileInUsageHelp()) {
                 positionals.add(0, AT_FILE_POSITIONAL_PARAM);
+                AT_FILE_POSITIONAL_PARAM.messages(commandSpec.usageMessage().messages());
             }
             List<ArgGroupSpec> groups = optionListGroups();
             for (ArgGroupSpec group : groups) { positionals.removeAll(group.positionalParameters()); }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -12947,7 +12947,7 @@ public static class Help {
 
         private final static int defaultOptionsColumnWidth = 24;
         public final PositionalParamSpec AT_FILE_POSITIONAL_PARAM = PositionalParamSpec.builder()
-                .paramLabel("${picocli.atfile.label:-@<filename>}").description("${picocli.atfile.description:-One or more argument files containing options}").arity("0..*")
+                .paramLabel("${picocli.atfile.label:-@<filename>}").description("${picocli.atfile.description:-One or more argument files containing options.}").arity("0..*")
                 .descriptionKey("picocli.atfile").build();
 
         private final CommandSpec commandSpec;

File: src/test/java/picocli/I18nTest.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.ResourceBundle;
 
 import static org.junit.Assert.*;
+import static picocli.TestUtil.stripAnsiTrace;
 
 /**
  * Tests internationalization (i18n) and localization (l12n)-related functionality.
@@ -722,6 +723,6 @@ public void testTracingWithResourceBundle() {
                 "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'help' (picocli.CommandLine$HelpCommand)%n" +
                 "[picocli DEBUG] Creating CommandSpec for object of class picocli.CommandLine$AutoHelpMixin with factory picocli.CommandLine$DefaultFactory%n" +
                 "");
-        assertEquals(expected, err.toString());
+        assertEquals(stripAnsiTrace(expected), stripAnsiTrace(err.toString()));
     }
 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5388,7 +5388,7 @@ public CommandSpec addSubcommand(String name, CommandLine subCommandLine) {
                 if (subSpec.name == null) { subSpec.name(actualName); }
                 subSpec.parent(this);
                 for (String alias : subSpec.aliases()) {
-                    if (t.isDebug()) {t.debug("Adding alias '%s' for subcommand '%s' to '%s'%n", alias, actualName, this.qualifiedName());}
+                    if (t.isDebug()) {t.debug("Adding alias '%s' for '%s'%n", (parent == null ? "" : parent.qualifiedName() + " ") + alias, this.qualifiedName());}
                     previous = commands.put(alias, subCommandLine);
                     if (previous != null && previous != subCommandLine) { throw new InitializationException("Alias '" + alias + "' for subcommand '" + actualName + "' is already used by another subcommand of '" + this.name() + "'"); }
                 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -9802,7 +9802,7 @@ private static boolean initFromAnnotatedTypedMembers(TypedMember member,
                         throw new InitializationException("@Mixins are not supported on @ArgGroups");
                         // TODO groupBuilder.addMixin(member.getMixinName(), buildMixinForMember(member, factory));
                     } else {
-                        commandSpec.addMixin(member.getMixinName(), buildMixinForMember(member, factory));
+                        commandSpec.addMixin(member.getMixinName(), buildMixinForMember(member, factory), member);
                     }
                     result = true;
                 }

File: src/test/java/picocli/I18nTest.java
Patch:
@@ -709,7 +709,7 @@ public void testTracingWithResourceBundle() {
 
         String expected = String.format("" +
                 "[picocli DEBUG] Creating CommandSpec for object of class picocli.I18nCommand with factory picocli.CommandLine$DefaultFactory%n" +
-                "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'i18n-top' (picocli.I18nCommand@2db0f6b2)%n" +
+                "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'i18n-top' (picocli.I18nCommand)%n" +
                 "[picocli DEBUG] Creating CommandSpec for object of class picocli.CommandLine$HelpCommand with factory picocli.CommandLine$DefaultFactory%n" +
                 "[picocli DEBUG] Adding subcommand 'help' to 'i18n-top'%n" +
                 "[picocli DEBUG] Created Messages from resourceBundle[base=picocli.SharedMessages] for command 'help' (picocli.CommandLine$HelpCommand)%n" +

File: src/test/java/picocli/test/CommandLineExecution.java
Patch:
@@ -63,11 +63,11 @@ protected boolean isAlive() {
         return alive;
     }
 
-    protected String getSystemOutString() {
+    public String getSystemOutString() {
         return this.out.toString();
     }
 
-    protected String getSystemErrString() {
+    public String getSystemErrString() {
         return this.err.toString();
     }
 

File: src/test/java/picocli/test/Execution.java
Patch:
@@ -63,8 +63,8 @@ public void setCustomizeErr(boolean customizeErr) {
     protected abstract void execute();
     protected abstract boolean isAlive();
     protected abstract int getExitCode();
-    protected abstract String getSystemOutString();
-    protected abstract String getSystemErrString();
+    public abstract String getSystemOutString();
+    public abstract String getSystemErrString();
 
     public static Builder builder(CommandLine commandLine) {
         return new Builder(commandLine);

File: src/test/java/picocli/test/ProcessExecution.java
Patch:
@@ -41,15 +41,15 @@ protected int getExitCode() {
         return process.exitValue();
     }
 
-    protected String getSystemOutString() {
+    public String getSystemOutString() {
         try {
             return readFully(process.getInputStream());
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
-    protected String getSystemErrString() {
+    public String getSystemErrString() {
         try {
             return readFully(process.getErrorStream());
         } catch (IOException e) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3901,11 +3901,12 @@ private static class NoCompletionCandidates implements Iterable<String> {
      * </p><p>
      * The {@code Mixin} annotation provides a way to reuse common options and parameters without subclassing. For example:
      * </p><pre>
+     * &#064;Command(name="HelloWorld")
      * class HelloWorld implements Runnable {
      *
      *     // adds the --help and --version options to this command
      *     &#064;Mixin
-     *     private HelpOptions = new HelpOptions();
+     *     private HelpOptions options = new HelpOptions();
      *
      *     &#064;Option(names = {"-u", "--userName"}, required = true, description = "The user name")
      *     String userName;

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -1259,7 +1259,7 @@ public void testGenerateCompletionScript() {
                 "# =======================\n" +
                 "#\n" +
                 "# Bash completion support for the `myapp` command,\n" +
-                "# generated by [picocli](http://picocli.info/) version 4.0.5-SNAPSHOT.\n" +
+                "# generated by [picocli](http://picocli.info/) version %s.\n" +
                 "#\n" +
                 "# Installation\n" +
                 "# ------------\n" +
@@ -1383,7 +1383,7 @@ public void testGenerateCompletionScript() {
                 "# The `-o default` option means that if the function generated no matches, the\n" +
                 "# default Bash completions and the Readline default filename completions are performed.\n" +
                 "complete -F _complete_myapp -o default myapp myapp.sh myapp.bash\n" +
-                "%n");
+                "\n", CommandLine.VERSION);
         cmd.execute("generate-completion");
         assertEquals(expected, sw.toString());
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -15469,6 +15469,7 @@ public PropertiesDefaultProvider(Properties properties) {
          */
         public PropertiesDefaultProvider(File file) {
             this(createProperties(file, null));
+            properties.remove("__picocli_internal_location");
             location = file;
         }
 
@@ -15514,7 +15515,7 @@ private static Properties loadProperties(CommandSpec commandSpec) {
         public String defaultValue(ArgSpec argSpec) throws Exception {
             if (properties == null) {
                 properties = loadProperties(argSpec.command());
-                location = properties == null ? null : (File) properties.get("__picocli_internal_location");
+                location = properties == null ? null : (File) properties.remove("__picocli_internal_location");
             }
             if (properties == null || properties.isEmpty()) {
                 return null;

File: picocli-examples/src/main/java/picocli/examples/defaultprovider/TwoPass.java
Patch:
@@ -34,7 +34,7 @@ static class FirstPass {
     @Command(name = "my-command", mixinStandardHelpOptions = true, version = "my-command 1.0",
             description = "Demonstrates a command that allows users to specify the location of a \"profile\" file with default values for the command line arguments")
     static class FinalPass implements Runnable {
-        @Option(names = "--profile", description = "...")
+        @Option(names = "--profile", description = "Path to the profile file. Default: ${DEFAULT-VALUE}")
         File profilePath = new File(System.getProperty("user.dir"), "my-command.properties");
 
         @Option(names = "-a", description = "...")

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5628,7 +5628,7 @@ private void check(ArgGroupSpec group, Set<ArgGroupSpec> existing) {
              * @param annotatedElement the `{@literal @}Mixin`-annotated program element
              * @return this CommandSpec for method chaining
              * @see #mixinAnnotatedElements()
-             * @since 5.0 */
+             * @since 4.1 */
             public CommandSpec addMixin(String name, CommandSpec mixin, IAnnotatedElement annotatedElement) {
                 CommandSpec result = addMixin(name, mixin);
                 mixinAnnotatedElements.put(interpolator.interpolate(name), annotatedElement);
@@ -5703,7 +5703,7 @@ void initParentCommand(Object parent) {
             /** Returns a map of the mixin names to mixin {@code IAnnotatedElement} objects for this command.
              * @return an immutable map of `{@literal @}Mixin`-annotated elements added to this command.
              * @see #addMixin(String, CommandSpec, IAnnotatedElement)
-             * @since 5.0 */
+             * @since 4.1 */
             public Map<String, IAnnotatedElement> mixinAnnotatedElements() { return Collections.unmodifiableMap(mixinAnnotatedElements); }
 
             /** Returns the list of options configured for this command.

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -873,7 +873,7 @@ private void connectModel(AbstractCommandSpecProcessor proc) {
                 CommandSpec mixee = mixinEntry.getKey();
                 for (MixinInfo mixinInfo : mixinEntry.getValue()) {
                     logger.fine(String.format("Adding mixin name=%s to %s", mixinInfo.mixinName(), mixee.name()));
-                    mixee.addMixin(mixinInfo.mixinName(), mixinInfo.mixin()/*, mixinInfo.annotatedElement()*/);
+                    mixee.addMixin(mixinInfo.mixinName(), mixinInfo.mixin(), mixinInfo.annotatedElement());
                 }
             }
 

File: picocli-annotation-processing-tests/src/test/java/picocli/annotation/processing/tests/AbstractCommandSpecProcessorTest.java
Patch:
@@ -246,8 +246,8 @@ public void testCommandWithBundle() {
     }
 
     private void assertOnlySourceVersionWarning(Compilation compilation) {
-        assertThat(compilation).hadWarningCount(1);
-        assertThat(compilation).hadWarningContaining("Supported source version 'RELEASE_6' from annotation processor 'picocli.annotation.processing.tests");
+        assertThat(compilation).hadWarningCount(0); // #826 version warnings are now suppressed
+        // assertThat(compilation).hadWarningContaining("Supported source version 'RELEASE_6' from annotation processor 'picocli.annotation.processing.tests");
     }
 
-}
\ No newline at end of file
+}

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -9202,6 +9202,7 @@ static TypedMember createIfAnnotated(Method method, IScope scope, CommandSpec sp
                 return isAnnotated(method) ? new TypedMember(method, scope, spec) : null;
             }
             private TypedMember(Method method, IScope scope, CommandSpec spec) {
+                this.scope = scope;
                 accessible = Assert.notNull(method, "method");
                 accessible.setAccessible(true);
                 name = propertyName(method.getName());
@@ -9231,6 +9232,7 @@ private TypedMember(Method method, IScope scope, CommandSpec spec) {
                 }
             }
             TypedMember(MethodParam param, IScope scope) {
+                this.scope = scope;
                 accessible = Assert.notNull(param, "command method parameter");
                 accessible.setAccessible(true);
                 name = param.getName();

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -11905,6 +11905,9 @@ private boolean isOption(String arg) {
             if (commandSpec.optionsMap().containsKey(arg)) { // -v or -f or --file (not attached to param or other option)
                 return true;
             }
+            if (commandSpec.subcommands().containsKey(arg)) {
+                return true;
+            }
             int separatorIndex = arg.indexOf(config().separator());
             if (separatorIndex > 0) { // -f=FILE or --file==FILE (attached to param via separator)
                 if (commandSpec.optionsMap().containsKey(arg.substring(0, separatorIndex))) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10741,6 +10741,9 @@ private StringBuilder toString(StringBuilder result) {
 
             void validate(CommandLine commandLine) {
                 validationResult = GroupValidationResult.SUCCESS_PRESENT; // we matched _something_ or this object would not exist...
+                if (group() != null && !group().validate()) {
+                    return;
+                }
                 for (GroupMatchContainer sub : matchedSubgroups.values()) {
                     sub.validate(commandLine);
                     if (sub.validationResult.blockingFailure()) {

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/TypeConverterMetaData.java
Patch:
@@ -46,7 +46,7 @@ public static TypeConverterMetaData[] extract(Element element) {
                         List<AnnotationValue> typeMirrors = (List<AnnotationValue>) list.getValue();
                         List<TypeConverterMetaData> result = new ArrayList<TypeConverterMetaData>();
                         for (AnnotationValue annotationValue : typeMirrors) {
-                            result.add(new TypeConverterMetaData((TypeMirror) annotationValue));
+                            result.add(new TypeConverterMetaData((TypeMirror) annotationValue.getValue()));
                         }
                         return result.toArray(new TypeConverterMetaData[0]);
                     }

File: picocli-annotation-processing-tests/src/test/java/picocli/annotation/processing/tests/Issue777Test.java
Patch:
@@ -31,8 +31,9 @@ public void testIssue777Composite() {
                         "/picocli/issue777/Exclusive.yaml",
                         "/picocli/issue777/Exclusive2.yaml",
                         "/picocli/issue777/Composite2.yaml",
-                        "/picocli/issue777/Composite.yaml",
-                        "/picocli/issue777/All.yaml"),
+                        "/picocli/issue777/All.yaml",
+                        "/picocli/issue777/Composite.yaml"
+                ),
                 JavaFileObjects.forResource("picocli/issue777/CompositeGroupDemo.java"));
 
         assertThat(compilation).succeeded();

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AnnotatedElementHolder.java
Patch:
@@ -59,6 +59,6 @@ public <T> T set(T value) {
      */
     @Override
     public String toString() {
-        return String.format("%s(%s %s)", getClass().getCanonicalName(), element.getKind(), element);
+        return String.format("%s(%s %s in %s)", getClass().getSimpleName(), element.getKind(), element, element.getEnclosingElement());
     }
 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -8338,7 +8338,7 @@ public static class ArgGroupSpec implements IOrdered {
 
                 args      = Collections.unmodifiableSet(new LinkedHashSet<ArgSpec>(builder.args()));
                 subgroups = Collections.unmodifiableList(new ArrayList<ArgGroupSpec>(builder.subgroups()));
-                if (args.isEmpty() && subgroups.isEmpty()) { throw new InitializationException("ArgGroup has no options or positional parameters, and no subgroups"); }
+                if (args.isEmpty() && subgroups.isEmpty()) { throw new InitializationException("ArgGroup has no options or positional parameters, and no subgroups: " + scope + " " + (getter == null ? setter : getter)); }
 
                 int i = 1;
                 for (ArgGroupSpec sub : subgroups) { sub.parentGroup = this; sub.id = id + "." + i++; }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5564,8 +5564,8 @@ public CommandSpec addMixin(String name, CommandSpec mixin) {
                 for (Map.Entry<String, CommandLine> entry : mixin.subcommands().entrySet()) {
                     addSubcommand(entry.getKey(), entry.getValue());
                 }
-                Set<OptionSpec> options = new HashSet<OptionSpec>(mixin.options());
-                Set<PositionalParamSpec> positionals = new HashSet<PositionalParamSpec>(mixin.positionalParameters());
+                Set<OptionSpec> options = new LinkedHashSet<OptionSpec>(mixin.options());
+                Set<PositionalParamSpec> positionals = new LinkedHashSet<PositionalParamSpec>(mixin.positionalParameters());
                 for (ArgGroupSpec argGroupSpec : mixin.argGroups()) {
                     Set<OptionSpec> groupOptions = new HashSet<OptionSpec>();
                     Set<PositionalParamSpec> groupPositionals = new HashSet<PositionalParamSpec>();

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/processor/NativeImageConfigGeneratorProcessor.java
Patch:
@@ -38,6 +38,8 @@ public class NativeImageConfigGeneratorProcessor extends AbstractCompositeGenera
      */
     public static final String OPTION_PROJECT = "project";
 
+    public NativeImageConfigGeneratorProcessor() {}
+
     @Override
     public synchronized void init(ProcessingEnvironment processingEnv) {
         super.init(processingEnv);

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -812,7 +812,7 @@ private void connectModel(AbstractCommandSpecProcessor proc) {
                     logger.fine("Building ArgGroupSpec for " + groups + " in arg group " + group);
                     group.addSubgroup(groups.getValue().build());
                 } else {
-                    CommandSpec commandSpec = commands.get(groups.getKey());
+                    CommandSpec commandSpec = commands.get(groups.getKey().getEnclosingElement());
                     if (commandSpec == null) {
                         proc.error(groups.getKey(), "@ArgGroups must be enclosed in a @Command or @ArgGroup-annotated element, but was %s: %s", groups.getKey().getEnclosingElement(), groups.getKey().getEnclosingElement().getSimpleName());
                     } else {

File: src/test/java/picocli/Issue776ArgGroupsIgnoredInMixinTest.java
Patch:
@@ -11,7 +11,7 @@
 import static org.junit.Assert.*;
 
 
-public class Issue776OptionHeadingIgnoredInMixinTest {
+public class Issue776ArgGroupsIgnoredInMixinTest {
 
     @Command(name = "test",
             description = "Picocli test.",
@@ -46,7 +46,6 @@ private static class A2 {
         }
     }
 
-    @Ignore
     @Test
     public void testUsage() {
         String expected = String.format("" +

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -151,6 +151,9 @@ private static String stacktrace(Exception e) {
     }
 
     private boolean tryProcess(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+
+        new AnnotationValidator(processingEnv).validateAnnotations(roundEnv);
+
         Context context = new Context();
         buildCommands(roundEnv, context);
         buildMixins(roundEnv, context);
@@ -162,11 +165,8 @@ private boolean tryProcess(Set<? extends TypeElement> annotations, RoundEnvironm
         buildUnmatched(roundEnv, context);
 
         context.connectModel(this);
-
         debugFoundAnnotations(annotations, roundEnv);
 
-        new AnnotationValidator(processingEnv).validateAnnotations(roundEnv);
-
         return handleCommands(context.commands, annotations, roundEnv);
     }
 

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -3968,6 +3968,7 @@ class App {
             @Parameters List<String> remainder;
         }
         App app = new App();
+        System.setProperty("picocli.ignore.invalid.split", "");
         CommandLine cmd = new CommandLine(app);
         cmd.getCommandSpec().parser().aritySatisfiedByAttachedOptionParam(true);
         cmd.parseArgs("-xa,b,c", "d", "e");

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -1433,7 +1433,7 @@ class ValSepC {
             @Option(names = "-b", arity="2", split=",") String[] b;
             @Option(names = "-c", arity="*", split=",") String[] c;
             @Option(names = "-d") boolean d;
-            @Option(names = "-e", arity="1", split=",") boolean e;
+            @Option(names = "-e", arity="1", split=",") boolean[] e;
             @Unmatched String[] remaining;
         }
         ValSepC val1 = parseCommonsCliCompatible(new ValSepC(), "-a 1 2 3 4".split(" "));
@@ -1458,11 +1458,11 @@ class ValSepC {
 
         ValSepC val7 = parseCommonsCliCompatible(new ValSepC(), "-d".split(" "));
         assertTrue(val7.d);
-        assertFalse(val7.e);
+        assertNull(val7.e);
 
         ValSepC val8 = parseCommonsCliCompatible(new ValSepC(), "-e true".split(" "));
         assertFalse(val8.d);
-        assertTrue(val8.e);
+        assertTrue(val8.e[0]);
     }
 
     @Test

File: src/test/java/picocli/InterpolatedModelTest.java
Patch:
@@ -160,7 +160,7 @@ class App {
                     split = "${sys:xsplit}",
                     descriptionKey = "${sys:xdescriptionKey}",
                     paramLabel = "${sys:paramLabel}"
-            ) int x;
+            ) int[] x;
         }
 
         System.setProperty("xname1", "-NAME1");
@@ -177,7 +177,7 @@ class App {
         String expected = String.format("" +
                 "Usage: cmd [-NAME1=PARAMLABEL[;;;PARAMLABEL...] PARAMLABEL[;;;PARAMLABEL...]%n" +
                 "           PARAMLABEL[;;;PARAMLABEL...] PARAMLABEL[;;;PARAMLABEL...]%n" +
-                "           [PARAMLABEL [PARAMLABEL]]]%n" +
+                "           [PARAMLABEL [PARAMLABEL]]]...%n" +
                 "      -NAME1, --NAME2=PARAMLABEL[;;;PARAMLABEL...] PARAMLABEL[;;;PARAMLABEL...]%n" +
                 "        PARAMLABEL[;;;PARAMLABEL...] PARAMLABEL[;;;PARAMLABEL...] [PARAMLABEL%n" +
                 "        [PARAMLABEL]]%n" +

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -2473,11 +2473,12 @@ public void testHelpCreateLayout_CreatesDefaultColumns() {
         Help help = new Help(CommandSpec.create(), new ColorScheme.Builder(Help.Ansi.OFF).build());
         Help.Layout layout = help.createDefaultLayout();
 
+        int[] widthsForNoOptions = {2, 2, 1, 3, 72};
         TextTable expected = TextTable.forDefaultColumns(Help.Ansi.OFF, 80);
         assertEquals(expected.columns().length, layout.table.columns().length);
         for (int i = 0; i < expected.columns().length; i++) {
             assertEquals(expected.columns()[i].indent, layout.table.columns()[i].indent);
-            assertEquals(expected.columns()[i].width, layout.table.columns()[i].width);
+            assertEquals(widthsForNoOptions[i], layout.table.columns()[i].width);
             assertEquals(expected.columns()[i].overflow, layout.table.columns()[i].overflow);
         }
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -10990,7 +10990,7 @@ private void processArguments(List<CommandLine> parsedCommands,
                 // Double-dash separates options from positional arguments.
                 // If found, then interpret the remaining args as positional parameters.
                 if (commandSpec.parser.endOfOptionsDelimiter().equals(arg)) {
-                    tracer.info("Found end-of-options delimiter '--'. Treating remainder as positional parameters.%n");
+                    tracer.info("Found end-of-options delimiter '%s'. Treating remainder as positional parameters.%n", commandSpec.parser.endOfOptionsDelimiter());
                     endOfOptions = true;
                     processRemainderAsPositionalParameters(required, initialized, args);
                     return; // we are done

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -2262,7 +2262,7 @@ static class DataSource {
     @Test
     // https://github.com/remkop/picocli/issues/746
     public void test746DefaultValue() {
-        TestUtil.setTraceLevel("DEBUG");
+        //TestUtil.setTraceLevel("DEBUG");
         CommandWithDefaultValue bean = new CommandWithDefaultValue();
         CommandLine cmd = new CommandLine(bean);
 

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -650,7 +650,7 @@ public void testBooleanOptionsArity0_nShortFormFailsIfAttachedParamNotABoolean()
             CommandLine.populateCommand(new BooleanOptionsArity0_nAndParameters(), "-rv234 -bool".split(" "));
             fail("Expected exception");
         } catch (UnmatchedArgumentException ok) {
-            assertEquals("Unknown option: -234 (while processing option: '-rv234')", ok.getMessage());
+            assertEquals("Unknown option: '-234' (while processing option: '-rv234')", ok.getMessage());
         }
     }
     @Test
@@ -1151,13 +1151,13 @@ class NonVarArgArrayParamsZeroArity {
             CommandLine.populateCommand(new NonVarArgArrayParamsZeroArity(), "a", "b", "c");
             fail("Expected UnmatchedArgumentException");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments: a, b, c", ex.getMessage());
+            assertEquals("Unmatched arguments from index 0: 'a', 'b', 'c'", ex.getMessage());
         }
         try {
             CommandLine.populateCommand(new NonVarArgArrayParamsZeroArity(), "a");
             fail("Expected UnmatchedArgumentException");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched argument: a", ex.getMessage());
+            assertEquals("Unmatched argument at index 0: 'a'", ex.getMessage());
         }
         NonVarArgArrayParamsZeroArity params = CommandLine.populateCommand(new NonVarArgArrayParamsZeroArity());
         assertEquals(null, params.params);

File: src/test/java/picocli/CommandLineCommandMethodTest.java
Patch:
@@ -504,7 +504,7 @@ public void testCompactFieldsAnyOrder_method() throws Exception {
             CommandLine.populateCommand(m, "-oout -r -vp1 p2".split(" "));
             fail("should fail: -v does not take an argument");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unknown option: -p1 (while processing option: '-vp1')", ex.getMessage());
+            assertEquals("Unknown option: '-p1' (while processing option: '-vp1')", ex.getMessage());
         }
     }
 
@@ -819,7 +819,7 @@ public void explicit(@Option(names = "-v") boolean v) {
     @Test
     public void testSubcommandMethodInvalidInputHandling() {
         String expected = String.format("" +
-                "Unknown option: -y%n" +
+                "Unknown option: '-y'%n" +
                 "Usage: maincommand subcommand [-x=<arg0>]%n" +
                 "  -x=<arg0>%n");
 

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -313,7 +313,7 @@ public void testMultiValueOptionArityAloneIsInsufficient() {
             commandLine.parseArgs("-c", "1", "2", "3");
             fail("Expected exception");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments: 2, 3", ex.getMessage());
+            assertEquals("Unmatched arguments from index 2: '2', '3'", ex.getMessage());
         }
     }
 
@@ -329,7 +329,7 @@ public void testMultiValuePositionalParamArityAloneIsInsufficient() {
             commandLine.parseArgs("1", "2", "3");
             fail("Expected exception");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments: 2, 3", ex.getMessage());
+            assertEquals("Unmatched arguments from index 1: '2', '3'", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/CommandLineParseWithHandlersTest.java
Patch:
@@ -480,7 +480,7 @@ static class MyRunnable implements Runnable {
             "  -x=<option>     this is an option%n");
 
     private static final String INVALID_INPUT = format("" +
-            "Unmatched argument: invalid input%n");
+            "Unmatched argument at index 0: 'invalid input'%n");
 
     private static final String MYCALLABLE_INVALID_INPUT = INVALID_INPUT + MYCALLABLE_USAGE;
 

File: src/test/java/picocli/CommandLineTypeConversionTest.java
Patch:
@@ -1038,7 +1038,7 @@ class App {
         try {
             CommandLine.populateCommand(new App(), "a:c", "1:3");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments: a:c, 1:3", ex.getMessage());
+            assertEquals("Unmatched arguments from index 0: 'a:c', '1:3'", ex.getMessage());
         }
     }
 
@@ -1050,7 +1050,7 @@ class App {
         try {
             CommandLine.populateCommand(new App(), "a:c", "1:3");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments: a:c, 1:3", ex.getMessage());
+            assertEquals("Unmatched arguments from index 0: 'a:c', '1:3'", ex.getMessage());
         }
     }
     enum ResultTypes {

File: src/test/java/picocli/ExecuteTest.java
Patch:
@@ -364,7 +364,7 @@ static class MyRunnable implements Runnable {
             "  -x=<option>     this is an option%n");
 
     private static final String INVALID_INPUT = format("" +
-            "Unmatched argument: invalid input%n");
+            "Unmatched argument at index 0: 'invalid input'%n");
 
     private static final String MYCALLABLE_INVALID_INPUT = INVALID_INPUT + MYCALLABLE_USAGE;
 

File: src/test/java/picocli/InteractiveArgTest.java
Patch:
@@ -622,7 +622,7 @@ class App {
                 cmd.parseArgs("-y", "456", "abc");
                 fail("Expect exception");
             } catch (UnmatchedArgumentException ex) {
-                assertEquals("Unknown option: -y", ex.getMessage());
+                assertEquals("Unknown option: '-y'", ex.getMessage());
             }
         } finally {
             System.setOut(out);
@@ -654,7 +654,7 @@ class App {
                 cmd.parseArgs("-y", "-w", "456", "abc");
                 fail("Expect exception");
             } catch (UnmatchedArgumentException ex) {
-                assertEquals("Unknown options: -y, -w", ex.getMessage());
+                assertEquals("Unknown options: '-y', '-w'", ex.getMessage());
             }
         } finally {
             System.setOut(out);

File: src/test/java/picocli/CompletionCandidatesTest.java
Patch:
@@ -196,7 +196,7 @@ class App {
                 "                           very, long, list, of, completion, candidates, that,%n" +
                 "                           is, intended, to, wrap, to, the, next, line., I,%n" +
                 "                           wonder, if, it, is, long, enough.%n" +
-                "      --logfile=<file>   Use given file for log. Default: \\a\\b\\c%n" +
+                "      --logfile=<file>   Use given file for log. Default: %s%n" +
                 "  -P=[<key=ppp>...]      Use value for project key.%n" +
                 "                         Default={key1=veryveryverylonglonglongvaluevaluevalue,%n" +
                 "                           key2=very2very2very2longlonglongvaluevaluevalue2,%n" +
@@ -206,7 +206,7 @@ class App {
                 "                           B, C, D%n" +
                 "      --y=<y>            Test long default. Default: This is a very long%n" +
                 "                           default value that is intended to wrap to the next%n" +
-                "                           line. I wonder if it is long enough.%n");
+                "                           line. I wonder if it is long enough.%n", new App().file);
         String actual = usageString(new CommandLine(new App(), new InnerClassFactory(this)), CommandLine.Help.Ansi.OFF);
         assertEquals(expected, actual);
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -37,6 +37,7 @@
 import java.text.SimpleDateFormat;
 import java.util.*;
 import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import picocli.CommandLine.Help.Ansi.IStyle;
@@ -13415,8 +13416,8 @@ public static TextTable forDefaultColumns(Ansi ansi, int longOptionsColumnWidth,
                         new Column(2,                                       0, TRUNCATE), // "*"
                         new Column(2,                                       0, SPAN), // "-c"
                         new Column(1,                                       0, TRUNCATE), // ","
-                        new Column(longOptionsColumnWidth,                         1, SPAN),  // " --create"
-                        new Column(usageHelpWidth - longOptionsColumnWidth, 1, WRAP)); // " Creates a ..."
+                        new Column(longOptionsColumnWidth,                  1, SPAN),  // " --create"
+                        new Column(usageHelpWidth - 5 - longOptionsColumnWidth, 1, WRAP)); // " Creates a ..."
             }
 
             /** Constructs a new TextTable with columns with the specified width, all SPANning  multiple columns on

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -2105,8 +2105,8 @@ class App {
         String expectedOutput =
                         "Usage: <main class> [--foo-bar-baz=<foo>]\n" +
                         "      --foo-bar-baz=<foo>     Default:\n" +
-                        "                              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n" +
-                        "                              aaaaaaaaaaaaaaaaaaaaaaaaaa\n";
+                        "                              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n" +
+                        "                              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n";
 
         assertEquals(expectedOutput, content);
     }

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -1643,11 +1643,12 @@ class App {
         }
 
         App app = new App();
-        new CommandLine(app).parseArgs("--", "a", "b");
+        CommandLine cmd = new CommandLine(app);
+        cmd.parseArgs("--", "a", "b");
         assertEquals(Arrays.asList("a", "b"), app.unmatchedList);
         assertArrayEquals(new String[]{"a", "b"}, app.unmatchedArray);
 
-        new CommandLine(app).parseArgs("--", "x", "y");
+        cmd.parseArgs("--", "x", "y");
         assertEquals(Arrays.asList("x", "y"), app.unmatchedList);
         assertArrayEquals(new String[]{"x", "y"}, app.unmatchedArray);
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -11251,7 +11251,7 @@ private boolean varargCanConsumeNextValue(ArgSpec argSpec, String nextValue) {
          */
         private boolean isOption(String arg) {
             if (arg == null)      { return false; }
-            if ("--".equals(arg)) { return true; }
+            if (commandSpec.parser().endOfOptionsDelimiter().equals(arg)) { return true; }
 
             // not just arg prefix: we may be in the middle of parsing -xrvfFILE
             if (commandSpec.optionsMap().containsKey(arg)) { // -v or -f or --file (not attached to param or other option)

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13169,7 +13169,7 @@ public static TextTable forDefaultColumns(Ansi ansi, int longOptionsColumnWidth,
                 return forColumns(ansi,
                         new Column(2,                                       0, TRUNCATE), // "*"
                         new Column(2,                                       0, SPAN), // "-c"
-                        new Column(1,                                       0, SPAN), // ","
+                        new Column(1,                                       0, TRUNCATE), // ","
                         new Column(longOptionsColumnWidth,                         1, SPAN),  // " --create"
                         new Column(usageHelpWidth - longOptionsColumnWidth, 1, WRAP)); // " Creates a ..."
             }

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -3851,6 +3851,7 @@ public void testInterpreterApplyValueToSingleValuedField() throws Exception {
         Class lookBehindClass = Class.forName("picocli.CommandLine$LookBehind");
         Method applyValueToSingleValuedField = c.getDeclaredMethod("applyValueToSingleValuedField",
                 ArgSpec.class,
+                boolean.class,
                 lookBehindClass,
                 Range.class,
                 Stack.class, Set.class, String.class);
@@ -3868,7 +3869,7 @@ public void testInterpreterApplyValueToSingleValuedField() throws Exception {
         Object SEPARATE = lookBehindClass.getDeclaredField("SEPARATE").get(null);
 
         int value = (Integer) applyValueToSingleValuedField.invoke(interpreter,
-                arg, SEPARATE, Range.valueOf("1"), new Stack<String>(), new HashSet<String>(), "");
+                arg, false, SEPARATE, Range.valueOf("1"), new Stack<String>(), new HashSet<String>(), "");
         assertEquals(0, value);
     }
 

File: picocli-codegen/src/main/java/picocli/codegen/util/Resources.java
Patch:
@@ -32,7 +32,9 @@ public static String slurp(String resource) {
 
     public static String slurp(InputStream in) {
         Scanner s = new Scanner(in).useDelimiter("\\A");
-        return s.hasNext() ? s.next() : "";
+        return s.hasNext()
+                ? s.next().replaceAll("\r\n", "\n").replaceAll("\n", System.getProperty("line.separator"))
+                : "";
     }
 
     private Resources() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4854,7 +4854,7 @@ private String validateSubcommandName(String name, CommandSpec subSpec) {
             }
 
             private void initCommandHierarchyWithResourceBundle(String bundleBaseName, ResourceBundle rb) {
-                if (resourceBundle() == null) {
+                if (resourceBundle() == null && resourceBundleBaseName() == null) {
                     setBundle(bundleBaseName, rb);
                 }
                 for (CommandLine sub : commands.values()) { // percolate down the hierarchy
@@ -6079,7 +6079,7 @@ void initFromMixin(UsageMessageSpec mixin, CommandSpec commandSpec) {
                 if (initializable(footerHeading, mixin.footerHeading(), DEFAULT_SINGLE_VALUE))                         {footerHeading = mixin.footerHeading();}
                 if (initializable(parameterListHeading, mixin.parameterListHeading(), DEFAULT_SINGLE_VALUE))           {parameterListHeading = mixin.parameterListHeading();}
                 if (initializable(optionListHeading, mixin.optionListHeading(), DEFAULT_SINGLE_VALUE))                 {optionListHeading = mixin.optionListHeading();}
-                if (Messages.empty(messages)) { messages(Messages.copy(commandSpec, mixin.messages())); }
+                if (Messages.empty(messages) && Messages.resourceBundleBaseName(messages) == null) { messages(Messages.copy(commandSpec, mixin.messages())); }
                 if (initializable(adjustLineBreaksForWideCJKCharacters, mixin.adjustLineBreaksForWideCJKCharacters(), DEFAULT_ADJUST_CJK)) {adjustLineBreaksForWideCJKCharacters = mixin.adjustLineBreaksForWideCJKCharacters();}
             }
             void initFrom(UsageMessageSpec settings, CommandSpec commandSpec) {

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -415,6 +415,7 @@ private void buildArgGroup(Element element, Context context) {
             error(element, "@ArgGroup must have a declared or array type, not %s", element.asType());
             return;
         }
+        @SuppressWarnings("deprecation") // SimpleElementVisitor6 is deprecated in Java 9
         ArgGroupSpec.Builder builder = element.accept(new SimpleElementVisitor6<ArgGroupSpec.Builder, Void>(null) {
             @Override public ArgGroupSpec.Builder visitVariable(VariableElement e, Void aVoid) {
                 return ArgGroupSpec.builder(new TypedMember(e, -1));
@@ -597,6 +598,7 @@ private void buildParentCommand(Element element, Context context) {
         }
     }
 
+    @SuppressWarnings("deprecation") // SimpleElementVisitor6 is deprecated in Java 9
     private IAnnotatedElement buildTypedMember(Element element) {
         return element.accept(new SimpleElementVisitor6<TypedMember, Void>(null) {
             @Override

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ReflectionConfigGenerator.java
Patch:
@@ -232,6 +232,7 @@ void visitCommandSpec(CommandSpec spec) throws Exception {
             }
         }
 
+        @SuppressWarnings("deprecation") // SimpleElementVisitor6 is deprecated in Java 9
         private void visitElement(Element element) {
             element.accept(new SimpleElementVisitor6<Void, Void>() {
                 @Override
@@ -287,6 +288,7 @@ public Void visitDeclared(DeclaredType t, List<String> collect) {
         // convert canonical type names (picocli.AutoComplete.App) to class name (picocli.AutoComplete$App)
         // convert generic (java.util.List<java.io.File>) to raw (java.util.List)
         private String elementTypeName(TypeMirror typeMirror) {
+            @SuppressWarnings("deprecation") // SimpleElementVisitor6 is deprecated in Java 9
             String result = typeMirror.accept(new SimpleTypeVisitor6<String, Void>() {
                 @Override
                 public String visitDeclared(DeclaredType declaredType, Void aVoid) {

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -2274,10 +2274,10 @@ class App {
         assertEquals(new File("/path/to/file"), app.d.get(0));
 
         assertEquals(app.e.size(), 1);
-        assertEquals(new Long(67890), app.e.get(12345));
+        assertEquals(Long.valueOf(67890), app.e.get(12345));
 
         assertEquals(app.f.size(), 1);
-        assertEquals(67.89f, app.f.get(new Long(12345)));
+        assertEquals(67.89f, app.f.get(Long.valueOf(12345)));
 
         assertEquals(app.g.size(), 1);
         assertEquals(12.34f, app.g.get(TimeUnit.MILLISECONDS));

File: src/test/java/picocli/InnerClassFactory.java
Patch:
@@ -56,7 +56,9 @@ public <K> K create(final Class<K> cls) throws Exception {
                 return constructor.newInstance(outer);
             } catch (Exception ex) {
                 try {
-                    return cls.newInstance();
+                    @SuppressWarnings("deprecation") // Class.newInstance is deprecated in Java 9
+                    K result = cls.newInstance();
+                    return result;
                 } catch (Exception ex2) {
                     try {
                         Constructor<K> constructor = cls.getDeclaredConstructor();

File: picocli-annotation-processing-tests/src/test/java/picocli/annotation/processing/tests/ReflectionConfigGeneratorProcessorTest.java
Patch:
@@ -32,7 +32,7 @@ public void generateExampleFullJava8Api() {
     }
 
     @Test
-    public void generate() {
+    public void generateNestedWithSubcommands() {
         ReflectionConfigGeneratorProcessor processor = new ReflectionConfigGeneratorProcessor();
         Compilation compilation =
                 javac()

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AnnotationValidator.java
Patch:
@@ -18,6 +18,7 @@
 
 public class AnnotationValidator {
 
+    @SuppressWarnings("unchecked")
     private static final List<Class<? extends Annotation>> ALL = Collections.unmodifiableList(
             Arrays.asList(
                     CommandLine.Command.class,

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4223,6 +4223,7 @@ public Help create(CommandSpec commandSpec, Help.ColorScheme colorScheme) {
      * @see picocli.CommandLine#CommandLine(Object, IFactory)
      * @see #call(Class, IFactory, PrintStream, PrintStream, Help.Ansi, String...)
      * @see #run(Class, IFactory, PrintStream, PrintStream, Help.Ansi, String...)
+     * @see #defaultFactory()
      * @since 2.2 */
     public interface IFactory {
         /**

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -13300,7 +13300,9 @@ static boolean ansiPossible() {
             }
             static boolean isJansiConsoleInstalled() {
                 try {
-                    Object wrapped = FilterOutputStream.class.getDeclaredField("out").get(System.out);
+                    Field f = FilterOutputStream.class.getDeclaredField("out");
+                    f.setAccessible(true);
+                    Object wrapped = f.get(System.out);
                     return wrapped.getClass().getName().startsWith("org.fusesource.jansi");
                 } catch (Exception reflectionFailed) {
                     return false;

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4194,8 +4194,9 @@ public interface IFactory {
          */
         <K> K create(Class<K> cls) throws Exception;
     }
-    /** Returns a default {@link IFactory} implementation. Package-protected for testing purposes. */
-    static IFactory defaultFactory() { return new DefaultFactory(); }
+    /** Returns the default {@link IFactory} implementation used if no factory was specified in the {@link #CommandLine(Object) CommandLine constructor}.
+     * @since 4.0 */
+    public static IFactory defaultFactory() { return new DefaultFactory(); }
     private static class DefaultFactory implements IFactory {
         public <T> T create(Class<T> cls) throws Exception {
             if (cls.isInterface() && Collection.class.isAssignableFrom(cls)) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4495,7 +4495,7 @@ public static interface ISetter {
          * </p>
          * @since 3.0 */
         public static class CommandSpec {
-            /** Constant String holding the default program name: {@code "&lt;main class&gt;" }. */
+            /** Constant String holding the default program name: {@code "<main class>" }. */
             static final String DEFAULT_COMMAND_NAME = "<main class>";
 
             /** Constant Boolean holding the default setting for whether this is a help command: <code>{@value}</code>.*/
@@ -4734,10 +4734,10 @@ private void initCommandHierarchyWithResourceBundle(String bundleBaseName, Resou
              * @since 4.0 */
             public CommandSpec setAddMethodSubcommands(Boolean addMethodSubcommands) { isAddMethodSubcommands = addMethodSubcommands; return this; }
 
-            /** Returns whether whether variables should be interpolated in String values. {@value #DEFAULT_COMMAND_NAME} by default.
+            /** Returns whether whether variables should be interpolated in String values. {@value #DEFAULT_INTERPOLATE_VARIABLES} by default.
              * @since 4.0 */
             public boolean interpolateVariables() { return (interpolateVariables == null) ? DEFAULT_INTERPOLATE_VARIABLES : interpolateVariables; }
-            /** Sets whether whether variables should be interpolated in String values. {@value #DEFAULT_COMMAND_NAME} by default.
+            /** Sets whether whether variables should be interpolated in String values. {@value #DEFAULT_INTERPOLATE_VARIABLES} by default.
              * @since 4.0 */
             public CommandSpec interpolateVariables(Boolean interpolate) { interpolateVariables = interpolate; return this; }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4727,10 +4727,10 @@ private void initCommandHierarchyWithResourceBundle(String bundleBaseName, Resou
                 }
             }
 
-            /** Returns whether method commands should be added as subcommands. {@value #DEFAULT_IS_ADD_METHOD_SUBCOMMANDS} by default. Used by the annotation processor.
+            /** Returns whether method commands should be added as subcommands. True by default. Used by the annotation processor.
              * @since 4.0 */
             public boolean isAddMethodSubcommands() { return (isAddMethodSubcommands == null) ? DEFAULT_IS_ADD_METHOD_SUBCOMMANDS : isAddMethodSubcommands; }
-            /** Sets whether method commands should be added as subcommands. {@value #DEFAULT_IS_ADD_METHOD_SUBCOMMANDS} by default. Used by the annotation processor.
+            /** Sets whether method commands should be added as subcommands. True by default. Used by the annotation processor.
              * @since 4.0 */
             public CommandSpec setAddMethodSubcommands(Boolean addMethodSubcommands) { isAddMethodSubcommands = addMethodSubcommands; return this; }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1257,6 +1257,7 @@ protected R throwOrExit(ExecutionException ex) {
             if (hasExitCode()) {
                 ex.printStackTrace(this.err());
                 exit(exitCode());
+                return null;
             }
             throw ex;
         }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -167,7 +167,7 @@ public int handleExecutionException(ExecutionException ex, ParseResult parseResu
             Throwable cause = ex.getCause() == null ? ex : ex.getCause();
             if (cause instanceof Exception) { throw (Exception) cause; }
             if (cause instanceof Error)     { throw (Error)     cause; }
-            return ex.getCommandLine().getCommandSpec().exitCodeOnExecutionException;
+            throw ex;
         }
     };
 

File: src/test/java/picocli/CommandLineCommandMethodTest.java
Patch:
@@ -928,7 +928,7 @@ public void testCommandMethodsRequireNonArgConstructor() {
         try {
             CommandLine.invoke("cannotBeCalled", StaticMethodCommand.class);
         } catch (ExecutionException ex) {
-            assertTrue(ex.getCause() instanceof UnsupportedOperationException);
+            assertTrue(ex.getCause() instanceof NoSuchMethodException);
         }
     }
 

File: picocli-codegen/src/main/java/picocli/codegen/annotation/processing/AbstractCommandSpecProcessor.java
Patch:
@@ -1002,6 +1002,7 @@ private TypedMember(ExecutableElement method) {
         public boolean isUnmatched()    { return isAnnotationPresent(Unmatched.class); }
         public boolean isInjectSpec()   { return isAnnotationPresent(Spec.class); }
         public boolean isMultiValue()   { return getTypeInfo().isMultiValue(); }
+        public boolean isInteractive()  { return (isOption() && getAnnotation(Option.class).interactive()) || (isParameter() && getAnnotation(Parameters.class).interactive()); }
         public ITypeInfo getTypeInfo()  { return typeInfo; }
         public CommandLine.Model.IGetter getter()         { return getter; }
         public CommandLine.Model.ISetter setter()         { return setter; }

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -1945,7 +1945,8 @@ static class Inner {
         }
     }
 
-    @Test
+    @Ignore
+    @Test // https://github.com/remkop/picocli/issues/655
     public void testCompositeValidation() {
         TestComposite app = new TestComposite();
         CommandLine cmd = new CommandLine(app);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5329,7 +5329,7 @@ public String[] renderedDescription()  {
                 String defaultValueString = defaultValueString();
                 String[] result = new String[desc.length];
                 for (int i = 0; i < desc.length; i++) {
-                    result[i] = format(desc[i].replace(DESCRIPTION_VARIABLE_DEFAULT_VALUE, defaultValueString)
+                    result[i] = format(desc[i].replace(DESCRIPTION_VARIABLE_DEFAULT_VALUE, defaultValueString.replace("%", "%%"))
                             .replace(DESCRIPTION_VARIABLE_COMPLETION_CANDIDATES, candidates.toString()));
                 }
                 return result;

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -650,7 +650,7 @@ public void testBooleanOptionsArity0_nShortFormFailsIfAttachedParamNotABoolean()
             CommandLine.populateCommand(new BooleanOptionsArity0_nAndParameters(), "-rv234 -bool".split(" "));
             fail("Expected exception");
         } catch (UnmatchedArgumentException ok) {
-            assertEquals("Unknown option: -234", ok.getMessage());
+            assertEquals("Unknown option: -234 (while processing option: '-rv234')", ok.getMessage());
         }
     }
     @Test

File: src/test/java/picocli/CommandLineCommandMethodTest.java
Patch:
@@ -501,7 +501,7 @@ public void testCompactFieldsAnyOrder_method() throws Exception {
             CommandLine.populateCommand(m, "-oout -r -vp1 p2".split(" "));
             fail("should fail: -v does not take an argument");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unknown option: -p1", ex.getMessage());
+            assertEquals("Unknown option: -p1 (while processing option: '-vp1')", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -589,7 +589,7 @@ public void testCompactFieldsAnyOrder() {
             CommandLine.populateCommand(new CompactFields(), "-oout -r -vp1 p2".split(" "));
             fail("should fail: -v does not take an argument");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unknown option: -p1", ex.getMessage());
+            assertEquals("Unknown option: -p1 (while processing option: '-vp1')", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/LenientParsingTest.java
Patch:
@@ -195,7 +195,7 @@ public void testBooleanOptionsArity0_nShortFormFailsIfAttachedParamNotABoolean()
         cmd.getCommandSpec().parser().collectErrors(true);
         cmd.parse("-rv234 -bool".split(" "));
         assertEquals(1, cmd.getParseResult().errors().size());
-        assertEquals("Unknown option: -234", cmd.getParseResult().errors().get(0).getMessage());
+        assertEquals("Unknown option: -234 (while processing option: '-rv234')", cmd.getParseResult().errors().get(0).getMessage());
     }
 
     @Test

File: src/test/java/picocli/ArgGroupTest.java
Patch:
@@ -708,7 +708,7 @@ public void testValidationRequiredNonExclusive_Zero() {
             group.validateConstraints(cmd, Collections.<ArgSpec>emptyList());
             fail("Expected exception");
         } catch (MissingParameterException ex) {
-            assertEquals("Error: Missing required argument(s): -a, -c, -b", ex.getMessage());
+            assertEquals("Error: Missing required argument(s): -a, -b, -c", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -271,7 +271,7 @@ public void testVersionHelp_helpCommand() {
         CommandSpec helpCommand = CommandSpec.create().helpCommand(true);
         assertTrue(helpCommand.helpCommand());
 
-        CommandSpec parent = CommandSpec.create().addOption(OptionSpec.builder("-x").required(true).build());
+        CommandSpec parent = CommandSpec.create().addOption(OptionSpec.builder("-x").type(String.class).required(true).build());
         parent.addSubcommand("help", helpCommand);
 
         CommandLine commandLine = new CommandLine(parent);

File: src/test/java/picocli/LenientParsingTest.java
Patch:
@@ -135,7 +135,7 @@ class Tricky3 {
 
         cmd.parse(new String[] {"-t"});
         assertEquals(3, cmd.getParseResult().errors().size());
-        assertEquals("Missing required options [-v=<more>, params[0]=<mandatory>, params[1]=<alsoMandatory>]", cmd.getParseResult().errors().get(0).getMessage());
+        assertEquals("Missing required options [-v, params[0]=<mandatory>, params[1]=<alsoMandatory>]", cmd.getParseResult().errors().get(0).getMessage());
         assertEquals("Missing required parameters: <mandatory>, <alsoMandatory>", cmd.getParseResult().errors().get(1).getMessage());
         assertEquals("Missing required parameter: <alsoMandatory>", cmd.getParseResult().errors().get(2).getMessage());
     }

File: picocli-codegen/src/main/java/picocli/codegen/aot/graalvm/ReflectionConfigGenerator.java
Patch:
@@ -287,8 +287,10 @@ private void visitSetter(ISetter setter) throws NoSuchFieldException, IllegalAcc
 
         private void visitFieldBinding(Object fieldBinding) throws IllegalAccessException, NoSuchFieldException {
             Field field = (Field) accessibleField(fieldBinding.getClass(), REFLECTED_FIELD_BINDING_FIELD).get(fieldBinding);
+            getOrCreateClass(field.getDeclaringClass()).addField(field.getName());
+
             Object scope = accessibleField(fieldBinding.getClass(), REFLECTED_BINDING_FIELD_SCOPE).get(fieldBinding);
-            getOrCreateClass(scope.getClass()).addField(field.getName());
+            getOrCreateClass(scope.getClass());
         }
 
         private void visitMethodBinding(Object methodBinding) throws IllegalAccessException, NoSuchFieldException {

File: picocli-codegen/src/test/java/picocli/codegen/aot/graalvm/Example.java
Patch:
@@ -41,7 +41,7 @@ public class Example implements Runnable {
     List<String> unmatched;
 
     private int minimum;
-    private File[] otherFiles;
+    private List<File> otherFiles;
 
     @Command
     int multiply(@Option(names = "--count") int count,
@@ -59,7 +59,7 @@ public void setMinimum(int min) {
     }
 
     @Parameters(index = "1..*")
-    public void setOtherFiles(File[] otherFiles) {
+    public void setOtherFiles(List<File> otherFiles) {
         for (File f : otherFiles) {
             if (!f.exists()) {
                 throw new ParameterException(spec.commandLine(), "File " + f.getAbsolutePath() + " must exist");
@@ -70,7 +70,7 @@ public void setOtherFiles(File[] otherFiles) {
 
     public void run() {
         System.out.printf("timeUnit=%s, length=%s, file=%s, unmatched=%s, minimum=%s, otherFiles=%s%n",
-                timeUnit, mixin.length, file, unmatched, minimum, Arrays.toString(otherFiles));
+                timeUnit, mixin.length, file, unmatched, minimum, otherFiles);
     }
 
     public static void main(String[] args) {

File: src/test/java/picocli/ModelCommandReflectionTest.java
Patch:
@@ -89,7 +89,7 @@ public void testValidateMixin() throws Exception {
     @Test
     public void testValidateUnmatched() throws Exception {
         Class<?> reflection = Class.forName("picocli.CommandLine$Model$CommandReflection");
-        Method validateUnmatched = reflection.getDeclaredMethod("validateUnmatched", CommandLine.Model.TypedMember.class);
+        Method validateUnmatched = reflection.getDeclaredMethod("validateUnmatched", CommandLine.Model.IAnnotatedElement.class);
         validateUnmatched.setAccessible(true);
 
         CommandLine.Model.TypedMember typedMember = new CommandLine.Model.TypedMember(TypedMemberObj.class.getDeclaredField("x"));

File: src/test/java/picocli/ModelTestUtil.java
Patch:
@@ -33,7 +33,7 @@ public static OptionSpec option(Object obj, String fieldName) throws Exception {
         return option(obj, fieldName, CommandLine.defaultFactory());
     }
     public static OptionSpec option(Object obj, String fieldName, CommandLine.IFactory factory) throws Exception {
-        return ArgsReflection.extractOptionSpec(TypedMember.createIfAnnotated(obj.getClass().getDeclaredField(fieldName), obj), factory);
+        return OptionSpec.builder(TypedMember.createIfAnnotated(obj.getClass().getDeclaredField(fieldName), obj), factory).build();
     }
     public static OptionSpec[] options(Object obj, String... fieldNames) throws Exception {
         OptionSpec[] result = new OptionSpec[fieldNames.length];

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -8703,7 +8703,8 @@ protected Text createDetailedSynopsisOptionsText(Comparator<OptionSpec> optionSo
                 StringBuilder clusteredOptional = new StringBuilder("-");
                 for (OptionSpec option : options) {
                     if (option.hidden()) { continue; }
-                    if (option.type() == boolean.class || option.type() == Boolean.class) {
+                    boolean isFlagOption = option.type() == boolean.class || option.type() == Boolean.class;
+                    if (isFlagOption && option.arity().max <= 0) { // #612 consider arity: boolean options may require a parameter
                         String shortestName = option.shortestName();
                         if (shortestName.length() == 2 && shortestName.startsWith("-")) {
                             booleanOptions.add(option);

File: src/test/java/picocli/CommandLineTypeConversionTest.java
Patch:
@@ -524,7 +524,7 @@ public void testCharsetConvertersInvalidError() {
     }
     @Test
     public void testInetAddressConvertersInvalidError() {
-        parseInvalidValue("-InetAddress", "%$::a?*!a", "java.net.UnknownHostException: %$::a?*!a");
+        parseInvalidValue("-InetAddress", "%$::a?*!a", "java.net.UnknownHostException: ");
     }
     @Test
     public void testUUIDConvertersInvalidError() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -7953,7 +7953,7 @@ private void updateHelpRequested(CommandSpec command) {
             isHelpRequested |= command.helpCommand();
         }
         private void updateHelpRequested(ArgSpec argSpec) {
-            if (argSpec.isOption()) {
+            if (!parseResult.isInitializingDefaultValues && argSpec.isOption()) {
                 OptionSpec option = (OptionSpec) argSpec;
                 isHelpRequested                  |= is(argSpec, "help", option.help());
                 parseResult.versionHelpRequested |= is(argSpec, "versionHelp", option.versionHelp());

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -137,7 +137,7 @@ public Integer call() {
                 }
                 Class<?> cls = Class.forName(commandLineFQCN);
                 Object instance = factory.create(cls);
-                CommandLine commandLine = new CommandLine(instance);
+                CommandLine commandLine = new CommandLine(instance, factory);
 
                 if (commandName == null) {
                     commandName = commandLine.getCommandName(); //new CommandLine.Help(commandLine.commandDescriptor).commandName;

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -408,7 +408,7 @@ private String expectedCompletionScriptForAutoCompleteApp() {
                 "# =======================\n" +
                 "#\n" +
                 "# Bash completion support for the `picocli.AutoComplete` command,\n" +
-                "# generated by [picocli](http://picocli.info/) version 4.0.0-SNAPSHOT.\n" +
+                "# generated by [picocli](http://picocli.info/) version 3.9.1-SNAPSHOT.\n" +
                 "#\n" +
                 "# Installation\n" +
                 "# ------------\n" +
@@ -573,7 +573,7 @@ private String expectedCompletionScriptForNonDefault() {
                 "# =======================\n" +
                 "#\n" +
                 "# Bash completion support for the `nondefault` command,\n" +
-                "# generated by [picocli](http://picocli.info/) version 4.0.0-SNAPSHOT.\n" +
+                "# generated by [picocli](http://picocli.info/) version 3.9.1-SNAPSHOT.\n" +
                 "#\n" +
                 "# Installation\n" +
                 "# ------------\n" +

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -146,7 +146,7 @@ class App { }
     }
     @Test
     public void testVersion() {
-        assertEquals("4.0.0-SNAPSHOT", CommandLine.VERSION);
+        assertEquals("3.9.1-SNAPSHOT", CommandLine.VERSION);
     }
     @Test
     public void testArrayPositionalParametersAreReplacedNotAppendedTo() {

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -584,7 +584,7 @@ public void testBooleanOptionsArity0_nTrue() {
         BooleanOptionsArity0_nAndParameters
                 params = CommandLine.populateCommand(new BooleanOptionsArity0_nAndParameters(), "-bool true".split(" "));
         assertTrue(params.bool);
-        assertArrayEquals(new String[0], params.params);
+        assertNull(params.params);
     }
 
     @Test

File: src/test/java/picocli/CommandLineTypeConversionTest.java
Patch:
@@ -429,6 +429,7 @@ public void testISO8601TimeConverterExceptionHandling() throws Exception {
         Field fqcn = c.getDeclaredField("FQCN");
         fqcn.setAccessible(true);
 
+        Object original = fqcn.get(null);
         fqcn.set(null, "a.b.c"); // change FQCN to an unknown class
         assertEquals("a.b.c", fqcn.get(null));
 
@@ -438,6 +439,8 @@ public void testISO8601TimeConverterExceptionHandling() throws Exception {
         } catch (InvocationTargetException outer) {
             TypeConversionException ex = (TypeConversionException) outer.getTargetException();
             assertTrue(ex.getMessage().startsWith("Unable to create new java.sql.Time with long value " + now));
+        } finally {
+            fqcn.set(null, original); // change FQCN back to java.sql.Time for other tests
         }
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -8150,7 +8150,7 @@ public Date convert(String value) {
          * {@code HH:mm:ss.SSS}, {@code HH:mm:ss,SSS}. Other formats result in a ParameterException. */
         static class ISO8601TimeConverter implements ITypeConverter<Object> {
             // Implementation note: use reflection so that picocli only requires the java.base module in Java 9.
-            private static final String FQCN = "java.sql.Time";
+            private static /*final*/ String FQCN = "java.sql.Time"; // non-final for testing
             public Object convert(String value) {
                 try {
                     if (value.length() <= 5) {

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -840,7 +840,7 @@ public void testDebugOutputForDoubleDashSeparatesPositionalParameters() throws E
                         "[picocli INFO] Picocli version: %3$s%n" +
                         "[picocli INFO] Parsing 6 command line args [-oout, --, -r, -v, p1, p2]%n" +
                         "[picocli DEBUG] Parser configuration: posixClusteredShortOptionsAllowed=true, stopAtPositional=false, stopAtUnmatched=false, separator=null, overwrittenOptionsAllowed=false, unmatchedArgumentsAllowed=false, expandAtFiles=true, atFileCommentChar=#, endOfOptionsDelimiter=--, limitSplit=false, aritySatisfiedByAttachedOptionParam=false, toggleBooleanFlags=true, unmatchedOptionsArePositionalParams=false, collectErrors=false,caseInsensitiveEnumValuesAllowed=false, trimQuotes=false, splitQuotedStrings=false%n" +
-                        "[picocli DEBUG] (ANSI is disabled by default: TTY=...)%n" +
+                        "[picocli DEBUG] (ANSI is disabled by default: isatty=...)%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.CommandLineTest$CompactFields.verbose of type boolean to false.%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.CommandLineTest$CompactFields.recursive of type boolean to false.%n" +
                         "[picocli DEBUG] Set initial value for field java.io.File picocli.CommandLineTest$CompactFields.outputFile of type class java.io.File to null.%n" +
@@ -1733,7 +1733,7 @@ public void testTracingDebugWithSubCommands() throws Exception {
                         "[picocli INFO] Picocli version: %3$s%n" +
                         "[picocli INFO] Parsing 8 command line args [--git-dir=/home/rpopma/picocli, commit, -m, \"Fixed typos\", --, src1.java, src2.java, src3.java]%n" +
                         "[picocli DEBUG] Parser configuration: posixClusteredShortOptionsAllowed=true, stopAtPositional=false, stopAtUnmatched=false, separator=null, overwrittenOptionsAllowed=false, unmatchedArgumentsAllowed=false, expandAtFiles=true, atFileCommentChar=#, endOfOptionsDelimiter=--, limitSplit=false, aritySatisfiedByAttachedOptionParam=false, toggleBooleanFlags=true, unmatchedOptionsArePositionalParams=false, collectErrors=false,caseInsensitiveEnumValuesAllowed=false, trimQuotes=false, splitQuotedStrings=false%n" +
-                        "[picocli DEBUG] (ANSI is disabled by default: TTY=...)%n" +
+                        "[picocli DEBUG] (ANSI is disabled by default: isatty=...)%n" +
                         "[picocli DEBUG] Set initial value for field java.io.File picocli.Demo$Git.gitDir of type class java.io.File to null.%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.CommandLine$AutoHelpMixin.helpRequested of type boolean to false.%n" +
                         "[picocli DEBUG] Set initial value for field boolean picocli.CommandLine$AutoHelpMixin.versionRequested of type boolean to false.%n" +

File: src/test/java/picocli/PicocliTestUtil.java
Patch:
@@ -29,7 +29,7 @@ public static String stripAnsiTrace(String original) {
     }
 
     private static String stripAnsiTraceOnce(String original) {
-        String prefix = "(ANSI is disabled by default: TTY=";
+        String prefix = "(ANSI is disabled by default: isatty=";
         int pos = original.indexOf(prefix);
         if (pos > 0) {
             int to = original.indexOf(")", pos);

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -249,7 +249,7 @@ public void testAutoCompleteAppCompletionScriptFileWillNotOverwrite() throws Exc
         AutoComplete.main(String.format("-o=%s", completionScript.getAbsolutePath()), "picocli.AutoComplete$App");
 
         String expected = String.format("" +
-                "%s exists. Specify -f to overwrite.%n" +
+                "ERROR: picocli.AutoComplete: %s exists. Specify --force to overwrite.%n" +
                 "%s", completionScript.getAbsolutePath(), AUTO_COMPLETE_APP_USAGE);
         assertEquals(expected, systemErrRule.getLog());
     }
@@ -269,7 +269,7 @@ public void testAutoCompleteAppCommandScriptFileWillNotOverwrite() throws Except
         AutoComplete.main("--writeCommandScript", String.format("-o=%s", completionScript.getAbsolutePath()), "picocli.AutoComplete$App");
 
         String expected = String.format("" +
-                "%s exists. Specify -f to overwrite.%n" +
+                "ERROR: picocli.AutoComplete: %s exists. Specify --force to overwrite.%n" +
                 "%s", commandScript.getAbsolutePath(), AUTO_COMPLETE_APP_USAGE);
         assertEquals(expected, systemErrRule.getLog());
     }

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -3694,7 +3694,7 @@ class App {
         cli.setTrimQuotes(true);
         cli.parse("@" + file.getAbsolutePath());
         assertEquals("something else", app.quoted);
-        assertEquals("https://picocli.info/", app.url);
+        assertEquals("https://picocli.info/", app.url.toString());
         assertEquals("C:\\Program Files\\picocli.txt", app.unescaped);
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -9240,7 +9240,7 @@ private int copy(BreakIterator line, Text text, Text columnValue, int offset) {
                         break;
                     }
                 }
-                if (done == 0 && length(text) > columnValue.maxLength) {
+                if (done == 0 && length(text) + offset > columnValue.maxLength) {
                     // The value is a single word that is too big to be written to the column. Write as much as we can.
                     done = copy(text, columnValue, offset);
                 }

File: picocli-examples/src/main/java/picocli/examples/subcommands/ParentCommandDemo.java
Patch:
@@ -42,7 +42,6 @@ static class List implements Runnable {
         @Option(names = {"-r", "--recursive"}, description = "Recursively list subdirectories")
         private boolean recursive;
 
-        @Override
         public void run() {
             list(new File(parent.baseDirectory, "."));
         }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4518,9 +4518,9 @@ private <T extends Builder<T>> ArgSpec(Builder<T> builder) {
                 } else {
                     auxiliaryTypes = builder.auxiliaryTypes;
                 }
-                if (builder.completionCandidates == null && type.isEnum()) {
+                if (builder.completionCandidates == null && auxiliaryTypes[0].isEnum()) {
                     List<String> list = new ArrayList<String>();
-                    for (Object c : type.getEnumConstants()) { list.add(c.toString()); }
+                    for (Object c : auxiliaryTypes[0].getEnumConstants()) { list.add(c.toString()); }
                     completionCandidates = Collections.unmodifiableList(list);
                 } else {
                     completionCandidates = builder.completionCandidates;

File: src/test/java/picocli/CommandLineCommandMethodTest.java
Patch:
@@ -78,7 +78,7 @@ int run2(int a, @Option(names="-b", required=true) int b) {
             return a*b;
         }
     }
-	@SuppressWarnings("deprecation")
+    @SuppressWarnings("deprecation")
     @Test
     public void testAnnotateMethod_noArg() throws Exception {
         setTraceLevel("OFF");
@@ -502,4 +502,4 @@ public void testParamIndexAnnotatedAndUnAnnotated() {
     private static Set<String> set(String... elements) {
         return new HashSet<String>(Arrays.asList(elements));
     }
-}
\ No newline at end of file
+}

File: src/test/java/picocli/CommandLineTypeConversionTest.java
Patch:
@@ -511,7 +511,7 @@ private void parseInvalidValue(String option, String value, String... errorMessa
                 if (actual.getMessage().equals(errMsg)) { return; } // that is okay also
             }
             String type = option.substring(1);
-            String expected = String.format("Invalid value for option '%s': cannot convert '%s' to %s (%s)", option, value, type, errorMessage[0]);
+            String expected = String.format("Invalid value for option '%s': cannot convert '%s' to %s (%s", option, value, type, errorMessage[0]);
             assertTrue("expected:<" + expected + "> but was:<" + actual.getMessage() + ">",
                     actual.getMessage().startsWith(expected));
         }

File: src/test/java/picocli/CommandLineParseWithHandlersTest.java
Patch:
@@ -264,7 +264,7 @@ public void run() {
 
         assertFalse(runWasCalled[0]);
         assertEquals(String.format(
-                "Could not convert 'not a number' to int for option '-number': java.lang.NumberFormatException: For input string: \"not a number\"%n" +
+                "Invalid value for option '-number': 'not a number' is not an int%n" +
                         "Usage: <main class> [-number=<number>]%n" +
                         "      -number=<number>%n"), sps.toString());
     }
@@ -299,7 +299,7 @@ class App implements Callable<Boolean> {
 
         assertNull(callResult);
         assertEquals(String.format(
-                "Could not convert 'not a number' to int for option '-number': java.lang.NumberFormatException: For input string: \"not a number\"%n" +
+                "Invalid value for option '-number': 'not a number' is not an int%n" +
                         "Usage: <main class> [-number=<number>]%n" +
                         "      -number=<number>%n"), sps.toString());
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3038,7 +3038,7 @@ public interface IDefaultValueProvider {
         * @param argSpec the option or positional parameter, never {@code null}
         * @return the default value for the option or positional parameter, or {@code null} if
         *       this provider has no default value for the specified option or positional parameter
-        * @throws Exception an exception detailing what went wrong when obtaining default value
+        * @throws Exception when there was a problem obtaining the default value
         */
         String defaultValue(ArgSpec argSpec) throws Exception;
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2372,7 +2372,7 @@ private static class NoCompletionCandidates implements Iterable<String> {
         /** Use this attribute to specify an {@code Iterable<String>} class that generates completion candidates for this option.
          * For map fields, completion candidates should be in {@code key=value} form.
          * <p>
-         * Completion candidates are used in bash completion scripts generated by the {@link AutoComplete} class.
+         * Completion candidates are used in bash completion scripts generated by the {@code picocli.AutoComplete} class.
          * Bash has special completion options to generate file names and host names, and the bash completion scripts
          * generated by {@code AutoComplete} delegate to these bash built-ins for {@code @Options} whose {@code type} is
          * {@code java.io.File}, {@code java.nio.file.Path} or {@code java.net.InetAddress}.
@@ -2554,8 +2554,8 @@ private static class NoCompletionCandidates implements Iterable<String> {
         /** Use this attribute to specify an {@code Iterable<String>} class that generates completion candidates for
          * this positional parameter. For map fields, completion candidates should be in {@code key=value} form.
          * <p>
-         * Completion candidates are used in bash completion scripts generated by the {@link AutoComplete} class.
-         * Unfortunately, {@link AutoComplete} is not very good yet at generating completions for positional parameters.
+         * Completion candidates are used in bash completion scripts generated by the {@code picocli.AutoComplete} class.
+         * Unfortunately, {@code picocli.AutoComplete} is not very good yet at generating completions for positional parameters.
          * </p>
          *
          * @return a class whose instances can iterate over the completion candidates for this positional parameter

File: src/test/java/picocli/I18nSubclass.java
Patch:
@@ -4,7 +4,7 @@
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
-@Command(name = "i18l-sub",
+@Command(name = "i18n-sub",
         description = {"orig sub desc 1", "orig sub desc 2"},
         descriptionHeading = "orig sub desc heading:%n",
         headerHeading = "orig sub header heading%n")

File: src/test/java/picocli/I18nSubclass2.java
Patch:
@@ -4,7 +4,7 @@
 import picocli.CommandLine.Option;
 import picocli.CommandLine.Parameters;
 
-@Command(name = "i18l-sub2",
+@Command(name = "i18n-sub2",
         resourceBundle = "picocli.I18nSubclass2_Messages",
         description = {"orig sub2 desc 1", "orig sub2 desc 2"},
         descriptionHeading = "orig sub2 desc heading%n",

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -1496,7 +1496,7 @@ class ChildOption extends ParentOption {
             CommandLine.populateCommand(new ChildOption(), "");
             fail("expected CommandLine$DuplicateOptionAnnotationsException");
         } catch (DuplicateOptionAnnotationsException ex) {
-            String expected = String.format("Option name '-p' is used by both field String %s.path and field String %s.text",
+            String expected = String.format("Option name '-p' is used by both field String %s.text and field String %s.path",
                     ChildOption.class.getName(), ParentOption.class.getName());
             assertEquals(expected, ex.getMessage());
         }

File: src/test/java/picocli/I18nTest.java
Patch:
@@ -25,7 +25,7 @@
 import static picocli.HelpTestUtil.usageString;
 
 /**
- * Tests valid values-related functionality.
+ * Tests internationalization (i18n) and localization (l12n)-related functionality.
  */
 public class I18nTest {
 

File: src/test/java/picocli/ModelTestUtil.java
Patch:
@@ -33,7 +33,7 @@ public static OptionSpec option(Object obj, String fieldName) throws Exception {
         return option(obj, fieldName, CommandLine.defaultFactory());
     }
     public static OptionSpec option(Object obj, String fieldName, CommandLine.IFactory factory) throws Exception {
-        return ArgsReflection.extractOptionSpec(TypedMember.createIfAnnotated(obj.getClass().getDeclaredField(fieldName), obj), factory);
+        return ArgsReflection.extractOptionSpec(TypedMember.createIfAnnotated(obj.getClass().getDeclaredField(fieldName), obj), factory, "", null);
     }
     public static OptionSpec[] options(Object obj, String... fieldNames) throws Exception {
         OptionSpec[] result = new OptionSpec[fieldNames.length];

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -7990,7 +7990,7 @@ public DefaultParamLabelRenderer(CommandSpec commandSpec) {
             public Text renderParameterLabel(ArgSpec argSpec, Ansi ansi, List<IStyle> styles) {
                 Range capacity = argSpec.isOption() ? argSpec.arity() : ((PositionalParamSpec)argSpec).capacity();
                 if (capacity.max == 0) { return ansi.new Text(""); }
-                if (argSpec.hideParamSyntax()) { return ansi.apply(separator() + argSpec.paramLabel(), styles); }
+                if (argSpec.hideParamSyntax()) { return ansi.apply((argSpec.isOption() ? separator() : "") + argSpec.paramLabel(), styles); }
                 
                 Text paramName = ansi.apply(argSpec.paramLabel(), styles);
                 String split = argSpec.splitRegex();

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -517,7 +517,7 @@ public void testPositionalDefaultRequiredIsFalse() throws Exception {
     }
     @Test
     public void testPositionalDefaultFixParamLabelIsFalse() throws Exception {
-        assertTrue(PositionalParamSpec.builder().build().hideParamSyntax());
+        assertFalse(PositionalParamSpec.builder().build().hideParamSyntax());
     }
 
     @Test

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -7087,7 +7087,8 @@ public static interface IHelpCommandInitializable {
      * <img src="doc-files/class-diagram-help-api.png" alt="Class Diagram of the CommandLine.Help API">
      * </p>
      * <h2>Layered API</h2>
-     * <p>The {@link Command} annotation provides the easiest way to customize usage help messages. See
+     * <p>The {@link Command} annotation and the {@link UsageMessageSpec} programmatic API equivalent
+     * provide the easiest way to configure the usage help message. See
      * the <a href="https://remkop.github.io/picocli/index.html#_usage_help">Manual</a> for details.</p>
      * <p>This Help class provides high-level functions to create sections of the usage help message and headings
      * for these sections. Instead of calling the {@link CommandLine#usage(PrintStream, CommandLine.Help.ColorScheme)}

File: src/main/java/picocli/package-info.java
Patch:
@@ -14,7 +14,7 @@
  * </p>
  * <h2>Class Diagram of the Picocli Exceptions</h2>
  * <p>
- * <img src="doc-files/class-diagram-excepitons.png" alt="Class Diagram of the Picocli Exceptions">
+ * <img src="doc-files/class-diagram-exceptions.png" alt="Class Diagram of the Picocli Exceptions">
  * </p>
  * <h2>Class Diagram of the CommandLine.Help API</h2>
  * <p>

File: src/test/java/picocli/CommandLineParseWithHandlersTest.java
Patch:
@@ -58,7 +58,7 @@ public void testParseWithHandlerRunXxxFailsIfNotRunnableOrCallable() {
             public Object create() {return new App();}
         };
         String[] args = { "abc" };
-        verifyAllFail(factory, "Parsed command (picocli.CommandLineParseWithHandlersTest$", ") is not Runnable or Callable", args);
+        verifyAllFail(factory, "Parsed command (picocli.CommandLineParseWithHandlersTest$", ") is not Method, Runnable or Callable", args);
     }
 
     @Test

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -241,7 +241,9 @@ public CommandLine addSubcommand(String name, Object command) {
      */
     public CommandLine addSubcommand(String name, Object command, String... aliases) {
         CommandLine subcommandLine = toCommandLine(command, factory);
-        subcommandLine.getCommandSpec().aliases(aliases);
+        List<String> update = new ArrayList<String>(Arrays.asList(subcommandLine.getCommandSpec().aliases()));
+        update.addAll(Arrays.asList(aliases));
+        subcommandLine.getCommandSpec().aliases(update.toArray(new String[0]));
         getCommandSpec().addSubcommand(name, subcommandLine);
         CommandLine.Model.CommandReflection.initParentCommand(subcommandLine.getCommandSpec().userObject(), getCommandSpec().userObject());
         return this;

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3196,6 +3196,9 @@ void validate() {
             /** Sets the CommandLine constructed with this {@code CommandSpec} model. */
             protected CommandSpec commandLine(CommandLine commandLine) {
                 this.commandLine = commandLine;
+                for (CommandSpec mixedInSpec : mixins.values()) {
+                    mixedInSpec.commandLine(commandLine);
+                }
                 for (CommandLine sub : commands.values()) {
                     sub.getCommandSpec().parent(this);
                 }

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -1202,6 +1202,7 @@ public void testBooleanObjectVersionHelpOptions() {
         assertTrue(new CommandLine(cmd).parseArgs("-x").isVersionHelpRequested());
     }
     @Test
+    @SuppressWarnings("deprecation")
     public void testGettersOnOptionBuilder() {
         ISetter setter = new ISetter() {
             public <T> T set(T value) throws Exception {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3824,7 +3824,7 @@ public abstract static class ArgSpec {
             Map<Integer, Object> typedValueAtPosition = new TreeMap<Integer, Object>();
 
             /** Constructs a new {@code ArgSpec}. */
-            private ArgSpec(Builder builder) {
+            private <T extends Builder<T>> ArgSpec(Builder<T> builder) {
                 description = builder.description == null ? new String[0] : builder.description;
                 splitRegex = builder.splitRegex == null ? "" : builder.splitRegex;
                 paramLabel = empty(builder.paramLabel) ? "PARAM" : builder.paramLabel;

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -810,7 +810,7 @@ class ArrayBinding implements ISetter {
     public void testUnmatchedArgsBinding_forStringCollectionSupplier() {
         setTraceLevel("OFF");
         class ArrayBinding implements IGetter {
-            List<String> list = new ArrayList();
+            List<String> list = new ArrayList<String>();
             @SuppressWarnings("unchecked") public <T> T get() {
                 return (T) list;
             }

File: src/test/java/picocli/CommandLineParseWithHandlersTest.java
Patch:
@@ -175,11 +175,11 @@ class App implements Callable<Object> {
     }
 
     private void verifyReturnValueForBuiltInHandlers2(CommandLineFactory factory, Object expected, String[] args) {
-        IParseResultHandler2[] handlers = new IParseResultHandler2[] {
+        IParseResultHandler2<?>[] handlers = new IParseResultHandler2[] {
                 new RunFirst(), new RunLast(), new RunAll()
         };
         PrintStream out = new PrintStream(new ByteArrayOutputStream());
-        for (IParseResultHandler2 handler : handlers) {
+        for (IParseResultHandler2<?> handler : handlers) {
             String descr = handler.getClass().getSimpleName();
             Object actual = factory.create().parseWithHandler(handler, args);
             assertEquals(descr + ": return value", expected, actual);

File: src/test/java/picocli/CommandLineParseWithHandlersTest.java
Patch:
@@ -58,7 +58,7 @@ public void testParseWithHandlerRunXxxFailsIfNotRunnableOrCallable() {
             public Object create() {return new App();}
         };
         String[] args = { "abc" };
-        verifyAllFail(factory, "Parsed command (picocli.CommandLineParseWithHandlersTest$", ") is not Runnable or Callable", args);
+        verifyAllFail(factory, "Parsed command (picocli.CommandLineParseWithHandlersTest$", ") is not Method, Runnable or Callable", args);
     }
 
     @Test

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -634,8 +634,9 @@ private static CommandSpec findCommandFor(ArgSpec arg, CommandSpec cmd) {
         return (arg instanceof OptionSpec) ? findCommandFor((OptionSpec) arg, cmd) : findCommandFor((PositionalParamSpec) arg, cmd);
     }
     private static CommandSpec findCommandFor(OptionSpec option, CommandSpec commandSpec) {
-        OptionSpec found = commandSpec.findOption(option.longestName());
-        if (found != null) { return commandSpec; }
+        for (OptionSpec defined : commandSpec.options()) {
+            if (defined == option) { return commandSpec; }
+        }
         for (CommandLine sub : commandSpec.subcommands().values()) {
             CommandSpec result = findCommandFor(option, sub.getCommandSpec());
             if (result != null) { return result; }

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -505,7 +505,7 @@ public void testBooleanOptionsArity0_nShortFormFailsIfAttachedParamNotABoolean()
             CommandLine.populateCommand(new BooleanOptionsArity0_nAndParameters(), "-rv234 -bool".split(" "));
             fail("Expected exception");
         } catch (UnmatchedArgumentException ok) {
-            assertEquals("Unmatched argument [-234]", ok.getMessage());
+            assertEquals("Unknown option: -234", ok.getMessage());
         }
     }
     @Test
@@ -851,13 +851,13 @@ class NonVarArgArrayParamsZeroArity {
             CommandLine.populateCommand(new NonVarArgArrayParamsZeroArity(), "a", "b", "c");
             fail("Expected UnmatchedArgumentException");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments [a, b, c]", ex.getMessage());
+            assertEquals("Unmatched arguments: a, b, c", ex.getMessage());
         }
         try {
             CommandLine.populateCommand(new NonVarArgArrayParamsZeroArity(), "a");
             fail("Expected UnmatchedArgumentException");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched argument [a]", ex.getMessage());
+            assertEquals("Unmatched argument: a", ex.getMessage());
         }
         NonVarArgArrayParamsZeroArity params = CommandLine.populateCommand(new NonVarArgArrayParamsZeroArity());
         assertEquals(null, params.params);

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -289,7 +289,7 @@ public void testMultiValueOptionArityAloneIsInsufficient() throws Exception {
             commandLine.parse("-c", "1", "2", "3");
             fail("Expected exception");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments [2, 3]", ex.getMessage());
+            assertEquals("Unmatched arguments: 2, 3", ex.getMessage());
         }
     }
 
@@ -305,7 +305,7 @@ public void testMultiValuePositionalParamArityAloneIsInsufficient() throws Excep
             commandLine.parse("1", "2", "3");
             fail("Expected exception");
         } catch (UnmatchedArgumentException ex) {
-            assertEquals("Unmatched arguments [2, 3]", ex.getMessage());
+            assertEquals("Unmatched arguments: 2, 3", ex.getMessage());
         }
     }
 

File: src/test/java/picocli/CommandLineParseWithHandlersTest.java
Patch:
@@ -382,7 +382,7 @@ static class MyRunnable implements Runnable {
             "  -x= <option>    this is an option%n");
 
     private static final String INVALID_INPUT = format("" +
-            "Unmatched argument [invalid input]%n");
+            "Unmatched argument: invalid input%n");
 
     private static final String MYCALLABLE_INVALID_INPUT = INVALID_INPUT + MYCALLABLE_USAGE;
 

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -3390,7 +3390,7 @@ public void run() { }
         CommandLine.run(new App(), System.out, new PrintStream(baos), Help.Ansi.OFF, args);
 
         String expected = format("" +
-                "Missing required parameters at positions 0..*: FILES%n" +
+                "Missing required parameter: FILES%n" +
                 "Usage: <main class> FILES...%n" +
                 "      FILES...   List of files%n");
         assertEquals(expected, baos.toString());
@@ -3412,7 +3412,7 @@ public void run() { }
         CommandLine.run(new App(), System.out, new PrintStream(baos), Help.Ansi.OFF, args);
 
         String expected = format("" +
-                "Missing required parameters at positions 0..*: FILES%n" +
+                "Missing required parameter: FILES%n" +
                 "Usage: <main class> [-v] FILES...%n" +
                 "      FILES...   List of files%n" +
                 "  -v             Print output%n");

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -554,7 +554,7 @@ public void testComplete() {
         test(spec, a("sub2", "subsub2", "-t", "0", "--t"),    4, 3, cur, l("imeUnit", "imeout"));
         test(spec, a("sub2", "subsub2", "-t", "0", "-u"),     4, 2, cur, l(""));
         test(spec, a("sub2", "subsub2", "-t", "0", "-u"),     5, 0, cur, timeUnitValues());
-        test(spec, a("sub2", "subsub2", "-t", "0", "-u", "M"),5, 1, cur, l("ICROSECONDS", "ILLISECONDS", "INUTES"));
+        test(spec, a("sub2", "subsub2", "-t", "0", "-u", "S"),5, 1, cur, l("ECONDS"));
         test(spec, a("sub2", "subsub2", "a"),                 2, 1, cur, l(""));
         test(spec, a("sub2", "subsub2", "a"),                 3, 0, cur, l("--timeUnit", "--timeout", "-t", "-u", "a", "b", "c"));
     }

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -1686,7 +1686,7 @@ class Injected {
             new CommandLine(injected);
             fail("Expect exception");
         } catch (InitializationException ex) {
-            assertEquals("@picocli.CommandLine.Inject annotation is only supported on fields of type picocli.CommandLine$Model$CommandSpec", ex.getMessage());
+            assertEquals("@picocli.CommandLine.Spec annotation is only supported on fields of type picocli.CommandLine$Model$CommandSpec", ex.getMessage());
         }
     }
 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2709,7 +2709,7 @@ private static void validatePositionalParameters(List<PositionalParamSpec> posit
         for (PositionalParamSpec positional : positionalParametersFields) {
             Range index = positional.index();
             if (index.min > min) {
-                throw new ParameterIndexGapException("Missing positional parameter with index=" + min +
+                throw new ParameterIndexGapException("Command definition should have a positional parameter with index=" + min +
                         ". Nearest positional parameter '" + positional.paramLabel() + "' has index=" + index.min);
             }
             min = Math.max(min, index.max);

File: src/main/java/picocli/groovy/PicocliScriptASTTransformation.java
Patch:
@@ -108,8 +108,6 @@ private void changeBaseScriptTypeFromDeclaration(final SourceUnit source, final
             }
             de.setRightExpression(new VariableExpression("this"));
         } else {
-            source.getErrorCollector().addWarning(1, "!baseScriptType.isScript, baseScriptType=" + baseScriptType, source.getCST(), source);
-            source.getErrorCollector().addWarning(1, "cNode = " + cNode, source.getCST(), source);
             baseScriptType = BASE_SCRIPT_TYPE;
         }
         Expression value = node.getMember("value");

File: src/main/java/picocli/groovy/PicocliScriptASTTransformation.java
Patch:
@@ -60,8 +60,6 @@ public void visit(ASTNode[] nodes, SourceUnit source) {
         AnnotationNode node = (AnnotationNode) nodes[0];
         if (!MY_TYPE.equals(node.getClassNode())) return;
 
-        source.getErrorCollector().addWarning(1, "parent=" + parent, source.getCST(), source);
-
         if (parent instanceof DeclarationExpression) {
             changeBaseScriptTypeFromDeclaration(source, (DeclarationExpression) parent, node);
         } else if (parent instanceof ImportNode || parent instanceof PackageNode) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2183,11 +2183,10 @@ private static class NoCompletionCandidates implements Iterable<String> {
         String name() default "";
     }
     /**
-     * Fields annotated with {@code @Inject} will be initialized with the {@code CommandLine} or {@code CommandSpec} for the command the field is part of. Example usage:
+     * Fields annotated with {@code @Inject} will be initialized with the {@code CommandSpec} for the command the field is part of. Example usage:
      * <pre>
      * class InjectExample implements Runnable {
-     *     &#064;Inject CommandLine commandLine; // usually you inject either the CommandLine
-     *     &#064;Inject CommandSpec commandSpec; // or the CommandSpec
+     *     &#064;Inject CommandSpec commandSpec;
      *     //...
      *     public void run() {
      *         // do something with the injected objects

File: src/test/java/picocli/CompletionCandidatesTest.java
Patch:
@@ -151,7 +151,7 @@ class App {
                 "                           long, list, of, completion, candidates, that, is,%n" +
                 "                           intended, to, wrap, to, the, next, line., I, wonder, if,%n" +
                 "                           it, is, long, enough.%n" +
-                "      --logfile=<file>   Use given file for log. Default: \\a\\b\\c%n" +
+                "      --logfile=<file>   Use given file for log. Default: %s%n" +
                 "      --strNull=<str>    String without default. Default: null%n" +
                 "      --x=<x>[,<x>...]   Comma-separated list of some xxx's. Valid values: A, B, C, D%n" +
                 "      --y=<y>            Test long default. Default: This is a very long default%n" +
@@ -160,7 +160,7 @@ class App {
                 "  -P= [<key=ppp>...]     Use value for project key.%n" +
                 "                         Default={key1=veryveryverylonglonglongvaluevaluevalue,%n" +
                 "                           key2=very2very2very2longlonglongvaluevaluevalue2,%n" +
-                "                           key3=very3very3very3longlonglongvaluevaluevalue3}%n");
+                "                           key3=very3very3very3longlonglongvaluevaluevalue3}%n", new File("/a/b/c"));
         String actual = usageString(new CommandLine(new App(), new InnerClassFactory(this)), CommandLine.Help.Ansi.OFF);
         assertEquals(expected, actual);
     }

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -456,7 +456,7 @@ class App {
         }
     }
 
-    private static class BooleanOptionsArity0_nAndParameters {
+    static class BooleanOptionsArity0_nAndParameters {
         @Parameters String[] params;
         @Option(names = "-bool", arity = "0..*") boolean bool;
         @Option(names = {"-v", "-other"}, arity="0..*") boolean vOrOther;

File: src/test/java/picocli/CommandLineTypeConversionTest.java
Patch:
@@ -645,7 +645,7 @@ class App {
         commandLine.parse("100");
         assertEquals(123, app.converted);
     }
-    private static class EnumParams {
+    static class EnumParams {
         @Option(names = "-timeUnit")
         TimeUnit timeUnit;
         @Option(names = "-timeUnitArray", arity = "2") TimeUnit[] timeUnitArray;

File: src/main/java/picocli/groovy/PicocliScriptASTTransformation.java
Patch:
@@ -137,7 +137,9 @@ private void changeBaseScriptType(final SourceUnit source, final AnnotatedNode p
         }
 
         List<AnnotationNode> annotations = parent.getAnnotations(COMMAND_TYPE);
-        cNode.addAnnotations(annotations);
+        if (cNode.getAnnotations(COMMAND_TYPE).isEmpty()) { // #388 prevent "Duplicate annotation for class" AnnotationFormatError
+            cNode.addAnnotations(annotations);
+        }
         cNode.setSuperClass(baseScriptType);
 
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4171,6 +4171,7 @@ private static void initSubcommands(Command cmd, CommandSpec parent, IFactory fa
                 }
             }
             static void initParentCommand(Object subcommand, Object parent) {
+                if (subcommand == null) { return; }
                 try {
                     Class<?> cls = subcommand.getClass();
                     while (cls != null) {

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -384,7 +384,7 @@ private static void generateFunctionCallsToArrContains(String scriptName,
             int count = functionCalls.size();
             String functionName = "_picocli_" + scriptName + "_" + concat("_", predecessors, entry.getKey(), new Bashify());
             functionCalls.add(format("  ArrContains COMP_WORDS CMDS%2$d && { %1$s; return $?; }\n", functionName, count));
-            buff.append(      format("  CMDS%2$d=(%1$s)\n", concat(" ", predecessors, entry.getKey(), new Bashify()), count));
+            buff.append(      format("  CMDS%2$d=(%1$s)\n", concat(" ", predecessors, entry.getKey(), new NullFunction()), count));
 
             // remember the function name and associated subcommand so we can easily generate a function later
             function2command.put(new CommandDescriptor(functionName, entry.getKey()), entry.getValue());

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -3927,9 +3927,9 @@ class Flags {
         assertFalse(!flags.p0);
         assertTrue (!flags.p1);
         commandLine.parse("-a", "-b", "true", "false");
-        assertFalse(flags.a);
-        assertTrue (flags.b);
-        assertFalse(!flags.p0); // as set
+        assertFalse(!flags.a);
+        assertTrue (!flags.b);
+        assertFalse(!flags.p0);
         assertTrue (!flags.p1);
     }
 

File: src/test/java/picocli/CommandLineArityTest.java
Patch:
@@ -520,7 +520,7 @@ public void testBooleanOptionsArity0_nShortFormFailsIfAttachedWithSepParamNotABo
             CommandLine.populateCommand(new BooleanOptionsArity0_nAndParameters(), "-rv=234 -bool".split(" "));
             fail("was able to assign 234 to boolean");
         } catch (CommandLine.ParameterException ex) {
-            assertEquals("'234' is not a boolean for option '-v'", ex.getMessage());
+            assertEquals("'234' is not a boolean for option '-other'", ex.getMessage());
         }
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3492,7 +3492,7 @@ <T> T setValue(T newValue) throws PicocliException {
             protected void resetOriginalStringValues() { originalStringValues = new ArrayList<String>(); }
 
             boolean acceptsValues(ParserSpec parser) {
-                return !parser.arityRestrictsCumulativeSize() || stringValues().size() < arity().max;
+                return arity().max == 0 || !parser.arityRestrictsCumulativeSize() || stringValues().size() < arity().max;
             }
 
             protected boolean showDefaultValue(CommandSpec commandSpec) {

File: examples/src/main/java/picocli/examples/model/BasicResultProcessing.java
Patch:
@@ -47,7 +47,7 @@ public static void main(final String[] args) {
             if (CommandLine.printHelpIfRequested(pr)) { return; }
 
             int count = pr.optionValue('c', 1);
-            List<File> files = pr.positionalValue(pr.positionalParams().get(0), Collections.<File>emptyList());
+            List<File> files = pr.positionalValue(pr.matchedPositionals().get(0), Collections.<File>emptyList());
             for (File f : files) {
                 for (int i = 0; i < count; i++) {
                     System.out.println(i + " " + f.getName());

File: examples/src/main/java/picocli/examples/model/ResultHandlerWithReturnValue.java
Patch:
@@ -45,7 +45,7 @@ public static void main(final String[] args) {
         class Handler extends AbstractParseResultHandler<Integer> {
             public Integer handle(ParseResult pr) {
                 int count = pr.optionValue('c', 1);
-                List<File> files = pr.positionalValue(pr.positionalParams().get(0), Collections.<File>emptyList());
+                List<File> files = pr.positionalValue(pr.matchedPositionals().get(0), Collections.<File>emptyList());
                 for (File f : files) {
                     for (int i = 0; i < count; i++) {
                         System.out.println(i + " " + f.getName());

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -823,9 +823,9 @@ class App {
         CommandLine cmd = new CommandLine(app);
         cmd.setUnmatchedOptionsArePositionalParams(true);
         ParseResult parseResult = cmd.parseArgs("-x", "-a", "AAA");
-        assertTrue(parseResult.hasPositional(0));
+        assertTrue(parseResult.hasMatchedPositional(0));
         assertArrayEquals(new String[]{"-x"}, parseResult.positionalValue(0, new String[0]));
-        assertTrue(parseResult.hasOption("a"));
+        assertTrue(parseResult.hasMatchedOption("a"));
         assertEquals("AAA", parseResult.optionValue("a", null));
 
         assertArrayEquals(new String[]{"-x"}, app.remainder);

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -23,7 +23,6 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Field;
 import java.math.BigDecimal;
 import java.net.InetAddress;
@@ -34,7 +33,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -48,7 +46,6 @@
 import java.util.TreeMap;
 import java.util.TreeSet;
 import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.*;

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -5948,7 +5948,7 @@ public String detailedSynopsis(int synopsisHeadingLength, Comparator<OptionSpec>
 
             if(!commandSpec.subcommands().isEmpty()){
                 optionText = optionText.append(" [")
-                        .append(colorScheme.optionText("COMMAND"))
+                        .append("COMMAND")
                         .append("]");
             }
 

File: src/test/java/picocli/Demo.java
Patch:
@@ -470,7 +470,7 @@ public void testUsageMainCommand()  {
             throw new InternalError(ex.toString());
         }
     }
-    static final String EXPECTED_USAGE_MAIN = "Usage: git [-hV] [--git-dir=<gitDir>]%n" +
+    static final String EXPECTED_USAGE_MAIN = "Usage: git [-hV] [--git-dir=<gitDir>] [COMMAND]%n" +
             "Git is a fast, scalable, distributed revision control system with an unusually%n" +
             "rich command set that provides both high-level operations and full access to%n" +
             "internals.%n" +
@@ -494,7 +494,7 @@ public void testUsageMainCommand()  {
             "  rebase    Forward-port local commits to the updated upstream head.%n" +
             "  tag       Create, list, delete or verify a tag object signed with GPG.%n";
 
-    static final String EXPECTED_USAGE_MAIN_ANSI = "Usage: \u001B[1mgit\u001B[21m\u001B[0m [\u001B[33m-hV\u001B[39m\u001B[0m] [\u001B[33m--git-dir\u001B[39m\u001B[0m=\u001B[3m<gitDir>\u001B[23m\u001B[0m]%n" +
+    static final String EXPECTED_USAGE_MAIN_ANSI = "Usage: \u001B[1mgit\u001B[21m\u001B[0m [\u001B[33m-hV\u001B[39m\u001B[0m] [\u001B[33m--git-dir\u001B[39m\u001B[0m=\u001B[3m<gitDir>\u001B[23m\u001B[0m] [COMMAND]%n" +
             "Git is a fast, scalable, distributed revision control system with an unusually%n" +
             "rich command set that provides both high-level operations and full access to%n" +
             "internals.%n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4836,7 +4836,7 @@ private int applyValueToSingleValuedField(ArgSpec argSpec,
                         Boolean currentValue = (Boolean) argSpec.getValue();
                         value = String.valueOf(currentValue == null || !currentValue); // #147 toggle existing boolean value
                     }
-                } else if (CharSequence.class.isAssignableFrom(cls)) { // String option with optional value
+                } else { // option with optional value #325
                     if (isOption(value)) {
                         args.push(value); // we don't consume the value
                         value = "";

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -306,7 +306,7 @@ class Params {
         cmd.getCommandSpec().usageMessage().showDefaultValues(true);
         String result = usageString(cmd, Help.Ansi.OFF);
         assertEquals(format("" +
-                "Usage: <main class> -x=INT[,INT]... [-x=INT[,INT]...]...%n" +
+                "Usage: <main class> [-x=INT[,INT]...]...%n" +
                 "  -x, --array=INT[,INT]...    the array%n" +
                 "                                Default: 5,4,3,2,1%n"), result);
     }

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -970,7 +970,8 @@ public void testParser_MaxArityIsMaxTotalParams_split() {
         cmd.parser().maxArityIsMaxTotalParams(true);
 
         ParseResult parseResult = new CommandLine(cmd).parseArgs("-x", "1,2,3");
-        assertEquals(Arrays.asList("1,2,3"), parseResult.rawOptionValues('x')); // raw is the original command line argument
+        assertEquals(Arrays.asList("1", "2", "3"), parseResult.rawOptionValues('x')); // raw is split but untyped
+        assertEquals(Arrays.asList("1,2,3"), parseResult.option('x').originalStringValues()); // the original command line argument
         assertArrayEquals(new String[]{"1", "2", "3"}, parseResult.optionValue('x', (String[]) null));
 
         CommandSpec cmd2 = CommandSpec.create().addOption(OptionSpec.builder("-x").arity("1..3").splitRegex(",").build());

File: examples/src/main/java/picocli/examples/ExitCodeDemo.java
Patch:
@@ -30,8 +30,7 @@ public static void main(String... args) {
         CommandLine cmd = new CommandLine(new ExitCodeDemo());
         cmd.parseWithHandlers(
                 new CommandLine.RunLast().andExit(123),
-                Collections.<Object>emptyList(),
-                new CommandLine.DefaultExceptionHandler<List<Object>>().andExit(456),
+                CommandLine.defaultExceptionHandler().andExit(456),
                 args);
     }
 }

File: examples/src/main/java/picocli/examples/model/ResultHandlerWithReturnValue.java
Patch:
@@ -43,19 +43,19 @@ public static void main(final String[] args) {
         CommandLine commandLine = new CommandLine(spec);
 
         class Handler extends AbstractParseResultHandler<Void> {
-            public Void handle(ParseResult pr, Void retVal) {
+            public Void handle(ParseResult pr) {
                 int count = pr.optionValue('c', 1);
                 List<File> files = pr.positionalValue(pr.positionalParams().get(0), Collections.<File>emptyList());
                 for (File f : files) {
                     for (int i = 0; i < count; i++) {
                         System.out.println(i + " " + f.getName());
                     }
                 }
-                return retVal;
+                return null;
             }
             protected Handler self() { return this; }
         }
 
-        commandLine.parseWithHandler(new Handler(), null, args);
+        commandLine.parseWithHandler(new Handler(), args);
     }
 }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -811,7 +811,7 @@ private static List<Object> execute(CommandLine parsed, List<Object> executionRe
      * }</pre>
      * @since 3.0 */
     public abstract static class AbstractParseResultHandler<R> extends AbstractHandler<R, AbstractParseResultHandler<R>> implements IParseResultHandler2<R> {
-        /** Prints help if requested, and otherwise calls {@link #process(CommandLine.ParseResult, R)}.
+        /** Prints help if requested, and otherwise calls {@link #process(CommandLine.ParseResult, Object)}.
          * Finally, either a list of result objects is returned, or the JVM is terminated if an exit code {@linkplain #andExit(int) was set}.
          *
          * @param parseResult the {@code ParseResult} that resulted from successfully parsing the command line arguments

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -772,7 +772,7 @@ private static Object execute(CommandLine parsed) {
     }
     /** Command line parse result handler that prints help if requested, and otherwise calls {@link #process(CommandLine.ParseResult)}
      * with the parse result. Facilitates implementation of the {@link IParseResultHandler2} interface.
-     * An example subclass can look like this:</p>
+     * <p>An example subclass can look like this:</p>
      * <pre>{@code
      * class MyResultHandler extends AbstractParseResultHandler {
      *     public List<Object> process(ParseResult parseResult) throws ExecutionException { ... }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2969,7 +2969,7 @@ abstract static class Builder<T extends Builder<T>> {
          * Depending on the option's {@link #arity() arity},
          * the parser may expect it to have option parameters. The parser will call {@link #setValue(Object) setValue} on
          * the matched option for each of the option parameters encountered.
-         * </p<p>
+         * </p><p>
          * For multi-value options, the {@code type} may be an array, a {@code Collection} or a {@code Map}. In this case
          * the parser will get the data structure by calling {@link #getValue() getValue} and modify the contents of this data structure.
          * (In the case of arrays, the array is replaced with a new instance with additional elements.)
@@ -2993,7 +2993,7 @@ abstract static class Builder<T extends Builder<T>> {
          * {@code OptionSpec} objects are used by the picocli command line interpreter and help message generator.
          * Picocli can construct an {@code OptionSpec} automatically from fields and methods with {@link Option @Option}
          * annotations. Alternatively an {@code OptionSpec} can be constructed programmatically.
-         * </p<p>
+         * </p><p>
          * When an {@code OptionSpec} is created from an {@link Option @Option} -annotated field or method, it is "bound"
          * to that field or method: this field is set (or the method is invoked) when the option is matched and
          * {@link #setValue(Object) setValue} is called.
@@ -3148,7 +3148,7 @@ private Builder(OptionSpec original) {
          * {@code PositionalParamSpec} objects are used by the picocli command line interpreter and help message generator.
          * Picocli can construct a {@code PositionalParamSpec} automatically from fields and methods with {@link Parameters @Parameters}
          * annotations. Alternatively a {@code PositionalParamSpec} can be constructed programmatically.
-         * </p<p>
+         * </p><p>
          * When a {@code PositionalParamSpec} is created from a {@link Parameters @Parameters} -annotated field or method,
          * it is "bound" to that field or method: this field is set (or the method is invoked) when the position is matched
          * and {@link #setValue(Object) setValue} is called.

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4607,7 +4607,7 @@ public static class Help {
         /** Constant String holding the default program name, value defined in {@link CommandSpec#DEFAULT_COMMAND_NAME}. */
         protected static final String DEFAULT_COMMAND_NAME = CommandSpec.DEFAULT_COMMAND_NAME;
 
-        /** Constant String holding the default string that separates options from option parameters, value defined in {@link CommandSpec#DEFAULT_SEPARATOR}. */
+        /** Constant String holding the default string that separates options from option parameters, value defined in {@link ParserSpec#DEFAULT_SEPARATOR}. */
         protected static final String DEFAULT_SEPARATOR = ParserSpec.DEFAULT_SEPARATOR;
 
         private final static int MINIMUM_USAGE_WIDTH = 55;

File: src/test/java/picocli/CommandLineTypeConversionTest.java
Patch:
@@ -89,7 +89,7 @@ static class SupportedTypes {
         @Option(names = "-Currency")      Currency aCurrencyField;
         @Option(names = "-tz")            TimeZone aTimeZone;
         @Option(names = "-byteOrder")     ByteOrder aByteOrder;
-        @Option(names = "-Class")         Class aClass;
+        @Option(names = "-Class")         Class<?> aClass;
         @Option(names = "-Connection")    Connection aConnection;
         @Option(names = "-Driver")        Driver aDriver;
         @Option(names = "-Timestamp")     Timestamp aTimestamp;
@@ -630,7 +630,7 @@ static class Plus23Converter implements ITypeConverter<Integer> {
         public Integer convert(String value) { return Integer.parseInt(value) + 23; }
     }
     static class Plus23ConverterFactory implements CommandLine.IFactory {
-        public <T> T create(Class<T> cls) { return (T) new Plus23Converter(); }
+        @SuppressWarnings("unchecked") public <T> T create(Class<T> cls) { return (T) new Plus23Converter(); }
     }
     @Test
     public void testAnnotatedCustomConverterFactory() {
@@ -778,6 +778,7 @@ private void verifyReflectedConverter(Map<Class<?>, ITypeConverter<?>> registry,
         assertEquals(expectedToString, path.toString());
     }
 
+    @SuppressWarnings("unchecked")
     private Map<Class<?>, ITypeConverter<?>> extractRegistry(CommandLine commandLine) throws Exception {
         Object interpreter = makeAccessible(CommandLine.class.getDeclaredField("interpreter")).get(commandLine);
         return (Map<Class<?>, ITypeConverter<?>>) makeAccessible(interpreter.getClass().getDeclaredField("converterRegistry")).get(interpreter);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -356,7 +356,7 @@ public boolean isStopAtPositional() {
      */
     public CommandLine setStopAtPositional(boolean newValue) {
         this.stopAtPositional = newValue;
-        for (CommandLine command : interpreter.commands.values()) {
+        for (CommandLine command : getCommandSpec().subcommands().values()) {
             command.setStopAtPositional(newValue);
         }
         return this;

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -490,7 +490,7 @@ public List<Object> handleException(ParameterException ex, PrintStream out, Help
      * {@linkplain #parse(String...) parsing} command line arguments. This method prints out
      * {@linkplain #usage(PrintStream, Help.Ansi) usage help} if {@linkplain #isUsageHelpRequested() requested}
      * or {@linkplain #printVersionHelp(PrintStream, Help.Ansi) version help} if {@linkplain #isVersionHelpRequested() requested}
-     * and returns {@code true}. If the command is a {@link Command#isHelpCommand()} and {@code runnable} or {@code callable},
+     * and returns {@code true}. If the command is a {@link Command#helpCommand()} and {@code runnable} or {@code callable},
      * that command is executed and this method returns {@code true}.
      * Otherwise, if none of the specified {@code CommandLine} objects have help requested,
      * this method returns {@code false}.

File: src/main/java/picocli/groovy/PicocliScript.java
Patch:
@@ -88,5 +88,5 @@
 @Target({ElementType.LOCAL_VARIABLE, ElementType.PACKAGE, ElementType.TYPE /*, ElementType.IMPORT*/})
 @GroovyASTTransformationClass("picocli.groovy.PicocliScriptASTTransformation")
 public @interface PicocliScript {
-    Class value() default PicocliBaseScript.class;
+    Class<?> value() default PicocliBaseScript.class;
 }

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -323,7 +323,7 @@ public void testAutoCompleteAppBothScriptFilesForceOverwrite() throws Exception
                 "# =======================\n" +
                 "#\n" +
                 "# Bash completion support for the `picocli.AutoComplete` command,\n" +
-                "# generated by [picocli](http://picocli.info/) version 3.0.0-alpha1-SNAPSHOT.\n" +
+                "# generated by [picocli](http://picocli.info/) version 3.0.0-alpha-1-SNAPSHOT.\n" +
                 "#\n" +
                 "# Installation\n" +
                 "# ------------\n" +

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -118,7 +118,7 @@ public <T> T create(Class<T> cls) throws Exception {
     }
     @Test
     public void testVersion() {
-        assertEquals("3.0.0-alpha1-SNAPSHOT", CommandLine.VERSION);
+        assertEquals("3.0.0-alpha-1-SNAPSHOT", CommandLine.VERSION);
     }
     @Test
     public void testArrayPositionalParametersAreAppendedNotReplaced() {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1027,7 +1027,7 @@ public <K> CommandLine registerConverter(Class<K> cls, ITypeConverter<K> convert
         return this;
     }
 
-    /** Returns the String that separates option names from option values when parsing command line options. {@value Help#DEFAULT_SEPARATOR} by default.
+    /** Returns the String that separates option names from option values when parsing command line options. {@value CommandLine.CommandSpec#DEFAULT_SEPARATOR} by default.
      * @return the String the parser uses to separate option names from option values */
     public String getSeparator() {
         return commandSpec.separator;
@@ -1042,7 +1042,7 @@ public CommandLine setSeparator(String separator) {
         return this;
     }
 
-    /** Returns the command name (also called program name) displayed in the usage help synopsis. {@value Help#DEFAULT_COMMAND_NAME} by default.
+    /** Returns the command name (also called program name) displayed in the usage help synopsis. {@value CommandLine.CommandSpec#DEFAULT_COMMAND_NAME} by default.
      * @return the command name (also called program name) displayed in the usage
      * @since 2.0 */
     public String getCommandName() {
@@ -3842,7 +3842,7 @@ public Help(Object command, Ansi ansi) {
          * on the specified class and superclasses.
          * @param command the annotated object to create usage help for
          * @param colorScheme the color scheme to use
-         * @deprecated use {@link Help(CommandSpec, ColorScheme} */
+         * @deprecated use {@link picocli.CommandLine.Help#Help(picocli.CommandLine.CommandSpec, picocli.CommandLine.Help.ColorScheme)}  */
         public Help(Object command, ColorScheme colorScheme) {
             this(CommandSpecBuilder.build(command, new DefaultFactory()), colorScheme);
         }

File: src/test/java/picocli/CommandLineModelTest.java
Patch:
@@ -73,7 +73,7 @@ public void testModelHelp() throws Exception {
         CommandSpec spec = new CommandSpec(null);
         spec.add(new OptionSpec().names("-h", "--help").usageHelp(true).description("show help and exit"));
         spec.add(new OptionSpec().names("-V", "--version").usageHelp(true).description("show help and exit"));
-        spec.add(new OptionSpec().names("-c", "--count").paramLabel("COUNT").arity("1").propertyType(int.class).description("number of times to execute"));
+        spec.add(new OptionSpec().names("-c", "--count").paramLabel("COUNT").arity("1").type(int.class).description("number of times to execute"));
         CommandLine commandLine = new CommandLine(spec);
         String actual = usageString(commandLine, Ansi.OFF);
         String expected = String.format("" +
@@ -89,7 +89,7 @@ public void testModelParse() throws Exception {
         CommandSpec spec = new CommandSpec(null);
         spec.add(new OptionSpec().names("-h", "--help").usageHelp(true).description("show help and exit"));
         spec.add(new OptionSpec().names("-V", "--version").usageHelp(true).description("show help and exit"));
-        spec.add(new OptionSpec().names("-c", "--count").paramLabel("COUNT").arity("1").propertyType(int.class).description("number of times to execute"));
+        spec.add(new OptionSpec().names("-c", "--count").paramLabel("COUNT").arity("1").type(int.class).description("number of times to execute"));
         CommandLine commandLine = new CommandLine(spec);
         commandLine.parse("-c", "33");
         assertEquals(33, spec.getOptionsMap().get("-c").getValue());

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3877,7 +3877,7 @@ private Text[][] renderDescriptionLines(Option option,
                 Text EMPTY = Ansi.EMPTY_TEXT;
                 List<Text[]> result = new ArrayList<Text[]>();
                 Text[] descriptionFirstLines = scheme.ansi().new Text(str(option.description(), 0)).splitLines();
-                if (descriptionFirstLines.length == 0) {
+                if (descriptionFirstLines.length == 0 || (descriptionFirstLines.length == 1 && descriptionFirstLines[0].plain.length() == 0)) {
                     if (showDefault) {
                         descriptionFirstLines = new Text[]{scheme.ansi().new Text("  Default: " + defaultValue)};
                         showDefault = false; // don't show the default value twice
@@ -4820,7 +4820,7 @@ public Object clone() {
 
                 public Text[] splitLines() {
                     List<Text> result = new ArrayList<Text>();
-                    boolean trailingEmptyString = false;
+                    boolean trailingEmptyString = plain.length() == 0;
                     int start = 0, end = 0;
                     for (int i = 0; i < plain.length(); i++, end = i) {
                         char c = plain.charAt(i);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2091,7 +2091,7 @@ private void processArguments(List<CommandLine> parsedCommands,
 
                 // if we find another command, we are done with the current command
                 if (commands.containsKey(arg)) {
-                    if (!isHelpRequested && !required.isEmpty()) { // ensure current command portion is valid
+                    if (!isAnyHelpRequested() && !required.isEmpty()) { // ensure current command portion is valid
                         throw MissingParameterException.create(CommandLine.this, required, separator);
                     }
                     if (tracer.isDebug()) {tracer.debug("Found subcommand '%s' (%s)%n", arg, commands.get(arg).interpreter.command.getClass().getName());}

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -448,13 +448,13 @@ private static Object execute(CommandLine parsed) {
                 ((Runnable) command).run();
                 return null;
             } catch (Exception ex) {
-                throw new ExecutionException(parsed, "Error while running command (" + command + ")", ex);
+                throw new ExecutionException(parsed, "Error while running command (" + command + "): " + ex, ex);
             }
         } else if (command instanceof Callable) {
             try {
                 return ((Callable<Object>) command).call();
             } catch (Exception ex) {
-                throw new ExecutionException(parsed, "Error while calling command (" + command + ")", ex);
+                throw new ExecutionException(parsed, "Error while calling command (" + command + "): " + ex, ex);
             }
         }
         throw new ExecutionException(parsed, "Parsed command (" + command + ") is not Runnable or Callable");

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2166,7 +2166,7 @@ private void processClusteredShortOptions(Collection<Field> required,
                     }
                     int consumed = applyOption(field, Option.class, arity, paramAttachedToOption, args, initialized, argDescription);
                     // only return if cluster (and maybe more) was consumed, otherwise continue do-while loop
-                    if (consumed > 0) {
+                    if (consumed > 0 || args.isEmpty()) {
                         return;
                     }
                     cluster = args.pop();

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1857,6 +1857,7 @@ private class Interpreter {
         private int position;
 
         Interpreter(Object command) {
+            converterRegistry.put(Object.class,        new BuiltIn.StringConverter());
             converterRegistry.put(String.class,        new BuiltIn.StringConverter());
             converterRegistry.put(StringBuilder.class, new BuiltIn.StringBuilderConverter());
             converterRegistry.put(CharSequence.class,  new BuiltIn.CharSequenceConverter());

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -220,8 +220,8 @@ public CommandLine getParent() {
      * @return the annotated object that this {@code CommandLine} instance was constructed with
      * @since 0.9.7
      */
-    public Object getCommand() {
-        return interpreter.command;
+    public <T> T getCommand() {
+        return (T) interpreter.command;
     }
 
     /** Returns {@code true} if an option annotated with {@link Option#usageHelp()} was specified on the command line.

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3098,7 +3098,8 @@ public Text[][] render(Option option, Field field, IParamLabelRenderer paramLabe
                 Object defaultValue = null;
                 try {
                     defaultValue = field.get(command);
-                    if (defaultValue != null && field.getType().isArray()) {
+                    if (defaultValue == null) { showDefault = false; } // #201 don't show null default values
+                    else if (field.getType().isArray()) {
                         StringBuilder sb = new StringBuilder();
                         for (int i = 0; i < Array.getLength(defaultValue); i++) {
                             sb.append(i > 0 ? ", " : "").append(Array.get(defaultValue, i));

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1802,6 +1802,9 @@ private void processClusteredShortOptions(Collection<Field> required,
                     // arity may be >= 1, or
                     // arity <= 0 && !cluster.startsWith(separator)
                     // e.g., boolean @Option("-v", arity=0, varargs=true); arg "-rvTRUE", remainder cluster="TRUE"
+                    if (!args.isEmpty() && args.peek().length() == 0 && !paramAttachedToOption) {
+                        args.pop(); // throw out empty string we get at the end of a group of clustered short options
+                    }
                     int consumed = applyOption(field, Option.class, arity, paramAttachedToOption, args, initialized, argDescription);
                     // only return if cluster (and maybe more) was consumed, otherwise continue do-while loop
                     if (consumed > 0) {
@@ -1843,9 +1846,6 @@ private int applyOption(Field field,
                                 Set<Field> initialized,
                                 String argDescription) throws Exception {
             updateHelpRequested(field);
-            if (!args.isEmpty() && args.peek().length() == 0 && !valueAttachedToOption) {
-                args.pop(); // throw out empty string we get at the end of a group of clustered short options
-            }
             int length = args.size();
             assertNoMissingParameters(field, arity.min, args);
 

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -2715,7 +2715,7 @@ public void testTracingDebugWithSubCommands() throws Exception {
                         "[picocli DEBUG] Processing argument '--git-dir=/home/rpopma/picocli'. Remainder=[commit, -m, \"Fixed typos\", --, src1.java, src2.java, src3.java]%n" +
                         "[picocli DEBUG] Separated '--git-dir' option from '/home/rpopma/picocli' option parameter%n" +
                         "[picocli DEBUG] Found option named '--git-dir': field java.io.File picocli.Demo$Git.gitDir, arity=1%n" +
-                        "[picocli INFO] Setting File field 'Git.gitDir' to '\\home\\rpopma\\picocli' (was 'null') for option --git-dir%n" +
+                        "[picocli INFO] Setting File field 'Git.gitDir' to '%s' (was 'null') for option --git-dir%n" +
                         "[picocli DEBUG] Processing argument 'commit'. Remainder=[-m, \"Fixed typos\", --, src1.java, src2.java, src3.java]%n" +
                         "[picocli DEBUG] Found subcommand 'commit' (picocli.Demo$GitCommit)%n" +
                         "[picocli DEBUG] Initializing picocli.Demo$GitCommit: 8 options, 1 positional parameters, 0 required, 0 subcommands.%n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2710,7 +2710,7 @@ public String detailedSynopsis(int synopsisHeadingLength, Comparator<Field> opti
             textTable.indentWrappedLines = 1; // don't worry about first line: options (2nd column) always start with a space
 
             // right-adjust the command name by length of synopsis heading
-            Text PADDING = Ansi.OFF.new Text(spaces(synopsisHeadingLength));
+            Text PADDING = Ansi.OFF.new Text(stringOf('X', synopsisHeadingLength));
             textTable.addRowValues(new Text[] {PADDING.append(colorScheme.commandText(commandName)), optionText});
             return textTable.toString().substring(synopsisHeadingLength); // cut off leading synopsis heading spaces
         }
@@ -2920,9 +2920,9 @@ private static String join(String[] names, int offset, int length, String separa
             }
             return result.toString();
         }
-        private static String spaces(int length) {
+        private static String stringOf(char chr, int length) {
             char[] buff = new char[length];
-            Arrays.fill(buff, ' ');
+            Arrays.fill(buff, chr);
             return new String(buff);
         }
 

File: src/test/java/picocli/CustomLayoutDemo.java
Patch:
@@ -22,7 +22,6 @@
 import picocli.CommandLine.Help.Layout;
 import picocli.CommandLine.Help.TextTable;
 
-import java.awt.Point;
 import java.lang.reflect.Field;
 
 import static picocli.CommandLine.*;

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -156,7 +156,6 @@ class Params {
                 ""), result);
     }
 
-    @Ignore("Until #181 is fixed: Incorrect help message for short options with paramLabel when arity > 1")
     @Test
     public void testUsageParamLabels() throws Exception {
         @Command()

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -4136,7 +4136,7 @@ public MissingTypeConverterException(String msg) {
         }
     }
 
-    private static class Point {
+    public static class Point {
         public int x;
         public int y;
 

File: src/test/java/picocli/CustomLayoutDemo.java
Patch:
@@ -22,7 +22,6 @@
 import picocli.CommandLine.Help.Layout;
 import picocli.CommandLine.Help.TextTable;
 
-import java.awt.Point;
 import java.lang.reflect.Field;
 
 import static picocli.CommandLine.*;

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -249,8 +249,8 @@ public boolean equals(Object obj) {
             "  declare -A tmp\n" +
             "  eval lArr1=(\"\\\"\\${$1[@]}\\\"\")\n" +
             "  eval lArr2=(\"\\\"\\${$2[@]}\\\"\")\n" +
-            "  for i in \"${lArr1[@]}\";{ [ -n \"$i\" ] && ((++tmp['$i']));}\n" +
-            "  for i in \"${lArr2[@]}\";{ [ -z \"${tmp[$i]}\" ] && return 1;}\n" +
+            "  for i in \"${lArr1[@]}\";{ [ -n \"$i\" ] && ((++tmp[$i]));}\n" +
+            "  for i in \"${lArr2[@]}\";{ [ -n \"$i\" ] && [ -z \"${tmp[$i]}\" ] && return 1;}\n" +
             "  return 0\n" +
             "}\n" +
             "\n";

File: src/test/java/picocli/AutoCompleteTest.java
Patch:
@@ -339,8 +339,8 @@ public void testAutoCompleteAppBothScriptFilesForceOverwrite() throws Exception
                 "  declare -A tmp\n" +
                 "  eval lArr1=(\"\\\"\\${$1[@]}\\\"\")\n" +
                 "  eval lArr2=(\"\\\"\\${$2[@]}\\\"\")\n" +
-                "  for i in \"${lArr1[@]}\";{ [ -n \"$i\" ] && ((++tmp['$i']));}\n" +
-                "  for i in \"${lArr2[@]}\";{ [ -z \"${tmp[$i]}\" ] && return 1;}\n" +
+                "  for i in \"${lArr1[@]}\";{ [ -n \"$i\" ] && ((++tmp[$i]));}\n" +
+                "  for i in \"${lArr2[@]}\";{ [ -n \"$i\" ] && [ -z \"${tmp[$i]}\" ] && return 1;}\n" +
                 "  return 0\n" +
                 "}\n" +
                 "\n" +

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -1650,7 +1650,7 @@ class Versioned {}
         String[] args = {"@|bold VALUE1|@", "@|underline VALUE2|@", "VALUE3"};
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         PrintStream ps = new PrintStream(baos, true, "UTF8");
-        new CommandLine(new Versioned()).printVersionHelp(ps, Help.Ansi.ON, args);
+        new CommandLine(new Versioned()).printVersionHelp(ps, Help.Ansi.ON, (Object[]) args);
         String result = baos.toString("UTF8");
         assertEquals(String.format("" +
                 "\u001B[33mVersioned Command 1.0\u001B[39m\u001B[0m%n" +

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -562,7 +562,7 @@ public void testEnumArrayTypeConversionFailsForInvalidInput() {
             CommandLine.populateCommand(new EnumParams(), "-timeUnitArray", "a", "b");
             fail("Accepted invalid timeunit");
         } catch (Exception ex) {
-            assertEquals("Could not convert 'a' to TimeUnit[] for option '-timeUnitArray' at index 0 (timeUnitArray)" +
+            assertEquals("Could not convert 'a' to TimeUnit for option '-timeUnitArray' at index 0 (timeUnitArray)" +
                     ": java.lang.IllegalArgumentException: No enum constant java.util.concurrent.TimeUnit.a", ex.getMessage());
         }
     }

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -213,7 +213,7 @@ private static String generateEntryPointFunction(String scriptName,
         predecessors.add(scriptName);
         List<String> functionCallsToArrContains = new ArrayList<String>();
 
-        function2command.put(scriptName, commandLine);
+        function2command.put("_picocli_" + scriptName, commandLine);
         generateFunctionCallsToArrContains(predecessors, commandLine, buff, functionCallsToArrContains, function2command);
 
         buff.append("\n");

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -213,7 +213,7 @@ private static String generateEntryPointFunction(String scriptName,
         predecessors.add(scriptName);
         List<String> functionCallsToArrContains = new ArrayList<String>();
 
-        function2command.put(scriptName, commandLine);
+        function2command.put("_picocli_" + scriptName, commandLine);
         generateFunctionCallsToArrContains(predecessors, commandLine, buff, functionCallsToArrContains, function2command);
 
         buff.append("\n");

File: src/main/java/picocli/AutoComplete.java
Patch:
@@ -213,7 +213,7 @@ private static String generateEntryPointFunction(String scriptName,
         predecessors.add(scriptName);
         List<String> functionCallsToArrContains = new ArrayList<String>();
 
-        function2command.put(scriptName, commandLine);
+        function2command.put("_picocli_" + scriptName, commandLine);
         generateFunctionCallsToArrContains(predecessors, commandLine, buff, functionCallsToArrContains, function2command);
 
         buff.append("\n");

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1643,7 +1643,7 @@ private Object tryConvert(Field field, int index, ITypeConverter<?> converter, S
             } catch (ParameterException ex) {
                 throw new ParameterException(ex.getMessage() + optionDescription(" for ", field, index));
             } catch (Exception other) {
-                String desc = optionDescription(" for ", field, index);
+                String desc = optionDescription(" for ", field, index) + ": " + other;
                 throw new ParameterException("Could not convert '" + value + "' to " + type.getSimpleName() + desc, other);
             }
         }
@@ -3598,7 +3598,7 @@ public ParameterException(String msg, Exception ex) {
         private static ParameterException create(Exception ex, String arg, int i, String[] args) {
             String next = args.length < i + 1 ? "" : " " + args[i + 1];
             String msg = ex.getClass().getSimpleName() + ": " + ex.getLocalizedMessage()
-                    + " while processing option[" + i + "] '" + arg + next + "'.";
+                    + " while processing option[" + i + "] '" + arg + next + "': " + ex.toString();
             return new ParameterException(msg, ex);
         }
     }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -118,7 +118,7 @@
  */
 public class CommandLine {
     /** This is picocli version {@value}. */
-    public static final String VERSION = "0.9.4-SNAPSHOT";
+    public static final String VERSION = "0.9.3";
 
     /** Set this field to {@code true} to force ANSI escape sequences on, or to {@code false} to force ANSI escape
      * sequences off. The default ({@code null}) is to enable ANSI escape sequences on supported platforms.  */

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -82,7 +82,7 @@
 public class CommandLineTest {
     @Test
     public void testVersion() {
-        assertEquals("0.9.4-SNAPSHOT", CommandLine.VERSION);
+        assertEquals("0.9.3", CommandLine.VERSION);
     }
 
     private static class SupportedTypes {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -118,7 +118,7 @@
  */
 public class CommandLine {
     /** This is picocli version {@value}. */
-    public static final String VERSION = "0.9.2-SNAPSHOT";
+    public static final String VERSION = "0.9.2";
 
     /** Set this field to {@code true} to force ANSI escape sequences on, or to {@code false} to force ANSI escape
      * sequences off. The default ({@code null}) is to enable ANSI escape sequences on supported platforms.  */

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -82,7 +82,7 @@
 public class CommandLineTest {
     @Test
     public void testVersion() {
-        assertEquals("0.9.2-SNAPSHOT", CommandLine.VERSION);
+        assertEquals("0.9.2", CommandLine.VERSION);
     }
 
     private static class SupportedTypes {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2803,6 +2803,7 @@ public static class Ansi {
             private Ansi() {}
             // http://stackoverflow.com/questions/1403772/how-can-i-check-if-a-java-programs-input-output-streams-are-connected-to-a-term
             static final boolean calcTTY() {
+                if (isWindows && isXterm) { return true; } // Cygwin uses pseudo-tty and console is always null...
                 try { return System.class.getDeclaredMethod("console").invoke(null) != null; }
                 catch (Throwable reflectionFailed) { return true; }
             }

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1631,14 +1631,14 @@ static class UUIDConverter implements ITypeConverter<UUID> {
      * <p>Finally, the Help class contains inner classes and interfaces that can be used to create custom help messages.</p>
      * <h4>IOptionRenderer and IParameterRenderer</h4>
      * <p>Renders a field annotated with {@link Option} or {@link Parameters} to an array of {@link Text} values.
-     * By default, these values are<ul>
+     * By default, these values are</p><ul>
      * <li>mandatory marker character (if the option/parameter is {@link Option#required() required})</li>
      * <li>short option name (empty for parameters)</li>
      * <li>comma or empty (empty for parameters)</li>
      * <li>long option names (the parameter {@link IParamLabelRenderer label} for parameters)</li>
      * <li>description</li>
      * </ul>
-     * Other components rely on this ordering.</p>
+     * <p>Other components rely on this ordering.</p>
      * <h4>Layout</h4>
      * <p>Delegates to the renderers to create {@link Text} values for the annotated fields, and uses a
      * {@link TextTable} to display these values in tabular format. Layout is responsible for deciding which values

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -3193,8 +3193,9 @@ public DuplicateOptionAnnotationsException(String msg) {
         }
 
         private static DuplicateOptionAnnotationsException create(String name, Field field1, Field field2) {
-            return new DuplicateOptionAnnotationsException("Option name '" + name + "' is used in both "
-                    + field1.getName() + " and " + field2.getName());
+            return new DuplicateOptionAnnotationsException("Option name '" + name + "' is used by both " +
+                    field1.getDeclaringClass().getName() + "." + field1.getName() + " and " +
+                    field2.getDeclaringClass().getName() + "." + field2.getName());
         }
     }
 

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -1684,7 +1684,7 @@ class ChildOption extends ParentOption {
             CommandLine.parse(new ChildOption(), "");
             fail("expected CommandLine$DuplicateOptionAnnotationsException");
         } catch (DuplicateOptionAnnotationsException ex) {
-            assertEquals("Option name '-p' is used in both path and text", ex.getMessage());
+            assertEquals("Option name '-p' is used by both picocli.CommandLineTest$2ParentOption.path and picocli.CommandLineTest$2ChildOption.text", ex.getMessage());
         }
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1287,7 +1287,7 @@ private List<Object> consumeArguments(Field field,
                                               Class<?> annotation,
                                               Arity arity,
                                               Stack<String> args,
-                                              ITypeConverter converter,
+                                              ITypeConverter<?> converter,
                                               Class<?> type) throws Exception {
             List<Object> result = new ArrayList<Object>();
             int index = 0;
@@ -1311,7 +1311,7 @@ private List<Object> consumeArguments(Field field,
         private int consumeOneArgument(Field field,
                                        Arity arity,
                                        Stack<String> args,
-                                       ITypeConverter converter,
+                                       ITypeConverter<?> converter,
                                        Class<?> type,
                                        List<Object> result, int index) throws Exception {
             String[] values = split(trim(args.pop()), field);

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -2243,7 +2243,7 @@ public Text[][] render(Option option, Field field, IParamLabelRenderer paramLabe
                 if (showDefault) {
                     Arrays.fill(result[result.length - 1], Text.EMPTY);
                     int row = empty(result[ROW_COUNT - 2][COLUMN_COUNT - 1]) ? ROW_COUNT - 2 : ROW_COUNT - 1;
-                    result[row][COLUMN_COUNT - 1] = new Text("Default: " + defaultValue);
+                    result[row][COLUMN_COUNT - 1] = new Text("  Default: " + defaultValue);
                 }
                 return result;
             }

File: src/test/java/picocli/Demo.java
Patch:
@@ -343,7 +343,7 @@ public void testUsageSubCommandStatus() {
             "                               * normal - Shows untracked files and directories.%n" +
             "                               * all - Also shows individual files in untracked%n" +
             "                                directories.%n" +
-            "                              Default: all%n";
+            "                                Default: all%n";
 
     static final String EXPECTED_USAGE_GITSTATUS_ANSI = "Show the working tree status.%n" +
             "Usage: @|bold git-status|@ [@|yellow <options>|@...] [--] [@|yellow <pathspec>|@...]%n" +
@@ -366,7 +366,7 @@ public void testUsageSubCommandStatus() {
             "                               * @|yellow normal|@ - Shows untracked files and directories.%n" +
             "                               * @|yellow all|@ - Also shows individual files in untracked%n" +
             "                                directories.%n" +
-            "                              Default: all%n";
+            "                                Default: all%n";
 
     public void testUsageSubCommandCommit() {
         try {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1793,6 +1793,7 @@ public Help(Object annotatedObject, ColorScheme colorScheme) {
             commandListHeading =   (commandListHeading == null)   ? "Commands:%n" : commandListHeading;
             separator =            (separator == null)            ? "=" : separator;
             parameterLabelRenderer = new DefaultParamLabelRenderer(separator);
+            Collections.sort(positionalParametersFields, new PositionalParametersSorter());
         }
 
         /** Registers all specified commands with this Help.

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -912,8 +912,8 @@ private static void init(Class<?> cls,
                               List<Field> positionalParametersFields) {
         Field[] declaredFields = cls.getDeclaredFields();
         for (Field field : declaredFields) {
+            field.setAccessible(true);
             if (field.isAnnotationPresent(Option.class)) {
-                field.setAccessible(true);
                 Option option = field.getAnnotation(Option.class);
                 if (option.required()) {
                     requiredFields.add(field);

File: src/test/java/picocli/Demo.java
Patch:
@@ -437,12 +437,12 @@ public void testUsageSubCommandCommit() {
             "                                affected.%n" +
             "  @|yellow -p|@, @|yellow --patch|@                 Use the interactive patch selection interface to%n" +
             "                                chose which changes to commit%n" +
-            "  @|yellow -C|@, @|yellow --reuse-message|@=@|italic <commit>|@%n" +
+            "  @|yellow -C|@, @|yellow --reuse-message|@=@|italic <commit|@@|italic >|@%n" +
             "                              Take an existing commit object, and reuse the log%n" +
             "                                message and the authorship information%n" +
             "                                (including the timestamp) when creating the%n" +
             "                                commit.%n" +
-            "  @|yellow -c|@, @|yellow --reedit-message|@=@|italic <commit>|@%n" +
+            "  @|yellow -c|@, @|yellow --reedit-message|@=@|italic <commi|@@|italic t>|@%n" +
             "                              Like -C, but with -c the editor is invoked, so%n" +
             "                                that the user canfurther edit the commit%n" +
             "                                message.%n" +

File: src/test/java/picocli/Demo.java
Patch:
@@ -419,7 +419,7 @@ public void testUsageSubCommandCommit() {
             "%n" +
             "Record changes to the repository.%n" +
             "%n" +
-            "@|bold git-commit|@ [@|yellow -ap|@] [@|yellow --fixup|@=@|italic <commit>|@] [@|yellow --squash|@=@|italic <commit>@|yellow ] [@|yellow -c|@=@|italic <commit>|@]%n" +
+            "@|bold git-commit|@ [@|yellow -ap|@] [@|yellow --fixup|@=@|italic <commit>|@] [@|yellow --squash|@=@|italic <commit>|@] [@|yellow -c|@=@|italic <commit>|@]%n" +
             "           [@|yellow -C|@=@|italic <commit>|@] [@|yellow -F|@=@|italic <file>|@] [@|yellow -m|@[=@|italic <msg>|@...]] [@|yellow <files>|@...]%n" +
             "%n" +
             "@|bold,underline Description:|@%n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1798,7 +1798,7 @@ public String detailedSynopsis(Comparator<Field> optionSort, boolean clusterBool
                     String optionNames = ShortestFirst.sort(option.names())[0];
                     optionText = optionText.append(colorScheme.optionText(optionNames));
 
-                    Text optionParamText = parameterLabelRenderer.renderParameterLabel(field, colorScheme.parameterStyles);
+                    Text optionParamText = parameterLabelRenderer.renderParameterLabel(field, colorScheme.optionParamStyles);
                     optionText = optionText.append(optionParamText);
                     if (!option.required()) {
                         optionText = optionText.append("]");

File: src/test/java/picocli/WindowsJansiDemo.java
Patch:
@@ -24,7 +24,7 @@
  * Requires Jansi on the classpath.
  */
 @Command(name = "picocli.WindowsJansiDemo")
-public class WindowsJansiDemo extends SubcommandDemo {
+public class WindowsJansiDemo extends Demo {
 public static void main(String[] args) {
     AnsiConsole.systemInstall();                      // Jansi magic
     if (System.getProperty("picocli.ansi") == null) { // no user preference

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -747,7 +747,7 @@ public void testCompactWithOptionParamAttachedColonSeparatorChar() {
         verifyCompact(compact, true, true, "out", fileArray("p1", "p2"));
     }
 
-    /** @see {@link #testGnuLongOptionsWithVariousSeparators()} */
+    /** See {@link #testGnuLongOptionsWithVariousSeparators()}  */
     @Test
     public void testDefaultSeparatorIsEquals() {
         assertEquals("=", new CommandLine(new CompactFields()).getSeparator());

File: src/test/java/picocli/Demo.java
Patch:
@@ -52,6 +52,7 @@ enum GitStatusMode {all, no, normal};
 
     @CommandLine.Command(name = "git-status",
             header = "Show the working tree status",
+            showDefaultValues = true,
             customSynopsis = "git-status [<options>...] [--] [<pathspec>...]",
             description = "Displays paths that have differences between the index file and the current HEAD commit, " +
                     "paths that have differences between the working tree and the index file, and paths in the " +

File: src/test/java/picocli/CommandLineTest.java
Patch:
@@ -79,7 +79,7 @@
 public class CommandLineTest {
     @Test
     public void testVersion() {
-        assertEquals("0.2.0", CommandLine.VERSION);
+        assertEquals("0.3.0", CommandLine.VERSION);
     }
 
     private static class SupportedTypes {

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -873,7 +873,7 @@ public void testNetstatUsageFormat() {
         @CommandLine.Command(name = "NETSTAT",
                 separator = " ",
                 abbreviateSynopsis = true,
-                header = "Displays protocol statistics and current TCP/IP network connections.\n")
+                header = "Displays protocol statistics and current TCP/IP network connections.%n")
         class Netstat {
             @Option(names="-a", description="Displays all connections and listening ports.")
             boolean displayAll;
@@ -940,7 +940,7 @@ class Netstat {
         sb.append(layout);
 
         String expected = String.format("" +
-                "Displays protocol statistics and current TCP/IP network connections.\n" +
+                "Displays protocol statistics and current TCP/IP network connections.%n" +
                 "%n" +
                 "NETSTAT [-a] [-b] [-e] [-f] [-n] [-o] [-p proto] [-q] [-r] [-s] [-t] [-x] [-y]%n" +
                 "        [interval]%n" +

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1737,9 +1737,9 @@ public int compare(Field f1, Field f2) {
                 Option o2 = f2.getAnnotation(Option.class);
                 Arity arity1 = Arity.forOption(f1);
                 Arity arity2 = Arity.forOption(f2);
-                int result = arity1.min - arity2.min;
+                int result = arity1.max - arity2.max;
                 if (result == 0) {
-                    result = arity1.max - arity2.max;
+                    result = arity1.min - arity2.min;
                 }
                 return result == 0 ? super.compare(f1, f2) : result;
             }

File: src/test/java/picocli/CommandLineHelpTest.java
Patch:
@@ -120,7 +120,7 @@ class Example {
     }
 
     @Test
-    public void testCreateDefaultOptionRenderer_ReturnsMinimalOptionRenderer() {
+    public void testCreateDefaultOptionRenderer_ReturnsDefaultOptionRenderer() {
         assertEquals(Help.DefaultOptionRenderer.class, Help.createDefaultOptionRenderer().getClass());
     }
 

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -1417,6 +1417,7 @@ public Help appendGenericUsageTo(String prefix, StringBuilder sb) {
          */
         public Help appendOptionDetailsTo(StringBuilder sb) {
             TextTable textTable = new TextTable();
+            textTable.parameterRenderer = this.parameterRenderer;
             Map<Option, Field> map = new TreeMap<Option, Field>(new AlphabeticOrder()); // default: sort options ABC
             map.putAll(option2Field); // options are stored in order of declaration for custom layouts
             for (Option option : map.keySet()) {

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -913,7 +913,7 @@ private void setPositionalArguments(String[] args, int index) throws Exception {
             int arity = positionalParametersField.getAnnotation(Parameters.class).arity();
             int length = args.length - index;
             assertNoMissingParameters(positionalParametersField, arity, length);
-            applyOption(positionalParametersField, Parameters.class, varargs, length, args[index], index, args);
+            applyOption(positionalParametersField, Parameters.class, varargs, arity, args[index], index, args);
         }
 
         @SuppressWarnings("unchecked")

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -832,7 +832,7 @@ private int applyOption(Field field, Class<?> annotation, boolean varargs, int a
                     if (element instanceof Collection) {
                         collection.addAll((Collection) element);
                     } else {
-                        collection.add(value);
+                        collection.add(element);
                     }
                 }
                 return converted.size();

File: src/main/java/picocli/CommandLine.java
Patch:
@@ -784,6 +784,9 @@ private int applyOption(Field field, Class<?> annotation, boolean varargs, int a
             updateHelpRequested(field);
             Class<?> cls = field.getType();
             int length = args.length - index;
+            if (arity == Integer.MAX_VALUE) {
+                arity = length; // consume all available args
+            }
             assertNoMissingParameters(field, arity, length);
             if (cls.isArray()) {
                 Class<?> type = cls.getComponentType();

