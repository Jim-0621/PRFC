File: src/test/java/org/joda/time/TestMutableDateTime_Properties.java
Patch:
@@ -244,7 +244,8 @@ public void testPropertyGetMonthOfYear() {
         assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());
         assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());
         assertEquals(9, test.monthOfYear().getMaximumTextLength(null));
-        assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));
+        int max = test.monthOfYear().getMaximumShortTextLength(null);
+        assertTrue(max == 3 || max == 4);  // for JDK17+
         test = new MutableDateTime(2004, 7, 9, 0, 0, 0, 0);
         assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH));
         assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH));

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -168,7 +168,7 @@ static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zi
                 Short index = Short.valueOf(count);
                 idToIndex.put(id, index);
                 indexToId.put(index, id);
-                if (++count == Integer.MAX_VALUE) {
+                if (++count == Short.MAX_VALUE) {
                     throw new InternalError("Too many time zone ids");
                 }
             }
@@ -177,7 +177,7 @@ static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zi
                 Short index = Short.valueOf(count);
                 idToIndex.put(id, index);
                 indexToId.put(index, id);
-                if (++count == Integer.MAX_VALUE) {
+                if (++count == Short.MAX_VALUE) {
                     throw new InternalError("Too many time zone ids");
                 }
             }

File: src/main/java/org/joda/time/DateMidnight.java
Patch:
@@ -134,6 +134,7 @@ public static DateMidnight now(Chronology chronology) {
      * This uses {@link ISODateTimeFormat#dateTimeParser()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed date-midnight, not null
      * @since 2.0
      */
     @FromString
@@ -146,6 +147,7 @@ public static DateMidnight parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed date-midnight, not null
      * @since 2.0
      */
     public static DateMidnight parse(String str, DateTimeFormatter formatter) {

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -142,6 +142,7 @@ public static DateTime now(Chronology chronology) {
      * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed date-time, not null
      * @since 2.0
      */
     @FromString
@@ -154,6 +155,7 @@ public static DateTime parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed date-time, not null
      * @since 2.0
      */
     public static DateTime parse(String str, DateTimeFormatter formatter) {

File: src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -1235,6 +1235,7 @@ public String toString() {
      * referring to the id is written out. When the stub is read in, it
      * replaces itself with a DateTimeZone object.
      * @return a stub object to go in the stream
+     * @throws ObjectStreamException if the stream is invalid
      */
     protected Object writeReplace() throws ObjectStreamException {
         return new Stub(iID);

File: src/main/java/org/joda/time/Duration.java
Patch:
@@ -54,6 +54,7 @@ public final class Duration
      * This parses the format {@code PTa.bS}, as per {@link #toString()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed duration, not null
      * @since 2.0
      */
     @FromString

File: src/main/java/org/joda/time/IllegalFieldValueException.java
Patch:
@@ -340,6 +340,8 @@ public String getMessage() {
     /**
      * Provide additional detail by prepending a message to the existing message.
      * A colon is separator is automatically inserted between the messages.
+     * 
+     * @param message the message to prepend
      * @since 1.3
      */
     public void prependMessage(String message) {

File: src/main/java/org/joda/time/Interval.java
Patch:
@@ -69,6 +69,7 @@ public final class Interval
      * offset of the default time-zone. See also {@link #parseWithOffset(String)}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed interval, not null
      * @since 2.0
      */
     public static Interval parse(String str) {
@@ -99,6 +100,7 @@ public static Interval parse(String str) {
      * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed interval, not null
      * @since 2.9
      */
     public static Interval parseWithOffset(String str) {

File: src/main/java/org/joda/time/MonthDay.java
Patch:
@@ -142,6 +142,7 @@ public static MonthDay now(Chronology chronology) {
      * This uses {@link ISODateTimeFormat#localDateParser()} or the format {@code --MM-dd}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed month-day, not null
      * @since 2.0
      */
     @FromString
@@ -154,6 +155,7 @@ public static MonthDay parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed month-day, not null
      * @since 2.0
      */
     public static MonthDay parse(String str, DateTimeFormatter formatter) {

File: src/main/java/org/joda/time/MutableDateTime.java
Patch:
@@ -142,6 +142,7 @@ public static MutableDateTime now(Chronology chronology) {
      * This uses {@link ISODateTimeFormat#dateTimeParser()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed date-time, not null
      * @since 2.0
      */
     @FromString
@@ -154,6 +155,7 @@ public static MutableDateTime parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed date-time, not null
      * @since 2.0
      */
     public static MutableDateTime parse(String str, DateTimeFormatter formatter) {

File: src/main/java/org/joda/time/MutableInterval.java
Patch:
@@ -65,6 +65,7 @@ public class MutableInterval
      * 'datetime/period' or 'period/datetime'.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed interval, not null
      * @since 2.0
      */
     public static MutableInterval parse(String str) {

File: src/main/java/org/joda/time/MutablePeriod.java
Patch:
@@ -67,6 +67,7 @@ public class MutablePeriod
      * This uses {@link ISOPeriodFormat#standard()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed period, not null
      * @since 2.0
      */
     @FromString
@@ -79,6 +80,7 @@ public static MutablePeriod parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed period, not null
      * @since 2.0
      */
     public static MutablePeriod parse(String str, PeriodFormatter formatter) {

File: src/main/java/org/joda/time/Period.java
Patch:
@@ -74,6 +74,7 @@ public final class Period
      * This uses {@link ISOPeriodFormat#standard()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed period, not null
      * @since 2.0
      */
     @FromString
@@ -86,6 +87,7 @@ public static Period parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed period, not null
      * @since 2.0
      */
     public static Period parse(String str, PeriodFormatter formatter) {
@@ -250,6 +252,7 @@ public static Period millis(int millis) {
      *
      * @param start  the start of the period, must not be null
      * @param end  the end of the period, must not be null
+     * @return the period, not null
      * @throws IllegalArgumentException if the partials are null or invalid
      * @since 1.1
      */

File: src/main/java/org/joda/time/ReadableDateTime.java
Patch:
@@ -195,6 +195,7 @@ public interface ReadableDateTime extends ReadableInstant {
      * Output the instant using the specified format pattern.
      *
      * @param pattern  pattern specification
+     * @return the formatted output, not null
      * @throws IllegalArgumentException  if pattern is invalid
      * @see  org.joda.time.format.DateTimeFormat
      */
@@ -205,6 +206,7 @@ public interface ReadableDateTime extends ReadableInstant {
      *
      * @param pattern  pattern specification
      * @param locale  Locale to use, or null for default
+     * @return the formatted output, not null
      * @throws IllegalArgumentException  if pattern is invalid
      * @see  org.joda.time.format.DateTimeFormat
      */

File: src/main/java/org/joda/time/ReadableInstant.java
Patch:
@@ -145,7 +145,7 @@ public interface ReadableInstant extends Comparable<ReadableInstant> {
      * <p>
      * To compare two instants for absolute time (ie. UTC milliseconds 
      * ignoring the chronology), use {@link #isEqual(ReadableInstant)} or
-     * {@link #compareTo(Object)}.
+     * {@link #compareTo}.
      *
      * @param readableInstant  a readable instant to check against
      * @return true if millisecond and chronology are equal, false if

File: src/main/java/org/joda/time/TimeOfDay.java
Patch:
@@ -163,6 +163,7 @@ public static TimeOfDay fromDateFields(Date date) {
      * This method uses the UTC time zone internally.
      *
      * @param millisOfDay  the number of milliseconds into a day to convert
+     * @return the time, not null
      */
     public static TimeOfDay fromMillisOfDay(long millisOfDay) {
         return fromMillisOfDay(millisOfDay, null);
@@ -178,6 +179,7 @@ public static TimeOfDay fromMillisOfDay(long millisOfDay) {
      *
      * @param millisOfDay  the number of milliseconds into a day to convert
      * @param chrono  the chronology, null means ISO chronology
+     * @return the time, not null
      */
     public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {
         chrono = DateTimeUtils.getChronology(chrono);

File: src/main/java/org/joda/time/YearMonth.java
Patch:
@@ -134,6 +134,7 @@ public static YearMonth now(Chronology chronology) {
      * This uses {@link ISODateTimeFormat#localDateParser()}.
      * 
      * @param str  the string to parse, not null
+     * @return the parsed year-month, not null
      * @since 2.0
      */
     @FromString
@@ -146,6 +147,7 @@ public static YearMonth parse(String str) {
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null
+     * @return the parsed year-month, not null
      * @since 2.0
      */
     public static YearMonth parse(String str, DateTimeFormatter formatter) {

File: src/main/java/org/joda/time/base/BasePartial.java
Patch:
@@ -287,6 +287,7 @@ protected void setValues(int[] values) {
      * Output the date using the specified format pattern.
      *
      * @param pattern  the pattern specification, null means use <code>toString</code>
+     * @return the formatted output, not null
      * @see org.joda.time.format.DateTimeFormat
      */
     public String toString(String pattern) {
@@ -301,6 +302,8 @@ public String toString(String pattern) {
      *
      * @param pattern  the pattern specification, null means use <code>toString</code>
      * @param locale  Locale to use, null means default
+     * @return the formatted output, not null
+     * @throws IllegalArgumentException if the pattern is invalid
      * @see org.joda.time.format.DateTimeFormat
      */
     public String toString(String pattern, Locale locale) throws IllegalArgumentException {

File: src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java
Patch:
@@ -124,6 +124,7 @@ protected static int between(ReadablePartial start, ReadablePartial end, Readabl
      *
      * @param period  the period to get the number of hours from, must not be null
      * @param millisPerUnit  the number of milliseconds in one standard unit of this period
+     * @return the int value
      * @throws IllegalArgumentException if the period contains imprecise duration values
      */
     protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {

File: src/main/java/org/joda/time/chrono/LenientChronology.java
Patch:
@@ -39,6 +39,7 @@ public final class LenientChronology extends AssembledChronology {
      * Create a LenientChronology for any chronology.
      *
      * @param base the chronology to wrap
+     * @return the chronology, not null
      * @throws IllegalArgumentException if chronology is null
      */
     public static LenientChronology getInstance(Chronology base) {

File: src/main/java/org/joda/time/chrono/LimitChronology.java
Patch:
@@ -59,6 +59,7 @@ public final class LimitChronology extends AssembledChronology {
      * @param base  base chronology to wrap
      * @param lowerLimit  inclusive lower limit, or null if none
      * @param upperLimit  exclusive upper limit, or null if none
+     * @return the chronology, not null
      * @throws IllegalArgumentException if chronology is null or limits are invalid
      */
     public static LimitChronology getInstance(Chronology base,

File: src/main/java/org/joda/time/chrono/StrictChronology.java
Patch:
@@ -39,6 +39,7 @@ public final class StrictChronology extends AssembledChronology {
      * Create a StrictChronology for any chronology.
      *
      * @param base the chronology to wrap
+     * @return the chronology, not null
      * @throws IllegalArgumentException if chronology is null
      */
     public static StrictChronology getInstance(Chronology base) {

File: src/main/java/org/joda/time/chrono/ZonedChronology.java
Patch:
@@ -53,6 +53,7 @@ public final class ZonedChronology extends AssembledChronology {
      *
      * @param base base chronology to wrap
      * @param zone the time zone
+     * @return the chronology, not null
      * @throws IllegalArgumentException if chronology or time zone is null
      */
     public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {

File: src/main/java/org/joda/time/convert/StringConverter.java
Patch:
@@ -157,7 +157,6 @@ public long getDurationMillis(Object object) {
      * @param period  period to get modified
      * @param object  the String to convert, must not be null
      * @param chrono  the chronology to use
-     * @return the millisecond duration
      * @throws ClassCastException if the object is invalid
      */
     public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) {

File: src/main/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java
Patch:
@@ -277,6 +277,8 @@ public int getLeapAmount() {
     /**
      * If this field were to leap, then it would be in units described by the
      * returned duration. If this field doesn't ever leap, null is returned.
+     * 
+     * @return the duration field
      */
     public DurationField getLeapDurationField() {
         return getField().getLeapDurationField();

File: src/main/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -45,6 +45,8 @@ public abstract class BaseDateTimeField extends DateTimeField {
 
     /**
      * Constructor.
+     * 
+     * @param type  the field type
      */
     protected BaseDateTimeField(DateTimeFieldType type) {
         super();

File: src/main/java/org/joda/time/field/FieldUtils.java
Patch:
@@ -246,6 +246,7 @@ public static int safeMultiplyToInt(long val1, long val2) {
     /**
      * Verify that input values are within specified bounds.
      * 
+     * @param field  the field to check
      * @param value  the value to check
      * @param lowerBound  the lower bound allowed for value
      * @param upperBound  the upper bound allowed for value
@@ -263,6 +264,7 @@ public static void verifyValueBounds(DateTimeField field,
     /**
      * Verify that input values are within specified bounds.
      * 
+     * @param fieldType  the field type to check
      * @param value  the value to check
      * @param lowerBound  the lower bound allowed for value
      * @param upperBound  the upper bound allowed for value
@@ -281,6 +283,7 @@ public static void verifyValueBounds(DateTimeFieldType fieldType,
     /**
      * Verify that input values are within specified bounds.
      * 
+     * @param fieldName  the field name to check
      * @param value  the value to check
      * @param lowerBound  the lower bound allowed for value
      * @param upperBound  the upper bound allowed for value

File: src/main/java/org/joda/time/format/DateTimePrinter.java
Patch:
@@ -78,6 +78,7 @@ void printTo(StringBuffer buf, long instant, Chronology chrono,
      * this millisecond value
      * @param displayZone  the time zone to use, null means local time
      * @param locale  the locale to use, null means default locale
+     * @throws IOException if an IO error occurs
      */
     void printTo(Writer out, long instant, Chronology chrono,
                  int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
@@ -98,6 +99,7 @@ void printTo(Writer out, long instant, Chronology chrono,
      * @param out  formatted partial is written out, not null
      * @param partial  partial to format, not null
      * @param locale  the locale to use, null means default locale
+     * @throws IOException if an IO error occurs
      */
     void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException;
 

File: src/main/java/org/joda/time/format/InternalPrinter.java
Patch:
@@ -52,6 +52,7 @@ interface InternalPrinter {
      * this millisecond value
      * @param displayZone  the time zone to use, null means local time
      * @param locale  the locale to use, null means default locale
+     * @throws IOException if an IO error occurs
      */
     void printTo(Appendable appendable, long instant, Chronology chrono,
                  int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
@@ -62,6 +63,7 @@ void printTo(Appendable appendable, long instant, Chronology chrono,
      * @param appendable  formatted instant is appended to, not null
      * @param partial  partial to format, not null
      * @param locale  the locale to use, null means default locale
+     * @throws IOException if an IO error occurs
      */
     void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException;
 

File: src/main/java/org/joda/time/format/PeriodFormat.java
Patch:
@@ -196,6 +196,7 @@ public static PeriodFormatter wordBased() {
      * Available languages are English, Danish, Dutch, French, German, Japanese,
      * Polish, Portuguese and Spanish.
      * 
+     * @param locale the locale
      * @return the formatter, not null
      * @since 2.0, regex since 2.5
      */

File: src/main/java/org/joda/time/format/PeriodFormatter.java
Patch:
@@ -222,6 +222,7 @@ public void printTo(StringBuffer buf, ReadablePeriod period) {
      *
      * @param out  the formatted period is written out
      * @param period  the period to format, not null
+     * @throws IOException if an IO error occurs
      */
     public void printTo(Writer out, ReadablePeriod period) throws IOException {
         checkPrinter();

File: src/main/java/org/joda/time/format/PeriodPrinter.java
Patch:
@@ -77,6 +77,7 @@ public interface PeriodPrinter {
      * @param out  the formatted period is written out
      * @param period  the period to format
      * @param locale  the locale to use
+     * @throws IOException if an IO error occurs
      */
     void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException;
 

File: src/main/java/org/joda/time/Period.java
Patch:
@@ -1650,7 +1650,7 @@ public Period normalizedStandard(PeriodType type) {
             if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
                 int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
                 result = result.withYears(normalizedYears);
-                totalMonths = totalMonths - (normalizedYears * 12);
+                totalMonths = totalMonths - (normalizedYears * 12L);
             }
             if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
                 int normalizedMonths = FieldUtils.safeToInt(totalMonths);

File: src/main/java/org/joda/time/chrono/BasicChronology.java
Patch:
@@ -177,9 +177,9 @@ public long getDateTimeMillis(
         FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);
         FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);
         FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);
-        long millisOfDay = hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
-                        + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
-                        + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
+        long millisOfDay = (long) hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
+                        + (long) minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
+                        + (long) secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
                         + millisOfSecond;
         return getDateTimeMillis0(year, monthOfYear, dayOfMonth, (int) millisOfDay);
     }

File: src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -2382,7 +2382,7 @@ public int parseInto(DateTimeParserBucket bucket, CharSequence text, int positio
                     prefix = text.subSequence(pos, i + 1).toString();
                     pos += prefix.length();
                     String prefixLookup = prefix;
-                    if (i < textLen) {
+                    if (i < textLen - 1) {
                         prefixLookup += text.charAt(i + 1);
                     }
                     suffixSet = GROUPED_IDS.get(prefixLookup);
@@ -2631,7 +2631,7 @@ public int parseInto(DateTimeParserBucket bucket, CharSequence text, int positio
                 bucket.restoreState(originalState);
             }
 
-            if (bestValidPos > position || (bestValidPos == position && isOptional)) {
+            if (bestValidPos > position || (bestValidPos == position && isOptional)) {  // LGTM ignore
                 // Restore the state to the best valid parse.
                 if (bestValidState != null) {
                     bucket.restoreState(bestValidState);

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -1775,7 +1775,7 @@ long getFieldValue(ReadablePeriod period) {
                     if (isZero(period) && iFieldFormatters[iFieldType] == this) {
                         int i = Math.min(iFieldType, 8);  // line split out for IBM JDK
                         i--;                              // see bug 1660490
-                        for (; i >= 0 && i <= MAX_FIELD; i--) {
+                        for (; i >= 0; i--) {
                             if (isSupported(type, i) && iFieldFormatters[i] != null) {
                                 return Long.MAX_VALUE;
                             }

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -168,7 +168,7 @@ static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zi
                 Short index = Short.valueOf(count);
                 idToIndex.put(id, index);
                 indexToId.put(index, id);
-                if (++count == 0) {
+                if (++count == Integer.MAX_VALUE) {
                     throw new InternalError("Too many time zone ids");
                 }
             }
@@ -177,7 +177,7 @@ static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zi
                 Short index = Short.valueOf(count);
                 idToIndex.put(id, index);
                 indexToId.put(index, id);
-                if (++count == 0) {
+                if (++count == Integer.MAX_VALUE) {
                     throw new InternalError("Too many time zone ids");
                 }
             }

File: src/main/java/org/joda/time/format/DateTimeFormatter.java
Patch:
@@ -399,7 +399,9 @@ public DateTimeZone getZone() {
      * @since 1.1
      */
     public DateTimeFormatter withPivotYear(Integer pivotYear) {
-        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {
+        long oldVal = iPivotYear == null ? Long.MIN_VALUE : iPivotYear;
+        long newVal = pivotYear == null ? Long.MIN_VALUE : pivotYear;
+        if (oldVal == newVal) {
             return this;
         }
         return new DateTimeFormatter(iPrinter, iParser, iLocale,

File: src/main/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -470,7 +470,6 @@ private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, bool
      *
      * @param bld  the builder
      * @param extended  whether to append the separator
-     * @param sep  the separator
      * @since 1.1
      */
     private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) {

File: src/main/java/org/joda/time/Period.java
Patch:
@@ -267,7 +267,7 @@ public static Period fieldDifference(ReadablePartial start, ReadablePartial end)
                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields");
             }
             types[i] = start.getFieldType(i).getDurationType();
-            if (i > 0 && types[i - 1] == types[i]) {
+            if (i > 0 && types[i - 1].equals(types[i])) {
                 throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields");
             }
             values[i] = end.getValue(i) - start.getValue(i);

File: src/main/java/org/joda/time/PeriodType.java
Patch:
@@ -646,7 +646,7 @@ public boolean isSupported(DurationFieldType type) {
      */
     public int indexOf(DurationFieldType type) {
         for (int i = 0, isize = size(); i < isize; i++) {
-            if (iTypes[i] == type) {
+            if (iTypes[i].equals(type)) {
                 return i;
             }
         }

File: src/main/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -79,6 +79,8 @@ protected ISODateTimeFormat() {
      * formatter that best fits. This can be useful for outputting
      * less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).
      * <p>
+     * Note that parsing is often not supported by the resulting formatter, especially in basic mode.
+     * <p>
      * The list provided may have overlapping fields, such as dayOfWeek and
      * dayOfMonth. In this case, the style is chosen based on the following
      * list, thus in the example, the calendar style is chosen as dayOfMonth

File: src/main/java/org/joda/time/Period.java
Patch:
@@ -107,7 +107,7 @@ public static Period parse(String str, PeriodFormatter formatter) {
      * @return the period
      */
     public static Period years(int years) {
-        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());
+        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());
     }
 
     /**

File: src/main/java/org/joda/time/LocalDate.java
Patch:
@@ -730,7 +730,7 @@ public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {
         long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;
         long instant = zone.convertLocalToUTC(localMillis, false);
         instant = chrono.dayOfMonth().roundFloor(instant);
-        return new DateTime(instant, chrono);
+        return new DateTime(instant, chrono).withEarlierOffsetAtOverlap();
     }
 
     //-----------------------------------------------------------------------

File: src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -75,7 +75,7 @@
  * </ul>
  * <p>
  * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only
- * supports long format time zone ids. Thus EST and ECT are not accepted.
+ * supports long format time zone ids. Thus PST and ECT are not accepted.
  * However, the factory that accepts a TimeZone will attempt to convert from
  * the old short id to a suitable long id.
  * <p>

File: src/main/java/org/joda/time/format/DateTimeParserBucket.java
Patch:
@@ -448,7 +448,9 @@ public long computeMillis(boolean resetFields, CharSequence text) {
             }
             if (resetFields) {
                 for (int i = 0; i < count; i++) {
-                    millis = savedFields[i].set(millis, i == (count - 1));
+                    if (!savedFields[i].iField.isLenient()) {
+                        millis = savedFields[i].set(millis, i == (count - 1));
+                    }
                 }
             }
         } catch (IllegalFieldValueException e) {

File: src/test/java/org/joda/time/TestBaseSingleFieldPeriod.java
Patch:
@@ -147,7 +147,7 @@ public void testFactory_standardPeriodIn_RPeriod() {
             Single.standardPeriodIn(Period.months(1), DateTimeConstants.MILLIS_PER_DAY);
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestDays.java
Patch:
@@ -166,7 +166,7 @@ public void testFactory_standardDaysIn_RPeriod() {
             Days.standardDaysIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -181,13 +181,13 @@ public void testFactory_parseDays_String() {
             Days.parseDays("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Days.parseDays("P1DT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestHours.java
Patch:
@@ -135,7 +135,7 @@ public void testFactory_standardHoursIn_RPeriod() {
             Hours.standardHoursIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -150,13 +150,13 @@ public void testFactory_parseHours_String() {
             Hours.parseHours("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Hours.parseHours("P1DT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestMinutes.java
Patch:
@@ -125,7 +125,7 @@ public void testFactory_standardMinutesIn_RPeriod() {
             Minutes.standardMinutesIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -140,13 +140,13 @@ public void testFactory_parseMinutes_String() {
             Minutes.parseMinutes("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Minutes.parseMinutes("P1DT1M");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestMonths.java
Patch:
@@ -191,13 +191,13 @@ public void testFactory_parseMonths_String() {
             Months.parseMonths("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Months.parseMonths("P1MT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestSeconds.java
Patch:
@@ -122,7 +122,7 @@ public void testFactory_standardSecondsIn_RPeriod() {
             Seconds.standardSecondsIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -137,13 +137,13 @@ public void testFactory_parseSeconds_String() {
             Seconds.parseSeconds("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Seconds.parseSeconds("P1DT1S");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestWeeks.java
Patch:
@@ -124,7 +124,7 @@ public void testFactory_standardWeeksIn_RPeriod() {
             Weeks.standardWeeksIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -139,13 +139,13 @@ public void testFactory_parseWeeks_String() {
             Weeks.parseWeeks("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Weeks.parseWeeks("P1WT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestYears.java
Patch:
@@ -122,13 +122,13 @@ public void testFactory_parseYears_String() {
             Years.parseYears("P1M1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Years.parseYears("P1YT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestBaseSingleFieldPeriod.java
Patch:
@@ -147,7 +147,7 @@ public void testFactory_standardPeriodIn_RPeriod() {
             Single.standardPeriodIn(Period.months(1), DateTimeConstants.MILLIS_PER_DAY);
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestDays.java
Patch:
@@ -166,7 +166,7 @@ public void testFactory_standardDaysIn_RPeriod() {
             Days.standardDaysIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -181,13 +181,13 @@ public void testFactory_parseDays_String() {
             Days.parseDays("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Days.parseDays("P1DT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestHours.java
Patch:
@@ -135,7 +135,7 @@ public void testFactory_standardHoursIn_RPeriod() {
             Hours.standardHoursIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -150,13 +150,13 @@ public void testFactory_parseHours_String() {
             Hours.parseHours("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Hours.parseHours("P1DT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestMinutes.java
Patch:
@@ -125,7 +125,7 @@ public void testFactory_standardMinutesIn_RPeriod() {
             Minutes.standardMinutesIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -140,13 +140,13 @@ public void testFactory_parseMinutes_String() {
             Minutes.parseMinutes("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Minutes.parseMinutes("P1DT1M");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestMonths.java
Patch:
@@ -191,13 +191,13 @@ public void testFactory_parseMonths_String() {
             Months.parseMonths("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Months.parseMonths("P1MT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestSeconds.java
Patch:
@@ -122,7 +122,7 @@ public void testFactory_standardSecondsIn_RPeriod() {
             Seconds.standardSecondsIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -137,13 +137,13 @@ public void testFactory_parseSeconds_String() {
             Seconds.parseSeconds("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Seconds.parseSeconds("P1DT1S");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestWeeks.java
Patch:
@@ -124,7 +124,7 @@ public void testFactory_standardWeeksIn_RPeriod() {
             Weeks.standardWeeksIn(Period.months(1));
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 
@@ -139,13 +139,13 @@ public void testFactory_parseWeeks_String() {
             Weeks.parseWeeks("P1Y1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Weeks.parseWeeks("P1WT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/test/java/org/joda/time/TestYears.java
Patch:
@@ -122,13 +122,13 @@ public void testFactory_parseYears_String() {
             Years.parseYears("P1M1D");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
         try {
             Years.parseYears("P1YT1H");
             fail();
         } catch (IllegalArgumentException ex) {
-            // expeceted
+            // expected
         }
     }
 

File: src/main/java/org/joda/time/Instant.java
Patch:
@@ -75,7 +75,7 @@ public static Instant now() {
 
     //-----------------------------------------------------------------------
     /**
-     * Parses a {@code Instant} from the specified string.
+     * Parses an {@code Instant} from the specified string.
      * <p>
      * This uses {@link ISODateTimeFormat#dateTimeParser()}.
      * 
@@ -88,7 +88,7 @@ public static Instant parse(String str) {
     }
 
     /**
-     * Parses a {@code Instant} from the specified string using a formatter.
+     * Parses an {@code Instant} from the specified string using a formatter.
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null

File: src/main/java/org/joda/time/Interval.java
Patch:
@@ -58,7 +58,7 @@ public final class Interval
 
     //-----------------------------------------------------------------------
     /**
-     * Parses a {@code Interval} from the specified string.
+     * Parses an {@code Interval} from the specified string.
      * <p>
      * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}
      * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',
@@ -76,7 +76,7 @@ public static Interval parse(String str) {
     }
 
     /**
-     * Parses a {@code Interval} from the specified string, using any offset it contains.
+     * Parses an {@code Interval} from the specified string, using any offset it contains.
      * <p>
      * The String formats are described by
      * {@link ISODateTimeFormat#dateTimeParser()}{@code .withOffsetParsed()}

File: src/main/java/org/joda/time/Instant.java
Patch:
@@ -75,7 +75,7 @@ public static Instant now() {
 
     //-----------------------------------------------------------------------
     /**
-     * Parses a {@code Instant} from the specified string.
+     * Parses an {@code Instant} from the specified string.
      * <p>
      * This uses {@link ISODateTimeFormat#dateTimeParser()}.
      * 
@@ -88,7 +88,7 @@ public static Instant parse(String str) {
     }
 
     /**
-     * Parses a {@code Instant} from the specified string using a formatter.
+     * Parses an {@code Instant} from the specified string using a formatter.
      * 
      * @param str  the string to parse, not null
      * @param formatter  the formatter to use, not null

File: src/main/java/org/joda/time/Interval.java
Patch:
@@ -58,7 +58,7 @@ public final class Interval
 
     //-----------------------------------------------------------------------
     /**
-     * Parses a {@code Interval} from the specified string.
+     * Parses an {@code Interval} from the specified string.
      * <p>
      * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}
      * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',
@@ -76,7 +76,7 @@ public static Interval parse(String str) {
     }
 
     /**
-     * Parses a {@code Interval} from the specified string, using any offset it contains.
+     * Parses an {@code Interval} from the specified string, using any offset it contains.
      * <p>
      * The String formats are described by
      * {@link ISODateTimeFormat#dateTimeParser()}{@code .withOffsetParsed()}

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -572,7 +572,7 @@ public PeriodFormatterBuilder appendMillis() {
     /**
      * Instruct the printer to emit an integer millis field, if supported.
      * <p>
-     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.
+     * The number of parsed digits can be controlled using {@link #maximumParsedDigits(int)}.
      *
      * @return this PeriodFormatterBuilder
      */

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -572,7 +572,7 @@ public PeriodFormatterBuilder appendMillis() {
     /**
      * Instruct the printer to emit an integer millis field, if supported.
      * <p>
-     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.
+     * The number of parsed digits can be controlled using {@link #maximumParsedDigits(int)}.
      *
      * @return this PeriodFormatterBuilder
      */

File: src/example/org/joda/example/time/DateTimeBrowser.java
Patch:
@@ -51,7 +51,7 @@
 
 import org.joda.time.DateTime;
 
-/** DateTimeBrowser is a Java Swing application which reads a file contining
+/** DateTimeBrowser is a Java Swing application which reads a file containing
  * strings and displays DateTime values in a JTable.<p>
  * The input strings must be suitable for instantiation
  * of DateTime objects.  The file is read, and an attempt is made

File: src/main/java/org/joda/time/Chronology.java
Patch:
@@ -75,7 +75,7 @@ public abstract class Chronology {
     /**
      * Returns an instance of this Chronology that operates in the UTC time
      * zone. Chronologies that do not operate in a time zone or are already
-     * UTC must return themself.
+     * UTC must return themselves.
      *
      * @return a version of this chronology that ignores time zones
      */

File: src/main/java/org/joda/time/DateMidnight.java
Patch:
@@ -42,7 +42,7 @@
  * This class uses a Chronology internally. The Chronology determines how the
  * millisecond instant value is converted into the date time fields.
  * The default Chronology is <code>ISOChronology</code> which is the agreed
- * international standard and compatable with the modern Gregorian calendar.
+ * international standard and compatible with the modern Gregorian calendar.
  *
  * <p>Each individual field can be queried in two ways:
  * <ul>
@@ -922,7 +922,7 @@ public DateMidnight withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      * @since 1.3

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -1634,7 +1634,7 @@ public DateTime withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      * @since 1.3
@@ -2268,7 +2268,7 @@ public DateTime setCopy(String text) {
          * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result
          * to force the later time during a DST overlap if desired.
          * <p>
-         * From v2.2, this method handles a daylight svaings time gap, setting the
+         * From v2.2, this method handles a daylight savings time gap, setting the
          * time to the last instant before the gap.
          * <p>
          * The DateTime attached to this property is unchanged by this call.
@@ -2297,7 +2297,7 @@ public DateTime withMaximumValue() {
          * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result
          * to force the earlier time during a DST overlap if desired.
          * <p>
-         * From v2.2, this method handles a daylight svaings time gap, setting the
+         * From v2.2, this method handles a daylight savings time gap, setting the
          * time to the first instant after the gap.
          * <p>
          * The DateTime attached to this property is unchanged by this call.

File: src/main/java/org/joda/time/DateTimeConstants.java
Patch:
@@ -103,7 +103,7 @@ public class DateTimeConstants {
     /**
      * Constant (1) representing AD, years after zero (from Calendar).
      * <p>
-     * All new chronologies with differrent Era values should try to assign
+     * All new chronologies with different Era values should try to assign
      * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned
      * the value 1. Earlier eras are assigned sequentially smaller numbers.
      * Later eras are assigned sequentially greater numbers.
@@ -112,7 +112,7 @@ public class DateTimeConstants {
     /**
      * Alternative constant (1) representing CE, Common Era (secular).
      * <p>
-     * All new chronologies with differrent Era values should try to assign
+     * All new chronologies with different Era values should try to assign
      * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned
      * the value 1. Earlier eras are assigned sequentially smaller numbers.
      * Later eras are assigned sequentially greater numbers.

File: src/main/java/org/joda/time/DateTimeField.java
Patch:
@@ -251,7 +251,7 @@ public abstract class DateTimeField {
      * <p>
      * Partial instants only contain some fields. This may result in a maximum
      * possible value, such as TimeOfDay normally being limited to 23:59:59:999.
-     * If ths limit is reached by the addition, this method will wrap back to
+     * If this limit is reached by the addition, this method will wrap back to
      * 00:00:00.000. In fact, you would generally only use this method for
      * classes that have a limitation such as this.
      * <p>

File: src/main/java/org/joda/time/DateTimeFieldType.java
Patch:
@@ -435,7 +435,7 @@ private static class StandardDateTimeFieldType extends DateTimeFieldType {
          * Constructor.
          * 
          * @param name  the name to use
-         * @param ordinal  the byte value for the oridinal index
+         * @param ordinal  the byte value for the ordinal index
          * @param unitType  the unit duration type
          * @param rangeType  the range duration type
          */

File: src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -1259,7 +1259,7 @@ public java.util.TimeZone toTimeZone() {
     public abstract boolean equals(Object object);
 
     /**
-     * Gets a hash code compatable with equals.
+     * Gets a hash code compatible with equals.
      * 
      * @return suitable hashcode
      */

File: src/main/java/org/joda/time/Days.java
Patch:
@@ -62,7 +62,7 @@ public final class Days extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of days that can be stored in this object. */
     public static final Days MIN_VALUE = new Days(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.days());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380865L;
@@ -106,7 +106,7 @@ public static Days days(int days) {
     //-----------------------------------------------------------------------
     /**
      * Creates a <code>Days</code> representing the number of whole days
-     * between the two specified datetimes. This method corectly handles
+     * between the two specified datetimes. This method correctly handles
      * any daylight savings time changes that may occur during the interval.
      *
      * @param start  the start instant, must not be null
@@ -144,7 +144,7 @@ public static Days daysBetween(ReadablePartial start, ReadablePartial end) {
 
     /**
      * Creates a <code>Days</code> representing the number of whole days
-     * in the specified interval. This method corectly handles any daylight
+     * in the specified interval. This method correctly handles any daylight
      * savings time changes that may occur during the interval.
      *
      * @param interval  the interval to extract days from, null returns zero

File: src/main/java/org/joda/time/Hours.java
Patch:
@@ -64,7 +64,7 @@ public final class Hours extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of hours that can be stored in this object. */
     public static final Hours MIN_VALUE = new Hours(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.hours());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380864L;

File: src/main/java/org/joda/time/IllegalFieldValueException.java
Patch:
@@ -32,7 +32,7 @@ public class IllegalFieldValueException extends IllegalArgumentException {
      * @param fieldName  the field name
      * @param value  the value rejected
      * @param lowerBound  the lower bound allowed
-     * @param upperBound  the uppe bound allowed
+     * @param upperBound  the upper bound allowed
      * @param explain  an explanation
      * @return the message
      */

File: src/main/java/org/joda/time/LocalDate.java
Patch:
@@ -509,7 +509,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
     }
 
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * <p>
      * This method is required to support the <code>ReadablePartial</code>
      * interface. The supported fields are Year, MonthOfYear and DayOfMonth.
@@ -1567,7 +1567,7 @@ public LocalDate withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      */

File: src/main/java/org/joda/time/LocalDateTime.java
Patch:
@@ -564,7 +564,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
     }
 
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * <p>
      * This method is required to support the <code>ReadablePartial</code>
      * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
@@ -1700,7 +1700,7 @@ public LocalDateTime withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      */

File: src/main/java/org/joda/time/LocalTime.java
Patch:
@@ -560,7 +560,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
     }
 
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * <p>
      * This method is required to support the <code>ReadablePartial</code>
      * interface. The supported fields are HourOfDay, MinuteOfHour,
@@ -1264,7 +1264,7 @@ public Property millisOfDay() {
      * setting the time fields from this instance and the date fields from
      * the current date.
      *
-     * @return this time as a datetime using todays date
+     * @return this time as a datetime using today's date
      */
     public DateTime toDateTimeToday() {
         return toDateTimeToday(null);
@@ -1279,7 +1279,7 @@ public DateTime toDateTimeToday() {
      * specified.
      *
      * @param zone  the zone to use, null means default
-     * @return this time as a datetime using todays date
+     * @return this time as a datetime using today's date
      */
     public DateTime toDateTimeToday(DateTimeZone zone) {
         Chronology chrono = getChronology().withZone(zone);

File: src/main/java/org/joda/time/Minutes.java
Patch:
@@ -54,7 +54,7 @@ public final class Minutes extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of minutes that can be stored in this object. */
     public static final Minutes MIN_VALUE = new Minutes(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.minutes());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380863L;

File: src/main/java/org/joda/time/Months.java
Patch:
@@ -126,7 +126,7 @@ public static Months months(int months) {
     //-----------------------------------------------------------------------
     /**
      * Creates a <code>Months</code> representing the number of whole months
-     * between the two specified datetimes. This method corectly handles
+     * between the two specified datetimes. This method correctly handles
      * any daylight savings time changes that may occur during the interval.
      * <p>
      * This method calculates by adding months to the start date until the result
@@ -172,7 +172,7 @@ public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {
 
     /**
      * Creates a <code>Months</code> representing the number of whole months
-     * in the specified interval. This method corectly handles any daylight
+     * in the specified interval. This method correctly handles any daylight
      * savings time changes that may occur during the interval.
      *
      * @param interval  the interval to extract months from, null returns zero

File: src/main/java/org/joda/time/Partial.java
Patch:
@@ -583,7 +583,7 @@ public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
      * <p>
      * If the addition is zero, then <code>this</code> is returned.
      * The addition will overflow into larger fields (eg. minute to hour).
-     * If the maximum is reached, the addition will wra.
+     * If the maximum is reached, the addition will wrap.
      *
      * @param fieldType  the field type to add to, not null
      * @param amount  the amount to add

File: src/main/java/org/joda/time/Period.java
Patch:
@@ -285,7 +285,7 @@ public static Period fieldDifference(ReadablePartial start, ReadablePartial end)
      * </pre>
      * Bear in mind that this creates four period instances in total, three of
      * which are immediately discarded.
-     * The alterative is more efficient, but less readable:
+     * The alternative is more efficient, but less readable:
      * <pre>
      * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);
      * </pre>

File: src/main/java/org/joda/time/ReadableDuration.java
Patch:
@@ -126,7 +126,7 @@ public interface ReadableDuration extends Comparable<ReadableDuration> {
     boolean equals(Object readableDuration);
 
     /**
-     * Gets a hash code for the duration that is compatable with the 
+     * Gets a hash code for the duration that is compatible with the
      * equals method.
      * The following formula must be used:
      * <pre>

File: src/main/java/org/joda/time/ReadableInterval.java
Patch:
@@ -294,7 +294,7 @@ public interface ReadableInterval {
     boolean equals(Object readableInterval);
 
     /**
-     * Gets a hash code for the time interval that is compatable with the 
+     * Gets a hash code for the time interval that is compatible with the
      * equals method.
      * <p>
      * The formula used must be as follows:

File: src/main/java/org/joda/time/Seconds.java
Patch:
@@ -54,7 +54,7 @@ public final class Seconds extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of seconds that can be stored in this object. */
     public static final Seconds MIN_VALUE = new Seconds(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.seconds());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380862L;

File: src/main/java/org/joda/time/TimeOfDay.java
Patch:
@@ -1108,7 +1108,7 @@ public TimeOfDay addToCopy(int valueToAdd) {
          * Smaller fields are unaffected.
          * <p>
          * If the result would be too large (beyond 23:59:59:999) or too
-         * small (less than 00:00:00.000) then an Execption is thrown.
+         * small (less than 00:00:00.000) then an Exception is thrown.
          * For the alternate behaviour which wraps to the next 'day',
          * see {@link #addToCopy(int)}.
          * <p>

File: src/main/java/org/joda/time/Weeks.java
Patch:
@@ -54,7 +54,7 @@ public final class Weeks extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of weeks that can be stored in this object. */
     public static final Weeks MIN_VALUE = new Weeks(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.weeks());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380866L;

File: src/main/java/org/joda/time/YearMonthDay.java
Patch:
@@ -89,7 +89,7 @@ public final class YearMonthDay
      * <p>
      * Each field is queried from the Calendar and assigned to the YearMonthDay.
      * This is useful if you have been using the Calendar as a local date,
-     * ignoing the zone.
+     * ignoring the zone.
      * <p>
      * This factory method ignores the type of the calendar and always
      * creates a YearMonthDay with ISO chronology. It is expected that you
@@ -119,7 +119,7 @@ public static YearMonthDay fromCalendarFields(Calendar calendar) {
      * <p>
      * Each field is queried from the Date and assigned to the YearMonthDay.
      * This is useful if you have been using the Date as a local date,
-     * ignoing the zone.
+     * ignoring the zone.
      * <p>
      * This factory method always creates a YearMonthDay with ISO chronology.
      *
@@ -222,7 +222,7 @@ public YearMonthDay(long instant, Chronology chronology) {
      * The chronology used will be derived from the object, defaulting to ISO.
      * <p>
      * NOTE: Prior to v1.3 the string format was described by
-     * {@link ISODateTimeFormat#dateTimeParser()}. Time ony strings are now rejected.
+     * {@link ISODateTimeFormat#dateTimeParser()}. Time only strings are now rejected.
      *
      * @param instant  the datetime object, null means now
      * @throws IllegalArgumentException if the instant is invalid

File: src/main/java/org/joda/time/Years.java
Patch:
@@ -54,7 +54,7 @@ public final class Years extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of years that can be stored in this object. */
     public static final Years MIN_VALUE = new Years(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.years());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380868L;
@@ -90,7 +90,7 @@ public static Years years(int years) {
     //-----------------------------------------------------------------------
     /**
      * Creates a <code>Years</code> representing the number of whole years
-     * between the two specified datetimes. This method corectly handles
+     * between the two specified datetimes. This method correctly handles
      * any daylight savings time changes that may occur during the interval.
      *
      * @param start  the start instant, must not be null
@@ -128,7 +128,7 @@ public static Years yearsBetween(ReadablePartial start, ReadablePartial end) {
 
     /**
      * Creates a <code>Years</code> representing the number of whole years
-     * in the specified interval. This method corectly handles any daylight
+     * in the specified interval. This method correctly handles any daylight
      * savings time changes that may occur during the interval.
      *
      * @param interval  the interval to extract years from, null returns zero

File: src/main/java/org/joda/time/base/AbstractDateTime.java
Patch:
@@ -260,7 +260,7 @@ public int getMillisOfSecond() {
      * differ in accuracy. Joda-Time's implementation is generally more up to
      * date and thus more accurate - for example JDK1.3 has no historical data.
      * The effect of this is that the field values of the <code>Calendar</code>
-     * may differ from those of this object, even though the milliseond value
+     * may differ from those of this object, even though the millisecond value
      * is the same. Most of the time this just means that the JDK field values
      * are wrong, as our time zone information is more up to date.
      *
@@ -285,7 +285,7 @@ public Calendar toCalendar(Locale locale) {
      * differ in accuracy. Joda-Time's implementation is generally more up to
      * date and thus more accurate - for example JDK1.3 has no historical data.
      * The effect of this is that the field values of the <code>Calendar</code>
-     * may differ from those of this object, even though the milliseond value
+     * may differ from those of this object, even though the millisecond value
      * is the same. Most of the time this just means that the JDK field values
      * are wrong, as our time zone information is more up to date.
      *

File: src/main/java/org/joda/time/base/AbstractPartial.java
Patch:
@@ -69,7 +69,7 @@ protected AbstractPartial() {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the field type at the specifed index.
+     * Gets the field type at the specified index.
      * 
      * @param index  the index
      * @return the field type
@@ -95,7 +95,7 @@ public DateTimeFieldType[] getFieldTypes() {
     }
 
     /**
-     * Gets the field at the specifed index.
+     * Gets the field at the specified index.
      * 
      * @param index  the index
      * @return the field

File: src/main/java/org/joda/time/base/BaseLocal.java
Patch:
@@ -53,7 +53,7 @@ protected BaseLocal() {
      * Gets the local milliseconds from the Java epoch
      * of 1970-01-01T00:00:00 (not fixed to any specific time zone).
      * <p>
-     * This method is useful in certain circustances for high performance
+     * This method is useful in certain circumstances for high performance
      * access to the datetime fields.
      * 
      * @return the number of milliseconds since 1970-01-01T00:00:00

File: src/main/java/org/joda/time/base/BasePartial.java
Patch:
@@ -215,7 +215,7 @@ protected BasePartial(BasePartial base, Chronology chrono) {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * 
      * @param index  the index
      * @return the value

File: src/main/java/org/joda/time/base/BasePeriod.java
Patch:
@@ -284,7 +284,7 @@ protected BasePeriod(Object period, PeriodType type, Chronology chrono) {
 
     /**
      * Constructor used when we trust ourselves.
-     * Do not expose publically.
+     * Do not expose publicly.
      *
      * @param values  the values to use, not null, not cloned
      * @param type  which set of fields this period supports, not null

File: src/main/java/org/joda/time/chrono/AssembledChronology.java
Patch:
@@ -94,7 +94,7 @@ public abstract class AssembledChronology extends BaseChronology {
      * as AbstractChronology.
      *
      * @param base optional base chronology to copy initial fields from
-     * @param param optional param object avalable for assemble method
+     * @param param optional param object available for assemble method
      */
     protected AssembledChronology(Chronology base, Object param) {
         iBase = base;

File: src/main/java/org/joda/time/chrono/BaseChronology.java
Patch:
@@ -65,7 +65,7 @@ protected BaseChronology() {
     /**
      * Returns an instance of this Chronology that operates in the UTC time
      * zone. Chronologies that do not operate in a time zone or are already
-     * UTC must return themself.
+     * UTC must return themselves.
      *
      * @return a version of this chronology that ignores time zones
      */

File: src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java
Patch:
@@ -40,7 +40,7 @@ class BasicYearDateTimeField extends ImpreciseDateTimeField {
     /**
      * Restricted constructor.
      * 
-     * @param chronology  the chronology this field belogs to
+     * @param chronology  the chronology this field belongs to
      */
     BasicYearDateTimeField(BasicChronology chronology) {
         super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());

File: src/main/java/org/joda/time/chrono/BuddhistChronology.java
Patch:
@@ -41,7 +41,7 @@
  * However, the actual rules for Thailand are much more involved than
  * this class covers. (This class is accurate after 1941-01-01 ISO).
  * <p>
- * This chronlogy is being retained for those who want a same effect
+ * This chronology is being retained for those who want a same effect
  * replacement for the Sun class. It is hoped that community support will
  * enable a more accurate chronology for Thailand, to be developed.
  * <p>

File: src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
Patch:
@@ -23,7 +23,7 @@
 import org.joda.time.field.FieldUtils;
 
 /**
- * This field is not publicy exposed by ISOChronology, but rather it is used to
+ * This field is not publicly exposed by ISOChronology, but rather it is used to
  * build the yearOfCentury and centuryOfEra fields. It merely drops the sign of
  * the year.
  *

File: src/main/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -359,7 +359,7 @@ public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valu
      * <p>
      * Partial instants only contain some fields. This may result in a maximum
      * possible value, such as TimeOfDay normally being limited to 23:59:59:999.
-     * If ths limit is reached by the addition, this method will wrap back to
+     * If this limit is reached by the addition, this method will wrap back to
      * 00:00:00.000. In fact, you would generally only use this method for
      * classes that have a limitation such as this.
      * <p>

File: src/main/java/org/joda/time/field/BaseDurationField.java
Patch:
@@ -40,7 +40,7 @@ public abstract class BaseDurationField extends DurationField implements Seriali
     /** Serialization lock. */
     private static final long serialVersionUID = -2554245107589433218L;
 
-    /** A desriptive name for the field. */
+    /** A descriptive name for the field. */
     private final DurationFieldType iType;
 
     protected BaseDurationField(DurationFieldType type) {

File: src/main/java/org/joda/time/field/SkipDateTimeField.java
Patch:
@@ -47,7 +47,7 @@ public final class SkipDateTimeField extends DelegatedDateTimeField {
     /**
      * Constructor that skips zero.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      */
     public SkipDateTimeField(Chronology chronology, DateTimeField field) {
@@ -57,7 +57,7 @@ public SkipDateTimeField(Chronology chronology, DateTimeField field) {
     /**
      * Constructor.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      * @param skip  the value to skip
      */

File: src/main/java/org/joda/time/field/SkipUndoDateTimeField.java
Patch:
@@ -46,7 +46,7 @@ public final class SkipUndoDateTimeField extends DelegatedDateTimeField {
     /**
      * Constructor that reinserts zero.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      */
     public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {
@@ -56,7 +56,7 @@ public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {
     /**
      * Constructor.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      * @param skip  the value to skip
      */

File: src/main/java/org/joda/time/field/UnsupportedDateTimeField.java
Patch:
@@ -33,7 +33,7 @@
  */
 public final class UnsupportedDateTimeField extends DateTimeField implements Serializable {
 
-    /** Serialilzation version */
+    /** Serialization version */
     private static final long serialVersionUID = -1934618396111902255L;
 
     /** The cache of unsupported datetime field instances */

File: src/main/java/org/joda/time/field/UnsupportedDurationField.java
Patch:
@@ -219,7 +219,7 @@ public long getUnitMillis() {
     }
 
     /**
-     * Always returns zero, indicating that sort order is not relevent.
+     * Always returns zero, indicating that sort order is not relevant.
      *
      * @return zero always
      */

File: src/main/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -127,7 +127,7 @@ protected ISODateTimeFormat() {
      * -20-.040      -20-.040    minute/milli *
      *   plus datetime formats like {date}T{time}
      * </pre>
-     * * indiates that this is not an official ISO format and can be excluded
+     * * indicates that this is not an official ISO format and can be excluded
      * by passing in <code>strictISO</code> as <code>true</code>.
      * <p>
      * This method can side effect the input collection of fields.

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -215,7 +215,7 @@ public PeriodFormatterBuilder append(PeriodFormatter formatter) {
      * Appends a printer parser pair.
      * <p>
      * Either the printer or the parser may be null, in which case the builder will
-     * be unable to produce a parser or printer repectively.
+     * be unable to produce a parser or printer respectively.
      *
      * @param printer  appends a printer to the builder, null if printing is not supported
      * @param parser  appends a parser to the builder, null if parsing is not supported
@@ -308,7 +308,7 @@ public PeriodFormatterBuilder printZeroRarelyFirst() {
     }
 
     /**
-     * Print zero values for the next and following appened fields only if the
+     * Print zero values for the next and following appended fields only if the
      * period supports it.
      *
      * @return this PeriodFormatterBuilder

File: src/main/java/org/joda/time/tz/FixedDateTimeZone.java
Patch:
@@ -70,7 +70,7 @@ public long previousTransition(long instant) {
     }
 
     /**
-     * Override to return the correct timzone instance.
+     * Override to return the correct timezone instance.
      * @since 1.5
      */
     public java.util.TimeZone toTimeZone() {

File: src/test/java/org/joda/time/field/TestUnsupportedDateTimeField.java
Patch:
@@ -72,7 +72,7 @@ public void testNullValuesToGetInstanceThrowsException() {
      * different duration fields
      * 
      * Then the field returned in the first invocation should not be equal to
-     * the field returned by the second invocation. In otherwords, the generated
+     * the field returned by the second invocation. In other words, the generated
      * instance should be the same for a unique pairing of
      * DateTimeFieldType/DurationField
      */

File: src/example/org/joda/example/time/DateTimeBrowser.java
Patch:
@@ -51,7 +51,7 @@
 
 import org.joda.time.DateTime;
 
-/** DateTimeBrowser is a Java Swing application which reads a file contining
+/** DateTimeBrowser is a Java Swing application which reads a file containing
  * strings and displays DateTime values in a JTable.<p>
  * The input strings must be suitable for instantiation
  * of DateTime objects.  The file is read, and an attempt is made

File: src/main/java/org/joda/time/Chronology.java
Patch:
@@ -75,7 +75,7 @@ public abstract class Chronology {
     /**
      * Returns an instance of this Chronology that operates in the UTC time
      * zone. Chronologies that do not operate in a time zone or are already
-     * UTC must return themself.
+     * UTC must return themselves.
      *
      * @return a version of this chronology that ignores time zones
      */

File: src/main/java/org/joda/time/DateMidnight.java
Patch:
@@ -42,7 +42,7 @@
  * This class uses a Chronology internally. The Chronology determines how the
  * millisecond instant value is converted into the date time fields.
  * The default Chronology is <code>ISOChronology</code> which is the agreed
- * international standard and compatable with the modern Gregorian calendar.
+ * international standard and compatible with the modern Gregorian calendar.
  *
  * <p>Each individual field can be queried in two ways:
  * <ul>
@@ -922,7 +922,7 @@ public DateMidnight withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      * @since 1.3

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -1634,7 +1634,7 @@ public DateTime withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      * @since 1.3
@@ -2268,7 +2268,7 @@ public DateTime setCopy(String text) {
          * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result
          * to force the later time during a DST overlap if desired.
          * <p>
-         * From v2.2, this method handles a daylight svaings time gap, setting the
+         * From v2.2, this method handles a daylight savings time gap, setting the
          * time to the last instant before the gap.
          * <p>
          * The DateTime attached to this property is unchanged by this call.
@@ -2297,7 +2297,7 @@ public DateTime withMaximumValue() {
          * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result
          * to force the earlier time during a DST overlap if desired.
          * <p>
-         * From v2.2, this method handles a daylight svaings time gap, setting the
+         * From v2.2, this method handles a daylight savings time gap, setting the
          * time to the first instant after the gap.
          * <p>
          * The DateTime attached to this property is unchanged by this call.

File: src/main/java/org/joda/time/DateTimeConstants.java
Patch:
@@ -103,7 +103,7 @@ public class DateTimeConstants {
     /**
      * Constant (1) representing AD, years after zero (from Calendar).
      * <p>
-     * All new chronologies with differrent Era values should try to assign
+     * All new chronologies with different Era values should try to assign
      * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned
      * the value 1. Earlier eras are assigned sequentially smaller numbers.
      * Later eras are assigned sequentially greater numbers.
@@ -112,7 +112,7 @@ public class DateTimeConstants {
     /**
      * Alternative constant (1) representing CE, Common Era (secular).
      * <p>
-     * All new chronologies with differrent Era values should try to assign
+     * All new chronologies with different Era values should try to assign
      * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned
      * the value 1. Earlier eras are assigned sequentially smaller numbers.
      * Later eras are assigned sequentially greater numbers.

File: src/main/java/org/joda/time/DateTimeField.java
Patch:
@@ -251,7 +251,7 @@ public abstract class DateTimeField {
      * <p>
      * Partial instants only contain some fields. This may result in a maximum
      * possible value, such as TimeOfDay normally being limited to 23:59:59:999.
-     * If ths limit is reached by the addition, this method will wrap back to
+     * If this limit is reached by the addition, this method will wrap back to
      * 00:00:00.000. In fact, you would generally only use this method for
      * classes that have a limitation such as this.
      * <p>

File: src/main/java/org/joda/time/DateTimeFieldType.java
Patch:
@@ -435,7 +435,7 @@ private static class StandardDateTimeFieldType extends DateTimeFieldType {
          * Constructor.
          * 
          * @param name  the name to use
-         * @param ordinal  the byte value for the oridinal index
+         * @param ordinal  the byte value for the ordinal index
          * @param unitType  the unit duration type
          * @param rangeType  the range duration type
          */

File: src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -1259,7 +1259,7 @@ public java.util.TimeZone toTimeZone() {
     public abstract boolean equals(Object object);
 
     /**
-     * Gets a hash code compatable with equals.
+     * Gets a hash code compatible with equals.
      * 
      * @return suitable hashcode
      */

File: src/main/java/org/joda/time/Days.java
Patch:
@@ -62,7 +62,7 @@ public final class Days extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of days that can be stored in this object. */
     public static final Days MIN_VALUE = new Days(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.days());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380865L;
@@ -106,7 +106,7 @@ public static Days days(int days) {
     //-----------------------------------------------------------------------
     /**
      * Creates a <code>Days</code> representing the number of whole days
-     * between the two specified datetimes. This method corectly handles
+     * between the two specified datetimes. This method correctly handles
      * any daylight savings time changes that may occur during the interval.
      *
      * @param start  the start instant, must not be null
@@ -144,7 +144,7 @@ public static Days daysBetween(ReadablePartial start, ReadablePartial end) {
 
     /**
      * Creates a <code>Days</code> representing the number of whole days
-     * in the specified interval. This method corectly handles any daylight
+     * in the specified interval. This method correctly handles any daylight
      * savings time changes that may occur during the interval.
      *
      * @param interval  the interval to extract days from, null returns zero

File: src/main/java/org/joda/time/Hours.java
Patch:
@@ -64,7 +64,7 @@ public final class Hours extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of hours that can be stored in this object. */
     public static final Hours MIN_VALUE = new Hours(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.hours());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380864L;

File: src/main/java/org/joda/time/IllegalFieldValueException.java
Patch:
@@ -32,7 +32,7 @@ public class IllegalFieldValueException extends IllegalArgumentException {
      * @param fieldName  the field name
      * @param value  the value rejected
      * @param lowerBound  the lower bound allowed
-     * @param upperBound  the uppe bound allowed
+     * @param upperBound  the upper bound allowed
      * @param explain  an explanation
      * @return the message
      */

File: src/main/java/org/joda/time/LocalDate.java
Patch:
@@ -509,7 +509,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
     }
 
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * <p>
      * This method is required to support the <code>ReadablePartial</code>
      * interface. The supported fields are Year, MonthOfYear and DayOfMonth.
@@ -1567,7 +1567,7 @@ public LocalDate withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      */

File: src/main/java/org/joda/time/LocalDateTime.java
Patch:
@@ -564,7 +564,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
     }
 
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * <p>
      * This method is required to support the <code>ReadablePartial</code>
      * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
@@ -1700,7 +1700,7 @@ public LocalDateTime withEra(int era) {
      * Instead, this method returns a new instance with the value of
      * century of era changed.
      *
-     * @param centuryOfEra  the centurey of era to set
+     * @param centuryOfEra  the century of era to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      */

File: src/main/java/org/joda/time/LocalTime.java
Patch:
@@ -560,7 +560,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
     }
 
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * <p>
      * This method is required to support the <code>ReadablePartial</code>
      * interface. The supported fields are HourOfDay, MinuteOfHour,
@@ -1264,7 +1264,7 @@ public Property millisOfDay() {
      * setting the time fields from this instance and the date fields from
      * the current date.
      *
-     * @return this time as a datetime using todays date
+     * @return this time as a datetime using today's date
      */
     public DateTime toDateTimeToday() {
         return toDateTimeToday(null);
@@ -1279,7 +1279,7 @@ public DateTime toDateTimeToday() {
      * specified.
      *
      * @param zone  the zone to use, null means default
-     * @return this time as a datetime using todays date
+     * @return this time as a datetime using today's date
      */
     public DateTime toDateTimeToday(DateTimeZone zone) {
         Chronology chrono = getChronology().withZone(zone);

File: src/main/java/org/joda/time/Minutes.java
Patch:
@@ -54,7 +54,7 @@ public final class Minutes extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of minutes that can be stored in this object. */
     public static final Minutes MIN_VALUE = new Minutes(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.minutes());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380863L;

File: src/main/java/org/joda/time/Months.java
Patch:
@@ -126,7 +126,7 @@ public static Months months(int months) {
     //-----------------------------------------------------------------------
     /**
      * Creates a <code>Months</code> representing the number of whole months
-     * between the two specified datetimes. This method corectly handles
+     * between the two specified datetimes. This method correctly handles
      * any daylight savings time changes that may occur during the interval.
      * <p>
      * This method calculates by adding months to the start date until the result
@@ -172,7 +172,7 @@ public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {
 
     /**
      * Creates a <code>Months</code> representing the number of whole months
-     * in the specified interval. This method corectly handles any daylight
+     * in the specified interval. This method correctly handles any daylight
      * savings time changes that may occur during the interval.
      *
      * @param interval  the interval to extract months from, null returns zero

File: src/main/java/org/joda/time/Partial.java
Patch:
@@ -583,7 +583,7 @@ public Partial withFieldAdded(DurationFieldType fieldType, int amount) {
      * <p>
      * If the addition is zero, then <code>this</code> is returned.
      * The addition will overflow into larger fields (eg. minute to hour).
-     * If the maximum is reached, the addition will wra.
+     * If the maximum is reached, the addition will wrap.
      *
      * @param fieldType  the field type to add to, not null
      * @param amount  the amount to add

File: src/main/java/org/joda/time/Period.java
Patch:
@@ -285,7 +285,7 @@ public static Period fieldDifference(ReadablePartial start, ReadablePartial end)
      * </pre>
      * Bear in mind that this creates four period instances in total, three of
      * which are immediately discarded.
-     * The alterative is more efficient, but less readable:
+     * The alternative is more efficient, but less readable:
      * <pre>
      * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);
      * </pre>

File: src/main/java/org/joda/time/ReadableDuration.java
Patch:
@@ -126,7 +126,7 @@ public interface ReadableDuration extends Comparable<ReadableDuration> {
     boolean equals(Object readableDuration);
 
     /**
-     * Gets a hash code for the duration that is compatable with the 
+     * Gets a hash code for the duration that is compatible with the
      * equals method.
      * The following formula must be used:
      * <pre>

File: src/main/java/org/joda/time/ReadableInterval.java
Patch:
@@ -294,7 +294,7 @@ public interface ReadableInterval {
     boolean equals(Object readableInterval);
 
     /**
-     * Gets a hash code for the time interval that is compatable with the 
+     * Gets a hash code for the time interval that is compatible with the
      * equals method.
      * <p>
      * The formula used must be as follows:

File: src/main/java/org/joda/time/Seconds.java
Patch:
@@ -54,7 +54,7 @@ public final class Seconds extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of seconds that can be stored in this object. */
     public static final Seconds MIN_VALUE = new Seconds(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.seconds());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380862L;

File: src/main/java/org/joda/time/TimeOfDay.java
Patch:
@@ -1108,7 +1108,7 @@ public TimeOfDay addToCopy(int valueToAdd) {
          * Smaller fields are unaffected.
          * <p>
          * If the result would be too large (beyond 23:59:59:999) or too
-         * small (less than 00:00:00.000) then an Execption is thrown.
+         * small (less than 00:00:00.000) then an Exception is thrown.
          * For the alternate behaviour which wraps to the next 'day',
          * see {@link #addToCopy(int)}.
          * <p>

File: src/main/java/org/joda/time/Weeks.java
Patch:
@@ -54,7 +54,7 @@ public final class Weeks extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of weeks that can be stored in this object. */
     public static final Weeks MIN_VALUE = new Weeks(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.weeks());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380866L;

File: src/main/java/org/joda/time/YearMonthDay.java
Patch:
@@ -89,7 +89,7 @@ public final class YearMonthDay
      * <p>
      * Each field is queried from the Calendar and assigned to the YearMonthDay.
      * This is useful if you have been using the Calendar as a local date,
-     * ignoing the zone.
+     * ignoring the zone.
      * <p>
      * This factory method ignores the type of the calendar and always
      * creates a YearMonthDay with ISO chronology. It is expected that you
@@ -119,7 +119,7 @@ public static YearMonthDay fromCalendarFields(Calendar calendar) {
      * <p>
      * Each field is queried from the Date and assigned to the YearMonthDay.
      * This is useful if you have been using the Date as a local date,
-     * ignoing the zone.
+     * ignoring the zone.
      * <p>
      * This factory method always creates a YearMonthDay with ISO chronology.
      *
@@ -222,7 +222,7 @@ public YearMonthDay(long instant, Chronology chronology) {
      * The chronology used will be derived from the object, defaulting to ISO.
      * <p>
      * NOTE: Prior to v1.3 the string format was described by
-     * {@link ISODateTimeFormat#dateTimeParser()}. Time ony strings are now rejected.
+     * {@link ISODateTimeFormat#dateTimeParser()}. Time only strings are now rejected.
      *
      * @param instant  the datetime object, null means now
      * @throws IllegalArgumentException if the instant is invalid

File: src/main/java/org/joda/time/Years.java
Patch:
@@ -54,7 +54,7 @@ public final class Years extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of years that can be stored in this object. */
     public static final Years MIN_VALUE = new Years(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.years());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380868L;
@@ -90,7 +90,7 @@ public static Years years(int years) {
     //-----------------------------------------------------------------------
     /**
      * Creates a <code>Years</code> representing the number of whole years
-     * between the two specified datetimes. This method corectly handles
+     * between the two specified datetimes. This method correctly handles
      * any daylight savings time changes that may occur during the interval.
      *
      * @param start  the start instant, must not be null
@@ -128,7 +128,7 @@ public static Years yearsBetween(ReadablePartial start, ReadablePartial end) {
 
     /**
      * Creates a <code>Years</code> representing the number of whole years
-     * in the specified interval. This method corectly handles any daylight
+     * in the specified interval. This method correctly handles any daylight
      * savings time changes that may occur during the interval.
      *
      * @param interval  the interval to extract years from, null returns zero

File: src/main/java/org/joda/time/base/AbstractDateTime.java
Patch:
@@ -260,7 +260,7 @@ public int getMillisOfSecond() {
      * differ in accuracy. Joda-Time's implementation is generally more up to
      * date and thus more accurate - for example JDK1.3 has no historical data.
      * The effect of this is that the field values of the <code>Calendar</code>
-     * may differ from those of this object, even though the milliseond value
+     * may differ from those of this object, even though the millisecond value
      * is the same. Most of the time this just means that the JDK field values
      * are wrong, as our time zone information is more up to date.
      *
@@ -285,7 +285,7 @@ public Calendar toCalendar(Locale locale) {
      * differ in accuracy. Joda-Time's implementation is generally more up to
      * date and thus more accurate - for example JDK1.3 has no historical data.
      * The effect of this is that the field values of the <code>Calendar</code>
-     * may differ from those of this object, even though the milliseond value
+     * may differ from those of this object, even though the millisecond value
      * is the same. Most of the time this just means that the JDK field values
      * are wrong, as our time zone information is more up to date.
      *

File: src/main/java/org/joda/time/base/AbstractPartial.java
Patch:
@@ -69,7 +69,7 @@ protected AbstractPartial() {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the field type at the specifed index.
+     * Gets the field type at the specified index.
      * 
      * @param index  the index
      * @return the field type
@@ -95,7 +95,7 @@ public DateTimeFieldType[] getFieldTypes() {
     }
 
     /**
-     * Gets the field at the specifed index.
+     * Gets the field at the specified index.
      * 
      * @param index  the index
      * @return the field

File: src/main/java/org/joda/time/base/BaseLocal.java
Patch:
@@ -53,7 +53,7 @@ protected BaseLocal() {
      * Gets the local milliseconds from the Java epoch
      * of 1970-01-01T00:00:00 (not fixed to any specific time zone).
      * <p>
-     * This method is useful in certain circustances for high performance
+     * This method is useful in certain circumstances for high performance
      * access to the datetime fields.
      * 
      * @return the number of milliseconds since 1970-01-01T00:00:00

File: src/main/java/org/joda/time/base/BasePartial.java
Patch:
@@ -215,7 +215,7 @@ protected BasePartial(BasePartial base, Chronology chrono) {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * 
      * @param index  the index
      * @return the value

File: src/main/java/org/joda/time/base/BasePeriod.java
Patch:
@@ -284,7 +284,7 @@ protected BasePeriod(Object period, PeriodType type, Chronology chrono) {
 
     /**
      * Constructor used when we trust ourselves.
-     * Do not expose publically.
+     * Do not expose publicly.
      *
      * @param values  the values to use, not null, not cloned
      * @param type  which set of fields this period supports, not null

File: src/main/java/org/joda/time/chrono/AssembledChronology.java
Patch:
@@ -94,7 +94,7 @@ public abstract class AssembledChronology extends BaseChronology {
      * as AbstractChronology.
      *
      * @param base optional base chronology to copy initial fields from
-     * @param param optional param object avalable for assemble method
+     * @param param optional param object available for assemble method
      */
     protected AssembledChronology(Chronology base, Object param) {
         iBase = base;

File: src/main/java/org/joda/time/chrono/BaseChronology.java
Patch:
@@ -65,7 +65,7 @@ protected BaseChronology() {
     /**
      * Returns an instance of this Chronology that operates in the UTC time
      * zone. Chronologies that do not operate in a time zone or are already
-     * UTC must return themself.
+     * UTC must return themselves.
      *
      * @return a version of this chronology that ignores time zones
      */

File: src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java
Patch:
@@ -40,7 +40,7 @@ class BasicYearDateTimeField extends ImpreciseDateTimeField {
     /**
      * Restricted constructor.
      * 
-     * @param chronology  the chronology this field belogs to
+     * @param chronology  the chronology this field belongs to
      */
     BasicYearDateTimeField(BasicChronology chronology) {
         super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());

File: src/main/java/org/joda/time/chrono/BuddhistChronology.java
Patch:
@@ -41,7 +41,7 @@
  * However, the actual rules for Thailand are much more involved than
  * this class covers. (This class is accurate after 1941-01-01 ISO).
  * <p>
- * This chronlogy is being retained for those who want a same effect
+ * This chronology is being retained for those who want a same effect
  * replacement for the Sun class. It is hoped that community support will
  * enable a more accurate chronology for Thailand, to be developed.
  * <p>

File: src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
Patch:
@@ -23,7 +23,7 @@
 import org.joda.time.field.FieldUtils;
 
 /**
- * This field is not publicy exposed by ISOChronology, but rather it is used to
+ * This field is not publicly exposed by ISOChronology, but rather it is used to
  * build the yearOfCentury and centuryOfEra fields. It merely drops the sign of
  * the year.
  *

File: src/main/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -359,7 +359,7 @@ public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valu
      * <p>
      * Partial instants only contain some fields. This may result in a maximum
      * possible value, such as TimeOfDay normally being limited to 23:59:59:999.
-     * If ths limit is reached by the addition, this method will wrap back to
+     * If this limit is reached by the addition, this method will wrap back to
      * 00:00:00.000. In fact, you would generally only use this method for
      * classes that have a limitation such as this.
      * <p>

File: src/main/java/org/joda/time/field/BaseDurationField.java
Patch:
@@ -40,7 +40,7 @@ public abstract class BaseDurationField extends DurationField implements Seriali
     /** Serialization lock. */
     private static final long serialVersionUID = -2554245107589433218L;
 
-    /** A desriptive name for the field. */
+    /** A descriptive name for the field. */
     private final DurationFieldType iType;
 
     protected BaseDurationField(DurationFieldType type) {

File: src/main/java/org/joda/time/field/SkipDateTimeField.java
Patch:
@@ -47,7 +47,7 @@ public final class SkipDateTimeField extends DelegatedDateTimeField {
     /**
      * Constructor that skips zero.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      */
     public SkipDateTimeField(Chronology chronology, DateTimeField field) {
@@ -57,7 +57,7 @@ public SkipDateTimeField(Chronology chronology, DateTimeField field) {
     /**
      * Constructor.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      * @param skip  the value to skip
      */

File: src/main/java/org/joda/time/field/SkipUndoDateTimeField.java
Patch:
@@ -46,7 +46,7 @@ public final class SkipUndoDateTimeField extends DelegatedDateTimeField {
     /**
      * Constructor that reinserts zero.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      */
     public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {
@@ -56,7 +56,7 @@ public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {
     /**
      * Constructor.
      * 
-     * @param chronology  the chronoogy to use
+     * @param chronology  the chronology to use
      * @param field  the field to skip zero on
      * @param skip  the value to skip
      */

File: src/main/java/org/joda/time/field/UnsupportedDateTimeField.java
Patch:
@@ -33,7 +33,7 @@
  */
 public final class UnsupportedDateTimeField extends DateTimeField implements Serializable {
 
-    /** Serialilzation version */
+    /** Serialization version */
     private static final long serialVersionUID = -1934618396111902255L;
 
     /** The cache of unsupported datetime field instances */

File: src/main/java/org/joda/time/field/UnsupportedDurationField.java
Patch:
@@ -219,7 +219,7 @@ public long getUnitMillis() {
     }
 
     /**
-     * Always returns zero, indicating that sort order is not relevent.
+     * Always returns zero, indicating that sort order is not relevant.
      *
      * @return zero always
      */

File: src/main/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -127,7 +127,7 @@ protected ISODateTimeFormat() {
      * -20-.040      -20-.040    minute/milli *
      *   plus datetime formats like {date}T{time}
      * </pre>
-     * * indiates that this is not an official ISO format and can be excluded
+     * * indicates that this is not an official ISO format and can be excluded
      * by passing in <code>strictISO</code> as <code>true</code>.
      * <p>
      * This method can side effect the input collection of fields.

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -215,7 +215,7 @@ public PeriodFormatterBuilder append(PeriodFormatter formatter) {
      * Appends a printer parser pair.
      * <p>
      * Either the printer or the parser may be null, in which case the builder will
-     * be unable to produce a parser or printer repectively.
+     * be unable to produce a parser or printer respectively.
      *
      * @param printer  appends a printer to the builder, null if printing is not supported
      * @param parser  appends a parser to the builder, null if parsing is not supported
@@ -308,7 +308,7 @@ public PeriodFormatterBuilder printZeroRarelyFirst() {
     }
 
     /**
-     * Print zero values for the next and following appened fields only if the
+     * Print zero values for the next and following appended fields only if the
      * period supports it.
      *
      * @return this PeriodFormatterBuilder

File: src/main/java/org/joda/time/tz/FixedDateTimeZone.java
Patch:
@@ -70,7 +70,7 @@ public long previousTransition(long instant) {
     }
 
     /**
-     * Override to return the correct timzone instance.
+     * Override to return the correct timezone instance.
      * @since 1.5
      */
     public java.util.TimeZone toTimeZone() {

File: src/test/java/org/joda/time/field/TestUnsupportedDateTimeField.java
Patch:
@@ -72,7 +72,7 @@ public void testNullValuesToGetInstanceThrowsException() {
      * different duration fields
      * 
      * Then the field returned in the first invocation should not be equal to
-     * the field returned by the second invocation. In otherwords, the generated
+     * the field returned by the second invocation. In other words, the generated
      * instance should be the same for a unique pairing of
      * DateTimeFieldType/DurationField
      */

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -60,7 +60,7 @@ protected AbstractInterval() {
      */
     protected void checkInterval(long start, long end) {
         if (end < start) {
-            throw new IllegalArgumentException("The end instant must be greater the start");
+            throw new IllegalArgumentException("The end instant must be greater than the start instant");
         }
     }
 

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -60,7 +60,7 @@ protected AbstractInterval() {
      */
     protected void checkInterval(long start, long end) {
         if (end < start) {
-            throw new IllegalArgumentException("The end instant must be greater the start");
+            throw new IllegalArgumentException("The end instant must be greater than the start instant");
         }
     }
 

File: src/test/java/org/joda/time/format/TestDateTimeFormatter.java
Patch:
@@ -1037,7 +1037,7 @@ public void testZoneShortNameNearTransition() {
         DateTime outDST   = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);
         DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);
 
-        DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S z");
+        DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S z").withLocale(Locale.ENGLISH);
         assertEquals("2005-10-30 01:00:00.0 EDT", fmt.print(inDST_1));
         assertEquals("2005-10-30 01:59:59.9 EDT", fmt.print(inDST_2));
         assertEquals("2005-10-30 02:00:00.0 EST", fmt.print(onDST));

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -192,7 +192,7 @@ static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zi
     }
 
     static int parseYear(String str, int def) {
-        str = str.toLowerCase();
+        str = str.toLowerCase(Locale.ENGLISH);
         if (str.equals("minimum") || str.equals("min")) {
             return Integer.MIN_VALUE;
         } else if (str.equals("maximum") || str.equals("max")) {

File: src/main/java/org/joda/time/base/AbstractDuration.java
Patch:
@@ -120,7 +120,7 @@ public boolean isEqual(ReadableDuration duration) {
      * Is the length of this duration longer than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is longer than the duration passed in
+     * @return true if this duration is strictly longer than the duration passed in
      */
     public boolean isLongerThan(ReadableDuration duration) {
         if (duration == null) {
@@ -133,7 +133,7 @@ public boolean isLongerThan(ReadableDuration duration) {
      * Is the length of this duration shorter than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is shorter than the duration passed in
+     * @return true if this duration is strictly shorter than the duration passed in
      */
     public boolean isShorterThan(ReadableDuration duration) {
         if (duration == null) {

File: src/main/java/org/joda/time/base/AbstractPartial.java
Patch:
@@ -341,7 +341,7 @@ public int compareTo(ReadablePartial other) {
      * a time zone to accurately determine the current date.
      *
      * @param partial  a partial to check against, must not be null
-     * @return true if this date is after the date passed in
+     * @return true if this date is strictly after the date passed in
      * @throws IllegalArgumentException if the specified partial is null
      * @throws ClassCastException if the partial has field types that don't match
      * @since 1.1
@@ -363,7 +363,7 @@ public boolean isAfter(ReadablePartial partial) {
      * a time zone to accurately determine the current date.
      *
      * @param partial  a partial to check against, must not be null
-     * @return true if this date is before the date passed in
+     * @return true if this date is strictly before the date passed in
      * @throws IllegalArgumentException if the specified partial is null
      * @throws ClassCastException if the partial has field types that don't match
      * @since 1.1

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -263,6 +263,7 @@ static boolean test(String id, DateTimeZone tz) {
         long end = ISOChronology.getInstanceUTC().year().set(0, 2050);
 
         int offset = tz.getOffset(millis);
+        int stdOffset = tz.getStandardOffset(millis);
         String key = tz.getNameKey(millis);
 
         List<Long> transitions = new ArrayList<Long>();
@@ -276,10 +277,10 @@ static boolean test(String id, DateTimeZone tz) {
             millis = next;
 
             int nextOffset = tz.getOffset(millis);
+            int nextStdOffset = tz.getStandardOffset(millis);
             String nextKey = tz.getNameKey(millis);
 
-            if (offset == nextOffset
-                && key.equals(nextKey)) {
+            if (offset == nextOffset && stdOffset == nextStdOffset && key.equals(nextKey)) {
                 System.out.println("*d* Error in " + tz.getID() + " "
                                    + new DateTime(millis,
                                                   ISOChronology.getInstanceUTC()));

File: src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
Patch:
@@ -441,7 +441,9 @@ public void writeTo(String zoneID, OutputStream out) throws IOException {
         if (out instanceof DataOutput) {
             writeTo(zoneID, (DataOutput)out);
         } else {
-            writeTo(zoneID, (DataOutput)new DataOutputStream(out));
+            DataOutputStream dout = new DataOutputStream(out);
+            writeTo(zoneID, (DataOutput)dout);
+            dout.flush();
         }
     }
 

File: src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
Patch:
@@ -441,7 +441,9 @@ public void writeTo(String zoneID, OutputStream out) throws IOException {
         if (out instanceof DataOutput) {
             writeTo(zoneID, (DataOutput)out);
         } else {
-            writeTo(zoneID, (DataOutput)new DataOutputStream(out));
+            DataOutputStream dout = new DataOutputStream(out);
+            writeTo(zoneID, (DataOutput)dout);
+            dout.flush();
         }
     }
 

File: src/test/java/org/joda/time/TestDateMidnight_Basics.java
Patch:
@@ -422,8 +422,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDateTimeComparator.java
Patch:
@@ -271,8 +271,8 @@ public void testSerialization1() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(c);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);
@@ -289,8 +289,8 @@ public void testSerialization2() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(c);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDateTimeFieldType.java
Patch:
@@ -314,8 +314,8 @@ private DateTimeFieldType doSerialization(DateTimeFieldType type) throws Excepti
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(type);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDateTimeZone.java
Patch:
@@ -1025,8 +1025,8 @@ public void testSerialization1() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(zone);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);
@@ -1043,8 +1043,8 @@ public void testSerialization2() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(zone);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDateTime_Basics.java
Patch:
@@ -487,8 +487,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDays.java
Patch:
@@ -240,8 +240,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDurationFieldType.java
Patch:
@@ -176,8 +176,8 @@ private DurationFieldType doSerialization(DurationFieldType type) throws Excepti
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(type);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestDuration_Basics.java
Patch:
@@ -237,8 +237,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestHours.java
Patch:
@@ -209,8 +209,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestInstant_Basics.java
Patch:
@@ -367,8 +367,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestInterval_Basics.java
Patch:
@@ -1032,8 +1032,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestLocalDateTime_Basics.java
Patch:
@@ -1051,8 +1051,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestLocalDate_Basics.java
Patch:
@@ -1106,8 +1106,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestLocalTime_Basics.java
Patch:
@@ -766,8 +766,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestMinutes.java
Patch:
@@ -199,8 +199,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestMonthDay_Basics.java
Patch:
@@ -769,8 +769,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestMonths.java
Patch:
@@ -226,8 +226,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestMutableDateTime_Basics.java
Patch:
@@ -391,8 +391,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestMutableInterval_Basics.java
Patch:
@@ -452,8 +452,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestMutablePeriod_Basics.java
Patch:
@@ -163,8 +163,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestPartial_Basics.java
Patch:
@@ -781,8 +781,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestPeriodType.java
Patch:
@@ -110,8 +110,8 @@ private void assertEqualsAfterSerialization(PeriodType type) throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(type);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);
@@ -125,8 +125,8 @@ private void assertSameAfterSerialization(PeriodType type) throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(type);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestPeriod_Basics.java
Patch:
@@ -230,8 +230,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestSeconds.java
Patch:
@@ -196,8 +196,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestTimeOfDay_Basics.java
Patch:
@@ -853,8 +853,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestWeeks.java
Patch:
@@ -198,8 +198,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestYearMonthDay_Basics.java
Patch:
@@ -779,8 +779,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestYearMonth_Basics.java
Patch:
@@ -603,8 +603,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/TestYears.java
Patch:
@@ -181,8 +181,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/field/TestMillisDurationField.java
Patch:
@@ -202,8 +202,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/field/TestPreciseDurationField.java
Patch:
@@ -261,8 +261,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/field/TestScaledDurationField.java
Patch:
@@ -278,8 +278,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/test/java/org/joda/time/tz/TestCachedDateTimeZone.java
Patch:
@@ -68,8 +68,8 @@ public void testSerialization() throws Exception {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(baos);
         oos.writeObject(test);
-        byte[] bytes = baos.toByteArray();
         oos.close();
+        byte[] bytes = baos.toByteArray();
         
         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
         ObjectInputStream ois = new ObjectInputStream(bais);

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -528,6 +528,9 @@ public void parseDataFile(BufferedReader in, boolean backward) throws IOExceptio
                         rs.addRule(r);
                     }
                 } else if (token.equalsIgnoreCase("Zone")) {
+		    if (st.countTokens() < 4) {
+			throw new IllegalArgumentException("Attempting to create a Zone from an incomplete tokenizer");
+		    }
                     zone = new Zone(st);
                 } else if (token.equalsIgnoreCase("Link")) {
                     String real = st.nextToken();

File: src/main/java/org/joda/time/format/DateTimeParserBucket.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2014 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -565,7 +565,7 @@ void init(DateTimeField field, String text, Locale locale) {
         
         long set(long millis, boolean reset) {
             if (iText == null) {
-                millis = iField.set(millis, iValue);
+                millis = iField.setExtended(millis, iValue);
             } else {
                 millis = iField.set(millis, iText, iLocale);
             }

File: src/test/java/org/joda/time/TestAll.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2015 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -129,6 +129,7 @@ public static Test suite() {
         suite.addTest(TestStringConvert.suite());
         suite.addTest(TestSerialization.suite());
         suite.addTest(TestIllegalFieldValueException.suite());
+        suite.addTest(TestMinMaxLong.suite());
         return suite;
     }
 

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -60,7 +60,7 @@ protected AbstractInterval() {
      */
     protected void checkInterval(long start, long end) {
         if (end < start) {
-            throw new IllegalArgumentException("The end instant must be greater or equal to the start");
+            throw new IllegalArgumentException("The end instant must be greater the start");
         }
     }
 

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -694,6 +694,9 @@ private static class Rule {
         public final String iLetterS;
 
         Rule(StringTokenizer st) {
+            if (st.countTokens() < 6) {
+                throw new IllegalArgumentException("Attempting to create a Rule from an incomplete tokenizer");
+            }
             iName = st.nextToken().intern();
             iFromYear = parseYear(st.nextToken(), 0);
             iToYear = parseYear(st.nextToken(), iFromYear);

File: src/main/java/org/joda/time/Interval.java
Patch:
@@ -462,7 +462,7 @@ public Interval withStart(ReadableInstant start) {
     }
 
     /**
-     * Creates a new interval with the specified start millisecond instant.
+     * Creates a new interval with the specified end millisecond instant.
      *
      * @param endInstant  the end instant for the new interval
      * @return an interval with the start from this interval and the specified end

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -399,7 +399,7 @@ public MutableInterval toMutableInterval() {
      * @throws ArithmeticException if the duration exceeds the capacity of a long
      */
     public long toDurationMillis() {
-        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());
+        return FieldUtils.safeSubtract(getEndMillis(), getStartMillis());
     }
 
     /**

File: src/main/java/org/joda/time/Interval.java
Patch:
@@ -462,7 +462,7 @@ public Interval withStart(ReadableInstant start) {
     }
 
     /**
-     * Creates a new interval with the specified start millisecond instant.
+     * Creates a new interval with the specified end millisecond instant.
      *
      * @param endInstant  the end instant for the new interval
      * @return an interval with the start from this interval and the specified end

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -399,7 +399,7 @@ public MutableInterval toMutableInterval() {
      * @throws ArithmeticException if the duration exceeds the capacity of a long
      */
     public long toDurationMillis() {
-        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());
+        return FieldUtils.safeSubtract(getEndMillis(), getStartMillis());
     }
 
     /**

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -118,7 +118,7 @@ public PeriodFormatterBuilder() {
      * This is the main method used by applications at the end of the build
      * process to create a usable formatter.
      * <p>
-     * Subsequent changes to this builder do not affect the returned formatter.
+     * Once this method has been called, the builder is in an invalid state.
      * <p>
      * The returned formatter may not support both printing and parsing.
      * The methods {@link PeriodFormatter#isPrinter()} and

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -123,11 +123,11 @@ public static DateTime now(Chronology chronology) {
     /**
      * Parses a {@code DateTime} from the specified string.
      * <p>
-     * This uses {@link ISODateTimeFormat#dateTimeParser().withOffsetParsed()}
+     * This uses {@link ISODateTimeFormat#dateTimeParser()}{@code .withOffsetParsed()}
      * which is different to passing a {@code String} to the constructor.
      * <p>
      * Sometimes this method and {@code new DateTime(str)} return different results.
-     * This can be confusing as the different is not visible in {@link #toString()}.
+     * This can be confusing as the difference is not visible in {@link #toString()}.
      * <p>
      * When passed a date-time string without an offset, such as '2010-06-30T01:20',
      * both the constructor and this method use the default time-zone.

File: src/main/java/org/joda/time/ReadableInterval.java
Patch:
@@ -260,7 +260,7 @@ public interface ReadableInterval {
      * Converts the duration of the interval to a period using the
      * standard period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @return a time period derived from the interval
@@ -271,7 +271,7 @@ public interface ReadableInterval {
      * Converts the duration of the interval to a period using the
      * specified period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @param type  the requested type of the duration, null means standard

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -424,7 +424,7 @@ public Duration toDuration() {
      * Converts the duration of the interval to a <code>Period</code> using the
      * All period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @return a time period derived from the interval
@@ -437,7 +437,7 @@ public Period toPeriod() {
      * Converts the duration of the interval to a <code>Period</code> using the
      * specified period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @param type  the requested type of the duration, null means AllType

File: src/main/java/org/joda/time/ReadableInterval.java
Patch:
@@ -260,7 +260,7 @@ public interface ReadableInterval {
      * Converts the duration of the interval to a period using the
      * standard period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @return a time period derived from the interval
@@ -271,7 +271,7 @@ public interface ReadableInterval {
      * Converts the duration of the interval to a period using the
      * specified period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @param type  the requested type of the duration, null means standard

File: src/main/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -424,7 +424,7 @@ public Duration toDuration() {
      * Converts the duration of the interval to a <code>Period</code> using the
      * All period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @return a time period derived from the interval
@@ -437,7 +437,7 @@ public Period toPeriod() {
      * Converts the duration of the interval to a <code>Period</code> using the
      * specified period type.
      * <p>
-     * This method should be used to exract the field values describing the
+     * This method should be used to extract the field values describing the
      * difference between the start and end instants.
      *
      * @param type  the requested type of the duration, null means AllType

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -138,7 +138,7 @@ public static DateTime now(Chronology chronology) {
      * the offset is directly parsed and stored.
      * As such, {@code DateTime.parse("2010-06-30T01:20+02:00")} and
      * {@code new DateTime("2010-06-30T01:20+02:00"))} are NOT equal.
-     * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(1)}.
+     * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(2)}.
      * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.
      * 
      * @param str  the string to parse, not null

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -138,7 +138,7 @@ public static DateTime now(Chronology chronology) {
      * the offset is directly parsed and stored.
      * As such, {@code DateTime.parse("2010-06-30T01:20+02:00")} and
      * {@code new DateTime("2010-06-30T01:20+02:00"))} are NOT equal.
-     * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(1)}.
+     * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(2)}.
      * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.
      * 
      * @param str  the string to parse, not null

File: src/main/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java
Patch:
@@ -370,7 +370,7 @@ public Interval toInterval() {
         DateTimeField field = getField();
         long start = field.roundFloor(getMillis());
         long end = field.add(start, 1);
-        Interval interval = new Interval(start, end);
+        Interval interval = new Interval(start, end, getChronology());
         return interval;
     }
 

File: src/test/java/org/joda/time/TestDateTime_Properties.java
Patch:
@@ -1343,10 +1343,10 @@ public void testPropertyToIntervalHourOfDay() {
       assertEquals(new DateTime(2004, 6, 9, 13, 0, 0, 0), testInterval.getStart());
       assertEquals(new DateTime(2004, 6, 9, 14, 0, 0, 0), testInterval.getEnd());
 
-      DateTime midnightTest = new DateTime(2004, 6, 9, 23, 23, 43, 53);
+      DateTime midnightTest = new DateTime(2004, 6, 9, 23, 23, 43, 53, COPTIC_PARIS);
       Interval midnightTestInterval = midnightTest.hourOfDay().toInterval();
-      assertEquals(new DateTime(2004, 6, 9, 23, 0, 0, 0), midnightTestInterval.getStart());
-      assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0), midnightTestInterval.getEnd());
+      assertEquals(new DateTime(2004, 6, 9, 23, 0, 0, 0, COPTIC_PARIS), midnightTestInterval.getStart());
+      assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0, COPTIC_PARIS), midnightTestInterval.getEnd());
     }
 
     public void testPropertyToIntervalMinuteOfHour() {

File: src/main/java/org/joda/time/Seconds.java
Patch:
@@ -149,7 +149,7 @@ public static Seconds secondsIn(ReadableInterval interval) {
      * durations for each field. Only those fields which have a precise duration in
      * the ISO UTC chronology can be converted.
      * <ul>
-     * <li>One week consists of 7 seconds.
+     * <li>One week consists of 7 days.
      * <li>One day consists of 24 hours.
      * <li>One hour consists of 60 minutes.
      * <li>One minute consists of 60 seconds.

File: src/main/java/org/joda/time/Seconds.java
Patch:
@@ -149,7 +149,7 @@ public static Seconds secondsIn(ReadableInterval interval) {
      * durations for each field. Only those fields which have a precise duration in
      * the ISO UTC chronology can be converted.
      * <ul>
-     * <li>One week consists of 7 seconds.
+     * <li>One week consists of 7 days.
      * <li>One day consists of 24 hours.
      * <li>One hour consists of 60 minutes.
      * <li>One minute consists of 60 seconds.

File: src/main/java/org/joda/time/tz/DefaultNameProvider.java
Patch:
@@ -116,6 +116,9 @@ private synchronized String[] getNameSet(Locale locale, String id, String nameKe
         if (locale == null || id == null || nameKey == null) {
             return null;
         }
+        if (id.startsWith("Etc/")) {
+            id = id.substring(4);
+        }
 
         Map<String, Map<Boolean, Object>> byIdCache = iByLocaleCache2.get(locale);
         if (byIdCache == null) {

File: src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
Patch:
@@ -1443,7 +1443,7 @@ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transitio
                         curNameKey.equals(zoneNameData[2]) &&
                         curNameKey.equals(zoneNameData[4])) {
                     
-                    if (ZoneInfoCompiler.verbose()) {
+                    if (ZoneInfoLogger.verbose()) {
                         System.out.println("Fixing duplicate name key - " + nextNameKey);
                         System.out.println("     - " + new DateTime(trans[i], chrono) +
                                            " - " + new DateTime(trans[i + 1], chrono));
@@ -1460,7 +1460,7 @@ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transitio
             if (tailZone != null) {
                 if (tailZone.iStartRecurrence.getNameKey()
                     .equals(tailZone.iEndRecurrence.getNameKey())) {
-                    if (ZoneInfoCompiler.verbose()) {
+                    if (ZoneInfoLogger.verbose()) {
                         System.out.println("Fixing duplicate recurrent name key - " +
                                            tailZone.iStartRecurrence.getNameKey());
                     }

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -1573,11 +1573,12 @@ public int parseInto(
             int length = 0;
             int fractPos = -1;
             boolean hasDigits = false;
+            boolean negative = false;
             while (length < limit) {
                 char c = text.charAt(position + length);
                 // leading sign
                 if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {
-                    boolean negative = c == '-';
+                    negative = c == '-';
 
                     // Next character must be a digit.
                     if (length + 1 >= limit || 
@@ -1653,7 +1654,7 @@ public int parseInto(
                             fractValue *= 10;
                         }
                     }
-                    if (wholeValue < 0) {
+                    if (negative || wholeValue < 0) {
                         fractValue = -fractValue;
                     }
                 }

File: src/main/java/org/joda/time/base/AbstractInstant.java
Patch:
@@ -385,7 +385,7 @@ public boolean isBefore(ReadableInstant instant) {
      * comparing solely by millisecond.
      *
      * @param instant  a millisecond instant to check against
-     * @return true if this instant is before the instant passed in
+     * @return true if this instant is equal to the instant passed in
      */
     public boolean isEqual(long instant) {
         return (getMillis() == instant);
@@ -395,7 +395,7 @@ public boolean isEqual(long instant) {
      * Is this instant equal to the current instant
      * comparing solely by millisecond.
      * 
-     * @return true if this instant is before the current instant
+     * @return true if this instant is equal to the current instant
      */
     public boolean isEqualNow() {
         return isEqual(DateTimeUtils.currentTimeMillis());

File: src/main/java/org/joda/time/Chronology.java
Patch:
@@ -31,7 +31,7 @@
  * <p>
  * The provided chronology implementations are:
  * <ul>
- * <li>ISO - Based on the ISO8601 standard and suitable for use after about 1600
+ * <li>ISO - The <i>de facto<i> world calendar system, based on the ISO-8601 standard
  * <li>GJ - Historically accurate calendar with Julian followed by Gregorian
  * <li>Gregorian - The Gregorian calendar system used for all time (proleptic)
  * <li>Julian - The Julian calendar system used for all time (proleptic)

File: src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
Patch:
@@ -209,7 +209,7 @@ public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valu
         }
         if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
             // month is largest field and being added to, such as month-day
-            int curMonth0 = partial.getValue(0) - 1;
+            int curMonth0 = values[0] - 1;
             int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
             return set(partial, 0, values, newMonth);
         }

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -1059,7 +1059,7 @@ public int scan(String periodStr, final int position) {
             int sourceLength = periodStr.length();
             search:
             for (int pos = position; pos < sourceLength; pos++) {
-                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {
+                if (periodStr.regionMatches(false, pos, text, 0, textLength)) {
                     if (!matchesOtherAffix(textLength, periodStr, pos)) {
                         return pos;
                     }

File: src/main/java/org/joda/time/convert/AbstractConverter.java
Patch:
@@ -40,7 +40,7 @@ protected AbstractConverter() {
 
     //-----------------------------------------------------------------------
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * <p>
      * This implementation returns the current time.
      * 
@@ -54,7 +54,7 @@ public long getInstantMillis(Object object, Chronology chrono) {
 
     //-----------------------------------------------------------------------
     /**
-     * Extracts the chronology from an object of this convertor's type
+     * Extracts the chronology from an object of this converter's type
      * where the time zone is specified.
      * <p>
      * This implementation returns the ISO chronology.
@@ -68,7 +68,7 @@ public Chronology getChronology(Object object, DateTimeZone zone) {
     }
 
     /**
-     * Extracts the chronology from an object of this convertor's type
+     * Extracts the chronology from an object of this converter's type
      * where the chronology is specified.
      * <p>
      * This implementation returns the chronology specified, or the

File: src/main/java/org/joda/time/convert/ConverterManager.java
Patch:
@@ -26,7 +26,7 @@
  * interval converters.
  * <p>
  * This class is threadsafe, so adding/removing converters can be done at any
- * time. Updating the set of convertors is relatively expensive, and so should
+ * time. Updating the set of converters is relatively expensive, and so should
  * not be performed often.
  * <p>
  * The default instant converters are:

File: src/main/java/org/joda/time/convert/DurationConverter.java
Patch:
@@ -25,7 +25,7 @@
 public interface DurationConverter extends Converter {
 
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond duration

File: src/main/java/org/joda/time/convert/ReadableDurationConverter.java
Patch:
@@ -44,7 +44,7 @@ protected ReadableDurationConverter() {
 
     //-----------------------------------------------------------------------
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond value

File: src/main/java/org/joda/time/convert/ReadableInstantConverter.java
Patch:
@@ -88,7 +88,7 @@ public Chronology getChronology(Object object, Chronology chrono) {
     }
 
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the ReadableInstant to convert, must not be null
      * @param chrono  the non-null result of getChronology

File: src/main/java/org/joda/time/convert/AbstractConverter.java
Patch:
@@ -40,7 +40,7 @@ protected AbstractConverter() {
 
     //-----------------------------------------------------------------------
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * <p>
      * This implementation returns the current time.
      * 
@@ -54,7 +54,7 @@ public long getInstantMillis(Object object, Chronology chrono) {
 
     //-----------------------------------------------------------------------
     /**
-     * Extracts the chronology from an object of this convertor's type
+     * Extracts the chronology from an object of this converter's type
      * where the time zone is specified.
      * <p>
      * This implementation returns the ISO chronology.
@@ -68,7 +68,7 @@ public Chronology getChronology(Object object, DateTimeZone zone) {
     }
 
     /**
-     * Extracts the chronology from an object of this convertor's type
+     * Extracts the chronology from an object of this converter's type
      * where the chronology is specified.
      * <p>
      * This implementation returns the chronology specified, or the

File: src/main/java/org/joda/time/convert/ConverterManager.java
Patch:
@@ -26,7 +26,7 @@
  * interval converters.
  * <p>
  * This class is threadsafe, so adding/removing converters can be done at any
- * time. Updating the set of convertors is relatively expensive, and so should
+ * time. Updating the set of converters is relatively expensive, and so should
  * not be performed often.
  * <p>
  * The default instant converters are:

File: src/main/java/org/joda/time/convert/DurationConverter.java
Patch:
@@ -25,7 +25,7 @@
 public interface DurationConverter extends Converter {
 
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond duration

File: src/main/java/org/joda/time/convert/ReadableDurationConverter.java
Patch:
@@ -44,7 +44,7 @@ protected ReadableDurationConverter() {
 
     //-----------------------------------------------------------------------
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond value

File: src/main/java/org/joda/time/convert/ReadableInstantConverter.java
Patch:
@@ -88,7 +88,7 @@ public Chronology getChronology(Object object, Chronology chrono) {
     }
 
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the ReadableInstant to convert, must not be null
      * @param chrono  the non-null result of getChronology

File: src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -91,7 +91,7 @@ public abstract class DateTimeZone implements Serializable {
     private static final long serialVersionUID = 5546345482340108586L;
 
     /** The time zone for Universal Coordinated Time */
-    public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0);
+    public static final DateTimeZone UTC = UTCDateTimeZone.INSTANCE;
     /** Maximum offset. */
     private static final int MAX_MILLIS = (86400 * 1000) - 1;
 

File: src/test/java/org/joda/time/format/TestPeriodFormatterBuilder.java
Patch:
@@ -339,7 +339,7 @@ public void testFormatPrefixSimple3() {
             fail();
         } catch (IllegalArgumentException ex) {}
     }
-    
+
     public void testFormatPrefixSimple4IgnoringPrefix() {
         PeriodFormatter f = builder.appendPrefix("m").appendMinutes()
                 .appendSeparator(" ").appendPrefix("ms").appendMillis().toFormatter();
@@ -348,7 +348,7 @@ public void testFormatPrefixSimple4IgnoringPrefix() {
         Period period = f.parsePeriod(oneMS);
         assertEquals(Period.millis(1), period);
     }
-    
+
     public void testPluralAffixParseOrder() {
         PeriodFormatter f = builder.appendDays().appendSuffix("day", "days").toFormatter();
         String twoDays = Period.days(2).toString(f);
@@ -486,7 +486,6 @@ public void testFormatPrefixRegEx4IgnoringPrefix() {
         assertEquals("msss2", twoMS);
         Period period2 = f.parsePeriod(twoMS);
         assertEquals(Period.millis(2), period2);
-
     }
 
     //-----------------------------------------------------------------------

File: src/test/java/org/joda/time/format/TestPeriodFormat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2012 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: src/test/java/org/joda/time/format/TestPeriodFormatterBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2006 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -1075,7 +1075,7 @@ static class RegExAffix implements PeriodFieldAffix {
         private final Pattern[] iPatterns;
 
         RegExAffix(String[] regExes, String[] texts) {
-            iSuffixes = texts;
+            iSuffixes = texts.clone();
             iPatterns = new Pattern[regExes.length];
 
             for (int i = 0; i < regExes.length; i++) {

File: src/main/java/org/joda/time/chrono/BaseChronology.java
Patch:
@@ -258,7 +258,9 @@ public int[] get(ReadablePeriod period, long startInstant, long endInstant) {
             for (int i = 0; i < size; i++) {
                 DurationField field = period.getFieldType(i).getField(this);
                 int value = field.getDifference(endInstant, startInstant);
-                startInstant = field.add(startInstant, value);
+                if (value != 0) {
+                    startInstant = field.add(startInstant, value);
+                }
                 values[i] = value;
             }
         }

File: src/main/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -785,7 +785,7 @@ private static int selectStyle(char ch) {
 
     //-----------------------------------------------------------------------
     static class StyleFormatter
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private static final ConcurrentHashMap<StyleFormatterCacheKey, DateTimeFormatter> cCache = new ConcurrentHashMap<StyleFormatterCacheKey, DateTimeFormatter>();
         
@@ -820,8 +820,8 @@ public int estimateParsedLength() {
             return 40;  // guess
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
-            DateTimeParser p = getFormatter(bucket.getLocale()).getParser();
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+            InternalParser p = getFormatter(bucket.getLocale()).getParser0();
             return p.parseInto(bucket, text, position);
         }
 

File: src/main/java/org/joda/time/format/DateTimeParserBucket.java
Patch:
@@ -172,11 +172,11 @@ public void reset() {
      */
     public long parseMillis(DateTimeParser parser, CharSequence text) {
         reset();
-        return doParseMillis(parser, text);
+        return doParseMillis(DateTimeParserInternalParser.of(parser), text);
     }
 
-    long doParseMillis(DateTimeParser parser, CharSequence text) {
-        int newPos = parser.parseInto(this, text.toString(), 0);
+    long doParseMillis(InternalParser parser, CharSequence text) {
+        int newPos = parser.parseInto(this, text, 0);
         if (newPos >= 0) {
             if (newPos >= text.length()) {
                 return computeMillis(true, text);

File: src/main/java/org/joda/time/format/FormatUtils.java
Patch:
@@ -419,7 +419,7 @@ public static int calculateDigitCount(long value) {
                 ((int)(Math.log(value) / LOG_10) + 1)))));
     }
 
-    static int parseTwoDigits(String text, int position) {
+    static int parseTwoDigits(CharSequence text, int position) {
         int value = text.charAt(position) - '0';
         return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';
     }

File: src/test/java/org/joda/time/format/TestDateTimeFormatter.java
Patch:
@@ -348,7 +348,7 @@ public void testPrinterParserMethods() {
             fail();
         } catch (UnsupportedOperationException ex) {}
         
-        f2 = new DateTimeFormatter((InternalPrinter) null, f.getParser());
+        f2 = new DateTimeFormatter((DateTimePrinter) null, f.getParser());
         assertEquals(null, f2.getPrinter());
         assertEquals(f.getParser(), f2.getParser());
         assertEquals(false, f2.isPrinter());

File: src/main/java/org/joda/time/Interval.java
Patch:
@@ -468,7 +468,7 @@ public Interval withPeriodAfterStart(ReadablePeriod period) {
     /**
      * Creates a new interval with the specified period before the end instant.
      *
-     * @param period the duration to subtract from the end to get the new start instant, null means zero
+     * @param period the period to subtract from the end to get the new start instant, null means zero
      * @return an interval with the end from this interval and a calculated start
      * @throws IllegalArgumentException if the period is negative
      */

File: src/main/java/org/joda/time/base/AbstractInstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -417,7 +417,7 @@ public boolean isEqual(ReadableInstant instant) {
     /**
      * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
      * 
-     * @return ISO8601 time formatted string.
+     * @return ISO8601 time formatted string, not null
      */
     @ToString
     public String toString() {
@@ -429,7 +429,7 @@ public String toString() {
      * Uses the specified formatter to convert this partial to a String.
      *
      * @param formatter  the formatter to use, null means use <code>toString()</code>.
-     * @return the formatted string
+     * @return the formatted string, not null
      * @since 1.1
      */
     public String toString(DateTimeFormatter formatter) {

File: src/main/java/org/joda/time/ReadableDuration.java
Patch:
@@ -103,15 +103,15 @@ public interface ReadableDuration extends Comparable<ReadableDuration> {
      * Is the length of this duration longer than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to or greater than the duration passed in
+     * @return true if this duration is greater than the duration passed in
      */
     boolean isLongerThan(ReadableDuration duration);
 
     /**
      * Is the length of this duration shorter than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to or less than the duration passed in
+     * @return true if this duration is less than the duration passed in
      */
     boolean isShorterThan(ReadableDuration duration);
 

File: src/main/java/org/joda/time/format/FormatUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -109,7 +109,7 @@ public static void appendPaddedInteger(Appendable appenadble, int value, int siz
             appenadble.append(Integer.toString(value));
         }
     }
-    
+
     /**
      * Converts an integer to a string, prepended with a variable amount of '0'
      * pad characters, and appends it to the given buffer.

File: src/test/java/org/joda/time/format/TestDateTimeFormatter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2011 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -348,7 +348,7 @@ public void testPrinterParserMethods() {
             fail();
         } catch (UnsupportedOperationException ex) {}
         
-        f2 = new DateTimeFormatter(null, f.getParser());
+        f2 = new DateTimeFormatter((InternalPrinter) null, f.getParser());
         assertEquals(null, f2.getPrinter());
         assertEquals(f.getParser(), f2.getParser());
         assertEquals(false, f2.isPrinter());

File: src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -2223,7 +2223,7 @@ public void printTo(
                 return;
             }
             displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
-            if (displayOffset == 0 && iMinFields == 1) {
+            if (displayOffset == 0 && iMinFields <= 1) {
                 return;
             }
 
@@ -2236,7 +2236,7 @@ public void printTo(
                 return;
             }
             displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
-            if (displayOffset == 0 && iMinFields == 2) {
+            if (displayOffset == 0 && iMinFields <= 2) {
                 return;
             }
 
@@ -2249,7 +2249,7 @@ public void printTo(
                 return;
             }
             displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
-            if (displayOffset == 0 && iMinFields == 3) {
+            if (displayOffset == 0 && iMinFields <= 3) {
                 return;
             }
 

File: src/main/java/org/joda/time/Partial.java
Patch:
@@ -369,7 +369,7 @@ public DateTimeFieldType[] getFieldTypes() {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * 
      * @param index  the index
      * @return the value

File: src/main/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -159,7 +159,7 @@ public class DateTimeFormat {
         @Override
         protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {
             return size() > PATTERN_CACHE_SIZE;
-        };
+        }
     };
 
     /** Maps patterns to formatters, patterns don't vary by locale. */

File: src/main/java/org/joda/time/Partial.java
Patch:
@@ -369,7 +369,7 @@ public DateTimeFieldType[] getFieldTypes() {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * 
      * @param index  the index
      * @return the value

File: src/main/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -159,7 +159,7 @@ public class DateTimeFormat {
         @Override
         protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {
             return size() > PATTERN_CACHE_SIZE;
-        };
+        }
     };
 
     /** Maps patterns to formatters, patterns don't vary by locale. */

File: src/main/java/org/joda/time/Partial.java
Patch:
@@ -458,6 +458,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                             if (fieldType.getRangeDurationType() == null) {
                                 break;
                             }
+                            if (loopType.getRangeDurationType() == null) {
+                                continue;
+                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {

File: src/main/java/org/joda/time/field/UnsupportedDurationField.java
Patch:
@@ -224,9 +224,6 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
-        if (durationField.isSupported()) {
-            return 1;
-        }
         return 0;
     }
 

File: src/main/java/org/joda/time/field/UnsupportedDurationField.java
Patch:
@@ -224,6 +224,9 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
+        if (durationField.isSupported()) {
+            return 1;
+        }
         return 0;
     }
 

File: src/main/java/org/joda/time/DateTimeUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2012 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -370,7 +370,7 @@ public static final boolean isContiguous(ReadablePartial partial) {
         for (int i = 0; i < partial.size(); i++) {
             DateTimeField loopField = partial.getField(i);
             if (i > 0) {
-                if (loopField.getRangeDurationField().getType() != lastType) {
+                if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) {
                     return false;
                 }
             }

File: src/main/java/org/joda/time/chrono/BasicChronology.java
Patch:
@@ -278,6 +278,7 @@ protected void assemble(Fields fields) {
             fields.yearOfEra, 99);
         fields.centuryOfEra = new DividedDateTimeField(
             field, DateTimeFieldType.centuryOfEra(), 100);
+        fields.centuries = fields.centuryOfEra.getDurationField();
         
         field = new RemainderDateTimeField(
             (DividedDateTimeField) fields.centuryOfEra);
@@ -293,15 +294,13 @@ protected void assemble(Fields fields) {
         fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);
         
         field = new RemainderDateTimeField(
-            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);
+            fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);
         fields.weekyearOfCentury = new OffsetDateTimeField(
             field, DateTimeFieldType.weekyearOfCentury(), 1);
         
         // The remaining (imprecise) durations are available from the newly
         // created datetime fields.
-
         fields.years = fields.year.getDurationField();
-        fields.centuries = fields.centuryOfEra.getDurationField();
         fields.months = fields.monthOfYear.getDurationField();
         fields.weekyears = fields.weekyear.getDurationField();
     }

File: src/main/java/org/joda/time/chrono/ISOChronology.java
Patch:
@@ -170,12 +170,12 @@ protected void assemble(Fields fields) {
             // Use zero based century and year of century.
             fields.centuryOfEra = new DividedDateTimeField(
                 ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);
+            fields.centuries = fields.centuryOfEra.getDurationField();
+            
             fields.yearOfCentury = new RemainderDateTimeField(
                 (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());
             fields.weekyearOfCentury = new RemainderDateTimeField(
-                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());
-
-            fields.centuries = fields.centuryOfEra.getDurationField();
+                (DividedDateTimeField) fields.centuryOfEra, fields.weekyears, DateTimeFieldType.weekyearOfCentury());
         }
     }
 

File: src/test/java/org/joda/time/TestDateMidnight_Properties.java
Patch:
@@ -136,7 +136,7 @@ public void testPropertyGetYearOfEra() {
         assertEquals("2004", test.yearOfEra().getAsShortText());
         assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
-        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
         assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
     }
@@ -154,7 +154,7 @@ public void testPropertyGetCenturyOfEra() {
         assertEquals("20", test.centuryOfEra().getAsShortText());
         assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
-        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
         assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
     }

File: src/test/java/org/joda/time/TestDateTime_Properties.java
Patch:
@@ -141,7 +141,7 @@ public void testPropertyGetYearOfEra() {
         assertEquals("2004", test.yearOfEra().getAsShortText());
         assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
-        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
         assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
     }
@@ -160,7 +160,7 @@ public void testPropertyGetCenturyOfEra() {
         assertEquals("20", test.centuryOfEra().getAsShortText());
         assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
-        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
         assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
     }

File: src/test/java/org/joda/time/TestMutableDateTime_Properties.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -127,7 +127,7 @@ public void testPropertyGetYearOfEra() {
         assertEquals("2004", test.yearOfEra().getAsShortText());
         assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
-        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
         assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
     }
@@ -144,7 +144,7 @@ public void testPropertyGetCenturyOfEra() {
         assertEquals("20", test.centuryOfEra().getAsShortText());
         assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
-        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
         assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
     }

File: src/main/java/org/joda/time/Duration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -26,8 +26,9 @@
  * <p>
  * A duration is defined by a fixed number of milliseconds.
  * There is no concept of fields, such as days or seconds, as these fields can vary in length.
+ * <p>
  * A duration may be converted to a {@link Period} to obtain field values.
- * This conversion will typically cause a loss of precision, however.
+ * This conversion will typically cause a loss of precision.
  * <p>
  * Duration is thread-safe and immutable.
  *

File: src/main/java/org/joda/time/base/BaseDuration.java
Patch:
@@ -67,7 +67,7 @@ protected BaseDuration(long duration) {
      *
      * @param startInstant  interval start, in milliseconds
      * @param endInstant  interval end, in milliseconds
-     * @throws ArithmeticException if the duration exceeds a 64 bit long
+     * @throws ArithmeticException if the duration exceeds a 64-bit long
      */
     protected BaseDuration(long startInstant, long endInstant) {
         super();
@@ -79,7 +79,7 @@ protected BaseDuration(long startInstant, long endInstant) {
      *
      * @param start  interval start, null means now
      * @param end  interval end, null means now
-     * @throws ArithmeticException if the duration exceeds a 64 bit long
+     * @throws ArithmeticException if the duration exceeds a 64-bit long
      */
     protected BaseDuration(ReadableInstant start, ReadableInstant end) {
         super();

File: src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
Patch:
@@ -171,7 +171,7 @@ static void writeMillis(DataOutput out, long millis) throws IOException {
         // Write milliseconds either because the additional precision is
         // required or the minutes didn't fit in the field.
         
-        // Form 11 (64 bits effective precision, but write as if 70 bits)
+        // Form 11 (64-bits effective precision, but write as if 70 bits)
         out.writeByte(millis < 0 ? 0xff : 0xc0);
         out.writeLong(millis);
     }
@@ -205,7 +205,7 @@ static long readMillis(DataInput in) throws IOException {
             return w * 1000L;
 
         case 3:
-            // Form 11 (64 bits effective precision)
+            // Form 11 (64-bits effective precision)
             return in.readLong();
         }
     }

File: src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -45,14 +45,14 @@
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * Compiles Olson ZoneInfo database files into binary files for each time zone
+ * Compiles IANA ZoneInfo database files into binary files for each time zone
  * in the database. {@link DateTimeZoneBuilder} is used to construct and encode
  * compiled data files. {@link ZoneInfoProvider} loads the encoded files and
  * converts them back into {@link DateTimeZone} objects.
  * <p>
  * Although this tool is similar to zic, the binary formats are not
- * compatible. The latest Olson database files may be obtained
- * <a href="http://www.twinsun.com/tz/tz-link.htm">here</a>.
+ * compatible. The latest IANA time zone database files may be obtained
+ * <a href="http://www.iana.org/time-zones">here</a>.
  * <p>
  * ZoneInfoCompiler is mutable and not thread-safe, although the main method
  * may be safely invoked by multiple threads.

File: src/main/java/org/joda/time/tz/CachedDateTimeZone.java
Patch:
@@ -81,7 +81,7 @@ public static CachedDateTimeZone forZone(DateTimeZone zone) {
 
     private final DateTimeZone iZone;
 
-    private final Info[] iInfoCache = new Info[cInfoCacheMask + 1];
+    private final transient Info[] iInfoCache = new Info[cInfoCacheMask + 1];
 
     private CachedDateTimeZone(DateTimeZone zone) {
         super(zone.getID());

File: src/main/java/org/joda/time/LocalDate.java
Patch:
@@ -110,7 +110,7 @@ public final class LocalDate
     /** The chronology to use in UTC. */
     private final Chronology iChronology;
     /** The cached hash code. */
-    private transient volatile int iHash;
+    private transient int iHash;
 
     //-----------------------------------------------------------------------
     /**

File: src/main/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -95,8 +95,9 @@
  * the full form is used; otherwise a short or abbreviated form is used if
  * available.
  * <p>
- * <strong>Number</strong>: The minimum number of digits. Shorter numbers
- * are zero-padded to this amount.
+ * <strong>Number</strong>: The minimum number of digits.
+ * Shorter numbers are zero-padded to this amount.
+ * When parsing, any number of digits are accepted.
  * <p>
  * <strong>Year</strong>: Numeric presentation for year and weekyear fields
  * are handled specially. For example, if the count of 'y' is 2, the year

File: src/test/java/org/joda/time/chrono/TestAll.java
Patch:
@@ -47,6 +47,7 @@ public static Test suite() {
         suite.addTest(TestJulianChronology.suite());
         suite.addTest(TestISOChronology.suite());
         suite.addTest(TestLenientChronology.suite());
+        suite.addTest(TestGJDate.suite());
         
         return suite;
     }

File: src/main/java/org/joda/time/DateTime.java
Patch:
@@ -1498,7 +1498,9 @@ public Property property(DateTimeFieldType type) {
      * same millis and chronology.
      * 
      * @return a DateMidnight using the same millis and chronology
+     * @deprecated DateMidnight is deprecated
      */
+    @Deprecated
     public DateMidnight toDateMidnight() {
         return new DateMidnight(getMillis(), getChronology());
     }

File: src/test/java/org/joda/time/TestDateMidnight_Basics.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -44,6 +44,7 @@
  *
  * @author Stephen Colebourne
  */
+@SuppressWarnings("deprecation")
 public class TestDateMidnight_Basics extends TestCase {
     // Test in 2002/03 as time zones are more well known
     // (before the late 90's they were all over the place)
@@ -990,6 +991,7 @@ public void testProperty() {
         assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear()));
         assertEquals(test.property(DateTimeFieldType.millisOfSecond()), test.property(DateTimeFieldType.millisOfSecond()));
         DateTimeFieldType bad = new DateTimeFieldType("bad") {
+            private static final long serialVersionUID = 1L;
             public DurationFieldType getDurationType() {
                 return DurationFieldType.weeks();
             }

File: src/test/java/org/joda/time/TestDateMidnight_Constructors.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -32,6 +32,7 @@
  *
  * @author Stephen Colebourne
  */
+@SuppressWarnings("deprecation")
 public class TestDateMidnight_Constructors extends TestCase {
     // Test in 2002/03 as time zones are more well known
     // (before the late 90's they were all over the place)

File: src/test/java/org/joda/time/TestDateMidnight_Properties.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -30,6 +30,7 @@
  * @author Stephen Colebourne
  * @author Mike Schrag
  */
+@SuppressWarnings("deprecation")
 public class TestDateMidnight_Properties extends TestCase {
     // Test in 2002/03 as time zones are more well known
     // (before the late 90's they were all over the place)

File: src/test/java/org/joda/time/TestDateTime_Basics.java
Patch:
@@ -522,6 +522,7 @@ public void testToString_String_Locale() {
         assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null));
     }
 
+    @SuppressWarnings("deprecation")
     public void testToString_DTFormatter() {
         DateMidnight test = new DateMidnight(TEST_TIME_NOW);
         assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH")));

File: src/test/java/org/joda/time/TestLocalDate_Basics.java
Patch:
@@ -872,6 +872,7 @@ public void testToDateTime_wrongChronoLocalTime_Zone() {
     }
 
     //-----------------------------------------------------------------------
+    @SuppressWarnings("deprecation")
     public void testToDateMidnight() {
         LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);
         
@@ -881,6 +882,7 @@ public void testToDateMidnight() {
     }
 
     //-----------------------------------------------------------------------
+    @SuppressWarnings("deprecation")
     public void testToDateMidnight_Zone() {
         LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);
         
@@ -889,6 +891,7 @@ public void testToDateMidnight_Zone() {
         assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test);
     }
 
+    @SuppressWarnings("deprecation")
     public void testToDateMidnight_nullZone() {
         LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);
         

File: src/test/java/org/joda/time/TestStringConvert.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -49,6 +49,7 @@ protected void tearDown() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    @SuppressWarnings("deprecation")
     public void testDateMidnight() {
         DateMidnight test = new DateMidnight(2010, 6, 30, ISOChronology.getInstance(ZONE));
         String str = StringConvert.INSTANCE.convertToString(test);

File: src/main/java/org/joda/time/format/DateTimeFormatter.java
Patch:
@@ -54,8 +54,8 @@
  * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>
  * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>
  * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>
- * <li>{@link #withPivotYear()} - returns a new formatter with the specified pivot year</li>
- * <li>{@link #withDefaultYear()} - returns a new formatter with the specified default year</li>
+ * <li>{@link #withPivotYear(int)} - returns a new formatter with the specified pivot year</li>
+ * <li>{@link #withDefaultYear(int)} - returns a new formatter with the specified default year</li>
  * </ul>
  * Each of these returns a new formatter (instances of this class are immutable).
  * <p>

File: src/main/java/org/joda/time/format/DateTimeFormatter.java
Patch:
@@ -54,8 +54,8 @@
  * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>
  * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>
  * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>
- * <li>{@link #withPivotYear()} - returns a new formatter with the specified pivot year</li>
- * <li>{@link #withDefaultYear()} - returns a new formatter with the specified default year</li>
+ * <li>{@link #withPivotYear(int)} - returns a new formatter with the specified pivot year</li>
+ * <li>{@link #withDefaultYear(int)} - returns a new formatter with the specified default year</li>
  * </ul>
  * Each of these returns a new formatter (instances of this class are immutable).
  * <p>

File: src/main/java/org/joda/time/base/AbstractPeriod.java
Patch:
@@ -216,7 +216,7 @@ public int hashCode() {
     /**
      * Gets the value as a String in the ISO8601 duration format.
      * <p>
-     * For example, "P6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
+     * For example, "PT6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
      * <p>
      * For more control over the output, see
      * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.

File: src/main/java/org/joda/time/base/AbstractPeriod.java
Patch:
@@ -216,7 +216,7 @@ public int hashCode() {
     /**
      * Gets the value as a String in the ISO8601 duration format.
      * <p>
-     * For example, "P6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
+     * For example, "PT6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
      * <p>
      * For more control over the output, see
      * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.

File: src/main/java/org/joda/time/convert/StringConverter.java
Patch:
@@ -137,11 +137,9 @@ public long getDurationMillis(Object object) {
             millis = Integer.parseInt(str);
         } else if (negative) {
         	seconds = Long.parseLong(str.substring(firstDigit, str.length()));
-        }
-        else {
+        } else {
             seconds = Long.parseLong(str);
         }
-        assert(seconds >= 0L);
         if (negative) {
             return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis);
         } else {

File: src/main/java/org/joda/time/LocalTime.java
Patch:
@@ -1290,7 +1290,7 @@ public DateTime toDateTimeToday(DateTimeZone zone) {
 
     //-----------------------------------------------------------------------
     /**
-     * Output the time in ISO8601 format (HH:mm:ss.SSSZZ).
+     * Output the time in ISO8601 format (HH:mm:ss.SSS).
      * 
      * @return ISO8601 time formatted string.
      */

File: src/main/java/org/joda/time/Years.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
  * An immutable time period representing a number of years.
  * <p>
  * <code>Years</code> is an immutable period that can only store years.
- * It does not store years, days or hours for example. As such it is a
+ * It does not store months, days or hours for example. As such it is a
  * type-safe way of representing a number of years in an application.
  * <p>
  * The number of years is set in the constructor, and may be queried using

File: src/main/java/org/joda/time/format/PeriodFormat.java
Patch:
@@ -86,7 +86,7 @@ public static PeriodFormatter wordBased() {
      * {@code org.joda.time.format.messages}.
      * This can be added to via the normal classpath resource bundle mechanisms.
      * <p>
-     * Available languages are Danish, Dutch, English, French, German, Japanese, Portuguese, and Spanish.
+     * Available languages are English, Danish, Dutch, French, German, Japanese, Portuguese, and Spanish.
      * 
      * @return the formatter, not null
      * @since 2.0

File: src/main/java/org/joda/time/format/PeriodFormat.java
Patch:
@@ -86,7 +86,7 @@ public static PeriodFormatter wordBased() {
      * {@code org.joda.time.format.messages}.
      * This can be added to via the normal classpath resource bundle mechanisms.
      * <p>
-     * Available languages are English, German, Dutch, French, Spanish and Portuguese.
+     * Available languages are Danish, Dutch, English, French, German, Japanese, Portuguese, and Spanish.
      * 
      * @return the formatter, not null
      * @since 2.0

File: src/main/java/org/joda/time/chrono/BasicGJChronology.java
Patch:
@@ -131,7 +131,7 @@ int getDaysInMonthMax(int month) {
 
     //-----------------------------------------------------------------------
     int getDaysInMonthMaxForSet(long instant, int value) {
-        return (value > 28 ? getDaysInMonthMax(instant) : 28);
+        return ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28);
     }
 
     //-----------------------------------------------------------------------

File: src/main/java/org/joda/time/DateTimeUtils.java
Patch:
@@ -50,8 +50,8 @@ public class DateTimeUtils {
         map.put("GMT", DateTimeZone.UTC);
         put(map, "EST", "America/New_York");
         put(map, "EDT", "America/New_York");
-        put(map, "CST", "America/Chigaco");
-        put(map, "CDT", "America/Chigaco");
+        put(map, "CST", "America/Chicago");
+        put(map, "CDT", "America/Chicago");
         put(map, "MST", "America/Denver");
         put(map, "MDT", "America/Denver");
         put(map, "PST", "America/Los_Angeles");

File: src/main/java/org/joda/time/DateTimeUtils.java
Patch:
@@ -50,8 +50,8 @@ public class DateTimeUtils {
         map.put("GMT", DateTimeZone.UTC);
         put(map, "EST", "America/New_York");
         put(map, "EDT", "America/New_York");
-        put(map, "CST", "America/Chigaco");
-        put(map, "CDT", "America/Chigaco");
+        put(map, "CST", "America/Chicago");
+        put(map, "CDT", "America/Chicago");
         put(map, "MST", "America/Denver");
         put(map, "MDT", "America/Denver");
         put(map, "PST", "America/Los_Angeles");

File: src/main/java/org/joda/time/LocalDateTime.java
Patch:
@@ -238,7 +238,7 @@ public static LocalDateTime fromDateFields(Date date) {
             date.getHours(),
             date.getMinutes(),
             date.getSeconds(),
-            (int) (date.getTime() % 1000)
+            (((int) (date.getTime() % 1000)) + 1000) % 1000
         );
     }
 

File: src/main/java/org/joda/time/chrono/BasicChronology.java
Patch:
@@ -155,7 +155,7 @@ public long getDateTimeMillis(
         }
 
         FieldUtils.verifyValueBounds
-            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);
+            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1);
         return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
     }
 

File: src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -322,7 +322,7 @@ public static DateTimeZone forTimeZone(TimeZone zone) {
 
         // Support GMT+/-hh:mm formats
         if (convId == null) {
-            convId = zone.getDisplayName();
+            convId = zone.getID();
             if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
                 convId = convId.substring(3);
                 int offset = parseOffset(convId);

File: src/main/java/org/joda/time/PeriodType.java
Patch:
@@ -569,10 +569,10 @@ public static synchronized PeriodType forFields(DurationFieldType[] types) {
         PeriodType checkPartType = new PeriodType(null, type.iTypes, null);
         PeriodType checkedType = (PeriodType) cache.get(checkPartType);
         if (checkedType != null) {
-            cache.put(inPartType, checkedType);
+            cache.put(checkPartType, checkedType);
             return checkedType;
         }
-        cache.put(inPartType, type);
+        cache.put(checkPartType, type);
         return type;
     }
 

File: src/test/java/org/joda/time/TestPeriodType.java
Patch:
@@ -523,10 +523,12 @@ public void testForFields3() throws Exception {
     public void testForFields4() throws Exception {
         DurationFieldType[] types = new DurationFieldType[] {
             DurationFieldType.weeks(),
+            DurationFieldType.days(),  // adding this makes this test unique, so cache is not pre-populated
             DurationFieldType.months(),
         };
         DurationFieldType[] types2 = new DurationFieldType[] {
             DurationFieldType.months(),
+            DurationFieldType.days(),
             DurationFieldType.weeks(),
         };
         PeriodType type = PeriodType.forFields(types);

File: src/main/java/org/joda/time/MutablePeriod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2011 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -540,7 +540,7 @@ public void setPeriod(long startInstant, long endInstant) {
      * 
      * @param startInstant  interval start, in milliseconds
      * @param endInstant  interval end, in milliseconds
-     * @param chrono  the chronology to use, not null
+     * @param chrono  the chronology to use, null means ISO chronology
      * @throws ArithmeticException if the set exceeds the capacity of the period
      */
     public void setPeriod(long startInstant, long endInstant, Chronology chrono) {
@@ -603,7 +603,7 @@ public void setPeriod(long duration) {
      * available precise field.
      * 
      * @param duration  the duration, in milliseconds
-     * @param chrono  the chronology to use, not null
+     * @param chrono  the chronology to use, null means ISO chronology
      * @throws ArithmeticException if the set exceeds the capacity of the period
      */
     public void setPeriod(long duration, Chronology chrono) {

File: src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -2249,11 +2249,11 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                             break zeroOffset;
                         }
                     }
-                    bucket.setOffset(0);
+                    bucket.setOffset(Integer.valueOf(0));
                     return position;
                 }
                 if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {
-                    bucket.setOffset(0);
+                    bucket.setOffset(Integer.valueOf(0));
                     return position + iZeroOffsetParseText.length();
                 }
             }
@@ -2403,7 +2403,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 }
             }
 
-            bucket.setOffset(negative ? -offset : offset);
+            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));
             return position;
         }
 

File: JodaTime/src/main/java/org/joda/time/MutablePeriod.java
Patch:
@@ -177,7 +177,7 @@ public MutablePeriod(int years, int months, int weeks, int days,
      * @param duration  the duration, in milliseconds
      */
     public MutablePeriod(long duration) {
-        super(duration, null, null);
+        super(duration);
     }
 
     /**

File: JodaTime/src/main/java/org/joda/time/Period.java
Patch:
@@ -379,7 +379,7 @@ public Period(int years, int months, int weeks, int days,
      * @param duration  the duration, in milliseconds
      */
     public Period(long duration) {
-        super(duration, null, null);
+        super(duration);
     }
 
     /**

File: JodaTime/src/main/java/org/joda/time/field/LenientDateTimeField.java
Patch:
@@ -72,6 +72,6 @@ public long set(long instant, int value) {
         long localInstant = iBase.getZone().convertUTCToLocal(instant);
         long difference = FieldUtils.safeSubtract(value, get(instant));
         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);
-        return iBase.getZone().convertLocalToUTC(localInstant, false);
+        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);
     }
 }

File: JodaTime/src/test/java/org/joda/time/TestLocalDate_Basics.java
Patch:
@@ -68,7 +68,7 @@ public class TestLocalDate_Basics extends TestCase {
     /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */
     private static long CUTOVER_GAZA = 1175378400000L;
     private static int OFFSET_GAZA = 7200000;  // +02:00
-    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA);
+    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA, 3600);
 
     private long TEST_TIME_NOW =
             (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;

File: JodaTime/src/test/java/org/joda/time/chrono/TestLenientChronology.java
Patch:
@@ -120,7 +120,7 @@ public void testNearDstTransition() {
     /** Mock zone simulating America/Grand_Turk cutover at midnight 2007-04-01 */
     private static long CUTOVER_TURK = 1175403600000L;
     private static int OFFSET_TURK = -18000000;  // -05:00
-    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK);
+    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK, 3600);
 
     //-----------------------------------------------------------------------
     public void test_MockTurkIsCorrect() {

File: JodaTime/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -49,7 +49,7 @@
  *     .appendYears()
  *     .appendSuffix(" year", " years")
  *     .appendSeparator(" and ")
- *     .printZeroRarely()
+ *     .printZeroRarelyLast()
  *     .appendMonths()
  *     .appendSuffix(" month", " months")
  *     .toFormatter();

File: JodaTime/src/main/java/org/joda/time/DateTimeZone.java
Patch:
@@ -129,7 +129,8 @@ public static DateTimeZone getDefault() {
                     DateTimeZone temp = null;
                     try {
                         try {
-                            temp = forID(System.getProperty("user.timezone"));
+                            String id = System.getProperty("user.timezone");
+                            temp = (id == null ? UTC : forID(id));  // null check avoids stack overflow
                         } catch (RuntimeException ex) {
                             // ignored
                         }

File: JodaTime/src/main/java/org/joda/time/MonthDay.java
Patch:
@@ -434,7 +434,7 @@ public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {
      * This method is typically used to add multiple copies of complex
      * period instances. Adding one field is best achieved using methods
      * like {@link #withFieldAdded(DurationFieldType, int)}
-     * or {@link #plusYears(int)}.
+     * or {@link #plusMonths(int)}.
      * 
      * @param period  the period to add to this one, null means zero
      * @param scalar  the amount of times to add, such as -1 to subtract once
@@ -632,7 +632,7 @@ public MonthDay withMonthOfYear(int monthOfYear) {
      * Instead, this method returns a new instance with the value of
      * day of month changed.
      *
-     * @param dayOMonth  the day of month to set
+     * @param dayOfMonth  the day of month to set
      * @return a copy of this object with the field set, never null
      * @throws IllegalArgumentException if the value is invalid
      */

File: JodaTime/src/java/org/joda/time/LocalTime.java
Patch:
@@ -197,7 +197,7 @@ public static LocalTime fromDateFields(Date date) {
             date.getHours(),
             date.getMinutes(),
             date.getSeconds(),
-            (int) (date.getTime() % 1000)
+            (((int) (date.getTime() % 1000)) + 1000) % 1000
         );
     }
 

File: JodaTime/src/java/org/joda/time/TimeOfDay.java
Patch:
@@ -148,7 +148,7 @@ public static TimeOfDay fromDateFields(Date date) {
             date.getHours(),
             date.getMinutes(),
             date.getSeconds(),
-            (int) (date.getTime() % 1000)
+            (((int) (date.getTime() % 1000)) + 1000) % 1000
         );
     }
 

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestDays.java
Patch:
@@ -200,6 +200,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Days test = Days.SEVEN;
         
@@ -216,6 +217,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToStandardWeeks() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestHours.java
Patch:
@@ -202,6 +202,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Hours test = Hours.SEVEN;
         
@@ -218,6 +219,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToStandardWeeks() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestLocalDateTime_Basics.java
Patch:
@@ -841,6 +841,7 @@ public void testProperty() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40, COPTIC_PARIS);
         
@@ -860,6 +861,7 @@ public void testSerialization() throws Exception {
         assertTrue(Arrays.equals(test.getFields(), result.getFields()));
         assertEquals(test.getChronology(), result.getChronology());
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToString() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestLocalDate_Basics.java
Patch:
@@ -954,6 +954,7 @@ public void testProperty() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         LocalDate test = new LocalDate(1972, 6, 9, COPTIC_PARIS);
         
@@ -973,6 +974,7 @@ public void testSerialization() throws Exception {
         assertTrue(Arrays.equals(test.getFields(), result.getFields()));
         assertEquals(test.getChronology(), result.getChronology());
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToString() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestLocalTime_Basics.java
Patch:
@@ -757,6 +757,7 @@ public void testProperty() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_PARIS);
         
@@ -776,6 +777,7 @@ public void testSerialization() throws Exception {
         assertTrue(Arrays.equals(test.getFields(), result.getFields()));
         assertEquals(test.getChronology(), result.getChronology());
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToString() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestMinutes.java
Patch:
@@ -192,6 +192,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Minutes test = Minutes.THREE;
         
@@ -208,6 +209,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToStandardWeeks() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestMonths.java
Patch:
@@ -192,6 +192,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Months test = Months.THREE;
         
@@ -208,6 +209,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testPlus_int() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestPartial_Basics.java
Patch:
@@ -754,6 +754,7 @@ public void testProperty() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Partial test = createHourMinPartial(COPTIC_PARIS);
         
@@ -773,6 +774,7 @@ public void testSerialization() throws Exception {
         assertTrue(Arrays.equals(test.getFields(), result.getFields()));
         assertEquals(test.getChronology(), result.getChronology());
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testGetFormatter1() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestSeconds.java
Patch:
@@ -189,6 +189,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Seconds test = Seconds.THREE;
         
@@ -205,6 +206,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToStandardWeeks() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestTimeOfDay_Basics.java
Patch:
@@ -858,6 +858,7 @@ public void testProperty() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);
         
@@ -877,6 +878,7 @@ public void testSerialization() throws Exception {
         assertTrue(Arrays.equals(test.getFields(), result.getFields()));
         assertEquals(test.getChronology(), result.getChronology());
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToString() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestWeeks.java
Patch:
@@ -191,6 +191,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Weeks test = Weeks.THREE;
         
@@ -207,6 +208,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToStandardDays() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestYearMonthDay_Basics.java
Patch:
@@ -789,6 +789,7 @@ public void testProperty() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         YearMonthDay test = new YearMonthDay(1972, 6, 9, COPTIC_PARIS);
         
@@ -808,6 +809,7 @@ public void testSerialization() throws Exception {
         assertTrue(Arrays.equals(test.getFields(), result.getFields()));
         assertEquals(test.getChronology(), result.getChronology());
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testToString() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/TestYears.java
Patch:
@@ -174,6 +174,7 @@ public void testToString() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         Years test = Years.THREE;
         
@@ -190,6 +191,7 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testPlus_int() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestConverterSet.java
Patch:
@@ -70,6 +70,7 @@ public TestConverterSet(String name) {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testClass() throws Exception {
         Class cls = ConverterSet.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -82,6 +83,7 @@ public void testClass() throws Exception {
         assertEquals(false, Modifier.isProtected(con.getModifiers()));
         assertEquals(false, Modifier.isPrivate(con.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testBigHashtable() {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestDateConverter.java
Patch:
@@ -63,6 +63,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = DateConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -78,6 +79,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestLongConverter.java
Patch:
@@ -62,6 +62,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = LongConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -77,6 +78,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestReadableDurationConverter.java
Patch:
@@ -65,6 +65,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = ReadableDurationConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -80,6 +81,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestReadableInstantConverter.java
Patch:
@@ -66,6 +66,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = ReadableInstantConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -81,6 +82,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestReadableIntervalConverter.java
Patch:
@@ -68,6 +68,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = ReadableIntervalConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -83,6 +84,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestReadablePartialConverter.java
Patch:
@@ -69,6 +69,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = ReadablePartialConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -84,6 +85,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/convert/TestReadablePeriodConverter.java
Patch:
@@ -64,6 +64,7 @@ protected void setUp() throws Exception {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSingleton() throws Exception {
         Class cls = ReadablePeriodConverter.class;
         assertEquals(false, Modifier.isPublic(cls.getModifiers()));
@@ -79,6 +80,7 @@ public void testSingleton() throws Exception {
         assertEquals(false, Modifier.isProtected(fld.getModifiers()));
         assertEquals(false, Modifier.isPrivate(fld.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testSupportedType() throws Exception {

File: JodaTimeContrib/gwt/branch/test/org/joda/time/field/TestMillisDurationField.java
Patch:
@@ -196,6 +196,7 @@ public void test_compareTo() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         DurationField test = MillisDurationField.INSTANCE;
         
@@ -212,5 +213,6 @@ public void testSerialization() throws Exception {
         
         assertSame(test, result);
     }
+    //END GWT IGNORE
 
 }

File: JodaTimeContrib/gwt/branch/test/org/joda/time/field/TestPreciseDurationField.java
Patch:
@@ -255,6 +255,7 @@ public void test_compareTo() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         DurationField test = iField;
         
@@ -271,5 +272,6 @@ public void testSerialization() throws Exception {
         
         assertEquals(test, result);
     }
+    //END GWT IGNORE
 
 }

File: JodaTimeContrib/gwt/branch/test/org/joda/time/field/TestScaledDurationField.java
Patch:
@@ -272,6 +272,7 @@ public void test_compareTo() {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testSerialization() throws Exception {
         DurationField test = iField;
         
@@ -288,5 +289,6 @@ public void testSerialization() throws Exception {
         
         assertEquals(test, result);
     }
+    //END GWT IGNORE
 
 }

File: JodaTimeContrib/gwt/branch/test/org/joda/time/tz/TestUTCProvider.java
Patch:
@@ -46,6 +46,7 @@ public TestUTCProvider(String name) {
     }
 
     //-----------------------------------------------------------------------
+    //BEGIN GWT IGNORE
     public void testClass() throws Exception {
         Class cls = UTCProvider.class;
         assertEquals(true, Modifier.isPublic(cls.getModifiers()));
@@ -54,6 +55,7 @@ public void testClass() throws Exception {
         assertEquals(1, cls.getDeclaredConstructors().length);
         assertEquals(true, Modifier.isPublic(con.getModifiers()));
     }
+    //END GWT IGNORE
 
     //-----------------------------------------------------------------------
     public void testGetAvailableIDs() throws Exception {

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java
Patch:
@@ -35,9 +35,9 @@
  */
 public class PersistentDateTimeTZ implements UserType, Serializable
 {
-	public final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();
+    public final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();
 
-	private static final int[] SQL_TYPES = new int[]
+    private static final int[] SQL_TYPES = new int[]
     {
         Types.TIMESTAMP,
         Types.VARCHAR,

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInstant.java
Patch:
@@ -126,7 +126,7 @@ public Object replace(Object original, Object target, Object owner) throws Hiber
         return original;
     }
 
-	// __________ EnhancedUserType ____________________
+    // __________ EnhancedUserType ____________________
 
     public String objectToSQLString(Object object)
     {

File: JodaTime/src/test/org/joda/time/format/TestDateTimeFormatter.java
Patch:
@@ -257,11 +257,11 @@ public void testWithGetZone() {
 
     public void testWithGetChronology() {
         DateTimeFormatter f2 = f.withChronology(BUDDHIST_PARIS);
-        assertEquals(BUDDHIST_PARIS, f2.getChronolgy());
+        assertEquals(BUDDHIST_PARIS, f2.getChronology());
         assertSame(f2, f2.withChronology(BUDDHIST_PARIS));
         
         f2 = f.withChronology(null);
-        assertEquals(null, f2.getChronolgy());
+        assertEquals(null, f2.getChronology());
         assertSame(f2, f2.withChronology(null));
     }
 

File: JodaTime/src/java/org/joda/time/DateTimeZone.java
Patch:
@@ -196,7 +196,7 @@ public static DateTimeZone forID(String id) {
                 return fixedOffsetZone(id, offset);
             }
         }
-        throw new IllegalArgumentException("The datetime zone id is not recognised: " + id);
+        throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised");
     }
 
     /**
@@ -310,8 +310,7 @@ public static DateTimeZone forTimeZone(TimeZone zone) {
                 }
             }
         }
-
-        throw new IllegalArgumentException("The datetime zone id is not recognised: " + id);
+        throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised");
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/Months.java
Patch:
@@ -41,7 +41,7 @@ public final class Months extends BaseSingleFieldPeriod {
 
     /** Constant representing zero months. */
     public static final Months ZERO = new Months(0);
-    /** Constant representing one day. */
+    /** Constant representing one month. */
     public static final Months ONE = new Months(1);
     /** Constant representing two months. */
     public static final Months TWO = new Months(2);
@@ -70,7 +70,7 @@ public final class Months extends BaseSingleFieldPeriod {
     /** Constant representing the minimum number of months that can be stored in this object. */
     public static final Months MIN_VALUE = new Months(Integer.MIN_VALUE);
 
-    /** The paser to use for this class. */
+    /** The parser to use for this class. */
     private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.months());
     /** Serialization version. */
     private static final long serialVersionUID = 87525275727380867L;

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTime.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import org.joda.time.DateTime;
 
 /**
- * Persist {@link org.joda.time.DateTime} via hibernate
+ * Persist {@link org.joda.time.DateTime} via hibernate.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -28,8 +28,8 @@
 import org.joda.time.DateTimeZone;
 
 /**
- * Persist {@link org.joda.time.DateTime} via hibernate.<br />
- * The timezone will be stored in an extra column
+ * Persist {@link org.joda.time.DateTime} via hibernate.
+ * The timezone will be stored in an extra column.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentInterval.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import org.joda.time.LocalDate;
 
 /**
- * Persist {@link org.joda.time.LocalDate} via hibernate
+ * Persist {@link org.joda.time.LocalDate} via hibernate.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalDateTime.java
Patch:
@@ -27,7 +27,7 @@
 import org.joda.time.LocalDateTime;
 
 /**
- * Persist {@link org.joda.time.LocalDateTime} via hibernate
+ * Persist {@link org.joda.time.LocalDateTime} via hibernate.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import org.joda.time.LocalTime;
 
 /**
- * Persist {@link org.joda.time.LocalDate} via hibernate
+ * Persist {@link org.joda.time.LocalDate} via hibernate.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeAsTime.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -29,8 +29,8 @@
 import org.joda.time.LocalTime;
 
 /**
- * Persist {@link org.joda.time.LocalDate} via hibernate
- * This uses a simple integer to store the time as milliseconds since 1970-1-1. <br />
+ * Persist {@link org.joda.time.LocalDate} via hibernate.
+ * This uses a simple integer to store the time as milliseconds since 1970-1-1.
  * The milliseconds will survive.
  *
  * @author Mario Ivankovits (mario@ops.co.at)

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentLocalTimeExact.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import org.joda.time.LocalTime;
 
 /**
- * Persist {@link org.joda.time.LocalDate} via hibernate
+ * Persist {@link org.joda.time.LocalDate} via hibernate.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -29,8 +29,8 @@
 import org.joda.time.TimeOfDay;
 
 /**
- * Persist {@link org.joda.time.TimeOfDay} via hibernate. <br />
- * This uses java.sql.Time and the time datatype of your database. <br />
+ * Persist {@link org.joda.time.TimeOfDay} via hibernate.
+ * This uses java.sql.Time and the time datatype of your database.
  * Notice: You might loose the milliseconds part.
  *
  * @author Mario Ivankovits (mario@ops.co.at)

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,8 +27,8 @@
 import org.joda.time.TimeOfDay;
 
 /**
- * Persist {@link org.joda.time.TimeOfDay} via hibernate.<br />
- * This uses a simple integer to store the time as milliseconds since 1970-1-1. <br />
+ * Persist {@link org.joda.time.TimeOfDay} via hibernate.
+ * This uses a simple integer to store the time as milliseconds since 1970-1-1.
  * The milliseconds will survive.
  *
  * @author Mario Ivankovits (mario@ops.co.at)

File: JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentYearMonthDay.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@
 import org.joda.time.YearMonthDay;
 
 /**
- * Persist {@link org.joda.time.YearMonthDay} via hibernate
+ * Persist {@link org.joda.time.YearMonthDay} via hibernate.
  *
  * @author Mario Ivankovits (mario@ops.co.at)
  */

File: JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -1443,7 +1443,7 @@ long getFieldValue(ReadablePeriod period) {
                     if (isZero(period) && iFieldFormatters[iFieldType] == this) {
                         int i = Math.min(iFieldType, 8);  // line split out for IBM JDK
                         i--;                              // see bug 1660490
-                        for (; i >= 0 && i <= MAX_FIELD; i++) {
+                        for (; i >= 0 && i <= MAX_FIELD; i--) {
                             if (isSupported(type, i) && iFieldFormatters[i] != null) {
                                 return Long.MAX_VALUE;
                             }

File: JodaTime/src/java/org/joda/time/Duration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2005,2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2006 Stephen Colebourne
+ *  Copyright 2001-2006,2008 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

File: JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
Patch:
@@ -291,7 +291,7 @@ static class ZonedDurationField extends BaseDurationField {
         }
 
         public boolean isPrecise() {
-            return iTimeField ? iField.isPrecise() : this.iZone.isFixed();
+            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();
         }
 
         public long getUnitMillis() {

File: JodaTime/src/java/org/joda/time/LocalTime.java
Patch:
@@ -1196,7 +1196,7 @@ public DateTime toDateTimeToday(DateTimeZone zone) {
 
     //-----------------------------------------------------------------------
     /**
-     * Output the time in ISO8601 format (HH:mm:ss.SSSZ).
+     * Output the time in ISO8601 format (HH:mm:ss.SSSZZ).
      * 
      * @return ISO8601 time formatted string.
      */

File: JodaTime/src/java/org/joda/time/MutableDateTime.java
Patch:
@@ -1141,7 +1141,7 @@ public Object clone() {
     }
 
     /**
-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).
+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
      * 
      * @return ISO8601 time formatted string.
      */

File: JodaTime/src/java/org/joda/time/base/AbstractInstant.java
Patch:
@@ -416,7 +416,7 @@ public boolean isEqual(ReadableInstant instant) {
 
     //-----------------------------------------------------------------------
     /**
-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).
+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
      * 
      * @return ISO8601 time formatted string.
      */

File: JodaTime/src/java/org/joda/time/DateTimeZone.java
Patch:
@@ -864,7 +864,7 @@ public int getOffsetFromLocal(long instantLocal) {
         if (offsetLocal != offsetAdjusted) {
             // we need to ensure that time is always after the DST gap
             // this happens naturally for positive offsets, but not for negative
-            if (offsetLocal < 0) {
+            if ((offsetLocal - offsetAdjusted) < 0) {
                 // if we just return offsetAdjusted then the time is pushed
                 // back before the transition, whereas it should be
                 // on or after the transition

File: JodaTime/src/java/org/joda/time/Days.java
Patch:
@@ -55,9 +55,9 @@ public final class Days extends BaseSingleFieldPeriod {
     public static final Days SIX = new Days(6);
     /** Constant representing seven days. */
     public static final Days SEVEN = new Days(7);
-    /** Constant representing the maximum nuber of days that can be stored in this object. */
+    /** Constant representing the maximum number of days that can be stored in this object. */
     public static final Days MAX_VALUE = new Days(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of days that can be stored in this object. */
+    /** Constant representing the minimum number of days that can be stored in this object. */
     public static final Days MIN_VALUE = new Days(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/java/org/joda/time/Hours.java
Patch:
@@ -55,11 +55,11 @@ public final class Hours extends BaseSingleFieldPeriod {
     public static final Hours SIX = new Hours(6);
     /** Constant representing seven hours. */
     public static final Hours SEVEN = new Hours(7);
-    /** Constant representing seven hours. */
+    /** Constant representing eight hours. */
     public static final Hours EIGHT = new Hours(8);
-    /** Constant representing the maximum nuber of hours that can be stored in this object. */
+    /** Constant representing the maximum number of hours that can be stored in this object. */
     public static final Hours MAX_VALUE = new Hours(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of hours that can be stored in this object. */
+    /** Constant representing the minimum number of hours that can be stored in this object. */
     public static final Hours MIN_VALUE = new Hours(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/java/org/joda/time/Minutes.java
Patch:
@@ -47,9 +47,9 @@ public final class Minutes extends BaseSingleFieldPeriod {
     public static final Minutes TWO = new Minutes(2);
     /** Constant representing three minutes. */
     public static final Minutes THREE = new Minutes(3);
-    /** Constant representing the maximum nuber of minutes that can be stored in this object. */
+    /** Constant representing the maximum number of minutes that can be stored in this object. */
     public static final Minutes MAX_VALUE = new Minutes(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of minutes that can be stored in this object. */
+    /** Constant representing the minimum number of minutes that can be stored in this object. */
     public static final Minutes MIN_VALUE = new Minutes(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/java/org/joda/time/Months.java
Patch:
@@ -65,9 +65,9 @@ public final class Months extends BaseSingleFieldPeriod {
     public static final Months ELEVEN = new Months(11);
     /** Constant representing twelve months. */
     public static final Months TWELVE = new Months(12);
-    /** Constant representing the maximum nuber of months that can be stored in this object. */
+    /** Constant representing the maximum number of months that can be stored in this object. */
     public static final Months MAX_VALUE = new Months(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of months that can be stored in this object. */
+    /** Constant representing the minimum number of months that can be stored in this object. */
     public static final Months MIN_VALUE = new Months(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/java/org/joda/time/Seconds.java
Patch:
@@ -47,9 +47,9 @@ public final class Seconds extends BaseSingleFieldPeriod {
     public static final Seconds TWO = new Seconds(2);
     /** Constant representing three seconds. */
     public static final Seconds THREE = new Seconds(3);
-    /** Constant representing the maximum nuber of seconds that can be stored in this object. */
+    /** Constant representing the maximum number of seconds that can be stored in this object. */
     public static final Seconds MAX_VALUE = new Seconds(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of seconds that can be stored in this object. */
+    /** Constant representing the minimum number of seconds that can be stored in this object. */
     public static final Seconds MIN_VALUE = new Seconds(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/java/org/joda/time/Weeks.java
Patch:
@@ -47,9 +47,9 @@ public final class Weeks extends BaseSingleFieldPeriod {
     public static final Weeks TWO = new Weeks(2);
     /** Constant representing three weeks. */
     public static final Weeks THREE = new Weeks(3);
-    /** Constant representing the maximum nuber of weeks that can be stored in this object. */
+    /** Constant representing the maximum number of weeks that can be stored in this object. */
     public static final Weeks MAX_VALUE = new Weeks(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of weeks that can be stored in this object. */
+    /** Constant representing the minimum number of weeks that can be stored in this object. */
     public static final Weeks MIN_VALUE = new Weeks(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/java/org/joda/time/Years.java
Patch:
@@ -41,15 +41,15 @@ public final class Years extends BaseSingleFieldPeriod {
 
     /** Constant representing zero years. */
     public static final Years ZERO = new Years(0);
-    /** Constant representing one day. */
+    /** Constant representing one year. */
     public static final Years ONE = new Years(1);
     /** Constant representing two years. */
     public static final Years TWO = new Years(2);
     /** Constant representing three years. */
     public static final Years THREE = new Years(3);
-    /** Constant representing the maximum nuber of years that can be stored in this object. */
+    /** Constant representing the maximum number of years that can be stored in this object. */
     public static final Years MAX_VALUE = new Years(Integer.MAX_VALUE);
-    /** Constant representing the minimum nuber of years that can be stored in this object. */
+    /** Constant representing the minimum number of years that can be stored in this object. */
     public static final Years MIN_VALUE = new Years(Integer.MIN_VALUE);
 
     /** The paser to use for this class. */

File: JodaTime/src/test/org/joda/time/TestDateTimeZone.java
Patch:
@@ -843,7 +843,7 @@ public void testPatchedNameKeysLondon() throws Exception {
         // the tz database does not have unique name keys [1716305]
         DateTimeZone zone = DateTimeZone.forID("Europe/London");
         
-        DateTime now = new DateTime();
+        DateTime now = new DateTime(2007, 1, 1, 0, 0, 0, 0);
         String str1 = zone.getName(now.getMillis());
         String str2 = zone.getName(now.plusMonths(6).getMillis());
         assertEquals(false, str1.equals(str2));
@@ -853,7 +853,7 @@ public void testPatchedNameKeysSydney() throws Exception {
         // the tz database does not have unique name keys [1716305]
         DateTimeZone zone = DateTimeZone.forID("Australia/Sydney");
         
-        DateTime now = new DateTime();
+        DateTime now = new DateTime(2007, 1, 1, 0, 0, 0, 0);
         String str1 = zone.getName(now.getMillis());
         String str2 = zone.getName(now.plusMonths(6).getMillis());
         assertEquals(false, str1.equals(str2));

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -413,7 +413,7 @@ public DateTimeFormatterBuilder appendDecimal(
      * printed value requires more digits
      * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
-     * @since 1.4
+     * @since 1.5
      */
     public DateTimeFormatterBuilder appendFixedDecimal(
             DateTimeFieldType fieldType, int numDigits) {
@@ -465,7 +465,7 @@ public DateTimeFormatterBuilder appendSignedDecimal(
      * printed value requires more digits
      * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>
-     * @since 1.4
+     * @since 1.5
      */
     public DateTimeFormatterBuilder appendFixedSignedDecimal(
             DateTimeFieldType fieldType, int numDigits) {

File: JodaTime/src/java/org/joda/time/PeriodType.java
Patch:
@@ -682,12 +682,12 @@ int getIndexedField(ReadablePeriod period, int index) {
      * @param index  the index to use
      * @param values  the array to populate
      * @param newValue  the value to set
-     * @throws IllegalArgumentException if not supported
+     * @throws UnsupportedOperationException if not supported
      */
     boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {
         int realIndex = iIndices[index];
         if (realIndex == -1) {
-            throw new IllegalArgumentException("Field is not supported");
+            throw new UnsupportedOperationException("Field is not supported");
         }
         values[realIndex] = newValue;
         return true;

File: JodaTime/src/java/org/joda/time/PeriodType.java
Patch:
@@ -700,12 +700,12 @@ boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newV
      * @param index  the index to use
      * @param values  the array to populate
      * @param valueToAdd  the value to add
-     * @throws IllegalArgumentException if not supported
+     * @throws UnsupportedOperationException if not supported
      */
     boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) {
         int realIndex = iIndices[index];
         if (realIndex == -1) {
-            throw new IllegalArgumentException("Field is not supported");
+            throw new UnsupportedOperationException("Field is not supported");
         }
         values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd);
         return true;

File: JodaTime/src/test/org/joda/time/TestPeriod_Basics.java
Patch:
@@ -730,7 +730,7 @@ public void testPlus() {
         try {
             test.plusYears(1);
             fail();
-        } catch (IllegalArgumentException ex) {}
+        } catch (UnsupportedOperationException ex) {}
     }
 
     public void testPlusZero() {
@@ -784,7 +784,7 @@ public void testMinus() {
         try {
             test.minusYears(1);
             fail();
-        } catch (IllegalArgumentException ex) {}
+        } catch (UnsupportedOperationException ex) {}
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/Days.java
Patch:
@@ -323,7 +323,7 @@ public Seconds toStandardSeconds() {
      * not be true for some unusual chronologies. However, it is included as it
      * is a useful operation for many applications and business rules.
      * 
-     * @return a period representing the number of hours for this number of days
+     * @return a duration equivalent to this number of days
      */
     public Duration toStandardDuration() {
         long days = getValue();  // assign to a long

File: JodaTime/src/java/org/joda/time/Hours.java
Patch:
@@ -322,7 +322,7 @@ public Seconds toStandardSeconds() {
      * However, the method is included as it is a useful operation for many
      * applications and business rules.
      *
-     * @return a period representing the number of hours for this number of hours
+     * @return a duration equivalent to this number of hours
      */
     public Duration toStandardDuration() {
         long hours = getValue();  // assign to a long

File: JodaTime/src/java/org/joda/time/Minutes.java
Patch:
@@ -303,7 +303,7 @@ public Seconds toStandardSeconds() {
      * However, the method is included as it is a useful operation for many
      * applications and business rules.
      *
-     * @return a period representing the number of minutes for this number of minutes
+     * @return a duration equivalent to this number of minutes
      */
     public Duration toStandardDuration() {
         long minutes = getValue();  // assign to a long

File: JodaTime/src/java/org/joda/time/Seconds.java
Patch:
@@ -303,7 +303,7 @@ public Minutes toStandardMinutes() {
      * not be true for some unusual chronologies. However, it is included as it
      * is a useful operation for many applications and business rules.
      * 
-     * @return a period representing the number of hours for this number of seconds
+     * @return a duration equivalent to this number of seconds
      */
     public Duration toStandardDuration() {
         long seconds = getValue();  // assign to a long

File: JodaTime/src/java/org/joda/time/Weeks.java
Patch:
@@ -309,7 +309,7 @@ public Seconds toStandardSeconds() {
      * not be true for some unusual chronologies. However, it is included as it
      * is a useful operation for many applications and business rules.
      * 
-     * @return a period representing the number of hours for this number of weeks
+     * @return a duration equivalent to this number of weeks
      */
     public Duration toStandardDuration() {
         long weeks = getValue();  // assign to a long

File: JodaTime/src/java/org/joda/time/base/BasePeriod.java
Patch:
@@ -325,7 +325,7 @@ public int getValue(int index) {
     /**
      * Gets the total millisecond duration of this period relative to a start instant.
      * <p>
-     * This method adds the period to the specifed instant in order to
+     * This method adds the period to the specified instant in order to
      * calculate the duration.
      * <p>
      * An instant must be supplied as the duration of a period varies.

File: JodaTime/src/java/org/joda/time/DateTimeZone.java
Patch:
@@ -266,6 +266,9 @@ public static DateTimeZone forOffsetMillis(int millisOffset) {
      * excluded IDs are the short three letter form (except UTC). This 
      * method will attempt to convert between time zones created using the
      * short IDs and the full version.
+     * <p>
+     * This method is not designed to parse time zones with rules created by
+     * applications using <code>SimpleTimeZone</code> directly.
      * 
      * @param zone  the zone to convert, null means default
      * @return the DateTimeZone object for the zone

File: JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
Patch:
@@ -110,8 +110,8 @@ protected void assemble(Fields fields) {
         fields.halfdayOfDay = convertField(fields.halfdayOfDay);
     }
 
-    private static final DateTimeField convertField(DateTimeField field) {
-        return LenientDateTimeField.getInstance(field);
+    private final DateTimeField convertField(DateTimeField field) {
+        return LenientDateTimeField.getInstance(field, getBase());
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/test/org/joda/time/TestAll.java
Patch:
@@ -113,6 +113,7 @@ public static Test suite() {
         suite.addTest(TestDateTimeConstants.suite());
         suite.addTest(TestDateTimeUtils.suite());
         suite.addTest(TestDateTimeZone.suite());
+        suite.addTest(TestDateTimeZoneCutover.suite());
         suite.addTest(TestPeriodType.suite());
 //        suite.addTest(TestParseISO.suite());
         suite.addTest(TestDurationField.suite());

File: JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -371,7 +371,7 @@ public Map compile(File outputDir, File[] sources) throws IOException {
             Zone zone = (Zone)iZones.get(i);
             DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
             zone.addToBuilder(builder, iRuleSets);
-            final DateTimeZone original = builder.toDateTimeZone(zone.iName);
+            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
             DateTimeZone tz = original;
             if (test(tz.getID(), tz)) {
                 map.put(tz.getID(), tz);
@@ -382,7 +382,7 @@ public Map compile(File outputDir, File[] sources) throws IOException {
                         file.getParentFile().mkdirs();
                     }
                     OutputStream out = new FileOutputStream(file);
-                    builder.writeTo(out);
+                    builder.writeTo(zone.iName, out);
                     out.close();
 
                     // Test if it can be read back.

File: JodaTime/src/test/org/joda/time/tz/TestBuilder.java
Patch:
@@ -188,7 +188,7 @@ static DateTimeZoneBuilder buildAmericaLosAngelesBuilder() {
     }
 
     static DateTimeZone buildAmericaLosAngeles() {
-        return buildAmericaLosAngelesBuilder().toDateTimeZone("America/Los_Angeles");
+        return buildAmericaLosAngelesBuilder().toDateTimeZone("America/Los_Angeles", true);
     }
 
     private DateTimeZone originalDateTimeZone = null;
@@ -287,7 +287,7 @@ static DateTimeZone testSerialization(DateTimeZoneBuilder builder, String id)
         throws IOException
     {
         ByteArrayOutputStream out = new ByteArrayOutputStream();
-        builder.writeTo(out);
+        builder.writeTo("America/Los_Angeles", out);
         ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
         DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);
         assertEquals(id, tz.getID());
@@ -298,7 +298,7 @@ public void testFixed() throws IOException {
         DateTimeZoneBuilder builder = new DateTimeZoneBuilder()
             .setStandardOffset(3600000)
             .setFixedSavings("LMT", 0);
-        DateTimeZone tz = builder.toDateTimeZone("Test");
+        DateTimeZone tz = builder.toDateTimeZone("Test", true);
 
         for (int i=0; i<2; i++) {
             assertEquals("Test", tz.getID());

File: JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java
Patch:
@@ -65,7 +65,7 @@ public final boolean isLenient() {
      */
     public long set(long instant, int value) {
         int min = getMinimumValue(instant);
-        if (value >= min && value < getMaximumValue(instant)) {
+        if (value >= min && value <= getMaximumValue(instant)) {
             return super.set(instant, value);
         }
         return add(super.set(instant, min), value - min);

File: JodaTime/src/test/org/joda/time/chrono/TestAll.java
Patch:
@@ -46,6 +46,7 @@ public static Test suite() {
         suite.addTest(TestIslamicChronology.suite());
         suite.addTest(TestJulianChronology.suite());
         suite.addTest(TestISOChronology.suite());
+        suite.addTest(TestLenientChronology.suite());
         
         return suite;
     }

File: JodaTime/src/test/org/joda/time/TestDateTimeFieldType.java
Patch:
@@ -289,6 +289,7 @@ public void test_other() throws Exception {
         Constructor con = cls.getDeclaredConstructors()[0];
         Object[] params = new Object[] {
             "other", new Byte((byte) 128), DurationFieldType.hours(), DurationFieldType.months()};
+        con.setAccessible(true);  // for Apache Harmony JVM
         DateTimeFieldType type = (DateTimeFieldType) con.newInstance(params);
         
         assertEquals("other", type.getName());

File: JodaTime/src/java/org/joda/time/DateTimeZone.java
Patch:
@@ -877,7 +877,7 @@ public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {
     /**
      * Get the datetime zone as a {@link java.util.TimeZone}.
      * 
-     * @return the equivalent TimeZone object
+     * @return the closest matching TimeZone object
      */
     public java.util.TimeZone toTimeZone() {
         return java.util.TimeZone.getTimeZone(iID);

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -39,7 +39,7 @@
  * <p>
  * DateTimeFormatterBuilder is used for constructing formatters which are then
  * used to print or parse. The formatters are built by appending specific fields
- * or other formatters to an instanece of this builder.
+ * or other formatters to an instance of this builder.
  * <p>
  * For example, a formatter that prints month and year, like "January 1970",
  * can be constructed as follows:

File: JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -38,7 +38,7 @@
  * <p>
  * PeriodFormatterBuilder is used for constructing formatters which are then
  * used to print or parse. The formatters are built by appending specific fields
- * or other formatters to an instanece of this builder.
+ * or other formatters to an instance of this builder.
  * <p>
  * For example, a formatter that prints years and months, like "15 years and 8 months",
  * can be constructed as follows:

File: JodaTime/src/java/org/joda/time/base/AbstractPartial.java
Patch:
@@ -23,6 +23,7 @@
 import org.joda.time.DurationFieldType;
 import org.joda.time.ReadableInstant;
 import org.joda.time.ReadablePartial;
+import org.joda.time.field.FieldUtils;
 import org.joda.time.format.DateTimeFormatter;
 
 /**
@@ -266,7 +267,7 @@ public boolean equals(Object partial) {
                 return false;
             }
         }
-        return (getChronology() == other.getChronology());
+        return FieldUtils.equals(getChronology(), other.getChronology());
     }
 
     /**

File: JodaTime/src/java/org/joda/time/base/BaseSingleFieldPeriod.java
Patch:
@@ -170,7 +170,7 @@ protected int getValue() {
      * Sets the amount of this period.
      * To make a subclass immutable you must declare it final, or block this method.
      *
-     * @param vaue  the period value
+     * @param value  the period value
      */
     protected void setValue(int value) {
         iPeriod = value;

File: JodaTime/src/java/org/joda/time/LocalDate.java
Patch:
@@ -258,6 +258,7 @@ public LocalDate(long instant, Chronology chronology) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @throws IllegalArgumentException if the instant is invalid
@@ -278,6 +279,7 @@ public LocalDate(Object instant) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @param zone  the time zone
@@ -303,6 +305,7 @@ public LocalDate(Object instant, DateTimeZone zone) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @param chronology  the chronology

File: JodaTime/src/java/org/joda/time/LocalDateTime.java
Patch:
@@ -252,6 +252,7 @@ public LocalDateTime(long instant, Chronology chronology) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @throws IllegalArgumentException if the instant is invalid
@@ -272,6 +273,7 @@ public LocalDateTime(Object instant) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @param zone  the time zone
@@ -297,6 +299,7 @@ public LocalDateTime(Object instant, DateTimeZone zone) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @param chronology  the chronology

File: JodaTime/src/java/org/joda/time/LocalTime.java
Patch:
@@ -287,6 +287,7 @@ public LocalTime(long instant, Chronology chronology) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @throws IllegalArgumentException if the instant is invalid
@@ -307,6 +308,7 @@ public LocalTime(Object instant) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @param zone  the time zone
@@ -332,6 +334,7 @@ public LocalTime(Object instant, DateTimeZone zone) {
      * {@link org.joda.time.convert.ConverterManager ConverterManager} and
      * include ReadablePartial, ReadableInstant, String, Calendar and Date.
      * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.
+     * The default String converter ignores the zone and only parses the field values.
      *
      * @param instant  the datetime object
      * @param chronology  the chronology

File: JodaTime/src/java/org/joda/time/Partial.java
Patch:
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2006 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -780,9 +780,9 @@ public String toString(String pattern, Locale locale) {
 
     //-----------------------------------------------------------------------
     /**
-     * The property class for <code>YearMonthDay</code>.
+     * The property class for <code>Partial</code>.
      * <p>
-     * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.
+     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.
      * 
      * @author Stephen Colebourne
      * @since 1.1

File: JodaTime/src/java/org/joda/time/LocalTime.java
Patch:
@@ -68,7 +68,7 @@
  * All standard Chronology classes supplied are thread-safe and immutable.
  *
  * @author Stephen Colebourne
- * @since 1.0
+ * @since 1.3
  */
 public final class LocalTime
         extends AbstractPartial
@@ -1204,7 +1204,7 @@ public String toString(String pattern, Locale locale) throws IllegalArgumentExce
      *
      * @author Stephen Colebourne
      * @author Brian S O'Neill
-     * @since 1.2
+     * @since 1.3
      */
     public static final class Property extends AbstractReadableInstantFieldProperty {
         

File: JodaTime/src/java/org/joda/time/TimeOfDay.java
Patch:
@@ -265,7 +265,7 @@ public TimeOfDay(long instant, Chronology chronology) {
      * @throws IllegalArgumentException if the instant is invalid
      */
     public TimeOfDay(Object instant) {
-        super(instant, null);
+        super(instant, null, ISODateTimeFormat.timeParser());
     }
 
     /**
@@ -295,7 +295,7 @@ public TimeOfDay(Object instant) {
      * @throws IllegalArgumentException if the instant is invalid
      */
     public TimeOfDay(Object instant, Chronology chronology) {
-        super(instant, DateTimeUtils.getChronology(chronology));
+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser());
     }
 
     /**

File: JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java
Patch:
@@ -90,7 +90,7 @@ public int getMaximumValue(ReadablePartial partial, int[] values) {
 
     protected int getMaximumValueForSet(long instant, int value) {
         int maxLessOne = iChronology.getDaysInYearMax() - 1;
-        return value > maxLessOne ? getMaximumValue(instant) : maxLessOne;
+        return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne;
     }
 
     /**

File: JodaTime/src/java/org/joda/time/LocalDate.java
Patch:
@@ -714,7 +714,7 @@ public LocalDate withFields(ReadablePartial partial) {
      * month of year field will be changed in the returned instance.
      * If the field type is null, then <code>this</code> is returned.
      * <p>
-     * These three lines are equivalent:
+     * These two lines are equivalent:
      * <pre>
      * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);
      * LocalDate updated = dt.dayOfMonth().withValue(6);

File: JodaTime/src/java/org/joda/time/LocalDateTime.java
Patch:
@@ -412,10 +412,10 @@ public LocalDateTime(
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the number of fields in this partial, which is three.
+     * Gets the number of fields in this partial, which is four.
      * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
      *
-     * @return the field count, three
+     * @return the field count, four
      */
     public int size() {
         return 4;

File: JodaTime/src/test/org/joda/time/TestDateMidnight_Properties.java
Patch:
@@ -205,8 +205,8 @@ public void testPropertyGetYear() {
         assertEquals(9, test.year().getMaximumShortTextLength(null));
         assertEquals(-292275054, test.year().getMinimumValue());
         assertEquals(-292275054, test.year().getMinimumValueOverall());
-        assertEquals(292277023, test.year().getMaximumValue());
-        assertEquals(292277023, test.year().getMaximumValueOverall());
+        assertEquals(292278993, test.year().getMaximumValue());
+        assertEquals(292278993, test.year().getMaximumValueOverall());
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/test/org/joda/time/TestMutableDateTime_Properties.java
Patch:
@@ -200,8 +200,8 @@ public void testPropertyGetYear() {
         assertEquals(9, test.year().getMaximumShortTextLength(null));
         assertEquals(-292275054, test.year().getMinimumValue());
         assertEquals(-292275054, test.year().getMinimumValueOverall());
-        assertEquals(292277023, test.year().getMaximumValue());
-        assertEquals(292277023, test.year().getMaximumValueOverall());
+        assertEquals(292278993, test.year().getMaximumValue());
+        assertEquals(292278993, test.year().getMaximumValueOverall());
     }
 
     public void testPropertyAddYear() {

File: JodaTime/src/java/org/joda/time/LocalDate.java
Patch:
@@ -259,7 +259,6 @@ public LocalDate(long instant, Chronology chronology) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object
-     * @param zone  the time zone
      * @throws IllegalArgumentException if the instant is invalid
      */
     public LocalDate(Object instant) {
@@ -1218,7 +1217,7 @@ public LocalDate withYearOfEra(int yearOfEra) {
      * Instead, this method returns a new instance with the value of
      * year of century changed.
      *
-     * @param year of century  the year of century to set
+     * @param yearOfCentury  the year of century to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      */
@@ -1495,6 +1494,7 @@ public String toString(String pattern, Locale locale) throws IllegalArgumentExce
      * <pre>
      * LocalDate dt = new LocalDate(1972, 12, 3);
      * LocalDate dt1920 = dt.year().withValue(1920);
+     * </pre>
      * <p>
      * LocalDate.Propery itself is thread-safe and immutable, as well as the
      * LocalDate being operated on.

File: JodaTime/src/java/org/joda/time/LocalDateTime.java
Patch:
@@ -1422,7 +1422,7 @@ public LocalDateTime withYearOfEra(int yearOfEra) {
      * Instead, this method returns a new instance with the value of
      * year of century changed.
      *
-     * @param year of century  the year of century to set
+     * @param yearOfCentury  the year of century to set
      * @return a copy of this object with the field set
      * @throws IllegalArgumentException if the value is invalid
      */
@@ -1800,6 +1800,7 @@ public String toString(String pattern, Locale locale) throws IllegalArgumentExce
      * <pre>
      * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0, 0, 0);
      * LocalDateTime dt1920 = dt.year().setCopy(1920);
+     * </pre>
      * <p>
      * LocalDateTime.Propery itself is thread-safe and immutable, as well as the
      * LocalDateTime being operated on.

File: JodaTime/src/java/org/joda/time/LocalTime.java
Patch:
@@ -702,7 +702,7 @@ public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) {
      * <p>
      * This method is typically used to add complex period instances.
      * Adding one field is best achieved using methods
-     * like {@link #plusYears(int)}.
+     * like {@link #plusHours(int)}.
      * 
      * @param period  the period to add to this one, null means zero
      * @return a copy of this time with the period added
@@ -813,7 +813,7 @@ public LocalTime plusMillis(int millis) {
      * <p>
      * This method is typically used to subtract complex period instances.
      * Subtracting one field is best achieved using methods
-     * like {@link #minusYears(int)}.
+     * like {@link #minusHours(int)}.
      * 
      * @param period  the period to reduce this instant by
      * @return a copy of this time with the period taken away
@@ -1160,6 +1160,7 @@ public String toString(String pattern, Locale locale) throws IllegalArgumentExce
      * <pre>
      * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
      * DateTime dt1920 = dt.year().setCopy(1920);
+     * </pre>
      * <p>
      * LocalTime.Propery itself is thread-safe and immutable, as well as the
      * LocalTime being operated on.

File: JodaTime/src/test/org/joda/time/TestDateTime_Basics.java
Patch:
@@ -505,7 +505,7 @@ public void testToDateTimeISO() {
         assertSame(DateTime.class, result.getClass());
         assertSame(ISOChronology.class, result.getChronology().getClass());
         assertEquals(test.getMillis(), result.getMillis());
-        assertEquals(ISOChronology.getInstance(), result.getChronology());
+        assertEquals(ISOChronology.getInstance(PARIS), result.getChronology());
         assertNotSame(test, result);
         
         test = new DateTime(TEST_TIME1, BuddhistChronology.getInstance());

File: JodaTime/src/test/org/joda/time/TestInstant_Basics.java
Patch:
@@ -403,7 +403,7 @@ public void testToDateTimeISO() {
         assertSame(DateTime.class, result.getClass());
         assertSame(ISOChronology.class, result.getChronology().getClass());
         assertEquals(test.getMillis(), result.getMillis());
-        assertEquals(ISOChronology.getInstance(), result.getChronology());
+        assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());
     }
 
     public void testToDateTime_DateTimeZone() {
@@ -443,7 +443,7 @@ public void testToMutableDateTime() {
         Instant test = new Instant(TEST_TIME1);
         MutableDateTime result = test.toMutableDateTime();
         assertEquals(test.getMillis(), result.getMillis());
-        assertEquals(ISOChronology.getInstance(), result.getChronology());
+        assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());
     }
 
     public void testToMutableDateTimeISO() {
@@ -452,7 +452,7 @@ public void testToMutableDateTimeISO() {
         assertSame(MutableDateTime.class, result.getClass());
         assertSame(ISOChronology.class, result.getChronology().getClass());
         assertEquals(test.getMillis(), result.getMillis());
-        assertEquals(ISOChronology.getInstance(), result.getChronology());
+        assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());
     }
 
     public void testToMutableDateTime_DateTimeZone() {

File: JodaTime/src/test/org/joda/time/tz/TestAll.java
Patch:
@@ -37,6 +37,7 @@ public static Test suite() {
         suite.addTest(TestUTCProvider.suite());
         suite.addTest(TestBuilder.suite());
         suite.addTest(TestCompiler.suite());
+        suite.addTest(TestFixedDateTimeZone.suite());
         return suite;
     }
 

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -2444,7 +2444,7 @@ static class MatchingParser
                 if (parser != null) {
                     int len = parser.estimateParsedLength();
                     if (len > est) {
-                        len = est;
+                        est = len;
                     }
                 }
             }

File: JodaTime/src/java/org/joda/time/field/FieldUtils.java
Patch:
@@ -47,7 +47,7 @@ private FieldUtils() {
      */
     public static int safeNegate(int value) {
         if (value == Integer.MIN_VALUE) {
-            throw new ArithmeticException("Integer.MIN_VALUE cannoy be negated");
+            throw new ArithmeticException("Integer.MIN_VALUE cannot be negated");
         }
         return -value;
     }

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneSupport.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneTag.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatSupport.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/FormatTag.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/JodaTagLibraryValidator.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeSupport.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeTag.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Resources.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneSupport.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/SetDateTimeZoneTag.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Util.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright 1999-2004 The Apache Software Foundation.
- * Modifications, Copyright 2005 Joda.org
+ * Modifications, Copyright 2005 Stephen Colebourne
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: JodaTime/src/java/org/joda/time/chrono/BasicChronology.java
Patch:
@@ -699,7 +699,7 @@ int getMaxMonth() {
      * defined as:
      * <pre>
      *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch
-     * <pre>
+     * </pre>
      * where epoch is 1970-01-01 (Gregorian).
      */
     abstract long getApproxMillisAtEpoch();

File: JodaTime/src/java/org/joda/time/convert/DateConverter.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Date;
 
 import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
 
 /**
  * DateConverter converts a java util Date to an instant or partial.
@@ -54,8 +53,7 @@ protected DateConverter() {
      */
     public long getInstantMillis(Object object, Chronology chrono) {
         Date date = (Date) object;
-        long millisLocal = date.getTime() - date.getTimezoneOffset() * 60000;
-        return millisLocal - DateTimeZone.getDefault().getOffsetFromLocal(millisLocal);
+        return date.getTime();
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java
Patch:
@@ -461,9 +461,9 @@ protected void assemble(Fields fields) {
 
     //-----------------------------------------------------------------------
     /**
-     * Leap year patterns for the Islamic Chronology.
+     * Opaque object describing a leap year pattern for the Islamic Chronology.
      */
-    static class LeapYearPatternType implements Serializable {
+    public static class LeapYearPatternType implements Serializable {
         /** Serialization lock */
         private static final long serialVersionUID = 26581275372698L;
 //        /** Leap year raw data encoded into bits. */

File: JodaTime/src/java/org/joda/time/chrono/IslamicChronology.java
Patch:
@@ -463,7 +463,7 @@ protected void assemble(Fields fields) {
     /**
      * Leap year patterns for the Islamic Chronology.
      */
-    public static class LeapYearPatternType implements Serializable {
+    static class LeapYearPatternType implements Serializable {
         /** Serialization lock */
         private static final long serialVersionUID = 26581275372698L;
 //        /** Leap year raw data encoded into bits. */
@@ -488,7 +488,7 @@ public static class LeapYearPatternType implements Serializable {
          * @param index  the index
          * @param pattern  the bit pattern
          */
-        protected LeapYearPatternType(int index, int pattern) {
+        LeapYearPatternType(int index, int pattern) {
             super();
             this.index = (byte) index;
             this.pattern = pattern;
@@ -499,7 +499,7 @@ protected LeapYearPatternType(int index, int pattern) {
          * @param year  the year to query
          * @return true if leap
          */
-        public boolean isLeapYear(int year) {
+        boolean isLeapYear(int year) {
             int key = 1 << (year % 30);
             return ((pattern & key) > 0);
         }

File: JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
Patch:
@@ -261,9 +261,8 @@ protected void assemble(Fields fields) {
             fields.weekyear = new SkipDateTimeField(this, fields.weekyear);
             
             fields.era = ERA_FIELD;
-            fields.months = MONTH_DURATION_FIELD;
-            fields.monthOfYear = new BasicFixedMonthOfYearDateTimeField(this, MONTH_DURATION_FIELD);
-            fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);
+            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);
+            fields.months = fields.monthOfYear.getDurationField();
         }
     }
 

File: JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java
Patch:
@@ -261,9 +261,8 @@ protected void assemble(Fields fields) {
             fields.weekyear = new SkipDateTimeField(this, fields.weekyear);
             
             fields.era = ERA_FIELD;
-            fields.months = MONTH_DURATION_FIELD;
-            fields.monthOfYear = new BasicFixedMonthOfYearDateTimeField(this, MONTH_DURATION_FIELD);
-            fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);
+            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);
+            fields.months = fields.monthOfYear.getDurationField();
         }
     }
 

File: JodaTime/src/java/org/joda/time/Instant.java
Patch:
@@ -18,6 +18,7 @@
 import java.io.Serializable;
 
 import org.joda.time.base.AbstractInstant;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.InstantConverter;
 
@@ -86,7 +87,7 @@ public Instant(long instant) {
     public Instant(Object instant) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        iMillis = converter.getInstantMillis(instant, ChronologyType.iso().getChronologyUTC());
+        iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());
     }
 
     //-----------------------------------------------------------------------
@@ -217,7 +218,7 @@ public long getMillis() {
      * @return ISO in the UTC zone
      */
     public Chronology getChronology() {
-        return ChronologyType.iso().getChronologyUTC();
+        return ISOChronology.getInstanceUTC();
     }
 
 }

File: JodaTime/src/java/org/joda/time/TimeOfDay.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Locale;
 
 import org.joda.time.base.BasePartial;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.field.AbstractPartialFieldProperty;
 import org.joda.time.field.FieldUtils;
 import org.joda.time.format.ISODateTimeFormat;
@@ -139,7 +140,7 @@ public TimeOfDay() {
      * @since 1.1
      */
     public TimeOfDay(DateTimeZone zone) {
-        super(ChronologyType.iso().getChronology(zone));
+        super(ISOChronology.getInstance(zone));
     }
 
     /**

File: JodaTime/src/java/org/joda/time/YearMonthDay.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Locale;
 
 import org.joda.time.base.BasePartial;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.field.AbstractPartialFieldProperty;
 import org.joda.time.field.FieldUtils;
 import org.joda.time.format.ISODateTimeFormat;
@@ -98,7 +99,7 @@ public YearMonthDay() {
      * @since 1.1
      */
     public YearMonthDay(DateTimeZone zone) {
-        super(ChronologyType.iso().getChronology(zone));
+        super(ISOChronology.getInstance(zone));
     }
 
     /**

File: JodaTime/src/java/org/joda/time/base/BaseInterval.java
Patch:
@@ -18,14 +18,14 @@
 import java.io.Serializable;
 
 import org.joda.time.Chronology;
-import org.joda.time.ChronologyType;
 import org.joda.time.DateTimeUtils;
 import org.joda.time.MutableInterval;
 import org.joda.time.ReadWritableInterval;
 import org.joda.time.ReadableDuration;
 import org.joda.time.ReadableInstant;
 import org.joda.time.ReadableInterval;
 import org.joda.time.ReadablePeriod;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.IntervalConverter;
 import org.joda.time.field.FieldUtils;
@@ -86,7 +86,7 @@ protected BaseInterval(ReadableInstant start, ReadableInstant end) {
         super();
         if (start == null && end == null) {
             iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();
-            iChronology = ChronologyType.iso().getChronology();
+            iChronology = ISOChronology.getInstance();
         } else {
             iChronology = DateTimeUtils.getInstantChronology(start);
             iStartMillis = DateTimeUtils.getInstantMillis(start);

File: JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
Patch:
@@ -16,11 +16,11 @@
 package org.joda.time.convert;
 
 import org.joda.time.Chronology;
-import org.joda.time.ChronologyType;
 import org.joda.time.DateTimeUtils;
 import org.joda.time.DateTimeZone;
 import org.joda.time.PeriodType;
 import org.joda.time.ReadablePartial;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AbstractConverter simplifies the process of implementing a converter.
@@ -63,7 +63,7 @@ public long getInstantMillis(Object object, Chronology chrono) {
      * @return the chronology, never null
      */
     public Chronology getChronology(Object object, DateTimeZone zone) {
-        return ChronologyType.iso().getChronology(zone);
+        return ISOChronology.getInstance(zone);
     }
 
     /**

File: JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.GregorianCalendar;
 
 import org.joda.time.Chronology;
-import org.joda.time.ChronologyType;
 import org.joda.time.DateTimeZone;
 import org.joda.time.chrono.BuddhistChronology;
 import org.joda.time.chrono.GJChronology;
 import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.chrono.JulianChronology;
 
 /**
@@ -104,7 +104,7 @@ public Chronology getChronology(Object object, DateTimeZone zone) {
                 return GJChronology.getInstance(zone, cutover, 4);
             }
         } else {
-            return ChronologyType.iso().getChronology(zone);
+            return ISOChronology.getInstance(zone);
         }
     }
 

File: JodaTime/src/test/org/joda/time/TestAll.java
Patch:
@@ -35,7 +35,6 @@ public TestAll(String testName) {
     public static Test suite() {
         TestSuite suite = new TestSuite();
         suite.addTest(TestChronology.suite());
-        suite.addTest(TestChronologyType.suite());
         suite.addTest(TestDateTimeFieldType.suite());
         suite.addTest(TestDurationFieldType.suite());
         

File: JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java
Patch:
@@ -182,7 +182,6 @@ public void testGetMethods() {
         MutableDateTime test = new MutableDateTime();
         
         assertEquals(ISOChronology.getInstance(), test.getChronology());
-        assertEquals(ChronologyType.iso(), test.getChronologyType());
         assertEquals(LONDON, test.getZone());
         assertEquals(TEST_TIME_NOW, test.getMillis());
         

File: JodaTime/src/test/org/joda/time/TestMutableDateTime_Basics.java
Patch:
@@ -182,6 +182,7 @@ public void testGetMethods() {
         MutableDateTime test = new MutableDateTime();
         
         assertEquals(ISOChronology.getInstance(), test.getChronology());
+        assertEquals(ChronologyType.iso(), test.getChronologyType());
         assertEquals(LONDON, test.getZone());
         assertEquals(TEST_TIME_NOW, test.getMillis());
         

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -2229,13 +2229,13 @@ public int estimatePrintedLength() {
         public void printTo(
                 StringBuffer buf, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) {
-            buf.append(print(instant, displayZone, locale));
+            buf.append(print(instant - displayOffset, displayZone, locale));
         }
 
         public void printTo(
                 Writer out, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            out.write(print(instant, displayZone, locale));
+            out.write(print(instant - displayOffset, displayZone, locale));
         }
 
         private String print(long instant, DateTimeZone displayZone, Locale locale) {

File: JodaTime/src/test/org/joda/time/TestDateTime_Constructors.java
Patch:
@@ -83,12 +83,14 @@ protected void setUp() throws Exception {
         zone = DateTimeZone.getDefault();
         locale = Locale.getDefault();
         DateTimeZone.setDefault(LONDON);
+        java.util.TimeZone.setDefault(LONDON.toTimeZone());
         Locale.setDefault(Locale.UK);
     }
 
     protected void tearDown() throws Exception {
         DateTimeUtils.setCurrentMillisSystem();
         DateTimeZone.setDefault(zone);
+        java.util.TimeZone.setDefault(zone.toTimeZone());
         Locale.setDefault(locale);
         zone = null;
     }

File: JodaTime/src/test/org/joda/time/TestInstant_Constructors.java
Patch:
@@ -71,12 +71,14 @@ protected void setUp() throws Exception {
         zone = DateTimeZone.getDefault();
         locale = Locale.getDefault();
         DateTimeZone.setDefault(LONDON);
+        java.util.TimeZone.setDefault(LONDON.toTimeZone());
         Locale.setDefault(Locale.UK);
     }
 
     protected void tearDown() throws Exception {
         DateTimeUtils.setCurrentMillisSystem();
         DateTimeZone.setDefault(zone);
+        java.util.TimeZone.setDefault(zone.toTimeZone());
         Locale.setDefault(locale);
         zone = null;
     }

File: JodaTime/src/test/org/joda/time/TestMutableDateTime_Constructors.java
Patch:
@@ -83,12 +83,14 @@ protected void setUp() throws Exception {
         zone = DateTimeZone.getDefault();
         locale = Locale.getDefault();
         DateTimeZone.setDefault(LONDON);
+        java.util.TimeZone.setDefault(LONDON.toTimeZone());
         Locale.setDefault(Locale.UK);
     }
 
     protected void tearDown() throws Exception {
         DateTimeUtils.setCurrentMillisSystem();
         DateTimeZone.setDefault(zone);
+        java.util.TimeZone.setDefault(zone.toTimeZone());
         Locale.setDefault(locale);
         zone = null;
     }

File: JodaTime/src/test/org/joda/time/TestTimeOfDay_Constructors.java
Patch:
@@ -73,11 +73,13 @@ protected void setUp() throws Exception {
         DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);
         zone = DateTimeZone.getDefault();
         DateTimeZone.setDefault(LONDON);
+        java.util.TimeZone.setDefault(LONDON.toTimeZone());
     }
 
     protected void tearDown() throws Exception {
         DateTimeUtils.setCurrentMillisSystem();
         DateTimeZone.setDefault(zone);
+        java.util.TimeZone.setDefault(zone.toTimeZone());
         zone = null;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java
Patch:
@@ -122,7 +122,7 @@ public abstract class BaseGJChronology extends AssembledChronology {
     private static final int CACHE_SIZE = 1;
     private static final int CACHE_MASK = CACHE_SIZE - 1;
 
-    private final YearInfo[] iYearInfoCache = new YearInfo[CACHE_SIZE];
+    private transient final YearInfo[] iYearInfoCache = new YearInfo[CACHE_SIZE];
 
     private final int iMinDaysInFirstWeek;
 

File: JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
Patch:
@@ -307,7 +307,8 @@ int getDaysInMonthMax(int month) {
 
     //-----------------------------------------------------------------------
     int getMonthOfYear(long millis, int year) {
-        return ((int) ((millis - getYearMillis(year)) / 30)) + 1;
+        return ((int) ((millis - getYearMillis(year))
+                       / (30L * DateTimeConstants.MILLIS_PER_DAY))) + 1;
     }
     
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -34,7 +34,7 @@
  * For example, to format a date time in ISO format:
  * <pre>
  * DateTime dt = new DateTime();
- * DateTimeFormatter fmt = DateTimeFormat.getInstance().dateTime();
+ * DateTimeFormatter fmt = ISODateTimeFormat.dateTime();
  * String str = fmt.print(dt);
  * </pre>
  * <p>

File: JodaTime/src/test/org/joda/time/TestAll.java
Patch:
@@ -35,6 +35,7 @@ public TestAll(String testName) {
     public static Test suite() {
         TestSuite suite = new TestSuite();
         suite.addTest(TestChronology.suite());
+        suite.addTest(TestChronologyType.suite());
         suite.addTest(TestDateTimeFieldType.suite());
         suite.addTest(TestDurationFieldType.suite());
         

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/DateTimeZoneSupport.java
Patch:
@@ -98,7 +98,7 @@ public void release() {
      * Otherwise, the time zone configuration setting
      * <tt>org.joda.time.FMT_TIME_ZONE</tt> is used.
      * 
-     * @param pageContext  the page containing the action for which the time zone
+     * @param pc  the page containing the action for which the time zone
      *  needs to be determined
      * @param fromTag  the action for which the time zone needs to be determined
      * 

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/ParseDateTimeSupport.java
Patch:
@@ -91,8 +91,9 @@ public int doEndTag() throws JspException {
             input = value;
         } else {
             // ... retrieving and trimming our body
-            if (bodyContent != null && bodyContent.getString() != null)
+            if (bodyContent != null && bodyContent.getString() != null) {
                 input = bodyContent.getString().trim();
+            }
         }
 
         if ((input == null) || input.equals("")) {

File: JodaTimeContrib/jsptags/src/java/org/joda/time/contrib/jsptag/Util.java
Patch:
@@ -174,7 +174,7 @@ public static Locale parseLocale(String locale, String variant) {
      * form parameter values properly, since browsers typically encode form
      * field values using the response's charset).
      * 
-     * @param pageContext the page context whose response object is assigned the
+     * @param pc the page context whose response object is assigned the
      * given locale
      * @param locale the response locale
      */
@@ -470,7 +470,7 @@ public static LocalizationContext getLocalizationContext(PageContext pc) {
      * <tt>javax.servlet.jsp.jstl.fmt.fallbackLocale</tt> configuration
      * setting) and the available locales, for the given base name.
      * 
-     * @param pageContext Page in which the resource bundle with the given base
+     * @param pc Page in which the resource bundle with the given base
      * name is requested
      * @param basename Resource bundle base name
      * 

File: JodaTime/src/java/org/joda/time/Period.java
Patch:
@@ -161,7 +161,6 @@ public static Period millis(int millis) {
      *
      * @param start  the start of the period, must not be null
      * @param end  the end of the period, must not be null
-     * @param type  which set of fields this period supports, null means standard
      * @throws IllegalArgumentException if the partials are null or invalid
      * @since 1.1
      */

File: JodaTime/src/java/org/joda/time/Partial.java
Patch:
@@ -109,7 +109,7 @@ public Partial() {
      * Note that, although this is a clean way to write code, it is fairly
      * inefficient internally.
      *
-     * @param chronology  the chronology, null means ISO
+     * @param chrono  the chronology, null means ISO
      */
     public Partial(Chronology chrono) {
         super();

File: JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
Patch:
@@ -125,8 +125,6 @@ public class ISODateTimeFormat {
 
     /**
      * Restricted constructor.
-     * 
-     * @param chrono  the chronology to use, must not be null
      */
     protected ISODateTimeFormat() {
         super();

File: JodaTime/src/java/org/joda/time/Partial.java
Patch:
@@ -846,7 +846,6 @@ public String toString(String pattern, Locale locale) {
      * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.
      * 
      * @author Stephen Colebourne
-     * @since 1.0
      */
     public static class Property extends AbstractPartialFieldProperty implements Serializable {
 

File: JodaTimeContrib/src/java/org/joda/time/contrib/hibernate/PersistentDateTimeTZ.java
Patch:
@@ -35,7 +35,9 @@
  */
 public class PersistentDateTimeTZ implements UserType
 {
-    private static final int[] SQL_TYPES = new int[]
+	public final static PersistentDateTimeTZ INSTANCE = new PersistentDateTimeTZ();
+
+	private static final int[] SQL_TYPES = new int[]
     {
         Types.TIMESTAMP,
         Types.VARCHAR,

File: JodaTime/src/test/org/joda/time/TestSerialization.java
Patch:
@@ -176,7 +176,9 @@ public void testSerializedDateTimeZoneUTC() throws Exception {
     }
 
     public void testSerializedDateTimeZone() throws Exception {
-        DateTimeZone test = PARIS;
+        // have to re-get the zone, as TestDateTimeZone may have
+        // changed the cache, or a SoftReference may have got cleared
+        DateTimeZone test = DateTimeZone.forID("Europe/Paris");
         loadAndCompare(test, "DateTimeZone.dat", true);
         inlineCompare(test, true);
     }

File: JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -532,7 +532,7 @@ public PeriodFormatterBuilder appendSuffix(String text) {
      * @see #appendPrefix
      */
     public PeriodFormatterBuilder appendSuffix(String singularText,
-                                                 String pluralText) {
+                                               String pluralText) {
         if (singularText == null || pluralText == null) {
             throw new IllegalArgumentException();
         }
@@ -1169,7 +1169,7 @@ public int parseInto(
             } else {
                 limit = Math.min(iMaxParsedDigits, text.length() - position);
             }
-            
+
             // validate input number
             int length = 0;
             int fractPos = -1;
@@ -1212,7 +1212,7 @@ public int parseInto(
                 return ~position;
             }
 
-            if (position + length != suffixPos) {
+            if (suffixPos >= 0 && position + length != suffixPos) {
                 // If there are additional non-digit characters before the
                 // suffix is reached, then assume that the suffix found belongs
                 // to a field not yet reached. Return original position so that

File: JodaTime/src/java/org/joda/time/ReadablePartial.java
Patch:
@@ -25,7 +25,7 @@
  * not include a time zone.
  * <p>
  * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>
- * using one of the <code>resolve</code> methods. These work by providing a full base
+ * using the <code>toDateTime</code> method. This works by providing a full base
  * instant that can be used to 'fill in the gaps' and specify a time zone.
  *
  * @author Stephen Colebourne

File: JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -47,7 +47,7 @@
  * For example, to use a patterm:
  * <pre>
  * DateTime dt = new DateTime();
- * DateTimeFormatter fmt = DateTimeFormat.getInstance().forPattern("MMMM, yyyy");
+ * DateTimeFormatter fmt = DateTimeFormat.forPattern("MMMM, yyyy");
  * String str = fmt.print(dt);
  * </pre>
  *

File: JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
Patch:
@@ -38,7 +38,6 @@ public final class UnsupportedDurationField extends DurationField implements Ser
 
     /**
      * Gets an instance of UnsupportedDurationField for a specific named field.
-     * Names should be plural, such as 'years' or 'hours'.
      * The returned instance is cached.
      * 
      * @param type  the type to obtain

File: JodaTime/src/java/org/joda/time/DateTime.java
Patch:
@@ -372,7 +372,7 @@ public DateTime withChronology(Chronology newChronology) {
      * from this method with Europe/Paris would be 13:30.
      * <p>
      * The returned object will be a new instance of the same implementation type.
-     * This method changes alters the time zone, and does not change the
+     * This method changes the time zone, and does not change the
      * millisecond instant, with the effect that the field values usually change.
      * The returned object will be either be a new instance or <code>this</code>.
      *
@@ -393,7 +393,7 @@ public DateTime withZone(DateTimeZone newZone) {
      * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).
      * <p>
      * The returned object will be a new instance of the same implementation type.
-     * This method alters the time zone and the millisecond instant to keep
+     * This method changes the time zone and the millisecond instant to keep
      * the field values the same.
      * The returned object will be either be a new instance or <code>this</code>.
      *

File: JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
Patch:
@@ -438,7 +438,8 @@ public void parseDataFile(BufferedReader in) throws IOException {
         Zone zone = null;
         String line;
         while ((line = in.readLine()) != null) {
-            if (line.length() == 0 || line.charAt(0) == '#') {
+            String trimmed = line.trim();
+            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {
                 continue;
             }
 

File: JodaTime/src/java/org/joda/time/Interval.java
Patch:
@@ -177,7 +177,7 @@ public Interval toInterval() {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the interval where the this interval and that specified overlap.
+     * Gets the interval where this interval and that specified overlap.
      * 
      * @param interval  the interval to examine, null means now
      * @return the overlap interval, null if no overlap

File: JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -398,12 +398,12 @@ private static void parsePatternTo(DateTimeFormatterBuilder builder, String patt
                     DateTimeFieldType type;
                     switch (c) {
                     case 'x':
-                        builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);
+                        builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, true);
                         break;
                     case 'y':
                     case 'Y':
                     default:
-                        builder.appendTwoDigitYear(new DateTime().getYear() - 30);
+                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, true);
                         break;
                     }
                 } else {

File: JodaTime/src/java/org/joda/time/chrono/BaseChronology.java
Patch:
@@ -30,10 +30,10 @@
 import org.joda.time.field.UnsupportedDurationField;
 
 /**
- * AbstractChronology provides a skeleton implementation for chronology
+ * BaseChronology provides a skeleton implementation for chronology
  * classes. Many utility methods are defined, but all fields are unsupported.
  * <p>
- * AbstractChronology is thread-safe and immutable, and all subclasses must be
+ * BaseChronology is thread-safe and immutable, and all subclasses must be
  * as well.
  *
  * @author Brian S O'Neill

File: JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java
Patch:
@@ -38,7 +38,7 @@
  * Most of the utility methods required by subclasses are package-private,
  * reflecting the intention that they be defined in the same package.
  * <p>
- * AbstractGJChronology is thread-safe and immutable, and all subclasses must
+ * BaseGJChronology is thread-safe and immutable, and all subclasses must
  * be as well.
  *
  * @author Stephen Colebourne

File: JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -601,7 +601,7 @@ public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newV
      * Sets a value in the milliseconds supplied from a human-readable, text value.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * This implementation uses {@link #convertText(String, Locale)} and
+     * This implementation uses <code>convertText(String, Locale)</code> and
      * {@link #set(long, int)}.
      * <p>
      * Note: subclasses that override this method should also override
@@ -638,7 +638,7 @@ public final long set(long instant, String text) {
      * Sets a value in the milliseconds supplied from a human-readable, text value.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * This implementation uses {@link #convertText(String, Locale)} and
+     * This implementation uses <code>convertText(String, Locale)</code> and
      * {@link #set(ReadablePartial, int, int[], int)}.
      *
      * @param instant  the partial instant

File: JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -83,7 +83,7 @@
  * S       fraction of second           number        978
  *
  * z       time zone                    text          Pacific Standard Time; PST
- * Z       time zone offset/id          text          -0800; -08:00; Asia/Tokyo
+ * Z       time zone offset/id          zone          -0800; -08:00; Asia/Tokyo
  *
  * '       escape for text              delimiter
  * ''      single quote                 literal       '

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
Patch:
@@ -199,7 +199,6 @@ public Locale getLocale() {
      * Calling this method sets the override zone to null.
      * Calling the override zone method sets this flag off.
      * 
-     * @param locale  the locale to use
      * @return the new formatter
      */
     public DateTimeFormatter withOffsetParsed() {
@@ -229,11 +228,11 @@ public boolean isOffsetParsed() {
      * <p>
      * When parsing, this chronology will be set on the parsed datetime.
      * <p>
-     * A null zone means of no-override.
+     * A null chronology means of no-override.
      * If both an override chronology and an override zone are set, the
      * override zone will take precedence over the zone in the chronology.
      * 
-     * @param zone  the zone to use as an override
+     * @param chrono  the chronology to use as an override
      * @return the new formatter
      */
     public DateTimeFormatter withChronology(Chronology chrono) {

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -857,7 +857,7 @@ public DateTimeFormatterBuilder appendTimeZoneOffset(
      *
      * @param pattern  pattern specification
      * @throws IllegalArgumentException if the pattern is invalid
-     * @see DateTimeFormat#appendPatternTo(DateTimeFormatterBuilder,String)
+     * @see DateTimeFormat
      */
     public DateTimeFormatterBuilder appendPattern(String pattern) {
         DateTimeFormat.appendPatternTo(this, pattern);

File: JodaTime/src/java/org/joda/time/format/FormatUtils.java
Patch:
@@ -354,7 +354,7 @@ static int parseTwoDigits(String text, int position) {
     }
 
     static String createErrorMessage(final String text, final int errorPos) {
-        int sampleLen = errorPos + 20;
+        int sampleLen = errorPos + 32;
         String sampleText;
         if (text.length() <= sampleLen + 3) {
             sampleText = text;

File: JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
Patch:
@@ -86,7 +86,7 @@ public class DelegatedDateTimeField extends DateTimeField implements Serializabl
      * 
      * @param field  the field being decorated
      */
-    protected DelegatedDateTimeField(DateTimeField field) {
+    public DelegatedDateTimeField(DateTimeField field) {
         this(field, null);
     }
 
@@ -96,7 +96,7 @@ protected DelegatedDateTimeField(DateTimeField field) {
      * @param field  the field being decorated
      * @param type  the field type override
      */
-    protected DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {
+    public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {
         super();
         if (field == null) {
             throw new IllegalArgumentException("The field must not be null");

File: JodaTime/src/java/org/joda/time/YearMonthDay.java
Patch:
@@ -354,7 +354,7 @@ public YearMonthDay withChronologyRetainFields(Chronology newChronology) {
      */
     public YearMonthDay withField(DateTimeFieldType fieldType, int value) {
         int index = indexOfSupported(fieldType);
-        if (value == 0) {
+        if (value == getValue(index)) {
             return this;
         }
         int[] newValues = getValues();

File: JodaTime/src/java/org/joda/time/YearMonthDay.java
Patch:
@@ -353,10 +353,10 @@ public YearMonthDay withChronologyRetainFields(Chronology newChronology) {
      * @throws IllegalArgumentException if the value is null or invalid
      */
     public YearMonthDay withField(DateTimeFieldType fieldType, int value) {
+        int index = indexOfSupported(fieldType);
         if (value == 0) {
             return this;
         }
-        int index = indexOfSupported(fieldType);
         int[] newValues = getValues();
         newValues = getField(index).set(this, index, newValues, value);
         return new YearMonthDay(this, newValues);
@@ -369,7 +369,7 @@ public YearMonthDay withField(DateTimeFieldType fieldType, int value) {
      * <p>
      * These three lines are equivalent:
      * <pre>
-     * YearMonthDay added = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);
+     * YearMonthDay added = ymd.withFieldAdded(DateTimeFieldType.dayOfMonth(), 6);
      * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);
      * YearMonthDay added = ymd.property(DateTimeFieldType.dayOfMonth()).addToCopy(6);
      * </pre>
@@ -381,10 +381,10 @@ public YearMonthDay withField(DateTimeFieldType fieldType, int value) {
      * @throws ArithmeticException if the new datetime exceeds the capacity
      */
     public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {
+        int index = indexOfSupported(fieldType);
         if (amount == 0) {
             return this;
         }
-        int index = indexOfSupported(fieldType);
         int[] newValues = getValues();
         newValues = getField(index).add(this, index, newValues, amount);
         return new YearMonthDay(this, newValues);

File: JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java
Patch:
@@ -564,7 +564,7 @@ public void testToString() {
     //-----------------------------------------------------------------------
     public void testToString_String() {
         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);
-        assertEquals(" 10", test.toString("yyyy HH"));
+        assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString("yyyy HH"));
         assertEquals("T10:20:30.040", test.toString(null));
     }
 

File: JodaTime/src/test/org/joda/time/convert/MockUnknownCalendar.java
Patch:
@@ -100,5 +100,8 @@ public int getGreatestMinimum(int field) {
     public int getLeastMaximum(int field) {
         return 0;
     }
+    public int compareTo(Object arg0) {
+        return 0;
+    }
     
 }

File: JodaTime/src/test/org/joda/time/TestInterval_Basics.java
Patch:
@@ -404,7 +404,7 @@ public void testIsAfter_RInterval() {
         Interval test = new Interval(TEST_TIME1, TEST_TIME2);
         
         assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));
-        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));
+        assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));
         assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));
         
         assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));

File: JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java
Patch:
@@ -404,7 +404,7 @@ public void testIsAfter_RInterval() {
         MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);
         
         assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1)));
-        assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));
+        assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1)));
         assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1)));
         
         assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE)));

File: JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java
Patch:
@@ -600,7 +600,7 @@ public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {
     }
 
     /**
-     * Append a separator, which is output only if fields are printed after the separator.
+     * Append a separator, which is output only if fields are printed before the separator.
      * <p>
      * For example, <code>builder.appendDays().appendSeparator(",").appendHours()</code>
      * will only output the comma if the days fields is output.

File: JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -621,7 +621,7 @@ public DurationFieldType getRangeDurationType() {
         public DateTimeField getField(Chronology chrono) {
             DateTimeField wrappedField = iWrappedType.getField(chrono);
             RemainderDateTimeField field = iRecent;
-            if (field.getWrappedField() == wrappedField) {
+            if (field != null && field.getWrappedField() == wrappedField) {
                 return field;
             }
             field = new RemainderDateTimeField(wrappedField, iType, iDivisor);

File: JodaTime/src/java/org/joda/time/MutablePeriod.java
Patch:
@@ -947,7 +947,7 @@ public void addMillis(int millis) {
      * @return a clone of the this object.
      */
     public MutablePeriod copy() {
-        return (MutablePeriod)clone();
+        return (MutablePeriod) clone();
     }
 
     /**

File: JodaTime/src/java/org/joda/time/DateMidnight.java
Patch:
@@ -307,6 +307,7 @@ public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chrono
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @param chronology  the chronology to use, not null
+     * @return the updated instant, rounded to midnight
      */
     protected long checkInstant(long instant, Chronology chronology) {
         return chronology.dayOfMonth().roundFloor(instant);

File: JodaTime/src/java/org/joda/time/DateTimeComparator.java
Patch:
@@ -239,6 +239,8 @@ public int compare(Object lhsObj, Object rhsObj) {
     //-----------------------------------------------------------------------
     /**
      * Support serialization singletons.
+     * 
+     * @return the resolved singleton instance
      */
     private Object readResolve() {
         return getInstance(iLowerLimit, iUpperLimit);

File: JodaTime/src/java/org/joda/time/DateMidnight.java
Patch:
@@ -526,7 +526,7 @@ public DateMidnight plus(long duration) {
      * <p>
      * If the amount is zero or null, then <code>this</code> is returned.
      * 
-     * @param durationToAdd  the duration to add to this one, null means zero
+     * @param duration  the duration to add to this one, null means zero
      * @return a copy of this datetime with the duration added
      * @throws ArithmeticException if the new datetime exceeds the capacity of a long
      */
@@ -576,8 +576,8 @@ public DateMidnight minus(long duration) {
      * @return a copy of this datetime with the duration taken away
      * @throws ArithmeticException if the new datetime exceeds the capacity of a long
      */
-    public DateMidnight minus(ReadableDuration durationToAdd) {
-        return withDurationAdded(durationToAdd, -1);
+    public DateMidnight minus(ReadableDuration duration) {
+        return withDurationAdded(duration, -1);
     }
 
     /**

File: JodaTime/src/java/org/joda/time/DateTime.java
Patch:
@@ -657,7 +657,7 @@ public DateTime plus(long duration) {
      * <p>
      * If the amount is zero or null, then <code>this</code> is returned.
      * 
-     * @param durationToAdd  the duration to add to this one, null means zero
+     * @param duration  the duration to add to this one, null means zero
      * @return a copy of this datetime with the duration added
      * @throws ArithmeticException if the new datetime exceeds the capacity of a long
      */
@@ -707,8 +707,8 @@ public DateTime minus(long duration) {
      * @return a copy of this datetime with the duration taken away
      * @throws ArithmeticException if the new datetime exceeds the capacity of a long
      */
-    public DateTime minus(ReadableDuration durationToAdd) {
-        return withDurationAdded(durationToAdd, -1);
+    public DateTime minus(ReadableDuration duration) {
+        return withDurationAdded(duration, -1);
     }
 
     /**

File: JodaTime/src/java/org/joda/time/Instant.java
Patch:
@@ -204,7 +204,7 @@ public Instant plus(long duration) {
      * <p>
      * If the amount is zero or null, then <code>this</code> is returned.
      * 
-     * @param durationToAdd  the duration to add to this one, null means zero
+     * @param duration  the duration to add to this one, null means zero
      * @return a copy of this instant with the duration added
      * @throws ArithmeticException if the new instant exceeds the capacity of a long
      */
@@ -235,8 +235,8 @@ public Instant minus(long duration) {
      * @return a copy of this instant with the duration taken away
      * @throws ArithmeticException if the new instant exceeds the capacity of a long
      */
-    public Instant minus(ReadableDuration durationToAdd) {
-        return withDurationAdded(durationToAdd, -1);
+    public Instant minus(ReadableDuration duration) {
+        return withDurationAdded(duration, -1);
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/Period.java
Patch:
@@ -646,15 +646,15 @@ public Period withField(DurationFieldType field, int value) {
      * @return the new period instance
      * @throws IllegalArgumentException if the field type is null or unsupported
      */
-    public Period withFieldAdded(DurationFieldType field, int valueToAdd) {
+    public Period withFieldAdded(DurationFieldType field, int value) {
         if (field == null) {
             throw new IllegalArgumentException("Field must not be null");
         }
-        if (valueToAdd == 0) {
+        if (value == 0) {
             return this;
         }
         int[] newValues = getValues();  // cloned
-        super.addFieldInto(newValues, field, valueToAdd);
+        super.addFieldInto(newValues, field, value);
         return new Period(newValues, getPeriodType());
     }
 

File: JodaTime/src/java/org/joda/time/ReadableInterval.java
Patch:
@@ -255,7 +255,7 @@ public interface ReadableInterval {
      * on start and end millis plus the chronology.
      * All ReadableInterval instances are accepted.
      * <p>
-     * To compare the duration of two time intervals, use {@link #getDuration()}
+     * To compare the duration of two time intervals, use {@link #toDuration()}
      * to get the durations and compare those.
      *
      * @param readableInterval  a readable interval to check against

File: JodaTime/src/java/org/joda/time/TimeOfDay.java
Patch:
@@ -141,7 +141,7 @@ public static TimeOfDay fromMillisOfDay(long millisOfDay) {
      * but additional days will be ignored.
      * This method uses the UTC time zone internally.
      *
-     * @param instant  the number of milliseconds into a day to convert
+     * @param millisOfDay  the number of milliseconds into a day to convert
      * @param chrono  the chronology, null means ISO chronology
      */
     public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {

File: JodaTime/src/java/org/joda/time/base/AbstractInterval.java
Patch:
@@ -248,7 +248,7 @@ public boolean isBefore(ReadableInstant instant) {
      * <p>
      * Intervals are inclusive of the start instant and exclusive of the end.
      * 
-     * @param instant  the instant to compare to, null means now
+     * @param interval  the interval to compare to, null means now
      * @return true if this time interval is before the interval specified
      */
     public boolean isBefore(ReadableInterval interval) {
@@ -303,7 +303,7 @@ public boolean isAfter(ReadableInstant instant) {
      * <p>
      * Intervals are inclusive of the start instant and exclusive of the end.
      * 
-     * @param instant  the instant to compare to, null means now
+     * @param interval  the interval to compare to, null means now
      * @return true if this time interval is after the interval specified
      */
     public boolean isAfter(ReadableInterval interval) {
@@ -398,7 +398,7 @@ public Period toPeriod(PeriodType type) {
      * on start and end millis plus the chronology.
      * All ReadableInterval instances are accepted.
      * <p>
-     * To compare the duration of two time intervals, use {@link #getDuration()}
+     * To compare the duration of two time intervals, use {@link #toDuration()}
      * to get the durations and compare those.
      *
      * @param readableInterval  a readable interval to check against

File: JodaTime/src/java/org/joda/time/base/AbstractPartial.java
Patch:
@@ -69,7 +69,7 @@
  * Calculations on are performed using a {@link Chronology}.
  * This chronology is set to be in the UTC time zone for all calculations.
  * <p>
- * The methods on this class uses {@link ReadablePartial#getFieldSize()},
+ * The methods on this class uses {@link ReadablePartial#size()},
  * {@link ReadablePartial#getField(int)} and {@link ReadablePartial#getValue(int)}
  * to calculate their results. Subclasses may have a better implementation.
  * <p>

File: JodaTime/src/java/org/joda/time/base/AbstractPeriod.java
Patch:
@@ -120,7 +120,7 @@ public int[] getValues() {
      * If the field type specified is not supported by the period then zero
      * is returned.
      *
-     * @param field  the field type to query, null returns zero
+     * @param type  the field type to query, null returns zero
      * @return the value of that field, zero if field not supported
      */
     public int get(DurationFieldType type) {
@@ -177,7 +177,7 @@ public MutablePeriod toMutablePeriod() {
      * Compares this object with the specified object for equality based
      * on the value of each field. All ReadablePeriod instances are accepted.
      *
-     * @param readablePeriod  a readable period to check against
+     * @param period  a readable period to check against
      * @return true if all the field values are equal, false if
      *  not or the period is null or of an incorrect type
      */

File: JodaTime/src/java/org/joda/time/base/BasePartial.java
Patch:
@@ -201,7 +201,6 @@ protected BasePartial(int[] values, Chronology chronology) {
      *
      * @param base  the base partial
      * @param values  the new set of values, not cloned, null means use base
-     * @param chrono  the chronology to use, null means use base
      */
     protected BasePartial(BasePartial base, int[] values) {
         super();
@@ -216,7 +215,6 @@ protected BasePartial(BasePartial base, int[] values) {
      * This should not be used by mutable subclasses.
      *
      * @param base  the base partial
-     * @param values  the new set of values, not cloned, null means use base
      * @param chrono  the chronology to use, null means use base
      */
     protected BasePartial(BasePartial base, Chronology chrono) {

File: JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -162,7 +162,7 @@ public String getAsText(ReadablePartial partial, int fieldValue, Locale locale)
      * Get the human-readable, text value of this field from a partial instant.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation calls {@link ReadablePartial#get(DateTimeField)}
+     * The default implementation calls {@link ReadablePartial#get(DateTimeFieldType)}
      * and {@link #getAsText(ReadablePartial, int, Locale)}.
      *
      * @param partial  the partial instant to query
@@ -236,7 +236,7 @@ public String getAsShortText(ReadablePartial partial, int fieldValue, Locale loc
      * Get the human-readable, short text value of this field from a partial instant.
      * If the specified locale is null, the default locale is used.
      * <p>
-     * The default implementation calls {@link ReadablePartial#get(DateTimeField)}
+     * The default implementation calls {@link ReadablePartial#get(DateTimeFieldType)}
      * and {@link #getAsText(ReadablePartial, int, Locale)}.
      *
      * @param partial  the partial instant to query

File: JodaTime/src/test/org/joda/time/TestAll.java
Patch:
@@ -73,6 +73,7 @@ public TestAll(String testName) {
     public static Test suite() {
         TestSuite suite = new TestSuite();
         suite.addTest(TestChronology.suite());
+        suite.addTest(TestDateTimeFieldType.suite());
         
         suite.addTest(TestInstant_Constructors.suite());
         suite.addTest(TestInstant_Basics.suite());

File: JodaTime/src/test/org/joda/time/TestDuration_Constructors.java
Patch:
@@ -193,7 +193,7 @@ public void testConstructor_RI_RI4() throws Throwable {
      * Test constructor (Object)
      */
     public void testConstructor_Object1() throws Throwable {
-        Duration test = new Duration("P72.345S");
+        Duration test = new Duration("PT72.345S");
         assertEquals(72345, test.getMillis());
     }
 

File: JodaTime/src/java/org/joda/time/DateTimeUtils.java
Patch:
@@ -241,15 +241,15 @@ public static final DateTimeZone getZone(DateTimeZone zone) {
     /**
      * Gets the period type handling null.
      * <p>
-     * If the zone is <code>null</code>, {@link PeriodType#getAllType()}
+     * If the zone is <code>null</code>, {@link PeriodType#standard()}
      * will be returned. Otherwise, the type specified is returned.
      * 
-     * @param type  the time zone to use, null means the All type
+     * @param type  the time zone to use, null means the standard type
      * @return the type to use, never null
      */
     public static final PeriodType getPeriodType(PeriodType type) {
         if (type == null) {
-            return PeriodType.getAllType();
+            return PeriodType.standard();
         }
         return type;
     }

File: JodaTime/src/java/org/joda/time/MutableDateTime.java
Patch:
@@ -500,7 +500,7 @@ public void add(ReadablePeriod period) {
      */
     public void add(ReadablePeriod period, int scalar) {
         if (period != null) {
-            setMillis(period.addTo(getMillis(), scalar));  // set via this class not super
+            setMillis(period.addTo(getMillis(), scalar, getChronology()));  // set via this class not super
         }
     }
 

File: JodaTime/src/java/org/joda/time/base/AbstractPartial.java
Patch:
@@ -286,6 +286,9 @@ protected long resolve(long baseInstant, Chronology chrono) {
      * @return true if fields and values are equal
      */
     public boolean equals(Object partial) {
+        if (this == partial) {
+            return true;
+        }
         if (partial instanceof ReadablePartial == false) {
             return false;
         }

File: JodaTime/src/java/org/joda/time/convert/ConverterManager.java
Patch:
@@ -140,7 +140,6 @@ protected ConverterManager() {
 
         iDurationConverters = new ConverterSet(new Converter[] {
             ReadableDurationConverter.INSTANCE,
-            ReadablePeriodConverter.INSTANCE,
             ReadableIntervalConverter.INSTANCE,
             StringConverter.INSTANCE,
             LongConverter.INSTANCE,

File: JodaTime/src/test/org/joda/time/TestDateTimeUtils.java
Patch:
@@ -324,8 +324,8 @@ public void testGetZone_Zone() {
 
     //-----------------------------------------------------------------------
     public void testGetPeriodType_PeriodType() {
-        assertEquals(PeriodType.getDayHourType(), DateTimeUtils.getPeriodType(PeriodType.getDayHourType()));
-        assertEquals(PeriodType.getAllType(), DateTimeUtils.getPeriodType(null));
+        assertEquals(PeriodType.dayTime(), DateTimeUtils.getPeriodType(PeriodType.dayTime()));
+        assertEquals(PeriodType.standard(), DateTimeUtils.getPeriodType(null));
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/test/org/joda/time/TestInterval_Constructors.java
Patch:
@@ -242,7 +242,7 @@ public void testConstructor_RI_RP2() throws Throwable {
 
     public void testConstructor_RI_RP3() throws Throwable {
         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));
-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());
+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());
         long result = TEST_TIME_NOW;
         result = ISOChronology.getInstanceUTC().months().add(result, 6);
         result = ISOChronology.getInstanceUTC().days().add(result, 3);
@@ -326,7 +326,7 @@ public void testConstructor_RP_RI2() throws Throwable {
 
     public void testConstructor_RP_RI3() throws Throwable {
         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));
-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());
+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());
         long result = TEST_TIME_NOW;
         result = ISOChronology.getInstanceUTC().months().add(result, -6);
         result = ISOChronology.getInstanceUTC().days().add(result, -3);

File: JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java
Patch:
@@ -256,7 +256,7 @@ public void testConstructor_RI_RP2() throws Throwable {
 
     public void testConstructor_RI_RP3() throws Throwable {
         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));
-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());
+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());
         long result = TEST_TIME_NOW;
         result = ISOChronology.getInstanceUTC().months().add(result, 6);
         result = ISOChronology.getInstanceUTC().days().add(result, 3);
@@ -340,7 +340,7 @@ public void testConstructor_RP_RI2() throws Throwable {
 
     public void testConstructor_RP_RI3() throws Throwable {
         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));
-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());
+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());
         long result = TEST_TIME_NOW;
         result = ISOChronology.getInstanceUTC().months().add(result, -6);
         result = ISOChronology.getInstanceUTC().days().add(result, -3);

File: JodaTime/src/test/org/joda/time/format/TestPeriodFormatterBuilder.java
Patch:
@@ -74,8 +74,8 @@ public class TestPeriodFormatterBuilder extends TestCase {
     
     private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);
     private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);
-    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.getYearDayType());
-    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.getYearDayType());
+    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());
+    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());
     private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);
     private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);
 

File: JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java
Patch:
@@ -271,7 +271,7 @@ public int compareTo(ReadableInstant instant) {
         }
         int thisValue = get();
         Chronology chrono = DateTimeUtils.getChronology(instant.getChronology());
-        int otherValue = chrono.getField(getFieldType()).get(instant.getMillis());
+        int otherValue = getFieldType().getField(chrono).get(instant.getMillis());
         if (thisValue < otherValue) {
             return -1;
         } else if (thisValue > otherValue) {

File: JodaTime/src/java/org/joda/time/base/BasePartial.java
Patch:
@@ -239,7 +239,7 @@ protected BasePartial(BasePartial other, int[] values) {
      * @param chrono  the chronology to use
      */
     protected int[] initValues(long instant, Chronology chrono) {
-        int[] values = new int[getFieldSize()];
+        int[] values = new int[size()];
         for (int i = 0; i < values.length; i++) {
             values[i] = getField(i, chrono).get(instant);
         }

File: JodaTime/src/test/org/joda/time/TestAbstractPartial.java
Patch:
@@ -166,7 +166,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
             }
         }
 
-        public int getFieldSize() {
+        public int size() {
             return 2;
         }
         

File: JodaTime/src/test/org/joda/time/TestAllPackages.java
Patch:
@@ -76,6 +76,7 @@ public static Test suite() {
         suite.addTest(org.joda.time.chrono.TestAll.suite());
         suite.addTest(org.joda.time.chrono.gj.TestAll.suite());
         suite.addTest(org.joda.time.convert.TestAll.suite());
+        suite.addTest(org.joda.time.format.TestAll.suite());
         suite.addTest(org.joda.time.tz.TestAll.suite());
         return suite;
     }

File: JodaTime/src/test/org/joda/time/TestBasePartial.java
Patch:
@@ -156,7 +156,7 @@ protected DateTimeField getField(int index, Chronology chrono) {
             }
         }
 
-        public int getFieldSize() {
+        public int size() {
             return 2;
         }
         

File: JodaTime/src/java/org/joda/time/DateTimeFieldType.java
Patch:
@@ -451,7 +451,7 @@ public String getName() {
      * 
      * @return duration unit of the field, never null
      */
-    public DurationFieldType getUnitDurationType() {
+    public DurationFieldType getDurationType() {
         return iUnitType;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
Patch:
@@ -220,7 +220,7 @@ protected void assemble(Fields fields) {
             
             field = new OffsetDateTimeField(fields.yearOfEra, 99);
             fields.centuryOfEra = new DividedDateTimeField(
-                field, DateTimeFieldType.centuryOfEra(), "centuries", 100);
+                field, DateTimeFieldType.centuryOfEra(), 100);
             
             field = new RemainderDateTimeField(
                 (DividedDateTimeField) fields.centuryOfEra);

File: JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
Patch:
@@ -58,9 +58,10 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
+import org.joda.time.DurationFieldType;
 import org.joda.time.field.BaseDateTimeField;
-import org.joda.time.field.UnsupportedDurationField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.UnsupportedDurationField;
 
 /**
  * Provides time calculations for the buddhist era component of time.
@@ -152,7 +153,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.getInstance("eras");
+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());
     }
 
     public DurationField getRangeDurationField() {

File: JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
Patch:
@@ -61,6 +61,7 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
+import org.joda.time.DurationFieldType;
 import org.joda.time.field.FieldUtils;
 import org.joda.time.field.PreciseDurationField;
 
@@ -109,7 +110,7 @@ public final class CopticChronology extends BaseGJChronology {
 
     static {
         cMonthsField =  new PreciseDurationField
-            ("months", 30L * DateTimeConstants.MILLIS_PER_DAY);
+            (DurationFieldType.months(), 30L * DateTimeConstants.MILLIS_PER_DAY);
         INSTANCE_UTC = getInstance(DateTimeZone.UTC);
     }
 

File: JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
Patch:
@@ -58,9 +58,10 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
+import org.joda.time.DurationFieldType;
 import org.joda.time.field.BaseDateTimeField;
-import org.joda.time.field.UnsupportedDurationField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.UnsupportedDurationField;
 
 /**
  * Provides time calculations for the coptic era component of time.
@@ -151,7 +152,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.getInstance("eras");
+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());
     }
 
     public DurationField getRangeDurationField() {

File: JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
Patch:
@@ -73,7 +73,7 @@ final class CopticYearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     CopticYearDateTimeField(BaseGJChronology chronology) {
-        super(DateTimeFieldType.year(), "years", chronology.getAverageMillisPerYear());
+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJChronology.java
Patch:
@@ -1029,7 +1029,7 @@ private static class LinkedDurationField extends DecoratedDurationField {
         private final ImpreciseCutoverField iField;
 
         LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {
-            super(durationField, durationField.getName());
+            super(durationField, durationField.getType());
             iField = dateTimeField;
         }
 

File: JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
Patch:
@@ -58,9 +58,10 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
+import org.joda.time.DurationFieldType;
 import org.joda.time.field.BaseDateTimeField;
-import org.joda.time.field.UnsupportedDurationField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.UnsupportedDurationField;
 
 /**
  * Provides time calculations for the era component of time.
@@ -162,7 +163,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.getInstance("eras");
+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());
     }
 
     public DurationField getRangeDurationField() {

File: JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
Patch:
@@ -84,7 +84,7 @@ final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     GJMonthOfYearDateTimeField(BaseGJChronology chronology) {
-        super(DateTimeFieldType.monthOfYear(), "months", chronology.getAverageMillisPerMonth());
+        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
Patch:
@@ -81,7 +81,7 @@ final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     GJWeekyearDateTimeField(BaseGJChronology chronology) {
-        super(DateTimeFieldType.weekyear(), "weekyears", chronology.getAverageMillisPerYear());
+        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
Patch:
@@ -79,7 +79,7 @@ final class GJYearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     GJYearDateTimeField(BaseGJChronology chronology) {
-        super(DateTimeFieldType.year(), "years", chronology.getAverageMillisPerYear());
+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
Patch:
@@ -207,7 +207,7 @@ protected void assemble(Fields fields) {
         if (getBase().getZone() == DateTimeZone.UTC) {
             // Use zero based century and year of century.
             fields.centuryOfEra = new DividedDateTimeField(
-                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), "centuries", 100);
+                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);
             fields.yearOfCentury = new RemainderDateTimeField(
                 (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());
 

File: JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
Patch:
@@ -379,7 +379,7 @@ private class LimitDurationField extends DecoratedDurationField {
         private static final long serialVersionUID = 8049297699408782284L;
 
         LimitDurationField(DurationField field) {
-            super(field, field.getName());
+            super(field, field.getType());
         }
 
         public int getValue(long duration, long instant) {

File: JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
Patch:
@@ -275,7 +275,7 @@ static class ZonedDurationField extends BaseDurationField {
         final DateTimeZone iZone;
 
         ZonedDurationField(DurationField field, DateTimeZone zone) {
-            super(field.getName());
+            super(field.getType());
             if (!field.isSupported()) {
                 throw new IllegalArgumentException();
             }

File: JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
Patch:
@@ -86,12 +86,11 @@ public class DividedDateTimeField extends DecoratedDateTimeField {
      * 
      * @param field  the field to wrap, like "year()".
      * @param type  the field type this field will actually use
-     * @param durationName  short, descriptive name, like "centuries".
      * @param divisor  divisor, such as 100 years in a century
      * @throws IllegalArgumentException if divisor is less than two
      */
     public DividedDateTimeField(DateTimeField field,
-                                DateTimeFieldType type, String durationName, int divisor) {
+                                DateTimeFieldType type, int divisor) {
         super(field, type);
                 
         if (divisor < 2) {
@@ -102,7 +101,8 @@ public DividedDateTimeField(DateTimeField field,
         if (unitField == null) {
             iDurationField = null;
         } else {
-            iDurationField = new ScaledDurationField(unitField, durationName, divisor);
+            iDurationField = new ScaledDurationField(
+                unitField, type.getDurationType(), divisor);
         }
 
         iDivisor = divisor;

File: JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
Patch:
@@ -82,12 +82,11 @@ public class RemainderDateTimeField extends DecoratedDateTimeField {
      * 
      * @param field  the field to wrap, like "year()".
      * @param type  the field type this field actually uses
-     * @param rangeName  short, descriptive name, like "centuries".
      * @param divisor  divisor, such as 100 years in a century
      * @throws IllegalArgumentException if divisor is less than two
      */
     public RemainderDateTimeField(DateTimeField field,
-                                  DateTimeFieldType type, String rangeName, int divisor) {
+                                  DateTimeFieldType type, int divisor) {
         super(field, type);
 
         if (divisor < 2) {
@@ -98,7 +97,8 @@ public RemainderDateTimeField(DateTimeField field,
         if (rangeField == null) {
             iRangeField = null;
         } else {
-            iRangeField = new ScaledDurationField(rangeField, rangeName, divisor);
+            iRangeField = new ScaledDurationField(
+                rangeField, type.getRangeDurationType(), divisor);
         }
 
         iDivisor = divisor;

File: JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
Patch:
@@ -81,7 +81,7 @@ public final class UnsupportedDateTimeField extends DateTimeField implements Ser
      * Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'.
      * The returned instance is cached.
      * 
-     * @param name  the name to obtain
+     * @param type  the type to obtain
      * @return the instance
      * @throws IllegalArgumentException if durationField is null
      */

File: JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
Patch:
@@ -290,15 +290,15 @@ public static void appendPatternTo(DateTimeFormatterBuilder builder, String patt
                     switch (c) {
                     case 'x':
                         field = new RemainderDateTimeField
-                            (chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), "centuries", 100);
+                            (chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);
                         break;
                     case 'y': default:
                         field = new RemainderDateTimeField
-                            (chronoUTC.year(), DateTimeFieldType.yearOfCentury(), "centuries", 100);
+                            (chronoUTC.year(), DateTimeFieldType.yearOfCentury(), 100);
                         break;
                     case 'Y':
                         field = new RemainderDateTimeField
-                            (chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), "centuries", 100);
+                            (chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);
                         break;
                     }
                     builder.appendDecimal(field, 2, 2);

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java
Patch:
@@ -63,9 +63,8 @@
 abstract class TestGJDateTimeField extends ImpreciseDateTimeField {
     protected final TestGJChronology iChronology;
 
-    public TestGJDateTimeField(DateTimeFieldType type, String duratioName,
-                               long unitMillis, TestGJChronology chrono) {
-        super(type, duratioName, unitMillis);
+    public TestGJDateTimeField(DateTimeFieldType type, long unitMillis, TestGJChronology chrono) {
+        super(type, unitMillis);
         iChronology = chrono;
     }
 

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJDayOfMonthField extends TestGJDateTimeField {
     public TestGJDayOfMonthField(TestGJChronology chrono) {
-        super(DateTimeFieldType.dayOfMonth(), "days", chrono.MILLIS_PER_DAY, chrono);
+        super(DateTimeFieldType.dayOfMonth(), chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJDayOfWeekField extends TestGJDateTimeField {
     public TestGJDayOfWeekField(TestGJChronology chrono) {
-        super(DateTimeFieldType.dayOfWeek(), "days", chrono.MILLIS_PER_DAY, chrono);
+        super(DateTimeFieldType.dayOfWeek(), chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJDayOfYearField extends TestGJDateTimeField {
     public TestGJDayOfYearField(TestGJChronology chrono) {
-        super(DateTimeFieldType.dayOfYear(), "days", chrono.MILLIS_PER_DAY, chrono);
+        super(DateTimeFieldType.dayOfYear(), chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJMonthOfYearField extends TestGJDateTimeField {
     public TestGJMonthOfYearField(TestGJChronology chrono) {
-        super(DateTimeFieldType.monthOfYear(), "months", chrono.millisPerMonth(), chrono);
+        super(DateTimeFieldType.monthOfYear(), chrono.millisPerMonth(), chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJWeekOfWeekyearField extends TestGJDateTimeField {
     public TestGJWeekOfWeekyearField(TestGJChronology chrono) {
-        super(DateTimeFieldType.weekOfWeekyear(), "weeks",
+        super(DateTimeFieldType.weekOfWeekyear(),
               (long)(chrono.MILLIS_PER_DAY * 7), chrono);
     }
 

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJWeekyearField extends TestGJDateTimeField {
     public TestGJWeekyearField(TestGJChronology chrono) {
-        super(DateTimeFieldType.weekyear(), "weekyears", chrono.millisPerYear(), chrono);
+        super(DateTimeFieldType.weekyear(), chrono.millisPerYear(), chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java
Patch:
@@ -62,7 +62,7 @@
  */
 class TestGJYearField extends TestGJDateTimeField {
     public TestGJYearField(TestGJChronology chrono) {
-        super(DateTimeFieldType.year(), "years", chrono.millisPerYear(), chrono);
+        super(DateTimeFieldType.year(), chrono.millisPerYear(), chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
Patch:
@@ -56,6 +56,7 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
@@ -82,7 +83,7 @@ final class BuddhistEraDateTimeField extends BaseDateTimeField {
      * Restricted constructor
      */
     private BuddhistEraDateTimeField() {
-        super("era");
+        super(DateTimeFieldType.era());
     }
 
     /**

File: JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
Patch:
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.PreciseDurationDateTimeField;
@@ -74,7 +75,7 @@ final class CopticDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
      * Restricted constructor.
      */
     CopticDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {
-        super("dayOfMonth", days);
+        super(DateTimeFieldType.dayOfMonth(), days);
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
Patch:
@@ -56,6 +56,7 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
@@ -81,7 +82,7 @@ final class CopticEraDateTimeField extends BaseDateTimeField {
      * Restricted constructor
      */
     private CopticEraDateTimeField() {
-        super("era");
+        super(DateTimeFieldType.era());
     }
 
     /**

File: JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
Patch:
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 
@@ -72,7 +73,7 @@ final class CopticMonthOfYearDateTimeField extends PreciseDurationDateTimeField
      * Restricted constructor.
      */
     CopticMonthOfYearDateTimeField(BaseGJChronology chronology, DurationField months) {
-        super("monthOfYear", months);
+        super(DateTimeFieldType.monthOfYear(), months);
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
Patch:
@@ -53,10 +53,10 @@
  */
 package org.joda.time.chrono;
 
-import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
-import org.joda.time.field.ImpreciseDateTimeField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
  *
@@ -73,7 +73,7 @@ final class CopticYearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     CopticYearDateTimeField(BaseGJChronology chronology) {
-        super("year", "years", chronology.getAverageMillisPerYear());
+        super(DateTimeFieldType.year(), "years", chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJChronology.java
Patch:
@@ -615,7 +615,7 @@ private class CutoverField extends BaseDateTimeField {
 
         CutoverField(DateTimeField julianField, DateTimeField gregorianField,
                      long cutoverMillis, boolean convertByWeekyear) {
-            super(gregorianField.getName());
+            super(gregorianField.getType());
             iJulianField = julianField;
             iGregorianField = gregorianField;
             iCutover = cutoverMillis;

File: JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
Patch:
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.PreciseDurationDateTimeField;
@@ -76,7 +77,7 @@ final class GJDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
      * Restricted constructor.
      */
     GJDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {
-        super("dayOfMonth", days);
+        super(DateTimeFieldType.dayOfMonth(), days);
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
Patch:
@@ -56,6 +56,7 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 
@@ -79,7 +80,7 @@ final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {
      * Restricted constructor.
      */
     GJDayOfWeekDateTimeField(BaseGJChronology chronology, DurationField days) {
-        super("dayOfWeek", days);
+        super(DateTimeFieldType.dayOfWeek(), days);
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
Patch:
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.PreciseDurationDateTimeField;
@@ -76,7 +77,7 @@ final class GJDayOfYearDateTimeField extends PreciseDurationDateTimeField {
      * Restricted constructor
      */
     GJDayOfYearDateTimeField(BaseGJChronology chronology, DurationField days) {
-        super("dayOfYear", days);
+        super(DateTimeFieldType.dayOfYear(), days);
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
Patch:
@@ -56,6 +56,7 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.field.BaseDateTimeField;
 import org.joda.time.field.UnsupportedDurationField;
@@ -80,7 +81,7 @@ final class GJEraDateTimeField extends BaseDateTimeField {
      * Restricted constructor
      */
     GJEraDateTimeField(BaseGJChronology chronology) {
-        super("era");
+        super(DateTimeFieldType.era());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
Patch:
@@ -56,6 +56,7 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.field.FieldUtils;
 import org.joda.time.field.ImpreciseDateTimeField;
@@ -83,7 +84,7 @@ final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     GJMonthOfYearDateTimeField(BaseGJChronology chronology) {
-        super("monthOfYear", "months", chronology.getAverageMillisPerMonth());
+        super(DateTimeFieldType.monthOfYear(), "months", chronology.getAverageMillisPerMonth());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
Patch:
@@ -55,6 +55,7 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.PreciseDurationDateTimeField;
@@ -78,7 +79,7 @@ final class GJWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {
      * Restricted constructor
      */
     GJWeekOfWeekyearDateTimeField(BaseGJChronology chronology, DurationField weeks) {
-        super("weekOfWeekyear", weeks);
+        super(DateTimeFieldType.weekOfWeekyear(), weeks);
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
Patch:
@@ -54,10 +54,10 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
-import org.joda.time.field.ImpreciseDateTimeField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
  * Provides time calculations for the week of the weekyear component of time.
@@ -81,7 +81,7 @@ final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     GJWeekyearDateTimeField(BaseGJChronology chronology) {
-        super("weekyear", "weekyears", chronology.getAverageMillisPerYear());
+        super(DateTimeFieldType.weekyear(), "weekyears", chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
Patch:
@@ -54,9 +54,10 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
-import org.joda.time.field.ImpreciseDateTimeField;
 import org.joda.time.field.FieldUtils;
+import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
  * Provides time calculations for the year component of time.
@@ -78,7 +79,7 @@ final class GJYearDateTimeField extends ImpreciseDateTimeField {
      * Restricted constructor
      */
     GJYearDateTimeField(BaseGJChronology chronology) {
-        super("year", "years", chronology.getAverageMillisPerYear());
+        super(DateTimeFieldType.year(), "years", chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
Patch:
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
@@ -73,7 +74,7 @@ final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {
      * Restricted constructor.
      */
     GJYearOfEraDateTimeField(DateTimeField yearField, BaseGJChronology chronology) {
-        super(yearField, "yearOfEra");
+        super(yearField, DateTimeFieldType.yearOfEra());
         iChronology = chronology;
     }
 

File: JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
Patch:
@@ -54,6 +54,7 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
@@ -79,7 +80,7 @@ class ISOYearOfEraDateTimeField extends DecoratedDateTimeField {
      * Restricted constructor.
      */
     private ISOYearOfEraDateTimeField() {
-        super(GregorianChronology.getInstanceUTC().year(), "yearOfEra");
+        super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());
     }
 
     public int get(long instant) {

File: JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
Patch:
@@ -441,7 +441,7 @@ private class LimitDateTimeField extends DecoratedDateTimeField {
                            DurationField durationField,
                            DurationField rangeDurationField,
                            DurationField leapDurationField) {
-            super(field, field.getName());
+            super(field, field.getType());
             iDurationField = durationField;
             iRangeDurationField = rangeDurationField;
             iLeapDurationField = leapDurationField;

File: JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
Patch:
@@ -356,7 +356,7 @@ static final class ZonedDateTimeField extends BaseDateTimeField {
                            DurationField durationField,
                            DurationField rangeDurationField,
                            DurationField leapDurationField) {
-            super(field.getName());
+            super(field.getType());
             if (!field.isSupported()) {
                 throw new IllegalArgumentException();
             }

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -61,6 +61,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.MillisDurationField;
@@ -1743,7 +1744,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
             if (iParseField == null) {
                 iParseField = new PreciseDateTimeField
-                    ("", MillisDurationField.INSTANCE, iField.getDurationField());
+                    (DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, iField.getDurationField());
             }
 
             bucket.saveField(iParseField, (int)value);

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
@@ -62,9 +63,9 @@
 abstract class TestGJDateTimeField extends ImpreciseDateTimeField {
     protected final TestGJChronology iChronology;
 
-    public TestGJDateTimeField(String name, String duratioName,
+    public TestGJDateTimeField(DateTimeFieldType type, String duratioName,
                                long unitMillis, TestGJChronology chrono) {
-        super(name, duratioName, unitMillis);
+        super(type, duratioName, unitMillis);
         iChronology = chrono;
     }
 

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJDayOfMonthField extends TestGJDateTimeField {
     public TestGJDayOfMonthField(TestGJChronology chrono) {
-        super("dayOfMonth", "days", chrono.MILLIS_PER_DAY, chrono);
+        super(DateTimeFieldType.dayOfMonth(), "days", chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJDayOfWeekField extends TestGJDateTimeField {
     public TestGJDayOfWeekField(TestGJChronology chrono) {
-        super("dayOfWeek", "days", chrono.MILLIS_PER_DAY, chrono);
+        super(DateTimeFieldType.dayOfWeek(), "days", chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJDayOfYearField extends TestGJDateTimeField {
     public TestGJDayOfYearField(TestGJChronology chrono) {
-        super("dayOfYear", "days", chrono.MILLIS_PER_DAY, chrono);
+        super(DateTimeFieldType.dayOfYear(), "days", chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJMonthOfYearField extends TestGJDateTimeField {
     public TestGJMonthOfYearField(TestGJChronology chrono) {
-        super("monthOfYear", "months", chrono.millisPerMonth(), chrono);
+        super(DateTimeFieldType.monthOfYear(), "months", chrono.millisPerMonth(), chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJWeekOfWeekyearField extends TestGJDateTimeField {
     public TestGJWeekOfWeekyearField(TestGJChronology chrono) {
-        super("weekOfWeekyear", "weeks",
+        super(DateTimeFieldType.weekOfWeekyear(), "weeks",
               (long)(chrono.MILLIS_PER_DAY * 7), chrono);
     }
 

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJWeekyearField extends TestGJDateTimeField {
     public TestGJWeekyearField(TestGJChronology chrono) {
-        super("weekyear", "weekyears", chrono.millisPerYear(), chrono);
+        super(DateTimeFieldType.weekyear(), "weekyears", chrono.millisPerYear(), chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java
Patch:
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono.gj;
 
+import org.joda.time.DateTimeFieldType;
 import org.joda.time.DurationField;
 
 /**
@@ -61,7 +62,7 @@
  */
 class TestGJYearField extends TestGJDateTimeField {
     public TestGJYearField(TestGJChronology chrono) {
-        super("year", "years", chrono.millisPerYear(), chrono);
+        super(DateTimeFieldType.year(), "years", chrono.millisPerYear(), chrono);
     }
 
     public int get(long millis) {

File: JodaTime/src/java/org/joda/time/base/BasePartial.java
Patch:
@@ -69,7 +69,7 @@
  * data in array and <code>Chronology</code> fields.
  * <p>
  * This class should generally not be used directly by API users.
- * The {@link ReadablePeriod} interface should be used when different 
+ * The {@link org.joda.time.ReadablePeriod} interface should be used when different 
  * kinds of partial objects are to be referenced.
  * <p>
  * BasePartial subclasses may be mutable and not thread-safe.

File: JodaTime/src/java/org/joda/time/MutableDateTime.java
Patch:
@@ -400,7 +400,6 @@ public void setRounding(DateTimeField field, int mode) {
      *
      * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
      * datetime to
-     * @see #setDateTime(long)
      */
     public void setMillis(long instant) {
         switch (iRoundingMode) {
@@ -894,7 +893,7 @@ public void setDate(
      * Set the time from milliseconds.
      * The date part of this object will be unaffected.
      *
-     * @param instant  an instant to copy the time from, date part ignored
+     * @param millis  an instant to copy the time from, date part ignored
      * @throws IllegalArgumentException if the value is invalid
      */
     public void setTime(final long millis) {

File: JodaTime/src/java/org/joda/time/base/BasePeriod.java
Patch:
@@ -251,7 +251,7 @@ public PeriodType getPeriodType() {
      * an imprecise period.
      * <p>
      * An imprecise period can be made precise by pairing it with a
-     * date in a {@link ReadableInterval}.
+     * date in a {@link org.joda.time.ReadableInterval}.
      *
      * @return true if the period is precise
      */

File: JodaTime/src/java/org/joda/time/DateTime.java
Patch:
@@ -557,7 +557,7 @@ public DateTime withPeriodAdded(ReadablePeriod periodToAdd) {
      * DateTime added = dt.hourOfDay().addToCopy(6);
      * </pre>
      * 
-     * @param durationToAdd  the duration to add to this one, null means zero
+     * @param periodToAdd  the period to add to this one, null means zero
      * @param scalar  the amount of times to add, such as -1 to subtract once
      * @return a copy of this datetime with the period added
      * @throws ArithmeticException if the new datetime exceeds the capacity of a long

File: JodaTime/src/java/org/joda/time/DateTimeUtils.java
Patch:
@@ -227,8 +227,8 @@ public static final Chronology getChronology(Chronology chrono) {
      * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}
      * will be returned. Otherwise, the chronology is returned.
      * 
-     * @param chrono  the chronology to use, null means the default zone
-     * @return the chronology, or default if null
+     * @param zone  the time zone to use, null means the default zone
+     * @return the time zone, or default if null
      */
     public static final DateTimeZone getZone(DateTimeZone zone) {
         if (zone == null) {

File: JodaTime/src/java/org/joda/time/base/AbstractDateTime.java
Patch:
@@ -171,7 +171,7 @@ public int getDayOfYear() {
     /**
      * Get the day of month field value.
      * <p>
-     * The values for the day of month are defined in {@link DateTimeConstants}.
+     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.
      * 
      * @return the day of month
      */
@@ -182,7 +182,7 @@ public int getDayOfMonth() {
     /**
      * Get the day of week field value.
      * <p>
-     * The values for the day of week are defined in {@link DateTimeConstants}.
+     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.
      * 
      * @return the day of week
      */

File: JodaTime/src/java/org/joda/time/AbstractPeriod.java
Patch:
@@ -364,7 +364,8 @@ private static long scaleValue(int value, int scalar) {
      */
     public final Instant addTo(ReadableInstant instant, int scalar) {
         long instantMillis = DateTimeUtils.getInstantMillis(instant);
-        return new Instant(addTo(instantMillis, scalar, instant.getChronology()));
+        Chronology chrono = DateTimeUtils.getInstantChronology(instant, null);
+        return new Instant(addTo(instantMillis, scalar, chrono));
     }
 
     /**

File: JodaTime/src/java/org/joda/time/MutableInterval.java
Patch:
@@ -395,7 +395,7 @@ public void setDurationAfterStart(ReadableDuration duration) {
      */
     public void setDurationBeforeEnd(ReadableDuration duration) {
         long durationMillis = DateTimeUtils.getDurationMillis(duration);
-        setStartMillis(FieldUtils.safeAdd(getStartMillis(), -durationMillis));
+        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis));
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/MutableInterval.java
Patch:
@@ -342,7 +342,7 @@ public void setEndMillis(long endInstant) {
     /** 
      * Sets the end of this time interval as an Instant.
      *
-     * @param instant  the end of the time interval, null means now
+     * @param end  the end of the time interval, null means now
      * @throws IllegalArgumentException if the end is before the start
      */
     public void setEndInstant(ReadableInstant end) {

File: JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
Patch:
@@ -121,8 +121,7 @@ public long[] getIntervalMillis(Object object) {
      */
     public void setInto(ReadWritableInterval writableInterval, Object object) {
         ReadableInterval interval = (ReadableInterval) object;
-        writableInterval.setStartMillis(interval.getStartMillis());
-        writableInterval.setEndMillis(interval.getEndMillis());
+        writableInterval.setInterval(interval);
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/convert/StringConverter.java
Patch:
@@ -246,8 +246,7 @@ private long[] parseInterval(ReadWritableInterval writableInterval, Object objec
         if (writableInterval == null) {
             return new long[] {startInstant, endInstant};
         } else {
-            writableInterval.setStartMillis(startInstant);
-            writableInterval.setEndMillis(endInstant);
+            writableInterval.setInterval(startInstant, endInstant);
             return null;
         }
     }

File: JodaTime/src/java/org/joda/time/AbstractDuration.java
Patch:
@@ -338,14 +338,13 @@ protected void setDuration(ReadableDuration duration) {
     }
 
     /**
-     * Sets all the fields in one go from a millisecond interval.
+     * Sets all the fields in one go from a millisecond duration.
      * <p>
      * Subclasses that wish to be immutable should override this method with an
      * empty implementation that is protected and final. This also ensures that
      * all lower subclasses are also immutable.
      * 
-     * @param startInstant  interval start, in milliseconds
-     * @param endInstant  interval end, in milliseconds
+     * @param length  duration length, in milliseconds
      */
     protected void setMillis(long length) {
         iMillis = length;

File: JodaTime/src/java/org/joda/time/AbstractInterval.java
Patch:
@@ -494,7 +494,6 @@ public final MutableInterval toMutableInterval() {
      * The time period may not be precise - if you want the millisecond duration
      * then you should use {@link #getDuration()}.
      *
-     * @param type  the requested type of the duration, null means AllType
      * @return a time period derived from the interval
      */
     public final Period toPeriod() {
@@ -510,7 +509,7 @@ public final Period toPeriod() {
      * The time period may not be precise - if you want the millisecond duration
      * then you should use {@link #getDuration()}.
      *
-     * @param type  the requested type of the duration, null means AllType
+     * @param type  the requested type of the period, null means AllType
      * @return a time period derived from the interval
      */
     public final Period toPeriod(PeriodType type) {

File: JodaTime/src/java/org/joda/time/ReadableInterval.java
Patch:
@@ -219,7 +219,6 @@ public interface ReadableInterval {
      * The time period may not be precise - if you want the millisecond duration
      * then you should use {@link #getDuration()}.
      *
-     * @param type  the requested type of the duration, null means AllType
      * @return a time period derived from the interval
      */
     Period toPeriod();
@@ -233,7 +232,7 @@ public interface ReadableInterval {
      * The time period may not be precise - if you want the millisecond duration
      * then you should use {@link #getDuration()}.
      *
-     * @param type  the requested type of the duration, null means AllType
+     * @param type  the requested type of the period, null means AllType
      * @return a time period derived from the interval
      */
     Period toPeriod(PeriodType type);

File: JodaTime/src/test/org/joda/time/TestInterval_Constructors.java
Patch:
@@ -213,7 +213,7 @@ public void testConstructor_RI_RP2() throws Throwable {
 
     public void testConstructor_RI_RP3() throws Throwable {
         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));
-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getUTCAllType());
+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());
         long result = TEST_TIME_NOW;
         result = ISOChronology.getInstanceUTC().months().add(result, 6);
         result = ISOChronology.getInstanceUTC().days().add(result, 3);
@@ -290,7 +290,7 @@ public void testConstructor_RP_RI2() throws Throwable {
 
     public void testConstructor_RP_RI3() throws Throwable {
         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));
-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getUTCAllType());
+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());
         long result = TEST_TIME_NOW;
         result = ISOChronology.getInstanceUTC().months().add(result, -6);
         result = ISOChronology.getInstanceUTC().days().add(result, -3);

File: JodaTime/src/test/org/joda/time/convert/TestConverterManager.java
Patch:
@@ -368,8 +368,8 @@ public void testGetDurationConverter() {
         c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));
         assertEquals(ReadableDuration.class, c.getSupportedType());
         
-        c = ConverterManager.getInstance().getDurationConverter(new Period(PeriodType.getMillisType()));
-        assertEquals(ReadableDuration.class, c.getSupportedType());
+        c = ConverterManager.getInstance().getDurationConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));
+        assertEquals(ReadablePeriod.class, c.getSupportedType());
         
         c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));
         assertEquals(ReadableInterval.class, c.getSupportedType());
@@ -507,7 +507,7 @@ public void testRemoveDurationConverterSecurity() {
     private static int PERIOD_SIZE = 5;
     
     public void testGetPeriodConverter() {
-        PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(PeriodType.getMillisType()));
+        PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));
         assertEquals(ReadablePeriod.class, c.getSupportedType());
         
         c = ConverterManager.getInstance().getPeriodConverter(new Duration(123L));

File: JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java
Patch:
@@ -141,8 +141,8 @@ public void testSetInto_Object() throws Exception {
         assertEquals(0, m.getYears());
         assertEquals(0, m.getMonths());
         assertEquals(0, m.getWeeks());
-        assertEquals(3, m.getDays());
-        assertEquals(0, m.getHours());
+        assertEquals(0, m.getDays());
+        assertEquals(3 * 24, m.getHours());
         assertEquals(4, m.getMinutes());
         assertEquals(0, m.getSeconds());
         assertEquals(5, m.getMillis());

File: JodaTime/src/java/org/joda/time/AbstractPeriod.java
Patch:
@@ -582,6 +582,9 @@ public final int hashCode() {
      * Gets the value as a String in the ISO8601 duration format.
      * <p>
      * For example, "P6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
+     * <p>
+     * For more control over the output, see
+     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.
      *
      * @return the value as an ISO8601 string
      */

File: JodaTime/src/java/org/joda/time/AbstractInterval.java
Patch:
@@ -496,7 +496,7 @@ public final MutableInterval toMutableInterval() {
     //-----------------------------------------------------------------------
     /**
      * Converts the duration of the interval to a time period using the
-     * All duration type.
+     * All period type.
      * <p>
      * This method should be used to exract the field values describing the
      * difference between the start and end instants.
@@ -512,7 +512,7 @@ public final TimePeriod toTimePeriod() {
 
     /**
      * Converts the duration of the interval to a time period using the
-     * specified duration type.
+     * specified period type.
      * <p>
      * This method should be used to exract the field values describing the
      * difference between the start and end instants.
@@ -522,7 +522,7 @@ public final TimePeriod toTimePeriod() {
      * @param type  the requested type of the duration, null means AllType
      * @return a time period derived from the interval
      */
-    public final TimePeriod toTimePeriod(DurationType type) {
+    public final TimePeriod toTimePeriod(PeriodType type) {
         return new TimePeriod(getStartMillis(), getEndMillis(), type);
     }
 

File: JodaTime/src/java/org/joda/time/ReadableInterval.java
Patch:
@@ -212,7 +212,7 @@ public interface ReadableInterval {
     //-----------------------------------------------------------------------
     /**
      * Converts the duration of the interval to a time period using the
-     * All duration type.
+     * All period type.
      * <p>
      * This method should be used to exract the field values describing the
      * difference between the start and end instants.
@@ -226,7 +226,7 @@ public interface ReadableInterval {
 
     /**
      * Converts the duration of the interval to a time period using the
-     * specified duration type.
+     * specified period type.
      * <p>
      * This method should be used to exract the field values describing the
      * difference between the start and end instants.
@@ -236,7 +236,7 @@ public interface ReadableInterval {
      * @param type  the requested type of the duration, null means AllType
      * @return a time period derived from the interval
      */
-    TimePeriod toTimePeriod(DurationType type);
+    TimePeriod toTimePeriod(PeriodType type);
 
     //-----------------------------------------------------------------------
     /**

File: JodaTime/src/java/org/joda/time/convert/LongConverter.java
Patch:
@@ -57,7 +57,6 @@
 
 /**
  * LongConverter converts a Long to milliseconds in the ISOChronology.
- * The duration type created is the millis type.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill

File: JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
Patch:
@@ -58,7 +58,7 @@
 import org.joda.time.ReadableInterval;
 
 /**
- * Converts intervals into durations of any requested duration type.
+ * Converts intervals into durations of any requested period type.
  *
  * @author Brian S O'Neill
  * @since 1.0

File: JodaTime/src/java/org/joda/time/format/AbstractTimePeriodFormatter.java
Patch:
@@ -53,7 +53,7 @@
  */
 package org.joda.time.format;
 
-import org.joda.time.DurationType;
+import org.joda.time.PeriodType;
 import org.joda.time.MutableTimePeriod;
 import org.joda.time.ReadableTimePeriod;
 import org.joda.time.TimePeriod;
@@ -88,11 +88,11 @@ public String print(ReadableTimePeriod period) {
         return buf.toString();
     }
 
-    public TimePeriod parseTimePeriod(DurationType type, String text) {
+    public TimePeriod parseTimePeriod(PeriodType type, String text) {
         return parseMutableTimePeriod(type, text).toTimePeriod();
     }
 
-    public MutableTimePeriod parseMutableTimePeriod(DurationType type, String text) {
+    public MutableTimePeriod parseMutableTimePeriod(PeriodType type, String text) {
         TimePeriodParser p = (TimePeriodParser) this;
         MutableTimePeriod period = new MutableTimePeriod(0, type);
 

File: JodaTime/src/java/org/joda/time/format/TimePeriodParser.java
Patch:
@@ -54,7 +54,7 @@
 package org.joda.time.format;
 
 import org.joda.time.TimePeriod;
-import org.joda.time.DurationType;
+import org.joda.time.PeriodType;
 import org.joda.time.MutableTimePeriod;
 import org.joda.time.ReadWritableTimePeriod;
 
@@ -96,7 +96,7 @@ public interface TimePeriodParser {
      * @return parsed value in a Duration object
      * @throws IllegalArgumentException if any field is out of range
      */
-    TimePeriod parseTimePeriod(DurationType type, String periodStr);
+    TimePeriod parseTimePeriod(PeriodType type, String periodStr);
 
     /**
      * Parses a period from the given text, returning a new MutableTimePeriod.
@@ -106,6 +106,6 @@ public interface TimePeriodParser {
      * @return parsed value in a MutableDuration object
      * @throws IllegalArgumentException if any field is out of range
      */
-    MutableTimePeriod parseMutableTimePeriod(DurationType type, String periodStr);
+    MutableTimePeriod parseMutableTimePeriod(PeriodType type, String periodStr);
 
 }

File: JodaTime/src/test/org/joda/time/TestAll.java
Patch:
@@ -103,7 +103,7 @@ public static Test suite() {
         suite.addTest(TestDateTimeConstants.suite());
         suite.addTest(TestDateTimeUtils.suite());
         suite.addTest(TestDateTimeZone.suite());
-        suite.addTest(TestDurationType.suite());
+        suite.addTest(TestPeriodType.suite());
 //        suite.addTest(TestParseISO.suite());
         return suite;
     }

File: JodaTime/src/test/org/joda/time/convert/TestAll.java
Patch:
@@ -82,6 +82,7 @@ public static Test suite() {
         suite.addTest(TestReadableDurationConverter.suite());
         suite.addTest(TestReadableIntervalConverter.suite());
         suite.addTest(TestReadableInstantConverter.suite());
+        suite.addTest(TestReadablePeriodConverter.suite());
         suite.addTest(TestStringConverter.suite());
         return suite;
     }

File: JodaTime/src/test/org/joda/time/TestAll.java
Patch:
@@ -103,6 +103,7 @@ public static Test suite() {
         suite.addTest(TestDateTimeConstants.suite());
         suite.addTest(TestDateTimeUtils.suite());
         suite.addTest(TestDateTimeZone.suite());
+        suite.addTest(TestDurationType.suite());
 //        suite.addTest(TestParseISO.suite());
         return suite;
     }

File: JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
Patch:
@@ -158,7 +158,8 @@ private BuddhistChronology(Chronology base, Object param) {
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getZone());
+        Chronology base = getBase();
+        return base == null ? getInstanceUTC() : getInstance(base.getZone());
     }
 
     // Conversion

File: JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
Patch:
@@ -200,7 +200,8 @@ public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirst
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getZone());
+        Chronology base = getBase();
+        return base == null ? getInstanceUTC() : getInstance(base.getZone());
     }
 
     // Conversion

File: JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
Patch:
@@ -182,7 +182,8 @@ private GregorianChronology(Chronology base, Object param, int minDaysInFirstWee
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getZone());
+        Chronology base = getBase();
+        return base == null ? getInstanceUTC() : getInstance(base.getZone());
     }
 
     // Conversion

File: JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
Patch:
@@ -197,7 +197,8 @@ public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirst
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getBase().getZone());
+        Chronology base = getBase();
+        return base == null ? getInstanceUTC() : getInstance(base.getZone());
     }
 
     // Conversion

File: JodaTime/src/java/org/joda/time/MutableDateTime.java
Patch:
@@ -335,7 +335,7 @@ public MutableDateTime(
      * Gets the field used for rounding this instant, returning null if rounding
      * is not enabled.
      * 
-     * @param the rounding field
+     * @return the rounding field
      */
     public DateTimeField getRoundingField() {
         return iRoundingField;

File: JodaTime/src/test/org/joda/time/TestDateTimeZone.java
Patch:
@@ -696,7 +696,7 @@ public void testEqualsHashCode() {
         assertEquals(false, zone5.equals(zone1));
         assertEquals(false, zone5.equals(zone2));
         assertEquals(false, zone5.equals(zone3));
-        assertEquals(false, zone5.equals(zone5));
+        assertEquals(false, zone5.equals(zone4));
         assertEquals(false, zone1.hashCode() == zone5.hashCode());
         assertEquals(true, zone5.hashCode() == zone5.hashCode());
     }

File: JodaTime/src/java/org/joda/time/TimeOfDay.java
Patch:
@@ -440,7 +440,6 @@ public static class Property extends AbstractPartialFieldProperty implements Ser
          * Constructs a property.
          * 
          * @param partial  the partial instance
-         * @param field  the field
          * @param fieldIndex  the index in the partial
          */
         Property(TimeOfDay partial, int fieldIndex) {

File: JodaTime/src/java/org/joda/time/YearMonthDay.java
Patch:
@@ -352,7 +352,6 @@ public static class Property extends AbstractPartialFieldProperty implements Ser
          * Constructs a property.
          * 
          * @param partial  the partial instance
-         * @param field  the field
          * @param fieldIndex  the index in the partial
          */
         Property(YearMonthDay partial, int fieldIndex) {

File: JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
Patch:
@@ -99,7 +99,7 @@ public boolean isLenient() {
     /**
      * Get the Era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the era extracted from the input.
      */
     public int get(long instant) {
@@ -109,7 +109,7 @@ public int get(long instant) {
     /**
      * Set the Era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param era  the era (BuddhistChronology.BE) to update the time to.
      * @return the updated time instant.
      * @throws IllegalArgumentException  if era is invalid.

File: JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
Patch:
@@ -98,7 +98,7 @@ public boolean isLenient() {
     /**
      * Get the Era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the era extracted from the input.
      */
     public int get(long instant) {
@@ -108,7 +108,7 @@ public int get(long instant) {
     /**
      * Set the Era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param era  the era (CopticChronology.AM) to update the time to.
      * @return the updated time instant.
      * @throws IllegalArgumentException  if era is invalid.

File: JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
Patch:
@@ -107,7 +107,7 @@ protected String getAsText(int fieldValue, Locale locale) {
     /**
      * Get the abbreviated textual value of the specified time instant.
      * 
-     * @param instant  the time instant in millis to query
+     * @param fieldValue  the field value to query
      * @param locale  the locale to use
      * @return the day of the week, such as 'Mon'
      */

File: JodaTime/src/java/org/joda/time/convert/ConverterSet.java
Patch:
@@ -250,7 +250,7 @@ public ConverterSet remove(Converter converter, Converter[] removed) {
      * Returns a copy of this set, with the converter at the given index
      * removed.
      *
-     * @param converter converter to remove
+     * @param index index of converter to remove
      * @param removed if not null, element 0 is set to the removed converter
      * @throws IndexOutOfBoundsException if the index is invalid
      */

File: JodaTime/src/java/org/joda/time/DateMidnight.java
Patch:
@@ -69,7 +69,7 @@
  * <p>
  * This class does not represent a day, but the millisecond instant at midnight.
  * If you need a class that represents the whole day, then an {@link Interval} or
- * a {@link org.joda.time.partial.YearMonthDay YearMonthDay} may be more suitable.
+ * a {@link YearMonthDay} may be more suitable.
  * <p>
  * This class uses a Chronology internally. The Chronology determines how the
  * millisecond instant value is converted into the date time fields.

File: JodaTime/src/test/org/joda/time/chrono/gj/MainTest.java
Patch:
@@ -81,7 +81,7 @@
  * <p>
  * The mode can be either 'g' for proleptic gregorian (the default) or 'j' for
  * proleptic julian. To override the default random number generator seed, pass
- * in a thrid argument which accepts a long signed integer.
+ * in a third argument which accepts a long signed integer.
  *
  * @author Brian S O'Neill
  */

File: JodaTime/src/java/org/joda/time/field/BaseDurationField.java
Patch:
@@ -61,7 +61,7 @@
  * implementations.
  * <p>
  * This class should generally not be used directly by API users. The
- * DurationField interface should be used when different kinds of DurationField
+ * DurationField class should be used when different kinds of DurationField
  * objects are to be referenced.
  * <p>
  * BaseDurationField is thread-safe and immutable, and its subclasses must

File: JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -65,7 +65,7 @@
  * implementations. 
  * <p>
  * This class should generally not be used directly by API users. The
- * DateTimeField interface should be used when different kinds of DateTimeField
+ * DateTimeField class should be used when different kinds of DateTimeField
  * objects are to be referenced.
  * <p>
  * BaseDateTimeField is thread-safe and immutable, and its subclasses must

File: JodaTime/src/java/org/joda/time/field/BaseDurationField.java
Patch:
@@ -57,14 +57,14 @@
 import org.joda.time.DurationField;
 
 /**
- * AbstractDurationField provides the common behaviour for DurationField
+ * BaseDurationField provides the common behaviour for DurationField
  * implementations.
  * <p>
  * This class should generally not be used directly by API users. The
  * DurationField interface should be used when different kinds of DurationField
  * objects are to be referenced.
  * <p>
- * AbstractDurationField is thread-safe and immutable, and its subclasses must
+ * BaseDurationField is thread-safe and immutable, and its subclasses must
  * be as well.
  *
  * @author Brian S O'Neill

File: JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
Patch:
@@ -56,13 +56,13 @@
 import org.joda.time.DurationField;
 
 /**
- * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},
+ * <code>DecoratedDurationField</code> extends {@link BaseDurationField},
  * implementing only the minimum required set of methods. These implemented
  * methods delegate to a wrapped field.
  * <p>
  * This design allows new DurationField types to be defined that piggyback on
  * top of another, inheriting all the safe method implementations from
- * AbstractDurationField. Should any method require pure delegation to the
+ * BaseDurationField. Should any method require pure delegation to the
  * wrapped field, simply override and use the provided getWrappedField method.
  * <p>
  * DecoratedDurationField is thread-safe and immutable, and its subclasses must

File: JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
Patch:
@@ -151,7 +151,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     public DurationField getRangeDurationField() {

File: JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
Patch:
@@ -150,7 +150,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     public DurationField getRangeDurationField() {

File: JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
Patch:
@@ -161,7 +161,7 @@ public long roundHalfEven(long instant) {
     }
 
     public DurationField getDurationField() {
-        return UnsupportedDurationField.INSTANCE;
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     public DurationField getRangeDurationField() {

File: JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
Patch:
@@ -168,7 +168,7 @@ public Chronology getChronology(Object object, Chronology chrono) {
      * @return a debugging string
      */
     public String toString() {
-        return "Converter[" + getSupportedType() + "]";
+        return "Converter[" + (getSupportedType() == null ? "null" : getSupportedType().getName()) + "]";
     }
 
 }

File: JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
Patch:
@@ -126,7 +126,9 @@ public Chronology getChronology(Object object) {
      * @return the chronology, never null
      */
     public Chronology getChronology(Object object, DateTimeZone zone) {
-        if (object instanceof GregorianCalendar) {
+        if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
+            return BuddhistChronology.getInstance(zone);
+        } else if (object instanceof GregorianCalendar) {
             GregorianCalendar gc = (GregorianCalendar) object;
             long cutover = gc.getGregorianChange().getTime();
             if (cutover == Long.MIN_VALUE) {
@@ -136,8 +138,6 @@ public Chronology getChronology(Object object, DateTimeZone zone) {
             } else {
                 return GJChronology.getInstance(zone, cutover, 4);
             }
-        } else if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
-            return BuddhistChronology.getInstance(zone);
         } else {
             return ISOChronology.getInstance(zone);
         }

File: JodaTime/src/java/org/joda/time/convert/LongConverter.java
Patch:
@@ -58,6 +58,7 @@
 
 /**
  * LongConverter converts a Long to milliseconds in the ISOChronology.
+ * The duration type created is the millis type.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
@@ -127,7 +128,7 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * @throws ClassCastException if the object is invalid
      */
     public DurationType getDurationType(Object object) {
-        return DurationType.getAverageYearMonthType();
+        return DurationType.getMillisType();
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
Patch:
@@ -169,7 +169,7 @@ public TimeOfDay(long instant, Chronology chronology) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, null means now
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public TimeOfDay(Object instant) {
         super(instant);
@@ -189,7 +189,7 @@ public TimeOfDay(Object instant) {
      *
      * @param instant  the datetime object, null means now
      * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public TimeOfDay(Object instant, Chronology chronology) {
         super(instant, chronology);

File: JodaTime/src/java/org/joda/time/partial/YearMonthDay.java
Patch:
@@ -166,7 +166,7 @@ public YearMonthDay(long instant, Chronology chronology) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, null means now
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public YearMonthDay(Object instant) {
         super(instant);
@@ -186,7 +186,7 @@ public YearMonthDay(Object instant) {
      *
      * @param instant  the datetime object, null means now
      * @param chronology  the chronology, null means ISOChronology
-     * @throws IllegalArgumentException if the date is null
+     * @throws IllegalArgumentException if the instant is invalid
      */
     public YearMonthDay(Object instant, Chronology chronology) {
         super(instant, chronology);

File: JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -523,7 +523,7 @@ public long set(long instant, String text, Locale locale) {
      * If the specified locale is null, the default locale is used.
      * <p>
      * This implementation uses {@link #convertText(String, Locale)} and
-     * {@link #set(PartialInstant, int, int[], int)}.
+     * {@link #set(ReadablePartial, int, int[], int)}.
      *
      * @param instant  the partial instant
      * @param fieldIndex  the index of this field in the instant
@@ -645,7 +645,7 @@ public int getMinimumValue(ReadablePartial instant) {
      * Get the minimum value for this field using the partial instant and
      * the specified values.
      * <p>
-     * This implementation returns the same as {@link #getMinimumValue(PartialInstant)}.
+     * This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.
      * 
      * @param instant  the partial instant to query
      * @param values  the values to use
@@ -691,7 +691,7 @@ public int getMaximumValue(ReadablePartial instant) {
      * Get the maximum value for this field using the partial instant and
      * the specified values.
      * <p>
-     * This implementation returns the same as {@link #getMaximumValue(PartialInstant)}.
+     * This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.
      * 
      * @param instant  the partial instant to query
      * @param values  the values to use

File: JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
Patch:
@@ -444,7 +444,7 @@ protected long resolve(long baseMillis, Chronology chrono) {
      * Compares this PartialInstant with another returning true if the chronology,
      * fields and values are equal.
      *
-     * @param AbstractPartialInstant  an object to check against
+     * @param instant  an object to check against
      * @return true if fields and values are equal
      */
     public boolean equals(Object instant) {

File: JodaTime/src/java/org/joda/time/partial/AbstractPartialInstant.java
Patch:
@@ -197,6 +197,7 @@ public AbstractPartialInstant(Object instant) {
     public AbstractPartialInstant(Object instant, Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        chronology = converter.getChronology(instant, chronology);
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }

File: JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java
Patch:
@@ -155,7 +155,7 @@ public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {
      * Note: subclasses that override this method should also override
      * getMaximumTextLength.
      *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param fieldValue  the numeric value to convert to text
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
@@ -202,7 +202,7 @@ public String getAsShortText(PartialInstant partial, int fieldValue, Locale loca
      * Note: subclasses that override this method should also override
      * getMaximumShortTextLength.
      *
-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param fieldValue  the numeric value to convert to text
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */

File: JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
Patch:
@@ -183,7 +183,9 @@ public static void main(String[] args) {
      */
     private static void usage() {
             System.err.println("Usage:");
-            System.err.println("DateTimeBrowser <options> <filename>");
+            System.err.print("java <options> ");
+            System.err.print(DateTimeBrowser.class.getName());
+            System.err.println(" <filename>");
             System.err.println("<filename> contains a list of Strings");
             System.err.println("\twhich are valid for DateTime instantiation.");
             System.err.println("<optons>");

File: JodaTime/src/java/org/joda/time/partial/TimeOfDay.java
Patch:
@@ -216,7 +216,6 @@ public TimeOfDay(Object instant) {
     public TimeOfDay(Object instant, Chronology chronology) {
         super();
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        Chronology original = converter.getChronology(instant, chronology);
         if (chronology == null) {
             chronology = ISOChronology.getInstance();
         }
@@ -299,7 +298,7 @@ private int[] initValues(long instant, Chronology chrono) {
      * @param index  the index
      * @return the field
      */
-    protected DateTimeField getField(int index) {
+    DateTimeField getField(int index) {
         switch (index) {
             case HOUR_OF_DAY:
                 return iChronology.hourOfDay();
@@ -320,7 +319,7 @@ protected DateTimeField getField(int index) {
      * @param index  the index
      * @return the value
      */
-    protected int getValue(int index) {
+    int getValue(int index) {
         return iValues[index];
     }
     
@@ -401,6 +400,7 @@ public boolean isSupported(DateTimeField field) {
      * will be the date from the specified base plus the time from this instant.
      *
      * @param baseMillis  source of missing fields
+     * @param zone  the zone to use, null means default
      * @return the combined instant in milliseconds
      */
     public long resolve(long baseMillis, DateTimeZone zone) {

File: JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
Patch:
@@ -136,7 +136,7 @@ public DateTimeFormatterBuilder(final Chronology chrono) {
     /**
      * Creates a DateTimeFormatterBuilder with any chronology and locale.
      *
-     * @param chrono Chronology to use, or null for default iso
+     * @param chrono Chronology to use, or null for default of ISO
      * @param locale Locale to use, or null for default
      */
     public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {
@@ -161,7 +161,7 @@ public Chronology getChronology() {
     }
 
     /**
-     * Returns the locale being used the formatter builder.
+     * Returns the locale being used by the formatter builder.
      */
     public Locale getLocale() {
         return iLocale;

File: JodaTime/src/java/org/joda/time/convert/LongConverter.java
Patch:
@@ -127,7 +127,7 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * @throws ClassCastException if the object is invalid
      */
     public DurationType getDurationType(Object object) {
-        return DurationType.getMillisType();
+        return DurationType.getAverageYearMonthType();
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/convert/LongConverter.java
Patch:
@@ -127,7 +127,7 @@ public void setInto(ReadWritableDuration duration, Object object) {
      * @throws ClassCastException if the object is invalid
      */
     public DurationType getDurationType(Object object) {
-        return DurationType.getAverageYearMonthType();
+        return DurationType.getMillisType();
     }
 
     //-----------------------------------------------------------------------

File: JodaTime/src/java/org/joda/time/DateTimeConstants.java
Patch:
@@ -156,7 +156,7 @@ public final class DateTimeConstants {
     public static final int MINUTES_PER_HOUR = 60;
     /** Seconds in one hour (ISO) */
     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
-    /** Milliseconds in one hour (60) (ISO) */
+    /** Milliseconds in one hour (ISO) */
     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;
 
     /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the

File: JodaTime/src/java/org/joda/time/DateTimeConstants.java
Patch:
@@ -154,7 +154,7 @@ public final class DateTimeConstants {
 
     /** Minutes in one hour (ISO) */
     public static final int MINUTES_PER_HOUR = 60;
-    /** Milliseconds in one hour (ISO) */
+    /** Seconds in one hour (ISO) */
     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
     /** Minutes in one hour (60) (ISO) */
     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;

File: JodaTime/src/java/org/joda/time/field/FieldUtils.java
Patch:
@@ -58,7 +58,7 @@
 /**
  * General utilities that don't fit elsewhere.
  * <p>
- * Utils is thread-safe and immutable.
+ * FieldUtils is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @since 1.0

File: JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
Patch:
@@ -89,7 +89,7 @@ public interface ReadWritableDateTime extends ReadableDateTime, ReadWritableInst
 
     //-----------------------------------------------------------------------
     /**
-     * Set the week of the year to the specified value.
+     * Set the weekyear to the specified value.
      *
      * @param weekyear  the weekyear
      * @throws IllegalArgumentException if the value is invalid

File: JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
Patch:
@@ -653,7 +653,7 @@ Object[] genColNames() {
                 "DayOfMon",
                 "DayOfYr",
                 "WeekOfWY",
-                "YearOfWY",
+                "Weekyear",
                 "MonOfYr",
                 "Year"
             };

File: JodaTime/src/java/org/joda/time/convert/DurationConverter.java
Patch:
@@ -88,7 +88,6 @@ public interface DurationConverter extends Converter {
      *
      * @param duration duration to get modified
      * @param object  the object to convert, must not be null
-     * @return the millisecond duration
      * @throws ClassCastException if the object is invalid
      */
     void setInto(ReadWritableDuration duration, Object object);

File: JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
Patch:
@@ -88,7 +88,7 @@ public abstract class AbstractDateTimeFormatter {
     static String createErrorMessage(final String text, final int errorPos) {
         int sampleLen = errorPos + 20;
         String sampleText;
-        if (text.length() <= sampleLen) {
+        if (text.length() <= sampleLen + 3) {
             sampleText = text;
         } else {
             sampleText = text.substring(0, sampleLen).concat("...");

