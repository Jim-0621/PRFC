File: core/src/com/google/inject/internal/Initializable.java
Patch:
@@ -24,5 +24,5 @@
 interface Initializable<T> {
 
   /** Ensures the reference is initialized, then returns it. */
-  T get() throws InternalProvisionException;
+  T get(InternalContext context) throws InternalProvisionException;
 }

File: core/src/com/google/inject/internal/InjectionRequestProcessor.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.inject.spi.InjectionRequest;
 import com.google.inject.spi.StaticInjectionRequest;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 /**
@@ -76,12 +77,12 @@ private <T> void requestInjection(
       InjectionRequest<T> request, Set<InjectionPoint> injectionPoints, Errors errors) {
     // We don't need to keep the return value, because we're not _using_ the injected value
     // anyway... we're just injecting it.
-    Initializable<T> unused =
+    Optional<Initializable<T>> unused =
         initializer.requestInjection(
             injector,
             request.getType(),
             request.getInstance(),
-            null,
+            /* binding= */ null,
             request.getSource(),
             injectionPoints,
             errors);

File: core/src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -323,11 +323,11 @@ public String toString() {
   private static void bindStage(InjectorImpl injector, Stage stage) {
     Key<Stage> key = Key.get(Stage.class);
     InstanceBindingImpl<Stage> stageBinding =
-        new InstanceBindingImpl<Stage>(
+        new InstanceBindingImpl<>(
             injector,
             key,
             SourceProvider.UNKNOWN_SOURCE,
-            new ConstantFactory<Stage>(Initializables.of(stage)),
+            new ConstantFactory<Stage>(stage),
             ImmutableSet.<InjectionPoint>of(),
             stage);
     injector.getBindingData().putBinding(key, stageBinding);

File: core/src/com/google/inject/internal/InternalFactoryToInitializableAdapter.java
Patch:
@@ -45,7 +45,7 @@ public InternalFactoryToInitializableAdapter(
   @Override
   public T get(InternalContext context, Dependency<?> dependency, boolean linked)
       throws InternalProvisionException {
-    return circularGet(initializable.get(), context, dependency, provisionCallback);
+    return circularGet(initializable.get(context), context, dependency, provisionCallback);
   }
 
 

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -82,7 +82,6 @@ public static Test suite() {
     suite.addTestSuite(ReflectionTest.class);
     suite.addTestSuite(RequestInjectionTest.class);
     suite.addTestSuite(RequireAtInjectOnConstructorsTest.class);
-    suite.addTestSuite(ScopesTest.class);
     suite.addTestSuite(SerializationTest.class);
     suite.addTestSuite(SuperclassTest.class);
     suite.addTestSuite(TypeConversionTest.class);

File: core/test/com/google/inject/matcher/MatcherTest.java
Patch:
@@ -102,14 +102,13 @@ public void testOnly() {
     assertFalse(only(1).equals(only(2)));
   }
 
-  @SuppressWarnings("UnnecessaryBoxing")
   public void testIdenticalTo() {
     Object o = new Object();
     assertEquals("identicalTo(1)", identicalTo(1).toString());
     assertTrue(identicalTo(o).matches(o));
     assertFalse(identicalTo(o).matches(new Object()));
     assertEqualsBothWays(identicalTo(o), identicalTo(o));
-    assertFalse(identicalTo(1).equals(identicalTo(new Integer(1))));
+    assertFalse(identicalTo("hello").equals(identicalTo(new String("hello"))));
   }
 
   public void testInPackage() {

File: core/test/com/google/inject/internal/SimilarLookingTypesTest.java
Patch:
@@ -145,7 +145,7 @@ public void oneTypeConversion() {
             convertToLatterViaJvmAnnotations(
                 new TypeLiteral<Map<String, Integer>>() {},
                 new TypeLiteral<Map<? extends String, Integer>>() {}))
-        .isEqualTo("java.util.Map<@JvmWildcards java.lang.String, java.lang.Integer>");
+        .isEqualTo("java.util.Map<@JvmWildcard java.lang.String, java.lang.Integer>");
   }
 
   @Test
@@ -155,7 +155,7 @@ public void mixedConversion() {
                 new TypeLiteral<Map<String, ? extends Integer>>() {},
                 new TypeLiteral<Map<? extends String, Integer>>() {}))
         .isEqualTo(
-            "java.util.Map<@JvmWildcards java.lang.String,"
+            "java.util.Map<@JvmWildcard java.lang.String,"
                 + " @JvmSuppressWildcards java.lang.Integer>");
   }
 
@@ -166,7 +166,7 @@ public void complexConversion() {
                 new TypeLiteral<Map<List<? extends String>, ? super Integer>>() {},
                 new TypeLiteral<Map<? extends List<? extends String>, Integer>>() {}))
         .isEqualTo(
-            "java.util.Map<@JvmWildcards java.util.List<out java.lang.String>,"
+            "java.util.Map<@JvmWildcard java.util.List<out java.lang.String>,"
                 + " @JvmSuppressWildcards java.lang.Integer>");
   }
 }

File: core/src/com/google/inject/internal/aop/UnsafeClassDefiner.java
Patch:
@@ -62,6 +62,9 @@ final class UnsafeClassDefiner implements ClassDefiner {
       unsafeDefiner =
           tryPrivileged(
               HiddenClassDefiner::new, "Cannot bind MethodHandles.Lookup.defineHiddenClass");
+      if (HiddenClassDefiner.HAS_ERROR) {
+        unsafeDefiner = null;
+      }
     }
     UNSAFE_DEFINER = unsafeDefiner;
   }

File: core/test/com/googlecode/guice/BytecodeGenTest.java
Patch:
@@ -155,7 +155,9 @@ protected Class<?> loadClass(final String name, final boolean resolve)
         // standard bootdelegation of java.*
         return super.loadClass(name, resolve);
 
-      } else if (!name.contains(".internal.")) {
+      } else if (!name.contains(".internal.") || name.contains("InternalFlags")) {
+        // Note: the !!contains(InternalFlags) shouldn't be necessary,
+        // but Bazel 7.1.1 w/ JDK11 seems to have a weird classloader that causes issues w/o it.
 
         /*
          * load public and test classes directly from the classpath - we don't

File: core/test/com/google/inject/util/EnhancedTest.java
Patch:
@@ -1,9 +1,9 @@
 package com.google.inject.util;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth8.assertThat;
 import static org.junit.Assume.assumeTrue;
 
+import com.google.common.truth.Truth8;
 import com.google.inject.AbstractModule;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
@@ -46,8 +46,8 @@ public void unenhancedClass() {
     assertThat(bar.bar()).isEqualTo("bar");
 
     // The actual tests.
-    assertThat(Enhanced.unenhancedClass(foo.getClass())).isEqualTo(Optional.of(Foo.class));
-    assertThat(Enhanced.unenhancedClass(bar.getClass())).isEmpty();
+    Truth8.assertThat(Enhanced.unenhancedClass(foo.getClass())).isEqualTo(Optional.of(Foo.class));
+    Truth8.assertThat(Enhanced.unenhancedClass(bar.getClass())).isEmpty();
   }
 
   private static class InterceptingModule extends AbstractModule {

File: core/src/com/google/inject/internal/KotlinSupportInterface.java
Patch:
@@ -25,7 +25,7 @@ public interface KotlinSupportInterface {
    */
   Predicate<Integer> getIsParameterKotlinNullablePredicate(Method method);
 
-  /** Checks for any errors on the constructor's parameters's annotations. */
+  /** Checks for any errors on the constructor's parameters' annotations. */
   void checkConstructorParameterAnnotations(Constructor<?> constructor, Errors errors);
 
   /** Returns whether the {@code clazz} is a local Kotlin class. */

File: extensions/testlib/src/com/google/inject/testing/fieldbinder/BoundFieldModule.java
Patch:
@@ -363,7 +363,7 @@ private boolean allowsNull() {
     }
   }
 
-  /** Returns the the object originally passed to {@link BoundFieldModule#of}). */
+  /** Returns the object originally passed to {@link BoundFieldModule#of}). */
   public Object getInstance() {
     return instance;
   }

File: core/test/com/google/inject/example/JndiProvider.java
Patch:
@@ -21,6 +21,7 @@
 import javax.naming.Context;
 import javax.naming.NamingException;
 
+@SuppressWarnings("BanJNDI")
 class JndiProvider<T> implements Provider<T> {
 
   @Inject Context context;

File: extensions/jndi/src/com/google/inject/jndi/JndiIntegration.java
Patch:
@@ -26,6 +26,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
+@SuppressWarnings("BanJNDI")
 public class JndiIntegration {
 
   private JndiIntegration() {}

File: core/test/com/google/inject/internal/OptionalBinderTest.java
Patch:
@@ -775,6 +775,7 @@ protected void configure() {
       assertContains(
           expected.getMessage(),
           "No implementation for Integer",
+          "Requested by:",
           getShortName(module) + ".configure");
     }
   }

File: core/src/com/google/inject/Inject.java
Patch:
@@ -36,7 +36,7 @@
  *       The Injector then proceeds to perform field and method injections.
  *   <li>Pre-constructed instances passed to {@link Injector#injectMembers}, {@link
  *       com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and {@link
- *       com.google.inject.binder.LinkedBindingBuilder#toProvider(javax.inject.Provider)}. In this
+ *       com.google.inject.binder.LinkedBindingBuilder#toProvider(jakarta.inject.Provider)}. In this
  *       case all constructors are, of course, ignored.
  *   <li>Static fields and methods of classes which any {@link Module} has specifically requested
  *       static injection for, using {@link Binder#requestStaticInjection}.

File: core/src/com/google/inject/ProvidedBy.java
Patch:
@@ -32,5 +32,5 @@
 public @interface ProvidedBy {
 
   /** The implementation type. */
-  Class<? extends javax.inject.Provider<?>> value();
+  Class<? extends jakarta.inject.Provider<?>> value();
 }

File: core/src/com/google/inject/Provider.java
Patch:
@@ -38,7 +38,9 @@
  * @param <T> the type of object this provides
  * @author crazybob@google.com (Bob Lee)
  */
-public interface Provider<T> extends javax.inject.Provider<T>, jakarta.inject.Provider<T> {
+public interface Provider<T>
+    extends
+        jakarta.inject.Provider<T> {
 
   /**
    * Provides an instance of {@code T}.

File: core/src/com/google/inject/Scopes.java
Patch:
@@ -69,7 +69,6 @@ public Boolean visitNoScoping() {
         @Override
         public Boolean visitScopeAnnotation(Class<? extends Annotation> scopeAnnotation) {
           return scopeAnnotation == Singleton.class
-              || scopeAnnotation == javax.inject.Singleton.class
               || scopeAnnotation == jakarta.inject.Singleton.class;
         }
 

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -784,7 +784,7 @@ private <T> BindingImpl<TypeLiteral<T>> createTypeLiteralBinding(
   <T> BindingImpl<T> createProvidedByBinding(
       Key<T> key, Scoping scoping, ProvidedBy providedBy, Errors errors) throws ErrorsException {
     Class<?> rawType = key.getTypeLiteral().getRawType();
-    Class<? extends javax.inject.Provider<?>> providerType = providedBy.value();
+    Class<? extends jakarta.inject.Provider<?>> providerType = providedBy.value();
 
     // Make sure it's not the same type. TODO: Can we check for deeper loops?
     if (providerType == rawType) {

File: core/src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -338,7 +338,6 @@ private static class RootModule implements Module {
     public void configure(Binder binder) {
       binder = binder.withSource(SourceProvider.UNKNOWN_SOURCE);
       binder.bindScope(Singleton.class, SINGLETON);
-      binder.bindScope(javax.inject.Singleton.class, SINGLETON);
       binder.bindScope(jakarta.inject.Singleton.class, SINGLETON);
     }
   }

File: core/src/com/google/inject/internal/InternalFactoryToInitializableAdapter.java
Patch:
@@ -30,10 +30,10 @@
 final class InternalFactoryToInitializableAdapter<T> extends ProviderInternalFactory<T> {
 
   private final ProvisionListenerStackCallback<T> provisionCallback;
-  private final Initializable<? extends javax.inject.Provider<? extends T>> initializable;
+  private final Initializable<? extends jakarta.inject.Provider<? extends T>> initializable;
 
   public InternalFactoryToInitializableAdapter(
-      Initializable<? extends javax.inject.Provider<? extends T>> initializable,
+      Initializable<? extends jakarta.inject.Provider<? extends T>> initializable,
       Object source,
       ProvisionListenerStackCallback<T> provisionCallback) {
     super(source);
@@ -49,7 +49,7 @@ public T get(InternalContext context, Dependency<?> dependency, boolean linked)
 
   @Override
   protected T provision(
-      javax.inject.Provider<? extends T> provider,
+      jakarta.inject.Provider<? extends T> provider,
       Dependency<?> dependency,
       ConstructionContext<T> constructionContext)
       throws InternalProvisionException {

File: core/src/com/google/inject/internal/InternalProvisionException.java
Patch:
@@ -102,7 +102,7 @@ public static InternalProvisionException errorInUserCode(
   }
 
   public static InternalProvisionException subtypeNotProvided(
-      Class<? extends javax.inject.Provider<?>> providerType, Class<?> type) {
+      Class<? extends jakarta.inject.Provider<?>> providerType, Class<?> type) {
     return create(
         ErrorId.SUBTYPE_NOT_PROVIDED, "%s doesn't provide instances of %s.", providerType, type);
   }

File: core/src/com/google/inject/internal/ProvidedByInternalFactory.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.inject.ProvidedBy;
 import com.google.inject.internal.InjectorImpl.JitLimitation;
 import com.google.inject.spi.Dependency;
-import javax.inject.Provider;
+import jakarta.inject.Provider;
 
 /**
  * An {@link InternalFactory} for {@literal @}{@link ProvidedBy} bindings.
@@ -74,7 +74,7 @@ public T get(InternalContext context, Dependency<?> dependency, boolean linked)
 
   @Override
   protected T provision(
-      javax.inject.Provider<? extends T> provider,
+      jakarta.inject.Provider<? extends T> provider,
       Dependency<?> dependency,
       ConstructionContext<T> constructionContext)
       throws InternalProvisionException {

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.inject.internal.ProvisionListenerStackCallback.ProvisionCallback;
 import com.google.inject.spi.Dependency;
 import javax.annotation.Nullable;
-import javax.inject.Provider;
+import jakarta.inject.Provider;
 
 /**
  * Base class for InternalFactories that are used by Providers, to handle circular dependencies.

File: core/src/com/google/inject/internal/Scoping.java
Patch:
@@ -161,7 +161,6 @@ public void applyTo(ScopedBindingBuilder scopedBindingBuilder) {
 
   public static Scoping forAnnotation(final Class<? extends Annotation> scopingAnnotation) {
     if (scopingAnnotation == Singleton.class
-        || scopingAnnotation == javax.inject.Singleton.class
         || scopingAnnotation == jakarta.inject.Singleton.class) {
       return SINGLETON_ANNOTATION;
     }

File: core/src/com/google/inject/multibindings/MapBinderBinding.java
Patch:
@@ -49,10 +49,10 @@ public interface MapBinderBinding<T> {
 
   /**
    * Returns the keys of other bindings that represent this map. This will return an entry for
-   * {@code Map<K, com.google.inject.Provider<V>>}, {@code Map<K, javax.inject.Provider<V>>}, {@code
-   * Map<K, Set<com.google.inject.Provider<V>>>}, {@code Map<K, Set<javax.inject.Provider<V>>>},
+   * {@code Map<K, com.google.inject.Provider<V>>}, {@code Map<K, jakarta.inject.Provider<V>>}, {@code
+   * Map<K, Set<com.google.inject.Provider<V>>>}, {@code Map<K, Set<jakarta.inject.Provider<V>>>},
    * {@code Map<K, Collection<com.google.inject.Provider<V>>>}, {@code Map<K,
-   * Collection<javax.inject.Provider<V>>>}, {@code Map<K, Set<V>}, and {@code Map<K, ? extends V>}.
+   * Collection<jakarta.inject.Provider<V>>>}, {@code Map<K, Set<V>}, and {@code Map<K, ? extends V>}.
    *
    * @since 4.2.3
    */

File: core/src/com/google/inject/multibindings/MultibinderBinding.java
Patch:
@@ -47,7 +47,7 @@ public interface MultibinderBinding<T> {
   /**
    * Returns the keys of other bindings that represent this set. This will return an entry for
    * {@code Collection<com.google.inject.Provider<V>>}, {@code
-   * Collection<javax.inject.Provider<V>>}, and {@code Set<? extends V>}.
+   * Collection<jakarta.inject.Provider<V>>}, and {@code Set<? extends V>}.
    *
    * @since 4.2.3
    */

File: core/src/com/google/inject/multibindings/OptionalBinderBinding.java
Patch:
@@ -45,7 +45,7 @@ public interface OptionalBinderBinding<T> {
   /**
    * Returns the keys of other bindings that represent this OptionalBinder. This will return an
    * entry for {@code Optional<com.google.inject.Provider<V>>} and {@code
-   * Optional<javax.inject.Provider<V>>}.
+   * Optional<jakarta.inject.Provider<V>>}.
    *
    * @since 4.2.3
    */

File: core/src/com/google/inject/spi/ProviderInstanceBinding.java
Patch:
@@ -43,7 +43,7 @@ public interface ProviderInstanceBinding<T> extends Binding<T>, HasDependencies
    *
    * @since 4.0
    */
-  javax.inject.Provider<? extends T> getUserSuppliedProvider();
+  jakarta.inject.Provider<? extends T> getUserSuppliedProvider();
 
   /**
    * Returns the field and method injection points of the provider, injected at injector-creation

File: core/src/com/google/inject/spi/ProviderKeyBinding.java
Patch:
@@ -33,5 +33,5 @@ public interface ProviderKeyBinding<T> extends Binding<T> {
    * injector using {@link com.google.inject.Injector#getBinding(Key)
    * Injector.getBinding(providerKey)}
    */
-  Key<? extends javax.inject.Provider<? extends T>> getProviderKey();
+  Key<? extends jakarta.inject.Provider<? extends T>> getProviderKey();
 }

File: core/test/com/google/inject/KotlinSupportDoesNotBreakJavaTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;

File: core/test/com/google/inject/MembersInjectorTest.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicReference;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
 

File: core/test/com/google/inject/MethodInterceptionTest.java
Patch:
@@ -49,7 +49,7 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
-import javax.inject.Named;
+import jakarta.inject.Named;
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 import org.junit.Before;

File: core/test/com/google/inject/RestrictedBindingSourceTest.java
Patch:
@@ -23,8 +23,8 @@
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 import java.util.logging.Logger;
-import javax.inject.Named;
-import javax.inject.Qualifier;
+import jakarta.inject.Named;
+import jakarta.inject.Qualifier;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;

File: core/test/com/google/inject/errors/ChildBindingAlreadySetErrorTest.java
Patch:
@@ -14,8 +14,8 @@
 import com.google.inject.Provides;
 import com.google.inject.internal.InternalFlags;
 import com.google.inject.internal.InternalFlags.IncludeStackTraceOption;
-import javax.inject.Inject;
-import javax.inject.Named;
+import jakarta.inject.Inject;
+import jakarta.inject.Named;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/errors/DuplicateElementErrorTest.java
Patch:
@@ -17,7 +17,7 @@
 import java.lang.annotation.Retention;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/errors/DuplicateMapKeyErrorTest.java
Patch:
@@ -17,7 +17,7 @@
 import com.google.inject.multibindings.ProvidesIntoMap;
 import com.google.inject.multibindings.StringMapKey;
 import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/errors/ErrorMessagesTest.java
Patch:
@@ -12,7 +12,7 @@
 import com.google.inject.internal.InternalFlags;
 import com.google.inject.internal.InternalFlags.IncludeStackTraceOption;
 import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/errors/MissingConstructorErrorTest.java
Patch:
@@ -10,7 +10,7 @@
 import com.google.inject.Provides;
 import com.google.inject.internal.InternalFlags;
 import com.google.inject.internal.InternalFlags.IncludeStackTraceOption;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/errors/MissingImplementationErrorTest.java
Patch:
@@ -14,8 +14,8 @@
 import com.google.inject.internal.InternalFlags.IncludeStackTraceOption;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
+import jakarta.inject.Provider;
+import jakarta.inject.Qualifier;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/errors/NullInjectedIntoNonNullableTest.java
Patch:
@@ -15,8 +15,8 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Field;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
+import jakarta.inject.Inject;
+import jakarta.inject.Qualifier;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: core/test/com/google/inject/internal/util/LineNumbersTest.java
Patch:
@@ -28,7 +28,7 @@
 import com.google.inject.internal.InternalFlags;
 import com.google.inject.matcher.Matchers;
 import java.lang.reflect.Modifier;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 import org.junit.Test;

File: core/test/com/google/inject/spi/BindingSourceRestrictionTest.java
Patch:
@@ -10,7 +10,7 @@
 import com.google.inject.util.Modules;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
-import javax.inject.Named;
+import jakarta.inject.Named;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;

File: core/test/com/google/inject/spi/InjectorSpiTest.java
Patch:
@@ -126,8 +126,8 @@ protected Void visitOther(Element element) {
     }
     assertThat(actualKeys)
         .containsExactly(Key.get(Stage.class), Key.get(Injector.class), Key.get(Logger.class));
-    // singleton for javax.inject.Singleton, jakarta.inject.Singleton & c.g.i.Singleton
-    assertThat(scopes).hasSize(3);
+    // singleton for jakarta.inject.Singleton & c.g.i.Singleton
+    assertThat(scopes).hasSize(2);
     assertThat(typeConverters).hasSize(10); // all the built-in converters.
   }
 

File: core/test/com/google/inject/spi/ModuleAnnotatedMethodScannerTest.java
Patch:
@@ -47,7 +47,7 @@
 import java.lang.annotation.Target;
 import java.lang.reflect.Method;
 import java.util.Set;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;

File: core/test/com/google/inject/spi/ProviderMethodsTest.java
Patch:
@@ -434,7 +434,7 @@ protected void configure() {
         element instanceof ProviderInstanceBinding);
 
     ProviderInstanceBinding<?> binding = (ProviderInstanceBinding<?>) element;
-    javax.inject.Provider<?> provider = binding.getUserSuppliedProvider();
+    jakarta.inject.Provider<?> provider = binding.getUserSuppliedProvider();
     assertTrue(provider instanceof ProviderMethod);
     assertEquals(methodsObject, ((ProviderMethod) provider).getInstance());
     assertSame(provider, binding.getProviderInstance());

File: core/test/com/googlecode/guice/BytecodeGenTest.java
Patch:
@@ -39,7 +39,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.net.URLClassLoader;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 import org.junit.Before;
@@ -422,7 +422,6 @@ protected Class<?> loadClass(final String name, final boolean resolve)
       }
 
       if (name.startsWith("java.")
-          || name.startsWith("javax.")
           || name.startsWith("jakarta.")
           || name.equals(LogCreator.class.getName())
           || (!name.startsWith("com.google.inject.") && !name.startsWith("com.googlecode.guice"))) {

File: examples/guice-demo/src/main/java/com/example/App.java
Patch:
@@ -5,8 +5,8 @@
 import com.google.inject.Provides;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
+import jakarta.inject.Inject;
+import jakarta.inject.Qualifier;
 
 /** Hello world, Guice! */
 public class App {

File: examples/guice-demo/src/test/java/com/example/AppTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.google.inject.testing.fieldbinder.BoundFieldModule;
 import java.util.ArrayList;
 import java.util.List;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -304,7 +304,6 @@ public TypeLiteral<?> getImplementationType() {
           Key<?> paramKey = Annotations.getKey(param, method, paramAnnotations[p++], errors);
           Class<?> underlylingType = paramKey.getTypeLiteral().getRawType();
           if (underlylingType.equals(Provider.class)
-              || underlylingType.equals(javax.inject.Provider.class)
               || underlylingType.equals(jakarta.inject.Provider.class)) {
             errors.addMessage(
                 "A Provider may not be a type in a factory method of an AssistedInject."

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProvider2Test.java
Patch:
@@ -709,9 +709,9 @@ protected void configure() {
 
   interface JavaxProviderBasedColoredCarFactory {
     Car createCar(
-        javax.inject.Provider<Color> colorProvider, javax.inject.Provider<String> stringProvider);
+        jakarta.inject.Provider<Color> colorProvider, jakarta.inject.Provider<String> stringProvider);
 
-    Mustang createMustang(@Assisted("color") javax.inject.Provider<Color> colorProvider);
+    Mustang createMustang(@Assisted("color") jakarta.inject.Provider<Color> colorProvider);
   }
 
   @Test

File: extensions/assistedinject/test/com/google/inject/assistedinject/subpkg/SubpackageTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
 import java.util.logging.Logger;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;

File: extensions/assistedinject/test/com/google/inject/assistedinject/subpkg/SubpackageTestPrivateFallbackOnly.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
 import java.util.logging.Logger;
-import javax.inject.Inject;
+import jakarta.inject.Inject;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;

File: extensions/dagger-adapter/src/com/google/inject/daggeradapter/DaggerMethodScanner.java
Patch:
@@ -94,7 +94,8 @@ public <T> Key<T> prepareMethod(
   }
 
   private static final ImmutableSet<Class<? extends Annotation>> SCOPE_ANNOTATIONS =
-      ImmutableSet.of(javax.inject.Scope.class, jakarta.inject.Scope.class);
+      ImmutableSet.of(
+          jakarta.inject.Scope.class);
 
   private <T> void configureBindsKey(Binder binder, Method method, Key<T> key) {
     // the Dagger processor already validates the assignability of these two keys. parameterKey()

File: extensions/dagger-adapter/src/com/google/inject/daggeradapter/Keys.java
Patch:
@@ -28,7 +28,8 @@
 /** Utility methods for creating {@link Key}s. */
 final class Keys {
   private static final ImmutableSet<Class<? extends Annotation>> QUALIFIERS =
-      ImmutableSet.of(javax.inject.Qualifier.class, jakarta.inject.Qualifier.class);
+      ImmutableSet.of(
+          jakarta.inject.Qualifier.class);
 
   static Key<?> parameterKey(Parameter parameter) {
     Optional<Annotation> qualifier = getAnnotatedAnnotation(parameter, QUALIFIERS);

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/DaggerAdapterTest.java
Patch:
@@ -39,8 +39,8 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
 import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
+import jakarta.inject.Inject;
+import jakarta.inject.Qualifier;
 import junit.framework.TestCase;
 
 /**

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/IntoMapTest.java
Patch:
@@ -34,7 +34,7 @@
 import dagger.multibindings.StringKey;
 import java.lang.annotation.Retention;
 import java.util.Map;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import junit.framework.TestCase;
 
 /** {@link IntoMap} tests for {@link DaggerAdapter}. */

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/MultibindsTest.java
Patch:
@@ -31,7 +31,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 import java.util.Set;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import junit.framework.TestCase;
 
 /** Tests of {@link Multibinds} support in {@link DaggerAdapter}. */

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/OptionalBindingsTest.java
Patch:
@@ -28,7 +28,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Optional;
-import javax.inject.Qualifier;
+import jakarta.inject.Qualifier;
 import junit.framework.TestCase;
 
 /** Tests of {@link BindsOptionalOf} support in {@link DaggerAdapter}. */

File: extensions/persist/src/com/google/inject/persist/jpa/JpaLocalTxnInterceptor.java
Patch:
@@ -20,8 +20,8 @@
 import com.google.inject.persist.Transactional;
 import com.google.inject.persist.UnitOfWork;
 import java.lang.reflect.Method;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityTransaction;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityTransaction;
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 

File: extensions/persist/src/com/google/inject/persist/jpa/JpaPersistModule.java
Patch:
@@ -32,8 +32,8 @@
 import java.lang.reflect.Proxy;
 import java.util.List;
 import java.util.Map;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 

File: extensions/persist/src/com/google/inject/persist/jpa/JpaPersistService.java
Patch:
@@ -29,9 +29,9 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import java.util.Map;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
-import javax.persistence.Persistence;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
+import jakarta.persistence.Persistence;
 
 /**
  * @author Dhanji R. Prasanna (dhanji@gmail.com)

File: extensions/persist/test/com/google/inject/persist/jpa/ClassLevelManagedLocalTransactionsTest.java
Patch:
@@ -26,9 +26,9 @@
 import java.io.IOException;
 import java.util.Date;
 import java.util.List;
-import javax.inject.Provider;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.inject.Provider;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /**

File: extensions/persist/test/com/google/inject/persist/jpa/CustomPropsEntityManagerFactoryProvisionTest.java
Patch:
@@ -21,8 +21,8 @@
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.UnitOfWork;
 import java.util.Properties;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /** @author Dhanji R. Prasanna (dhanji@gmail.com) */

File: extensions/persist/test/com/google/inject/persist/jpa/DynamicFinderTest.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Date;
 import java.util.List;
 import java.util.UUID;
-import javax.persistence.EntityManager;
+import jakarta.persistence.EntityManager;
 import junit.framework.TestCase;
 
 /**

File: extensions/persist/test/com/google/inject/persist/jpa/EnsureJpaCanTakeObjectsInPropertiesTest.java
Patch:
@@ -21,8 +21,8 @@
 import com.google.inject.persist.UnitOfWork;
 import java.util.HashMap;
 import java.util.Map;
-import javax.persistence.EntityManagerFactory;
-import javax.persistence.PersistenceException;
+import jakarta.persistence.EntityManagerFactory;
+import jakarta.persistence.PersistenceException;
 import javax.sql.DataSource;
 import junit.framework.TestCase;
 import org.hibernate.cfg.Environment;

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerFactoryProvisionTest.java
Patch:
@@ -20,8 +20,8 @@
 import com.google.inject.Injector;
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.UnitOfWork;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /** @author Dhanji R. Prasanna (dhanji@gmail.com) */

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerPerRequestProvisionTest.java
Patch:
@@ -22,8 +22,8 @@
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.Transactional;
 import com.google.inject.persist.UnitOfWork;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /**

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerProvisionTest.java
Patch:
@@ -22,8 +22,8 @@
 import com.google.inject.Provider;
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.Transactional;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /**

File: extensions/persist/test/com/google/inject/persist/jpa/JpaPersistServiceTest.java
Patch:
@@ -23,9 +23,9 @@
 import static org.mockito.Mockito.when;
 
 import java.util.Properties;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
-import javax.persistence.spi.PersistenceProvider;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
+import jakarta.persistence.spi.PersistenceProvider;
 import junit.framework.TestCase;
 
 public class JpaPersistServiceTest extends TestCase {

File: extensions/persist/test/com/google/inject/persist/jpa/JpaTestEntity.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.persist.jpa;
 
-import javax.persistence.Entity;
-import javax.persistence.GeneratedValue;
-import javax.persistence.Id;
+import jakarta.persistence.Entity;
+import jakarta.persistence.GeneratedValue;
+import jakarta.persistence.Id;
 
 /** @author Dhanji R. Prasanna (dhanji@gmail.com) */
 @Entity

File: extensions/persist/test/com/google/inject/persist/jpa/JpaWorkManagerTest.java
Patch:
@@ -23,9 +23,9 @@
 import com.google.inject.persist.Transactional;
 import com.google.inject.persist.UnitOfWork;
 import java.util.Date;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
-import javax.persistence.Query;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
+import jakarta.persistence.Query;
 import junit.framework.TestCase;
 import org.hibernate.HibernateException;
 

File: extensions/persist/test/com/google/inject/persist/jpa/ManualLocalTransactionsConfidenceTest.java
Patch:
@@ -22,9 +22,9 @@
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.Transactional;
 import java.util.Date;
-import javax.inject.Provider;
-import javax.persistence.EntityManager;
-import javax.persistence.PersistenceException;
+import jakarta.inject.Provider;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.PersistenceException;
 import junit.framework.TestCase;
 
 /** @author Dhanji R. Prasanna (dhanji@gmail.com) */

File: extensions/persist/test/com/google/inject/persist/jpa/ManualLocalTransactionsTest.java
Patch:
@@ -23,8 +23,8 @@
 import com.google.inject.persist.Transactional;
 import com.google.inject.persist.UnitOfWork;
 import java.util.Date;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /**

File: extensions/persist/test/com/google/inject/persist/jpa/ManualLocalTransactionsWithCustomMatcherTest.java
Patch:
@@ -23,8 +23,8 @@
 import com.google.inject.persist.Transactional;
 import com.google.inject.persist.UnitOfWork;
 import java.util.Date;
-import javax.persistence.EntityManager;
-import javax.persistence.EntityManagerFactory;
+import jakarta.persistence.EntityManager;
+import jakarta.persistence.EntityManagerFactory;
 import junit.framework.TestCase;
 
 /**

File: extensions/servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import javax.servlet.Filter;
+import jakarta.servlet.Filter;
 
 /**
  * Builds the guice module that binds configured filters, with their wrapper FilterDefinitions. Is

File: extensions/servlet/src/com/google/inject/servlet/GuiceServletContextListener.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.inject.Injector;
 import java.lang.ref.WeakReference;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletContextEvent;
-import javax.servlet.ServletContextListener;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletContextEvent;
+import jakarta.servlet.ServletContextListener;
 
 /**
  * As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener} class

File: extensions/servlet/src/com/google/inject/servlet/InstanceFilterBinding.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject.servlet;
 
-import javax.servlet.Filter;
+import jakarta.servlet.Filter;
 
 /**
  * A binding to a single instance of a filter.

File: extensions/servlet/src/com/google/inject/servlet/InstanceFilterBindingImpl.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.common.base.MoreObjects;
 import java.util.Map;
-import javax.servlet.Filter;
+import jakarta.servlet.Filter;
 
 /**
  * Default implementation of InstanceFilterBinding.

File: extensions/servlet/src/com/google/inject/servlet/InstanceServletBinding.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject.servlet;
 
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * A binding to a single instance of a servlet.

File: extensions/servlet/src/com/google/inject/servlet/InstanceServletBindingImpl.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.common.base.MoreObjects;
 import java.util.Map;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * Default implementation of InstanceServletBinding.

File: extensions/servlet/src/com/google/inject/servlet/LinkedFilterBinding.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject.servlet;
 
 import com.google.inject.Key;
-import javax.servlet.Filter;
+import jakarta.servlet.Filter;
 
 /**
  * A linked binding to a filter.

File: extensions/servlet/src/com/google/inject/servlet/LinkedFilterBindingImpl.java
Patch:
@@ -19,7 +19,7 @@
 import com.google.common.base.MoreObjects;
 import com.google.inject.Key;
 import java.util.Map;
-import javax.servlet.Filter;
+import jakarta.servlet.Filter;
 
 /**
  * Default implementation of LinkedFilterBinding.

File: extensions/servlet/src/com/google/inject/servlet/LinkedServletBinding.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject.servlet;
 
 import com.google.inject.Key;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * A linked binding to a servlet.

File: extensions/servlet/src/com/google/inject/servlet/LinkedServletBindingImpl.java
Patch:
@@ -19,7 +19,7 @@
 import com.google.common.base.MoreObjects;
 import com.google.inject.Key;
 import java.util.Map;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * Default implementation of LinkedServletBinding.

File: extensions/servlet/src/com/google/inject/servlet/RequestScoped.java
Patch:
@@ -20,7 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
-import javax.inject.Scope;
+import jakarta.inject.Scope;
 
 /**
  * Apply this to implementation classes when you want one instance per request.

File: extensions/servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -22,9 +22,9 @@
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
 import java.util.Map;
-import javax.servlet.Filter;
-import javax.servlet.ServletContext;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.Filter;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * Configures the servlet scopes and creates bindings for the servlet API objects so you can inject

File: extensions/servlet/src/com/google/inject/servlet/ServletModuleTargetVisitor.java
Patch:
@@ -17,8 +17,8 @@
 import com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder;
 import com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder;
 import com.google.inject.spi.BindingTargetVisitor;
-import javax.servlet.Filter;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.Filter;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * A visitor for the servlet extension.

File: extensions/servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -30,9 +30,9 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import javax.servlet.http.HttpSession;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpSession;
 
 /**
  * Servlet scopes.

File: extensions/servlet/src/com/google/inject/servlet/ServletUtils.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 
 /**
  * Some servlet utility methods.

File: extensions/servlet/src/com/google/inject/servlet/ServletsModuleBuilder.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * Builds the guice module that binds configured servlets, with their wrapper ServletDefinitions. Is

File: extensions/servlet/test/com/google/inject/servlet/ContinuingHttpServletRequestTest.java
Patch:
@@ -18,8 +18,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.Cookie;
+import jakarta.servlet.http.HttpServletRequest;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
 

File: extensions/servlet/test/com/google/inject/servlet/DummyServlet.java
Patch:
@@ -16,7 +16,7 @@
 package com.google.inject.servlet;
 
 import com.google.inject.Singleton;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * Used in unit tests to verify the EDSL.

File: extensions/servlet/test/com/google/inject/servlet/InvalidScopeBindingTest.java
Patch:
@@ -5,9 +5,9 @@
 import com.google.inject.Guice;
 import com.google.inject.Scopes;
 import com.google.inject.Singleton;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.FilterConfig;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.HttpServlet;
 import junit.framework.TestCase;
 
 /**

File: extensions/servlet/test/com/google/inject/servlet/MultipleServletInjectorsTest.java
Patch:
@@ -23,9 +23,9 @@
 
 import com.google.inject.Guice;
 import com.google.inject.Injector;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletContextEvent;
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletContextEvent;
+import jakarta.servlet.http.HttpServlet;
 import junit.framework.TestCase;
 
 /**

File: extensions/servlet/test/com/google/inject/servlet/ScopeRequestIntegrationTest.java
Patch:
@@ -35,7 +35,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import junit.framework.TestCase;
 
 /** Tests continuation of requests */

File: extensions/servlet/test/com/google/inject/servlet/ServletUtilsTest.java
Patch:
@@ -5,7 +5,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 import junit.framework.TestCase;
 
 /**

File: extensions/struts2/test/com/google/inject/struts2/Struts2FactoryTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.google.inject.servlet.GuiceServletContextListener;
 import com.google.inject.servlet.ServletModule;
 import java.util.Date;
-import javax.inject.Singleton;
+import jakarta.inject.Singleton;
 import junit.framework.TestCase;
 import org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter;
 

File: core/test/com/googlecode/guice/BytecodeGenTest.java
Patch:
@@ -213,7 +213,7 @@ interface ProxyTest {
   public static class ProxyTestImpl implements ProxyTest {
 
     static {
-      //System.out.println(ProxyTestImpl.class.getClassLoader());
+      // System.out.println(ProxyTestImpl.class.getClassLoader());
     }
 
     @Override
@@ -423,9 +423,9 @@ protected Class<?> loadClass(final String name, final boolean resolve)
 
       if (name.startsWith("java.")
           || name.startsWith("javax.")
+          || name.startsWith("jakarta.")
           || name.equals(LogCreator.class.getName())
-          || (!name.startsWith("com.google.inject.")
-              && !name.startsWith("com.googlecode.guice"))) {
+          || (!name.startsWith("com.google.inject.") && !name.startsWith("com.googlecode.guice"))) {
 
         // standard parent delegation
         return super.loadClass(name, resolve);

File: core/src/com/google/inject/internal/RealMultibinder.java
Patch:
@@ -53,7 +53,6 @@ public final class RealMultibinder<T> implements Module {
 
   /** Implementation of newSetBinder. */
   public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) {
-    binder = binder.skipSources(RealMultibinder.class);
     RealMultibinder<T> result = new RealMultibinder<>(binder, key);
     binder.install(result);
     return result;

File: core/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -134,7 +134,7 @@ public static <T> Multibinder<T> newSetBinder(
    * @since 4.0
    */
   public static <T> Multibinder<T> newSetBinder(Binder binder, Key<T> key) {
-    return new Multibinder<T>(newRealSetBinder(binder.skipSources(Multibinder.class), key));
+    return new Multibinder<T>(newRealSetBinder(binder, key));
   }
 
   /**

File: core/src/com/google/inject/Scopes.java
Patch:
@@ -69,7 +69,8 @@ public Boolean visitNoScoping() {
         @Override
         public Boolean visitScopeAnnotation(Class<? extends Annotation> scopeAnnotation) {
           return scopeAnnotation == Singleton.class
-              || scopeAnnotation == javax.inject.Singleton.class;
+              || scopeAnnotation == javax.inject.Singleton.class
+              || scopeAnnotation == jakarta.inject.Singleton.class;
         }
 
         @Override

File: core/src/com/google/inject/internal/DelegatingInvocationHandler.java
Patch:
@@ -44,7 +44,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
               + " proxying is initialized to null."
               + " No methods can be called.");
 
-      // TODO: user -; ?
+      // TODO: method.setAccessible(true); ?
       // this would fix visibility errors when we proxy a
       // non-public interface.
       return method.invoke(delegate, args);

File: core/src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -339,6 +339,7 @@ public void configure(Binder binder) {
       binder = binder.withSource(SourceProvider.UNKNOWN_SOURCE);
       binder.bindScope(Singleton.class, SINGLETON);
       binder.bindScope(javax.inject.Singleton.class, SINGLETON);
+      binder.bindScope(jakarta.inject.Singleton.class, SINGLETON);
     }
   }
 

File: core/test/com/google/inject/spi/InjectorSpiTest.java
Patch:
@@ -124,7 +124,8 @@ protected Void visitOther(Element element) {
     }
     assertThat(actualKeys)
         .containsExactly(Key.get(Stage.class), Key.get(Injector.class), Key.get(Logger.class));
-    assertThat(scopes).hasSize(2); // singleton for javax.inject.Singleton & c.g.i.Singleton
+    // singleton for javax.inject.Singleton, jakarta.inject.Singleton & c.g.i.Singleton
+    assertThat(scopes).hasSize(3);
     assertThat(typeConverters).hasSize(10); // all the built-in converters.
   }
 

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -304,7 +304,8 @@ public TypeLiteral<?> getImplementationType() {
           Key<?> paramKey = Annotations.getKey(param, method, paramAnnotations[p++], errors);
           Class<?> underlylingType = paramKey.getTypeLiteral().getRawType();
           if (underlylingType.equals(Provider.class)
-              || underlylingType.equals(javax.inject.Provider.class)) {
+              || underlylingType.equals(javax.inject.Provider.class)
+              || underlylingType.equals(jakarta.inject.Provider.class)) {
             errors.addMessage(
                 "A Provider may not be a type in a factory method of an AssistedInject."
                     + "\n  Offending instance is parameter [%s] with key [%s] on method [%s]",

File: extensions/servlet/test/com/google/inject/servlet/ContextPathTest.java
Patch:
@@ -71,7 +71,7 @@ protected void configureServlets() {
                     .in(Scopes.SINGLETON);
                 serve("/foo/*").with(Key.get(TestServlet.class, Names.named("foo")));
                 serve("/bar/*").with(Key.get(TestServlet.class, Names.named("bar")));
-                // TODO - call and validate it is correct
+                // TODO: add a filter(..) call and validate it is correct
               }
             });
     injector.injectMembers(this);

File: core/src/com/google/inject/internal/DelegatingInvocationHandler.java
Patch:
@@ -44,7 +44,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
               + " proxying is initialized to null."
               + " No methods can be called.");
 
-      // TODO: method.setAccessible(true); ?
+      // TODO: user -; ?
       // this would fix visibility errors when we proxy a
       // non-public interface.
       return method.invoke(delegate, args);

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -167,7 +167,7 @@ private <T> Dependency<T> newDependency(Key<T> key, boolean allowsNull, int para
 
   /** Returns the injected constructor, field, or method. */
   public Member getMember() {
-    // TODO: Don't expose the original member (which probably has setAccessible(true)).
+    // TODO -).
     return member;
   }
 

File: extensions/servlet/test/com/google/inject/servlet/ContextPathTest.java
Patch:
@@ -71,7 +71,7 @@ protected void configureServlets() {
                     .in(Scopes.SINGLETON);
                 serve("/foo/*").with(Key.get(TestServlet.class, Names.named("foo")));
                 serve("/bar/*").with(Key.get(TestServlet.class, Names.named("bar")));
-                // TODO: add a filter(..) call and validate it is correct
+                // TODO - call and validate it is correct
               }
             });
     injector.injectMembers(this);

File: core/src/com/google/inject/internal/aop/AbstractGlueGenerator.java
Patch:
@@ -102,8 +102,8 @@ protected AbstractGlueGenerator(Class<?> hostClass, String marker) {
 
   /** Generates a unique name based on the original class name and marker. */
   private static String proxyName(String hostName, String marker, int hash) {
-    int id = ((hash & 0x000FFFFF) | (COUNTER.getAndIncrement() << 20));
-    String proxyName = hostName + marker + id;
+    long id = ((hash & 0x000FFFFF) | (COUNTER.getAndIncrement() << 20));
+    String proxyName = hostName + marker + Long.toHexString(id);
     if (proxyName.startsWith("java/") && !ClassDefining.hasPackageAccess()) {
       proxyName = '$' + proxyName; // can't define java.* glue in same package
     }

File: extensions/persist/test/com/google/inject/persist/jpa/CustomPropsEntityManagerFactoryProvisionTest.java
Patch:
@@ -54,6 +54,8 @@ public void testSessionCreateOnInjection() {
     //startup persistence
     injector.getInstance(PersistService.class).start();
 
+    injector.getInstance(UnitOfWork.class).begin();
+
     //obtain em
     assertTrue(injector.getInstance(EntityManager.class).isOpen());
   }

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerFactoryProvisionTest.java
Patch:
@@ -50,6 +50,8 @@ public void testSessionCreateOnInjection() {
     //startup persistence
     injector.getInstance(PersistService.class).start();
 
+    injector.getInstance(UnitOfWork.class).begin();
+
     //obtain em
     assertTrue(injector.getInstance(EntityManager.class).isOpen());
   }

File: extensions/persist/test/com/google/inject/persist/jpa/JpaPersistServiceTest.java
Patch:
@@ -34,7 +34,8 @@ public class JpaPersistServiceTest extends TestCase {
   private static final Properties PERSISTENCE_PROPERTIES = new Properties();
 
   private final JpaPersistService sut =
-      new JpaPersistService(PERSISTENCE_UNIT_NAME, PERSISTENCE_PROPERTIES);
+      new JpaPersistService(
+          JpaPersistOptions.builder().build(), PERSISTENCE_UNIT_NAME, PERSISTENCE_PROPERTIES);
   private final PersistenceProvider provider = mock(PersistenceProvider.class);
   private final EntityManagerFactory factory = mock(EntityManagerFactory.class);
   private final EntityManager entityManager = mock(EntityManager.class);

File: extensions/persist/test/com/google/inject/persist/jpa/ManualLocalTransactionsConfidenceTest.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.Transactional;
 import java.util.Date;
+import javax.inject.Provider;
 import javax.persistence.EntityManager;
 import javax.persistence.PersistenceException;
 import junit.framework.TestCase;
@@ -71,10 +72,11 @@ public void testThrowingCleanupInterceptorConfidence() {
   }
 
   public static class TransactionalObject {
-    @Inject EntityManager em;
+    @Inject Provider<EntityManager> emProvider;
 
     @Transactional
     public void runOperationInTxn() {
+      EntityManager em = emProvider.get();
       JpaParentTestEntity entity = new JpaParentTestEntity();
       JpaTestEntity child = new JpaTestEntity();
 

File: core/test/com/google/inject/BinderTest.java
Patch:
@@ -464,6 +464,8 @@ protected void configure() {
     assertNotNull(injector.getInstance(HasProvidedBy1.class));
     assertNotNull(injector.getInstance(HasImplementedBy1.class));
     assertNotSame(HasProvidedBy2.class, injector.getInstance(HasProvidedBy2.class).getClass());
+    assertNotSame(
+        injector.getInstance(HasProvidedBy2.class), injector.getInstance(HasProvidedBy2.class));
     assertSame(
         ExtendsHasImplementedBy2.class, injector.getInstance(HasImplementedBy2.class).getClass());
     assertSame(JustAClass.class, injector.getInstance(JustAClass.class).getClass());

File: core/src/com/google/inject/internal/ErrorId.java
Patch:
@@ -54,6 +54,7 @@ public enum ErrorId {
   RECURSIVE_BINDING,
   RECURSIVE_IMPLEMENTATION_TYPE,
   RECURSIVE_PROVIDER_TYPE,
+  REQUEST_INJECTION_WITH_DIFFERENT_TYPES,
   SCOPE_ANNOTATION_ON_ABSTRACT_TYPE,
   SCOPE_NOT_FOUND,
   STATIC_INJECTION_ON_INTERFACE,

File: core/src/com/google/inject/spi/InjectionRequest.java
Patch:
@@ -77,8 +77,7 @@ public TypeLiteral<T> getType() {
    *     the valid injection points.
    */
   public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException {
-    return InjectionPoint.forInstanceMethodsAndFields(
-        instance != null ? TypeLiteral.get(instance.getClass()) : type);
+    return InjectionPoint.forInstanceMethodsAndFields(type);
   }
 
   @Override

File: core/src/com/google/inject/Exposed.java
Patch:
@@ -24,7 +24,7 @@
 import java.lang.annotation.Target;
 
 /**
- * Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
+ * Accompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
  * private module to indicate that the provided binding is exposed.
  *
  * @author jessewilson@google.com (Jesse Wilson)

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -134,7 +134,7 @@ private <T> void validateKey(Object source, Key<T> key) {
   }
 
   /**
-   * Processor for visiting bindings. Each overriden method that wants to actually process the
+   * Processor for visiting bindings. Each overridden method that wants to actually process the
    * binding should call prepareBinding first.
    */
   abstract class Processor<T, V> extends DefaultBindingTargetVisitor<T, V> {
@@ -157,7 +157,7 @@ protected void prepareBinding() {
 
     /**
      * Schedule initialization of this binding to occur immediately after all bindings have been
-     * initialially processed.
+     * initially processed.
      */
     protected void scheduleInitialization(BindingImpl<?> binding) {
       processedBindingData.addUninitializedBinding(() -> initializeBinding(binding));

File: core/src/com/google/inject/internal/InternalProviderInstanceBindingImpl.java
Patch:
@@ -82,7 +82,7 @@ abstract static class Factory<T> implements InternalFactory<T>, Provider<T>, Has
      *
      * <p>May be useful for augmenting runtime error messages.
      *
-     * <p>Note: this will return {#code null} until {@link #initialize(InjectorImpl, Errors)} has
+     * <p>Note: this will return {@code null} until {@link #initialize(InjectorImpl, Errors)} has
      * already been called.
      */
     final Object getSource() {

File: core/src/com/google/inject/internal/Scoping.java
Patch:
@@ -303,7 +303,7 @@ static <T> InternalFactory<? extends T> scope(
   /**
    * Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance
    * map. If the scope annotation has no corresponding instance, an error will be added and unscoped
-   * will be retuned.
+   * will be returned.
    */
   static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) {
     Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation();

File: core/src/com/google/inject/multibindings/ProvidesIntoOptional.java
Patch:
@@ -32,7 +32,7 @@
  * <pre>
  * {@literal @}ProvidesIntoOptional(DEFAULT)
  * {@literal @}Named("url")
- * String provideFooUrl(FooManager fm) { returm fm.getUrl(); }
+ * String provideFooUrl(FooManager fm) { return fm.getUrl(); }
  *
  * {@literal @}ProvidesIntoOptional(ACTUAL)
  * {@literal @}Named("url")

File: core/src/com/google/inject/spi/ConstructorBinding.java
Patch:
@@ -24,7 +24,7 @@
 import org.aopalliance.intercept.MethodInterceptor;
 
 /**
- * A binding to the constructor of a concrete clss. To resolve injections, an instance is
+ * A binding to the constructor of a concrete class. To resolve injections, an instance is
  * instantiated by invoking the constructor.
  *
  * @author jessewilson@google.com (Jesse Wilson)

File: core/src/com/google/inject/spi/Dependency.java
Patch:
@@ -86,7 +86,7 @@ public InjectionPoint getInjectionPoint() {
 
   /**
    * Returns the index of this dependency in the injection point's parameter list, or {@code -1} if
-   * this dependency does not belong to a parameter list. Only method and constuctor dependencies
+   * this dependency does not belong to a parameter list. Only method and constructor dependencies
    * are elements in a parameter list.
    */
   public int getParameterIndex() {

File: core/src/com/google/inject/spi/ElementVisitor.java
Patch:
@@ -56,7 +56,7 @@ public interface ElementVisitor<V> {
   /** Visit a lookup of the members injector. */
   <T> V visit(MembersInjectorLookup<T> lookup);
 
-  /** Visit an error message and the context in which it occured. */
+  /** Visit an error message and the context in which it occurred. */
   V visit(Message message);
 
   /**

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -894,7 +894,7 @@ public static Annotation[] getAnnotations(Field field) {
     return ObjectArrays.concat(javaAnnotations, kotlinAnnotations, Annotation.class);
   }
 
-  /** A method signature. Used to handle method overridding. */
+  /** A method signature. Used to handle method overriding. */
   static class Signature {
 
     final String name;

File: core/src/com/google/inject/spi/Message.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.List;
 
 /**
- * An error message and the context in which it occured. Messages are usually created internally by
+ * An error message and the context in which it occurred. Messages are usually created internally by
  * Guice and its extensions. Messages can be created explicitly in a module using {@link
  * com.google.inject.Binder#addError(Throwable) addError()} statements:
  *

File: extensions/assistedinject/src/com/google/inject/assistedinject/AssistedConstructor.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.Set;
 
 /**
- * Internal respresentation of a constructor annotated with {@link AssistedInject}
+ * Internal representation of a constructor annotated with {@link AssistedInject}
  *
  * @author jmourits@google.com (Jerome Mourits)
  * @author jessewilson@google.com (Jesse Wilson)

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -145,7 +145,7 @@
  * <h3>Backwards compatibility using {@literal @}AssistedInject</h3>
  *
  * Instead of the {@literal @}Inject annotation, you may annotate the constructed classes with
- * {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatability mode.
+ * {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatibility mode.
  *
  * <p>Instead of matching factory method arguments to constructor parameters using their names, the
  * <strong>parameters are matched by their order</strong>. The first factory method argument is used

File: extensions/assistedinject/src/com/google/inject/assistedinject/ParameterListKey.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.List;
 
 /**
- * A list of {@link TypeLiteral}s to match an injectable Constructor's assited parameter types to
+ * A list of {@link TypeLiteral}s to match an injectable Constructor's assisted parameter types to
  * the corresponding factory method.
  *
  * @author jmourits@google.com (Jerome Mourits)

File: extensions/grapher/src/com/google/inject/grapher/DefaultEdgeCreator.java
Patch:
@@ -96,7 +96,7 @@ public Collection<Edge> visit(ConvertedConstantBinding<?> binding) {
     }
 
     /**
-     * Visitor for {@link InstanceBinding}. We then render any dependency edgess that the instance
+     * Visitor for {@link InstanceBinding}. We then render any dependency edges that the instance
      * may have, which come either from {@link InjectionPoint}s (method and field) on the instance,
      * or on {@link Dependency}s the instance declares through the {@link HasDependencies}
      * interface.

File: extensions/persist/src/com/google/inject/persist/finder/MaxResults.java
Patch:
@@ -23,7 +23,7 @@
 
 /**
  * Annotate any dynamic finder method's integer argument with this to pass in the maximum size of
- * returned result window. Usefule for paging result sets. Complement of {@link FirstResult}.
+ * returned result window. Useful for paging result sets. Complement of {@link FirstResult}.
  *
  * @author Dhanji R. Prasanna (dhanji@gmail.com)
  */

File: extensions/persist/src/com/google/inject/persist/jpa/JpaLocalTxnInterceptor.java
Patch:
@@ -117,7 +117,7 @@ private Transactional readTransactionMetadata(MethodInvocation methodInvocation)
   /**
    * Returns True if rollback DID NOT HAPPEN (i.e. if commit should continue).
    *
-   * @param transactional The metadata annotaiton of the method
+   * @param transactional The metadata annotation of the method
    * @param e The exception to test for rollback
    * @param txn A JPA Transaction to issue rollbacks on
    */

File: extensions/servlet/test/com/google/inject/servlet/ExtensionSpiTest.java
Patch:
@@ -34,7 +34,7 @@
 import junit.framework.TestCase;
 
 /**
- * A very basic test that servletmodule works with bindings.
+ * A very basic test that servlet module works with bindings.
  *
  * @author sameb@google.com (Sam Berlin)
  */

File: core/src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -510,7 +510,7 @@ public String toString() {
 
   /**
    * The WildcardType interface supports multiple upper bounds and multiple lower bounds. We only
-   * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper
+   * support what the Java 8 language needs - at most one bound. If a lower bound is set, the upper
    * bound must be Object.class.
    */
   public static class WildcardTypeImpl implements WildcardType, Serializable, CompositeType {

File: core/src/com/google/inject/internal/BindingAlreadySetError.java
Patch:
@@ -39,7 +39,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .map(e -> ((BindingAlreadySetError) e).binding.getSource())
             .map(ImmutableList::of)
             .collect(Collectors.toList()));
-    formatter.format("%n%s%n", Messages.bold("Bound at:"));
+    formatter.format("\n%s\n", Messages.bold("Bound at:"));
     for (int i = 0; i < sourcesList.size(); i++) {
       ErrorFormatter.formatSources(i + 1, sourcesList.get(i), formatter);
     }

File: core/src/com/google/inject/internal/ChildBindingAlreadySetError.java
Patch:
@@ -43,12 +43,12 @@ public boolean isMergeable(ErrorDetail<?> otherError) {
 
   @Override
   public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
-    formatter.format("%n%s%n", Messages.bold("Bound at:"));
+    formatter.format("\n%s\n", Messages.bold("Bound at:"));
     int index = 1;
     for (Object source : existingSources) {
       formatter.format("%-2s: ", index++);
       if (source.equals("")) {
-        formatter.format("as a just-in-time binding%n");
+        formatter.format("as a just-in-time binding\n");
       } else {
         new SourceFormatter(source, formatter, /* omitPreposition= */ true).format();
       }
@@ -63,7 +63,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .filter(list -> !list.isEmpty())
             .collect(Collectors.toList());
     if (!filteredSources.isEmpty()) {
-      formatter.format("%n%s%n", Messages.bold("Requested by:"));
+      formatter.format("\n%s\n", Messages.bold("Requested by:"));
       for (int i = 0; i < sourcesList.size(); i++) {
         ErrorFormatter.formatSources(i + 1, sourcesList.get(i), formatter);
       }

File: core/src/com/google/inject/internal/InternalProvisionException.java
Patch:
@@ -124,7 +124,7 @@ public static InternalProvisionException errorInUserInjector(
     return errorInUserCode(
         ErrorId.ERROR_IN_USER_INJECTOR,
         cause,
-        "Error injecting %s using %s.%n Reason: %s",
+        "Error injecting %s using %s.\n Reason: %s",
         type,
         listener,
         cause);
@@ -142,7 +142,7 @@ public static InternalProvisionException errorNotifyingInjectionListener(
     return errorInUserCode(
         ErrorId.OTHER,
         cause,
-        "Error notifying InjectionListener %s of %s.%n Reason: %s",
+        "Error notifying InjectionListener %s of %s.\n Reason: %s",
         listener,
         type,
         cause);
@@ -191,7 +191,7 @@ static void onNullInjectedIntoNonNullableDependency(Object source, Dependency<?>
             : "the " + parameterName + " of " + memberStackTraceElement;
     throw InternalProvisionException.create(
             ErrorId.NULL_INJECTED_INTO_NON_NULLABLE,
-            "null returned by binding at %s%n but %s is not @Nullable",
+            "null returned by binding at %s\n but %s is not @Nullable",
             source,
             formattedDependency)
         .addSource(source);

File: core/src/com/google/inject/internal/Messages.java
Patch:
@@ -69,7 +69,7 @@ public static String format(String messageFormat, Object... arguments) {
 
   /** Returns the formatted message for an exception with the specified messages. */
   public static String formatMessages(String heading, Collection<Message> errorMessages) {
-    Formatter fmt = new Formatter().format(heading).format(":%n%n");
+    Formatter fmt = new Formatter().format(heading).format(":\n\n");
     int index = 1;
     boolean displayCauses = getOnlyCause(errorMessages) == null;
 
@@ -102,7 +102,7 @@ public static String formatMessages(String heading, Collection<Message> errorMes
               cause.getClass().getName(), causeIdx);
         }
       }
-      fmt.format("%n");
+      fmt.format("\n");
       index++;
     }
 

File: core/src/com/google/inject/internal/MissingImplementationError.java
Patch:
@@ -55,7 +55,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .collect(Collectors.toList());
 
     if (!filteredSourcesList.isEmpty()) {
-      formatter.format("%n%s%n", Messages.bold("Requested by:"));
+      formatter.format("\n%s\n", Messages.bold("Requested by:"));
       int sourceListIndex = 1;
       for (List<Object> sources : filteredSourcesList) {
         ErrorFormatter.formatSources(sourceListIndex++, Lists.reverse(sources), formatter);

File: core/src/com/google/inject/internal/ProvisionListenerStackCallback.java
Patch:
@@ -76,7 +76,7 @@ public T provision(InternalContext context, ProvisionCallback<T> callable)
       throw InternalProvisionException.errorInUserCode(
           ErrorId.OTHER,
           caught,
-          "Error notifying ProvisionListener %s of %s.%n Reason: %s",
+          "Error notifying ProvisionListener %s of %s.\n Reason: %s",
           listener,
           binding.getKey(),
           caught);

File: core/src/com/google/inject/internal/ScopeNotFoundError.java
Patch:
@@ -33,7 +33,7 @@ protected void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter form
     sourcesSet.add(getSources());
     mergeableErrors.stream().map(ErrorDetail::getSources).forEach(sourcesSet::add);
 
-    formatter.format("%n%s%n", "Used at:");
+    formatter.format("\n%s\n", "Used at:");
     int sourceListIndex = 1;
     for (List<Object> sources : sourcesSet) {
       ErrorFormatter.formatSources(sourceListIndex++, Lists.reverse(sources), formatter);

File: core/src/com/google/inject/spi/BindingSourceRestriction.java
Patch:
@@ -69,7 +69,7 @@ public static Optional<String> getMissingImplementationSuggestion(
     }
     return Optional.of(
         String.format(
-            "%nHint: This key is restricted and cannot be bound directly. Restriction explanation:"
+            "\nHint: This key is restricted and cannot be bound directly. Restriction explanation:"
                 + " %s",
             restriction.explanation()));
   }

File: core/src/com/google/inject/spi/ErrorDetail.java
Patch:
@@ -60,13 +60,13 @@ public boolean isMergeable(ErrorDetail<?> otherError) {
    */
   public final void format(int index, List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
     String id = getErrorIdentifier().map(s -> "[" + Messages.redBold(s) + "]: ").orElse("");
-    formatter.format("%s) %s%s%n", index, id, getMessage());
+    formatter.format("%s) %s%s\n", index, id, getMessage());
     formatDetail(mergeableErrors, formatter);
     // TODO(b/151482394): Output potiential fixes for the error
     Optional<String> learnMoreLink = getLearnMoreLink();
     if (learnMoreLink.isPresent()) {
-      formatter.format("%n%s%n", Messages.bold("Learn more:"));
-      formatter.format("  %s%n", Messages.underline(learnMoreLink.get()));
+      formatter.format("\n%s\n", Messages.bold("Learn more:"));
+      formatter.format("  %s\n", Messages.underline(learnMoreLink.get()));
     }
   }
 

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -342,9 +342,9 @@ public Void visit(ScopeBinding scopeBinding) {
               StringBuilder sb =
                   new StringBuilder(
                       "The scope for @%s is bound directly and cannot be overridden.");
-              sb.append("%n     original binding at " + Errors.convert(scopeBinding.getSource()));
+              sb.append("\n     original binding at " + Errors.convert(scopeBinding.getSource()));
               for (Object usedSource : usedSources) {
-                sb.append("%n     bound directly at " + Errors.convert(usedSource) + "");
+                sb.append("\n     bound directly at " + Errors.convert(usedSource) + "");
               }
               binder
                   .withSource(overideBinding.getSource())

File: core/test/com/google/inject/internal/MessagesTest.java
Patch:
@@ -23,7 +23,7 @@ static class ExampleErrorDetail extends ErrorDetail<ExampleErrorDetail> {
 
     @Override
     public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
-      formatter.format("Duplicate count: %s%n", mergeableErrors.size() + 1);
+      formatter.format("Duplicate count: %s\n", mergeableErrors.size() + 1);
     }
 
     @Override

File: core/src/com/google/inject/PrivateModule.java
Patch:
@@ -137,7 +137,7 @@ protected final AnnotatedElementBuilder expose(TypeLiteral<?> type) {
   // everything below is copied from AbstractModule
 
   /** Returns the current binder. */
-  protected final PrivateBinder binder() {
+  protected PrivateBinder binder() {
     checkState(binder != null, "The binder can only be used inside configure()");
     return binder;
   }

File: extensions/struts2/test/com/google/inject/struts2/Struts2FactoryTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.struts2;
 
-import org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter;
 import com.google.inject.AbstractModule;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
@@ -25,7 +24,9 @@
 import com.google.inject.servlet.GuiceServletContextListener;
 import com.google.inject.servlet.ServletModule;
 import java.util.Date;
+import javax.inject.Singleton;
 import junit.framework.TestCase;
+import org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter;
 
 /**
  * Test for Struts2Factory
@@ -52,8 +53,7 @@ protected Injector getInjector() {
             @Override
             protected void configureServlets() {
               // Struts 2 setup
-              bind(StrutsPrepareAndExecuteFilter.class)
-                  .in(com.google.inject.Singleton.class);
+              bind(StrutsPrepareAndExecuteFilter.class).in(Singleton.class);
               filter("/*").through(StrutsPrepareAndExecuteFilter.class);
             }
           },

File: extensions/servlet/test/com/google/inject/servlet/ServletDefinitionPathsTest.java
Patch:
@@ -136,6 +136,9 @@ public final void testPathInfoWithServletStyleMatching() throws IOException, Ser
         "/path", "/*", "/a file with spaces in name.html", "");
     pathInfoWithServletStyleMatching(
         "/path/Tam%C3%A1s%20nem%20m%C3%A1s.html", "/path", "/*", "/Tams nem ms.html", "");
+
+    // see https://github.com/google/guice/issues/1655
+    pathInfoWithServletStyleMatching("/index.html", null, "/*", "/index.html", "");
   }
 
   private void pathInfoWithServletStyleMatching(

File: core/src/com/google/inject/multibindings/ProvidesIntoSet.java
Patch:
@@ -32,7 +32,7 @@
  * <pre>
  * {@literal @}ProvidesIntoSet
  * {@literal @}Named("urls")
- * String provideFooUrl(FooManager fm) { returm fm.getUrl(); }
+ * String provideFooUrl(FooManager fm) { return fm.getUrl(); }
  *
  * {@literal @}ProvidesIntoSet
  * {@literal @}Named("urls")

File: core/src/com/google/inject/Key.java
Patch:
@@ -513,7 +513,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-      return '@' + annotationType.getName();
+      return Annotations.annotationInstanceClassString(annotationType, /* includePackage= */ true);
     }
   }
 }

File: core/test/com/google/inject/spi/ModuleAnnotatedMethodScannerTest.java
Patch:
@@ -36,6 +36,7 @@
 import com.google.inject.Module;
 import com.google.inject.PrivateModule;
 import com.google.inject.Provides;
+import com.google.inject.internal.Annotations;
 import com.google.inject.internal.ProviderMethodsModule;
 import com.google.inject.internal.util.StackTraceElements;
 import com.google.inject.name.Named;
@@ -159,8 +160,7 @@ String foo() {
 
   private String methodName(Class<? extends Annotation> annotation, String method, Object container)
       throws Exception {
-    return "@"
-        + annotation.getName()
+    return Annotations.annotationInstanceClassString(annotation, /* includePackage= */ true)
         + " "
         + StackTraceElements.forMember(container.getClass().getDeclaredMethod(method));
   }

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -64,6 +64,7 @@ public static Test suite() {
     suite.addTestSuite(EagerSingletonTest.class);
     suite.addTestSuite(GenericInjectionTest.class);
     suite.addTestSuite(ImplicitBindingTest.class);
+    suite.addTestSuite(ImplicitBindingJdkPackagePrivateTest.class);
     suite.addTestSuite(InjectorTest.class);
     suite.addTestSuite(JitBindingsTest.class);
     suite.addTestSuite(Java8LanguageFeatureBindingTest.class);

File: core/test/com/google/inject/BindingTest.java
Patch:
@@ -357,8 +357,8 @@ protected void configure() {
             });
 
     D d = (D) injector.getInstance(Object.class);
-    d.hashCode();
-    d.hashCode();
+    int unused = d.hashCode();
+    int unused2 = d.hashCode();
     assertEquals(2, count.get());
   }
 

File: core/test/com/google/inject/InjectorTest.java
Patch:
@@ -47,8 +47,8 @@ public class InjectorTest extends TestCase {
 
   public void testToStringDoesNotInfinitelyRecurse() {
     Injector injector = Guice.createInjector(Stage.TOOL);
-    injector.toString();
-    injector.getBinding(Injector.class).toString();
+    String unused = injector.toString();
+    String unused2 = injector.getBinding(Injector.class).toString();
   }
 
   public void testProviderMethods() throws CreationException {

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProviderTest.java
Patch:
@@ -601,7 +601,7 @@ protected void configure() {
     }
   }
 
-  @SuppressWarnings("SelfEquals")
+  @SuppressWarnings({"SelfEquals", "ReturnValueIgnored"})
   public void testMethodsDeclaredInObject() {
     Injector injector =
         Guice.createInjector(

File: core/src/com/google/inject/AbstractModule.java
Patch:
@@ -139,9 +139,7 @@ protected void requestStaticInjection(Class<?>... types) {
     binder().requestStaticInjection(types);
   }
 
-  /**
-   * @see {@link Binder#bindInterceptor(com.google.inject.matcher.Matcher, MethodInterceptor[])}.
-   */
+  /** @see Binder#bindInterceptor */
   protected void bindInterceptor(
       Matcher<? super Class<?>> classMatcher,
       Matcher<? super Method> methodMatcher,

File: core/src/com/google/inject/internal/DelayedInitialize.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * Something that needs some delayed initialization, typically a binding or internal factory that
- * needs to be created & put into the bindings map & then initialized later.
+ * needs to be created; put into the bindings map and then initialized later.
  *
  * @author sameb@google.com (Sam Berlin)
  */

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -108,7 +108,7 @@ enum JitLimitation {
     NO_JIT,
     /** allows existing just in time bindings, but does not allow new ones */
     EXISTING_JIT,
-    /** allows existing just in time bindings & allows new ones to be created */
+    /** allows existing just in time bindings and allows new ones to be created */
     NEW_OR_EXISTING_JIT,
   }
 
@@ -368,7 +368,7 @@ private <T> BindingImpl<Provider<T>> createSyntheticProviderBinding(
     return new SyntheticProviderBindingImpl<T>(this, key, delegate);
   }
 
-  /** A framework-created JIT Provider<T> binding. */
+  /** A framework-created JIT {@code Provider<T>} binding. */
   private static class SyntheticProviderBindingImpl<T> extends BindingImpl<Provider<T>>
       implements ProviderBinding<Provider<T>>, HasDependencies {
     final BindingImpl<T> providedBinding;
@@ -618,7 +618,7 @@ <T> void initializeJitBinding(BindingImpl<T> binding, Errors errors) throws Erro
 
   /**
    * Iterates through the binding's dependencies to clean up any stray bindings that were leftover
-   * from a failed JIT binding. This is required because the bindings are eagerly & optimistically
+   * from a failed JIT binding. This is required because the bindings are eagerly and optimistically
    * added to allow circular dependency support, so dependencies may pass where they should have
    * failed.
    */

File: core/src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -55,8 +55,8 @@
  * similarly, but using {@link PrivateElements} instead of modules.
  *
  * <p>It is necessary to create the root and child injectors in a single batch because there can be
- * bidirectional parent <-> child injector dependencies that require the entire tree of injectors to
- * be initialized together in the {@link InternalInjectorCreator}.
+ * bidirectional parent &lt;-&gt; child injector dependencies that require the entire tree of
+ * injectors to be initialized together in the {@link InternalInjectorCreator}.
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: core/src/com/google/inject/internal/ProcessedBindingData.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.List;
 
 /**
- * Keeps track of creation listeners & uninitialized bindings, so they can be processed after
+ * Keeps track of creation listeners and uninitialized bindings, so they can be processed after
  * bindings are recorded.
  *
  * @author sameb@google.com (Sam Berlin)

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -20,8 +20,8 @@
 
 import com.google.inject.internal.ProvisionListenerStackCallback.ProvisionCallback;
 import com.google.inject.spi.Dependency;
-import javax.inject.Provider;
 import javax.annotation.Nullable;
+import javax.inject.Provider;
 
 /**
  * Base class for InternalFactories that are used by Providers, to handle circular dependencies.
@@ -75,7 +75,7 @@ public T call() throws InternalProvisionException {
   }
 
   /**
-   * Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as
+   * Provisions a new instance. Subclasses should override this to catch exceptions and rethrow as
    * ErrorsExceptions.
    */
   protected T provision(

File: core/src/com/google/inject/internal/ProvisionListenerCallbackStore.java
Patch:
@@ -110,7 +110,7 @@ private <T> ProvisionListenerStackCallback<T> create(Binding<T> binding) {
     return new ProvisionListenerStackCallback<T>(binding, listeners);
   }
 
-  /** A struct that holds key & binding but uses just key for equality/hashcode. */
+  /** A struct that holds key and binding but uses just key for equality/hashcode. */
   private static class KeyBinding {
     final Key<?> key;
     final Binding<?> binding;

File: core/src/com/google/inject/internal/RealMultibinder.java
Patch:
@@ -214,8 +214,8 @@ public int hashCode() {
 
   /**
    * Provider instance implementation that provides the actual set of values. This is parameterized
-   * so it can be used to supply a Set<T> and Set<? extends T>, the latter being useful for Kotlin
-   * support.
+   * so it can be used to supply a {@code Set<T>} and {@code Set<? extends T>}, the latter being
+   * useful for Kotlin support.
    */
   private static final class RealMultibinderProvider<T> extends BaseFactory<T, Set<T>> {
     List<Binding<T>> bindings;

File: core/src/com/google/inject/spi/ErrorDetail.java
Patch:
@@ -52,6 +52,7 @@ public boolean isMergeable(ErrorDetail<?> otherError) {
    *   <li>Details about the error such as the source of the error
    *   <li>Hints for fixing the error if available
    *   <li>Link to the documentation on this error in greater detail
+   * </ul>
    *
    * @param index index for this error
    * @param mergeableErrors list of errors that are mergeable with this error

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -814,8 +814,8 @@ private static Method[] getDeclaredMethods(TypeLiteral<?> type) {
   /**
    * Returns true if the method is eligible to be injected. This is different than {@link
    * #isValidMethod}, because ineligibility will not drop a method from being injected if a
-   * superclass was eligible & valid. Bridge & synthetic methods are excluded from eligibility for
-   * two reasons:
+   * superclass was eligible and valid. Bridge and synthetic methods are excluded from eligibility
+   * for two reasons:
    *
    * <p>Prior to Java8, javac would generate these methods in subclasses without annotations, which
    * means this would accidentally stop injecting a method annotated with {@link

File: core/src/com/google/inject/spi/TypeListenerBinding.java
Patch:
@@ -24,8 +24,9 @@
  * Binds types (picked using a Matcher) to an type listener. Registrations are created explicitly in
  * a module using {@link com.google.inject.Binder#bindListener(Matcher, TypeListener)} statements:
  *
- * <pre>
- *     register(only(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {}), listener);</pre>
+ * <pre>{@code
+ * register(only(new TypeLiteral<PaymentService<CreditCard>>() {}), listener);
+ * }</pre>
  *
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: core/test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -122,7 +122,7 @@ public void go() {}
    * dependencies. And so we can successfully create a binding for B. But later, when the binding
    * for A ultimately fails, we need to clean up the dependent binding for B.
    *
-   * <p>The test loops through linked bindings & bindings with constructor & member injections, to
+   * <p>The test loops through linked bindings & bindings with constructor and member injections, to
    * make sure that all are cleaned up and traversed. It also makes sure we don't touch explicit
    * bindings.
    */

File: core/test/com/google/inject/internal/SpiUtils.java
Patch:
@@ -82,7 +82,7 @@
 import java.util.Set;
 
 /**
- * Utilities for testing the Multibinder & MapBinder extension SPI.
+ * Utilities for testing the Multibinder and MapBinder extension SPI.
  *
  * @author sameb@google.com (Sam Berlin)
  */

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -118,7 +118,7 @@
  *     // excluding .implement for Shipment means the implementation class
  *     // will be 'Shipment' itself, which is legal if it's not an interface.
  *     .implement(Receipt.class, RealReceipt.class)
- *     .build(OrderFactory.class));</pre>
+ *     .build(OrderFactory.class));
  *
  * </pre>
  *

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -702,7 +702,7 @@ private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) {
 
   /**
    * Returns true if all dependencies are suitable for the optimized version of AssistedInject. The
-   * optimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if
+   * optimized version caches the binding and uses a ThreadLocal Provider, so can only be applied if
    * the assisted bindings are immediately provided. This looks for hints that the values may be
    * lazily retrieved, by looking for injections of Injector or a Provider for the assisted values.
    */

File: extensions/persist/src/com/google/inject/persist/Transactional.java
Patch:
@@ -48,7 +48,7 @@
   Class<? extends Exception>[] rollbackOn() default RuntimeException.class;
 
   /**
-   * A list of exceptions to <b>not<b> rollback on. A caveat to the rollbackOn clause. The
+   * A list of exceptions to <b>not</b> rollback on. A caveat to the rollbackOn clause. The
    * disjunction of rollbackOn and ignore represents the list of exceptions that will trigger a
    * rollback. The complement of rollbackOn and the universal set plus any exceptions in the ignore
    * set represents the list of exceptions that will trigger a commit. Note that ignore exceptions

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -66,6 +66,7 @@ public static Test suite() {
     suite.addTestSuite(ImplicitBindingTest.class);
     suite.addTestSuite(InjectorTest.class);
     suite.addTestSuite(JitBindingsTest.class);
+    suite.addTestSuite(Java8LanguageFeatureBindingTest.class);
     suite.addTestSuite(KeyTest.class);
     suite.addTestSuite(LoggerInjectionTest.class);
     suite.addTestSuite(MembersInjectorTest.class);

File: extensions/assistedinject/test/com/google/inject/assistedinject/StaticInterfaceMethodsTest.java
Patch:
@@ -14,14 +14,12 @@
  * limitations under the License.
  */
 
-package com.google.inject.jdk8;
+package com.google.inject.assistedinject;
 
 import com.google.inject.AbstractModule;
 import com.google.inject.Guice;
 import com.google.inject.Inject;
 import com.google.inject.Injector;
-import com.google.inject.assistedinject.Assisted;
-import com.google.inject.assistedinject.FactoryModuleBuilder;
 import junit.framework.TestCase;
 
 /**

File: core/src/com/google/inject/Key.java
Patch:
@@ -208,7 +208,7 @@ public final String toString() {
     // method.
     String local = toString;
     if (local == null) {
-      local = "Key[type=" + typeLiteral + ", annotation=" + annotationStrategy + "]";
+      local = "Key[type=" + typeLiteral + ", annotation=" + annotationStrategy + ']';
       toString = local;
     }
     return local;
@@ -513,7 +513,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-      return "@" + annotationType.getName();
+      return '@' + annotationType.getName();
     }
   }
 }

File: core/src/com/google/inject/internal/Annotations.java
Patch:
@@ -158,7 +158,7 @@ private static int annotationHashCode(
   /** Implements {@link Annotation#toString}. */
   private static String annotationToString(
       Class<? extends Annotation> type, Map<String, Object> members) throws Exception {
-    StringBuilder sb = new StringBuilder().append("@").append(type.getName()).append("(");
+    StringBuilder sb = new StringBuilder().append('@').append(type.getName()).append('(');
     JOINER.appendTo(
         sb,
         Maps.transformValues(
@@ -167,7 +167,7 @@ private static String annotationToString(
               String s = Arrays.deepToString(new Object[] {arg});
               return s.substring(1, s.length() - 1); // cut off brackets
             }));
-    return sb.append(")").toString();
+    return sb.append(')').toString();
   }
 
   /** Returns true if the given annotation is retained at runtime. */
@@ -413,7 +413,7 @@ public static String nameOf(Key<?> key) {
     if (annotation != null && !isMarker(annotationType)) {
       return key.getAnnotation().toString();
     } else if (key.getAnnotationType() != null) {
-      return "@" + key.getAnnotationType().getName();
+      return '@' + key.getAnnotationType().getName();
     } else {
       return "";
     }

File: core/src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -448,11 +448,11 @@ public String toString() {
         return stringBuilder.toString();
       }
 
-      stringBuilder.append("<").append(typeToString(typeArguments[0]));
+      stringBuilder.append('<').append(typeToString(typeArguments[0]));
       for (int i = 1; i < typeArguments.length; i++) {
         stringBuilder.append(", ").append(typeToString(typeArguments[i]));
       }
-      return stringBuilder.append(">").toString();
+      return stringBuilder.append('>').toString();
     }
 
     private static void ensureOwnerType(Type ownerType, Type rawType) {

File: core/src/com/google/inject/internal/UniqueAnnotations.java
Patch:
@@ -51,11 +51,11 @@ public Class<? extends Annotation> annotationType() {
 
       @Override
       public String toString() {
-        return "@"
+        return '@'
             + Internal.class.getName()
-            + "("
+            + '('
             + Annotations.memberValueString("value", value)
-            + ")";
+            + ')';
       }
 
       @Override

File: core/src/com/google/inject/internal/util/Classes.java
Patch:
@@ -44,9 +44,9 @@ public static String toString(Member member) {
     Class<? extends Member> memberType = Classes.memberType(member);
 
     if (memberType == Method.class) {
-      return member.getDeclaringClass().getName() + "." + member.getName() + "()";
+      return member.getDeclaringClass().getName() + '.' + member.getName() + "()";
     } else if (memberType == Field.class) {
-      return member.getDeclaringClass().getName() + "." + member.getName();
+      return member.getDeclaringClass().getName() + '.' + member.getName();
     } else if (memberType == Constructor.class) {
       return member.getDeclaringClass().getName() + ".<init>()";
     } else {

File: core/src/com/google/inject/name/NamedImpl.java
Patch:
@@ -53,7 +53,7 @@ public boolean equals(Object o) {
 
   @Override
   public String toString() {
-    return "@" + Named.class.getName() + "(" + Annotations.memberValueString("value", value) + ")";
+    return '@' + Named.class.getName() + '(' + Annotations.memberValueString("value", value) + ')';
   }
 
   @Override

File: core/src/com/google/inject/spi/Dependency.java
Patch:
@@ -115,9 +115,9 @@ public String toString() {
     StringBuilder builder = new StringBuilder();
     builder.append(key);
     if (injectionPoint != null) {
-      builder.append("@").append(injectionPoint);
+      builder.append('@').append(injectionPoint);
       if (parameterIndex != -1) {
-        builder.append("[").append(parameterIndex).append("]");
+        builder.append('[').append(parameterIndex).append(']');
       }
     }
     return builder.toString();

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -41,7 +41,6 @@
 import com.google.inject.spi.ScopeBinding;
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -231,7 +230,7 @@ public void configure() {
       }
 
       final Binder binder = baseBinder.skipSources(this.getClass());
-      final LinkedHashSet<Element> elements = new LinkedHashSet<>(baseElements);
+      final ImmutableSet<Element> elements = ImmutableSet.copyOf(baseElements);
       final Module scannersModule = extractScanners(elements);
       final List<Element> overrideElements =
           Elements.getElements(

File: extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java
Patch:
@@ -64,7 +64,7 @@ public String toString() {
       result.append("@Assisted ");
     }
     if (bindingAnnotation != null) {
-      result.append(bindingAnnotation).append(" ");
+      result.append(bindingAnnotation).append(' ');
     }
     return result.append(type).toString();
   }

File: extensions/servlet/test/com/google/inject/servlet/ServletUtilsTest.java
Patch:
@@ -54,9 +54,8 @@ public void testNormalizePath() {
     assertEquals("foo+bar", ServletUtils.normalizePath("foo+bar"));
     assertEquals("foo%20bar", ServletUtils.normalizePath("foo bar"));
     assertEquals("foo%25-bar", ServletUtils.normalizePath("foo%-bar"));
-    // TODO(b/5470035): fix this buggy behavior
-    assertEquals("foo%0Bar", ServletUtils.normalizePath("foo%+bar"));
-    assertEquals("foo%00bar", ServletUtils.normalizePath("foo%-0bar"));
+    assertEquals("foo%25+bar", ServletUtils.normalizePath("foo%+bar"));
+    assertEquals("foo%25-0bar", ServletUtils.normalizePath("foo%-0bar"));
   }
 
   private String getContextRelativePath(String contextPath, String requestPath) {

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -845,7 +845,8 @@ private <T> BindingImpl<T> createJustInTimeBindingRecursive(
             jitDisabled,
             parent.options.jitDisabled ? JitLimitation.NO_JIT : jitType);
       } catch (ErrorsException ignored) {
-        // TODO(b/160910914): Why are ErrorsExceptions ignored?
+        // If JIT binding creation failed in parent injector(s), create the JIT binding in this
+        // injector instead.
       }
     }
 

File: extensions/testlib/src/com/google/inject/testing/fieldbinder/BoundFieldModule.java
Patch:
@@ -350,6 +350,7 @@ private Optional<TypeLiteral<?>> computeNaturalFieldType() {
     private boolean allowsNull() {
       return !isTransparentProvider(fieldType.getRawType())
           && (Nullability.hasNullableAnnotation(field.getAnnotations())
+              || Nullability.hasNullableAnnotation(field.getAnnotatedType().getAnnotations())
               || KotlinSupport.getInstance().isNullable(field));
     }
   }

File: core/src/com/google/inject/internal/ProviderMethodsModule.java
Patch:
@@ -295,15 +295,17 @@ private <T> ProviderMethod<T> createProviderMethod(
     @SuppressWarnings("unchecked") // Define T as the method's return type.
     TypeLiteral<T> returnType = (TypeLiteral<T>) typeLiteral.getReturnType(method);
     Key<T> key = getKey(errors, returnType, method, method.getAnnotations());
+    boolean prepareMethodError = false;
     try {
       key = scanner.prepareMethod(binder, annotation, key, point);
     } catch (Throwable t) {
+      prepareMethodError = true;
       binder.addError(t);
     }
 
     if (Modifier.isAbstract(method.getModifiers())) {
       checkState(
-          key == null,
+          prepareMethodError || key == null,
           "%s returned a non-null key (%s) for %s. prepareMethod() must return null for abstract"
               + " methods",
           scanner,

File: extensions/dagger-adapter/src/com/google/inject/daggeradapter/DaggerAdapter.java
Patch:
@@ -60,7 +60,6 @@
  *
  * <ul>
  *   <li>Dagger provider methods have a "SET_VALUES" provision mode not supported by Guice.
- *   <li>MapBindings are not yet implemented (pending).
  *   <li>Be careful about stateful modules. In contrast to Dagger (where components are expected to
  *       be recreated on-demand with new Module instances), Guice typically has a single injector
  *       with a long lifetime, so your module instance will be used throughout the lifetime of the

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -377,9 +377,8 @@ public TypeLiteral<?> getImplementationType() {
             && userLookups == null
             && !Modifier.isPublic(factory.getClass().getModifiers())) {
           warnedAboutUserLookups = true;
-          // TODO(b/179303203): Upgrade this back to WARNING level
           logger.log(
-              Level.INFO,
+              Level.WARNING,
               "AssistedInject factory {0} is non-public and has javac-generated default methods. "
                   + " Please pass a `MethodHandles.lookups()` with"
                   + " FactoryModuleBuilder.withLookups when using this factory so that Guice can"

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -205,7 +205,7 @@ public static <F> Provider<F> newFactory(
         throw new ConfigurationException(e.getErrors().getMessages());
       }
 
-      return new FactoryProvider2<F>(Key.get(factoryType), collector);
+      return new FactoryProvider2<F>(Key.get(factoryType), collector, /* userLookups= */ null);
     }
   }
 

File: extensions/testlib/src/com/google/inject/testing/fieldbinder/BoundFieldModule.java
Patch:
@@ -348,7 +348,6 @@ private Optional<TypeLiteral<?>> computeNaturalFieldType() {
     private boolean allowsNull() {
       return !isTransparentProvider(fieldType.getRawType())
           && (Nullability.hasNullableAnnotation(field.getAnnotations())
-              || Nullability.hasNullableAnnotation(field.getAnnotatedType().getAnnotations())
               || KotlinSupport.getInstance().isNullable(field));
     }
   }

File: extensions/testlib/src/com/google/inject/testing/fieldbinder/BoundFieldModule.java
Patch:
@@ -348,6 +348,7 @@ private Optional<TypeLiteral<?>> computeNaturalFieldType() {
     private boolean allowsNull() {
       return !isTransparentProvider(fieldType.getRawType())
           && (Nullability.hasNullableAnnotation(field.getAnnotations())
+              || Nullability.hasNullableAnnotation(field.getAnnotatedType().getAnnotations())
               || KotlinSupport.getInstance().isNullable(field));
     }
   }

File: core/src/com/google/inject/internal/ErrorId.java
Patch:
@@ -5,6 +5,7 @@ public enum ErrorId {
   AMBIGUOUS_TYPE_CONVERSION,
   AOP_DISABLED,
   AT_INJECT_REQUIRED,
+  AT_TARGET_IS_MISSING_PARAMETER,
   BINDING_ALREADY_SET,
   BINDING_TO_GUICE_TYPE,
   BINDING_TO_PROVIDER,

File: core/src/com/google/inject/internal/KotlinSupportInterface.java
Patch:
@@ -24,4 +24,7 @@ public interface KotlinSupportInterface {
    * Returns a {@link Predicate} that says whether the method's i-th parameter is Kotlin-nullable.
    */
   Predicate<Integer> getIsParameterKotlinNullablePredicate(Method method);
+
+  /** Checks for any errors on the constructor's parameters's annotations. */
+  void checkConstructorParameterAnnotations(Constructor<?> constructor, Errors errors);
 }

File: core/src/com/google/inject/internal/Messages.java
Patch:
@@ -182,7 +182,7 @@ private static Object appendModules(Object source, ElementSource elementSource)
     if (modules.length() == 0) {
       return source;
     } else {
-      return source + modules;
+      return source + " (installed by: " + modules + ")";
     }
   }
 

File: core/src/com/google/inject/internal/MissingConstructorError.java
Patch:
@@ -57,8 +57,8 @@ protected void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter form
       } else if (Modifier.isPrivate(noArgConstructor.getModifiers())
           && !Modifier.isPrivate(rawType.getModifiers())) {
         formatter.format(
-            "%s has a private no-arg constructor but it's not private. Guice can only use private"
-                + " no-arg constructor if it is defined in a private class.%n",
+            "%s has a private no-arg constructor but the class is not private. Guice can only use"
+                + " a private no-arg constructor if it is defined in a private class.%n",
             rawType);
       }
     }

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -125,7 +125,7 @@ public String getInitParameter(String s) {
           }
 
           @Override
-          public Enumeration<?> getInitParameterNames() {
+          public Enumeration<String> getInitParameterNames() {
             return Iterators.asEnumeration(initParams.keySet().iterator());
           }
         });

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -134,7 +134,7 @@ public String getInitParameter(String s) {
           }
 
           @Override
-          public Enumeration<?> getInitParameterNames() {
+          public Enumeration<String> getInitParameterNames() {
             return Iterators.asEnumeration(initParams.keySet().iterator());
           }
         });

File: extensions/servlet/test/com/google/inject/servlet/FilterDefinitionTest.java
Patch:
@@ -76,9 +76,9 @@ public final void testFilterInitAndConfig() throws ServletException {
     assertEquals(contextName, filterConfig.getServletContext().getServletContextName());
     assertEquals(filterConfig.getFilterName(), Key.get(Filter.class).toString());
 
-    final Enumeration<?> names = filterConfig.getInitParameterNames();
+    final Enumeration<String> names = filterConfig.getInitParameterNames();
     while (names.hasMoreElements()) {
-      String name = (String) names.nextElement();
+      String name = names.nextElement();
 
       assertTrue(initParams.containsKey(name));
       assertEquals(filterConfig.getInitParameter(name), initParams.get(name));

File: extensions/servlet/test/com/google/inject/servlet/ServletDefinitionTest.java
Patch:
@@ -88,9 +88,9 @@ public final void testServletInitAndConfig() throws ServletException {
     assertEquals(Key.get(HttpServlet.class).toString(), mockServlet.getServletName());
 
     final ServletConfig servletConfig = mockServlet.getServletConfig();
-    final Enumeration<?> names = servletConfig.getInitParameterNames();
+    final Enumeration<String> names = servletConfig.getInitParameterNames();
     while (names.hasMoreElements()) {
-      String name = (String) names.nextElement();
+      String name = names.nextElement();
 
       assertTrue(initParams.containsKey(name));
       assertEquals(initParams.get(name), servletConfig.getInitParameter(name));

File: extensions/testlib/test/com/google/inject/testing/fieldbinder/BoundFieldModuleTest.java
Patch:
@@ -1043,7 +1043,7 @@ class Bindings {
     Bindings bindings = new Bindings();
 
     Injector injector =
-        Guice.createInjector(new @FooPermit BoundFieldModule.WithPermits(bindings) {});
+        Guice.createInjector(new BoundFieldModule.@FooPermit WithPermits(bindings) {});
 
     assertEquals((Integer) bindings.foo, injector.getInstance(Key.get(Integer.class, Foo.class)));
   }

File: core/src/com/google/inject/internal/InternalFlags.java
Patch:
@@ -166,7 +166,7 @@ public static boolean isBytecodeGenEnabled() {
   }
 
   public static boolean enableExperimentalErrorMessages() {
-    return false;
+    return true;
   }
 
   public static boolean enableColorizeErrorMessages() {

File: core/test/com/google/inject/Asserts.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.inject.internal.InternalFlags.getIncludeStackTraceOption;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
@@ -145,7 +146,7 @@ public static void assertEqualWhenReserialized(Object object) throws IOException
   /** Fails unless {@code object} has the same toString value when reserialized. */
   public static void assertSimilarWhenReserialized(Object object) throws IOException {
     Object reserialized = reserialize(object);
-    assertEquals(object.toString(), reserialized.toString());
+    assertThat(reserialized.toString()).isEqualTo(object.toString());
   }
 
   public static <E> E reserialize(E original) throws IOException {

File: core/test/com/google/inject/KeyTest.java
Patch:
@@ -220,8 +220,7 @@ public void testCannotCreateKeysWithTypeVariables() throws NoSuchMethodException
       Key.get(listOfT);
       fail("Guice should not allow keys for java.util.List<T>");
     } catch (ConfigurationException e) {
-      assertContains(
-          e.getMessage(), "java.util.List<T> cannot be used as a key; It is not fully specified.");
+      assertContains(e.getMessage(), "List<T> cannot be used as a key; It is not fully specified.");
     }
 
     TypeVariable<?> tType = (TypeVariable) listOfTType.getActualTypeArguments()[0];

File: core/test/com/google/inject/LoggerInjectionTest.java
Patch:
@@ -71,8 +71,7 @@ protected void configure() {
           });
       fail();
     } catch (CreationException expected) {
-      assertContains(
-          expected.getMessage(), "A binding to java.util.logging.Logger was already configured");
+      assertContains(expected.getMessage(), "Logger was bound multiple times.");
     }
   }
 }

File: core/test/com/google/inject/TypeLiteralInjectionTest.java
Patch:
@@ -76,9 +76,7 @@ public void testInjectTypeLiteralWithRawTypes() {
     } catch (ConfigurationException expected) {
       assertContains(
           expected.getMessage(),
-          TypeLiteral.class.getName()
-              + "<java.util.List<T>> "
-              + "cannot be used as a key; It is not fully specified.");
+          "TypeLiteral<List<T>> cannot be used as a key; It is not fully specified.");
     }
   }
 

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/ModuleIncludesTest.java
Patch:
@@ -95,7 +95,7 @@ public void testConflictingModuleInstances() {
       assertThat(e)
           .hasMessageThat()
           .contains(
-              "Duplicate module instances provided for " + ModuleWithIdentity.class.getName());
+              "Duplicate module instances provided for ModuleIncludesTest$ModuleWithIdentity:");
     }
   }
 

File: core/src/com/google/inject/internal/InternalFlags.java
Patch:
@@ -166,7 +166,7 @@ public static boolean isBytecodeGenEnabled() {
   }
 
   public static boolean enableExperimentalErrorMessages() {
-    return false;
+    return true;
   }
 
   public static boolean enableColorizeErrorMessages() {

File: core/test/com/google/inject/Asserts.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.inject.internal.InternalFlags.getIncludeStackTraceOption;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
@@ -145,7 +146,7 @@ public static void assertEqualWhenReserialized(Object object) throws IOException
   /** Fails unless {@code object} has the same toString value when reserialized. */
   public static void assertSimilarWhenReserialized(Object object) throws IOException {
     Object reserialized = reserialize(object);
-    assertEquals(object.toString(), reserialized.toString());
+    assertThat(reserialized.toString()).isEqualTo(object.toString());
   }
 
   public static <E> E reserialize(E original) throws IOException {

File: core/test/com/google/inject/KeyTest.java
Patch:
@@ -220,8 +220,7 @@ public void testCannotCreateKeysWithTypeVariables() throws NoSuchMethodException
       Key.get(listOfT);
       fail("Guice should not allow keys for java.util.List<T>");
     } catch (ConfigurationException e) {
-      assertContains(
-          e.getMessage(), "java.util.List<T> cannot be used as a key; It is not fully specified.");
+      assertContains(e.getMessage(), "List<T> cannot be used as a key; It is not fully specified.");
     }
 
     TypeVariable<?> tType = (TypeVariable) listOfTType.getActualTypeArguments()[0];

File: core/test/com/google/inject/LoggerInjectionTest.java
Patch:
@@ -71,8 +71,7 @@ protected void configure() {
           });
       fail();
     } catch (CreationException expected) {
-      assertContains(
-          expected.getMessage(), "A binding to java.util.logging.Logger was already configured");
+      assertContains(expected.getMessage(), "Logger was bound multiple times.");
     }
   }
 }

File: core/test/com/google/inject/TypeLiteralInjectionTest.java
Patch:
@@ -76,9 +76,7 @@ public void testInjectTypeLiteralWithRawTypes() {
     } catch (ConfigurationException expected) {
       assertContains(
           expected.getMessage(),
-          TypeLiteral.class.getName()
-              + "<java.util.List<T>> "
-              + "cannot be used as a key; It is not fully specified.");
+          "TypeLiteral<List<T>> cannot be used as a key; It is not fully specified.");
     }
   }
 

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/ModuleIncludesTest.java
Patch:
@@ -95,7 +95,7 @@ public void testConflictingModuleInstances() {
       assertThat(e)
           .hasMessageThat()
           .contains(
-              "Duplicate module instances provided for " + ModuleWithIdentity.class.getName());
+              "Duplicate module instances provided for ModuleIncludesTest$ModuleWithIdentity:");
     }
   }
 

File: core/test/com/google/inject/IntegrationTest.java
Patch:
@@ -62,7 +62,7 @@ protected void configure() {
           assertThrows(CreationException.class, () -> Guice.createInjector(module));
       assertThat(exception)
           .hasMessageThat()
-          .contains("Binding interceptor is not supported when AOP is disabled.");
+          .contains("Binding interceptor is not supported when bytecode generation is disabled.");
     }
   }
 

File: core/src/com/google/inject/internal/DuplicateMapKeyError.java
Patch:
@@ -30,7 +30,7 @@ protected final void formatDetail(List<ErrorDetail<?>> others, Formatter formatt
     formatter.format("%n%s%n", Messages.bold("Duplicates:"));
 
     for (Map.Entry<K, Collection<Binding<V>>> entry : duplicates.asMap().entrySet()) {
-      formatter.format("  Key: %s%n", Messages.redBold(entry.getKey().toString()));
+      formatter.format("  Key: \"%s\"%n", Messages.redBold(entry.getKey().toString()));
       formatter.format("  Bound at:%n");
       int index = 1;
       for (Binding<V> binding : entry.getValue()) {

File: core/src/com/google/inject/internal/PackageNameCompressor.java
Patch:
@@ -58,7 +58,6 @@ final class PackageNameCompressor {
   // TODO(erichang): Consider validating this regex by also passing in all of the known types from
   // keys, module names, component names, etc and checking against that list. This may have some
   // extra complications with taking apart types like List<Foo> to get the inner class names.
-  // TODO(user): Update the regular expression to handle single letter class names.
   private static final Pattern CLASSNAME_PATTERN =
       // Match lowercase package names with trailing dots. Start with a non-word character so we
       // don't match substrings in like Bar.Foo and match the com.foo.Foo. Require at least 2
@@ -69,7 +68,7 @@ final class PackageNameCompressor {
       Pattern.compile(
           "[\\W](([a-z_0-9]++[.]){2,}+"
               // Then match a name starting with an uppercase letter. This is the outer class name.
-              + "[A-Z][\\w$]++)");
+              + "[A-Z][\\w$]*)");
 
   // Pattern used to filter out quoted strings that should not have their package name compressed.
   // Picked '"' here because Guice uses it when including a string literal in an error message. This

File: core/src/com/google/inject/internal/PackageNameCompressor.java
Patch:
@@ -52,7 +52,7 @@ final class PackageNameCompressor {
 
   private static final Joiner PACKAGE_JOINER = Joiner.on('.');
 
-  // TODO(user): Consider validating this regex by also passing in all of the known types from
+  // TODO(erichang): Consider validating this regex by also passing in all of the known types from
   // keys, module names, component names, etc and checking against that list. This may have some
   // extra complications with taking apart types like List<Foo> to get the inner class names.
   private static final Pattern CLASSNAME_PATTERN =

File: core/src/com/google/inject/internal/InternalProvisionException.java
Patch:
@@ -208,7 +208,7 @@ static void onNullInjectedIntoNonNullableDependency(Object source, Dependency<?>
   private final List<Object> sourcesToPrepend = new ArrayList<>();
   private final ImmutableList<Message> errors;
 
-  private InternalProvisionException(Message error) {
+  InternalProvisionException(Message error) {
     this(ImmutableList.of(error));
   }
 

File: core/src/com/google/inject/internal/BindingAlreadySetError.java
Patch:
@@ -39,7 +39,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .map(e -> ((BindingAlreadySetError) e).binding.getSource())
             .map(ImmutableList::of)
             .collect(Collectors.toList()));
-    formatter.format("%s%n", Messages.bold("Bound at:"));
+    formatter.format("%n%s%n", Messages.bold("Bound at:"));
     for (int i = 0; i < sourcesList.size(); i++) {
       ErrorFormatter.formatSources(i + 1, sourcesList.get(i), formatter);
     }

File: core/src/com/google/inject/internal/DuplicateMapKeyError.java
Patch:
@@ -30,7 +30,7 @@ final class DuplicateMapKeyError<K, V> extends InternalErrorDetail<DuplicateMapK
 
   @Override
   protected final void formatDetail(List<ErrorDetail<?>> others, Formatter formatter) {
-    formatter.format("%s%n", Messages.bold("Duplicates:"));
+    formatter.format("%n%s%n", Messages.bold("Duplicates:"));
 
     for (Map.Entry<K, Collection<Binding<V>>> entry : duplicates.asMap().entrySet()) {
       formatter.format("  Key:%n");

File: core/src/com/google/inject/internal/GenericErrorDetail.java
Patch:
@@ -21,14 +21,13 @@ public GenericErrorDetail(
   public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
     Preconditions.checkArgument(mergeableErrors.isEmpty(), "Unexpected mergeable errors");
     List<Object> dependencies = getSources();
-    boolean omitPreposition = true;
     for (Object source : Lists.reverse(dependencies)) {
       if (InternalFlags.enableExperimentalErrorMessages()) {
-        new SourceFormatter(source, formatter, omitPreposition).format();
+        formatter.format("  ");
+        new SourceFormatter(source, formatter, /* omitPreposition= */ false).format();
       } else {
         Messages.formatSource(formatter, source);
       }
-      omitPreposition = false;
     }
   }
 

File: core/src/com/google/inject/internal/MissingConstructorError.java
Patch:
@@ -37,6 +37,7 @@ public boolean isMergeable(ErrorDetail<?> other) {
 
   @Override
   protected void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
+    formatter.format("%n");
     Class<?> rawType = type.getRawType();
     if (atInjectRequired) {
       formatter.format(

File: core/src/com/google/inject/internal/MissingImplementationError.java
Patch:
@@ -42,7 +42,6 @@ public boolean isMergeable(ErrorDetail<?> otherError) {
   public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
     if (!suggestions.isEmpty()) {
       suggestions.forEach(formatter::format);
-      formatter.format("%n");
     }
     List<List<Object>> sourcesList = new ArrayList<>();
     sourcesList.add(getSources());
@@ -56,7 +55,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .collect(Collectors.toList());
 
     if (!filteredSourcesList.isEmpty()) {
-      formatter.format("%s%n", Messages.bold("Requested by:"));
+      formatter.format("%n%s%n", Messages.bold("Requested by:"));
       int sourceListIndex = 1;
       for (List<Object> sources : filteredSourcesList) {
         ErrorFormatter.formatSources(sourceListIndex++, Lists.reverse(sources), formatter);

File: core/src/com/google/inject/internal/MissingImplementationErrorHints.java
Patch:
@@ -57,6 +57,7 @@ static <T> ImmutableList<String> getSuggestions(Key<T> key, Injector injector) {
         suggestions.add(
             Messages.format("%n    %d more binding%s with other annotations.", remaining, plural));
       }
+      suggestions.add("%n");
     } else {
       // For now, do a simple substring search for possibilities. This can help spot
       // issues when there are generics being used (such as a wrapper class) and the

File: core/src/com/google/inject/internal/ScopeNotFoundError.java
Patch:
@@ -33,7 +33,7 @@ protected void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter form
     sourcesSet.add(getSources());
     mergeableErrors.stream().map(ErrorDetail::getSources).forEach(sourcesSet::add);
 
-    formatter.format("%s%n", "Used at:");
+    formatter.format("%n%s%n", "Used at:");
     int sourceListIndex = 1;
     for (List<Object> sources : sourcesSet) {
       ErrorFormatter.formatSources(sourceListIndex++, Lists.reverse(sources), formatter);

File: core/src/com/google/inject/spi/ErrorDetail.java
Patch:
@@ -59,7 +59,7 @@ public boolean isMergeable(ErrorDetail<?> otherError) {
   public final void format(int index, List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
     if (InternalFlags.enableExperimentalErrorMessages()) {
       String id = getErrorIdentifier().map(s -> "[" + Messages.redBold(s) + "]: ").orElse("");
-      formatter.format("%s) %s%s%n%n", index, id, getMessage());
+      formatter.format("%s) %s%s%n", index, id, getMessage());
       formatDetail(mergeableErrors, formatter);
       // TODO(b/151482394): Output potiential fixes for the error
       Optional<String> learnMoreLink = getLearnMoreLink();

File: core/src/com/google/inject/internal/SourceFormatter.java
Patch:
@@ -83,7 +83,7 @@ private void formatDependency(Dependency<?> dependency) {
   }
 
   private void formatKey(Key<?> key) {
-    formatter.format("%s%s%n", preposition("for "), Messages.convert(key));
+    formatter.format("%s%s%n", preposition("while locating "), Messages.convert(key));
   }
 
   private void formatMember(Member member) {

File: core/src/com/google/inject/internal/ErrorId.java
Patch:
@@ -15,6 +15,7 @@ public enum ErrorId {
   CONVERTER_RETURNED_NULL,
   DUPLICATE_BINDING_ANNOTATIONS,
   DUPLICATE_ELEMENT,
+  DUPLICATE_MAP_KEY,
   DUPLICATE_SCOPES,
   DUPLICATE_SCOPE_ANNOTATIONS,
   ERROR_ENHANCING_CLASS,

File: core/test/com/google/inject/internal/MessagesTest.java
Patch:
@@ -18,7 +18,7 @@
 public final class MessagesTest {
   static class ExampleErrorDetail extends ErrorDetail<ExampleErrorDetail> {
     ExampleErrorDetail(String message) {
-      super("Example", message, ImmutableList.of(), null);
+      super(message, ImmutableList.of(), null);
     }
 
     @Override

File: core/src/com/google/inject/internal/InternalProvisionException.java
Patch:
@@ -247,6 +247,7 @@ ImmutableList<Message> getErrors() {
 
   /** Returns this exception convered to a ProvisionException. */
   public ProvisionException toProvisionException() {
-    return new ProvisionException(getErrors());
+    ProvisionException exception = new ProvisionException(getErrors());
+    return exception;
   }
 }

File: core/src/com/google/inject/internal/ErrorFormatter.java
Patch:
@@ -15,7 +15,7 @@ static void formatSources(int index, List<Object> sources, Formatter formatter)
       } else {
         formatter.format("%s", SourceFormatter.INDENT);
       }
-      new SourceFormatter(source, formatter).format();
+      new SourceFormatter(source, formatter, i == 0).format();
     }
   }
 }

File: core/src/com/google/inject/internal/GenericErrorDetail.java
Patch:
@@ -21,12 +21,14 @@ public GenericErrorDetail(
   public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatter) {
     Preconditions.checkArgument(mergeableErrors.isEmpty(), "Unexpected mergeable errors");
     List<Object> dependencies = getSources();
+    boolean omitPreposition = true;
     for (Object source : Lists.reverse(dependencies)) {
       if (InternalFlags.enableExperimentalErrorMessages()) {
-        new SourceFormatter(source, formatter).format();
+        new SourceFormatter(source, formatter, omitPreposition).format();
       } else {
         Messages.formatSource(formatter, source);
       }
+      omitPreposition = false;
     }
   }
 

File: core/src/com/google/inject/internal/BindingAlreadySetError.java
Patch:
@@ -39,7 +39,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .map(e -> ((BindingAlreadySetError) e).binding.getSource())
             .map(ImmutableList::of)
             .collect(Collectors.toList()));
-    formatter.format("Bound at the following %s locations:%n", sourcesList.size());
+    formatter.format("%s%n", Messages.bold("Bound at:"));
     for (int i = 0; i < sourcesList.size(); i++) {
       ErrorFormatter.formatSources(i + 1, sourcesList.get(i), formatter);
     }

File: core/src/com/google/inject/internal/MissingConstructorError.java
Patch:
@@ -67,7 +67,7 @@ protected void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter form
     sourcesList.add(getSources());
     mergeableErrors.forEach(error -> sourcesList.add(error.getSources()));
 
-    formatter.format("%s%n", "Requested by:");
+    formatter.format("%s%n", Messages.bold("Requested by:"));
     int sourceListIndex = 1;
     for (List<Object> sources : sourcesList) {
       ErrorFormatter.formatSources(sourceListIndex++, Lists.reverse(sources), formatter);

File: core/src/com/google/inject/internal/MissingImplementationError.java
Patch:
@@ -41,7 +41,7 @@ public void formatDetail(List<ErrorDetail<?>> mergeableErrors, Formatter formatt
             .collect(Collectors.toList());
 
     if (!filteredSourcesList.isEmpty()) {
-      formatter.format("%s%n", "Requested by:");
+      formatter.format("%s%n", Messages.bold("Requested by:"));
       int sourceListIndex = 1;
       for (List<Object> sources : filteredSourcesList) {
         ErrorFormatter.formatSources(sourceListIndex++, Lists.reverse(sources), formatter);

File: core/src/com/google/inject/internal/SourceFormatter.java
Patch:
@@ -38,6 +38,7 @@ final class SourceFormatter {
   }
 
   void format() {
+    // TODO(b/151482394): Omit the prepositions for first source in the list.
     boolean appendModuleSource = !moduleStack.isEmpty();
     if (source instanceof Dependency) {
       formatDependency((Dependency<?>) source);
@@ -85,13 +86,13 @@ private void formatInjectionPoint(Dependency<?> dependency, InjectionPoint injec
     Class<? extends Member> memberType = Classes.memberType(member);
     formatMember(injectionPoint.getMember());
     if (memberType == Field.class) {
-      formatter.format("%s \\_ for field %s%n", INDENT, member.getName());
+      formatter.format("%s \\_ for field %s%n", INDENT, Messages.redBold(member.getName()));
     } else if (dependency != null) {
       int ordinal = dependency.getParameterIndex() + 1;
       Optional<String> name = getParameterName(member, dependency.getParameterIndex());
       formatter.format(
           "%s \\_ for %s parameter %s%n",
-          INDENT, ordinal + Messages.getOrdinalSuffix(ordinal), name.orElse(""));
+          INDENT, ordinal + Messages.getOrdinalSuffix(ordinal), Messages.redBold(name.orElse("")));
     }
   }
 

File: core/test/com/google/inject/RequireAtInjectOnConstructorsTest.java
Patch:
@@ -139,12 +139,12 @@ protected void configure() {
       Asserts.assertContains(
           ce.getMessage(),
           "1) Explicit @Inject annotations are required on constructors, but "
-              + NoCxtors.class.getName()
+              + AnotherNoCxtors.class.getName()
               + " has no constructors annotated with @Inject",
           "at " + RequireAtInjectOnConstructorsTest.class.getName() + "$",
           "configure",
           "2) Explicit @Inject annotations are required on constructors, but "
-              + AnotherNoCxtors.class.getName()
+              + NoCxtors.class.getName()
               + " has no constructors annotated with @Inject",
           "at " + RequireAtInjectOnConstructorsTest.class.getName() + "$",
           "configure");

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -547,6 +547,9 @@ private <T> InjectionPoint findMatchingConstructorInjectionPoint(
     if (!anyAssistedInjectConstructors) {
       // If none existed, use @Inject.
       try {
+        // TODO(b/151482394): Change this to enforce that there is a @Inject annotated cosntructor
+        // since it doesn't make sense to use assisted inject with a no-arg constructor, regardless
+        // if the injector is configured to require @Inject annotation or not.
         return InjectionPoint.forConstructorOf(implementation);
       } catch (ConfigurationException e) {
         errors.merge(e.getErrorMessages());

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -93,10 +93,10 @@ static <T> ConstructorBindingImpl<T> create(
       throws ErrorsException {
     int numErrors = errors.size();
 
-    Class<? super T> rawType =
+    Class<?> rawType =
         constructorInjector == null
             ? key.getTypeLiteral().getRawType()
-            : (Class) constructorInjector.getDeclaringType().getRawType();
+            : constructorInjector.getDeclaringType().getRawType();
 
     // We can't inject abstract classes.
     if (Modifier.isAbstract(rawType.getModifiers())) {

File: extensions/servlet/test/com/google/inject/servlet/ServletTestUtils.java
Patch:
@@ -47,7 +47,7 @@ public static HttpServletRequest newFakeHttpServletRequest() {
         (HttpServletRequest)
             Proxy.newProxyInstance(
                 HttpServletRequest.class.getClassLoader(),
-                new Class[] {HttpServletRequest.class},
+                new Class<?>[] {HttpServletRequest.class},
                 new ThrowingInvocationHandler());
 
     return new HttpServletRequestWrapper(delegate) {

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProvideUtils.java
Patch:
@@ -79,6 +79,7 @@ static <T> Constructor<? extends T> findThrowingConstructor(
   }
 
   /** Adds errors to the binder if the exceptions aren't valid. */
+  @SuppressWarnings("rawtypes") // Class literal uses raw type.
   static void validateExceptions(
       Binder binder,
       Iterable<TypeLiteral<?>> actualExceptionTypes,

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProvides.java
Patch:
@@ -40,6 +40,7 @@
 public @interface CheckedProvides {
 
   /** The interface that provides this value, a subinterface of {@link CheckedProvider}. */
+  @SuppressWarnings("rawtypes") // Class literal uses raw type.
   Class<? extends CheckedProvider> value();
 
   /**

File: core/src/com/google/inject/Binder.java
Patch:
@@ -379,7 +379,7 @@ void bindInterceptor(
    * @return a binder that shares its configuration with this binder.
    * @since 2.0
    */
-  Binder skipSources(Class... classesToSkip);
+  Binder skipSources(Class<?>... classesToSkip);
 
   /**
    * Creates a new private child environment for bindings and other configuration. The returned

File: core/src/com/google/inject/PrivateBinder.java
Patch:
@@ -48,5 +48,5 @@ public interface PrivateBinder extends Binder {
   PrivateBinder withSource(Object source);
 
   @Override
-  PrivateBinder skipSources(Class... classesToSkip);
+  PrivateBinder skipSources(Class<?>... classesToSkip);
 }

File: core/src/com/google/inject/TypeLiteral.java
Patch:
@@ -168,7 +168,7 @@ Type resolveType(Type toResolve) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
     while (true) {
       if (toResolve instanceof TypeVariable) {
-        TypeVariable original = (TypeVariable) toResolve;
+        TypeVariable<?> original = (TypeVariable<?>) toResolve;
         toResolve = MoreTypes.resolveTypeVariable(type, rawType, original);
         if (toResolve == original) {
           return toResolve;

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -117,7 +117,7 @@ protected void putBinding(BindingImpl<?> binding) {
   private static boolean isOkayDuplicate(
       BindingImpl<?> original, BindingImpl<?> binding, InjectorBindingData bindingData) {
     if (original instanceof ExposedBindingImpl) {
-      ExposedBindingImpl exposed = (ExposedBindingImpl) original;
+      ExposedBindingImpl<?> exposed = (ExposedBindingImpl<?>) original;
       InjectorImpl exposedFrom = (InjectorImpl) exposed.getPrivateElements().getInjector();
       return (exposedFrom == binding.getInjector());
     } else {

File: core/src/com/google/inject/internal/Annotations.java
Patch:
@@ -83,6 +83,7 @@ public Annotation load(Class<? extends Annotation> input) {
    * Generates an Annotation for the annotation class. Requires that the annotation is all
    * optionals.
    */
+  @SuppressWarnings("unchecked") // Safe because generateAnnotationImpl returns T for Class<T>
   public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) {
     Preconditions.checkState(
         isAllDefaultMethods(annotationType), "%s is not all default methods", annotationType);

File: core/src/com/google/inject/internal/BindingBuilder.java
Patch:
@@ -104,7 +104,7 @@ public void toInstance(T instance) {
 
   @Override
   public BindingBuilder<T> toProvider(Provider<? extends T> provider) {
-    return toProvider((javax.inject.Provider<T>) provider);
+    return toProvider((javax.inject.Provider<? extends T>) provider);
   }
 
   @Override

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -93,7 +93,6 @@ static <T> ConstructorBindingImpl<T> create(
       throws ErrorsException {
     int numErrors = errors.size();
 
-    @SuppressWarnings("unchecked") // constructorBinding guarantees type is consistent
     Class<? super T> rawType =
         constructorInjector == null
             ? key.getTypeLiteral().getRawType()
@@ -145,7 +144,7 @@ static <T> ConstructorBindingImpl<T> create(
   }
 
   /** Returns true if the inject annotation is on the constructor. */
-  private static boolean hasAtInject(Constructor cxtor) {
+  private static boolean hasAtInject(Constructor<?> cxtor) {
     return cxtor.isAnnotationPresent(Inject.class)
         || cxtor.isAnnotationPresent(javax.inject.Inject.class);
   }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -164,7 +164,7 @@ public Errors withSource(Object source) {
    * Otherwise we need to know who's calling when resolving a just-in-time binding, which makes
    * things unnecessarily complex.
    */
-  public Errors missingImplementation(Key key) {
+  public Errors missingImplementation(Key<?> key) {
     return addMessage(ErrorId.MISSING_IMPLEMENTATION, "No implementation for %s was bound.", key);
   }
 
@@ -260,7 +260,7 @@ public Errors jitDisabledInParent(Key<?> key) {
         key);
   }
 
-  public Errors atInjectRequired(Class clazz) {
+  public Errors atInjectRequired(Class<?> clazz) {
     return addMessage(
         ErrorId.AT_INJECT_REQUIRED,
         "Explicit @Inject annotations are required on constructors,"
@@ -366,7 +366,7 @@ public Errors missingScopeAnnotation(Class<? extends Annotation> annotation) {
         format("Please annotate %s with @ScopeAnnotation.", annotation));
   }
 
-  public Errors optionalConstructor(Constructor constructor) {
+  public Errors optionalConstructor(Constructor<?> constructor) {
     return addMessage(
         ErrorId.OPTIONAL_CONSTRUCTOR,
         "%s is annotated @Inject(optional=true), but constructors cannot be optional.",

File: core/src/com/google/inject/internal/TypeConverterBindingProcessor.java
Patch:
@@ -73,6 +73,7 @@ public String toString() {
         injector,
         Matchers.subclassesOf(Enum.class),
         new TypeConverter() {
+          @SuppressWarnings("rawtypes") // Unavoidable, only way to use Enum.valueOf
           @Override
           public Object convert(String value, TypeLiteral<?> toType) {
             return Enum.valueOf((Class) toType.getRawType(), value);

File: core/src/com/google/inject/internal/util/LineNumbers.java
Patch:
@@ -44,7 +44,7 @@ final class LineNumbers {
 
   private static final int ASM_API_LEVEL = Opcodes.ASM7;
 
-  private final Class type;
+  private final Class<?> type;
   private final Map<String, Integer> lines = Maps.newHashMap();
   private String source;
   private int firstLine = Integer.MAX_VALUE;
@@ -54,7 +54,7 @@ final class LineNumbers {
    *
    * @param type the class to read line number information from
    */
-  public LineNumbers(Class type) throws IOException {
+  public LineNumbers(Class<?> type) throws IOException {
     this.type = type;
 
     if (!type.isArray()) {
@@ -125,7 +125,7 @@ private String memberKey(Member member) {
 
     } else if (member instanceof Constructor) {
       StringBuilder sb = new StringBuilder().append("<init>(");
-      for (Class param : ((Constructor) member).getParameterTypes()) {
+      for (Class<?> param : ((Constructor<?>) member).getParameterTypes()) {
         sb.append(org.objectweb.asm.Type.getDescriptor(param));
       }
       return sb.append(")V").toString();

File: core/src/com/google/inject/internal/util/SourceProvider.java
Patch:
@@ -54,7 +54,7 @@ private SourceProvider(SourceProvider parent, Iterable<String> classesToSkip) {
   }
 
   /** Returns a new instance that also skips {@code moreClassesToSkip}. */
-  public SourceProvider plusSkippedClasses(Class... moreClassesToSkip) {
+  public SourceProvider plusSkippedClasses(Class<?>... moreClassesToSkip) {
     return new SourceProvider(this, asStrings(moreClassesToSkip));
   }
 
@@ -65,9 +65,9 @@ private boolean shouldBeSkipped(String className) {
   }
 
   /** Returns the class names as Strings */
-  private static List<String> asStrings(Class... classes) {
+  private static List<String> asStrings(Class<?>... classes) {
     List<String> strings = Lists.newArrayList();
-    for (Class c : classes) {
+    for (Class<?> c : classes) {
       strings.add(c.getName());
     }
     return strings;

File: core/src/com/google/inject/internal/util/StackTraceElements.java
Patch:
@@ -65,7 +65,7 @@ public static Object forMember(Member member) {
       return SourceProvider.UNKNOWN_SOURCE;
     }
 
-    Class declaringClass = member.getDeclaringClass();
+    Class<?> declaringClass = member.getDeclaringClass();
 
     /*if[AOP]*/
     LineNumbers lineNumbers = lineNumbersCache.getUnchecked(declaringClass);

File: core/src/com/google/inject/spi/Dependency.java
Patch:
@@ -101,7 +101,7 @@ public int hashCode() {
   @Override
   public boolean equals(Object o) {
     if (o instanceof Dependency) {
-      Dependency dependency = (Dependency) o;
+      Dependency<?> dependency = (Dependency<?>) o;
       return Objects.equal(injectionPoint, dependency.injectionPoint)
           && parameterIndex == dependency.parameterIndex
           && key.equals(dependency.key);

File: core/src/com/google/inject/spi/Elements.java
Patch:
@@ -538,7 +538,7 @@ public RecordingBinder withTrustedSource(final Object source) {
     }
 
     @Override
-    public RecordingBinder skipSources(Class... classesToSkip) {
+    public RecordingBinder skipSources(Class<?>... classesToSkip) {
       // if a source is specified explicitly, we don't need to skip sources
       if (source != null) {
         return this;

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -828,7 +828,7 @@ private static boolean overrides(Method a, Method b) {
   static class Signature {
 
     final String name;
-    final Class[] parameterTypes;
+    final Class<?>[] parameterTypes;
     final int hash;
 
     Signature(Method method) {
@@ -837,7 +837,7 @@ static class Signature {
 
       int h = name.hashCode();
       h = h * 31 + parameterTypes.length;
-      for (Class parameterType : parameterTypes) {
+      for (Class<?> parameterType : parameterTypes) {
         h = h * 31 + parameterType.hashCode();
       }
       this.hash = h;

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -222,7 +222,7 @@ public void configure() {
           PrivateElements privateElements = (PrivateElements) element;
           PrivateBinder privateBinder =
               baseBinder.newPrivateBinder().withSource(privateElements.getSource());
-          for (Key exposed : privateElements.getExposedKeys()) {
+          for (Key<?> exposed : privateElements.getExposedKeys()) {
             privateBinder.withSource(privateElements.getExposedSource(exposed)).expose(exposed);
           }
           baseBinder = privateBinder;

File: core/test/com/google/inject/spi/ProviderMethodsTest.java
Patch:
@@ -863,7 +863,7 @@ List annotatedGenericProviderMethod() {
 
   public void testOverrideProviderMethod_subclassRawTypes_parameterType() {
     class SubClassModule extends SuperClassModule {
-      @SuppressWarnings("rawtypes") // Testing rawtypes
+      @SuppressWarnings({"unchecked", "rawtypes"}) // Testing rawtypes
       @Override
       Collection<String> annotatedGenericParameterProviderMethod(List foo) {
         return super.annotatedGenericParameterProviderMethod(foo);

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -106,7 +106,7 @@ public void init(
       return;
     }
 
-    //initialize our filter with the configured context params and servlet context
+    // initialize our filter with the configured context params and servlet context
     filter.init(
         new FilterConfig() {
           @Override
@@ -125,7 +125,7 @@ public String getInitParameter(String s) {
           }
 
           @Override
-          public Enumeration getInitParameterNames() {
+          public Enumeration<?> getInitParameterNames() {
             return Iterators.asEnumeration(initParams.keySet().iterator());
           }
         });

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -115,7 +115,7 @@ public void init(
       return;
     }
 
-    //initialize our servlet with the configured context params and servlet context
+    // initialize our servlet with the configured context params and servlet context
     httpServlet.init(
         new ServletConfig() {
           @Override
@@ -134,7 +134,7 @@ public String getInitParameter(String s) {
           }
 
           @Override
-          public Enumeration getInitParameterNames() {
+          public Enumeration<?> getInitParameterNames() {
             return Iterators.asEnumeration(initParams.keySet().iterator());
           }
         });

File: extensions/servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -398,7 +398,7 @@ private static Object validateAndCanonicalizeValue(Key<?> key, Object object) {
   }
 
   private static class Context implements RequestScoper {
-    final Map<Key, Object> map = Maps.newHashMap();
+    final Map<Key<?>, Object> map = Maps.newHashMap();
 
     // Synchronized to prevent two threads from using the same request
     // scope concurrently.

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethod.java
Patch:
@@ -48,7 +48,10 @@ class CheckedProviderMethod<T> implements CheckedProvider<T>, HasDependencies {
   private final ImmutableSet<Dependency<?>> dependencies;
   private final List<Provider<?>> parameterProviders;
   private final boolean exposed;
+
+  @SuppressWarnings("rawtypes") // Class literal uses rawtypes.
   private final Class<? extends CheckedProvider> checkedProvider;
+
   private final List<TypeLiteral<?>> exceptionTypes;
   private final boolean scopeExceptions;
 

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethodsModule.java
Patch:
@@ -86,7 +86,7 @@ List<CheckedProviderMethod<?>> getProviderMethods(Binder binder) {
 
   <T> CheckedProviderMethod<T> createProviderMethod(
       Binder binder, final Method method, CheckedProvides checkedProvides) {
-    @SuppressWarnings("rawtypes")
+    @SuppressWarnings("rawtypes") // Class literal uses rawtypes.
     Class<? extends CheckedProvider> throwingProvider = checkedProvides.value();
     binder = binder.withSource(method);
     Errors errors = new Errors(method);

File: core/test/com/google/inject/SuiteUtils.java
Patch:
@@ -26,7 +26,7 @@ public class SuiteUtils {
   public static TestSuite removeSuppressedTests(TestSuite suite, Set<String> suppressedTestNames) {
     TestSuite result = new TestSuite(suite.getName());
 
-    for (Enumeration e = suite.tests(); e.hasMoreElements(); ) {
+    for (Enumeration<?> e = suite.tests(); e.hasMoreElements(); ) {
       Test test = (Test) e.nextElement();
 
       if (suppressedTestNames.contains(test.toString())) {

File: core/test/com/google/inject/internal/MultibinderTest.java
Patch:
@@ -1473,7 +1473,7 @@ protected void configure() {
     assertEquals(setBinding.getDependencies().toString(), 2, setBinding.getDependencies().size());
     Set<Dependency<?>> expected = Sets.newHashSet();
     for (Dependency<?> dep : setBinding.getDependencies()) {
-      Key key = dep.getKey();
+      Key<?> key = dep.getKey();
       Dependency<?> providerDependency =
           Dependency.get(key.ofType(Types.providerOf(key.getTypeLiteral().getType())));
       expected.add(providerDependency);
@@ -1598,6 +1598,8 @@ protected void configure() {
             multibinder.addBinding().toInstance("b");
             multibinder.addBinding().toInstance("c");
 
+            // Safe because Set<? extends String> can be used as Set<String> in this context
+            @SuppressWarnings("unchecked")
             Multibinder<String> multibinder2 =
                 Multibinder.newSetBinder(
                     binder(), (TypeLiteral<String>) TypeLiteral.get(Types.subtypeOf(String.class)));

File: core/test/com/googlecode/guice/bundle/OSGiTestActivator.java
Patch:
@@ -482,6 +482,7 @@ protected void configure() {
 
             // this registers: A + PUBLIC -> AA, A + PROTECTED -> AB, etc...
             String suffix = TEST_CLAZZES[visibility.ordinal()].getSimpleName();
+            @SuppressWarnings("rawtypes") // Must use raw type here because of wildcard in api.
             Class imp = bundle.loadClass(api.getName() + suffix);
             bind(api).annotatedWith(named(visibility.name())).to(imp);
 

File: extensions/jmx/src/com/google/inject/tools/jmx/ManagedBinding.java
Patch:
@@ -20,9 +20,9 @@
 
 class ManagedBinding implements ManagedBindingMBean {
 
-  final Binding binding;
+  final Binding<?> binding;
 
-  ManagedBinding(Binding binding) {
+  ManagedBinding(Binding<?> binding) {
     this.binding = binding;
   }
 

File: extensions/persist/src/com/google/inject/persist/finder/Finder.java
Patch:
@@ -45,5 +45,6 @@
    * impl to autobox result lists into. The impl must have a default no-arg constructor and be a
    * subclass of {@code java.util.Collection}.
    */
+  @SuppressWarnings({"rawtypes"}) // Unavoidable because class literal uses raw types.
   Class<? extends Collection> returnAs() default Collection.class;
 }

File: extensions/servlet/test/com/google/inject/servlet/ServletTest.java
Patch:
@@ -166,7 +166,7 @@ public void testRequestAndResponseBindings_wrappingFilter() throws Exception {
     final HttpServletRequestWrapper requestWrapper =
         new HttpServletRequestWrapper(request) {
           @Override
-          public Map getParameterMap() {
+          public Map<String, String[]> getParameterMap() {
             return wrappedParamMap;
           }
 

File: extensions/servlet/test/com/google/inject/servlet/ServletTestUtils.java
Patch:
@@ -70,7 +70,7 @@ public void setAttribute(String name, Object value) {
       }
 
       @Override
-      public Map getParameterMap() {
+      public Map<String, String[]> getParameterMap() {
         return ImmutableMap.of();
       }
 
@@ -98,7 +98,7 @@ public static HttpServletResponse newFakeHttpServletResponse() {
     return (HttpServletResponse)
         Proxy.newProxyInstance(
             HttpServletResponse.class.getClassLoader(),
-            new Class[] {HttpServletResponse.class},
+            new Class<?>[] {HttpServletResponse.class},
             new ThrowingInvocationHandler());
   }
 
@@ -124,7 +124,7 @@ public static HttpSession newFakeHttpSession() {
     return (HttpSession)
         Proxy.newProxyInstance(
             HttpSession.class.getClassLoader(),
-            new Class[] {HttpSession.class},
+            new Class<?>[] {HttpSession.class},
             new FakeHttpSessionHandler());
   }
 }

File: extensions/struts2/src/com/google/inject/struts2/Struts2Factory.java
Patch:
@@ -98,7 +98,7 @@ public Class<?> getClassInstance(String name) throws ClassNotFoundException {
   }
 
   @Override
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "rawtypes"}) // Parent class uses raw type.
   public Object buildBean(Class clazz, Map<String, Object> extraContext) {
     if (strutsInjector == null) {
       synchronized (this) {
@@ -150,7 +150,8 @@ protected void configure() {
 
   @Override
   @SuppressWarnings("unchecked")
-  public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map interceptorRefParams)
+  public Interceptor buildInterceptor(
+      InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams)
       throws ConfigurationException {
     // Ensure the interceptor class is present.
     Class<? extends Interceptor> interceptorClass;

File: core/test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -65,6 +65,8 @@ public void testExplicitBindingOfGenericType() {
     Injector injector =
         Guice.createInjector(
             new AbstractModule() {
+              // Unavoidable because class literal uses raw type
+              @SuppressWarnings({"unchecked", "rawtypes"})
               @Override
               protected void configure() {
                 bind(Key.get(new TypeLiteral<Parameterized<String>>() {}))

File: core/test/com/google/inject/KeyTest.java
Patch:
@@ -103,6 +103,7 @@ public void testTypeEquality() throws Exception {
   /**
    * Key canonicalizes {@link int.class} to {@code Integer.class}, and won't expose wrapper types.
    */
+  @SuppressWarnings("rawtypes") // Unavoidable because class literal uses raw type
   public void testPrimitivesAndWrappersAreEqual() {
     Class[] primitives =
         new Class[] {
@@ -223,7 +224,7 @@ public void testCannotCreateKeysWithTypeVariables() throws NoSuchMethodException
           e.getMessage(), "java.util.List<T> cannot be used as a key; It is not fully specified.");
     }
 
-    TypeVariable tType = (TypeVariable) listOfTType.getActualTypeArguments()[0];
+    TypeVariable<?> tType = (TypeVariable) listOfTType.getActualTypeArguments()[0];
     TypeLiteral<?> t = TypeLiteral.get(tType);
     try {
       Key.get(t);

File: core/test/com/google/inject/MembersInjectorTest.java
Patch:
@@ -195,7 +195,7 @@ public void testCannotBindMembersInjector() {
           new AbstractModule() {
             @Override
             protected void configure() {
-              bind(MembersInjector.class).toProvider(Providers.<MembersInjector>of(null));
+              bind(MembersInjector.class).toProvider(Providers.of(null));
             }
           });
       fail();

File: core/test/com/google/inject/TypeLiteralInjectionTest.java
Patch:
@@ -66,7 +66,7 @@ protected void configure() {
   }
 
   public void testInjectTypeLiteralWithRawTypes() {
-    C c = Guice.createInjector().getInstance(C.class);
+    C<?> c = Guice.createInjector().getInstance(C.class);
     assertEquals(TypeLiteral.get(String.class), c.string);
     assertEquals(TypeLiteral.get(A.class), c.a);
 
@@ -110,6 +110,7 @@ static class B<T> extends A<T> {
     @Inject TypeLiteral<T> t;
   }
 
+  @SuppressWarnings("rawtypes") // Testing rawtypes.
   static class C<T> {
     @Inject TypeLiteral<String> string;
     @Inject TypeLiteral<A> a;

File: core/test/com/google/inject/spi/InjectionPointTest.java
Patch:
@@ -159,6 +159,7 @@ public void testUnattachedDependency() throws IOException {
   }
 
   public void testForConstructor() throws NoSuchMethodException {
+    @SuppressWarnings("rawtypes") // Unavoidable because class literal uses raw type.
     Constructor<HashSet> constructor = HashSet.class.getConstructor();
     TypeLiteral<HashSet<String>> hashSet = new TypeLiteral<HashSet<String>>() {};
 

File: core/test/com/google/inject/spi/SpiBindingsTest.java
Patch:
@@ -393,6 +393,7 @@ protected void configure() {
                 bind(String.class)
                     .toProvider(
                         new ProviderWithExtensionVisitor<String>() {
+                          @SuppressWarnings("unchecked") // Safe because V is fixed to String
                           @Override
                           public <B, V> V acceptExtensionVisitor(
                               BindingTargetVisitor<B, V> visitor,
@@ -451,7 +452,7 @@ protected String visitOther(Binding<? extends T> binding) {
     }
   }
 
-  public void checkBindingSource(Binding binding) {
+  public void checkBindingSource(Binding<?> binding) {
     assertContains(binding.getSource().toString(), getDeclaringSourcePart(getClass()));
     ElementSource source = (ElementSource) binding.getSource();
     assertFalse(source.getModuleClassNames().isEmpty());

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/TestScope.java
Patch:
@@ -37,7 +37,7 @@ class TestScope implements Scope {
   @ScopeAnnotation
   public @interface Scoped {}
 
-  private Map<Key, Object> inScopeObjectsMap = new HashMap<>();
+  private Map<Key<?>, Object> inScopeObjectsMap = new HashMap<>();
 
   @Override
   public <T> Provider<T> scope(final Key<T> key, final Provider<T> provider) {

File: core/test/com/google/inject/Asserts.java
Patch:
@@ -52,7 +52,7 @@ private Asserts() {}
   /**
    * Returns the String that would appear in an error message for this chain of classes as modules.
    */
-  public static String asModuleChain(Class... classes) {
+  public static String asModuleChain(Class<?>... classes) {
     return Joiner.on(" -> ")
         .appendTo(
             new StringBuilder(" (via modules: "),
@@ -65,7 +65,7 @@ public static String asModuleChain(Class... classes) {
    * Returns the source file appears in error messages based on {@link
    * #getIncludeStackTraceOption()} value.
    */
-  public static String getDeclaringSourcePart(Class clazz) {
+  public static String getDeclaringSourcePart(Class<?> clazz) {
     if (getIncludeStackTraceOption() == IncludeStackTraceOption.OFF) {
       return ".configure(Unknown Source";
     }
@@ -189,7 +189,7 @@ public static void awaitClear(WeakReference<?> ref) {
     // so we put a second latch and wait for a ReferenceQueue to tell us.
     Object data = ref.get();
     ReferenceQueue<Object> queue = null;
-    WeakReference extraRef = null;
+    WeakReference<Object> extraRef = null;
     if (data != null) {
       queue = new ReferenceQueue<>();
       extraRef = new WeakReference<>(data, queue);

File: core/test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -574,13 +574,13 @@ protected void configure() {
 
               @Provides
               @Singleton
-              Integer provideInteger(List list) {
+              Integer provideInteger(List<Object> list) {
                 return 2;
               }
 
               @Provides
-              List provideList(Integer integer) {
-                return new ArrayList();
+              List<Object> provideList(Integer integer) {
+                return new ArrayList<>();
               }
             });
     try {

File: core/src/com/google/inject/internal/BindingAlreadySetError.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.stream.Collectors;
 
 /** Error reported by Guice when a key is bound at multiple places the injector. */
-final class BindingAlreadySetError extends ErrorDetail<BindingAlreadySetError> {
+final class BindingAlreadySetError extends InternalErrorDetail<BindingAlreadySetError> {
   private final Binding<?> binding;
   private final Binding<?> original;
 

File: core/src/com/google/inject/internal/GenericErrorDetail.java
Patch:
@@ -9,8 +9,8 @@
 import java.util.Formatter;
 import java.util.List;
 
-/** Generic error message representing a Guice error. */
-public final class GenericErrorDetail extends ErrorDetail<GenericErrorDetail>
+/** Generic error message representing a Guice internal error. */
+public final class GenericErrorDetail extends InternalErrorDetail<GenericErrorDetail>
     implements Serializable {
   public GenericErrorDetail(
       ErrorId errorId, String message, List<Object> sources, Throwable cause) {

File: core/src/com/google/inject/internal/MissingImplementationError.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.stream.Collectors;
 
 /** Error reported by Guice when a key is not bound in the injector. */
-final class MissingImplementationError extends ErrorDetail<MissingImplementationError> {
+final class MissingImplementationError extends InternalErrorDetail<MissingImplementationError> {
   private final Key<?> key;
 
   public MissingImplementationError(Key<?> key, List<Object> sources) {

File: core/test/com/google/inject/internal/MessagesTest.java
Patch:
@@ -18,7 +18,7 @@
 public final class MessagesTest {
   static class ExampleErrorDetail extends ErrorDetail<ExampleErrorDetail> {
     ExampleErrorDetail(String message) {
-      super(ErrorId.OTHER, message, ImmutableList.of(), null);
+      super("Example", message, ImmutableList.of(), null);
     }
 
     @Override

File: core/src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -30,8 +30,8 @@
 import com.google.inject.Singleton;
 import com.google.inject.Stage;
 import com.google.inject.internal.InjectorImpl.InjectorOptions;
+import com.google.inject.internal.util.ContinuousStopwatch;
 import com.google.inject.internal.util.SourceProvider;
-import com.google.inject.internal.util.Stopwatch;
 import com.google.inject.spi.BindingSourceRestriction;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.Element;
@@ -133,7 +133,7 @@ Object lock() {
     List<InjectorShell> build(
         Initializer initializer,
         ProcessedBindingData processedBindingData,
-        Stopwatch stopwatch,
+        ContinuousStopwatch stopwatch,
         Errors errors) {
       checkState(stage != null, "Stage not initialized");
       checkState(privateElements == null || parent != null, "PrivateElements with no parent");

File: core/src/com/google/inject/spi/Elements.java
Patch:
@@ -342,6 +342,7 @@ void scanForAnnotatedMethods() {
         for (ModuleAnnotatedMethodScanner scanner : scanners) {
           currentScanner = scanner;
           moduleSource = entry.getValue().moduleSource;
+          permitMapConstruction.restoreCurrentModulePermits(moduleSource);
           try {
             install(ProviderMethodsModule.forModule(module, scanner));
           } catch (RuntimeException e) {

File: core/src/com/google/inject/spi/Message.java
Patch:
@@ -63,7 +63,7 @@ private Message(ErrorId errorId, ErrorDetail<?> errorDetail) {
   /** @since 2.0 */
   public Message(ErrorId errorId, List<Object> sources, String message, Throwable cause) {
     this.errorId = errorId;
-    this.errorDetail = new GenericErrorDetail(message, sources, cause);
+    this.errorDetail = new GenericErrorDetail(errorId, message, sources, cause);
   }
 
   /** @since 2.0 */
@@ -169,7 +169,8 @@ private Object writeReplace() throws ObjectStreamException {
     }
     return new Message(
         errorId,
-        new GenericErrorDetail(getMessage(), ImmutableList.copyOf(sourcesAsStrings), getCause()));
+        new GenericErrorDetail(
+            errorId, getMessage(), ImmutableList.copyOf(sourcesAsStrings), getCause()));
   }
 
   private static final long serialVersionUID = 0;

File: core/src/com/google/inject/internal/Messages.java
Patch:
@@ -309,7 +309,7 @@ static String formatParameter(Dependency<?> dependency) {
    * @see <a href="https://en.wikipedia.org/wiki/English_numerals#Ordinal_numbers">
    *     https://en.wikipedia.org/wiki/English_numerals#Ordinal_numbers</a>
    */
-  private static String getOrdinalSuffix(int ordinal) {
+  static String getOrdinalSuffix(int ordinal) {
     // negative ordinals don't make sense, we allow zero though because we are programmers
     checkArgument(ordinal >= 0);
     if ((ordinal / 10) % 10 == 1) {

File: core/src/com/google/inject/spi/ErrorDetail.java
Patch:
@@ -9,6 +9,8 @@
 /**
  * Details about a single Guice error and supports formatting itself in the context of other Guice
  * errors.
+ *
+ * <p>WARNING: The class and its APIs are still experimental and subject to change.
  */
 public abstract class ErrorDetail<SelfT extends ErrorDetail<SelfT>> implements Serializable {
   private final String message;

File: core/src/com/google/inject/internal/TypeConverterBindingProcessor.java
Patch:
@@ -74,7 +74,6 @@ public String toString() {
         Matchers.subclassesOf(Enum.class),
         new TypeConverter() {
           @Override
-          @SuppressWarnings("unchecked")
           public Object convert(String value, TypeLiteral<?> toType) {
             return Enum.valueOf((Class) toType.getRawType(), value);
           }
@@ -100,7 +99,6 @@ public String toString() {
         },
         new TypeConverter() {
           @Override
-          @SuppressWarnings("unchecked")
           public Object convert(String value, TypeLiteral<?> toType) {
             try {
               return Class.forName(value);
@@ -125,7 +123,6 @@ private static <T> void convertToPrimitiveType(
       TypeConverter typeConverter =
           new TypeConverter() {
             @Override
-            @SuppressWarnings("unchecked")
             public Object convert(String value, TypeLiteral<?> toType) {
               try {
                 return parser.invoke(null, value);

File: core/src/com/google/inject/Scopes.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject;
 
 import com.google.inject.internal.BindingImpl;
-import com.google.inject.internal.CircularDependencyProxy;
+import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.SingletonScope;
 import com.google.inject.spi.BindingScopingVisitor;
 import com.google.inject.spi.ExposedBinding;
@@ -197,6 +197,6 @@ private static Injector getInjector(LinkedKeyBinding<?> linkedKeyBinding) {
    * @since 4.0
    */
   public static boolean isCircularProxy(Object object) {
-    return object instanceof CircularDependencyProxy;
+    return BytecodeGen.isCircularProxy(object);
   }
 }

File: core/test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -673,9 +673,8 @@ protected void configure() {
     // entry: Key<IImpl> (3 - another circular dependency, this time from JImpl)
     // At this point, if the first Key<Impl> result was cached, our cache would have
     //  Key<IImpl> caching to an instanceof of I, but not an an instanceof of IImpl.
-    // If returned this, it would result in cglib giving a ClassCastException or
-    // java reflection giving an IllegalArgumentException when filling in parameters
-    // for the constructor, because JImpl wants an IImpl, not an I.
+    // If returned this, it would result in a ClassCastException or IllegalArgumentException
+    // when filling in parameters for the constructor, because JImpl wants an IImpl, not an I.
 
     try {
       injector.getInstance(IImpl.class);

File: core/test/com/google/inject/IntegrationTest.java
Patch:
@@ -49,7 +49,7 @@ protected void configure() {
     assertEquals(2, counter.count);
   }
 
-  static class Foo {
+  public static class Foo {
     boolean invoked;
 
     public void foo() {

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -148,8 +148,7 @@ enum JitLimitation {
     }
   }
 
-  /** Indexes bindings by type. */
-  void index() {
+  void indexBindingsByType() {
     for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) {
       bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding);
     }

File: core/src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -125,7 +125,7 @@ private void initializeStatically() {
     stopwatch.resetAndLog("Binding initialization");
 
     for (InjectorShell shell : shells) {
-      shell.getInjector().index();
+      shell.getInjector().indexBindingsByType();
     }
     stopwatch.resetAndLog("Binding indexing");
 

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -340,7 +340,8 @@ public Errors notASubtype(Class<?> implementationType, Class<?> type) {
 
   public Errors recursiveImplementationType() {
     return addMessage(
-        ErrorId.RECURSIVE_BINDING, "@ImplementedBy points to the same class it annotates.");
+        ErrorId.RECURSIVE_IMPLEMENTATION_TYPE,
+        "@ImplementedBy points to the same class it annotates.");
   }
 
   public Errors recursiveProviderType() {
@@ -569,7 +570,7 @@ public Errors exposedButNotBound(Key<?> key) {
 
   public Errors keyNotFullySpecified(TypeLiteral<?> typeLiteral) {
     return addMessage(
-        ErrorId.EXPOSED_BUT_NOT_BOUND,
+        ErrorId.KEY_NOT_FULLY_SPECIFIED,
         "%s cannot be used as a key; It is not fully specified.",
         typeLiteral);
   }

File: core/test/com/google/inject/spi/ElementSourceTest.java
Patch:
@@ -128,7 +128,7 @@ private ModuleSource createModuleSource() {
     // First module
     StackTraceElement[] partialCallStack = new StackTraceElement[1];
     partialCallStack[0] = BINDER_INSTALL;
-    ModuleSource moduleSource = new ModuleSource(A.class, partialCallStack);
+    ModuleSource moduleSource = new ModuleSource(A.class, partialCallStack, /* permitMap = */ null);
     // Second module
     partialCallStack = new StackTraceElement[2];
     partialCallStack[0] = BINDER_INSTALL;

File: core/test/com/google/inject/spi/ModuleSourceTest.java
Patch:
@@ -81,7 +81,7 @@ private void checkSizeThree(ModuleSource moduleSource) {
   private ModuleSource createWithSizeOne() {
     StackTraceElement[] partialCallStack = new StackTraceElement[1];
     partialCallStack[0] = BINDER_INSTALL;
-    return new ModuleSource(A.class, partialCallStack);
+    return new ModuleSource(A.class, partialCallStack, /* permitMap = */ null);
   }
 
   private ModuleSource createWithSizeTwo() {

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -104,15 +104,15 @@ public final class InjectionPoint {
   }
 
   private ImmutableList<Dependency<?>> forMember(
-      Member member, TypeLiteral<?> type, Annotation[][] paramterAnnotations) {
+      Member member, TypeLiteral<?> type, Annotation[][] parameterAnnotationsPerParameter) {
     Errors errors = new Errors(member);
 
     List<Dependency<?>> dependencies = Lists.newArrayList();
     int index = 0;
 
     for (TypeLiteral<?> parameterType : type.getParameterTypes(member)) {
       try {
-        Annotation[] parameterAnnotations = paramterAnnotations[index];
+        Annotation[] parameterAnnotations = parameterAnnotationsPerParameter[index];
         Key<?> key = Annotations.getKey(parameterType, member, parameterAnnotations, errors);
         dependencies.add(newDependency(key, Nullability.allowsNull(parameterAnnotations), index));
         index++;

File: core/src/com/google/inject/internal/ProvisionListenerStackCallback.java
Patch:
@@ -74,6 +74,7 @@ public T provision(InternalContext context, ProvisionCallback<T> callable)
       Object listener =
           provision.erredListener != null ? provision.erredListener.getClass() : "(unknown)";
       throw InternalProvisionException.errorInUserCode(
+          ErrorId.OTHER,
           caught,
           "Error notifying ProvisionListener %s of %s.%n Reason: %s",
           listener,

File: core/src/com/google/inject/internal/RealMapBinder.java
Patch:
@@ -1346,7 +1346,9 @@ public int hashCode() {
   private static <K, V> InternalProvisionException createNullValueException(
       K key, Binding<V> binding) {
     return InternalProvisionException.create(
+        ErrorId.NULL_VALUE_IN_MAP,
         "Map injection failed due to null value for key \"%s\", bound at: %s",
-        key, binding.getSource());
+        key,
+        binding.getSource());
   }
 }

File: core/test/com/google/inject/internal/InternalProvisionExceptionTest.java
Patch:
@@ -25,7 +25,7 @@ public final class InternalProvisionExceptionTest extends TestCase {
   public void testSourceFormatting() {
     // Note that the duplicate source gets dropped as well as the unknown source
     assertThat(
-            InternalProvisionException.create("An error")
+            InternalProvisionException.create(ErrorId.OTHER, "An error")
                 .addSource("Source1")
                 .addSource(SourceProvider.UNKNOWN_SOURCE)
                 .addSource("Source2")

File: core/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -69,7 +69,7 @@
  * provider's get method will be called each time the set is injected (unless the binding is also
  * scoped).
  *
- * <p>Annotations are be used to create different sets of the same element type. Each distinct
+ * <p>Annotations are used to create different sets of the same element type. Each distinct
  * annotation gets its own independent collection of elements.
  *
  * <p><strong>Elements must be distinct.</strong> If multiple bound elements have the same value,

File: core/src/com/google/inject/Injector.java
Patch:
@@ -278,7 +278,7 @@ public interface Injector {
    *
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    *
-   * @since 5.0
+   * @since 4.2.3
    */
   List<Element> getElements();
 
@@ -295,7 +295,7 @@ public interface Injector {
    *
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    *
-   * @since 5.0
+   * @since 4.2.3
    */
   Map<TypeLiteral<?>, List<InjectionPoint>> getAllMembersInjectorInjectionPoints();
 }

File: core/src/com/google/inject/multibindings/MapBinderBinding.java
Patch:
@@ -53,7 +53,7 @@ public interface MapBinderBinding<T> {
    * {@code Map<K, Collection<com.google.inject.Provider<V>>>}, {@code Map<K,
    * Collection<javax.inject.Provider<V>>>}, and {@code Map<K, Set<V>}.
    *
-   * @since 5.0
+   * @since 4.2.3
    */
   Set<Key<?>> getAlternateMapKeys();
 

File: core/src/com/google/inject/multibindings/MultibinderBinding.java
Patch:
@@ -49,7 +49,7 @@ public interface MultibinderBinding<T> {
    * {@code Collection<com.google.inject.Provider<V>>} and {@code
    * Collection<javax.inject.Provider<V>>}.
    *
-   * @since 5.0
+   * @since 4.2.3
    */
   Set<Key<?>> getAlternateSetKeys();
 

File: core/src/com/google/inject/multibindings/OptionalBinderBinding.java
Patch:
@@ -47,7 +47,7 @@ public interface OptionalBinderBinding<T> {
    * entry for {@code Optional<com.google.inject.Provider<V>>} and {@code
    * Optional<javax.inject.Provider<V>>}.
    *
-   * @since 5.0
+   * @since 4.2.3
    */
   Set<Key<?>> getAlternateKeys();
 

File: core/src/com/google/inject/spi/MembersInjectorLookup.java
Patch:
@@ -90,6 +90,7 @@ public MembersInjector<T> getDelegate() {
   /**
    * Returns the instance methods and fields that will be injected to fulfill this request.
    *
+   * @since 4.2.3
    * @return a possibly empty set of injection points. The set has a specified iteration order. All
    *     fields are returned and then all methods. Within the fields, supertype fields are returned
    *     before subtype fields. Similarly, supertype methods are returned before subtype methods.

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/CheckedProviderTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.inject.Asserts.assertContains;
 import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.collect.ImmutableList;
@@ -47,7 +48,6 @@
 import com.google.inject.throwingproviders.ThrowingProviderBinder.Result;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
-import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
@@ -1647,7 +1647,7 @@ public T get() {
   }
 
   @ScopeAnnotation
-  @Target(ElementType.TYPE)
+  @Target({TYPE, METHOD})
   @Retention(RetentionPolicy.RUNTIME)
   private @interface BadScope {}
 

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -279,14 +279,14 @@ public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
       // Disallow private constructors on non-private classes (unless they have @Inject)
       if (Modifier.isPrivate(noArgConstructor.getModifiers())
           && !Modifier.isPrivate(rawType.getModifiers())) {
-        errors.missingConstructor(rawType);
+        errors.missingConstructor(type);
         throw new ConfigurationException(errors.getMessages());
       }
 
       checkForMisplacedBindingAnnotations(noArgConstructor, errors);
       return new InjectionPoint(type, noArgConstructor);
     } catch (NoSuchMethodException e) {
-      errors.missingConstructor(rawType);
+      errors.missingConstructor(type);
       throw new ConfigurationException(errors.getMessages());
     }
   }

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProvider2Test.java
Patch:
@@ -539,7 +539,7 @@ protected void configure() {
     } catch (CreationException expected) {
       assertContains(
           expected.getMessage(),
-          "Could not find a suitable constructor in java.lang.Double.",
+          "No implementation for java.lang.Double (with no qualifier annotation) was bound",
           "at " + ColoredCarFactory.class.getName() + ".create(FactoryProvider2Test.java");
     }
   }
@@ -559,7 +559,7 @@ protected void configure() {
     } catch (CreationException expected) {
       assertContains(
           expected.getMessage(),
-          "Could not find a suitable constructor in java.lang.Double.",
+          "No implementation for java.lang.Double (with no qualifier annotation) was bound",
           "at " + ColoredCarFactory.class.getName() + ".create(FactoryProvider2Test.java");
     }
   }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -229,7 +229,7 @@ <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) {
     // annotations on simple types. This is usually a bad idea.
     if (sameTypes.isEmpty()
         && possibleMatches.isEmpty()
-        && key.getAnnotation() == null
+        && key.getAnnotationType() == null
         && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) {
       // We don't recommend using such simple types without annotations.
       sb.append(format("%nThe key seems very generic, did you forget an annotation?"));

File: core/src/com/google/inject/Binder.java
Patch:
@@ -128,7 +128,7 @@
  *     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>
  *
  * Sets up a constant binding. Constant injections must always be annotated. When a constant
- * binding's value is a string, it is eligile for conversion to all primitive types, to {@link
+ * binding's value is a string, it is eligible for conversion to all primitive types, to {@link
  * Enum#valueOf(Class, String) all enums}, and to {@link Class#forName class literals}. Conversions
  * for other types can be configured using {@link #convertToTypes(Matcher, TypeConverter)
  * convertToTypes()}.

File: core/src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -230,10 +230,11 @@ private boolean isEagerSingleton(InjectorImpl injector, BindingImpl<?> binding,
 
     // handle a corner case where a child injector links to a binding in a parent injector, and
     // that binding is singleton. We won't catch this otherwise because we only iterate the child's
-    // bindings.
+    // bindings. This only applies if the linked binding is not itself scoped.
     if (binding instanceof LinkedBindingImpl) {
       Key<?> linkedBinding = ((LinkedBindingImpl<?>) binding).getLinkedKey();
-      return isEagerSingleton(injector, injector.getBinding(linkedBinding), stage);
+      return binding.getScoping().isNoScope()
+          && isEagerSingleton(injector, injector.getBinding(linkedBinding), stage);
     }
 
     return false;

File: extensions/dagger-adapter/src/com/google/inject/daggeradapter/DaggerAdapter.java
Patch:
@@ -114,7 +114,7 @@ private static void checkUnsupportedDaggerAnnotations(Object module, Binder bind
           if (annotation.annotationType().getName().startsWith("dagger.")) {
             if (!SUPPORTED_METHOD_ANNOTATIONS.contains(annotation.annotationType())) {
               binder.addError(
-                  "%s is annotated with @%s which is not supported by DaggerAdapater",
+                  "%s is annotated with @%s which is not supported by DaggerAdapter",
                   method, annotation.annotationType().getCanonicalName());
             }
           }

File: core/test/com/google/inject/spi/ElementSourceTest.java
Patch:
@@ -128,14 +128,14 @@ private ModuleSource createModuleSource() {
     // First module
     StackTraceElement[] partialCallStack = new StackTraceElement[1];
     partialCallStack[0] = BINDER_INSTALL;
-    ModuleSource moduleSource = new ModuleSource(new A(), partialCallStack);
+    ModuleSource moduleSource = new ModuleSource(A.class, partialCallStack);
     // Second module
     partialCallStack = new StackTraceElement[2];
     partialCallStack[0] = BINDER_INSTALL;
     partialCallStack[1] =
         new StackTraceElement(
             "com.google.inject.spi.moduleSourceTest$A", "configure", "Unknown Source", 100);
-    moduleSource = moduleSource.createChild(new B(), partialCallStack);
+    moduleSource = moduleSource.createChild(B.class, partialCallStack);
     // Third module
     partialCallStack = new StackTraceElement[4];
     partialCallStack[0] = BINDER_INSTALL;
@@ -144,7 +144,7 @@ private ModuleSource createModuleSource() {
     partialCallStack[3] =
         new StackTraceElement(
             "com.google.inject.spi.moduleSourceTest$B", "configure", "Unknown Source", 200);
-    return moduleSource.createChild(new C(), partialCallStack);
+    return moduleSource.createChild(C.class, partialCallStack);
   }
 
   private static class A extends AbstractModule {

File: core/test/com/google/inject/spi/ModuleSourceTest.java
Patch:
@@ -81,7 +81,7 @@ private void checkSizeThree(ModuleSource moduleSource) {
   private ModuleSource createWithSizeOne() {
     StackTraceElement[] partialCallStack = new StackTraceElement[1];
     partialCallStack[0] = BINDER_INSTALL;
-    return new ModuleSource(new A(), partialCallStack);
+    return new ModuleSource(A.class, partialCallStack);
   }
 
   private ModuleSource createWithSizeTwo() {
@@ -91,7 +91,7 @@ private ModuleSource createWithSizeTwo() {
     partialCallStack[1] =
         new StackTraceElement(
             "com.google.inject.spi.moduleSourceTest$A", "configure", "moduleSourceTest.java", 100);
-    return moduleSource.createChild(new B(), partialCallStack);
+    return moduleSource.createChild(B.class, partialCallStack);
   }
 
   private ModuleSource createWithSizeThree() {
@@ -103,7 +103,7 @@ private ModuleSource createWithSizeThree() {
     partialCallStack[3] =
         new StackTraceElement(
             "com.google.inject.spi.moduleSourceTest$B", "configure", "moduleSourceTest.java", 200);
-    return moduleSource.createChild(new C(), partialCallStack);
+    return moduleSource.createChild(C.class, partialCallStack);
   }
 
   private static class A extends AbstractModule {

File: core/src/com/google/inject/spi/ModuleAnnotatedMethodScanner.java
Patch:
@@ -39,9 +39,9 @@ public abstract class ModuleAnnotatedMethodScanner {
   /**
    * Prepares a method for binding. This {@code key} parameter is the key discovered from looking at
    * the binding annotation and return value of the method. Implementations can modify the key to
-   * instead bind to another key. For example, Multibinder may want to change {@code @SetProvides
-   * String provideFoo()} to bind into a unique Key within the multibinder instead of binding {@code
-   * String}.
+   * instead bind to another key. For example, Multibinder may want to change
+   * {@code @ProvidesIntoSet String provideFoo()} to bind into a unique Key within the multibinder
+   * instead of binding {@code String}.
    *
    * <p>The injection point and annotation are provided in case the implementation wants to set the
    * key based on the property of the annotation or if any additional preparation is needed for any

File: core/src/com/google/inject/Injector.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ListMultimap;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.TypeConverterBinding;
@@ -298,5 +297,5 @@ public interface Injector {
    *
    * @since 5.0
    */
-  ListMultimap<TypeLiteral<?>, InjectionPoint> getAllMembersInjectorInjectionPoints();
+  Map<TypeLiteral<?>, List<InjectionPoint>> getAllMembersInjectorInjectionPoints();
 }

File: core/src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ListMultimap;
 import com.google.inject.Binding;
 import com.google.inject.Injector;
 import com.google.inject.Key;
@@ -315,7 +314,7 @@ public List<Element> getElements() {
     }
 
     @Override
-    public ListMultimap<TypeLiteral<?>, InjectionPoint> getAllMembersInjectorInjectionPoints() {
+    public Map<TypeLiteral<?>, List<InjectionPoint>> getAllMembersInjectorInjectionPoints() {
       return delegateInjector.getAllMembersInjectorInjectionPoints();
     }
 

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -314,7 +314,7 @@ public <F> Module build(final Key<F> factoryInterface) {
       @Override
       protected void configure() {
         Provider<F> provider = new FactoryProvider2<>(factoryInterface, bindings);
-        bind(factoryInterface).toProvider(provider);
+        binder().skipSources(this.getClass()).bind(factoryInterface).toProvider(provider);
       }
     };
   }

File: core/src/com/google/inject/internal/Annotations.java
Patch:
@@ -300,6 +300,9 @@ public static void checkForMisplacedScopeAnnotations(
     }
   }
 
+  // NOTE: getKey/findBindingAnnotation are used by Gin which is abandoned.  So changing this API
+  // will prevent Gin users from upgrading Guice version.
+
   /** Gets a key for the given type, member and annotations. */
   public static Key<?> getKey(
       TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors)

File: core/src/com/google/inject/internal/ErrorsException.java
Patch:
@@ -24,6 +24,8 @@
  * @author jessewilson@google.com (Jesse Wilson)
  */
 public class ErrorsException extends Exception {
+  // NOTE: this is used by Gin which is abandoned.  So changing this API will prevent Gin users from
+  // upgrading Guice version.
 
   private final Errors errors;
 

File: core/src/com/google/inject/internal/InternalProvisionException.java
Patch:
@@ -68,8 +68,6 @@ public final class InternalProvisionException extends Exception {
   private static final Set<Dependency<?>> warnedDependencies =
       Collections.newSetFromMap(new ConcurrentHashMap<Dependency<?>, Boolean>());
 
-  // TODO(lukes): rename ErrorsException to InternalConfigurationException after
-  // InternalProvisionException is fully integrated.
 
   public static InternalProvisionException circularDependenciesDisabled(Class<?> expectedType) {
     return create(

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -174,7 +174,7 @@ private Runnable asRunnable(final BindingImpl<?> binding) {
         public void run() {
           try {
             binding.getInjector().initializeBinding(binding, errors.withSource(source));
-          } catch (InternalConfigurationException e) {
+          } catch (ErrorsException e) {
             errors.merge(e.getErrors());
           }
         }

File: core/src/com/google/inject/internal/Annotations.java
Patch:
@@ -303,7 +303,7 @@ public static void checkForMisplacedScopeAnnotations(
   /** Gets a key for the given type, member and annotations. */
   public static Key<?> getKey(
       TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors)
-      throws InternalConfigurationException {
+      throws ErrorsException {
     int numErrorsBefore = errors.size();
     Annotation found = findBindingAnnotation(errors, member, annotations);
     errors.throwIfNewErrors(numErrorsBefore);

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -85,7 +85,7 @@ public Boolean visit(ConstructorBinding<? extends T> binding) {
                       false);
               scheduleInitialization(onInjector);
               putBinding(onInjector);
-            } catch (InternalConfigurationException e) {
+            } catch (ErrorsException e) {
               errors.merge(e.getErrors());
               putBinding(invalidBinding(injector, key, source));
             }

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -46,7 +46,7 @@ public void notify(Errors errors) {
       providerFactory =
           injector.getInternalFactory(
               providerKey, errors.withSource(source), JitLimitation.NEW_OR_EXISTING_JIT);
-    } catch (InternalConfigurationException e) {
+    } catch (ErrorsException e) {
       errors.merge(e.getErrors());
     }
   }

File: core/src/com/google/inject/internal/ConstructionProxyFactory.java
Patch:
@@ -24,5 +24,5 @@
 interface ConstructionProxyFactory<T> {
 
   /** Gets a construction proxy for the given constructor. */
-  ConstructionProxy<T> create() throws InternalConfigurationException;
+  ConstructionProxy<T> create() throws ErrorsException;
 }

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -88,7 +88,7 @@ static <T> ConstructorBindingImpl<T> create(
       Errors errors,
       boolean failIfNotLinked,
       boolean failIfNotExplicit)
-      throws InternalConfigurationException {
+      throws ErrorsException {
     int numErrors = errors.size();
 
     @SuppressWarnings("unchecked") // constructorBinding guarantees type is consistent
@@ -150,8 +150,7 @@ private static boolean hasAtInject(Constructor cxtor) {
 
   @Override
   @SuppressWarnings("unchecked") // the result type always agrees with the ConstructorInjector type
-  public void initialize(InjectorImpl injector, Errors errors)
-      throws InternalConfigurationException {
+  public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
     factory.constructorInjector =
         (ConstructorInjector<T>) injector.constructors.get(constructorInjectionPoint, errors);
     factory.provisionCallback = injector.provisionListenerStore.get(this);

File: core/src/com/google/inject/internal/ConstructorInjectorStore.java
Patch:
@@ -33,7 +33,7 @@ final class ConstructorInjectorStore {
       new FailableCache<InjectionPoint, ConstructorInjector<?>>() {
         @Override
         protected ConstructorInjector<?> create(InjectionPoint constructorInjector, Errors errors)
-            throws InternalConfigurationException {
+            throws ErrorsException {
           return createConstructor(constructorInjector, errors);
         }
       };
@@ -44,7 +44,7 @@ protected ConstructorInjector<?> create(InjectionPoint constructorInjector, Erro
 
   /** Returns a new complete constructor injector with injection listeners registered. */
   public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors)
-      throws InternalConfigurationException {
+      throws ErrorsException {
     return cache.get(constructorInjector, errors);
   }
 
@@ -62,7 +62,7 @@ boolean remove(InjectionPoint ip) {
   }
 
   private <T> ConstructorInjector<T> createConstructor(InjectionPoint injectionPoint, Errors errors)
-      throws InternalConfigurationException {
+      throws ErrorsException {
     int numErrorsBefore = errors.size();
 
     SingleParameterInjector<?>[] constructorParameterInjectors =

File: core/src/com/google/inject/internal/DelayedInitialize.java
Patch:
@@ -25,5 +25,5 @@
 interface DelayedInitialize {
 
   /** Initializes this binding, throwing any errors if necessary. */
-  void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException;
+  void initialize(InjectorImpl injector, Errors errors) throws ErrorsException;
 }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -592,16 +592,16 @@ private List<Object> getSources() {
     return sources;
   }
 
-  public void throwIfNewErrors(int expectedSize) throws InternalConfigurationException {
+  public void throwIfNewErrors(int expectedSize) throws ErrorsException {
     if (size() == expectedSize) {
       return;
     }
 
     throw toException();
   }
 
-  public InternalConfigurationException toException() {
-    return new InternalConfigurationException(this);
+  public ErrorsException toException() {
+    return new ErrorsException(this);
   }
 
   public boolean hasErrors() {

File: core/src/com/google/inject/internal/ErrorsException.java
Patch:
@@ -23,11 +23,11 @@
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */
-public final class InternalConfigurationException extends Exception {
+public class ErrorsException extends Exception {
 
   private final Errors errors;
 
-  public InternalConfigurationException(Errors errors) {
+  public ErrorsException(Errors errors) {
     this.errors = errors;
   }
 

File: core/src/com/google/inject/internal/FactoryProxy.java
Patch:
@@ -47,7 +47,7 @@ public void notify(final Errors errors) {
       targetFactory =
           injector.getInternalFactory(
               targetKey, errors.withSource(source), JitLimitation.NEW_OR_EXISTING_JIT);
-    } catch (InternalConfigurationException e) {
+    } catch (ErrorsException e) {
       errors.merge(e.getErrors());
     }
   }

File: core/src/com/google/inject/internal/FailableCache.java
Patch:
@@ -38,16 +38,16 @@ public Object load(K key) {
                   V result = null;
                   try {
                     result = FailableCache.this.create(key, errors);
-                  } catch (InternalConfigurationException e) {
+                  } catch (ErrorsException e) {
                     errors.merge(e.getErrors());
                   }
                   return errors.hasErrors() ? errors : result;
                 }
               });
 
-  protected abstract V create(K key, Errors errors) throws InternalConfigurationException;
+  protected abstract V create(K key, Errors errors) throws ErrorsException;
 
-  public V get(K key, Errors errors) throws InternalConfigurationException {
+  public V get(K key, Errors errors) throws ErrorsException {
     Object resultOrError = delegate.getUnchecked(key);
     if (resultOrError instanceof Errors) {
       errors.merge((Errors) resultOrError);

File: core/src/com/google/inject/internal/Initializer.java
Patch:
@@ -122,7 +122,7 @@ void validateOustandingInjections(Errors errors) {
     for (InjectableReference<?> reference : pendingInjections) {
       try {
         reference.validate(errors);
-      } catch (InternalConfigurationException e) {
+      } catch (ErrorsException e) {
         errors.merge(e.getErrors());
       }
     }
@@ -178,7 +178,7 @@ public InjectableReference(
       this.lock = checkNotNull(lock, "lock");
     }
 
-    public void validate(Errors errors) throws InternalConfigurationException {
+    public void validate(Errors errors) throws ErrorsException {
       @SuppressWarnings("unchecked") // the type of 'T' is a TypeLiteral<T>
       TypeLiteral<T> type = TypeLiteral.get((Class<T>) instance.getClass());
       membersInjector = injector.membersInjectorStore.get(type, errors.withSource(source));

File: core/src/com/google/inject/internal/LinkedProviderBindingImpl.java
Patch:
@@ -89,8 +89,7 @@ public Key<? extends javax.inject.Provider<? extends T>> getProviderKey() {
   }
 
   @Override
-  public void initialize(InjectorImpl injector, Errors errors)
-      throws InternalConfigurationException {
+  public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
     if (delayedInitializer != null) {
       delayedInitializer.initialize(injector, errors);
     }

File: core/src/com/google/inject/internal/LookupProcessor.java
Patch:
@@ -39,7 +39,7 @@ public <T> Boolean visit(MembersInjectorLookup<T> lookup) {
       MembersInjector<T> membersInjector =
           injector.membersInjectorStore.get(lookup.getType(), errors);
       lookup.initializeDelegate(membersInjector);
-    } catch (InternalConfigurationException e) {
+    } catch (ErrorsException e) {
       errors.merge(e.getErrors()); // TODO: source
     }
 
@@ -52,7 +52,7 @@ public <T> Boolean visit(ProviderLookup<T> lookup) {
     try {
       Provider<T> provider = injector.getProviderOrThrow(lookup.getDependency(), errors);
       lookup.initializeDelegate(provider);
-    } catch (InternalConfigurationException e) {
+    } catch (ErrorsException e) {
       errors.merge(e.getErrors()); // TODO: source
     }
 

File: core/src/com/google/inject/internal/ProvidedByInternalFactory.java
Patch:
@@ -50,8 +50,7 @@ void setProvisionListenerCallback(ProvisionListenerStackCallback<T> listener) {
   }
 
   @Override
-  public void initialize(InjectorImpl injector, Errors errors)
-      throws InternalConfigurationException {
+  public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
     providerBinding =
         injector.getBindingOrThrow(providerKey, errors, JitLimitation.NEW_OR_EXISTING_JIT);
   }

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -75,7 +75,7 @@ public T call() throws InternalProvisionException {
 
   /**
    * Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as
-   * InternalConfigurationExceptions.
+   * ErrorsExceptions.
    */
   protected T provision(
       Provider<? extends T> provider,

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -162,7 +162,7 @@ public void configure(Binder binder) {
   }
 
   @Override
-  void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
+  void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
     parameterInjectors = injector.getParametersInjectors(dependencies.asList(), errors);
   }
 

File: core/src/com/google/inject/internal/ProxyFactory.java
Patch:
@@ -151,7 +151,7 @@ public ImmutableMap<Method, List<MethodInterceptor>> getInterceptors() {
   }
 
   @Override
-  public ConstructionProxy<T> create() throws InternalConfigurationException {
+  public ConstructionProxy<T> create() throws ErrorsException {
     if (interceptors.isEmpty()) {
       return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
     }

File: core/src/com/google/inject/internal/RealMultibinder.java
Patch:
@@ -172,7 +172,7 @@ public Set<Dependency<?>> getDependencies() {
     }
 
     @Override
-    void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
+    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
       bindingSelection.initialize(injector, errors);
       this.bindings = bindingSelection.getBindings();
       this.injectors = bindingSelection.getParameterInjectors();
@@ -336,7 +336,7 @@ private static final class BindingSelection<T> {
       this.elementType = key.getTypeLiteral();
     }
 
-    void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
+    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
       // This will be called multiple times, once by each Factory. We only want
       // to do the work to initialize everything once, so guard this code with
       // isInitialized.
@@ -538,7 +538,7 @@ private static final class RealMultibinderCollectionOfProvidersProvider<T>
     }
 
     @Override
-    void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
+    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
       bindingSelection.initialize(injector, errors);
       ImmutableList.Builder<Provider<T>> providers = ImmutableList.builder();
       for (Binding<T> binding : bindingSelection.getBindings()) {

File: core/src/com/google/inject/internal/RealOptionalBinder.java
Patch:
@@ -758,8 +758,7 @@ private abstract static class RealOptionalBinderProviderWithDependencies<T, P>
     }
 
     @Override
-    final void initialize(InjectorImpl injector, Errors errors)
-        throws InternalConfigurationException {
+    final void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
       bindingSelection.initialize(injector);
       doInitialize();
     }

File: core/src/com/google/inject/internal/SingleFieldInjector.java
Patch:
@@ -29,7 +29,7 @@ final class SingleFieldInjector implements SingleMemberInjector {
   final BindingImpl<?> binding;
 
   public SingleFieldInjector(InjectorImpl injector, InjectionPoint injectionPoint, Errors errors)
-      throws InternalConfigurationException {
+      throws ErrorsException {
     this.injectionPoint = injectionPoint;
     this.field = (Field) injectionPoint.getMember();
     this.dependency = injectionPoint.getDependencies().get(0);

File: core/src/com/google/inject/internal/SingleMethodInjector.java
Patch:
@@ -29,7 +29,7 @@ final class SingleMethodInjector implements SingleMemberInjector {
   private final InjectionPoint injectionPoint;
 
   SingleMethodInjector(InjectorImpl injector, InjectionPoint injectionPoint, Errors errors)
-      throws InternalConfigurationException {
+      throws ErrorsException {
     this.injectionPoint = injectionPoint;
     final Method method = (Method) injectionPoint.getMember();
     methodInvoker = createMethodInvoker(method);

File: core/src/com/google/inject/internal/UntargettedBindingProcessor.java
Patch:
@@ -54,7 +54,7 @@ public Boolean visit(UntargettedBinding<? extends T> untargetted) {
                   injector.createUninitializedBinding(key, scoping, source, errors, false);
               scheduleInitialization(binding);
               putBinding(binding);
-            } catch (InternalConfigurationException e) {
+            } catch (ErrorsException e) {
               errors.merge(e.getErrors());
               putBinding(invalidBinding(injector, key, source));
             }

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -29,7 +29,7 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.InternalConfigurationException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.Nullability;
 import com.google.inject.internal.util.Classes;
 import java.lang.annotation.Annotation;
@@ -95,7 +95,7 @@ public final class InjectionPoint {
       key = Annotations.getKey(declaringType.getFieldType(field), field, annotations, errors);
     } catch (ConfigurationException e) {
       errors.merge(e.getErrorMessages());
-    } catch (InternalConfigurationException e) {
+    } catch (ErrorsException e) {
       errors.merge(e.getErrors());
     }
     errors.throwConfigurationExceptionIfErrorsExist();
@@ -120,7 +120,7 @@ private ImmutableList<Dependency<?>> forMember(
         index++;
       } catch (ConfigurationException e) {
         errors.merge(e.getErrorMessages());
-      } catch (InternalConfigurationException e) {
+      } catch (ErrorsException e) {
         errors.merge(e.getErrors());
       }
     }

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -31,7 +31,7 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.InternalConfigurationException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.Message;
@@ -202,7 +202,7 @@ public static <F> Provider<F> newFactory(
             collector.addBinding(returnType, implementationType);
           }
         }
-      } catch (InternalConfigurationException e) {
+      } catch (ErrorsException e) {
         throw new ConfigurationException(e.getErrors().getMessages());
       }
 

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -174,7 +174,7 @@ private Runnable asRunnable(final BindingImpl<?> binding) {
         public void run() {
           try {
             binding.getInjector().initializeBinding(binding, errors.withSource(source));
-          } catch (ErrorsException e) {
+          } catch (InternalConfigurationException e) {
             errors.merge(e.getErrors());
           }
         }

File: core/src/com/google/inject/internal/Annotations.java
Patch:
@@ -303,7 +303,7 @@ public static void checkForMisplacedScopeAnnotations(
   /** Gets a key for the given type, member and annotations. */
   public static Key<?> getKey(
       TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors)
-      throws ErrorsException {
+      throws InternalConfigurationException {
     int numErrorsBefore = errors.size();
     Annotation found = findBindingAnnotation(errors, member, annotations);
     errors.throwIfNewErrors(numErrorsBefore);

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -85,7 +85,7 @@ public Boolean visit(ConstructorBinding<? extends T> binding) {
                       false);
               scheduleInitialization(onInjector);
               putBinding(onInjector);
-            } catch (ErrorsException e) {
+            } catch (InternalConfigurationException e) {
               errors.merge(e.getErrors());
               putBinding(invalidBinding(injector, key, source));
             }

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -46,7 +46,7 @@ public void notify(Errors errors) {
       providerFactory =
           injector.getInternalFactory(
               providerKey, errors.withSource(source), JitLimitation.NEW_OR_EXISTING_JIT);
-    } catch (ErrorsException e) {
+    } catch (InternalConfigurationException e) {
       errors.merge(e.getErrors());
     }
   }

File: core/src/com/google/inject/internal/ConstructionProxyFactory.java
Patch:
@@ -24,5 +24,5 @@
 interface ConstructionProxyFactory<T> {
 
   /** Gets a construction proxy for the given constructor. */
-  ConstructionProxy<T> create() throws ErrorsException;
+  ConstructionProxy<T> create() throws InternalConfigurationException;
 }

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -88,7 +88,7 @@ static <T> ConstructorBindingImpl<T> create(
       Errors errors,
       boolean failIfNotLinked,
       boolean failIfNotExplicit)
-      throws ErrorsException {
+      throws InternalConfigurationException {
     int numErrors = errors.size();
 
     @SuppressWarnings("unchecked") // constructorBinding guarantees type is consistent
@@ -150,7 +150,8 @@ private static boolean hasAtInject(Constructor cxtor) {
 
   @Override
   @SuppressWarnings("unchecked") // the result type always agrees with the ConstructorInjector type
-  public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+  public void initialize(InjectorImpl injector, Errors errors)
+      throws InternalConfigurationException {
     factory.constructorInjector =
         (ConstructorInjector<T>) injector.constructors.get(constructorInjectionPoint, errors);
     factory.provisionCallback = injector.provisionListenerStore.get(this);

File: core/src/com/google/inject/internal/ConstructorInjectorStore.java
Patch:
@@ -33,7 +33,7 @@ final class ConstructorInjectorStore {
       new FailableCache<InjectionPoint, ConstructorInjector<?>>() {
         @Override
         protected ConstructorInjector<?> create(InjectionPoint constructorInjector, Errors errors)
-            throws ErrorsException {
+            throws InternalConfigurationException {
           return createConstructor(constructorInjector, errors);
         }
       };
@@ -44,7 +44,7 @@ protected ConstructorInjector<?> create(InjectionPoint constructorInjector, Erro
 
   /** Returns a new complete constructor injector with injection listeners registered. */
   public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors)
-      throws ErrorsException {
+      throws InternalConfigurationException {
     return cache.get(constructorInjector, errors);
   }
 
@@ -62,7 +62,7 @@ boolean remove(InjectionPoint ip) {
   }
 
   private <T> ConstructorInjector<T> createConstructor(InjectionPoint injectionPoint, Errors errors)
-      throws ErrorsException {
+      throws InternalConfigurationException {
     int numErrorsBefore = errors.size();
 
     SingleParameterInjector<?>[] constructorParameterInjectors =

File: core/src/com/google/inject/internal/DelayedInitialize.java
Patch:
@@ -25,5 +25,5 @@
 interface DelayedInitialize {
 
   /** Initializes this binding, throwing any errors if necessary. */
-  void initialize(InjectorImpl injector, Errors errors) throws ErrorsException;
+  void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException;
 }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -592,16 +592,16 @@ private List<Object> getSources() {
     return sources;
   }
 
-  public void throwIfNewErrors(int expectedSize) throws ErrorsException {
+  public void throwIfNewErrors(int expectedSize) throws InternalConfigurationException {
     if (size() == expectedSize) {
       return;
     }
 
     throw toException();
   }
 
-  public ErrorsException toException() {
-    return new ErrorsException(this);
+  public InternalConfigurationException toException() {
+    return new InternalConfigurationException(this);
   }
 
   public boolean hasErrors() {

File: core/src/com/google/inject/internal/FactoryProxy.java
Patch:
@@ -47,7 +47,7 @@ public void notify(final Errors errors) {
       targetFactory =
           injector.getInternalFactory(
               targetKey, errors.withSource(source), JitLimitation.NEW_OR_EXISTING_JIT);
-    } catch (ErrorsException e) {
+    } catch (InternalConfigurationException e) {
       errors.merge(e.getErrors());
     }
   }

File: core/src/com/google/inject/internal/FailableCache.java
Patch:
@@ -38,16 +38,16 @@ public Object load(K key) {
                   V result = null;
                   try {
                     result = FailableCache.this.create(key, errors);
-                  } catch (ErrorsException e) {
+                  } catch (InternalConfigurationException e) {
                     errors.merge(e.getErrors());
                   }
                   return errors.hasErrors() ? errors : result;
                 }
               });
 
-  protected abstract V create(K key, Errors errors) throws ErrorsException;
+  protected abstract V create(K key, Errors errors) throws InternalConfigurationException;
 
-  public V get(K key, Errors errors) throws ErrorsException {
+  public V get(K key, Errors errors) throws InternalConfigurationException {
     Object resultOrError = delegate.getUnchecked(key);
     if (resultOrError instanceof Errors) {
       errors.merge((Errors) resultOrError);

File: core/src/com/google/inject/internal/Initializer.java
Patch:
@@ -122,7 +122,7 @@ void validateOustandingInjections(Errors errors) {
     for (InjectableReference<?> reference : pendingInjections) {
       try {
         reference.validate(errors);
-      } catch (ErrorsException e) {
+      } catch (InternalConfigurationException e) {
         errors.merge(e.getErrors());
       }
     }
@@ -178,7 +178,7 @@ public InjectableReference(
       this.lock = checkNotNull(lock, "lock");
     }
 
-    public void validate(Errors errors) throws ErrorsException {
+    public void validate(Errors errors) throws InternalConfigurationException {
       @SuppressWarnings("unchecked") // the type of 'T' is a TypeLiteral<T>
       TypeLiteral<T> type = TypeLiteral.get((Class<T>) instance.getClass());
       membersInjector = injector.membersInjectorStore.get(type, errors.withSource(source));

File: core/src/com/google/inject/internal/InternalConfigurationException.java
Patch:
@@ -23,11 +23,11 @@
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */
-public class ErrorsException extends Exception {
+public final class InternalConfigurationException extends Exception {
 
   private final Errors errors;
 
-  public ErrorsException(Errors errors) {
+  public InternalConfigurationException(Errors errors) {
     this.errors = errors;
   }
 

File: core/src/com/google/inject/internal/LinkedProviderBindingImpl.java
Patch:
@@ -89,7 +89,8 @@ public Key<? extends javax.inject.Provider<? extends T>> getProviderKey() {
   }
 
   @Override
-  public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+  public void initialize(InjectorImpl injector, Errors errors)
+      throws InternalConfigurationException {
     if (delayedInitializer != null) {
       delayedInitializer.initialize(injector, errors);
     }

File: core/src/com/google/inject/internal/LookupProcessor.java
Patch:
@@ -39,7 +39,7 @@ public <T> Boolean visit(MembersInjectorLookup<T> lookup) {
       MembersInjector<T> membersInjector =
           injector.membersInjectorStore.get(lookup.getType(), errors);
       lookup.initializeDelegate(membersInjector);
-    } catch (ErrorsException e) {
+    } catch (InternalConfigurationException e) {
       errors.merge(e.getErrors()); // TODO: source
     }
 
@@ -52,7 +52,7 @@ public <T> Boolean visit(ProviderLookup<T> lookup) {
     try {
       Provider<T> provider = injector.getProviderOrThrow(lookup.getDependency(), errors);
       lookup.initializeDelegate(provider);
-    } catch (ErrorsException e) {
+    } catch (InternalConfigurationException e) {
       errors.merge(e.getErrors()); // TODO: source
     }
 

File: core/src/com/google/inject/internal/ProvidedByInternalFactory.java
Patch:
@@ -50,7 +50,8 @@ void setProvisionListenerCallback(ProvisionListenerStackCallback<T> listener) {
   }
 
   @Override
-  public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+  public void initialize(InjectorImpl injector, Errors errors)
+      throws InternalConfigurationException {
     providerBinding =
         injector.getBindingOrThrow(providerKey, errors, JitLimitation.NEW_OR_EXISTING_JIT);
   }

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -75,7 +75,7 @@ public T call() throws InternalProvisionException {
 
   /**
    * Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as
-   * ErrorsExceptions.
+   * InternalConfigurationExceptions.
    */
   protected T provision(
       Provider<? extends T> provider,

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -162,7 +162,7 @@ public void configure(Binder binder) {
   }
 
   @Override
-  void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+  void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
     parameterInjectors = injector.getParametersInjectors(dependencies.asList(), errors);
   }
 

File: core/src/com/google/inject/internal/ProxyFactory.java
Patch:
@@ -151,7 +151,7 @@ public ImmutableMap<Method, List<MethodInterceptor>> getInterceptors() {
   }
 
   @Override
-  public ConstructionProxy<T> create() throws ErrorsException {
+  public ConstructionProxy<T> create() throws InternalConfigurationException {
     if (interceptors.isEmpty()) {
       return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
     }

File: core/src/com/google/inject/internal/RealMultibinder.java
Patch:
@@ -172,7 +172,7 @@ public Set<Dependency<?>> getDependencies() {
     }
 
     @Override
-    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+    void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
       bindingSelection.initialize(injector, errors);
       this.bindings = bindingSelection.getBindings();
       this.injectors = bindingSelection.getParameterInjectors();
@@ -336,7 +336,7 @@ private static final class BindingSelection<T> {
       this.elementType = key.getTypeLiteral();
     }
 
-    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+    void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
       // This will be called multiple times, once by each Factory. We only want
       // to do the work to initialize everything once, so guard this code with
       // isInitialized.
@@ -538,7 +538,7 @@ private static final class RealMultibinderCollectionOfProvidersProvider<T>
     }
 
     @Override
-    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+    void initialize(InjectorImpl injector, Errors errors) throws InternalConfigurationException {
       bindingSelection.initialize(injector, errors);
       ImmutableList.Builder<Provider<T>> providers = ImmutableList.builder();
       for (Binding<T> binding : bindingSelection.getBindings()) {

File: core/src/com/google/inject/internal/RealOptionalBinder.java
Patch:
@@ -758,7 +758,8 @@ private abstract static class RealOptionalBinderProviderWithDependencies<T, P>
     }
 
     @Override
-    final void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
+    final void initialize(InjectorImpl injector, Errors errors)
+        throws InternalConfigurationException {
       bindingSelection.initialize(injector);
       doInitialize();
     }

File: core/src/com/google/inject/internal/SingleFieldInjector.java
Patch:
@@ -29,7 +29,7 @@ final class SingleFieldInjector implements SingleMemberInjector {
   final BindingImpl<?> binding;
 
   public SingleFieldInjector(InjectorImpl injector, InjectionPoint injectionPoint, Errors errors)
-      throws ErrorsException {
+      throws InternalConfigurationException {
     this.injectionPoint = injectionPoint;
     this.field = (Field) injectionPoint.getMember();
     this.dependency = injectionPoint.getDependencies().get(0);

File: core/src/com/google/inject/internal/SingleMethodInjector.java
Patch:
@@ -29,7 +29,7 @@ final class SingleMethodInjector implements SingleMemberInjector {
   private final InjectionPoint injectionPoint;
 
   SingleMethodInjector(InjectorImpl injector, InjectionPoint injectionPoint, Errors errors)
-      throws ErrorsException {
+      throws InternalConfigurationException {
     this.injectionPoint = injectionPoint;
     final Method method = (Method) injectionPoint.getMember();
     methodInvoker = createMethodInvoker(method);

File: core/src/com/google/inject/internal/UntargettedBindingProcessor.java
Patch:
@@ -54,7 +54,7 @@ public Boolean visit(UntargettedBinding<? extends T> untargetted) {
                   injector.createUninitializedBinding(key, scoping, source, errors, false);
               scheduleInitialization(binding);
               putBinding(binding);
-            } catch (ErrorsException e) {
+            } catch (InternalConfigurationException e) {
               errors.merge(e.getErrors());
               putBinding(invalidBinding(injector, key, source));
             }

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -29,7 +29,7 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.InternalConfigurationException;
 import com.google.inject.internal.Nullability;
 import com.google.inject.internal.util.Classes;
 import java.lang.annotation.Annotation;
@@ -95,7 +95,7 @@ public final class InjectionPoint {
       key = Annotations.getKey(declaringType.getFieldType(field), field, annotations, errors);
     } catch (ConfigurationException e) {
       errors.merge(e.getErrorMessages());
-    } catch (ErrorsException e) {
+    } catch (InternalConfigurationException e) {
       errors.merge(e.getErrors());
     }
     errors.throwConfigurationExceptionIfErrorsExist();
@@ -120,7 +120,7 @@ private ImmutableList<Dependency<?>> forMember(
         index++;
       } catch (ConfigurationException e) {
         errors.merge(e.getErrorMessages());
-      } catch (ErrorsException e) {
+      } catch (InternalConfigurationException e) {
         errors.merge(e.getErrors());
       }
     }

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -31,7 +31,7 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.InternalConfigurationException;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.Message;
@@ -202,7 +202,7 @@ public static <F> Provider<F> newFactory(
             collector.addBinding(returnType, implementationType);
           }
         }
-      } catch (ErrorsException e) {
+      } catch (InternalConfigurationException e) {
         throw new ConfigurationException(e.getErrors().getMessages());
       }
 

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -171,7 +171,9 @@ protected T doProvision(InternalContext context, Dependency<?> dependency)
       throws InternalProvisionException {
     try {
       T t = doProvision(SingleParameterInjector.getAll(context, parameterInjectors));
-      Errors.checkForNull(t, getMethod(), dependency);
+      if (t == null && !dependency.isNullable()) {
+        InternalProvisionException.onNullInjectedIntoNonNullableDependency(getMethod(), dependency);
+      }
       return t;
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -171,9 +171,7 @@ protected T doProvision(InternalContext context, Dependency<?> dependency)
       throws InternalProvisionException {
     try {
       T t = doProvision(SingleParameterInjector.getAll(context, parameterInjectors));
-      if (t == null && !dependency.isNullable()) {
-        InternalProvisionException.onNullInjectedIntoNonNullableDependency(getMethod(), dependency);
-      }
+      Errors.checkForNull(t, getMethod(), dependency);
       return t;
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -171,7 +171,9 @@ protected T doProvision(InternalContext context, Dependency<?> dependency)
       throws InternalProvisionException {
     try {
       T t = doProvision(SingleParameterInjector.getAll(context, parameterInjectors));
-      Errors.checkForNull(t, getMethod(), dependency);
+      if (t == null && !dependency.isNullable()) {
+        InternalProvisionException.onNullInjectedIntoNonNullableDependency(getMethod(), dependency);
+      }
       return t;
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);

File: core/src/com/google/inject/internal/ConstantFactory.java
Patch:
@@ -29,9 +29,9 @@ public ConstantFactory(Initializable<T> initializable) {
   }
 
   @Override
-  public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
-      throws ErrorsException {
-    return initializable.get(errors);
+  public T get(InternalContext context, Dependency<?> dependency, boolean linked)
+      throws InternalProvisionException {
+    return initializable.get();
   }
 
   @Override

File: core/src/com/google/inject/internal/Initializable.java
Patch:
@@ -24,5 +24,5 @@
 interface Initializable<T> {
 
   /** Ensures the reference is initialized, then returns it. */
-  T get(Errors errors) throws ErrorsException;
+  T get() throws InternalProvisionException;
 }

File: core/src/com/google/inject/internal/Initializables.java
Patch:
@@ -23,7 +23,7 @@ final class Initializables {
   static <T> Initializable<T> of(final T instance) {
     return new Initializable<T>() {
       @Override
-      public T get(Errors errors) throws ErrorsException {
+      public T get() {
         return instance;
       }
 

File: core/src/com/google/inject/internal/SingleMemberInjector.java
Patch:
@@ -20,7 +20,7 @@
 
 /** Injects a field or method of a given object. */
 interface SingleMemberInjector {
-  void inject(Errors errors, InternalContext context, Object o);
+  void inject(InternalContext context, Object o) throws InternalProvisionException;
 
   InjectionPoint getInjectionPoint();
 }

File: core/src/com/google/inject/internal/UntargettedBindingImpl.java
Patch:
@@ -33,8 +33,7 @@ final class UntargettedBindingImpl<T> extends BindingImpl<T> implements Untarget
         source,
         new InternalFactory<T>() {
           @Override
-          public T get(
-              Errors errors, InternalContext context, Dependency<?> dependency, boolean linked) {
+          public T get(InternalContext context, Dependency<?> dependency, boolean linked) {
             throw new AssertionError();
           }
         },

File: core/src/com/google/inject/ConfigurationException.java
Patch:
@@ -70,7 +70,7 @@ public <E> E getPartialValue() {
   }
 
   @Override public String getMessage() {
-    return Messages.format("Guice configuration errors", messages);
+    return Messages.formatMessages("Guice configuration errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: core/src/com/google/inject/CreationException.java
Patch:
@@ -47,7 +47,7 @@ public Collection<Message> getErrorMessages() {
 
   @Override
   public String getMessage() {
-    return Messages.format("Unable to create injector, see the following errors", messages);
+    return Messages.formatMessages("Unable to create injector, see the following errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: core/src/com/google/inject/ProvisionException.java
Patch:
@@ -58,7 +58,7 @@ public Collection<Message> getErrorMessages() {
 
   @Override
   public String getMessage() {
-    return Messages.format("Unable to provision, see the following errors", messages);
+    return Messages.formatMessages("Unable to provision, see the following errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: core/src/com/google/inject/internal/Messages.java
Patch:
@@ -74,7 +74,7 @@ public static String format(String messageFormat, Object... arguments) {
   }
 
   /** Returns the formatted message for an exception with the specified messages. */
-  public static String format(String heading, Collection<Message> errorMessages) {
+  public static String formatMessages(String heading, Collection<Message> errorMessages) {
     Formatter fmt = new Formatter().format(heading).format(":%n%n");
     int index = 1;
     boolean displayCauses = getOnlyCause(errorMessages) == null;

File: core/src/com/google/inject/CreationException.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.inject.internal.Errors;
+import com.google.inject.internal.Messages;
 import com.google.inject.spi.Message;
 import java.util.Collection;
 
@@ -37,7 +37,7 @@ public class CreationException extends RuntimeException {
   public CreationException(Collection<Message> messages) {
     this.messages = ImmutableSet.copyOf(messages);
     checkArgument(!this.messages.isEmpty());
-    initCause(Errors.getOnlyCause(this.messages));
+    initCause(Messages.getOnlyCause(this.messages));
   }
 
   /** Returns messages for the errors that caused this exception. */
@@ -47,7 +47,7 @@ public Collection<Message> getErrorMessages() {
 
   @Override
   public String getMessage() {
-    return Errors.format("Unable to create injector, see the following errors", messages);
+    return Messages.format("Unable to create injector, see the following errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: core/src/com/google/inject/ProvisionException.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.inject.internal.Errors;
+import com.google.inject.internal.Messages;
 import com.google.inject.spi.Message;
 import java.util.Collection;
 
@@ -39,7 +39,7 @@ public final class ProvisionException extends RuntimeException {
   public ProvisionException(Iterable<Message> messages) {
     this.messages = ImmutableSet.copyOf(messages);
     checkArgument(!this.messages.isEmpty());
-    initCause(Errors.getOnlyCause(this.messages));
+    initCause(Messages.getOnlyCause(this.messages));
   }
 
   public ProvisionException(String message, Throwable cause) {
@@ -58,7 +58,7 @@ public Collection<Message> getErrorMessages() {
 
   @Override
   public String getMessage() {
-    return Errors.format("Unable to provision, see the following errors", messages);
+    return Messages.format("Unable to provision, see the following errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: core/test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -470,9 +470,6 @@ protected void configure() {
           expected.getMessage(),
           "Found a circular dependency involving "
               + A.class.getName()
-              + ", and circular dependencies are disabled.",
-          "Found a circular dependency involving "
-              + B.class.getName()
               + ", and circular dependencies are disabled.");
     }
   }

File: core/test/com/google/inject/ModulesTest.java
Patch:
@@ -56,7 +56,7 @@ protected void configure() {
     final Module combined2 = Modules.combine(skipSourcesModule);
     Injector injector = Guice.createInjector(combined2);
     ElementSource source = (ElementSource) injector.getBinding(Integer.class).getSource();
-    assertEquals(source.getModuleClassNames().size(), 4);
+    assertEquals(4, source.getModuleClassNames().size());
     assertEquals(
         ImmutableList.of(
             m1.getClass().getName(),

File: core/test/com/google/inject/spi/ElementSourceTest.java
Patch:
@@ -113,9 +113,9 @@ public void testGetCallStack_IntegrationTest() throws Exception {
               assertEquals("com.google.inject.spi.ElementSourceTest", callStack[14].getClassName());
               // Check modules index
               List<Integer> indexes = elementSource.getModuleConfigurePositionsInStackTrace();
-              assertEquals((int) indexes.get(0), 4);
-              assertEquals((int) indexes.get(1), 6);
-              assertEquals((int) indexes.get(2), 10);
+              assertEquals(4, (int) indexes.get(0));
+              assertEquals(6, (int) indexes.get(1));
+              assertEquals(10, (int) indexes.get(2));
               return;
           }
         }

File: core/test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -106,7 +106,7 @@ protected void configure() {
           @Override
           public Void visit(Message command) {
             assertEquals("A", command.getCause().getMessage());
-            assertEquals(command.getMessage(), "An exception was caught and reported. Message: A");
+            assertEquals("An exception was caught and reported. Message: A", command.getMessage());
             assertContains(command.getSource(), getDeclaringSourcePart(ElementsTest.class));
             return null;
           }

File: core/test/com/google/inject/util/OverrideModuleTest.java
Patch:
@@ -632,7 +632,7 @@ protected void configure() {
                         bind(RESULT_KEY).toInstance(OVERRIDDEN_RESULT);
                       }
                     }));
-    assertEquals(inj.getInstance(RESULT_KEY), OVERRIDDEN_RESULT);
+    assertEquals(OVERRIDDEN_RESULT, inj.getInstance(RESULT_KEY));
   }
 
   public void testPrivateBindingOverride() throws Exception {
@@ -646,7 +646,7 @@ protected void configure() {
                         bind(INPUT_KEY).toInstance(OVERRIDDEN_INPUT);
                       }
                     }));
-    assertEquals(inj.getInstance(RESULT_KEY), OVERRIDDEN_RESULT);
+    assertEquals(OVERRIDDEN_RESULT, inj.getInstance(RESULT_KEY));
   }
 
   public static class ExampleModule extends PrivateModule {

File: extensions/servlet/test/com/google/inject/servlet/FilterDefinitionTest.java
Patch:
@@ -73,7 +73,7 @@ public final void testFilterInitAndConfig() throws ServletException {
     assertTrue(filterDef.getFilter() instanceof MockFilter);
     final FilterConfig filterConfig = mockFilter.getConfig();
     assertTrue(null != filterConfig);
-    assertEquals(filterConfig.getServletContext().getServletContextName(), contextName);
+    assertEquals(contextName, filterConfig.getServletContext().getServletContextName());
     assertEquals(filterConfig.getFilterName(), Key.get(Filter.class).toString());
 
     final Enumeration names = filterConfig.getInitParameterNames();

File: core/src/com/google/inject/multibindings/ProvidesIntoMap.java
Patch:
@@ -32,7 +32,7 @@
  * <pre>
  * {@literal @}ProvidesIntoMap
  * {@literal @}StringMapKey("Foo")
- * {@literal @}Named("plugins")
+ * {@literal @}Named("urls")
  * Plugin provideFooUrl(FooManager fm) { return fm.getPlugin(); }
  *
  * {@literal @}ProvidesIntoMap

File: core/src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -195,7 +195,7 @@ public static Class<?> getRawType(Type type) {
       Type componentType = ((GenericArrayType) type).getGenericComponentType();
       return Array.newInstance(getRawType(componentType), 0).getClass();
 
-    } else if (type instanceof TypeVariable) {
+    } else if (type instanceof TypeVariable || type instanceof WildcardType) {
       // we could use the variable's bounds, but that'll won't work if there are multiple.
       // having a raw type that's more general than necessary is okay
       return Object.class;

File: core/src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -34,7 +34,6 @@
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
-import java.util.Map;
 import java.util.NoSuchElementException;
 
 /**
@@ -48,7 +47,7 @@ public class MoreTypes {
 
   private MoreTypes() {}
 
-  private static final Map<TypeLiteral<?>, TypeLiteral<?>> PRIMITIVE_TO_WRAPPER =
+  private static final ImmutableMap<TypeLiteral<?>, TypeLiteral<?>> PRIMITIVE_TO_WRAPPER =
       new ImmutableMap.Builder<TypeLiteral<?>, TypeLiteral<?>>()
           .put(TypeLiteral.get(boolean.class), TypeLiteral.get(Boolean.class))
           .put(TypeLiteral.get(byte.class), TypeLiteral.get(Byte.class))

File: core/src/com/google/inject/internal/ProvisionListenerCallbackStore.java
Patch:
@@ -29,7 +29,6 @@
 import com.google.inject.spi.ProvisionListener;
 import com.google.inject.spi.ProvisionListenerBinding;
 import java.util.List;
-import java.util.Set;
 import java.util.logging.Logger;
 
 /**
@@ -41,7 +40,7 @@ final class ProvisionListenerCallbackStore {
 
   // TODO(sameb): Consider exposing this in the API somehow?  Maybe?
   // Lots of code often want to skip over the internal stuffs.
-  private static final Set<Key<?>> INTERNAL_BINDINGS =
+  private static final ImmutableSet<Key<?>> INTERNAL_BINDINGS =
       ImmutableSet.of(Key.get(Injector.class), Key.get(Stage.class), Key.get(Logger.class));
 
   private final ImmutableList<ProvisionListenerBinding> listenerBindings;

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -44,14 +44,13 @@
 import com.google.inject.util.TypesTest;
 import com.googlecode.guice.GuiceTck;
 import com.googlecode.guice.Jsr330Test;
-import java.util.Set;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
 /** @author crazybob@google.com (Bob Lee) */
 public class AllTests {
 
-  private static final Set<String> SUPPRESSED_TEST_NAMES =
+  private static final ImmutableSet<String> SUPPRESSED_TEST_NAMES =
       ImmutableSet.of(
           "testUnscopedProviderWorksOutsideOfRequestedScope(" + ScopesTest.class.getName() + ")",
           "testCannotConvertUnannotatedBindings(" + TypeConversionTest.class.getName() + ")");

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -29,7 +29,6 @@
 import com.google.inject.Stage;
 import com.google.inject.TypeLiteral;
 import com.google.inject.spi.DefaultBindingTargetVisitor;
-import java.util.Set;
 
 /**
  * Guarantees that processing of Binding elements happens in a sane way.
@@ -41,7 +40,7 @@ abstract class AbstractBindingProcessor extends AbstractProcessor {
   // It's unfortunate that we have to maintain a blacklist of specific
   // classes, but we can't easily block the whole package because of
   // all our unit tests.
-  private static final Set<Class<?>> FORBIDDEN_TYPES =
+  private static final ImmutableSet<Class<?>> FORBIDDEN_TYPES =
       ImmutableSet.<Class<?>>of(
           AbstractModule.class,
           Binder.class,

File: extensions/servlet/src/com/google/inject/servlet/FilterChainInvocation.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.common.collect.Lists;
 import java.io.IOException;
 import java.util.List;
-import java.util.Set;
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
 import javax.servlet.ServletException;
@@ -43,7 +42,7 @@
  */
 class FilterChainInvocation implements FilterChain {
 
-  private static final Set<String> SERVLET_INTERNAL_METHODS =
+  private static final ImmutableSet<String> SERVLET_INTERNAL_METHODS =
       ImmutableSet.of(FilterChainInvocation.class.getName() + ".doFilter");
 
   private final FilterDefinition[] filterDefinitions;

File: core/test/com/google/inject/internal/MapBinderTest.java
Patch:
@@ -84,7 +84,7 @@
 /** @author dpb@google.com (David P. Baker) */
 public class MapBinderTest extends TestCase {
 
-  private static final Set<Key<?>> FRAMEWORK_KEYS =
+  private static final ImmutableSet<Key<?>> FRAMEWORK_KEYS =
       ImmutableSet.of(
           Key.get(java.util.logging.Logger.class), Key.get(Stage.class), Key.get(Injector.class));
 

File: core/src/com/google/inject/internal/AbstractBindingBuilder.java
Patch:
@@ -55,7 +55,7 @@ public AbstractBindingBuilder(Binder binder, List<Element> elements, Object sour
     this.binder = binder;
     this.elements = elements;
     this.position = elements.size();
-    this.binding = new UntargettedBindingImpl<T>(source, key, Scoping.UNSCOPED);
+    this.binding = new UntargettedBindingImpl<>(source, key, Scoping.UNSCOPED);
     elements.add(position, this.binding);
   }
 

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -102,7 +102,7 @@ public Boolean visit(InstanceBinding<? extends T> binding) {
             Initializable<T> ref =
                 initializer.requestInjection(
                     injector, instance, (Binding<T>) binding, source, injectionPoints);
-            ConstantFactory<? extends T> factory = new ConstantFactory<T>(ref);
+            ConstantFactory<? extends T> factory = new ConstantFactory<>(ref);
             InternalFactory<? extends T> scopedFactory =
                 Scoping.scope(key, injector, factory, source, scoping);
             putBinding(
@@ -175,7 +175,7 @@ public Boolean visit(LinkedKeyBinding<? extends T> binding) {
               errors.recursiveBinding();
             }
 
-            FactoryProxy<T> factory = new FactoryProxy<T>(injector, key, linkedKey, source);
+            FactoryProxy<T> factory = new FactoryProxy<>(injector, key, linkedKey, source);
             bindingData.addCreationListener(factory);
             InternalFactory<? extends T> scopedFactory =
                 Scoping.scope(key, injector, factory, source, scoping);
@@ -245,7 +245,7 @@ public Boolean visit(PrivateElements privateElements) {
   }
 
   private <T> void bindExposed(PrivateElements privateElements, Key<T> key) {
-    ExposedKeyFactory<T> exposedKeyFactory = new ExposedKeyFactory<T>(key, privateElements);
+    ExposedKeyFactory<T> exposedKeyFactory = new ExposedKeyFactory<>(key, privateElements);
     bindingData.addCreationListener(exposedKeyFactory);
     putBinding(
         new ExposedBindingImpl<T>(

File: core/src/com/google/inject/internal/ConstructionContext.java
Patch:
@@ -68,10 +68,10 @@ public Object createProxy(Errors errors, InjectorOptions injectorOptions, Class<
     }
 
     if (invocationHandlers == null) {
-      invocationHandlers = new ArrayList<DelegatingInvocationHandler<T>>();
+      invocationHandlers = new ArrayList<>();
     }
 
-    DelegatingInvocationHandler<T> invocationHandler = new DelegatingInvocationHandler<T>();
+    DelegatingInvocationHandler<T> invocationHandler = new DelegatingInvocationHandler<>();
     invocationHandlers.add(invocationHandler);
 
     // TODO: if I create a proxy which implements all the interfaces of

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -66,7 +66,7 @@ public ConstructorBindingImpl(
       InjectionPoint constructorInjectionPoint,
       Set<InjectionPoint> injectionPoints) {
     super(source, key, scoping);
-    this.factory = new Factory<T>(false, key);
+    this.factory = new Factory<>(false, key);
     ConstructionProxy<T> constructionProxy =
         new DefaultConstructionProxyFactory<T>(constructorInjectionPoint).create();
     this.constructorInjectionPoint = constructorInjectionPoint;
@@ -134,7 +134,7 @@ static <T> ConstructorBindingImpl<T> create(
 
     errors.throwIfNewErrors(numErrors);
 
-    Factory<T> factoryFactory = new Factory<T>(failIfNotLinked, key);
+    Factory<T> factoryFactory = new Factory<>(failIfNotLinked, key);
     InternalFactory<? extends T> scopedFactory =
         Scoping.scope(key, injector, factoryFactory, source, scoping);
 

File: core/src/com/google/inject/internal/ConstructorInjectorStore.java
Patch:
@@ -79,10 +79,10 @@ private <T> ConstructorInjector<T> createConstructor(InjectionPoint injectionPoi
         membersInjector.getAddedAspects().isEmpty()
             ? injectorAspects
             : ImmutableList.copyOf(concat(injectorAspects, membersInjector.getAddedAspects()));
-    ConstructionProxyFactory<T> factory = new ProxyFactory<T>(injectionPoint, methodAspects);
+    ConstructionProxyFactory<T> factory = new ProxyFactory<>(injectionPoint, methodAspects);
     /*end[AOP]*/
     /*if[NO_AOP]
-    ConstructionProxyFactory<T> factory = new DefaultConstructionProxyFactory<T>(injectionPoint);
+    ConstructionProxyFactory<T> factory = new DefaultConstructionProxyFactory<>(injectionPoint);
     end[NO_AOP]*/
 
     errors.throwIfNewErrors(numErrorsBefore);

File: core/src/com/google/inject/internal/DeferredLookups.java
Patch:
@@ -48,14 +48,14 @@ void initialize(Errors errors) {
 
   @Override
   public <T> Provider<T> getProvider(Key<T> key) {
-    ProviderLookup<T> lookup = new ProviderLookup<T>(key, key);
+    ProviderLookup<T> lookup = new ProviderLookup<>(key, key);
     lookups.add(lookup);
     return lookup.getProvider();
   }
 
   @Override
   public <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> type) {
-    MembersInjectorLookup<T> lookup = new MembersInjectorLookup<T>(type, type);
+    MembersInjectorLookup<T> lookup = new MembersInjectorLookup<>(type, type);
     lookups.add(lookup);
     return lookup.getMembersInjector();
   }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -197,7 +197,7 @@ <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) {
     sb.append(format("No implementation for %s was bound.", key));
 
     // Keys which have similar strings as the desired key
-    List<String> possibleMatches = new ArrayList<String>();
+    List<String> possibleMatches = new ArrayList<>();
 
     // Check for other keys that may have the same type,
     // but not the same annotation

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -136,7 +136,7 @@ enum JitLimitation {
       // No ThreadLocal.initialValue(), as that would cause classloader leaks. See
       // https://github.com/google/guice/issues/288#issuecomment-48216933,
       // https://github.com/google/guice/issues/288#issuecomment-48216944
-      localContext = new ThreadLocal<Object[]>();
+      localContext = new ThreadLocal<>();
     }
   }
 
@@ -805,7 +805,7 @@ private <T> BindingImpl<T> createImplementedByBinding(
     // Look up the target binding.
     final Key<? extends T> targetKey = Key.get(subclass);
     Object source = rawType;
-    FactoryProxy<T> factory = new FactoryProxy<T>(this, key, targetKey, source);
+    FactoryProxy<T> factory = new FactoryProxy<>(this, key, targetKey, source);
     factory.notify(errors); // causes the factory to initialize itself internally
     return new LinkedBindingImpl<T>(
         this,

File: core/src/com/google/inject/internal/InternalContext.java
Patch:
@@ -61,7 +61,7 @@ <T> ConstructionContext<T> getConstructionContext(Object key) {
     ConstructionContext<T> constructionContext =
         (ConstructionContext<T>) constructionContexts.get(key);
     if (constructionContext == null) {
-      constructionContext = new ConstructionContext<T>();
+      constructionContext = new ConstructionContext<>();
       constructionContexts.put(key, constructionContext);
     }
     return constructionContext;

File: core/src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -191,7 +191,7 @@ private void injectDynamically() {
    * while we're binding these singletons are not be eager.
    */
   void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors) {
-    List<BindingImpl<?>> candidateBindings = new ArrayList<BindingImpl<?>>();
+    List<BindingImpl<?>> candidateBindings = new ArrayList<>();
     @SuppressWarnings("unchecked") // casting Collection<Binding> to Collection<BindingImpl> is safe
     Collection<BindingImpl<?>> bindingsAtThisLevel =
         (Collection) injector.state.getExplicitBindingsThisLevel().values();

File: core/src/com/google/inject/internal/MembersInjectorStore.java
Patch:
@@ -93,7 +93,7 @@ private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Erro
     ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors);
     errors.throwIfNewErrors(numErrorsBefore);
 
-    EncounterImpl<T> encounter = new EncounterImpl<T>(errors, injector.lookups);
+    EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups);
     Set<TypeListener> alreadySeenListeners = Sets.newHashSet();
     for (TypeListenerBinding binding : typeListenerBindings) {
       TypeListener typeListener = binding.getListener();

File: core/src/com/google/inject/internal/RealMultibinder.java
Patch:
@@ -53,7 +53,7 @@ public final class RealMultibinder<T> implements Module {
   /** Implementation of newSetBinder. */
   public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) {
     binder = binder.skipSources(RealMultibinder.class);
-    RealMultibinder<T> result = new RealMultibinder<T>(binder, key);
+    RealMultibinder<T> result = new RealMultibinder<>(binder, key);
     binder.install(result);
     return result;
   }
@@ -86,7 +86,7 @@ static <T> TypeLiteral<Collection<javax.inject.Provider<T>>> collectionOfJavaxPr
 
   RealMultibinder(Binder binder, Key<T> key) {
     this.binder = checkNotNull(binder, "binder");
-    this.bindingSelection = new BindingSelection<T>(key);
+    this.bindingSelection = new BindingSelection<>(key);
   }
 
   @Override

File: core/src/com/google/inject/internal/RealOptionalBinder.java
Patch:
@@ -59,7 +59,7 @@
 public final class RealOptionalBinder<T> implements Module {
   public static <T> RealOptionalBinder<T> newRealOptionalBinder(Binder binder, Key<T> type) {
     binder = binder.skipSources(RealOptionalBinder.class);
-    RealOptionalBinder<T> optionalBinder = new RealOptionalBinder<T>(binder, type);
+    RealOptionalBinder<T> optionalBinder = new RealOptionalBinder<>(binder, type);
     binder.install(optionalBinder);
     return optionalBinder;
   }
@@ -185,7 +185,7 @@ enum Source {
   private final Binder binder;
 
   private RealOptionalBinder(Binder binder, Key<T> typeKey) {
-    this.bindingSelection = new BindingSelection<T>(typeKey);
+    this.bindingSelection = new BindingSelection<>(typeKey);
     this.binder = binder;
   }
 

File: core/src/com/google/inject/internal/SingletonScope.java
Patch:
@@ -101,7 +101,7 @@ public <T> Provider<T> scope(final Key<T> key, final Provider<T> creator) {
        * Circular proxies are used when potential deadlocks are detected. Guarded by itself.
        * ConstructionContext is not thread-safe, so each call should be synchronized.
        */
-      final ConstructionContext<T> constructionContext = new ConstructionContext<T>();
+      final ConstructionContext<T> constructionContext = new ConstructionContext<>();
 
       /** For each binding there is a separate lock that we hold during object creation. */
       final CycleDetectingLock<Key<?>> creationLock = cycleDetectingLockFactory.create(key);

File: core/src/com/google/inject/internal/util/StackTraceElements.java
Patch:
@@ -55,9 +55,8 @@ public LineNumbers load(Class<?> key) {
   /*end[AOP]*/
 
   private static final ConcurrentMap<InMemoryStackTraceElement, InMemoryStackTraceElement>
-      elementCache = new ConcurrentHashMap<InMemoryStackTraceElement, InMemoryStackTraceElement>();
-  private static final ConcurrentMap<String, String> stringCache =
-      new ConcurrentHashMap<String, String>();
+      elementCache = new ConcurrentHashMap<>();
+  private static final ConcurrentMap<String, String> stringCache = new ConcurrentHashMap<>();
 
   private static final String UNKNOWN_SOURCE = "Unknown Source";
 

File: core/src/com/google/inject/spi/Elements.java
Patch:
@@ -408,7 +408,7 @@ public <T> Provider<T> getProvider(final Key<T> key) {
 
     @Override
     public <T> Provider<T> getProvider(final Dependency<T> dependency) {
-      final ProviderLookup<T> element = new ProviderLookup<T>(getElementSource(), dependency);
+      final ProviderLookup<T> element = new ProviderLookup<>(getElementSource(), dependency);
       elements.add(element);
       return element.getProvider();
     }

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -190,7 +190,7 @@ public void configure() {
       }
 
       final Binder binder = baseBinder.skipSources(this.getClass());
-      final LinkedHashSet<Element> elements = new LinkedHashSet<Element>(baseElements);
+      final LinkedHashSet<Element> elements = new LinkedHashSet<>(baseElements);
       final Module scannersModule = extractScanners(elements);
       final List<Element> overrideElements =
           Elements.getElements(

File: core/test/com/google/inject/BindingOrderTest.java
Patch:
@@ -61,7 +61,7 @@ protected void configure() {
   public void testBindingWithExtraThreads() throws InterruptedException {
     final CountDownLatch ready = new CountDownLatch(1);
     final CountDownLatch done = new CountDownLatch(1);
-    final AtomicReference<B> ref = new AtomicReference<B>();
+    final AtomicReference<B> ref = new AtomicReference<>();
 
     final Object createsAThread =
         new Object() {

File: core/test/com/google/inject/BindingTest.java
Patch:
@@ -634,7 +634,7 @@ public void configure() {
     }
   }
 
-  private static List<Butter> butters = new ArrayList<Butter>();
+  private static List<Butter> butters = new ArrayList<>();
 
   private static interface Sandwitch {};
 

File: core/test/com/google/inject/EagerSingletonTest.java
Patch:
@@ -86,7 +86,7 @@ protected void configure() {
   public void testJustInTimeEagerSingletons_multipleThreads() throws Exception {
     // in order to make the data race more likely we need a lot of jit bindings.  The easiest thing
     // is just to 'copy' out class for B a bunch of times.
-    final List<Class<?>> jitBindings = new ArrayList<Class<?>>();
+    final List<Class<?>> jitBindings = new ArrayList<>();
     for (int i = 0; i < 1000; i++) {
       jitBindings.add(copyClass(B.class));
     }

File: core/test/com/google/inject/InjectorTest.java
Patch:
@@ -424,7 +424,7 @@ public Chicken get() {
 
   public void testJitBindingFromAnotherThreadDuringInjection() {
     final ExecutorService executorService = Executors.newSingleThreadExecutor();
-    final AtomicReference<JustInTime> got = new AtomicReference<JustInTime>();
+    final AtomicReference<JustInTime> got = new AtomicReference<>();
 
     Guice.createInjector(
         new AbstractModule() {

File: core/test/com/google/inject/KeyTest.java
Patch:
@@ -332,7 +332,7 @@ protected void configure() {
             binder().requestInjection(new TypeLiteral<Object>() {}, foo);
           }
         };
-    WeakReference<Module> moduleRef = new WeakReference<Module>(module);
+    WeakReference<Module> moduleRef = new WeakReference<>(module);
     final Injector injector = Guice.createInjector(module);
     module = null;
     awaitClear(moduleRef); // Make sure anonymous keys & typeliterals don't hold the module.
@@ -345,7 +345,7 @@ public void run() {
             injector.getInstance(Key.get(new TypeLiteral<Typed<Integer>>() {}));
           }
         };
-    WeakReference<Runnable> runnerRef = new WeakReference<Runnable>(runner);
+    WeakReference<Runnable> runnerRef = new WeakReference<>(runner);
     runner.run();
     runner = null;
     awaitClear(runnerRef); // also make sure anonymous keys & typeliterals don't hold for JITs

File: core/test/com/google/inject/MethodInterceptionTest.java
Patch:
@@ -121,7 +121,7 @@ protected void configure() {
   }
 
   public void testGetThis() {
-    final AtomicReference<Object> lastTarget = new AtomicReference<Object>();
+    final AtomicReference<Object> lastTarget = new AtomicReference<>();
 
     Injector injector =
         Guice.createInjector(

File: core/test/com/google/inject/ProvisionListenerTest.java
Patch:
@@ -528,7 +528,7 @@ public <T> void onProvision(ProvisionInvocation<T> provision) {
   private static class CountAndCaptureExceptionListener implements ProvisionListener {
     int beforeProvision = 0;
     int afterProvision = 0;
-    AtomicReference<RuntimeException> capture = new AtomicReference<RuntimeException>();
+    AtomicReference<RuntimeException> capture = new AtomicReference<>();
 
     @Override
     public <T> void onProvision(ProvisionInvocation<T> provision) {

File: core/test/com/google/inject/TypeListenerTest.java
Patch:
@@ -415,9 +415,8 @@ public <I> void hear(TypeLiteral<I> type, TypeEncounter<I> encounter) {
   }
 
   public void testLookupsAtInjectorCreateTime() {
-    final AtomicReference<Provider<B>> bProviderReference = new AtomicReference<Provider<B>>();
-    final AtomicReference<MembersInjector<A>> aMembersInjectorReference =
-        new AtomicReference<MembersInjector<A>>();
+    final AtomicReference<Provider<B>> bProviderReference = new AtomicReference<>();
+    final AtomicReference<MembersInjector<A>> aMembersInjectorReference = new AtomicReference<>();
 
     final InjectionListener<Object> lookupsTester =
         new InjectionListener<Object>() {

File: core/test/com/google/inject/internal/MapBinderTest.java
Patch:
@@ -1235,7 +1235,7 @@ public String apply(Set<Provider<String>> stringProvidersSet) {
 
   @SuppressWarnings("unchecked")
   private <K, V> Map<K, V> mapOf(Object... elements) {
-    Map<K, V> result = new HashMap<K, V>();
+    Map<K, V> result = new HashMap<>();
     for (int i = 0; i < elements.length; i += 2) {
       result.put((K) elements[i], (V) elements[i + 1]);
     }
@@ -1286,7 +1286,7 @@ public void configure() {
     // This ensures that MultiBinder is internally using the correct set name --
     // making sure that instances of marker annotations have the same set name as
     // MarkerAnnotation.class.
-    Map<Integer, Integer> expected = new HashMap<Integer, Integer>();
+    Map<Integer, Integer> expected = new HashMap<>();
     expected.put(1, 1);
     expected.put(2, 2);
     assertEquals(expected, s1);
@@ -1357,7 +1357,7 @@ protected void configure() {
                 binder.addBinding("bar").toInstance("foo");
               }
             });
-    WeakReference<Injector> weakRef = new WeakReference<Injector>(childInjector);
+    WeakReference<Injector> weakRef = new WeakReference<>(childInjector);
     WeakKeySetUtils.assertBlacklisted(parentInjector, mapKey);
 
     // Clear the ref, GC, and ensure that we are no longer blacklisting.

File: core/test/com/google/inject/internal/MultibinderTest.java
Patch:
@@ -1036,7 +1036,7 @@ public String toString() {
     }
 
     static Set<String> values(Iterable<StringGrabber> grabbers) {
-      Set<String> result = new HashSet<String>();
+      Set<String> result = new HashSet<>();
       for (StringGrabber grabber : grabbers) {
         result.add(grabber.string);
       }
@@ -1302,7 +1302,7 @@ public void configure() {
     // This ensures that MultiBinder is internally using the correct set name --
     // making sure that instances of marker annotations have the same set name as
     // MarkerAnnotation.class.
-    Set<Integer> expected = new HashSet<Integer>();
+    Set<Integer> expected = new HashSet<>();
     expected.add(1);
     expected.add(2);
     assertEquals(expected, s1);

File: core/test/com/google/inject/internal/OptionalBinderTest.java
Patch:
@@ -1433,7 +1433,7 @@ protected void configure() {
                     .toInstance(4);
               }
             });
-    WeakReference<Injector> weakRef = new WeakReference<Injector>(childInjector);
+    WeakReference<Injector> weakRef = new WeakReference<>(childInjector);
     WeakKeySetUtils.assertBlacklisted(parentInjector, Key.get(Integer.class));
 
     // Clear the ref, GC, and ensure that we are no longer blacklisting.

File: core/test/com/google/inject/internal/ProxyFactoryTest.java
Patch:
@@ -43,7 +43,7 @@ public void testSimpleCase()
     InjectionPoint injectionPoint = InjectionPoint.forConstructorOf(Simple.class);
 
     aspects.add(new MethodAspect(any(), any(), interceptor));
-    ProxyFactory<Simple> factory = new ProxyFactory<Simple>(injectionPoint, aspects);
+    ProxyFactory<Simple> factory = new ProxyFactory<>(injectionPoint, aspects);
 
     ConstructionProxy<Simple> constructionProxy = factory.create();
 

File: core/test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -879,7 +879,7 @@ public void testElementInitialization() {
     final AtomicReference<MembersInjector<String>> membersInjectorFromBinder =
         new AtomicReference<MembersInjector<String>>();
 
-    final AtomicReference<String> lastInjected = new AtomicReference<String>();
+    final AtomicReference<String> lastInjected = new AtomicReference<>();
     final MembersInjector<String> stringInjector =
         new MembersInjector<String>() {
           @Override

File: core/test/com/google/inject/spi/ProviderMethodsTest.java
Patch:
@@ -449,7 +449,7 @@ void provideFoo() {}
   }
 
   public void testInjectsJustOneLogger() {
-    AtomicReference<Logger> loggerRef = new AtomicReference<Logger>();
+    AtomicReference<Logger> loggerRef = new AtomicReference<>();
     Injector injector = Guice.createInjector(new FooModule(loggerRef));
 
     assertNull(loggerRef.get());

File: core/test/com/google/inject/util/OverrideModuleTest.java
Patch:
@@ -404,7 +404,7 @@ protected void configure() {
   }
 
   public void testOverrideIsLazy() {
-    final AtomicReference<String> value = new AtomicReference<String>("A");
+    final AtomicReference<String> value = new AtomicReference<>("A");
     Module overridden =
         Modules.override(
                 new AbstractModule() {

File: examples/src/example/xml/XmlBeanModule.java
Patch:
@@ -169,7 +169,7 @@ void setOn(Object o) {
 
   class BeanBuilder {
 
-    final List<Property> properties = new ArrayList<Property>();
+    final List<Property> properties = new ArrayList<>();
     final Class<?> type;
 
     BeanBuilder(Class<?> type) {

File: extensions/assistedinject/src/com/google/inject/assistedinject/AssistedConstructor.java
Patch:
@@ -52,7 +52,7 @@ private AssistedConstructor(Constructor<T> constructor, List<TypeLiteral<?>> par
     Annotation[][] annotations = constructor.getParameterAnnotations();
 
     List<Type> typeList = Lists.newArrayList();
-    allParameters = new ArrayList<Parameter>();
+    allParameters = new ArrayList<>();
 
     // categorize params as @Assisted or @Injected
     for (int i = 0; i < parameterTypes.size(); i++) {

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -313,7 +313,7 @@ public <F> Module build(final Key<F> factoryInterface) {
     return new AbstractModule() {
       @Override
       protected void configure() {
-        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, bindings);
+        Provider<F> provider = new FactoryProvider2<>(factoryInterface, bindings);
         bind(factoryInterface).toProvider(provider);
       }
     };

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -432,7 +432,7 @@ public F get() {
 
   @Override
   public Set<Dependency<?>> getDependencies() {
-    Set<Dependency<?>> combinedDeps = new HashSet<Dependency<?>>();
+    Set<Dependency<?>> combinedDeps = new HashSet<>();
     for (AssistData data : assistDataByMethod.values()) {
       combinedDeps.addAll(data.dependencies);
     }

File: extensions/assistedinject/src/com/google/inject/assistedinject/ParameterListKey.java
Patch:
@@ -34,7 +34,7 @@ class ParameterListKey {
   private final List<Type> paramList;
 
   public ParameterListKey(List<Type> paramList) {
-    this.paramList = new ArrayList<Type>(paramList);
+    this.paramList = new ArrayList<>(paramList);
   }
 
   public ParameterListKey(Type[] types) {

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryModuleBuilderTest.java
Patch:
@@ -529,7 +529,7 @@ protected void configure() {
 
   private void validateDependencies(Set<Key<?>> expectedKeys, Binding<?> binding) {
     Set<Dependency<?>> dependencies = ((HasDependencies) binding).getDependencies();
-    Set<Key<?>> actualKeys = new HashSet<Key<?>>();
+    Set<Key<?>> actualKeys = new HashSet<>();
     for (Dependency<?> dependency : dependencies) {
       actualKeys.add(dependency.getKey());
     }

File: extensions/grapher/test/com/google/inject/grapher/AbstractInjectorGrapherTest.java
Patch:
@@ -170,7 +170,7 @@ protected void configure() {
   }
 
   public void testProviderBindings() throws Exception {
-    final Wrapper<Provider<A2>> wrapper = new Wrapper<Provider<A2>>();
+    final Wrapper<Provider<A2>> wrapper = new Wrapper<>();
     grapher.graph(
         Guice.createInjector(
             new AbstractModule() {

File: extensions/mini/test/com/google/inject/mini/MiniGuiceTest.java
Patch:
@@ -179,8 +179,8 @@ public static class K {
   }
 
   public void testSingletonBindingAnnotationAndProvider() {
-    final AtomicReference<A> a1 = new AtomicReference<A>();
-    final AtomicReference<A> a2 = new AtomicReference<A>();
+    final AtomicReference<A> a1 = new AtomicReference<>();
+    final AtomicReference<A> a2 = new AtomicReference<>();
 
     L l =
         MiniGuice.inject(

File: extensions/persist/src/com/google/inject/persist/jpa/JpaLocalTxnInterceptor.java
Patch:
@@ -37,7 +37,7 @@ class JpaLocalTxnInterceptor implements MethodInterceptor {
   private static class Internal {}
 
   // Tracks if the unit of work was begun implicitly by this transaction.
-  private final ThreadLocal<Boolean> didWeStartWork = new ThreadLocal<Boolean>();
+  private final ThreadLocal<Boolean> didWeStartWork = new ThreadLocal<>();
 
   @Override
   public Object invoke(MethodInvocation methodInvocation) throws Throwable {

File: extensions/persist/src/com/google/inject/persist/jpa/JpaPersistService.java
Patch:
@@ -36,7 +36,7 @@
 /** @author Dhanji R. Prasanna (dhanji@gmail.com) */
 @Singleton
 class JpaPersistService implements Provider<EntityManager>, UnitOfWork, PersistService {
-  private final ThreadLocal<EntityManager> entityManager = new ThreadLocal<EntityManager>();
+  private final ThreadLocal<EntityManager> entityManager = new ThreadLocal<>();
 
   private final String persistenceUnitName;
   private final Map<?, ?> persistenceProperties;

File: extensions/persist/test/com/google/inject/persist/jpa/EnsureJpaCanTakeObjectsInPropertiesTest.java
Patch:
@@ -49,7 +49,7 @@ public static class DBModule extends AbstractModule {
 
     @Override
     protected void configure() {
-      Map<String, Object> p = new HashMap<String, Object>();
+      Map<String, Object> p = new HashMap<>();
 
       p.put(Environment.CONNECTION_PROVIDER, InjectedDataSourceConnectionProvider.class.getName());
       if (passDataSource) {

File: extensions/persist/test/com/google/inject/persist/jpa/JpaParentTestEntity.java
Patch:
@@ -32,7 +32,7 @@
 @Entity
 public class JpaParentTestEntity {
   private Long id;
-  private List<JpaTestEntity> children = new ArrayList<JpaTestEntity>();
+  private List<JpaTestEntity> children = new ArrayList<>();
 
   @Id
   @GeneratedValue

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -47,7 +47,7 @@ class FilterDefinition implements ProviderWithExtensionVisitor<FilterDefinition>
   private final Filter filterInstance;
 
   // always set after init is called.
-  private final AtomicReference<Filter> filter = new AtomicReference<Filter>();
+  private final AtomicReference<Filter> filter = new AtomicReference<>();
 
   public FilterDefinition(
       Key<? extends Filter> filterKey,

File: extensions/servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -47,7 +47,7 @@ public ServletModule.FilterKeyBindingBuilder filterRegex(List<String> regexes) {
   }
 
   private List<UriPatternMatcher> parsePatterns(UriPatternType type, List<String> patterns) {
-    List<UriPatternMatcher> patternMatchers = new ArrayList<UriPatternMatcher>();
+    List<UriPatternMatcher> patternMatchers = new ArrayList<>();
     for (String pattern : patterns) {
       UriPatternMatcher matcher = null;
       try {

File: extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -61,7 +61,7 @@
  * @author dhanji@gmail.com (Dhanji R. Prasanna)
  */
 public class GuiceFilter implements Filter {
-  static final ThreadLocal<Context> localContext = new ThreadLocal<Context>();
+  static final ThreadLocal<Context> localContext = new ThreadLocal<>();
   static volatile FilterPipeline pipeline = new DefaultFilterPipeline();
 
   /** We allow both the static and dynamic versions of the pipeline to exist. */
@@ -223,7 +223,7 @@ public void init(FilterConfig filterConfig) throws ServletException {
     final ServletContext servletContext = filterConfig.getServletContext();
 
     // Store servlet context in a weakreference, for injection
-    GuiceFilter.servletContext = new WeakReference<ServletContext>(servletContext);
+    GuiceFilter.servletContext = new WeakReference<>(servletContext);
 
     // In the default pipeline, this is a noop. However, if replaced
     // by a managed pipeline, a lazy init will be triggered the first time

File: extensions/servlet/src/com/google/inject/servlet/GuiceServletContextListener.java
Patch:
@@ -40,7 +40,7 @@ public void contextInitialized(ServletContextEvent servletContextEvent) {
 
     // Set the Servletcontext early for those people who are using this class.
     // NOTE(dhanji): This use of the servletContext is deprecated.
-    GuiceFilter.servletContext = new WeakReference<ServletContext>(servletContext);
+    GuiceFilter.servletContext = new WeakReference<>(servletContext);
 
     Injector injector = getInjector();
     injector

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -57,7 +57,7 @@ class ServletDefinition implements ProviderWithExtensionVisitor<ServletDefinitio
   private final HttpServlet servletInstance;
 
   //always set in init, our servlet is always presumed to be a singleton
-  private final AtomicReference<HttpServlet> httpServlet = new AtomicReference<HttpServlet>();
+  private final AtomicReference<HttpServlet> httpServlet = new AtomicReference<>();
 
   public ServletDefinition(
       Key<? extends HttpServlet> servletKey,

File: extensions/servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -49,7 +49,7 @@ private ServletScopes() {}
    * this scope map if no http request is available, and requires {@link #scopeRequest} to be called
    * as an alternative.
    */
-  private static final ThreadLocal<Context> requestScopeContext = new ThreadLocal<Context>();
+  private static final ThreadLocal<Context> requestScopeContext = new ThreadLocal<>();
 
   /** A sentinel attribute value representing null. */
   enum NullObject {

File: extensions/servlet/src/com/google/inject/servlet/ServletUtils.java
Patch:
@@ -77,7 +77,7 @@ static String normalizePath(String path) {
     // 1. decode and normalize safe percent escaped characters.  e.g. %70 -> 'p'
     // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/'
     // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F'
-    List<String> segments = new ArrayList<String>();
+    List<String> segments = new ArrayList<>();
     for (String segment : SLASH_SPLITTER.split(path)) {
       // This decodes all non-special characters from the path segment.  so if someone passes
       // /%2E/foo we will normalize it to /./foo and then /foo

File: extensions/servlet/src/com/google/inject/servlet/ServletsModuleBuilder.java
Patch:
@@ -51,7 +51,7 @@ public ServletModule.ServletKeyBindingBuilder serveRegex(List<String> regexes) {
   }
 
   private List<UriPatternMatcher> parsePatterns(UriPatternType type, List<String> patterns) {
-    List<UriPatternMatcher> patternMatchers = new ArrayList<UriPatternMatcher>();
+    List<UriPatternMatcher> patternMatchers = new ArrayList<>();
     for (String pattern : patterns) {
       if (!servletUris.add(pattern)) {
         binder

File: extensions/servlet/test/com/google/inject/servlet/FilterDispatchIntegrationTest.java
Patch:
@@ -285,7 +285,7 @@ private void runRequestForPath(FilterPipeline pipeline, String value, boolean ma
   public static class TestServlet extends HttpServlet {
     public static final String FORWARD_FROM = "/index.html";
     public static final String FORWARD_TO = "/forwarded.html";
-    public List<String> processedUris = new ArrayList<String>();
+    public List<String> processedUris = new ArrayList<>();
 
     @Override
     protected void service(

File: extensions/servlet/test/com/google/inject/servlet/ServletPipelineRequestDispatcherTest.java
Patch:
@@ -142,7 +142,7 @@ public final void testForwardToManagedServlet() throws IOException, ServletExcep
     mockResponse.resetBuffer();
     expectLastCall().once();
 
-    final List<String> paths = new ArrayList<String>();
+    final List<String> paths = new ArrayList<>();
     final HttpServlet mockServlet =
         new HttpServlet() {
           @Override

File: extensions/struts2/src/com/google/inject/struts2/GuiceObjectFactory.java
Patch:
@@ -46,7 +46,7 @@ public class GuiceObjectFactory extends ObjectFactory {
   Module module;
   volatile Injector injector;
   boolean developmentMode = false;
-  List<ProvidedInterceptor> interceptors = new ArrayList<ProvidedInterceptor>();
+  List<ProvidedInterceptor> interceptors = new ArrayList<>();
 
   @Override
   public boolean isNoArgConstructorRequired() {
@@ -71,7 +71,7 @@ void setDevelopmentMode(String developmentMode) {
     this.developmentMode = developmentMode.trim().equals("true");
   }
 
-  Set<Class<?>> boundClasses = new HashSet<Class<?>>();
+  Set<Class<?>> boundClasses = new HashSet<>();
 
   @Override
   public Class getClassInstance(String name) throws ClassNotFoundException {

File: extensions/struts2/src/com/google/inject/struts2/Struts2Factory.java
Patch:
@@ -51,7 +51,7 @@ public class Struts2Factory extends ObjectFactory {
 
   private static @com.google.inject.Inject Injector injector;
 
-  private final List<ProvidedInterceptor> interceptors = new ArrayList<ProvidedInterceptor>();
+  private final List<ProvidedInterceptor> interceptors = new ArrayList<>();
   private volatile Injector strutsInjector;
 
   @Override
@@ -67,7 +67,7 @@ void setModule(String moduleClassName) {
             + " Please install your module via a GuiceServletContextListener instead.");
   }
 
-  Set<Class<?>> boundClasses = new HashSet<Class<?>>();
+  Set<Class<?>> boundClasses = new HashSet<>();
 
   @Override
   public Class<?> getClassInstance(String name) throws ClassNotFoundException {

File: extensions/testlib/test/com/google/inject/testing/fieldbinder/BoundFieldModuleTest.java
Patch:
@@ -512,7 +512,7 @@ private static class ParameterizedObject<T> {
   }
 
   public void testBindParameterizedTypeFails() {
-    ParameterizedObject<Integer> instance = new ParameterizedObject<Integer>(0);
+    ParameterizedObject<Integer> instance = new ParameterizedObject<>(0);
 
     BoundFieldModule module = BoundFieldModule.of(instance);
 

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/TestScope.java
Patch:
@@ -37,7 +37,7 @@ class TestScope implements Scope {
   @ScopeAnnotation
   public @interface Scoped {}
 
-  private Map<Key, Object> inScopeObjectsMap = new HashMap<Key, Object>();
+  private Map<Key, Object> inScopeObjectsMap = new HashMap<>();
 
   @Override
   public <T> Provider<T> scope(final Key<T> key, final Provider<T> provider) {
@@ -56,6 +56,6 @@ public T get() {
   }
 
   public void beginNewScope() {
-    inScopeObjectsMap = new HashMap<Key, Object>();
+    inScopeObjectsMap = new HashMap<>();
   }
 }

File: core/src/com/google/inject/internal/MultibindingsMethodScanner.java
Patch:
@@ -40,13 +40,14 @@
  */
 public final class MultibindingsMethodScanner extends ModuleAnnotatedMethodScanner {
   public static final MultibindingsMethodScanner INSTANCE = new MultibindingsMethodScanner();
+  private static final ImmutableSet<Class<? extends Annotation>> ANNOTATIONS =
+      ImmutableSet.of(ProvidesIntoSet.class, ProvidesIntoMap.class, ProvidesIntoOptional.class);
 
   private MultibindingsMethodScanner() {}
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotationClasses() {
-    return ImmutableSet.of(
-        ProvidesIntoSet.class, ProvidesIntoMap.class, ProvidesIntoOptional.class);
+    return ANNOTATIONS;
   }
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // mapKey doesn't know its key type

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -106,14 +106,13 @@ public final class InjectionPoint {
   private ImmutableList<Dependency<?>> forMember(
       Member member, TypeLiteral<?> type, Annotation[][] paramterAnnotations) {
     Errors errors = new Errors(member);
-    Iterator<Annotation[]> annotationsIterator = Arrays.asList(paramterAnnotations).iterator();
 
     List<Dependency<?>> dependencies = Lists.newArrayList();
     int index = 0;
 
     for (TypeLiteral<?> parameterType : type.getParameterTypes(member)) {
       try {
-        Annotation[] parameterAnnotations = annotationsIterator.next();
+        Annotation[] parameterAnnotations = paramterAnnotations[index];
         Key<?> key = Annotations.getKey(parameterType, member, parameterAnnotations, errors);
         dependencies.add(newDependency(key, Nullability.allowsNull(parameterAnnotations), index));
         index++;

File: extensions/struts2/test/com/google/inject/struts2/Struts2FactoryTest.java
Patch:
@@ -52,7 +52,8 @@ protected Injector getInjector() {
             @Override
             protected void configureServlets() {
               // Struts 2 setup
-              bind(StrutsPrepareAndExecuteFilter.class).in(Singleton.class);
+              bind(StrutsPrepareAndExecuteFilter.class)
+                  .in(com.google.inject.Singleton.class);
               filter("/*").through(StrutsPrepareAndExecuteFilter.class);
             }
           },

File: core/src/com/google/inject/internal/CreationListener.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -21,4 +21,4 @@ interface CreationListener {
 
   /** Notifies that creation should happen. */
   void notify(Errors errors);
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/internal/ErrorsException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +14,6 @@
  * limitations under the License.
  */
 
-
 package com.google.inject.internal;
 
 /**

File: core/src/com/google/inject/internal/ExposedKeyFactory.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/internal/InternalFactory.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -27,9 +27,9 @@ interface InternalFactory<T> {
 
   /**
    * Creates an object to be injected.
+   *
    * @param context of this injection
    * @param linked true if getting as a result of a linked binding
-   *
    * @throws com.google.inject.internal.ErrorsException if a value cannot be provided
    * @return instance to be injected
    */

File: core/src/com/google/inject/internal/InternalFlags.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2013 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/internal/Lookups.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2009 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/internal/ModuleAnnotatedMethodScannerProcessor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2015 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -29,7 +29,8 @@ final class ModuleAnnotatedMethodScannerProcessor extends AbstractProcessor {
     super(errors);
   }
 
-  @Override public Boolean visit(ModuleAnnotatedMethodScannerBinding command) {
+  @Override
+  public Boolean visit(ModuleAnnotatedMethodScannerBinding command) {
     injector.state.addScanner(command);
     return true;
   }

File: core/src/com/google/inject/internal/UntargettedBindingProcessor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -25,11 +25,11 @@
  * @author sameb@google.com (Sam Berlin)
  */
 class UntargettedBindingProcessor extends AbstractBindingProcessor {
-  
+
   UntargettedBindingProcessor(Errors errors, ProcessedBindingData bindingData) {
     super(errors, bindingData);
   }
-  
+
   @Override
   public <T> Boolean visit(Binding<T> binding) {
     return binding.acceptTargetVisitor(

File: core/src/com/google/inject/internal/package-info.java
Patch:
@@ -14,7 +14,5 @@
  * limitations under the License.
  */
 
-/**
- * <i>Guice</i> (sounds like like "juice")
- */
+/** <i>Guice</i> (sounds like "juice") */
 package com.google.inject.internal;

File: extensions/jmx/src/com/google/inject/tools/jmx/ManagedBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/jmx/src/com/google/inject/tools/jmx/package-info.java
Patch:
@@ -14,7 +14,5 @@
  * limitations under the License.
  */
 
-/**
- * JMX integration; this extension requires {@code guice-jmx.jar}.
- */
+/** JMX integration; this extension requires {@code guice-jmx.jar}. */
 package com.google.inject.tools.jmx;

File: core/src/com/google/inject/ConfigurationException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/CreationException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.Errors;
 import com.google.inject.spi.Message;
-
 import java.util.Collection;
 
 /**
@@ -46,7 +45,8 @@ public Collection<Message> getErrorMessages() {
     return messages;
   }
 
-  @Override public String getMessage() {
+  @Override
+  public String getMessage() {
     return Errors.format("Unable to create injector, see the following errors", messages);
   }
 

File: core/src/com/google/inject/MembersInjector.java
Patch:
@@ -21,7 +21,6 @@
  * presence or absence of an injectable constructor.
  *
  * @param <T> type to inject members of
- *
  * @author crazybob@google.com (Bob Lee)
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: core/src/com/google/inject/OutOfScopeException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2007 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,8 +17,8 @@
 package com.google.inject;
 
 /**
- * Thrown from {@link Provider#get} when an attempt is made to access a scoped
- * object while the scope in question is not currently active.
+ * Thrown from {@link Provider#get} when an attempt is made to access a scoped object while the
+ * scope in question is not currently active.
  *
  * @author kevinb@google.com (Kevin Bourrillion)
  * @since 2.0

File: extensions/grapher/src/com/google/inject/grapher/Alias.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/src/com/google/inject/grapher/AliasCreator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/src/com/google/inject/grapher/EdgeCreator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/src/com/google/inject/grapher/NodeCreator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/src/com/google/inject/grapher/RootKeySetCreator.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/test/com/google/inject/example/JndiProviderClient.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -22,7 +22,6 @@
 import com.google.inject.CreationException;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
-
 import javax.naming.Context;
 import javax.naming.InitialContext;
 import javax.sql.DataSource;

File: examples/src/example/xml/Contact.java
Patch:
@@ -1,5 +1,3 @@
 package example.xml;
 
-public class Contact {
-
-}
+public class Contact {}

File: examples/src/example/xml/FromFlash.java
Patch:
@@ -1,7 +1,8 @@
 package example.xml;
 
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.*;
 
+import java.lang.annotation.Retention;
+
 @Retention(RUNTIME)
-public @interface FromFlash {}
\ No newline at end of file
+public @interface FromFlash {}

File: examples/src/example/xml/FromSim.java
Patch:
@@ -1,7 +1,8 @@
 package example.xml;
 
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.*;
 
+import java.lang.annotation.Retention;
+
 @Retention(RUNTIME)
 public @interface FromSim {}

File: examples/src/example/xml/SimCard.java
Patch:
@@ -7,4 +7,4 @@ public class SimCard implements Contacts {
   public Iterable<Contact> findByName(String name) {
     return Collections.emptyList();
   }
-}
\ No newline at end of file
+}

File: extensions/persist/src/com/google/inject/persist/jpa/Jpa.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,7 +17,6 @@
 package com.google.inject.persist.jpa;
 
 import com.google.inject.BindingAnnotation;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -27,4 +26,5 @@
  * @author dhanji@gmail.com (Dhanji R. Prasanna)
  */
 @Retention(RetentionPolicy.RUNTIME)
-@BindingAnnotation @interface Jpa {}
+@BindingAnnotation
+@interface Jpa {}

File: extensions/grapher/test/com/google/inject/grapher/demo/DanceParty.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/test/com/google/inject/grapher/demo/DancePartyFactory.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/test/com/google/inject/grapher/demo/DancePartyImpl.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/test/com/google/inject/grapher/demo/DeLorian.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -21,11 +21,11 @@
 
 class DeLorian {
   // We @Inject a Provider to demonstrate that the graph doesn't differentiate
-  // between a Provider<T> and just @Injecting T. 
+  // between a Provider<T> and just @Injecting T.
   @Inject @Driver Provider<Person> driver;
   @Inject FluxCapacitor fluxCapacitor;
   @Inject PrivateTestModule.Exposed exposed;
-  
+
   @Inject
   public void setEnergySource(EnergySource energySource) {}
 }

File: extensions/grapher/test/com/google/inject/grapher/demo/DocBrown.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/test/com/google/inject/grapher/demo/EnergySource.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,4 +19,4 @@
 import com.google.inject.ProvidedBy;
 
 @ProvidedBy(EnergySourceProvider.class)
-interface EnergySource {}
\ No newline at end of file
+interface EnergySource {}

File: extensions/grapher/test/com/google/inject/grapher/demo/FluxCapacitor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,4 +16,4 @@
 
 package com.google.inject.grapher.demo;
 
-class FluxCapacitor {}
\ No newline at end of file
+class FluxCapacitor {}

File: extensions/grapher/test/com/google/inject/grapher/demo/MartyMcFly.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,4 +16,4 @@
 
 package com.google.inject.grapher.demo;
 
-class MartyMcFly implements Person {}
\ No newline at end of file
+class MartyMcFly implements Person {}

File: extensions/grapher/test/com/google/inject/grapher/demo/MultibinderModule.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/test/com/google/inject/grapher/demo/Person.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,4 +16,4 @@
 
 package com.google.inject.grapher.demo;
 
-interface Person {}
\ No newline at end of file
+interface Person {}

File: extensions/grapher/test/com/google/inject/grapher/demo/PinballParts.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/test/com/google/inject/grapher/demo/Plutonium.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,4 +16,4 @@
 
 package com.google.inject.grapher.demo;
 
-class Plutonium implements EnergySource {}
\ No newline at end of file
+class Plutonium implements EnergySource {}

File: extensions/grapher/test/com/google/inject/grapher/demo/PlutoniumProvider.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -20,7 +20,8 @@
 import com.google.inject.Provider;
 
 class PlutoniumProvider implements Provider<Plutonium> {
-  @Inject public PlutoniumProvider(@Inventor Person inventor, @Used PinballParts parts) {}
+  @Inject
+  public PlutoniumProvider(@Inventor Person inventor, @Used PinballParts parts) {}
 
   @Override
   public Plutonium get() {

File: core/src/com/google/inject/name/Named.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,7 +19,6 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.inject.BindingAnnotation;
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -30,7 +29,7 @@
  * @author crazybob@google.com (Bob Lee)
  */
 @Retention(RUNTIME)
-@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
+@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
 @BindingAnnotation
 public @interface Named {
   String value();

File: core/src/com/google/inject/name/NamedImpl.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/persist/src/com/google/inject/persist/finder/DynamicFinder.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/struts2/example/src/com/google/inject/struts2/example/Count.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,9 +16,10 @@
 
 package com.google.inject.struts2.example;
 
-import com.google.inject.Inject;
 import static com.opensymphony.xwork2.Action.SUCCESS;
 
+import com.google.inject.Inject;
+
 public class Count {
 
   final Counter counter;

File: extensions/persist/test/com/google/inject/persist/jpa/JpaTestEntity.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -26,7 +26,8 @@ public class JpaTestEntity {
   private Long id;
   private String text;
 
-  @Id @GeneratedValue
+  @Id
+  @GeneratedValue
   public Long getId() {
     return id;
   }

File: extensions/servlet/src/com/google/inject/servlet/InstanceFilterBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,7 +19,7 @@
 import javax.servlet.Filter;
 
 /**
- * A binding to a single instance of a filter. 
+ * A binding to a single instance of a filter.
  *
  * @author sameb@google.com
  * @since 3.0
@@ -28,5 +28,4 @@ public interface InstanceFilterBinding extends ServletModuleBinding {
 
   /** Returns the filter instance that will be used. */
   Filter getFilterInstance();
-
 }

File: extensions/servlet/src/com/google/inject/servlet/InstanceServletBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,7 +19,7 @@
 import javax.servlet.http.HttpServlet;
 
 /**
- * A binding to a single instance of a servlet. 
+ * A binding to a single instance of a servlet.
  *
  * @author sameb@google.com
  * @since 3.0
@@ -28,5 +28,4 @@ public interface InstanceServletBinding extends ServletModuleBinding {
 
   /** Returns the servlet instance that will be used. */
   HttpServlet getServletInstance();
-
 }

File: extensions/servlet/src/com/google/inject/servlet/RequestScoped.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,7 +17,6 @@
 package com.google.inject.servlet;
 
 import com.google.inject.ScopeAnnotation;
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -28,7 +27,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-@Target({ ElementType.TYPE, ElementType.METHOD })
+@Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 @ScopeAnnotation
 public @interface RequestScoped {}

File: extensions/servlet/src/com/google/inject/servlet/ScopingException.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/servlet/src/com/google/inject/servlet/ServletModuleBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -20,7 +20,7 @@
 
 /**
  * A binding created by {@link ServletModule}.
- * 
+ *
  * @author sameb@google.com (Sam Berlin)
  * @since 3.0
  */
@@ -34,7 +34,7 @@ public interface ServletModuleBinding {
 
   /** Returns any context params supplied when creating the binding. */
   Map<String, String> getInitParams();
-  
+
   /** Returns true if the given URI will match this binding. */
   boolean matchesUri(String uri);
 }

File: extensions/servlet/src/com/google/inject/servlet/SessionScoped.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,7 +17,6 @@
 package com.google.inject.servlet;
 
 import com.google.inject.ScopeAnnotation;
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -29,7 +28,7 @@
  * @see com.google.inject.Scopes#SINGLETON
  * @author crazybob@google.com (Bob Lee)
  */
-@Target({ ElementType.TYPE, ElementType.METHOD })
+@Target({ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 @ScopeAnnotation
 public @interface SessionScoped {}

File: extensions/servlet/src/com/google/inject/servlet/package-info.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2006 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -15,8 +15,7 @@
  */
 
 /**
- * Servlet API scopes, bindings and registration; this extension requires {@code
- * guice-servlet.jar}.
+ * Servlet API scopes, bindings and registration; this extension requires {@code guice-servlet.jar}.
  *
  * <p>Apply {@link com.google.inject.servlet.GuiceFilter} to any servlets which will use the servlet
  * scopes. Install {@link com.google.inject.servlet.ServletModule} into your {@link

File: extensions/jndi/src/com/google/inject/jndi/package-info.java
Patch:
@@ -14,7 +14,5 @@
  * limitations under the License.
  */
 
-/**
- * JNDI integration; this extension requires {@code guice-jndi.jar}.
- */
+/** JNDI integration; this extension requires {@code guice-jndi.jar}. */
 package com.google.inject.jndi;

File: extensions/spring/src/com/google/inject/spring/package-info.java
Patch:
@@ -14,7 +14,5 @@
  * limitations under the License.
  */
 
-/**
- * Spring integration; this extension requires {@code guice-spring.jar}.
- */
+/** Spring integration; this extension requires {@code guice-spring.jar}. */
 package com.google.inject.spring;

File: extensions/servlet/test/com/google/inject/servlet/UriPatternTypeTest.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2014 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -14,7 +14,6 @@
  * limitations under the License.
  */
 
-
 package com.google.inject.servlet;
 
 import static junit.framework.Assert.fail;

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/ProviderChecker.java
Patch:
@@ -11,9 +11,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-/**
- * Helper methods to verify the correctness of CheckedProvider interfaces.
- */
+/** Helper methods to verify the correctness of CheckedProvider interfaces. */
 final class ProviderChecker {
 
   private ProviderChecker() {}

File: extensions/grapher/src/com/google/inject/grapher/graphviz/EdgeStyle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,8 +18,8 @@
 
 /**
  * Styles for edges.
- * <p>
- * See: http://www.graphviz.org/doc/info/attrs.html#k:style
+ *
+ * <p>See: http://www.graphviz.org/doc/info/attrs.html#k:style
  *
  * @author phopkins@gmail.com (Pete Hopkins)
  */

File: extensions/grapher/src/com/google/inject/grapher/graphviz/Graphviz.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2011 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: extensions/grapher/src/com/google/inject/grapher/graphviz/NodeStyle.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,8 +18,8 @@
 
 /**
  * Styles for nodes. Similar to {@link EdgeStyle} but with a few more options.
- * <p>
- * See: http://www.graphviz.org/doc/info/attrs.html#k:style
+ *
+ * <p>See: http://www.graphviz.org/doc/info/attrs.html#k:style
  *
  * @author phopkins@gmail.com (Pete Hopkins)
  */

File: extensions/grapher/src/com/google/inject/grapher/graphviz/PortIdFactory.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,8 +19,8 @@
 import java.lang.reflect.Member;
 
 /**
- * Interface for a service that returns Graphviz port IDs, used for naming the
- * rows in {@link com.google.inject.grapher.ImplementationNode}-displaying {@link GraphvizNode}s.
+ * Interface for a service that returns Graphviz port IDs, used for naming the rows in {@link
+ * com.google.inject.grapher.ImplementationNode}-displaying {@link GraphvizNode}s.
  *
  * @author phopkins@gmail.com (Pete Hopkins)
  */

File: extensions/grapher/src/com/google/inject/grapher/graphviz/PortIdFactoryImpl.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/test/com/google/inject/spi/FailingElementVisitor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,7 +19,8 @@
 import junit.framework.AssertionFailedError;
 
 class FailingElementVisitor extends DefaultElementVisitor<Void> {
-  @Override protected Void visitOther(Element element) {
+  @Override
+  protected Void visitOther(Element element) {
     throw new AssertionFailedError();
   }
 }

File: core/test/com/google/inject/spi/FailingTargetVisitor.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,11 +17,11 @@
 package com.google.inject.spi;
 
 import com.google.inject.Binding;
-
 import junit.framework.AssertionFailedError;
 
 public class FailingTargetVisitor<T> extends DefaultBindingTargetVisitor<T, Void> {
-  @Override protected Void visitOther(Binding<? extends T> binding) {
+  @Override
+  protected Void visitOther(Binding<? extends T> binding) {
     throw new AssertionFailedError();
   }
 }

File: core/src/com/google/inject/spi/DisableCircularProxiesOption.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/spi/Element.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -60,5 +60,4 @@ public interface Element {
    *     element.
    */
   void applyTo(Binder binder);
-
 }

File: core/src/com/google/inject/spi/HasDependencies.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -31,7 +31,7 @@ public interface HasDependencies {
    * Returns the known dependencies for this type. If this has dependencies whose values are not
    * known statically, a dependency for the {@link com.google.inject.Injector Injector} will be
    * included in the returned set.
-   * 
+   *
    * @return a possibly empty set
    */
   Set<Dependency<?>> getDependencies();

File: core/src/com/google/inject/spi/LinkedKeyBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -32,5 +32,4 @@ public interface LinkedKeyBinding<T> extends Binding<T> {
    * injector using {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
   Key<? extends T> getLinkedKey();
-
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/spi/ProviderBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -35,4 +35,4 @@ public interface ProviderBinding<T extends Provider<?>> extends Binding<T> {
    * Injector.getBinding(providedKey)}
    */
   Key<?> getProvidedKey();
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/spi/ProviderKeyBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -34,5 +34,4 @@ public interface ProviderKeyBinding<T> extends Binding<T> {
    * Injector.getBinding(providerKey)}
    */
   Key<? extends javax.inject.Provider<? extends T>> getProviderKey();
-
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/spi/ProviderWithDependencies.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/spi/RequireAtInjectOnConstructorsOption.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/spi/RequireExactBindingAnnotationsOption.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/spi/RequireExplicitBindingsOption.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2010 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/spi/ScopeBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -20,13 +20,13 @@
 
 import com.google.inject.Binder;
 import com.google.inject.Scope;
-
 import java.lang.annotation.Annotation;
 
 /**
  * Registration of a scope annotation with the scope that implements it. Instances are created
  * explicitly in a module using {@link com.google.inject.Binder#bindScope(Class, Scope) bindScope()}
  * statements:
+ *
  * <pre>
  *     Scope recordScope = new RecordScope();
  *     bindScope(RecordScoped.class, new RecordScope());</pre>

File: core/src/com/google/inject/spi/TypeConverter.java
Patch:
@@ -26,8 +26,6 @@
  */
 public interface TypeConverter {
 
-  /**
-   * Converts a string value. Throws an exception if a conversion error occurs.
-   */
+  /** Converts a string value. Throws an exception if a conversion error occurs. */
   Object convert(String value, TypeLiteral<?> toType);
 }

File: core/src/com/google/inject/spi/TypeListenerBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2009 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -36,8 +36,8 @@ public final class TypeListenerBinding implements Element {
   private final Matcher<? super TypeLiteral<?>> typeMatcher;
   private final TypeListener listener;
 
-  TypeListenerBinding(Object source, TypeListener listener,
-      Matcher<? super TypeLiteral<?>> typeMatcher) {
+  TypeListenerBinding(
+      Object source, TypeListener listener, Matcher<? super TypeLiteral<?>> typeMatcher) {
     this.source = source;
     this.listener = listener;
     this.typeMatcher = typeMatcher;

File: core/src/com/google/inject/spi/UntargettedBinding.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2008 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/spi/package-info.java
Patch:
@@ -14,7 +14,5 @@
  * limitations under the License.
  */
 
-/**
- * Guice service provider interface
- */
+/** Guice service provider interface */
 package com.google.inject.spi;

File: core/src/com/google/inject/multibindings/ClassMapKey.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2015 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/com/google/inject/multibindings/StringMapKey.java
Patch:
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2015 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/test/com/google/inject/spi/ProviderMethodsTest.java
Patch:
@@ -67,6 +67,7 @@
 /**
  * @author crazybob@google.com (Bob Lee)
  */
+@SuppressWarnings("ProvidesMethodOutsideOfModule")
 public class ProviderMethodsTest extends TestCase implements Module {
 
   @SuppressWarnings("unchecked")

File: extensions/mini/test/com/google/inject/mini/MiniGuiceTest.java
Patch:
@@ -27,6 +27,7 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
+@SuppressWarnings("ProvidesMethodOutsideOfModule")
 public final class MiniGuiceTest extends TestCase {
 
   public void testBasicInjection() {

File: core/test/com/google/inject/ErrorHandlingTest.java
Patch:
@@ -107,7 +107,7 @@ static class Invalid {
   }
 
   // suppress compiler error to test
-  @SuppressWarnings({"MoreThanOneScopeAnnotationOnClass, multiple-scope"})
+  @SuppressWarnings({"MoreThanOneScopeAnnotationOnClass", "multiple-scope"})
   @Singleton
   @GoodScope
   static class TooManyScopes {}

File: core/src/com/google/inject/AbstractModule.java
Patch:
@@ -54,6 +54,7 @@ public abstract class AbstractModule implements Module {
 
   Binder binder;
 
+  @Override
   public final synchronized void configure(Binder builder) {
     checkState(this.binder == null, "Re-entry is not allowed.");
 

File: core/src/com/google/inject/PrivateBinder.java
Patch:
@@ -44,7 +44,9 @@ public interface PrivateBinder extends Binder {
    */
   AnnotatedElementBuilder expose(TypeLiteral<?> type);
 
+  @Override
   PrivateBinder withSource(Object source);
 
+  @Override
   PrivateBinder skipSources(Class... classesToSkip);
 }

File: core/src/com/google/inject/PrivateModule.java
Patch:
@@ -91,6 +91,7 @@ public abstract class PrivateModule implements Module {
   /** Like abstract module, the binder of the current private module */
   private PrivateBinder binder;
 
+  @Override
   public final synchronized void configure(Binder binder) {
     checkState(this.binder == null, "Re-entry is not allowed.");
 

File: core/src/com/google/inject/Provider.java
Patch:
@@ -52,5 +52,6 @@ public interface Provider<T> extends javax.inject.Provider<T> {
    * @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
    *     and throwables to describe why provision failed.
    */
+  @Override
   T get();
 }

File: core/src/com/google/inject/Scope.java
Patch:
@@ -50,10 +50,10 @@ public interface Scope {
   public <T> Provider<T> scope(Key<T> key, Provider<T> unscoped);
 
   /**
-   * A short but useful description of this scope.  For comparison, the standard
-   * scopes that ship with guice use the descriptions
-   * {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
+   * A short but useful description of this scope. For comparison, the standard scopes that ship
+   * with guice use the descriptions {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
    * {@code "ServletScopes.REQUEST"}.
    */
+  @Override
   String toString();
 }

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -45,6 +45,7 @@ final class BoundProviderFactory<T> extends ProviderInternalFactory<T> implement
     this.providerKey = providerKey;
   }
 
+  @Override
   public void notify(Errors errors) {
     try {
       providerFactory = injector.getInternalFactory(providerKey, errors.withSource(source), JitLimitation.NEW_OR_EXISTING_JIT);
@@ -53,6 +54,7 @@ public void notify(Errors errors) {
     }
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
     context.pushState(providerKey, source);

File: core/src/com/google/inject/internal/ConstantFactory.java
Patch:
@@ -30,11 +30,13 @@ public ConstantFactory(Initializable<T> initializable) {
     this.initializable = initializable;
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
       throws ErrorsException {
     return initializable.get(errors);
   }
 
+  @Override
   public String toString() {
     return MoreObjects.toStringHelper(ConstantFactory.class)
         .add("value", initializable)

File: core/src/com/google/inject/internal/DeferredLookups.java
Patch:
@@ -49,12 +49,14 @@ void initialize(Errors errors) {
     new LookupProcessor(errors).process(injector, lookups);
   }
 
+  @Override
   public <T> Provider<T> getProvider(Key<T> key) {
     ProviderLookup<T> lookup = new ProviderLookup<T>(key, key);
     lookups.add(lookup);
     return lookup.getProvider();
   }
 
+  @Override
   public <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> type) {
     MembersInjectorLookup<T> lookup = new MembersInjectorLookup<T>(type, type);
     lookups.add(lookup);

File: core/src/com/google/inject/internal/DelegatingInvocationHandler.java
Patch:
@@ -29,8 +29,8 @@ class DelegatingInvocationHandler<T> implements InvocationHandler {
 
   private T delegate;
 
-  public Object invoke(Object proxy, Method method, Object[] args)
-      throws Throwable {
+  @Override
+  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
     try {
       // checking volatile field for synchronization
       Preconditions.checkState(initialized,

File: core/src/com/google/inject/internal/ExposedKeyFactory.java
Patch:
@@ -34,6 +34,7 @@ final class ExposedKeyFactory<T> implements InternalFactory<T>, CreationListener
     this.privateElements = privateElements;
   }
 
+  @Override
   public void notify(Errors errors) {
     InjectorImpl privateInjector = (InjectorImpl) privateElements.getInjector();
     BindingImpl<T> explicitBinding = privateInjector.state.getExplicitBinding(key);
@@ -49,6 +50,7 @@ public void notify(Errors errors) {
     this.delegate = explicitBinding;
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
     return delegate.getInternalFactory().get(errors, context, dependency, linked);

File: core/src/com/google/inject/internal/ExposureBuilder.java
Patch:
@@ -43,12 +43,14 @@ protected void checkNotAnnotated() {
     }
   }
 
+  @Override
   public void annotatedWith(Class<? extends Annotation> annotationType) {
     Preconditions.checkNotNull(annotationType, "annotationType");
     checkNotAnnotated();
     key = Key.get(key.getTypeLiteral(), annotationType);
   }
 
+  @Override
   public void annotatedWith(Annotation annotation) {
     Preconditions.checkNotNull(annotation, "annotation");
     checkNotAnnotated();

File: core/src/com/google/inject/internal/FactoryProxy.java
Patch:
@@ -41,6 +41,7 @@ final class FactoryProxy<T> implements InternalFactory<T>, CreationListener {
     this.source = source;
   }
 
+  @Override
   public void notify(final Errors errors) {
     try {
       targetFactory = injector.getInternalFactory(targetKey, errors.withSource(source), JitLimitation.NEW_OR_EXISTING_JIT);
@@ -49,6 +50,7 @@ public void notify(final Errors errors) {
     }
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
     Key<? extends T> localTargetKey = targetKey;

File: core/src/com/google/inject/internal/Initializables.java
Patch:
@@ -26,11 +26,13 @@ final class Initializables {
    */
   static <T> Initializable<T> of(final T instance) {
     return new Initializable<T>() {
+      @Override
       public T get(Errors errors) throws ErrorsException {
         return instance;
       }
 
-      @Override public String toString() {
+      @Override
+      public String toString() {
         return String.valueOf(instance);
       }
     };

File: core/src/com/google/inject/internal/Initializer.java
Patch:
@@ -174,6 +174,7 @@ public void validate(Errors errors) throws ErrorsException {
      * Reentrant. If {@code instance} was registered for injection at injector-creation time, this
      * method will ensure that all its members have been injected before returning.
      */
+    @Override
     public T get(Errors errors) throws ErrorsException {
       // skipping acquiring lock if initialization is already finished
       if (state == InjectableReferenceState.READY) {

File: core/src/com/google/inject/internal/InternalFactoryToInitializableAdapter.java
Patch:
@@ -40,6 +40,7 @@ public InternalFactoryToInitializableAdapter(
     this.initializable = checkNotNull(initializable, "provider");
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
     return circularGet(initializable.get(errors), errors, context, dependency,

File: core/src/com/google/inject/internal/InternalFactoryToProviderAdapter.java
Patch:
@@ -34,6 +34,7 @@ public InternalFactoryToProviderAdapter(Provider<? extends T> provider, Object s
     this.source = checkNotNull(source, "source");
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
     // TODO(sameb): Does this need to push state into the context?

File: core/src/com/google/inject/internal/MembersInjectorImpl.java
Patch:
@@ -62,6 +62,7 @@ public ImmutableList<SingleMemberInjector> getMemberInjectors() {
     return memberInjectors == null ? ImmutableList.<SingleMemberInjector>of() : memberInjectors;
   }
 
+  @Override
   public void injectMembers(T instance) {
     TypeLiteral<T> localTypeLiteral = typeLiteral;
     Errors errors = new Errors(localTypeLiteral);

File: core/src/com/google/inject/internal/ProvidedByInternalFactory.java
Patch:
@@ -54,11 +54,13 @@ void setProvisionListenerCallback(ProvisionListenerStackCallback<T> listener) {
     provisionCallback = listener;
   }
   
+  @Override
   public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
     providerBinding =
         injector.getBindingOrThrow(providerKey, errors, JitLimitation.NEW_OR_EXISTING_JIT);
   }
 
+  @Override
   public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
       throws ErrorsException {
     BindingImpl<? extends Provider<T>> localProviderBinding = providerBinding;

File: core/src/com/google/inject/internal/SingleFieldInjector.java
Patch:
@@ -42,10 +42,12 @@ public SingleFieldInjector(InjectorImpl injector, InjectionPoint injectionPoint,
     binding = injector.getBindingOrThrow(dependency.getKey(), errors, JitLimitation.NO_JIT);
   }
 
+  @Override
   public InjectionPoint getInjectionPoint() {
     return injectionPoint;
   }
 
+  @Override
   public void inject(Errors errors, InternalContext context, Object o) {
     errors = errors.withSource(dependency);
 

File: core/src/com/google/inject/spi/ConvertedConstantBinding.java
Patch:
@@ -48,8 +48,7 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
    */
   Key<String> getSourceKey();
 
-  /**
-   * Returns a singleton set containing only the converted key.
-   */
+  /** Returns a singleton set containing only the converted key. */
+  @Override
   Set<Dependency<?>> getDependencies();
 }

File: core/src/com/google/inject/spi/DisableCircularProxiesOption.java
Patch:
@@ -33,14 +33,17 @@ public final class DisableCircularProxiesOption implements Element {
     this.source = checkNotNull(source, "source");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).disableCircularProxies();
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }

File: core/src/com/google/inject/spi/ExposedBinding.java
Patch:
@@ -32,8 +32,7 @@ public interface ExposedBinding<T> extends Binding<T>, HasDependencies {
    */
   PrivateElements getPrivateElements();
 
-  /**
-   * Unsupported. Always throws {@link UnsupportedOperationException}.
-   */
+  /** Unsupported. Always throws {@link UnsupportedOperationException}. */
+  @Override
   void applyTo(Binder binder);
 }
\ No newline at end of file

File: core/src/com/google/inject/spi/InjectionRequest.java
Patch:
@@ -46,6 +46,7 @@ public InjectionRequest(Object source, TypeLiteral<T> type, T instance) {
     this.instance = checkNotNull(instance, "instance");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
@@ -74,10 +75,12 @@ public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException {
     return InjectionPoint.forInstanceMethodsAndFields(instance.getClass());
   }
 
+  @Override
   public <R> R acceptVisitor(ElementVisitor<R> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).requestInjection(type, instance);
   }

File: core/src/com/google/inject/spi/InterceptorBinding.java
Patch:
@@ -59,6 +59,7 @@ public final class InterceptorBinding implements Element {
     this.interceptors = ImmutableList.copyOf(interceptors);
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
@@ -75,10 +76,12 @@ public List<MethodInterceptor> getInterceptors() {
     return interceptors;
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).bindInterceptor(classMatcher, methodMatcher,
         interceptors.toArray(new MethodInterceptor[interceptors.size()]));

File: core/src/com/google/inject/spi/Message.java
Patch:
@@ -70,6 +70,7 @@ public Message(String message) {
     this(ImmutableList.of(), message, null);
   }
 
+  @Override
   public String getSource() {
     return sources.isEmpty()
         ? SourceProvider.UNKNOWN_SOURCE.toString()
@@ -89,6 +90,7 @@ public String getMessage() {
   }
 
   /** @since 2.0 */
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }
@@ -120,6 +122,7 @@ public Throwable getCause() {
   }
 
   /** @since 2.0 */
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).addError(this);
   }

File: core/src/com/google/inject/spi/ModuleAnnotatedMethodScannerBinding.java
Patch:
@@ -36,6 +36,7 @@ public ModuleAnnotatedMethodScannerBinding(Object source, ModuleAnnotatedMethodS
     this.scanner = checkNotNull(scanner, "scanner");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
@@ -44,10 +45,12 @@ public ModuleAnnotatedMethodScanner getScanner() {
     return scanner;
   }
   
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).scanModulesForAnnotatedMethods(scanner);
   }

File: core/src/com/google/inject/spi/ProvisionListenerBinding.java
Patch:
@@ -56,14 +56,17 @@ public Matcher<? super Binding<?>> getBindingMatcher() {
     return bindingMatcher;
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
 
+  @Override
   public <R> R acceptVisitor(ElementVisitor<R> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).bindListener(bindingMatcher,
         listeners.toArray(new ProvisionListener[listeners.size()]));

File: core/src/com/google/inject/spi/RequireAtInjectOnConstructorsOption.java
Patch:
@@ -34,14 +34,17 @@ public final class RequireAtInjectOnConstructorsOption implements Element {
     this.source = checkNotNull(source, "source");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).requireAtInjectOnConstructors();
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }

File: core/src/com/google/inject/spi/RequireExactBindingAnnotationsOption.java
Patch:
@@ -33,14 +33,17 @@ public final class RequireExactBindingAnnotationsOption implements Element {
     this.source = checkNotNull(source, "source");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).requireExactBindingAnnotations();
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }

File: core/src/com/google/inject/spi/RequireExplicitBindingsOption.java
Patch:
@@ -33,14 +33,17 @@ public final class RequireExplicitBindingsOption implements Element {
     this.source = checkNotNull(source, "source");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).requireExplicitBindings();
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }

File: core/src/com/google/inject/spi/ScopeBinding.java
Patch:
@@ -45,6 +45,7 @@ public final class ScopeBinding implements Element {
     this.scope = checkNotNull(scope, "scope");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
@@ -57,10 +58,12 @@ public Scope getScope() {
     return scope;
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).bindScope(annotationType, scope);
   }

File: core/src/com/google/inject/spi/StaticInjectionRequest.java
Patch:
@@ -42,6 +42,7 @@ public final class StaticInjectionRequest implements Element {
     this.type = checkNotNull(type, "type");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
@@ -66,10 +67,12 @@ public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException {
     return InjectionPoint.forStaticMethodsAndFields(type);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).requestStaticInjection(type);
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }

File: core/src/com/google/inject/spi/TypeConverterBinding.java
Patch:
@@ -46,6 +46,7 @@ public TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeM
     this.typeConverter = checkNotNull(typeConverter, "typeConverter");
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
@@ -58,10 +59,12 @@ public TypeConverter getTypeConverter() {
     return typeConverter;
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
   }

File: core/src/com/google/inject/spi/TypeListenerBinding.java
Patch:
@@ -53,14 +53,17 @@ public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
     return typeMatcher;
   }
 
+  @Override
   public Object getSource() {
     return source;
   }
 
+  @Override
   public <T> T acceptVisitor(ElementVisitor<T> visitor) {
     return visitor.visit(this);
   }
 
+  @Override
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).bindListener(typeMatcher, listener);
   }

File: core/src/com/google/inject/util/Providers.java
Patch:
@@ -61,6 +61,7 @@ private ConstantProvider(T instance) {
       this.instance = instance;
     }
 
+    @Override
     public T get() {
       return instance;
     }
@@ -115,6 +116,7 @@ private GuicifiedProvider(javax.inject.Provider<T> delegate) {
       this.delegate = delegate;
     }
 
+    @Override
     public T get() {
       return delegate.get();
     }
@@ -149,6 +151,7 @@ void initialize(Injector injector) {
       injector.injectMembers(delegate);
     }
 
+    @Override
     public Set<Dependency<?>> getDependencies() {
       return dependencies;
     }

File: core/test/com/google/inject/KeyTest.java
Patch:
@@ -234,7 +234,7 @@ interface B {}
   @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
   @BindingAnnotation @interface Bar {}
 
-  class HasTypeParameters<A, B extends List<A> & Runnable, C extends Runnable> {
+  static class HasTypeParameters<A, B extends List<A> & Runnable, C extends Runnable> {
     A a; B b; C c;
   }
 
@@ -278,7 +278,7 @@ public void testKeysWithDefaultAnnotations() {
 
   @AllDefaults
   @Marker
-  class HasAnnotations {}
+  static class HasAnnotations {}
 
   public void testAnonymousClassesDontHoldRefs() {
     final AtomicReference<Provider<List<String>>> stringProvider =

File: core/test/com/google/inject/ModulesTest.java
Patch:
@@ -70,6 +70,7 @@ public void testCombineSources() {
 
   private <T> Module newModule(final T toBind) {
     return new AbstractModule() {
+      @Override
       protected void configure() {
         @SuppressWarnings("unchecked") // getClass always needs a cast
         Class<T> tClass = (Class<T>) toBind.getClass();

File: core/test/com/google/inject/ProvisionExceptionTest.java
Patch:
@@ -393,6 +393,7 @@ static class QuadrupleSameFailure {
     @Inject QuadrupleSameFailure(Integer i1, Integer i2, String s1, String s2) { }
   }
   
+  @SuppressWarnings("ClassCanBeStatic")
   private class InnerClass {}
 
   static class A {
@@ -446,6 +447,7 @@ static class RealD implements D {
   }
 
   static class DProvider implements Provider<D> {
+    @Override
     public D get() {
       throw new UnsupportedOperationException();
     }
@@ -458,6 +460,7 @@ static class F {
   }
 
   static class FProvider implements Provider<F> {
+    @Override
     public F get() {
       return new F();
     }

File: core/test/com/google/inject/TypeLiteralTest.java
Patch:
@@ -192,7 +192,7 @@ public void testTypeVariableWithMultipleBounds() {
     assertEqualsBothWays(bTl, TypeLiteral.get(HasTypeParameters.class.getTypeParameters()[1]));
   }
 
-  class HasTypeParameters<A, B extends List<A> & Runnable, C extends Runnable> {
+  static class HasTypeParameters<A, B extends List<A> & Runnable, C extends Runnable> {
     A a; B b; C c;
   }
 }

File: core/test/com/google/inject/TypeLiteralTypeResolutionTest.java
Patch:
@@ -122,6 +122,7 @@ interface MyComparable<E extends MyComparable<E>> extends Comparable<E> {}
 
   static class MyInteger implements MyComparable<MyInteger> {
     int value;
+    @Override
     public int compareTo(MyInteger o) {
       return value - o.value;
     }

File: core/test/com/google/inject/example/JndiProvider.java
Patch:
@@ -33,6 +33,7 @@ class JndiProvider<T> implements Provider<T> {
     this.type = type;
   }
 
+  @Override
   public T get() {
     try {
       return type.cast(context.lookup(name));

File: core/test/com/google/inject/internal/OptionalBinderTest.java
Patch:
@@ -1090,12 +1090,14 @@ public void testModuleOverrideRepeatedInstalls_toProviderInstance() {
   }
 
   private static class AStringProvider implements Provider<String> {
+    @Override
     public String get() {
       return "A";
     }
   }
 
   private static class BStringProvider implements Provider<String> {
+    @Override
     public String get() {
       return "B";
     }

File: core/test/com/google/inject/internal/ProxyFactoryTest.java
Patch:
@@ -69,6 +69,7 @@ static class SimpleInterceptor implements MethodInterceptor {
 
     boolean invoked = false;
 
+    @Override
     public Object invoke(MethodInvocation methodInvocation) throws Throwable {
       invoked = true;
       return methodInvocation.proceed();
@@ -186,6 +187,7 @@ static class CountingInterceptor implements MethodInterceptor {
 
     int count;
 
+    @Override
     public Object invoke(MethodInvocation methodInvocation) throws Throwable {
       count++;
       return methodInvocation.proceed();
@@ -194,6 +196,7 @@ public Object invoke(MethodInvocation methodInvocation) throws Throwable {
 
   static class DoubleInterceptor implements MethodInterceptor {
 
+    @Override
     public Object invoke(MethodInvocation methodInvocation) throws Throwable {
       methodInvocation.proceed();
       return methodInvocation.proceed();

File: core/test/com/google/inject/internal/SpiUtils.java
Patch:
@@ -1160,14 +1160,17 @@ public String toString() {
   private static class Visitor<T> extends
       DefaultBindingTargetVisitor<T, Object> implements MultibindingsTargetVisitor<T, Object> {
   
+    @Override
     public Object visit(MultibinderBinding<? extends T> multibinding) {
       return multibinding;
     }
   
+    @Override
     public Object visit(MapBinderBinding<? extends T> mapbinding) {
       return mapbinding;
     }
     
+    @Override
     public Object visit(OptionalBinderBinding<? extends T> optionalbinding) {
       return optionalbinding;
     }

File: core/test/com/google/inject/spi/ToolStageInjectorTest.java
Patch:
@@ -139,6 +139,7 @@ private static class Foo implements Provider<Object> {
     private static SM sm;
     @SuppressWarnings("unused") @Inject static void staticMethod(SM sm) { Tooled.sm = sm; }
     
+    @Override
     public Object get() {
       return null;
     }
@@ -152,6 +153,7 @@ private static class Tooled implements Provider<Object> {
     private static SM sm;
     @Toolable @SuppressWarnings("unused") @Inject static void staticMethod(SM sm) { Tooled.sm = sm; }
     
+    @Override
     public Object get() {
       return null;
     }

File: core/test/com/google/inject/util/NoopOverrideTest.java
Patch:
@@ -25,6 +25,7 @@
  */
 public class NoopOverrideTest extends ElementsTest {
 
+  @Override
   protected void checkModule(Module module, ElementVisitor<?>... visitors) {
     Module overridden = Modules.override(module).with(Modules.EMPTY_MODULE);
     super.checkModule(overridden, visitors);

File: core/test/com/google/inject/util/ProvidersTest.java
Patch:
@@ -75,6 +75,7 @@ public JavaxProvider(int value) {
       this.value = value;
     }
     
+    @Override
     public Integer get() {
       return value;
     }
@@ -95,6 +96,7 @@ private static class JavaxProviderWithDependencies implements javax.inject.Provi
       this.value = value;
     }
     
+    @Override
     public Integer get() {
       return value;
     }

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryModuleBuilderTest.java
Patch:
@@ -40,13 +40,11 @@
 import com.google.inject.spi.Elements;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.Message;
-
-import junit.framework.TestCase;
-
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import junit.framework.TestCase;
 
 public class FactoryModuleBuilderTest extends TestCase {
   
@@ -492,6 +490,7 @@ protected void configure() {
               .build(NotHidden.class));
         }
       });
+      fail("Expected CreationException");
     } catch(CreationException ce) {
       assertEquals(NotHidden.class.getName() + " is public, but has a method that returns a non-public type: "
           + Hidden.class.getName() + ". Due to limitations with java.lang.reflect.Proxy, this is not allowed. "

File: extensions/grapher/src/com/google/inject/grapher/graphviz/PortIdFactoryImpl.java
Patch:
@@ -24,6 +24,7 @@
  * @author phopkins@gmail.com (Pete Hopkins)
  */
 public class PortIdFactoryImpl implements PortIdFactory {
+  @Override
   public String getPortId(Member member) {
     return "m_" + Integer.toHexString(member.hashCode());
   }

File: extensions/grapher/test/com/google/inject/grapher/TransitiveDependencyVisitorTest.java
Patch:
@@ -162,6 +162,7 @@ private static class ConstructedClassProvider implements Provider<ConstructedCla
     @Inject ConstructedClassProvider(A a, B b, C c) {}
     @Inject void setF(F f) {}
     
+    @Override
     public ConstructedClass get() {
       return null;
     }
@@ -171,6 +172,7 @@ private static class HasDependenciesClass implements Interface, HasDependencies
     @Inject A a;
     @Inject B b;
     
+    @Override
     public Set<Dependency<?>> getDependencies() {
       return ImmutableSet.<Dependency<?>>of(Dependency.get(Key.get(G.class)));
     }

File: extensions/grapher/test/com/google/inject/grapher/demo/EnergySourceProvider.java
Patch:
@@ -26,6 +26,7 @@ class EnergySourceProvider implements Provider<EnergySource> {
   // This will demonstrate a ConvertedConstantBinding.
   @Inject void setYear(@Named("year") int year) {}
   
+  @Override
   public EnergySource get() {
     return null;
   }

File: extensions/grapher/test/com/google/inject/grapher/demo/PlutoniumProvider.java
Patch:
@@ -22,6 +22,7 @@
 class PlutoniumProvider implements Provider<Plutonium> {
   @Inject public PlutoniumProvider(@Inventor Person inventor, @Used PinballParts parts) {}
 
+  @Override
   public Plutonium get() {
     return null;
   }

File: extensions/jmx/src/com/google/inject/tools/jmx/ManagedBinding.java
Patch:
@@ -26,14 +26,17 @@ class ManagedBinding implements ManagedBindingMBean {
     this.binding = binding;
   }
 
+  @Override
   public String getSource() {
     return binding.getSource().toString();
   }
 
+  @Override
   public String getKey() {
     return binding.getKey().toString();
   }
 
+  @Override
   public String getProvider() {
     return binding.getProvider().toString();
   }

File: extensions/jmx/test/com/google/inject/tools/jmx/JmxTest.java
Patch:
@@ -49,6 +49,7 @@ public static void main(String[] args) throws Exception {
   
   public static class TestModule extends AbstractModule {
 
+    @Override
     protected void configure() {
       bind(Foo.class).to(FooImpl.class);
       bind(Bar.class);

File: extensions/jndi/src/com/google/inject/jndi/JndiIntegration.java
Patch:
@@ -55,6 +55,7 @@ public JndiProvider(Class<T> type, String name) {
       this.name = name;
     }
 
+    @Override
     public T get() {
       try {
         return type.cast(context.lookup(name));

File: extensions/persist/src/com/google/inject/persist/jpa/JpaFinderProxy.java
Patch:
@@ -54,6 +54,7 @@ public JpaFinderProxy(Provider<EntityManager> emProvider) {
     this.emProvider = emProvider;
   }
 
+  @Override
   public Object invoke(MethodInvocation methodInvocation) throws Throwable {
     EntityManager em = emProvider.get();
 

File: extensions/persist/src/com/google/inject/persist/jpa/JpaLocalTxnInterceptor.java
Patch:
@@ -46,6 +46,7 @@ private static class Internal {}
   // Tracks if the unit of work was begun implicitly by this transaction.
   private final ThreadLocal<Boolean> didWeStartWork = new ThreadLocal<Boolean>();
 
+  @Override
   public Object invoke(MethodInvocation methodInvocation) throws Throwable {
 
     // Should we start a unit of work?

File: extensions/persist/test/com/google/inject/persist/jpa/ClassLevelManagedLocalTransactionsTest.java
Patch:
@@ -47,13 +47,15 @@ public class ClassLevelManagedLocalTransactionsTest extends TestCase {
   private static final String TRANSIENT_UNIQUE_TEXT = "JPAsome other unique texaksoksojadasdt"
       + new Date();
 
+  @Override
   public void setUp() {
     injector = Guice.createInjector(new JpaPersistModule("testUnit"));
 
     //startup persistence
     injector.getInstance(PersistService.class).start();
   }
 
+  @Override
   public void tearDown() {
     injector.getInstance(PersistService.class).stop();
     injector = null;

File: extensions/persist/test/com/google/inject/persist/jpa/DynamicFinderTest.java
Patch:
@@ -42,13 +42,15 @@
 public class DynamicFinderTest extends TestCase {
   private Injector injector;
 
+  @Override
   public void setUp() {
     injector = Guice.createInjector(new JpaPersistModule("testUnit").addFinder(JpaFinder.class));
 
     //startup persistence
     injector.getInstance(PersistService.class).start();
   }
 
+  @Override
   public final void tearDown() {
     injector.getInstance(PersistService.class).stop();
   }

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerFactoryProvisionTest.java
Patch:
@@ -33,10 +33,12 @@
 public class EntityManagerFactoryProvisionTest extends TestCase {
   private Injector injector;
 
+  @Override
   public void setUp() {
     injector = Guice.createInjector(new JpaPersistModule("testUnit"));
   }
 
+  @Override
   public final void tearDown() {
     injector.getInstance(UnitOfWork.class).end();
     injector.getInstance(EntityManagerFactory.class).close();

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerProvisionTest.java
Patch:
@@ -37,13 +37,15 @@
 public class EntityManagerProvisionTest extends TestCase {
   private Injector injector;
 
+  @Override
   public void setUp() {
     injector = Guice.createInjector(new JpaPersistModule("testUnit"));
 
     //startup persistence
     injector.getInstance(PersistService.class).start();
   }
 
+  @Override
   public final void tearDown() {
     injector.getInstance(EntityManagerFactory.class).close();
   }

File: extensions/persist/test/com/google/inject/persist/jpa/JpaPersistServiceTest.java
Patch:
@@ -60,6 +60,5 @@ public void test_givenErrorOnEntityManagerClose_whenEndIsCalled_thenEntityManage
     }
   }
 
-  private class SimulatedException extends RuntimeException {
-  }
+  private static class SimulatedException extends RuntimeException {}
 }

File: extensions/persist/test/com/google/inject/persist/jpa/ManualLocalTransactionsTest.java
Patch:
@@ -42,13 +42,15 @@ public class ManualLocalTransactionsTest extends TestCase {
   private static final String UNIQUE_TEXT = "some unique text" + new Date();
   private static final String UNIQUE_TEXT_2 = "some other unique text" + new Date();
 
+  @Override
   public void setUp() {
     injector = Guice.createInjector(new JpaPersistModule("testUnit"));
 
     //startup persistence
     injector.getInstance(PersistService.class).start();
   }
 
+  @Override
   public void tearDown() {
     injector.getInstance(EntityManagerFactory.class).close();
   }

File: extensions/servlet/src/com/google/inject/servlet/FilterChainInvocation.java
Patch:
@@ -65,6 +65,7 @@ public FilterChainInvocation(FilterDefinition[] filterDefinitions,
     this.proceedingChain = proceedingChain;
   }
 
+  @Override
   public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)
       throws IOException, ServletException {
     GuiceFilter.Context previous = GuiceFilter.localContext.get();

File: extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -115,6 +115,7 @@ static void reset() {
     localContext.remove();
   }
 
+  @Override
   public void doFilter(
       final ServletRequest servletRequest,
       final ServletResponse servletResponse,
@@ -213,6 +214,7 @@ HttpServletResponse getResponse() {
     }
   }
 
+  @Override
   public void init(FilterConfig filterConfig) throws ServletException {
     final ServletContext servletContext = filterConfig.getServletContext();
 
@@ -226,6 +228,7 @@ public void init(FilterConfig filterConfig) throws ServletException {
     filterPipeline.initPipeline(servletContext);
   }
 
+  @Override
   public void destroy() {
 
     try {

File: extensions/servlet/src/com/google/inject/servlet/GuiceServletContextListener.java
Patch:
@@ -37,6 +37,7 @@ public abstract class GuiceServletContextListener
 
   static final String INJECTOR_NAME = Injector.class.getName();
 
+  @Override
   public void contextInitialized(ServletContextEvent servletContextEvent) {
     final ServletContext servletContext = servletContextEvent.getServletContext();
 
@@ -50,6 +51,7 @@ public void contextInitialized(ServletContextEvent servletContextEvent) {
     servletContext.setAttribute(INJECTOR_NAME, injector);
   }
 
+  @Override
   public void contextDestroyed(ServletContextEvent servletContextEvent) {
     ServletContext servletContext = servletContextEvent.getServletContext();
     servletContext.removeAttribute(INJECTOR_NAME);

File: extensions/servlet/src/com/google/inject/servlet/InstanceFilterBindingImpl.java
Patch:
@@ -35,6 +35,7 @@ class InstanceFilterBindingImpl extends AbstractServletModuleBinding<Filter> imp
     super(initParams, target, patternMatcher);
   }
 
+  @Override
   public Filter getFilterInstance() {
     return getTarget();
   }

File: extensions/servlet/src/com/google/inject/servlet/InstanceServletBindingImpl.java
Patch:
@@ -35,6 +35,7 @@ class InstanceServletBindingImpl extends AbstractServletModuleBinding<HttpServle
     super(initParams, target, patternMatcher);
   }
 
+  @Override
   public HttpServlet getServletInstance() {
     return getTarget();
   }

File: extensions/servlet/src/com/google/inject/servlet/InternalServletModule.java
Patch:
@@ -60,6 +60,7 @@ void set(ServletContext injectedServletContext) {
       this.injectedServletContext = injectedServletContext;
     }
 
+    @Override
     public ServletContext get() {
       if (null != injectedServletContext) {
         return injectedServletContext;

File: extensions/servlet/src/com/google/inject/servlet/LinkedFilterBindingImpl.java
Patch:
@@ -38,6 +38,7 @@ class LinkedFilterBindingImpl extends AbstractServletModuleBinding<Key<? extends
     super(initParams, target, patternMatcher);
   }
 
+  @Override
   public Key<? extends Filter> getLinkedKey() {
     return getTarget();
   }

File: extensions/servlet/src/com/google/inject/servlet/LinkedServletBindingImpl.java
Patch:
@@ -38,6 +38,7 @@ class LinkedServletBindingImpl extends AbstractServletModuleBinding<Key<? extend
     super(initParams, target, patternMatcher);
   }
 
+  @Override
   public Key<? extends HttpServlet> getLinkedKey() {
     return getTarget();
   }

File: extensions/servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -444,6 +444,7 @@ private static void checkScopingState(boolean condition, String msg) {
   private static final <T> Callable<T> wrap(
       final Callable<T> delegate, final RequestScoper requestScoper) {
     return new Callable<T>() {
+      @Override
       public T call() throws Exception {
         RequestScoper.CloseableScope scope = requestScoper.open();
         try {

File: extensions/servlet/test/com/google/inject/servlet/ContextPathTest.java
Patch:
@@ -277,8 +277,9 @@ public void clear() {
   public static class TestFilterChain implements FilterChain {
     private boolean triggered = false;
 
-    public void doFilter(ServletRequest request, ServletResponse response) throws IOException,
-        ServletException {
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response)
+        throws IOException, ServletException {
       triggered = true;
     }
 

File: extensions/servlet/test/com/google/inject/servlet/ScopeRequestIntegrationTest.java
Patch:
@@ -147,6 +147,7 @@ public static class OffRequestCallable implements Callable<String> {
 
     public String value;
 
+    @Override
     public String call() throws Exception {
       // Inside this request, we should always get the same instance.
       assertSame(someObject.get(), someObject.get());
@@ -161,6 +162,7 @@ public String call() throws Exception {
   private static class Caller implements Callable<SomeObject> {
     @Inject Provider<SomeObject> someObject;
 
+    @Override
     public SomeObject call() throws Exception {
       return someObject.get();
     }

File: extensions/spring/src/com/google/inject/spring/SpringIntegration.java
Patch:
@@ -107,6 +107,7 @@ void initialize(BeanFactory beanFactory) {
       singleton = beanFactory.isSingleton(name);
     }
 
+    @Override
     public T get() {
       return singleton ? getSingleton() : type.cast(beanFactory.getBean(name));
     }

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethod.java
Patch:
@@ -103,6 +103,7 @@ void configure(Binder binder) {
         binder, exceptionTypes, sbinder.getExceptionTypes(), checkedProvider);
   }
 
+  @Override
   public T get() throws Exception {
     Object[] parameters = new Object[parameterProviders.size()];
     for (int i = 0; i < parameters.length; i++) {
@@ -128,6 +129,7 @@ public T get() throws Exception {
     }
   }
 
+  @Override
   public Set<Dependency<?>> getDependencies() {
     return dependencies;
   }

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethodsModule.java
Patch:
@@ -67,6 +67,7 @@ static Module forModule(Module module) {
     return new CheckedProviderMethodsModule(module);
   }
   
+  @Override
   public synchronized void configure(Binder binder) {
     for (CheckedProviderMethod<?> throwingProviderMethod : getProviderMethods(binder)) {
       throwingProviderMethod.configure(binder);
@@ -151,6 +152,7 @@ public LogProvider(Method method) {
       this.name = method.getDeclaringClass().getName() + "." + method.getName();
     }
     
+    @Override
     public Logger get() {
       return Logger.getLogger(name);
     }

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/ThrowingProvider.java
Patch:
@@ -36,5 +36,6 @@
  */
 @Deprecated
 public interface ThrowingProvider<T,E extends Exception> extends CheckedProvider<T> {
+  @Override
   T get() throws E;
 }

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/CheckedProviderMethodsModuleTest.java
Patch:
@@ -54,6 +54,7 @@ public class CheckedProviderMethodsModuleTest extends TestCase {
   private final TestScope testScope = new TestScope();
 
   interface RpcProvider<T> extends CheckedProvider<T> {
+    @Override
     T get() throws RemoteException, BindException;
   }
 
@@ -156,7 +157,7 @@ public void testWithInjectedParameters() throws BindException, RemoteException {
     RpcProvider<Pair<Double, String>> provider = injector
         .getInstance(Key.get(rpcProviderOfPair));
     Pair<Double, String> pair = provider.get();
-    assertEquals(pair.first, 4.0d);
+    assertEquals(pair.first, 4.0d, 0.0);
   }
 
   public void testWithThrownException() {

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/TestScope.java
Patch:
@@ -39,9 +39,10 @@ class TestScope implements Scope {
 
   private Map<Key, Object> inScopeObjectsMap = new HashMap<Key, Object>();
 
-  public <T> Provider<T> scope(
-      final Key<T> key, final Provider<T> provider) {
+  @Override
+  public <T> Provider<T> scope(final Key<T> key, final Provider<T> provider) {
     return new Provider<T>() {
+      @Override
       @SuppressWarnings({"unchecked"})
       public T get() {
         T t = (T) inScopeObjectsMap.get(key);

File: extensions/servlet/src/com/google/inject/servlet/ServletUtils.java
Patch:
@@ -220,10 +220,11 @@ boolean isEmpty() {
     }
 
     private void ensureCapacity(int minCapacity) {
-      if (bytes.length >= minCapacity) {
+      int cap = bytes.length;
+      if (cap >= minCapacity) {
         return;
       }
-      int newCapacity = bytes.length + bytes.length >> 1;  // *1.5
+      int newCapacity = cap + (cap >> 1);  // *1.5
       if (newCapacity < minCapacity) {
         // we are close to overflowing, grow by smaller steps
         newCapacity = minCapacity;

File: extensions/testlib/src/com/google/inject/testing/throwingproviders/CheckedProviderSubject.java
Patch:
@@ -61,7 +61,7 @@ public Subject<?, Object> providedValue() {
       got = provider.get();
     } catch (Exception e) {
       failureStrategy.fail(String.format("checked provider <%s> threw an exception", provider), e);
-      throw new AssertionError("Impossible, I hope...", e);
+      throw new AssertionError(e);
     }
     return assert_().withFailureMessage("value provided by <%s>", provider).that(got);
   }

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -265,8 +265,7 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency, b
 
       // This may not actually be safe because it could return a super type of T (if that's all the
       // client needs), but it should be OK in practice thanks to the wonders of erasure.
-      return (T) constructorInjector.construct(errors, context,
-          dependency.getKey().getTypeLiteral().getRawType(), provisionCallback);
+      return (T) constructorInjector.construct(errors, context, dependency, provisionCallback);
     }
   }
 }

File: core/src/com/google/inject/TypeLiteral.java
Patch:
@@ -38,8 +38,8 @@
 /**
  * Represents a generic type {@code T}. Java doesn't yet provide a way to
  * represent generic types, so this class does. Forces clients to create a
- * subclass of this class which enables retrieval the type information even at
- * runtime.
+ * subclass of this class which enables retrieval of the type information even
+ * at runtime.
  *
  * <p>For example, to create a type literal for {@code List<String>}, you can
  * create an empty anonymous inner class:

File: core/test/com/google/inject/spi/InjectionPointTest.java
Patch:
@@ -32,9 +32,6 @@
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.name.Named;
 import com.google.inject.spi.InjectionPoint.Signature;
-
-import junit.framework.TestCase;
-
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -43,6 +40,7 @@
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
+import junit.framework.TestCase;
 
 /**
  * @author jessewilson@google.com (Jesse Wilson)
@@ -331,6 +329,7 @@ static class Super {
   }
   
   static class Sub extends Super {
+    @SuppressWarnings("OverridesJavaxInjectableMethod")
     public void atInject() {}
     public void gInject() {}
     
@@ -348,6 +347,7 @@ public void gFirstThenAt() {}
   
   static class SubSub extends Sub {
     @Override public void privateAtAndPublicG() {}
+    @SuppressWarnings("OverridesJavaxInjectableMethod")
     @Override public void privateGAndPublicAt() {}
     
     @Override public void atFirstThenG() {}

File: core/src/com/google/inject/internal/Element.java
Patch:
@@ -15,7 +15,7 @@
  */
 
 
-package com.google.inject.multibindings;
+package com.google.inject.internal;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
@@ -35,8 +35,7 @@
 
   enum Type {
     MAPBINDER,
-    MULTIBINDER,
-    OPTIONALBINDER;
+    MULTIBINDER;
   }
 
   String setName();

File: core/src/com/google/inject/internal/Indexer.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.inject.multibindings;
+package com.google.inject.internal;
 
 import com.google.common.base.Objects;
 import com.google.inject.Binding;

File: core/src/com/google/inject/internal/RealElement.java
Patch:
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.inject.multibindings;
+package com.google.inject.internal;
 
 import com.google.inject.Key;
-import com.google.inject.internal.Annotations;
-
+import com.google.inject.internal.Element.Type;
 import java.lang.annotation.Annotation;
 import java.util.concurrent.atomic.AtomicInteger;
 

File: core/src/com/google/inject/multibindings/Element.java
Patch:
@@ -15,7 +15,7 @@
  */
 
 
-package com.google.inject.internal;
+package com.google.inject.multibindings;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
@@ -35,7 +35,8 @@
 
   enum Type {
     MAPBINDER,
-    MULTIBINDER;
+    MULTIBINDER,
+    OPTIONALBINDER;
   }
 
   String setName();

File: core/src/com/google/inject/multibindings/Indexer.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.inject.internal;
+package com.google.inject.multibindings;
 
 import com.google.common.base.Objects;
 import com.google.inject.Binding;

File: core/src/com/google/inject/multibindings/RealElement.java
Patch:
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package com.google.inject.internal;
+package com.google.inject.multibindings;
 
 import com.google.inject.Key;
-import com.google.inject.internal.Element.Type;
+import com.google.inject.internal.Annotations;
+
 import java.lang.annotation.Annotation;
 import java.util.concurrent.atomic.AtomicInteger;
 

File: core/src/com/google/inject/internal/Element.java
Patch:
@@ -15,7 +15,7 @@
  */
 
 
-package com.google.inject.multibindings;
+package com.google.inject.internal;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
@@ -35,8 +35,7 @@
 
   enum Type {
     MAPBINDER,
-    MULTIBINDER,
-    OPTIONALBINDER;
+    MULTIBINDER;
   }
 
   String setName();

File: core/src/com/google/inject/internal/Indexer.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.inject.multibindings;
+package com.google.inject.internal;
 
 import com.google.common.base.Objects;
 import com.google.inject.Binding;

File: core/src/com/google/inject/internal/RealElement.java
Patch:
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
-package com.google.inject.multibindings;
+package com.google.inject.internal;
 
 import com.google.inject.Key;
-import com.google.inject.internal.Annotations;
-
+import com.google.inject.internal.Element.Type;
 import java.lang.annotation.Annotation;
 import java.util.concurrent.atomic.AtomicInteger;
 

File: core/test/com/google/inject/BindingTest.java
Patch:
@@ -221,7 +221,7 @@ public void testTooManyConstructors() {
     }
   }
 
-  @SuppressWarnings("inject-constructors")
+  @SuppressWarnings("InjectMultipleAtInjectConstructors")
   static class TooManyConstructors {
     @Inject
     TooManyConstructors(Injector i) {}

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.ProviderInstanceBinding;
+import com.google.inject.spi.ProviderWithExtensionVisitor;
 import com.google.inject.spi.ProvidesMethodBinding;
 import com.google.inject.spi.ProvidesMethodTargetVisitor;
 import java.lang.annotation.Annotation;
@@ -41,8 +42,8 @@
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */
-public abstract class ProviderMethod<T> extends ProviderWithExtensionsBindingImpl.Factory<T>
-    implements HasDependencies, ProvidesMethodBinding<T> {
+public abstract class ProviderMethod<T> extends InternalProviderInstanceBindingImpl.CyclicFactory<T>
+    implements HasDependencies, ProvidesMethodBinding<T>, ProviderWithExtensionVisitor<T> {
 
   /**
    * Creates a {@link ProviderMethod}.

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProviderTest.java
Patch:
@@ -552,7 +552,8 @@ public void testFactoryFailsWithMissingBinding() {
           "1) Parameter of type 'double' is not injectable or annotated with @Assisted");
     }
   }
-  
+
+  @SuppressWarnings("SelfEquals")
   public void testMethodsDeclaredInObject() {
     Injector injector = Guice.createInjector(new AbstractModule() {
         @Override protected void configure() {
@@ -837,4 +838,4 @@ protected void configure() {
     assertEquals(ComparisonMethod.SHALLOW, shallowEquals.comparisonMethod);
     assertEquals(0.01d, shallowEquals.sigma);
   }
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -84,7 +84,7 @@ static <T> ConstructorBindingImpl<T> create(InjectorImpl injector, Key<T> key,
 
     // We can't inject abstract classes.
     if (Modifier.isAbstract(rawType.getModifiers())) {
-      errors.missingImplementation(key);
+      errors.missingImplementationWithHint(key, injector);
     }
 
     // Error: Inner class.

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -633,7 +633,7 @@ <T> BindingImpl<T> createUninitializedBinding(Key<T> key, Scoping scoping, Objec
 
     // Don't try to inject arrays or enums annotated with @ImplementedBy.
     if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) {
-      throw errors.missingImplementation(key).toException();
+      throw errors.missingImplementationWithHint(key, this).toException();
     }
 
     // Handle TypeLiteral<T> by binding the inner type
@@ -878,7 +878,7 @@ private <T> BindingImpl<T> createJustInTimeBinding(Key<T> key, Errors errors,
           // throw with a more appropriate message below
         }
       }
-      throw errors.missingImplementation(key).toException();
+      throw errors.missingImplementationWithHint(key, this).toException();
     }
 
     Object source = key.getTypeLiteral().getRawType();

File: core/src/com/google/inject/internal/UntargettedBindingProcessor.java
Patch:
@@ -41,11 +41,11 @@ public Boolean visit(UntargettedBinding<? extends T> untargetted) {
         // We can't assume abstract types aren't injectable. They may have an
         // @ImplementedBy annotation or something.
         if (key.getAnnotationType() != null) {
-          errors.missingImplementation(key);
+          errors.missingImplementationWithHint(key, injector);
           putBinding(invalidBinding(injector, key, source));
           return true;
         }
-    
+
         // This cast is safe after the preceeding check.
         try {
           BindingImpl<T> binding = injector.createUninitializedBinding(

File: core/test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -161,8 +161,8 @@ private void assertFailure(Injector injector, Class clazz) {
       fail("Shouldn't have been able to get binding of: " + clazz);
     } catch(ConfigurationException expected) {
       Message msg = Iterables.getOnlyElement(expected.getErrorMessages());
-      assertEquals("No implementation for " + InvalidInterface.class.getName() + " was bound.",
-          msg.getMessage());
+      Asserts.assertContains(msg.getMessage(),
+          "No implementation for " + InvalidInterface.class.getName() + " was bound.");
       List<Object> sources = msg.getSources();
       // Assert that the first item in the sources if the key for the class we're looking up,
       // ensuring that each lookup is "new".

File: core/test/com/google/inject/multibindings/MultibinderTest.java
Patch:
@@ -493,7 +493,8 @@ public void testSourceLinesInMultibindings() {
       });
       fail();
     } catch (CreationException expected) {
-      assertContains(expected.getMessage(), "No implementation for java.lang.Integer",
+      assertContains(expected.getMessage(), true,
+          "No implementation for java.lang.Integer",
           "at " + getClass().getName());
     }
   }

File: core/test/com/google/inject/BinderTest.java
Patch:
@@ -423,7 +423,8 @@ public void testPartialInjectorGetInstance() {
     } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "1) Could not find a suitable constructor in " + NoInjectConstructor.class.getName(),
-          "at " + MissingParameter.class.getName() + ".<init>(BinderTest.java:");
+          "for the 1st parameter of " + MissingParameter.class.getName() 
+              + ".<init>(BinderTest.java:");
     }
   }
 

File: core/src/com/google/inject/internal/Scoping.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.inject.spi.ScopeBinding;
 
 import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
 
 /**
  * References a scope, either directly (as a scope instance), or indirectly (as a scope annotation).
@@ -239,6 +240,8 @@ static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector,
 
     Scope scope = scoping.getScopeInstance();
 
+    // SingletonScope needs access to the injector's thread-specific InternalContext
+    SingletonScope.currentInjector.set(new WeakReference<InjectorImpl>(injector));
     Provider<T> scoped
         = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));
     return new InternalFactoryToProviderAdapter<T>(scoped, source);

File: extensions/dagger-adapter/test/com/google/inject/daggeradapter/DaggerAdapterTest.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.google.inject.daggeradapter;
 
-import static dagger.Provides.Type.SET;
-
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import com.google.inject.Binder;
@@ -75,7 +73,9 @@ Integer anInteger() {
   }
 
   @dagger.Module static class SetBindingDaggerModule2 {
-    @dagger.Provides(type=SET) Integer anInteger() {
+    @dagger.Provides
+    @IntoSet
+    Integer anInteger() {
       return 3;
     }
   }

File: extensions/servlet/test/com/google/inject/servlet/ContinuingHttpServletRequestTest.java
Patch:
@@ -65,7 +65,7 @@ public void testReturnDelegateCookies() {
 
     try {
       assertCookieArraysEqual(cookies, continuingRequest.getCookies());
-      fail();
+      throw new Error();
     } catch (AssertionFailedError e) {
       // Expected.
     }

File: core/src/com/google/inject/internal/ProxyFactory.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject.internal;
 
-import static com.google.inject.internal.BytecodeGen.newFastClass;
+import static com.google.inject.internal.BytecodeGen.newFastClassForMember;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -254,8 +254,7 @@ private static class ProxyConstructor<T> implements ConstructionProxy<T> {
       this.constructor = (Constructor<T>) injectionPoint.getMember();
       this.callbacks = callbacks;
       this.methodInterceptors = methodInterceptors;
-
-      this.fastClass = newFastClass(enhanced);
+      this.fastClass = newFastClassForMember(enhanced, constructor);
       this.constructorIndex = fastClass.getIndex(constructor.getParameterTypes());
     }
 

File: core/src/com/google/inject/spi/Message.java
Patch:
@@ -108,7 +108,7 @@ public Throwable getCause() {
   }
 
   @Override public int hashCode() {
-    return message.hashCode();
+    return Objects.hashCode(message, cause, sources);
   }
 
   @Override public boolean equals(Object o) {

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -31,6 +31,7 @@
 import com.google.inject.spi.HasDependenciesTest;
 import com.google.inject.spi.InjectionPointTest;
 import com.google.inject.spi.InjectorSpiTest;
+import com.google.inject.spi.MessageTest;
 import com.google.inject.spi.ModuleAnnotatedMethodScannerTest;
 import com.google.inject.spi.ModuleRewriterTest;
 import com.google.inject.spi.ModuleSourceTest;
@@ -134,6 +135,7 @@ public static Test suite() {
     suite.addTestSuite(ToolStageInjectorTest.class);
     suite.addTestSuite(ModuleSourceTest.class);
     suite.addTestSuite(ElementSourceTest.class);
+    suite.addTestSuite(MessageTest.class);
 
     // tools
     // suite.addTestSuite(JmxTest.class); not a testcase

File: extensions/grapher/src/com/google/inject/grapher/NodeId.java
Patch:
@@ -69,7 +69,7 @@ public Key<?> getKey() {
   }
 
   @Override public boolean equals(Object obj) {
-    if (!(obj.getClass().equals(NodeId.class))) {
+    if (obj == null || !(obj.getClass().equals(NodeId.class))) {
       return false;
     }
     NodeId other = (NodeId) obj;

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java
Patch:
@@ -831,7 +831,7 @@ public RealMapBinderProviderWithDependencies(Object equality) {
 
       @Override
       public boolean equals(Object obj) {
-        return this.getClass() == obj.getClass() &&
+        return obj != null && this.getClass() == obj.getClass() &&
           equality.equals(((RealMapBinderProviderWithDependencies<?>)obj).equality);
       }
 

File: extensions/multibindings/src/com/google/inject/multibindings/OptionalBinder.java
Patch:
@@ -687,7 +687,7 @@ public RealOptionalBinderProviderWithDependencies(Object equality) {
       }
 
       @Override public boolean equals(Object obj) {
-        return this.getClass() == obj.getClass()
+        return obj != null && this.getClass() == obj.getClass()
             && equality.equals(((RealOptionalBinderProviderWithDependencies<?>) obj).equality);
       }
 

File: core/src/com/google/inject/spi/TypeListener.java
Patch:
@@ -34,7 +34,7 @@ public interface TypeListener {
 
   /**
    * Invoked when Guice encounters a new type eligible for constructor or members injection.
-   * Called during injector creation (or afterwords if Guice encounters a type at run time and
+   * Called during injector creation (or afterwards if Guice encounters a type at run time and
    * creates a JIT binding).
    *
    * @param type encountered by Guice

File: core/src/com/google/inject/spi/TypeListener.java
Patch:
@@ -34,7 +34,7 @@ public interface TypeListener {
 
   /**
    * Invoked when Guice encounters a new type eligible for constructor or members injection.
-   * Called during injector creation (or afterwords if Guice encounters a type at run time and
+   * Called during injector creation (or afterwards if Guice encounters a type at run time and
    * creates a JIT binding).
    *
    * @param type encountered by Guice

File: extensions/multibindings/src/com/google/inject/multibindings/ProvidesIntoMap.java
Patch:
@@ -34,7 +34,7 @@
  * {@literal @}ProvidesIntoMap
  * {@literal @}StringMapKey("Foo")
  * {@literal @}Named("plugins")
- * Plugin provideFooUrl(FooManager fm) { returm fm.getPlugin(); }
+ * Plugin provideFooUrl(FooManager fm) { return fm.getPlugin(); }
  *
  * {@literal @}ProvidesIntoMap
  * {@literal @}StringMapKey("Bar")

File: core/src/com/google/inject/spi/Message.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableList;
 import com.google.inject.Binder;
@@ -28,6 +26,8 @@
 import java.io.Serializable;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * An error message and the context in which it occured. Messages are usually created internally by
  * Guice and its extensions. Messages can be created explicitly in a module using {@link
@@ -108,7 +108,7 @@ public Throwable getCause() {
   }
 
   @Override public int hashCode() {
-    return message.hashCode();
+    return Objects.hashCode(message, cause, sources);
   }
 
   @Override public boolean equals(Object o) {

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -31,6 +31,7 @@
 import com.google.inject.spi.HasDependenciesTest;
 import com.google.inject.spi.InjectionPointTest;
 import com.google.inject.spi.InjectorSpiTest;
+import com.google.inject.spi.MessageTest;
 import com.google.inject.spi.ModuleAnnotatedMethodScannerTest;
 import com.google.inject.spi.ModuleRewriterTest;
 import com.google.inject.spi.ModuleSourceTest;
@@ -134,6 +135,7 @@ public static Test suite() {
     suite.addTestSuite(ToolStageInjectorTest.class);
     suite.addTestSuite(ModuleSourceTest.class);
     suite.addTestSuite(ElementSourceTest.class);
+    suite.addTestSuite(MessageTest.class);
 
     // tools
     // suite.addTestSuite(JmxTest.class); not a testcase

File: core/src/com/google/inject/ProvidedBy.java
Patch:
@@ -34,5 +34,5 @@
   /**
    * The implementation type.
    */
-  Class<? extends Provider<?>> value();
+  Class<? extends javax.inject.Provider<?>> value();
 }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -201,7 +201,7 @@ public Errors bindingToProvider() {
     return addMessage("Binding to Provider is not allowed.");
   }
 
-  public Errors subtypeNotProvided(Class<? extends Provider<?>> providerType,
+  public Errors subtypeNotProvided(Class<? extends javax.inject.Provider<?>> providerType,
       Class<?> type) {
     return addMessage("%s doesn't provide instances of %s.", providerType, type);
   }

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -699,7 +699,7 @@ private <T> BindingImpl<TypeLiteral<T>> createTypeLiteralBinding(
   <T> BindingImpl<T> createProvidedByBinding(Key<T> key, Scoping scoping,
       ProvidedBy providedBy, Errors errors) throws ErrorsException {
     Class<?> rawType = key.getTypeLiteral().getRawType();
-    Class<? extends Provider<?>> providerType = providedBy.value();
+    Class<? extends javax.inject.Provider<?>> providerType = providedBy.value();
 
     // Make sure it's not the same type. TODO: Can we check for deeper loops?
     if (providerType == rawType) {

File: core/src/com/google/inject/internal/ProvidedByInternalFactory.java
Patch:
@@ -21,10 +21,11 @@
 
 import com.google.inject.Key;
 import com.google.inject.ProvidedBy;
-import com.google.inject.Provider;
 import com.google.inject.internal.InjectorImpl.JitLimitation;
 import com.google.inject.spi.Dependency;
 
+import javax.inject.Provider;
+
 /**
  * An {@link InternalFactory} for {@literal @}{@link ProvidedBy} bindings.
  * 

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -111,7 +111,7 @@ public Boolean visit(ProviderInstanceBinding<? extends T> binding) {
         // always visited with Binding<T>
         @SuppressWarnings("unchecked") 
         InternalFactory<T> factory = new InternalFactoryToInitializableAdapter<T>(
-            initializable, source, !injector.options.disableCircularProxies,
+            initializable, source,
             injector.provisionListenerStore.get((ProviderInstanceBinding<T>)binding));
         InternalFactory<? extends T> scopedFactory
             = Scoping.scope(key, injector, factory, source, scoping);
@@ -127,7 +127,7 @@ public Boolean visit(ProviderKeyBinding<? extends T> binding) {
         // always visited with Binding<T>
         @SuppressWarnings("unchecked") 
         BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<T>(
-            injector, providerKey, source, !injector.options.disableCircularProxies,
+            injector, providerKey, source,
             injector.provisionListenerStore.get((ProviderKeyBinding<T>) binding));
         bindingData.addCreationListener(boundProviderFactory);
         InternalFactory<? extends T> scopedFactory = Scoping.scope(

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -38,9 +38,8 @@ final class BoundProviderFactory<T> extends ProviderInternalFactory<T> implement
       InjectorImpl injector,
       Key<? extends javax.inject.Provider<? extends T>> providerKey,
       Object source,
-      boolean allowProxy,
       ProvisionListenerStackCallback<T> provisionCallback) {
-    super(source, allowProxy);
+    super(source);
     this.provisionCallback = checkNotNull(provisionCallback, "provisionCallback");
     this.injector = injector;
     this.providerKey = providerKey;
@@ -60,7 +59,7 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency, b
     try {
       errors = errors.withSource(providerKey);
       javax.inject.Provider<? extends T> provider = providerFactory.get(errors, context, dependency, true);
-      return circularGet(provider, errors, context, dependency, linked, provisionCallback);
+      return circularGet(provider, errors, context, dependency, provisionCallback);
     } finally {
       context.popState();
     }

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -133,7 +133,6 @@ private static boolean hasAtInject(Constructor cxtor) {
 
   @SuppressWarnings("unchecked") // the result type always agrees with the ConstructorInjector type
   public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
-    factory.allowCircularProxy = !injector.options.disableCircularProxies;
     factory.constructorInjector =
         (ConstructorInjector<T>) injector.constructors.get(constructorInjectionPoint, errors);
     factory.provisionCallback =
@@ -246,7 +245,6 @@ public int hashCode() {
   private static class Factory<T> implements InternalFactory<T> {
     private final boolean failIfNotLinked;
     private final Key<?> key;
-    private boolean allowCircularProxy;
     private ConstructorInjector<T> constructorInjector;
     private ProvisionListenerStackCallback<T> provisionCallback;
 
@@ -267,7 +265,7 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency, b
       // This may not actually be safe because it could return a super type of T (if that's all the
       // client needs), but it should be OK in practice thanks to the wonders of erasure.
       return (T) constructorInjector.construct(errors, context,
-          dependency.getKey().getTypeLiteral().getRawType(), allowCircularProxy, provisionCallback);
+          dependency.getKey().getTypeLiteral().getRawType(), provisionCallback);
     }
   }
 }

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -812,6 +812,9 @@ public static void formatSource(Formatter formatter, Object source, ElementSourc
       Key<?> key = (Key<?>) source;
       formatter.format("  while locating %s%n", convert(key, elementSource));
 
+    } else if (source instanceof Thread) {
+      formatter.format("  in thread %s%n", source);
+
     } else {
       formatter.format("  at %s%s%n", source, modules);
     }

File: extensions/multibindings/src/com/google/inject/multibindings/MapKey.java
Patch:
@@ -54,5 +54,5 @@
    * instances will be the keys. If {@code unwrapValue} is true, the value() type of key type
    * annotation will be the key type for injected map and the value instances will be the keys.
    */
-  boolean unwrapValue();
+  boolean unwrapValue() default true;
 }

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -801,6 +801,7 @@ private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors e
       throw errors.childBindingAlreadySet(key, sources).toException();
     }
 
+    key = MoreTypes.canonicalizeKey(key); // before storing the key long-term, canonicalize it.
     BindingImpl<T> binding = createJustInTimeBinding(key, errors, jitDisabled, jitType);
     state.parent().blacklist(key, state, binding.getSource());
     jitBindings.put(key, binding);

File: core/src/com/google/inject/spi/Dependency.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.inject.Key;
+import com.google.inject.internal.MoreTypes;
 
 import java.util.List;
 import java.util.Set;
@@ -54,7 +55,7 @@ public final class Dependency<T> {
    * nullable.
    */
   public static <T> Dependency<T> get(Key<T> key) {
-    return new Dependency<T>(null, key, true, -1);
+    return new Dependency<T>(null, MoreTypes.canonicalizeKey(key), true, -1);
   }
 
   /**

File: extensions/multibindings/test/com/google/inject/multibindings/MapBinderTest.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.inject.AbstractModule;
+import com.google.inject.Asserts;
 import com.google.inject.Binding;
 import com.google.inject.BindingAnnotation;
 import com.google.inject.ConfigurationException;
@@ -1025,7 +1026,7 @@ public void testWeakKeySet_integration_mapbinder() {
     // Clear the ref, GC, and ensure that we are no longer blacklisting.
     childInjector = null;
     
-    WeakKeySetUtils.awaitClear(weakRef);
+    Asserts.awaitClear(weakRef);
     WeakKeySetUtils.assertNotBlacklisted(parentInjector, mapKey);
   }
 }

File: extensions/multibindings/test/com/google/inject/multibindings/OptionalBinderTest.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.inject.AbstractModule;
+import com.google.inject.Asserts;
 import com.google.inject.Binding;
 import com.google.inject.BindingAnnotation;
 import com.google.inject.CreationException;
@@ -1203,7 +1204,7 @@ public void testWeakKeySet_integration() {
    // Clear the ref, GC, and ensure that we are no longer blacklisting.
    childInjector = null;
    
-   WeakKeySetUtils.awaitClear(weakRef);
+   Asserts.awaitClear(weakRef);
    WeakKeySetUtils.assertNotBlacklisted(parentInjector, Key.get(Integer.class));
  }
 

File: extensions/multibindings/src/com/google/inject/multibindings/ProvidesIntoMap.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Annotates methods of a {@link Module} to add items to a {@link MapBinder}.
  * The method's return type, binding annotation and additional key annotation determines
- * what Map this will contributes to. For example,
+ * what Map this will contribute to. For example,
  *
  * <pre>
  * {@literal @}ProvidesIntoMap

File: extensions/multibindings/src/com/google/inject/multibindings/ProvidesIntoOptional.java
Patch:
@@ -27,8 +27,8 @@
 
 /**
  * Annotates methods of a {@link Module} to add items to a {@link Multibinder}.
- * The method's return type and binding annotation determines what Set this will
- * contributes to. For example,
+ * The method's return type and binding annotation determines what Optional this will
+ * contribute to. For example,
  *
  * <pre>
  * {@literal @}ProvidesIntoOptional(DEFAULT)

File: extensions/multibindings/src/com/google/inject/multibindings/ProvidesIntoSet.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Annotates methods of a {@link Module} to add items to a {@link Multibinder}.
  * The method's return type and binding annotation determines what Set this will
- * contributes to. For example,
+ * contribute to. For example,
  *
  * <pre>
  * {@literal @}ProvidesIntoSet

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -1000,9 +1000,9 @@ public <T> Provider<T> getProvider(Class<T> type) {
     return getProvider(Key.get(type));
   }
 
-  <T> Provider<T> getProviderOrThrow(final Key<T> key, Errors errors) throws ErrorsException {
+  <T> Provider<T> getProviderOrThrow(final Dependency<T> dependency, Errors errors) throws ErrorsException {
+    final Key<T> key = dependency.getKey();
     final BindingImpl<? extends T> binding = getBindingOrThrow(key, errors, JitLimitation.NO_JIT);
-    final Dependency<T> dependency = Dependency.get(key);
 
     return new Provider<T>() {
       public T get() {
@@ -1034,7 +1034,7 @@ public T call(InternalContext context) throws ErrorsException {
   public <T> Provider<T> getProvider(final Key<T> key) {
     Errors errors = new Errors(key);
     try {
-      Provider<T> result = getProviderOrThrow(key, errors);
+      Provider<T> result = getProviderOrThrow(Dependency.get(key), errors);
       errors.throwIfNewErrors(0);
       return result;
     } catch (ErrorsException e) {

File: core/src/com/google/inject/internal/LookupProcessor.java
Patch:
@@ -48,7 +48,7 @@ final class LookupProcessor extends AbstractProcessor {
   @Override public <T> Boolean visit(ProviderLookup<T> lookup) {
     // ensure the provider can be created
     try {
-      Provider<T> provider = injector.getProviderOrThrow(lookup.getKey(), errors);
+      Provider<T> provider = injector.getProviderOrThrow(lookup.getDependency(), errors);
       lookup.initializeDelegate(provider);
     } catch (ErrorsException e) {
       errors.merge(e.getErrors()); // TODO: source

File: core/src/com/google/inject/spi/TypeEncounter.java
Patch:
@@ -64,7 +64,7 @@ public interface TypeEncounter<I> {
 
   /**
    * Returns the provider used to obtain instances for the given injection type. The returned
-   * provider will not be valid until the injetor has been created. The provider will throw an
+   * provider will not be valid until the injector has been created. The provider will throw an
    * {@code IllegalStateException} if you try to use it beforehand.
    */
   <T> Provider<T> getProvider(Class<T> type);

File: core/src/com/google/inject/spi/TypeEncounter.java
Patch:
@@ -64,7 +64,7 @@ public interface TypeEncounter<I> {
 
   /**
    * Returns the provider used to obtain instances for the given injection type. The returned
-   * provider will not be valid until the injetor has been created. The provider will throw an
+   * provider will not be valid until the injector has been created. The provider will throw an
    * {@code IllegalStateException} if you try to use it beforehand.
    */
   <T> Provider<T> getProvider(Class<T> type);

File: core/src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -246,9 +246,9 @@ public static String typeToString(Type type) {
   }
 
   /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+   * Returns the generic supertype for {@code type}. For example, given a class {@code IntegerSet},
+   * the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the result
+   * when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
    */
   public static Type getGenericSupertype(Type type, Class<?> rawType, Class<?> toResolve) {
     if (toResolve == rawType) {

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -93,7 +93,7 @@
  *
  * <pre>install(new FactoryModuleBuilder()
  *     .implement(Payment.class, RealPayment.class)
- *     .build(PaymentFactory.class);</pre>
+ *     .build(PaymentFactory.class));</pre>
  *
  * As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
  * factory cannot be used until the injector has been initialized.
@@ -115,7 +115,7 @@
  *     // excluding .implement for Shipment means the implementation class
  *     // will be 'Shipment' itself, which is legal if it's not an interface.
  *     .implement(Receipt.class, RealReceipt.class)
- *     .build(OrderFactory.class);</pre>
+ *     .build(OrderFactory.class));</pre>
  * </pre>
  *
  * <h3>Using the factory</h3>

File: extensions/grapher/src/com/google/inject/grapher/ImplementationNode.java
Patch:
@@ -21,8 +21,9 @@
 import java.util.Collection;
 
 /**
- * Node for types that have {@link Dependency}s and are bound to {@link InterfaceNode}s. These
- * nodes will often have fields for {@link Member}s that are {@link InjectionPoint}s.
+ * Node for types that have {@link com.google.inject.spi.Dependency}s and are
+ * bound to {@link InterfaceNode}s. These nodes will often have fields for
+ * {@link Member}s that are {@link com.google.inject.spi.InjectionPoint}s.
  *
  * @see DependencyEdge
  *

File: extensions/grapher/src/com/google/inject/grapher/NameFactory.java
Patch:
@@ -22,7 +22,8 @@
 
 /**
  * Interface for a service that provides nice {@link String}s that we can
- * display in the graph for the types that come up in {@link Binding}s.
+ * display in the graph for the types that come up in
+ * {@link com.google.inject.Binding}s.
  *
  * @author phopkins@gmail.com (Pete Hopkins)
  */

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizGrapher.java
Patch:
@@ -38,8 +38,8 @@
 import java.util.Map.Entry;
 
 /**
- * {@link InjectorGrapher} implementation that writes out a Graphviz DOT file of the graph.
- * Dependencies are bound in {@link GraphvizModule}.
+ * {@link com.google.inject.grapher.InjectorGrapher} implementation that writes out a Graphviz DOT
+ * file of the graph. Dependencies are bound in {@link GraphvizModule}.
  * <p>
  * Specify the {@link PrintWriter} to output to with {@link #setOut(PrintWriter)}.
  *

File: extensions/grapher/src/com/google/inject/grapher/graphviz/PortIdFactory.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * Interface for a service that returns Graphviz port IDs, used for naming the
- * rows in {@link ImplementationNode}-displaying {@link GraphvizNode}s.
+ * rows in {@link com.google.inject.grapher.ImplementationNode}-displaying {@link GraphvizNode}s.
  *
  * @author phopkins@gmail.com (Pete Hopkins)
  */

File: extensions/struts2/src/com/google/inject/struts2/GuiceObjectFactory.java
Patch:
@@ -40,7 +40,7 @@
 import java.util.logging.Logger;
 
 /**
- * @deprecated Use {@link com.google.inject.servlet.Struts2Factory} instead.
+ * @deprecated Use {@link com.google.inject.struts2.Struts2Factory} instead.
  */
 @Deprecated
 public class GuiceObjectFactory extends ObjectFactory {

File: core/test/com/google/inject/BinderTest.java
Patch:
@@ -360,7 +360,7 @@ protected void configure() {
 
   /**
    * See issue 614, Problem One
-   * http://code.google.com/p/google-guice/issues/detail?id=614
+   * https://github.com/google/guice/issues/614
    */
   public void testJitDependencyDoesntBlockOtherExplicitBindings() {
     Injector injector = Guice.createInjector(new AbstractModule() {
@@ -377,7 +377,7 @@ protected void configure() {
 
   /**
    * See issue 614, Problem Two
-   * http://code.google.com/p/google-guice/issues/detail?id=614
+   * https://github.com/google/guice/issues/id=614
    */
   public void testJitDependencyCanUseExplicitDependencies() {
     Guice.createInjector(new AbstractModule() {

File: core/test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -225,7 +225,7 @@ static class JitValid { @Inject JitValid2 a; }
   static class JitValid2 {}
   
   /**
-   * Regression test for http://code.google.com/p/google-guice/issues/detail?id=319
+   * Regression test for https://github.com/google/guice/issues/319
    * 
    * The bug is that a class that asks for a provider for itself during injection time, 
    * where any one of the other types required to fulfill the object creation was bound 

File: extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java
Patch:
@@ -116,7 +116,7 @@ private boolean isBound(Injector injector, Key<?> key) {
    * appropriate for testing if a key is bound and not for injecting.
    *
    * See Guice bug 125,
-   * http://code.google.com/p/google-guice/issues/detail?id=125
+   * https://github.com/google/guice/issues/125
    */
   public Key<?> fixAnnotations(Key<?> key) {
     return key.getAnnotation() == null

File: extensions/multibindings/test/com/google/inject/multibindings/MapBinderTest.java
Patch:
@@ -46,6 +46,7 @@
 import com.google.inject.ProvisionException;
 import com.google.inject.Stage;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.WeakKeySetUtils;
 import com.google.inject.name.Names;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;

File: extensions/persist/src/com/google/inject/persist/Transactional.java
Patch:
@@ -24,7 +24,8 @@
 
 /**
  * <p> Any method or class marked with this annotation will be considered for transactionality.
- * Consult the documentation on http://code.google.com/p/google-guice for detailed semantics.
+ * Consult the documentation on https://github.com/google/guice/wiki/GuicePersist for detailed
+ * semantics.
  * Marking a method {@code @Transactional} will start a new transaction before the method
  * executes and commit it after the method returns.
  * <p>

File: extensions/servlet/src/com/google/inject/servlet/InternalServletModule.java
Patch:
@@ -72,7 +72,7 @@ public ServletContext get() {
           + " warned that this MAY have unexpected behavior if you have more"
           + " than one injector (with ServletModule) running in the same JVM."
           + " Please consult the Guice documentation at"
-          + " http://code.google.com/p/google-guice/wiki/Servlets for more"
+          + " https://github.com/google/guice/wiki/Servlets for more"
           + " information.");
       return GuiceFilter.getServletContext();
     }

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -209,7 +209,7 @@ public String getPathInfo() {
           int servletPathLength = servletPath.length();
           String requestUri = getRequestURI();
           pathInfo = requestUri.substring(getContextPath().length()).replaceAll("[/]{2,}", "/");
-          // See: http://code.google.com/p/google-guice/issues/detail?id=372
+          // See: https://github.com/google/guice/issues/372
           if (pathInfo.startsWith(servletPath)) {
             pathInfo = pathInfo.substring(servletPathLength);
             // Corner case: when servlet path & request path match exactly (without trailing '/'),

File: extensions/multibindings/test/com/google/inject/multibindings/MapBinderTest.java
Patch:
@@ -46,6 +46,7 @@
 import com.google.inject.ProvisionException;
 import com.google.inject.Stage;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.WeakKeySetUtils;
 import com.google.inject.name.Names;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;

File: extensions/multibindings/test/com/google/inject/multibindings/OptionalBinderTest.java
Patch:
@@ -42,6 +42,7 @@
 import com.google.inject.Scopes;
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.RehashableKeys;
+import com.google.inject.internal.WeakKeySetUtils;
 import com.google.inject.multibindings.OptionalBinder.Actual;
 import com.google.inject.multibindings.OptionalBinder.Default;
 import com.google.inject.multibindings.SpiUtils.VisitType;

File: extensions/servlet/test/com/google/inject/servlet/ContinuingRequestIntegrationTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject.servlet;
 
+import javax.servlet.http.Cookie;
 import static org.easymock.EasyMock.createMock;
 import static org.easymock.EasyMock.expect;
 import static org.easymock.EasyMock.replay;
@@ -128,6 +129,7 @@ public final void testRequestContinuesInOtherThread()
         .andReturn("")
         .anyTimes();
     expect(request.getMethod()).andReturn("GET");
+    expect(request.getCookies()).andReturn(new Cookie[0]);
 
     FilterChain filterChain = createMock(FilterChain.class);
     expect(request.getParameter(PARAM_NAME)).andReturn(PARAM_VALUE);
@@ -171,6 +173,7 @@ public final void testRequestContinuationDiesInHttpRequestThread()
         .anyTimes();
 
     expect(request.getMethod()).andReturn("GET");
+    expect(request.getCookies()).andReturn(new Cookie[0]);
     FilterChain filterChain = createMock(FilterChain.class);
 
     replay(request, filterConfig, filterChain);

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/CheckedProviderTest.java
Patch:
@@ -746,7 +746,7 @@ String foo() throws RemoteException {
   }
 
   interface StringRemoteProvider extends CheckedProvider<String> {
-    String get() throws RemoteException;  
+    @Override String get() throws RemoteException;  
   }
 
   @SuppressWarnings("deprecation")

File: core/src/com/google/inject/CreationException.java
Patch:
@@ -47,7 +47,7 @@ public Collection<Message> getErrorMessages() {
   }
 
   @Override public String getMessage() {
-    return Errors.format("Guice creation errors", messages);
+    return Errors.format("Unable to create injector, see the following errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: core/src/com/google/inject/ProvisionException.java
Patch:
@@ -57,7 +57,7 @@ public Collection<Message> getErrorMessages() {
   }
 
   @Override public String getMessage() {
-    return Errors.format("Guice provision errors", messages);
+    return Errors.format("Unable to provision, see the following errors", messages);
   }
 
   private static final long serialVersionUID = 0;

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -331,7 +331,7 @@ public <F> Module build(TypeLiteral<F> factoryInterface) {
   public <F> Module build(final Key<F> factoryInterface) {
     return new AbstractModule() {
       @Override protected void configure() {
-        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, bindings);  
+        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, bindings);
         bind(factoryInterface).toProvider(provider);
       }
     };

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -331,7 +331,7 @@ public <F> Module build(TypeLiteral<F> factoryInterface) {
   public <F> Module build(final Key<F> factoryInterface) {
     return new AbstractModule() {
       @Override protected void configure() {
-        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, null, bindings);
+        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, bindings);  
         bind(factoryInterface).toProvider(provider);
       }
     };

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -331,7 +331,7 @@ public <F> Module build(TypeLiteral<F> factoryInterface) {
   public <F> Module build(final Key<F> factoryInterface) {
     return new AbstractModule() {
       @Override protected void configure() {
-        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, bindings);  
+        Provider<F> provider = new FactoryProvider2<F>(factoryInterface, null, bindings);
         bind(factoryInterface).toProvider(provider);
       }
     };

File: extensions/servlet/test/com/google/inject/servlet/AllTests.java
Patch:
@@ -49,10 +49,12 @@ public static Test suite() {
 
     // Multiple modules tests.
     suite.addTestSuite(MultiModuleDispatchIntegrationTest.class);
-    
+
     // Extension SPI tests.
     suite.addTestSuite(ExtensionSpiTest.class);
 
+    suite.addTestSuite(UriPatternTypeTest.class);
+
     return suite;
   }
 }

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizGrapher.java
Patch:
@@ -116,7 +116,7 @@ protected Map<String, String> getNodeAttributes(GraphvizNode node) {
 
     attrs.put("label", getNodeLabel(node));
     // remove most of the margin because the table has internal padding
-    attrs.put("margin", "0.02,0");
+    attrs.put("margin", "\"0.02,0\"");
     attrs.put("shape", node.getShape().toString());
     attrs.put("style", node.getStyle().toString());
     

File: core/test/com/google/inject/OptionalBindingTest.java
Patch:
@@ -255,6 +255,9 @@ public void testOptionalConstructorBlowsUp() {
   }
 
   static class HasOptionalConstructor {
+    // Suppress compiler errors by the error-prone checker InjectedConstructorAnnotations,
+    // which catches optional injected constructors.
+    @SuppressWarnings("InjectedConstructorAnnotations")
     @Inject(optional=true)
     HasOptionalConstructor() {}
   }

File: core/test/com/google/inject/ProvisionExceptionTest.java
Patch:
@@ -295,6 +295,9 @@ static class MethodWithBindingAnnotation {
   }
 
   static class ConstructorWithBindingAnnotation {
+    // Suppress compiler errors by the error-prone checker InjectedConstructorAnnotations,
+    // which catches injected constructors with binding annotations.
+    @SuppressWarnings("InjectedConstructorAnnotations")
     @Inject @Green ConstructorWithBindingAnnotation(String greenString) {}
   }
 

File: core/src/com/google/inject/internal/util/LineNumbers.java
Patch:
@@ -129,7 +129,7 @@ private class LineNumberReader extends ClassVisitor {
     private String name;
 
     LineNumberReader() {
-      super(Opcodes.ASM4);
+      super(Opcodes.ASM5);
     }
 
     public void visit(int version, int access, String name, String signature,
@@ -179,7 +179,7 @@ public AnnotationVisitor visitParameterAnnotation(int parameter,
 
     class LineNumberMethodVisitor extends MethodVisitor {
       LineNumberMethodVisitor() {
-        super(Opcodes.ASM4);
+        super(Opcodes.ASM5);
       }
 
       public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
@@ -205,7 +205,7 @@ public void visitLineNumber(int line, Label start) {
 
     class LineNumberAnnotationVisitor extends AnnotationVisitor {
       LineNumberAnnotationVisitor() {
-        super(Opcodes.ASM4);
+        super(Opcodes.ASM5);
       }
       public AnnotationVisitor visitAnnotation(String name, String desc) {
         return this;

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -98,7 +98,7 @@ protected void putBinding(BindingImpl<?> binding) {
     }
 
     // prevent the parent from creating a JIT binding for this key
-    injector.state.parent().blacklist(key, binding.getSource());
+    injector.state.parent().blacklist(key, injector.state, binding.getSource());
     injector.state.putBinding(key, binding);
   }
 

File: core/src/com/google/inject/internal/State.java
Patch:
@@ -105,7 +105,7 @@ public List<ProvisionListenerBinding> getProvisionListenerBindings() {
       return ImmutableList.of();
     }
 
-    public void blacklist(Key<?> key, Object source) {
+    public void blacklist(Key<?> key, State state, Object source) {
     }
 
     public boolean isBlacklisted(Key<?> key) {
@@ -165,9 +165,9 @@ TypeConverterBinding getConverter(
   /**
    * Forbids the corresponding injector from creating a binding to {@code key}. Child injectors
    * blacklist their bound keys on their parent injectors to prevent just-in-time bindings on the
-   * parent injector that would conflict.
+   * parent injector that would conflict and pass along their state to control the lifetimes.
    */
-  void blacklist(Key<?> key, Object source);
+  void blacklist(Key<?> key, State state, Object source);
 
   /**
    * Returns true if {@code key} is forbidden from being bound in this injector. This indicates that

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.inject.internal.MoreTypesTest;
 import com.google.inject.internal.RehashableKeysTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
+import com.google.inject.internal.WeakKeySetTest;
 import com.google.inject.internal.util.LineNumbersTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.name.NamedEquivalanceTest;
@@ -106,6 +107,7 @@ public static Test suite() {
     suite.addTestSuite(TypeLiteralInjectionTest.class);
     suite.addTestSuite(TypeLiteralTest.class);
     suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
+    suite.addTestSuite(WeakKeySetTest.class);
 
     // internal
     suite.addTestSuite(LineNumbersTest.class);

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -98,7 +98,7 @@ protected void putBinding(BindingImpl<?> binding) {
     }
 
     // prevent the parent from creating a JIT binding for this key
-    injector.state.parent().blacklist(key, injector.state, binding.getSource());
+    injector.state.parent().blacklist(key, binding.getSource());
     injector.state.putBinding(key, binding);
   }
 

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -791,7 +791,7 @@ private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors e
     }
 
     BindingImpl<T> binding = createJustInTimeBinding(key, errors, jitDisabled, jitType);
-    state.parent().blacklist(key, state, binding.getSource());
+    state.parent().blacklist(key, binding.getSource());
     jitBindings.put(key, binding);
     return binding;
   }

File: core/src/com/google/inject/internal/State.java
Patch:
@@ -105,7 +105,7 @@ public List<ProvisionListenerBinding> getProvisionListenerBindings() {
       return ImmutableList.of();
     }
 
-    public void blacklist(Key<?> key, State state, Object source) {
+    public void blacklist(Key<?> key, Object source) {
     }
 
     public boolean isBlacklisted(Key<?> key) {
@@ -165,9 +165,9 @@ TypeConverterBinding getConverter(
   /**
    * Forbids the corresponding injector from creating a binding to {@code key}. Child injectors
    * blacklist their bound keys on their parent injectors to prevent just-in-time bindings on the
-   * parent injector that would conflict and pass along their state to control the lifetimes.
+   * parent injector that would conflict.
    */
-  void blacklist(Key<?> key, State state, Object source);
+  void blacklist(Key<?> key, Object source);
 
   /**
    * Returns true if {@code key} is forbidden from being bound in this injector. This indicates that

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.inject.internal.MoreTypesTest;
 import com.google.inject.internal.RehashableKeysTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
-import com.google.inject.internal.WeakKeySetTest;
 import com.google.inject.internal.util.LineNumbersTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.name.NamedEquivalanceTest;
@@ -107,7 +106,6 @@ public static Test suite() {
     suite.addTestSuite(TypeLiteralInjectionTest.class);
     suite.addTestSuite(TypeLiteralTest.class);
     suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
-    suite.addTestSuite(WeakKeySetTest.class);
 
     // internal
     suite.addTestSuite(LineNumbersTest.class);

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -98,7 +98,7 @@ protected void putBinding(BindingImpl<?> binding) {
     }
 
     // prevent the parent from creating a JIT binding for this key
-    injector.state.parent().blacklist(key, binding.getSource());
+    injector.state.parent().blacklist(key, injector.state, binding.getSource());
     injector.state.putBinding(key, binding);
   }
 

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -791,7 +791,7 @@ private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors e
     }
 
     BindingImpl<T> binding = createJustInTimeBinding(key, errors, jitDisabled, jitType);
-    state.parent().blacklist(key, binding.getSource());
+    state.parent().blacklist(key, state, binding.getSource());
     jitBindings.put(key, binding);
     return binding;
   }

File: core/src/com/google/inject/internal/State.java
Patch:
@@ -105,7 +105,7 @@ public List<ProvisionListenerBinding> getProvisionListenerBindings() {
       return ImmutableList.of();
     }
 
-    public void blacklist(Key<?> key, Object source) {
+    public void blacklist(Key<?> key, State state, Object source) {
     }
 
     public boolean isBlacklisted(Key<?> key) {
@@ -165,9 +165,9 @@ TypeConverterBinding getConverter(
   /**
    * Forbids the corresponding injector from creating a binding to {@code key}. Child injectors
    * blacklist their bound keys on their parent injectors to prevent just-in-time bindings on the
-   * parent injector that would conflict.
+   * parent injector that would conflict and pass along their state to control the lifetimes.
    */
-  void blacklist(Key<?> key, Object source);
+  void blacklist(Key<?> key, State state, Object source);
 
   /**
    * Returns true if {@code key} is forbidden from being bound in this injector. This indicates that

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.inject.internal.MoreTypesTest;
 import com.google.inject.internal.RehashableKeysTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
+import com.google.inject.internal.WeakKeySetTest;
 import com.google.inject.internal.util.LineNumbersTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.name.NamedEquivalanceTest;
@@ -106,6 +107,7 @@ public static Test suite() {
     suite.addTestSuite(TypeLiteralInjectionTest.class);
     suite.addTestSuite(TypeLiteralTest.class);
     suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
+    suite.addTestSuite(WeakKeySetTest.class);
 
     // internal
     suite.addTestSuite(LineNumbersTest.class);

File: extensions/multibindings/src/com/google/inject/multibindings/Element.java
Patch:
@@ -38,7 +38,8 @@
 
   enum Type {
     MAPBINDER,
-    MULTIBINDER;
+    MULTIBINDER,
+    OPTIONALBINDER;
   }
 
   String setName();

File: extensions/persist/src/com/google/inject/persist/jpa/JpaLocalTxnInterceptor.java
Patch:
@@ -33,11 +33,12 @@
  */
 class JpaLocalTxnInterceptor implements MethodInterceptor {
 
+  // TODO(gak): Move these args to the cxtor & make these final.
   @Inject
-  private final JpaPersistService emProvider = null;
+  private JpaPersistService emProvider = null;
 
   @Inject
-  private final UnitOfWork unitOfWork = null;
+  private UnitOfWork unitOfWork = null;
 
   @Transactional
   private static class Internal {}

File: core/src/com/google/inject/Inject.java
Patch:
@@ -38,7 +38,7 @@
  * 
  * <li>Pre-constructed instances passed to {@link Injector#injectMembers},
  * {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and
- * {@link com.google.inject.binder.LinkedBindingBuilder#toProvider(Provider)}.
+ * {@link com.google.inject.binder.LinkedBindingBuilder#toProvider(javax.inject.Provider)}.
  * In this case all constructors are, of course, ignored.
  *
  * <li>Static fields and methods of classes which any {@link Module} has

File: core/src/com/google/inject/internal/InternalFactoryToInitializableAdapter.java
Patch:
@@ -18,7 +18,6 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.inject.Provider;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.ProviderInstanceBinding;
 
@@ -31,10 +30,10 @@
 final class InternalFactoryToInitializableAdapter<T> extends ProviderInternalFactory<T> {
 
   private final ProvisionListenerStackCallback<T> provisionCallback;
-  private final Initializable<Provider<? extends T>> initializable;
+  private final Initializable<? extends javax.inject.Provider<? extends T>> initializable;
 
   public InternalFactoryToInitializableAdapter(
-      Initializable<Provider<? extends T>> initializable,
+      Initializable<? extends javax.inject.Provider<? extends T>> initializable,
       Object source, boolean allowProxy,
       ProvisionListenerStackCallback<T> provisionCallback) {
     super(source, allowProxy);

File: core/test/com/google/inject/spi/SpiBindingsTest.java
Patch:
@@ -118,7 +118,7 @@ protected void configure() {
             binding.acceptTargetVisitor(new FailingTargetVisitor<T>() {
               @Override public Void visit(
                   ProviderInstanceBinding<? extends T> binding) {
-                assertSame(stringProvider, binding.getProviderInstance());
+                assertSame(stringProvider, binding.getUserSuppliedProvider());
                 return null;
               }
             });
@@ -359,7 +359,7 @@ protected void configure() {
         bind(String.class).toProvider(new ProviderWithExtensionVisitor<String>() {
           public <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
               ProviderInstanceBinding<? extends B> binding) {
-            assertSame(this, binding.getProviderInstance());
+            assertSame(this, binding.getUserSuppliedProvider());
             // We can't always check for FailingSpiTargetVisitor,
             // because constructing the injector visits here, and we need
             // to process the binding as normal

File: extensions/grapher/src/com/google/inject/grapher/DefaultNodeCreator.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.InstanceBinding;
 import com.google.inject.spi.ProviderInstanceBinding;
+
 import java.lang.reflect.Member;
 import java.util.Collection;
 import java.util.List;
@@ -120,7 +121,7 @@ private <T extends Binding<?> & HasDependencies> InstanceNode newInstanceNode(T
      */
     @Override public Collection<Node> visit(ProviderInstanceBinding<?> binding) {
       return ImmutableList.<Node>of(newInterfaceNode(binding), newInstanceNode(binding,
-          binding.getProviderInstance()));
+          binding.getUserSuppliedProvider()));
     }
 
     @Override public Collection<Node> visitOther(Binding<?> binding) {

File: extensions/grapher/test/com/google/inject/grapher/ShortNameFactoryTest.java
Patch:
@@ -157,7 +157,7 @@ public void testGetInstanceName_providerMethod() throws Exception {
         new DefaultBindingTargetVisitor<Object, Void>() {
           @SuppressWarnings("unchecked") @Override
           public Void visit(ProviderInstanceBinding<?> binding) {
-            methodHolder[0] = (ProviderMethod) binding.getProviderInstance();
+            methodHolder[0] = (ProviderMethod) binding.getUserSuppliedProvider();
             return null;
           }
         });

File: extensions/multibindings/test/com/google/inject/multibindings/SpiUtils.java
Patch:
@@ -135,7 +135,7 @@ private static <T> void mapInjectorTest(Key<T> mapKey, TypeLiteral<?> keyType,
           break;
         case PROVIDER_INSTANCE:
           if (value instanceof ProviderInstanceBinding
-              && ((ProviderInstanceBinding) value).getProviderInstance().get().equals(
+              && ((ProviderInstanceBinding) value).getUserSuppliedProvider().get().equals(
                   result.v.instance)) {
             found = entry;
           }
@@ -376,7 +376,7 @@ private static <T> void setInjectorTest(Key<T> setKey, TypeLiteral<?> elementTyp
           break;
         case PROVIDER_INSTANCE:
           if (item instanceof ProviderInstanceBinding
-              && ((ProviderInstanceBinding) item).getProviderInstance().get().equals(
+              && ((ProviderInstanceBinding) item).getUserSuppliedProvider().get().equals(
                   result.instance)) {
             found = item;
           }

File: core/src/com/google/inject/ProvisionException.java
Patch:
@@ -18,7 +18,6 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.Errors;
 import com.google.inject.spi.Message;
@@ -45,7 +44,7 @@ public ProvisionException(Iterable<Message> messages) {
 
   public ProvisionException(String message, Throwable cause) {
     super(cause);
-    this.messages = ImmutableSet.of(new Message(ImmutableList.of(), message, cause));
+    this.messages = ImmutableSet.of(new Message(message, cause));
   }
 
   public ProvisionException(String message) {

File: core/src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -147,7 +147,7 @@ List<InjectorShell> build(
 
       // add default type converters if this is a top-level injector
       if (parent == null) {
-        new TypeConverterBindingProcessor(errors).prepareBuiltInConverters(injector);
+        TypeConverterBindingProcessor.prepareBuiltInConverters(injector);
       }
 
       stopwatch.resetAndLog("Module execution");

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -171,7 +171,7 @@ static class OverrideModule extends AbstractModule {
     @Override
     public void configure() {
       Binder baseBinder = binder();
-      List<Element> baseElements = Elements.getElements(baseModules);
+      List<Element> baseElements = Elements.getElements(currentStage(), baseModules);
 
       // If the sole element was a PrivateElements, we want to override
       // the private elements within that -- so refocus our elements
@@ -191,7 +191,7 @@ public void configure() {
       
       final Binder binder = baseBinder.skipSources(this.getClass());
       final LinkedHashSet<Element> elements = new LinkedHashSet<Element>(baseElements);
-      final List<Element> overrideElements = Elements.getElements(overrides);
+      final List<Element> overrideElements = Elements.getElements(currentStage(), overrides);
 
       final Set<Key<?>> overriddenKeys = Sets.newHashSet();
       final Map<Class<? extends Annotation>, ScopeBinding> overridesScopeAnnotations =

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -171,7 +171,7 @@ static class OverrideModule extends AbstractModule {
     @Override
     public void configure() {
       Binder baseBinder = binder();
-      List<Element> baseElements = Elements.getElements(currentStage(), baseModules);
+      List<Element> baseElements = Elements.getElements(baseModules);
 
       // If the sole element was a PrivateElements, we want to override
       // the private elements within that -- so refocus our elements
@@ -191,7 +191,7 @@ public void configure() {
       
       final Binder binder = baseBinder.skipSources(this.getClass());
       final LinkedHashSet<Element> elements = new LinkedHashSet<Element>(baseElements);
-      final List<Element> overrideElements = Elements.getElements(currentStage(), overrides);
+      final List<Element> overrideElements = Elements.getElements(overrides);
 
       final Set<Key<?>> overriddenKeys = Sets.newHashSet();
       final Map<Class<? extends Annotation>, ScopeBinding> overridesScopeAnnotations =

File: core/test/com/google/inject/ProvisionListenerTest.java
Patch:
@@ -44,6 +44,7 @@
  * 
  * @author sameb@google.com (Sam Berlin)
  */
+// TODO(sameb): Add some tests for private modules & child injectors.
 public class ProvisionListenerTest extends TestCase {
 
   public void testExceptionInListenerBeforeProvisioning() {

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -115,7 +115,7 @@ private Errors(Errors parent, Object source) {
    * Returns an instance that uses {@code source} as a reference point for newly added errors.
    */
   public Errors withSource(Object source) {
-    return source == SourceProvider.UNKNOWN_SOURCE
+    return source == this.source || source == SourceProvider.UNKNOWN_SOURCE
         ? this
         : new Errors(this, source);
   }

File: core/src/com/google/inject/spi/Elements.java
Patch:
@@ -325,7 +325,7 @@ public void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
     }
 
     public RecordingBinder withSource(final Object source) {            
-      return new RecordingBinder(this, source, null);
+      return source == this.source ? this : new RecordingBinder(this, source, null);
     }
 
     public RecordingBinder skipSources(Class... classesToSkip) {

File: extensions/servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -52,7 +52,7 @@ private ServletScopes() {}
   /**
    * A threadlocal scope map for non-http request scopes. The {@link #REQUEST}
    * scope falls back to this scope map if no http request is available, and
-   * requires {@link #scopeRequest} to be called as an alertnative.
+   * requires {@link #scopeRequest} to be called as an alternative.
    */
   private static final ThreadLocal<Context> requestScopeContext
       = new ThreadLocal<Context>();

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -171,7 +171,7 @@ static class OverrideModule extends AbstractModule {
     @Override
     public void configure() {
       Binder baseBinder = binder();
-      List<Element> baseElements = Elements.getElements(baseModules);
+      List<Element> baseElements = Elements.getElements(currentStage(), baseModules);
 
       // If the sole element was a PrivateElements, we want to override
       // the private elements within that -- so refocus our elements
@@ -191,7 +191,7 @@ public void configure() {
       
       final Binder binder = baseBinder.skipSources(this.getClass());
       final LinkedHashSet<Element> elements = new LinkedHashSet<Element>(baseElements);
-      final List<Element> overrideElements = Elements.getElements(overrides);
+      final List<Element> overrideElements = Elements.getElements(currentStage(), overrides);
 
       final Set<Key<?>> overriddenKeys = Sets.newHashSet();
       final Map<Class<? extends Annotation>, ScopeBinding> overridesScopeAnnotations =

File: core/src/com/google/inject/internal/ProvidedByInternalFactory.java
Patch:
@@ -58,16 +58,15 @@ public void initialize(InjectorImpl injector, Errors errors) throws ErrorsExcept
     providerBinding =
         injector.getBindingOrThrow(providerKey, errors, JitLimitation.NEW_OR_EXISTING_JIT);
   }
-  
-  @SuppressWarnings("unchecked")// 
+
   public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
       throws ErrorsException {
     checkState(providerBinding != null, "not initialized");
     
     context.pushState(providerKey, providerBinding.getSource());
     try {
       errors = errors.withSource(providerKey);
-      Provider provider = providerBinding.getInternalFactory().get(
+      Provider<? extends T> provider = providerBinding.getInternalFactory().get(
           errors, context, dependency, true);
       return circularGet(provider, errors, context, dependency, linked, provisionCallback);
     } finally {

File: core/src/com/google/inject/spi/DefaultBindingTargetVisitor.java
Patch:
@@ -69,9 +69,9 @@ public V visit(ConvertedConstantBinding<? extends T> convertedConstantBinding) {
     return visitOther(convertedConstantBinding);
   }
 
-   // javac says it's an error to cast ProviderBinding<? extends T> to Binding<? extends T>
   @SuppressWarnings("unchecked")
   public V visit(ProviderBinding<? extends T> providerBinding) {
-    return visitOther((Binding) providerBinding);
+    // TODO(cushon): remove raw (Binding) cast when we don't care about javac 6 anymore
+    return visitOther((Binding<? extends T>) (Binding) providerBinding);
   }
 }

File: core/test/com/google/inject/NullableInjectionPointTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.google.inject;
 
 import static com.google.inject.Asserts.assertContains;
+import static com.google.inject.Asserts.getDeclaringSourcePart;
 
 import junit.framework.TestCase;
 
@@ -122,7 +123,7 @@ protected void configure() {
     } catch (CreationException expected) {
       assertContains(expected.getMessage(),
           "Binding to null instances is not allowed.",
-          "at " + getClass().getName(), ".configure(NullableInjectionPointTest.java:");
+          "at " + getClass().getName(), getDeclaringSourcePart(getClass()));
     }
   }
 

File: core/test/com/google/inject/ParentInjectorTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject;
 
 import static com.google.inject.Asserts.assertContains;
+import static com.google.inject.Asserts.getDeclaringSourcePart;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
@@ -44,8 +45,8 @@ public void testParentAndChildCannotShareExplicitBindings() {
       fail("Created the same explicit binding on both parent and child");
     } catch (CreationException e) {
       assertContains(e.getMessage(), "A binding to ", A.class.getName(), " was already configured",
-          " at ", getClass().getName(), ".configure(ParentInjectorTest.java:",
-          " at ", getClass().getName(), ".configure(ParentInjectorTest.java:");
+          " at ", getClass().getName(), getDeclaringSourcePart(getClass()),
+          " at ", getClass().getName(), getDeclaringSourcePart(getClass()));
     }
   }
 

File: core/test/com/google/inject/RequestInjectionTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject;
 
 import static com.google.inject.Asserts.assertContains;
+import static com.google.inject.Asserts.getDeclaringSourcePart;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.inject.matcher.Matchers;
@@ -128,7 +129,7 @@ public Runnable get() {
       assertContains(expected.getMessage(),
           "1) Error in custom provider, java.lang.UnsupportedOperationException",
           "for field at " + NeedsRunnable.class.getName() + ".runnable(RequestInjectionTest.java:",
-          "at " + getClass().getName(), ".configure(RequestInjectionTest.java:");
+          "at " + getClass().getName(), getDeclaringSourcePart(getClass()));
     }
   }
 

File: core/src/com/google/inject/spi/TypeConverterBinding.java
Patch:
@@ -20,6 +20,7 @@
 
 import com.google.inject.Binder;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.Errors;
 import com.google.inject.matcher.Matcher;
 
 /**
@@ -67,6 +68,6 @@ public void applyTo(Binder binder) {
 
   @Override public String toString() {
     return typeConverter + " which matches " + typeMatcher
-        + " (bound at " + source + ")";
+        + " (bound at " + Errors.convert(source) + ")";
   }
 }

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -37,6 +37,7 @@
 import com.google.inject.spi.SpiBindingsTest;
 import com.google.inject.spi.ToolStageInjectorTest;
 import com.google.inject.util.NoopOverrideTest;
+import com.google.inject.util.OverrideModuleTest;
 import com.google.inject.util.ProvidersTest;
 import com.google.inject.util.TypesTest;
 

File: core/test/com/google/inject/spi/ElementApplyToTest.java
Patch:
@@ -23,6 +23,7 @@
  */
 public class ElementApplyToTest extends ElementsTest {
 
+  @Override
   protected void checkModule(Module module, ElementVisitor<?>... visitors) {
     // convert from module to elements and back
     super.checkModule(Elements.getModule(Elements.getElements(module)), visitors);

File: core/test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -20,7 +20,6 @@
 import static com.google.inject.Asserts.assertContains;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
@@ -77,7 +76,7 @@ public class ElementsTest extends TestCase {
   public void testAddMessageErrorCommand() {
     checkModule(
         new AbstractModule() {
-          protected void configure() {
+          @Override protected void configure() {
             addError("Message %s %d %s", "A", 5, "C");
           }
         },

File: core/test/com/google/inject/ErrorHandlingTest.java
Patch:
@@ -100,7 +100,9 @@ static class Invalid {
     Invalid(String s) {}
   }
 
-  @Singleton @GoodScope
+  @SuppressWarnings("MoreThanOneScopeAnnotationOnClass") // suppress compiler error to test
+  @Singleton 
+  @GoodScope
   static class TooManyScopes {
   }
 

File: core/test/com/google/inject/ScopesTest.java
Patch:
@@ -413,7 +413,9 @@ static class NotASingleton {
     final int instanceId = nextInstanceId++;
   }
 
-  @Singleton @CustomScoped
+  @SuppressWarnings("MoreThanOneScopeAnnotationOnClass") // suppress compiler error for testing
+  @Singleton
+  @CustomScoped
   static class SingletonAndCustomScoped {}
 
   @ImplementedBy(Implementation.class)

File: core/src/com/google/inject/Inject.java
Patch:
@@ -34,7 +34,7 @@
  * <li>Every instance it constructs. The class being constructed must have
  * exactly one of its constructors marked with {@code @Inject} or must have a
  * constructor taking no parameters. The Injector then proceeds to perform
- * method and field injections.
+ * field and method injections.
  * 
  * <li>Pre-constructed instances passed to {@link Injector#injectMembers},
  * {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.MoreTypesTest;
+import com.google.inject.internal.RehashableKeysTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
 import com.google.inject.internal.util.LineNumbersTest;
 import com.google.inject.matcher.MatcherTest;
@@ -94,6 +95,7 @@ public static Test suite() {
     suite.addTestSuite(ProvisionListenerTest.class);
     // ProxyFactoryTest is AOP-only
     suite.addTestSuite(ReflectionTest.class);
+    suite.addTestSuite(RehashableKeysTest.class);
     suite.addTestSuite(RequestInjectionTest.class);
     suite.addTestSuite(RequireAtInjectOnConstructorsTest.class);
     suite.addTestSuite(ScopesTest.class);

File: core/test/com/googlecode/guice/Jsr330Test.java
Patch:
@@ -448,7 +448,9 @@ static class L {
   }
 
   static abstract class AbstractM {
-    @Inject abstract void setB(B b);
+    @SuppressWarnings("InjectJavaxInjectOnAbstractMethod")
+    @Inject
+    abstract void setB(B b);
   }
 
   static class M extends AbstractM {

File: core/test/com/googlecode/guice/Jsr330Test.java
Patch:
@@ -442,7 +442,9 @@ static class K {
   }
 
   static class L {
-    @Inject final B b = null;
+    @SuppressWarnings("InjectJavaxInjectOnFinalField")
+    @Inject
+    final B b = null;
   }
 
   static abstract class AbstractM {

File: core/src/com/google/inject/Provides.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Annotates methods of a {@link Module} to create a provider method binding. The method's return
- * type is bound to it's returned value. Guice will pass dependencies to the method as parameters.
+ * type is bound to its returned value. Guice will pass dependencies to the method as parameters.
  *
  * @author crazybob@google.com (Bob Lee)
  * @since 2.0

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -678,7 +678,7 @@ private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,
             InjectableMethod injectableMethod = new InjectableMethod(
                 current, method, atInject);
             if (checkForMisplacedBindingAnnotations(method, errors)
-                | !isValidMethod(injectableMethod, errors)) {
+                || !isValidMethod(injectableMethod, errors)) {
               if (overrideIndex != null) {
                 boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);
                 if(removed) {

File: core/src/com/google/inject/internal/ConstructorInjector.java
Patch:
@@ -94,7 +94,6 @@ public T call() throws ErrorsException {
         });
       }
     } finally {
-      constructionContext.removeCurrentReference();
       constructionContext.finishConstruction();
     }
   }
@@ -125,6 +124,8 @@ private T provision(Errors errors, InternalContext context,
           : userException;
       throw errors.withSource(constructionProxy.getInjectionPoint())
           .errorInjectingConstructor(cause).toException();
+    } finally {
+      constructionContext.removeCurrentReference();
     }
   }
 }

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -46,7 +46,7 @@ protected T circularGet(final Provider<? extends T> provider, final Errors error
       throws ErrorsException {    
     Class<?> expectedType = dependency.getKey().getTypeLiteral().getRawType();
     final ConstructionContext<T> constructionContext = context.getConstructionContext(this);
-    
+
     // We have a circular reference between constructors. Return a proxy.
     if (constructionContext.isConstructing()) {
       if (!allowProxy) {

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizGrapher.java
Patch:
@@ -249,7 +249,7 @@ protected List<String> htmlEscape(List<String> elements) {
   @Override protected void newImplementationNode(ImplementationNode node) {
     NodeId nodeId = node.getId();
     GraphvizNode gnode = new GraphvizNode(nodeId);
-    gnode.setStyle(NodeStyle.INVISIBLE);
+    gnode.setStyle(NodeStyle.SOLID);
 
     gnode.setHeaderBackgroundColor("#000000");
     gnode.setHeaderTextColor("#ffffff");
@@ -265,7 +265,7 @@ protected List<String> htmlEscape(List<String> elements) {
   @Override protected void newInstanceNode(InstanceNode node) {
     NodeId nodeId = node.getId();
     GraphvizNode gnode = new GraphvizNode(nodeId);
-    gnode.setStyle(NodeStyle.INVISIBLE);
+    gnode.setStyle(NodeStyle.SOLID);
 
     gnode.setHeaderBackgroundColor("#000000");
     gnode.setHeaderTextColor("#ffffff");

File: core/src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -228,7 +228,7 @@ public static boolean equals(Type a, Type b) {
       }
       TypeVariable<?> va = (TypeVariable) a;
       TypeVariable<?> vb = (TypeVariable) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+      return va.getGenericDeclaration().equals(vb.getGenericDeclaration())
           && va.getName().equals(vb.getName());
 
     } else {

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryModuleBuilderTest.java
Patch:
@@ -478,6 +478,7 @@ interface SingletonFactory {
     AssistedSingleton create(String string);
   }
   
+  @SuppressWarnings("GuiceAssistedInjectScoping")
   @Singleton
   static class AssistedSingleton {
     @Inject

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/ThrowingProviderBinder.java
Patch:
@@ -222,7 +222,7 @@ public T get() throws Exception {
             } else if (pe.getCause() instanceof Error) {
               throw (Error) pe.getCause();
             } else {
-              throw new AssertionError(pe.getCause()); // Impossible!
+              throw new AssertionError(pe); // Impossible!
             }
           }
         }

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethodsModule.java
Patch:
@@ -75,8 +75,7 @@ List<CheckedProviderMethod<?>> getProviderMethods(Binder binder) {
     List<CheckedProviderMethod<?>> result = Lists.newArrayList();
     for (Class<?> c = delegate.getClass(); c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
-        CheckedProvides checkedProvides =
-          (CheckedProvides)method.getAnnotation(CheckedProvides.class);
+        CheckedProvides checkedProvides = method.getAnnotation(CheckedProvides.class);
         if(checkedProvides != null) {
           result.add(createProviderMethod(binder, method, checkedProvides.value()));
         }

File: extensions/multibindings/src/com/google/inject/multibindings/RealElement.java
Patch:
@@ -44,7 +44,7 @@ public int uniqueId() {
   }
   
   public Type type() {
-	  return type;
+    return type;
   }
 
   public Class<? extends Annotation> annotationType() {

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -72,8 +72,8 @@
  * }</code></pre>
  *
  * <p>Contributing multibindings from different modules is supported. For
- * example, it is okay to have both {@code CandyModule} and {@code ChipsModule}
- * to both create their own {@code Multibinder<Snack>}, and to each contribute
+ * example, it is okay for both {@code CandyModule} and {@code ChipsModule}
+ * to create their own {@code Multibinder<Snack>}, and to each contribute
  * bindings to the set of snacks. When that set is injected, it will contain
  * elements from both modules.
  * 

File: extensions/servlet/src/com/google/inject/servlet/FilterChainInvocation.java
Patch:
@@ -18,7 +18,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 
 import java.io.IOException;
 import java.util.List;

File: extensions/servlet/src/com/google/inject/servlet/ManagedFilterPipeline.java
Patch:
@@ -81,8 +81,8 @@ private FilterDefinition[] collectFilterDefinitions(Injector injector) {
     for (Binding<FilterDefinition> entry : injector.findBindingsByType(FILTER_DEFS)) {
       filterDefinitions.add(entry.getProvider().get());
     }
-
-    // Convert to a fixed size array for speed.
+    
+    // Copy to a fixed-size array for speed of iteration.
     return filterDefinitions.toArray(new FilterDefinition[filterDefinitions.size()]);
   }
 

File: extensions/servlet/test/com/google/inject/servlet/FilterPipelineTest.java
Patch:
@@ -98,7 +98,7 @@ public final void testDispatchThruGuiceFilter() throws ServletException, IOExcep
 
   @Singleton
   public static class TestFilter implements Filter {
-    public void init(FilterConfig filterConfig) throws ServletException {
+    public void init(FilterConfig filterConfig) {
     }
 
     public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
@@ -112,11 +112,11 @@ public void destroy() {
 
   @Singleton
   public static class NeverFilter implements Filter {
-    public void init(FilterConfig filterConfig) throws ServletException {
+    public void init(FilterConfig filterConfig) {
     }
 
     public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
-        FilterChain filterChain) throws IOException, ServletException {
+        FilterChain filterChain) {
       fail("This filter should never have fired");
     }
 

File: core/src/com/google/inject/internal/Initializer.java
Patch:
@@ -159,7 +159,7 @@ public T get(Errors errors) throws ErrorsException {
         MembersInjectorImpl<T> membersInjector =
             (MembersInjectorImpl<T>)pendingMembersInjectors.remove(instance);
         Preconditions.checkState(membersInjector != null,
-            "No membersInjector available for instance: " + instance + ", from key: " + key);
+            "No membersInjector available for instance: %s, from key: %s", instance, key);
         
         // if in Stage.TOOL, we only want to inject & notify toolable injection points.
         // (otherwise we'll inject all of them)
@@ -174,4 +174,4 @@ public T get(Errors errors) throws ErrorsException {
       return instance.toString();
     }
   }
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/spi/ConvertedConstantBinding.java
Patch:
@@ -43,7 +43,7 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
   TypeConverterBinding getTypeConverterBinding();
 
   /**
-   * Returns the key for the source binding. That binding can e retrieved from an injector using
+   * Returns the key for the source binding. That binding can be retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
   Key<String> getSourceKey();
@@ -52,4 +52,4 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
    * Returns a singleton set containing only the converted key.
    */
   Set<Dependency<?>> getDependencies();
-}
\ No newline at end of file
+}

File: extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -77,6 +77,8 @@ public class GuiceFilter implements Filter {
       + "in your web application. If this is deliberate, you may safely "
       + "ignore this message. If this is NOT deliberate however, "
       + "your application may not work as expected.";
+  
+  private static final Logger LOGGER = Logger.getLogger(GuiceFilter.class.getName());
 
   public GuiceFilter() {
     // Use the static FilterPipeline
@@ -94,7 +96,7 @@ static void setPipeline(FilterPipeline pipeline) {
     // This can happen if you create many injectors and they all have their own
     // servlet module. This is legal, caveat a small warning.
     if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
-        Logger.getLogger(GuiceFilter.class.getName()).warning(MULTIPLE_INJECTORS_WARNING);
+      LOGGER.warning(MULTIPLE_INJECTORS_WARNING);
     }
 
     // We overwrite the default pipeline

File: core/src/com/google/inject/spi/ConvertedConstantBinding.java
Patch:
@@ -43,7 +43,7 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
   TypeConverterBinding getTypeConverterBinding();
 
   /**
-   * Returns the key for the source binding. That binding can be retrieved from an injector using
+   * Returns the key for the source binding. That binding can e retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
   Key<String> getSourceKey();

File: extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -78,8 +78,6 @@ public class GuiceFilter implements Filter {
       + "in your web application. If this is deliberate, you may safely "
       + "ignore this message. If this is NOT deliberate however, "
       + "your application may not work as expected.";
-  
-  private static final Logger LOGGER = Logger.getLogger(GuiceFilter.class.getName());
 
   //VisibleForTesting
   @Inject
@@ -88,7 +86,7 @@ static void setPipeline(FilterPipeline pipeline) {
     // This can happen if you create many injectors and they all have their own
     // servlet module. This is legal, caveat a small warning.
     if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
-      LOGGER.warning(MULTIPLE_INJECTORS_WARNING);
+        Logger.getLogger(GuiceFilter.class.getName()).warning(MULTIPLE_INJECTORS_WARNING);
     }
 
     // We overwrite the default pipeline

File: core/src/com/google/inject/spi/ConvertedConstantBinding.java
Patch:
@@ -43,7 +43,7 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
   TypeConverterBinding getTypeConverterBinding();
 
   /**
-   * Returns the key for the source binding. That binding can e retrieved from an injector using
+   * Returns the key for the source binding. That binding can be retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
   Key<String> getSourceKey();

File: extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -78,6 +78,8 @@ public class GuiceFilter implements Filter {
       + "in your web application. If this is deliberate, you may safely "
       + "ignore this message. If this is NOT deliberate however, "
       + "your application may not work as expected.";
+  
+  private static final Logger LOGGER = Logger.getLogger(GuiceFilter.class.getName());
 
   //VisibleForTesting
   @Inject
@@ -86,7 +88,7 @@ static void setPipeline(FilterPipeline pipeline) {
     // This can happen if you create many injectors and they all have their own
     // servlet module. This is legal, caveat a small warning.
     if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
-        Logger.getLogger(GuiceFilter.class.getName()).warning(MULTIPLE_INJECTORS_WARNING);
+      LOGGER.warning(MULTIPLE_INJECTORS_WARNING);
     }
 
     // We overwrite the default pipeline

File: extensions/servlet/src/com/google/inject/servlet/ManagedFilterPipeline.java
Patch:
@@ -137,15 +137,14 @@ public void dispatch(ServletRequest request, ServletResponse response,
   private ServletRequest withDispatcher(ServletRequest servletRequest,
       final ManagedServletPipeline servletPipeline) {
 
-    HttpServletRequest request = (HttpServletRequest) servletRequest;
-
     // don't wrap the request if there are no servlets mapped. This prevents us from inserting our
     // wrapper unless it's actually going to be used. This is necessary for compatibility for apps
     // that downcast their HttpServletRequests to a concrete implementation.
     if (!servletPipeline.hasServletsMapped()) {
       return servletRequest;
     }
 
+    HttpServletRequest request = (HttpServletRequest) servletRequest;
     //noinspection OverlyComplexAnonymousInnerClass
     return new HttpServletRequestWrapper(request) {
 

File: core/src/com/google/inject/internal/ConstructorInjectorStore.java
Patch:
@@ -31,6 +31,7 @@ final class ConstructorInjectorStore {
 
   private final FailableCache<InjectionPoint, ConstructorInjector<?>>  cache
       = new FailableCache<InjectionPoint, ConstructorInjector<?>> () {
+    @Override
     protected ConstructorInjector<?> create(InjectionPoint constructorInjector, Errors errors)
         throws ErrorsException {
       return createConstructor(constructorInjector, errors);

File: extensions/grapher/src/com/google/inject/grapher/graphviz/PortIdFactory.java
Patch:
@@ -16,14 +16,11 @@
 
 package com.google.inject.grapher.graphviz;
 
-import com.google.inject.grapher.StringNodeIdFactory;
-
 import java.lang.reflect.Member;
 
 /**
  * Interface for a service that returns Graphviz port IDs, used for naming the
  * rows in {@link ImplementationNode}-displaying {@link GraphvizNode}s.
- * Implemented by {@link StringNodeIdFactory}.
  *
  * @author phopkins@gmail.com (Pete Hopkins)
  */

File: extensions/grapher/test/com/google/inject/grapher/AllTests.java
Patch:
@@ -26,7 +26,7 @@ public class AllTests {
 
   public static Test suite() {
     TestSuite suite = new TestSuite();
-    suite.addTestSuite(GraphingVisitorTest.class);
+    suite.addTestSuite(AbstractInjectorGrapherTest.class);
     suite.addTestSuite(ShortNameFactoryTest.class);
     suite.addTestSuite(TransitiveDependencyVisitorTest.class);
     return suite;

File: extensions/grapher/test/com/google/inject/grapher/demo/DeLorian.java
Patch:
@@ -24,7 +24,8 @@ class DeLorian {
   // between a Provider<T> and just @Injecting T. 
   @Inject @Driver Provider<Person> driver;
   @Inject FluxCapacitor fluxCapacitor;
+  @Inject PrivateTestModule.Exposed exposed;
   
   @Inject
   public void setEnergySource(EnergySource energySource) {}
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/TypeLiteral.java
Patch:
@@ -171,7 +171,7 @@ private List<TypeLiteral<?>> resolveAll(Type[] types) {
     for (int t = 0; t < types.length; t++) {
       result[t] = resolve(types[t]);
     }
-    return ImmutableList.of(result);
+    return ImmutableList.copyOf(result);
   }
 
   /**

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -220,7 +220,7 @@ public Injector createChildInjector(Iterable<? extends Module> modules) {
   }
 
   public Injector createChildInjector(Module... modules) {
-    return createChildInjector(ImmutableList.of(modules));
+    return createChildInjector(ImmutableList.copyOf(modules));
   }
 
   /**

File: core/src/com/google/inject/spi/InterceptorBinding.java
Patch:
@@ -56,7 +56,7 @@ public final class InterceptorBinding implements Element {
     this.source = checkNotNull(source, "source");
     this.classMatcher = checkNotNull(classMatcher, "classMatcher");
     this.methodMatcher = checkNotNull(methodMatcher, "methodMatcher");
-    this.interceptors = ImmutableList.of(interceptors);
+    this.interceptors = ImmutableList.copyOf(interceptors);
   }
 
   public Object getSource() {

File: core/src/com/google/inject/spi/Message.java
Patch:
@@ -126,8 +126,8 @@ private Object writeReplace() throws ObjectStreamException {
     for (int i = 0; i < sourcesAsStrings.length; i++) {
       sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString();
     }
-    return new Message(ImmutableList.of(sourcesAsStrings), message, cause);
+    return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause);
   }
 
   private static final long serialVersionUID = 0;
-}
\ No newline at end of file
+}

File: core/src/com/google/inject/spi/ProvisionListenerBinding.java
Patch:
@@ -41,7 +41,7 @@ public final class ProvisionListenerBinding implements Element {
       ProvisionListener[] listeners) {
     this.source = source;
     this.keyMatcher = typeMatcher;
-    this.listeners = ImmutableList.of(listeners);
+    this.listeners = ImmutableList.copyOf(listeners);
   }
 
   /** Returns the registered listeners. */

File: core/src/com/google/inject/util/Modules.java
Patch:
@@ -100,7 +100,7 @@ public static OverriddenModuleBuilder override(Iterable<? extends Module> module
    * Returns a new module that installs all of {@code modules}.
    */
   public static Module combine(Module... modules) {
-    return combine(ImmutableSet.of(modules));
+    return combine(ImmutableSet.copyOf(modules));
   }
 
   /**

File: core/src/com/google/inject/Binder.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.inject.spi.ProvisionListener;
 import com.google.inject.spi.TypeConverter;
 import com.google.inject.spi.TypeListener;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;

File: core/src/com/google/inject/BindingAnnotation.java
Patch:
@@ -17,8 +17,9 @@
 package com.google.inject;
 
 import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/ConfigurationException.java
Patch:
@@ -16,10 +16,12 @@
 
 package com.google.inject;
 
-import com.google.inject.internal.Errors;
 import static com.google.common.base.Preconditions.checkState;
+
 import com.google.common.collect.ImmutableSet;
+import com.google.inject.internal.Errors;
 import com.google.inject.spi.Message;
+
 import java.util.Collection;
 
 /**

File: core/src/com/google/inject/Exposed.java
Patch:
@@ -16,10 +16,11 @@
 
 package com.google.inject;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/Guice.java
Patch:
@@ -16,10 +16,9 @@
 
 package com.google.inject;
 
-import java.util.Arrays;
-
 import com.google.inject.internal.InternalInjectorCreator;
 
+import java.util.Arrays;
 
 /**
  * The entry point to the Guice framework. Creates {@link Injector}s from

File: core/src/com/google/inject/ImplementedBy.java
Patch:
@@ -17,8 +17,9 @@
 package com.google.inject;
 
 import static java.lang.annotation.ElementType.TYPE;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/Inject.java
Patch:
@@ -16,12 +16,13 @@
 
 package com.google.inject;
 
-import java.lang.annotation.Documented;
 import static java.lang.annotation.ElementType.CONSTRUCTOR;
 import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/Injector.java
Patch:
@@ -16,13 +16,13 @@
 
 package com.google.inject;
 
+import com.google.inject.spi.TypeConverterBinding;
+
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import com.google.inject.spi.TypeConverterBinding;
-
 /**
  * Builds the graphs of objects that make up your application. The injector tracks the dependencies
  * for each type and uses bindings to inject them. This is the core of Guice, although you rarely

File: core/src/com/google/inject/PrivateModule.java
Patch:
@@ -16,15 +16,17 @@
 
 package com.google.inject;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.AnnotatedElementBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
-import static com.google.common.base.Preconditions.checkState;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;
 import com.google.inject.spi.TypeListener;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 

File: core/src/com/google/inject/ProvidedBy.java
Patch:
@@ -17,8 +17,9 @@
 package com.google.inject;
 
 import static java.lang.annotation.ElementType.TYPE;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/Provides.java
Patch:
@@ -16,10 +16,11 @@
 
 package com.google.inject;
 
-import java.lang.annotation.Documented;
 import static java.lang.annotation.ElementType.METHOD;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/ScopeAnnotation.java
Patch:
@@ -17,8 +17,9 @@
 package com.google.inject;
 
 import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/Singleton.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/binder/LinkedBindingBuilder.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
+
 import java.lang.reflect.Constructor;
 
 /**

File: core/src/com/google/inject/binder/ScopedBindingBuilder.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.binder;
 
 import com.google.inject.Scope;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/internal/AbstractBindingBuilder.java
Patch:
@@ -16,12 +16,14 @@
 
 package com.google.inject.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.Scope;
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.InstanceBinding;
+
 import java.lang.annotation.Annotation;
 import java.util.List;
 

File: core/src/com/google/inject/internal/AbstractBindingProcessor.java
Patch:
@@ -16,8 +16,7 @@
 
 package com.google.inject.internal;
 
-import java.util.Set;
-
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import com.google.inject.Binder;
 import com.google.inject.Binding;
@@ -28,9 +27,10 @@
 import com.google.inject.Provider;
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.spi.DefaultBindingTargetVisitor;
 
+import java.util.Set;
+
 /**
  * Guarantees that processing of Binding elements happens in a sane way.
  * 

File: core/src/com/google/inject/internal/AbstractProcessor.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.spi.DefaultElementVisitor;
 import com.google.inject.spi.Element;
+
 import java.util.Iterator;
 import java.util.List;
 

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -31,6 +31,7 @@
 import com.google.inject.spi.ProviderInstanceBinding;
 import com.google.inject.spi.ProviderKeyBinding;
 import com.google.inject.spi.UntargettedBinding;
+
 import java.util.Set;
 
 /**

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.internal;
 
-import javax.inject.Provider;
-
 import com.google.inject.Key;
 import com.google.inject.internal.InjectorImpl.JitLimitation;
 import com.google.inject.spi.Dependency;
 
+import javax.inject.Provider;
+
 /**
  * Delegates to a custom factory which is also bound in the injector.
  */

File: core/src/com/google/inject/internal/ConstantBindingBuilderImpl.java
Patch:
@@ -16,13 +16,14 @@
 
 package com.google.inject.internal;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.ConstantBindingBuilder;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.annotation.Annotation;
 import java.util.List;
 

File: core/src/com/google/inject/internal/ConstructionProxy.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: core/src/com/google/inject/internal/ConstructorInjector.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.internal.ProvisionListenerStackCallback.ProvisionCallback;
 import com.google.common.collect.ImmutableSet;
+import com.google.inject.internal.ProvisionListenerStackCallback.ProvisionCallback;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.reflect.InvocationTargetException;
 import java.util.Set;
 

File: core/src/com/google/inject/internal/ConstructorInjectorStore.java
Patch:
@@ -16,8 +16,9 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableList;
 import static com.google.common.collect.Iterables.concat;
+
+import com.google.common.collect.ImmutableList;
 import com.google.inject.spi.InjectionPoint;
 
 /**

File: core/src/com/google/inject/internal/DefaultConstructionProxyFactory.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.internal.BytecodeGen.Visibility;
 import com.google.common.collect.ImmutableMap;
+import com.google.inject.internal.BytecodeGen.Visibility;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: core/src/com/google/inject/internal/DeferredLookups.java
Patch:
@@ -16,14 +16,15 @@
 
 package com.google.inject.internal;
 
+import com.google.common.collect.Lists;
 import com.google.inject.Key;
 import com.google.inject.MembersInjector;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
-import com.google.common.collect.Lists;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.MembersInjectorLookup;
 import com.google.inject.spi.ProviderLookup;
+
 import java.util.List;
 
 /**

File: core/src/com/google/inject/internal/ExposedBindingImpl.java
Patch:
@@ -16,15 +16,16 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Injector;
 import com.google.inject.Key;
-import com.google.common.base.Objects;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.ExposedBinding;
 import com.google.inject.spi.PrivateElements;
+
 import java.util.Set;
 
 public final class ExposedBindingImpl<T> extends BindingImpl<T> implements ExposedBinding<T> {

File: core/src/com/google/inject/internal/ExposureBuilder.java
Patch:
@@ -16,10 +16,11 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Preconditions;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.binder.AnnotatedElementBuilder;
-import com.google.common.base.Preconditions;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/internal/InjectionRequestProcessor.java
Patch:
@@ -16,13 +16,14 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.ConfigurationException;
-import com.google.inject.Stage;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.inject.ConfigurationException;
+import com.google.inject.Stage;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.InjectionRequest;
 import com.google.inject.spi.StaticInjectionRequest;
+
 import java.util.List;
 import java.util.Set;
 

File: core/src/com/google/inject/internal/InstanceBindingImpl.java
Patch:
@@ -16,17 +16,18 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.Provider;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.base.Objects;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.InstanceBinding;
 import com.google.inject.util.Providers;
+
 import java.util.Set;
 
 final class InstanceBindingImpl<T> extends BindingImpl<T> implements InstanceBinding<T> {

File: core/src/com/google/inject/internal/InternalContext.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.Key;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
+import com.google.inject.Key;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.DependencyAndSource;
 

File: core/src/com/google/inject/internal/InternalFactoryToInitializableAdapter.java
Patch:
@@ -16,8 +16,9 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.Provider;
 import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.inject.Provider;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.ProviderInstanceBinding;
 

File: core/src/com/google/inject/internal/InternalFactoryToProviderAdapter.java
Patch:
@@ -16,8 +16,9 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.Provider;
 import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.inject.Provider;
 import com.google.inject.spi.Dependency;
 
 /**

File: core/src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.google.inject.internal;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
 import com.google.inject.Binding;
 import com.google.inject.Injector;
 import com.google.inject.Key;
@@ -25,11 +27,10 @@
 import com.google.inject.Scope;
 import com.google.inject.Stage;
 import com.google.inject.TypeLiteral;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import com.google.inject.internal.util.Stopwatch;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.TypeConverterBinding;
+
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;

File: core/src/com/google/inject/internal/LinkedBindingImpl.java
Patch:
@@ -16,14 +16,15 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Key;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.base.Objects;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.LinkedKeyBinding;
+
 import java.util.Set;
 
 public final class LinkedBindingImpl<T> extends BindingImpl<T> implements LinkedKeyBinding<T>, HasDependencies {

File: core/src/com/google/inject/internal/LinkedProviderBindingImpl.java
Patch:
@@ -16,14 +16,15 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Key;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.base.Objects;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.ProviderKeyBinding;
+
 import java.util.Set;
 
 final class LinkedProviderBindingImpl<T>

File: core/src/com/google/inject/internal/MembersInjectorImpl.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject.internal;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Key;
 import com.google.inject.MembersInjector;
 import com.google.inject.TypeLiteral;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.spi.InjectionListener;
 import com.google.inject.spi.InjectionPoint;
 

File: core/src/com/google/inject/internal/MembersInjectorStore.java
Patch:
@@ -16,12 +16,13 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.ConfigurationException;
-import com.google.inject.TypeLiteral;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.inject.ConfigurationException;
+import com.google.inject.TypeLiteral;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.TypeListenerBinding;
+
 import java.lang.reflect.Field;
 import java.util.List;
 import java.util.Set;

File: core/src/com/google/inject/internal/MessageProcessor.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Guice;
 import com.google.inject.spi.Message;
+
 import java.util.logging.Level;
 import java.util.logging.Logger;
 

File: core/src/com/google/inject/internal/PrivateElementProcessor.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.Lists;
 import com.google.inject.spi.PrivateElements;
+
 import java.util.List;
 
 /**

File: core/src/com/google/inject/internal/ProcessedBindingData.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.internal;
 
-import java.util.List;
-
 import com.google.common.collect.Lists;
 
+import java.util.List;
+
 /**
  * Keeps track of creation listeners & uninitialized bindings,
  * so they can be processed after bindings are recorded.

File: core/src/com/google/inject/internal/ProviderInstanceBindingImpl.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.Provider;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.base.Objects;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -19,11 +19,11 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import javax.inject.Provider;
 import com.google.inject.internal.ProvisionListenerStackCallback.ProvisionCallback;
-
 import com.google.inject.spi.Dependency;
 
+import javax.inject.Provider;
+
 /**
  * Base class for InternalFactories that are used by Providers, to handle
  * circular dependencies.

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -16,16 +16,17 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Exposed;
 import com.google.inject.Key;
 import com.google.inject.PrivateBinder;
 import com.google.inject.Provider;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.base.Objects;
 import com.google.inject.internal.util.StackTraceElements;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.ProviderWithDependencies;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: core/src/com/google/inject/internal/ProvisionListenerStackCallback.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.internal;
 
-import java.util.List;
-
 import com.google.inject.Key;
 import com.google.inject.ProvisionException;
-import com.google.inject.spi.ProvisionListener;
 import com.google.inject.spi.DependencyAndSource;
+import com.google.inject.spi.ProvisionListener;
+
+import java.util.List;
 
 /**
  * Intercepts provisions with a stack of listeners.

File: core/src/com/google/inject/internal/ScopeBindingProcessor.java
Patch:
@@ -16,9 +16,11 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.Scope;
 import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.inject.Scope;
 import com.google.inject.spi.ScopeBinding;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/internal/Scoping.java
Patch:
@@ -16,15 +16,16 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.Scope;
 import com.google.inject.Scopes;
 import com.google.inject.Singleton;
 import com.google.inject.Stage;
 import com.google.inject.binder.ScopedBindingBuilder;
-import com.google.common.base.Objects;
 import com.google.inject.spi.BindingScopingVisitor;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/internal/SingleFieldInjector.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.inject.internal.InjectorImpl.JitLimitation;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.reflect.Field;
 
 /**

File: core/src/com/google/inject/internal/SingleMethodInjector.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.inject.internal.BytecodeGen.Visibility;
 import com.google.inject.internal.InjectorImpl.MethodInvoker;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;

File: core/src/com/google/inject/internal/TypeConverterBindingProcessor.java
Patch:
@@ -18,12 +18,12 @@
 
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.util.SourceProvider;
-import com.google.common.base.Strings;
 import com.google.inject.matcher.AbstractMatcher;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.matcher.Matchers;
 import com.google.inject.spi.TypeConverter;
 import com.google.inject.spi.TypeConverterBinding;
+
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;

File: core/src/com/google/inject/internal/UniqueAnnotations.java
Patch:
@@ -16,10 +16,12 @@
 
 package com.google.inject.internal;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**

File: core/src/com/google/inject/internal/UntargettedBindingImpl.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.internal;
 
+import com.google.common.base.Objects;
 import com.google.inject.Binder;
 import com.google.inject.Key;
-import com.google.common.base.Objects;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.UntargettedBinding;

File: core/src/com/google/inject/internal/WeakKeySet.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.Key;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.inject.Key;
 import com.google.inject.internal.util.SourceProvider;
 
 import java.util.Map;

File: core/src/com/google/inject/internal/util/Classes.java
Patch:
@@ -24,7 +24,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
-
 /**
  * Class utilities.
  */

File: core/src/com/google/inject/internal/util/SourceProvider.java
Patch:
@@ -17,11 +17,12 @@
 package com.google.inject.internal.util;
 
 import static com.google.common.collect.Iterables.concat;
-import java.util.List;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 
+import java.util.List;
+
 /**
  * Provides access to the calling line of code.
  * 

File: core/src/com/google/inject/internal/util/StackTraceElements.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.internal.util;
 
+import com.google.common.base.Function;
+import com.google.common.collect.MapMaker;
+
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;
 import java.util.Map;
 
-import com.google.common.base.Function;
-import com.google.common.collect.MapMaker;
-
 /**
  * Creates stack trace elements for members.
  *

File: core/src/com/google/inject/matcher/Matchers.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;

File: core/src/com/google/inject/name/Named.java
Patch:
@@ -16,10 +16,12 @@
 
 package com.google.inject.name;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
 
 /**

File: core/src/com/google/inject/name/NamedImpl.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.name;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 

File: core/src/com/google/inject/name/Names.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Binder;
 import com.google.inject.Key;
+
 import java.util.Enumeration;
 import java.util.Map;
 import java.util.Properties;

File: core/src/com/google/inject/spi/BindingScopingVisitor.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.spi;
 
 import com.google.inject.Scope;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/spi/ConstructorBinding.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.spi;
 
 import com.google.inject.Binding;
+
 import java.lang.reflect.Method;
 import java.util.List;
 import java.util.Map;

File: core/src/com/google/inject/spi/ConvertedConstantBinding.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Binding;
 import com.google.inject.Key;
+
 import java.util.Set;
 
 /**

File: core/src/com/google/inject/spi/DefaultBindingScopingVisitor.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.spi;
 
 import com.google.inject.Scope;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/spi/DependencyAndSource.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject.spi;
 
-import java.lang.reflect.Member;
-
 import com.google.inject.Binding;
 import com.google.inject.internal.util.StackTraceElements;
 
+import java.lang.reflect.Member;
+
 /**
  * A combination of a {@link Dependency} and the {@link Binding#getSource()
  * source} where the dependency was bound.

File: core/src/com/google/inject/spi/DisableCircularProxiesOption.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject.spi;
 
-import com.google.inject.Binder;
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import com.google.inject.Binder;
+
 /**
  * A request to disable circular proxies.
  *

File: core/src/com/google/inject/spi/InjectionRequest.java
Patch:
@@ -16,10 +16,12 @@
 
 package com.google.inject.spi;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.inject.Binder;
 import com.google.inject.ConfigurationException;
 import com.google.inject.TypeLiteral;
-import static com.google.common.base.Preconditions.checkNotNull;
+
 import java.util.Set;
 
 /**

File: core/src/com/google/inject/spi/InstanceBinding.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.spi;
 
 import com.google.inject.Binding;
+
 import java.util.Set;
 
 /**

File: core/src/com/google/inject/spi/MembersInjectorLookup.java
Patch:
@@ -16,11 +16,12 @@
 
 package com.google.inject.spi;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.inject.Binder;
 import com.google.inject.MembersInjector;
 import com.google.inject.TypeLiteral;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 
 /**
  * A lookup of the members injector for a type. Lookups are created explicitly in a module using

File: core/src/com/google/inject/spi/PrivateElements.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Injector;
 import com.google.inject.Key;
+
 import java.util.List;
 import java.util.Set;
 

File: core/src/com/google/inject/spi/ProviderInstanceBinding.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Binding;
 import com.google.inject.Provider;
+
 import java.util.Set;
 
 /**

File: core/src/com/google/inject/spi/ProviderLookup.java
Patch:
@@ -16,11 +16,12 @@
 
 package com.google.inject.spi;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.Provider;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 
 /**
  * A lookup of the provider for a type. Lookups are created explicitly in a module using

File: core/src/com/google/inject/spi/ProvisionListener.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.spi;
 
-import java.util.List;
-
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.Scope;
 
+import java.util.List;
+
 /**
  * Listens for provisioning of objects. Useful for gathering timing information
  * about provisioning, post-provision initialization, and more.

File: core/src/com/google/inject/spi/ProvisionListenerBinding.java
Patch:
@@ -16,13 +16,13 @@
 
 package com.google.inject.spi;
 
-import java.util.List;
-
+import com.google.common.collect.ImmutableList;
 import com.google.inject.Binder;
 import com.google.inject.Key;
-import com.google.common.collect.ImmutableList;
 import com.google.inject.matcher.Matcher;
 
+import java.util.List;
+
 /**
  * Binds keys (picked using a Matcher) to a provision listener. Listeners are created explicitly in
  * a module using {@link Binder#bindListener(Matcher, ProvisionListener)} statements:

File: core/src/com/google/inject/spi/RequireExplicitBindingsOption.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject.spi;
 
-import com.google.inject.Binder;
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import com.google.inject.Binder;
+
 /**
  * A request to require explicit bindings.
  *

File: core/src/com/google/inject/spi/ScopeBinding.java
Patch:
@@ -16,9 +16,11 @@
 
 package com.google.inject.spi;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.inject.Binder;
 import com.google.inject.Scope;
-import static com.google.common.base.Preconditions.checkNotNull;
+
 import java.lang.annotation.Annotation;
 
 /**

File: core/src/com/google/inject/spi/StaticInjectionRequest.java
Patch:
@@ -16,9 +16,11 @@
 
 package com.google.inject.spi;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.inject.Binder;
 import com.google.inject.ConfigurationException;
-import static com.google.common.base.Preconditions.checkNotNull;
+
 import java.util.Set;
 
 /**

File: core/src/com/google/inject/spi/TypeConverterBinding.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject.spi;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.inject.Binder;
 import com.google.inject.TypeLiteral;
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 
 /**

File: core/src/com/google/inject/spi/TypeEncounter.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 import com.google.inject.matcher.Matcher;
+
 import java.lang.reflect.Method;
 
 /**

File: core/src/com/google/inject/util/Node.java
Patch:
@@ -16,10 +16,11 @@
 
 package com.google.inject.util;
 
-import com.google.inject.Key;
-import com.google.inject.internal.Errors;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.inject.Key;
+import com.google.inject.internal.Errors;
+
 import java.lang.annotation.Annotation;
 import java.util.Set;
 

File: core/src/com/google/inject/util/Types.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.inject.internal.MoreTypes.GenericArrayTypeImpl;
 import com.google.inject.internal.MoreTypes.ParameterizedTypeImpl;
 import com.google.inject.internal.MoreTypes.WildcardTypeImpl;
+
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;

File: core/test/com/google/inject/ErrorHandlingTest.java
Patch:
@@ -16,11 +16,13 @@
 
 package com.google.inject;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
 import java.util.List;
 

File: core/test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -19,12 +19,14 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.inject.util.Modules;
+
+import junit.framework.TestCase;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import junit.framework.TestCase;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: core/test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -17,12 +17,13 @@
 package com.google.inject;
 
 import com.google.common.collect.Iterables;
-import java.util.List;
-
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
+
 import junit.framework.TestCase;
 
+import java.util.List;
+
 /**
  * @author crazybob@google.com (Bob Lee)
  */

File: core/test/com/google/inject/IntegrationTest.java
Patch:
@@ -17,7 +17,9 @@
 package com.google.inject;
 
 import static com.google.inject.matcher.Matchers.any;
+
 import junit.framework.TestCase;
+
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 

File: core/test/com/google/inject/JitBindingsTest.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
+import static com.google.common.collect.ImmutableSet.of;
 import static com.google.inject.Asserts.assertContains;
+import static com.google.inject.JitBindingsTest.GetBindingCheck.ALLOW_BINDING;
 import static com.google.inject.JitBindingsTest.GetBindingCheck.ALLOW_BINDING_PROVIDER;
 import static com.google.inject.JitBindingsTest.GetBindingCheck.FAIL_ALL;
-import static com.google.inject.JitBindingsTest.GetBindingCheck.ALLOW_BINDING;
-import static com.google.common.collect.ImmutableSet.of;
 
 import junit.framework.TestCase;
 

File: core/test/com/google/inject/ModulesTest.java
Patch:
@@ -17,9 +17,11 @@
 package com.google.inject;
 
 import com.google.inject.util.Modules;
-import java.util.Arrays;
+
 import junit.framework.TestCase;
 
+import java.util.Arrays;
+
 /**
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: core/test/com/google/inject/NullableInjectionPointTest.java
Patch:
@@ -2,14 +2,14 @@
 
 import static com.google.inject.Asserts.assertContains;
 
+import junit.framework.TestCase;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-import junit.framework.TestCase;
-
 /**
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: core/test/com/google/inject/OptionalBindingTest.java
Patch:
@@ -18,8 +18,10 @@
 package com.google.inject;
 
 import static com.google.inject.Asserts.assertContains;
+
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
+
 import junit.framework.TestCase;
 
 /**

File: core/test/com/google/inject/ProviderInjectionTest.java
Patch:
@@ -16,8 +16,10 @@
 
 package com.google.inject;
 
-import com.google.inject.name.Named;
 import static com.google.inject.name.Names.named;
+
+import com.google.inject.name.Named;
+
 import junit.framework.TestCase;
 
 import java.util.Arrays;

File: core/test/com/google/inject/ReflectionTest.java
Patch:
@@ -18,10 +18,10 @@
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import java.lang.annotation.Retention;
-
 import junit.framework.TestCase;
 
+import java.lang.annotation.Retention;
+
 /**
  * @author crazybob@google.com (Bob Lee)
  */

File: core/test/com/google/inject/RequestInjectionTest.java
Patch:
@@ -17,10 +17,12 @@
 package com.google.inject;
 
 import static com.google.inject.Asserts.assertContains;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import junit.framework.TestCase;
 
+import java.lang.annotation.Retention;
+
 /**
  * @author crazybob@google.com (Bob Lee)
  */

File: core/test/com/google/inject/SuiteUtils.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject;
 
-import java.util.Enumeration;
-import java.util.Set;
-
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
+import java.util.Enumeration;
+import java.util.Set;
+
 public class SuiteUtils {
 
   public static TestSuite removeSuppressedTests(TestSuite suite, Set<String> suppressedTestNames) {

File: core/test/com/google/inject/example/ClientServiceWithGuice.java
Patch:
@@ -16,13 +16,14 @@
 
 package com.google.inject.example;
 
+import static junit.framework.Assert.assertTrue;
+
 import com.google.inject.AbstractModule;
 import com.google.inject.CreationException;
 import com.google.inject.Guice;
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Scopes;
-import static junit.framework.Assert.assertTrue;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: core/test/com/google/inject/example/ClientServiceWithGuiceDefaults.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Singleton;
+
 import junit.framework.Assert;
 
 /**

File: core/test/com/google/inject/example/JndiProvider.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Inject;
 import com.google.inject.Provider;
+
 import javax.naming.Context;
 import javax.naming.NamingException;
 

File: core/test/com/google/inject/example/JndiProviderClient.java
Patch:
@@ -16,11 +16,13 @@
 
 package com.google.inject.example;
 
+import static com.google.inject.example.JndiProvider.fromJndi;
+
 import com.google.inject.AbstractModule;
 import com.google.inject.CreationException;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
-import static com.google.inject.example.JndiProvider.fromJndi;
+
 import javax.naming.Context;
 import javax.naming.InitialContext;
 import javax.sql.DataSource;

File: core/test/com/google/inject/internal/MoreTypesTest.java
Patch:
@@ -17,9 +17,11 @@
 package com.google.inject.internal;
 
 import com.google.inject.TypeLiteral;
+
+import junit.framework.TestCase;
+
 import java.util.Map;
 import java.util.Set;
-import junit.framework.TestCase;
 
 /**
  * @author schmitt@google.com (Peter Schmitt)

File: core/test/com/google/inject/spi/BindingTargetVisitorTest.java
Patch:
@@ -18,6 +18,7 @@
 import com.google.inject.Binding;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
+
 import junit.framework.TestCase;
 
 /**

File: core/test/com/google/inject/spi/FailingBindingScopingVisitor.java
Patch:
@@ -17,9 +17,11 @@
 package com.google.inject.spi;
 
 import com.google.inject.Scope;
-import java.lang.annotation.Annotation;
+
 import junit.framework.AssertionFailedError;
 
+import java.lang.annotation.Annotation;
+
 public class FailingBindingScopingVisitor implements BindingScopingVisitor<Void> {
 
   public Void visitEagerSingleton() {

File: core/test/com/google/inject/spi/FailingTargetVisitor.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.spi;
 
 import com.google.inject.Binding;
+
 import junit.framework.AssertionFailedError;
 
 public class FailingTargetVisitor<T> extends DefaultBindingTargetVisitor<T, Void> {

File: core/test/com/google/inject/spi/InjectorSpiTest.java
Patch:
@@ -1,7 +1,5 @@
 package com.google.inject.spi;
 
-import java.util.Map;
-
 import com.google.inject.AbstractModule;
 import com.google.inject.Binding;
 import com.google.inject.Guice;
@@ -13,6 +11,8 @@
 
 import junit.framework.TestCase;
 
+import java.util.Map;
+
 /**
  * @author sberlin@gmail.com (Sam Berlin)
  */

File: core/test/com/google/inject/spi/ModuleRewriterTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject.spi;
 
+import com.google.common.collect.Lists;
 import com.google.inject.AbstractModule;
 import com.google.inject.Binding;
 import com.google.inject.ConfigurationException;
@@ -25,11 +26,11 @@
 import com.google.inject.Key;
 import com.google.inject.Module;
 import com.google.inject.Provider;
-import com.google.common.collect.Lists;
 import com.google.inject.name.Names;
-import java.util.List;
+
 import junit.framework.TestCase;
 
+import java.util.List;
 
 /**
  * @author jessewilson@google.com (Jesse Wilson)

File: core/test/com/google/inject/util/ProvidersTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.util;
 
 import com.google.inject.Provider;
+
 import junit.framework.TestCase;
 
 /**

File: extensions/assistedinject/src/com/google/inject/assistedinject/AssistedConstructor.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.google.inject.assistedinject;
 
+import com.google.common.collect.Lists;
 import com.google.inject.Inject;
 import com.google.inject.TypeLiteral;
-import com.google.common.collect.Lists;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;

File: extensions/assistedinject/src/com/google/inject/assistedinject/AssistedInject.java
Patch:
@@ -17,12 +17,13 @@
 package com.google.inject.assistedinject;
 
 import static java.lang.annotation.ElementType.CONSTRUCTOR;
-import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import java.lang.annotation.Target;
 
 import com.google.inject.Inject;
 
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
 /**
  * <p>
  * When used in tandem with {@link FactoryModuleBuilder}, constructors annotated with 

File: extensions/assistedinject/src/com/google/inject/assistedinject/BindingCollector.java
Patch:
@@ -15,12 +15,13 @@
  */
 package com.google.inject.assistedinject;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.inject.ConfigurationException;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.inject.spi.Message;
+
 import java.util.Collections;
 import java.util.Map;
 

File: extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java
Patch:
@@ -16,12 +16,14 @@
 
 package com.google.inject.assistedinject;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.inject.ConfigurationException;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.internal.Annotations;
-import static com.google.common.base.Preconditions.checkArgument;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;

File: extensions/assistedinject/src/com/google/inject/assistedinject/ParameterListKey.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.assistedinject;
 
 import com.google.inject.TypeLiteral;
+
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Arrays;

File: extensions/assistedinject/test/com/google/inject/assistedinject/ManyConstructorsTest.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.assistedinject;
 
-import junit.framework.TestCase;
-
 import com.google.inject.AbstractModule;
 import com.google.inject.Asserts;
 import com.google.inject.CreationException;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 
+import junit.framework.TestCase;
+
 /**
  * @author sameb@google.com (Sam Berlin)
  */

File: extensions/grapher/src/com/google/inject/grapher/GraphingVisitor.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject.grapher;
 
+import com.google.common.collect.Lists;
 import com.google.inject.Binding;
 import com.google.inject.Inject;
 import com.google.inject.Key;
 import com.google.inject.Provider;
-import com.google.common.collect.Lists;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.ConstructorBinding;
 import com.google.inject.spi.ConvertedConstantBinding;
@@ -34,6 +34,7 @@
 import com.google.inject.spi.ProviderInstanceBinding;
 import com.google.inject.spi.ProviderKeyBinding;
 import com.google.inject.spi.UntargettedBinding;
+
 import java.lang.reflect.Member;
 import java.util.Collection;
 import java.util.List;

File: extensions/grapher/src/com/google/inject/grapher/InjectorGrapher.java
Patch:
@@ -16,13 +16,14 @@
 
 package com.google.inject.grapher;
 
+import com.google.common.collect.Sets;
 import com.google.inject.Binding;
 import com.google.inject.Guice;
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Key;
-import com.google.common.collect.Sets;
 import com.google.inject.spi.BindingTargetVisitor;
+
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Iterator;

File: extensions/grapher/src/com/google/inject/grapher/ShortNameFactory.java
Patch:
@@ -16,12 +16,13 @@
 
 package com.google.inject.grapher;
 
-import com.google.inject.Key;
-import com.google.inject.TypeLiteral;
 import com.google.common.base.Joiner;
 import com.google.common.collect.Lists;
+import com.google.inject.Key;
+import com.google.inject.TypeLiteral;
 import com.google.inject.internal.ProviderMethod;
 import com.google.inject.internal.util.StackTraceElements;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;

File: extensions/grapher/src/com/google/inject/grapher/TransitiveDependencyVisitor.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.grapher;
 
-import com.google.inject.Key;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.inject.Key;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.ConstructorBinding;
 import com.google.inject.spi.ConvertedConstantBinding;
@@ -31,6 +31,7 @@
 import com.google.inject.spi.ProviderInstanceBinding;
 import com.google.inject.spi.ProviderKeyBinding;
 import com.google.inject.spi.UntargettedBinding;
+
 import java.util.Collection;
 import java.util.Set;
 

File: extensions/grapher/src/com/google/inject/grapher/graphviz/BindingEdgeFactory.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.grapher.graphviz;
 
+import com.google.common.collect.ImmutableList;
 import com.google.inject.Inject;
 import com.google.inject.grapher.BindingEdge;
-import com.google.common.collect.ImmutableList;
 
 /**
  * Graphviz-specific implementation of {@link BindingEdge.Factory}. Uses a

File: extensions/grapher/src/com/google/inject/grapher/graphviz/DependencyEdgeFactory.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.grapher.graphviz;
 
+import com.google.common.collect.ImmutableList;
 import com.google.inject.Inject;
 import com.google.inject.grapher.DependencyEdge;
-import com.google.common.collect.ImmutableList;
 import com.google.inject.spi.InjectionPoint;
 
 /**

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizEdge.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.grapher.graphviz;
 
 import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizNode.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
+
 import java.util.List;
 import java.util.Map;
 

File: extensions/grapher/test/com/google/inject/grapher/ShortNameFactoryTest.java
Patch:
@@ -32,13 +32,13 @@
 import com.google.inject.spi.DefaultBindingTargetVisitor;
 import com.google.inject.spi.ProviderInstanceBinding;
 
+import junit.framework.TestCase;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Member;
 
-import junit.framework.TestCase;
-
 /**
  * Tests for {@link ShortNameFactory}.
  *

File: extensions/grapher/test/com/google/inject/grapher/demo/Driver.java
Patch:
@@ -18,12 +18,12 @@
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.google.inject.BindingAnnotation;
-
 @Retention(RUNTIME)
 @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @BindingAnnotation

File: extensions/grapher/test/com/google/inject/grapher/demo/Inventor.java
Patch:
@@ -18,12 +18,12 @@
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.google.inject.BindingAnnotation;
-
 @Retention(RUNTIME)
 @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @BindingAnnotation

File: extensions/grapher/test/com/google/inject/grapher/demo/Nuclear.java
Patch:
@@ -18,12 +18,12 @@
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.google.inject.BindingAnnotation;
-
 @Retention(RUNTIME)
 @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @BindingAnnotation

File: extensions/grapher/test/com/google/inject/grapher/demo/Renewable.java
Patch:
@@ -18,12 +18,12 @@
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.google.inject.BindingAnnotation;
-
 @Retention(RUNTIME)
 @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @BindingAnnotation

File: extensions/grapher/test/com/google/inject/grapher/demo/Used.java
Patch:
@@ -18,12 +18,12 @@
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.google.inject.BindingAnnotation;
-
 @Retention(RUNTIME)
 @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @BindingAnnotation

File: extensions/jmx/src/com/google/inject/tools/jmx/Manager.java
Patch:
@@ -21,8 +21,10 @@
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Module;
+
 import java.lang.annotation.Annotation;
 import java.lang.management.ManagementFactory;
+
 import javax.management.MBeanServer;
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;

File: extensions/jmx/test/com/google/inject/tools/jmx/JmxTest.java
Patch:
@@ -16,13 +16,15 @@
 
 package com.google.inject.tools.jmx;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.inject.AbstractModule;
 import com.google.inject.BindingAnnotation;
 import com.google.inject.Key;
 import com.google.inject.Singleton;
 import com.google.inject.name.Names;
+
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: extensions/jndi/src/com/google/inject/jndi/JndiIntegration.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.Inject;
 import com.google.inject.Provider;
+
 import javax.naming.Context;
 import javax.naming.NamingException;
 

File: extensions/mini/src/com/google/inject/mini/MiniGuice.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
+
 import javax.inject.Provider;
 
 /**

File: extensions/multibindings/src/com/google/inject/multibindings/Element.java
Patch:
@@ -17,10 +17,11 @@
 
 package com.google.inject.multibindings;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.inject.BindingAnnotation;
 
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * An internal binding annotation applied to each element in a multibinding.

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinderBinding.java
Patch:
@@ -16,15 +16,15 @@
 
 package com.google.inject.multibindings;
 
-import java.util.List;
-import java.util.Map;
-
 import com.google.inject.Binding;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.Elements;
 
+import java.util.List;
+import java.util.Map;
+
 /**
  * A binding for a MapBinder.
  * <p>

File: extensions/multibindings/src/com/google/inject/multibindings/MultibinderBinding.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.multibindings;
 
-import java.util.List;
-
 import com.google.inject.Binding;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.Elements;
 
+import java.util.List;
+
 /**
  * A binding for a Multibinder.
  * 

File: extensions/persist/src/com/google/inject/persist/PersistFilter.java
Patch:
@@ -18,7 +18,9 @@
 
 import com.google.inject.Inject;
 import com.google.inject.Singleton;
+
 import java.io.IOException;
+
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
 import javax.servlet.FilterConfig;

File: extensions/persist/src/com/google/inject/persist/PersistModule.java
Patch:
@@ -16,9 +16,11 @@
 
 package com.google.inject.persist;
 
-import com.google.inject.AbstractModule;
 import static com.google.inject.matcher.Matchers.annotatedWith;
 import static com.google.inject.matcher.Matchers.any;
+
+import com.google.inject.AbstractModule;
+
 import org.aopalliance.intercept.MethodInterceptor;
 
 /**

File: extensions/persist/src/com/google/inject/persist/jpa/Jpa.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.persist.jpa;
 
 import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 

File: extensions/persist/src/com/google/inject/persist/jpa/JpaPersistService.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.persist.jpa;
 
+import com.google.common.base.Preconditions;
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.google.inject.Singleton;
-import com.google.common.base.Preconditions;
 import com.google.inject.persist.PersistService;
 import com.google.inject.persist.UnitOfWork;
 
@@ -29,6 +29,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import java.util.Properties;
+
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.Persistence;

File: extensions/persist/test/com/google/inject/persist/AllTests.java
Patch:
@@ -27,6 +27,7 @@
 import com.google.inject.persist.jpa.ManagedLocalTransactionsTest;
 import com.google.inject.persist.jpa.ManualLocalTransactionsTest;
 import com.google.inject.persist.jpa.ManualLocalTransactionsWithCustomMatcherTest;
+
 import junit.framework.Test;
 import junit.framework.TestSuite;
 

File: extensions/persist/test/com/google/inject/persist/EdslTest.java
Patch:
@@ -4,6 +4,7 @@
 import com.google.inject.Guice;
 import com.google.inject.Stage;
 import com.google.inject.persist.jpa.JpaPersistModule;
+
 import junit.framework.TestCase;
 
 /**

File: extensions/persist/test/com/google/inject/persist/jpa/JpaParentTestEntity.java
Patch:
@@ -18,6 +18,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;

File: extensions/service/src/com/google/inject/service/AsyncService.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.service;
 
 import com.google.common.base.Preconditions;
+
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;

File: extensions/servlet/src/com/google/inject/servlet/ContinuingHttpServletRequest.java
Patch:
@@ -16,10 +16,12 @@
 
 package com.google.inject.servlet;
 
-import com.google.inject.OutOfScopeException;
 import com.google.common.collect.Maps;
+import com.google.inject.OutOfScopeException;
+
 import java.io.IOException;
 import java.util.Map;
+
 import javax.servlet.ServletInputStream;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;

File: extensions/servlet/src/com/google/inject/servlet/DefaultFilterPipeline.java
Patch:
@@ -16,7 +16,9 @@
 package com.google.inject.servlet;
 
 import com.google.inject.Singleton;
+
 import java.io.IOException;
+
 import javax.servlet.FilterChain;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;

File: extensions/servlet/src/com/google/inject/servlet/FilterChainInvocation.java
Patch:
@@ -16,6 +16,7 @@
 package com.google.inject.servlet;
 
 import java.io.IOException;
+
 import javax.servlet.FilterChain;
 import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -15,10 +15,10 @@
  */
 package com.google.inject.servlet;
 
+import com.google.common.collect.Iterators;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Scopes;
-import com.google.common.collect.Iterators;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.ProviderInstanceBinding;
 import com.google.inject.spi.ProviderWithExtensionVisitor;
@@ -30,6 +30,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicReference;
+
 import javax.servlet.Filter;
 import javax.servlet.FilterConfig;
 import javax.servlet.ServletContext;

File: extensions/servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -15,13 +15,15 @@
  */
 package com.google.inject.servlet;
 
+import com.google.common.collect.Lists;
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
-import com.google.common.collect.Lists;
 import com.google.inject.internal.UniqueAnnotations;
+
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+
 import javax.servlet.Filter;
 
 /**

File: extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -18,9 +18,11 @@
 
 import com.google.inject.Inject;
 import com.google.inject.OutOfScopeException;
+
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 import java.util.logging.Logger;
+
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
 import javax.servlet.FilterConfig;

File: extensions/servlet/src/com/google/inject/servlet/GuiceServletContextListener.java
Patch:
@@ -17,7 +17,9 @@
 package com.google.inject.servlet;
 
 import com.google.inject.Injector;
+
 import java.lang.ref.WeakReference;
+
 import javax.servlet.ServletContext;
 import javax.servlet.ServletContextEvent;
 import javax.servlet.ServletContextListener;

File: extensions/servlet/src/com/google/inject/servlet/InstanceFilterBindingImpl.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.servlet;
 
+import com.google.common.base.Objects;
+
 import java.util.Map;
 
 import javax.servlet.Filter;
 
-import com.google.common.base.Objects;
-
 /**
  * Default implementation of InstanceFilterBinding.
  * 

File: extensions/servlet/src/com/google/inject/servlet/InstanceServletBindingImpl.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.servlet;
 
+import com.google.common.base.Objects;
+
 import java.util.Map;
 
 import javax.servlet.http.HttpServlet;
 
-import com.google.common.base.Objects;
-
 /**
  * Default implementation of InstanceServletBinding.
  * 

File: extensions/servlet/src/com/google/inject/servlet/LinkedFilterBinding.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.servlet;
 
-import javax.servlet.Filter;
-
 import com.google.inject.Key;
 
+import javax.servlet.Filter;
+
 /**
  * A linked binding to a filter. 
  *

File: extensions/servlet/src/com/google/inject/servlet/LinkedFilterBindingImpl.java
Patch:
@@ -16,13 +16,13 @@
 
 package com.google.inject.servlet;
 
+import com.google.common.base.Objects;
+import com.google.inject.Key;
+
 import java.util.Map;
 
 import javax.servlet.Filter;
 
-import com.google.common.base.Objects;
-import com.google.inject.Key;
-
 /**
  * Default implementation of LinkedFilterBinding.
  * 

File: extensions/servlet/src/com/google/inject/servlet/LinkedServletBinding.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.servlet;
 
-import javax.servlet.http.HttpServlet;
-
 import com.google.inject.Key;
 
+import javax.servlet.http.HttpServlet;
+
 /**
  * A linked binding to a servlet. 
  *

File: extensions/servlet/src/com/google/inject/servlet/LinkedServletBindingImpl.java
Patch:
@@ -16,13 +16,13 @@
 
 package com.google.inject.servlet;
 
+import com.google.common.base.Objects;
+import com.google.inject.Key;
+
 import java.util.Map;
 
 import javax.servlet.http.HttpServlet;
 
-import com.google.common.base.Objects;
-import com.google.inject.Key;
-
 /**
  * Default implementation of LinkedServletBinding.
  * 

File: extensions/servlet/src/com/google/inject/servlet/RequestParameters.java
Patch:
@@ -16,10 +16,12 @@
 
 package com.google.inject.servlet;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.inject.BindingAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
 
 /**

File: extensions/servlet/src/com/google/inject/servlet/RequestScoped.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.servlet;
 
 import com.google.inject.ScopeAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;

File: extensions/servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -18,10 +18,12 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
+import com.google.common.collect.ImmutableList;
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
-import com.google.common.collect.ImmutableList;
+
 import java.util.Map;
+
 import javax.servlet.Filter;
 import javax.servlet.ServletContext;
 import javax.servlet.http.HttpServlet;

File: extensions/servlet/src/com/google/inject/servlet/ServletModuleTargetVisitor.java
Patch:
@@ -14,13 +14,13 @@
 
 package com.google.inject.servlet;
 
-import javax.servlet.Filter;
-import javax.servlet.http.HttpServlet;
-
 import com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder;
 import com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder;
 import com.google.inject.spi.BindingTargetVisitor;
 
+import javax.servlet.Filter;
+import javax.servlet.http.HttpServlet;
+
 /**
  * A visitor for the servlet extension.
  * 

File: extensions/servlet/src/com/google/inject/servlet/SessionScoped.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.servlet;
 
 import com.google.inject.ScopeAnnotation;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;

File: extensions/servlet/test/com/google/inject/servlet/DummyFilterImpl.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.servlet;
 
 import java.io.IOException;
+
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
 import javax.servlet.FilterConfig;

File: extensions/servlet/test/com/google/inject/servlet/DummyServlet.java
Patch:
@@ -16,6 +16,7 @@
 package com.google.inject.servlet;
 
 import com.google.inject.Singleton;
+
 import javax.servlet.http.HttpServlet;
 
 /**

File: extensions/servlet/test/com/google/inject/servlet/EdslTest.java
Patch:
@@ -22,9 +22,11 @@
 import com.google.inject.Module;
 import com.google.inject.Singleton;
 import com.google.inject.Stage;
-import java.util.HashMap;
+
 import junit.framework.TestCase;
 
+import java.util.HashMap;
+
 /**
  * Sanity checks the EDSL and resultant bound module(s).
  *

File: extensions/servlet/test/com/google/inject/servlet/ServletTest.java
Patch:
@@ -29,13 +29,13 @@
 import static org.easymock.EasyMock.replay;
 import static org.easymock.EasyMock.verify;
 
+import com.google.common.collect.Maps;
 import com.google.inject.AbstractModule;
 import com.google.inject.BindingAnnotation;
 import com.google.inject.CreationException;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Key;
-import com.google.common.collect.Maps;
 import com.google.inject.servlet.RequestParameters;
 import com.google.inject.util.Providers;
 

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -85,7 +85,7 @@ public Boolean visit(InstanceBinding<? extends T> binding) {
         Set<InjectionPoint> injectionPoints = binding.getInjectionPoints();
         T instance = binding.getInstance();
         Initializable<T> ref = initializer.requestInjection(
-            injector, instance, source, injectionPoints);
+            injector, instance, key, source, injectionPoints);
         ConstantFactory<? extends T> factory = new ConstantFactory<T>(ref);
         InternalFactory<? extends T> scopedFactory
             = Scoping.scope(key, injector, factory, source, scoping);
@@ -99,7 +99,7 @@ public Boolean visit(ProviderInstanceBinding<? extends T> binding) {
         Provider<? extends T> provider = binding.getProviderInstance();
         Set<InjectionPoint> injectionPoints = binding.getInjectionPoints();
         Initializable<Provider<? extends T>> initializable = initializer
-            .<Provider<? extends T>>requestInjection(injector, provider, source, injectionPoints);
+            .<Provider<? extends T>>requestInjection(injector, provider, null, source, injectionPoints);
         InternalFactory<T> factory = new InternalFactoryToInitializableAdapter<T>(
             initializable, source, !injector.options.disableCircularProxies,
             injector.provisionListenerStore.get(key));

File: core/src/com/google/inject/internal/ConstructorInjector.java
Patch:
@@ -85,7 +85,7 @@ Object construct(final Errors errors, final InternalContext context,
       if (!provisionCallback.hasListeners()) {
         return provision(errors, context, constructionContext);        
       } else {
-        return provisionCallback.provision(errors, new ProvisionCallback<T>() {
+        return provisionCallback.provision(errors, context, new ProvisionCallback<T>() {
           public T call() throws ErrorsException {
             return provision(errors, context, constructionContext);
           }

File: core/src/com/google/inject/internal/InjectionRequestProcessor.java
Patch:
@@ -58,7 +58,7 @@ final class InjectionRequestProcessor extends AbstractProcessor {
     }
 
     initializer.requestInjection(
-        injector, request.getInstance(), request.getSource(), injectionPoints);
+        injector, request.getInstance(), null, request.getSource(), injectionPoints);
     return true;
   }
 

File: core/src/com/google/inject/internal/InternalFactoryToProviderAdapter.java
Patch:
@@ -35,6 +35,7 @@ public InternalFactoryToProviderAdapter(Provider<? extends T> provider, Object s
 
   public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
+    // TODO(sameb): Does this need to push state into the context?
     try {
       return errors.checkForNull(provider.get(), source, dependency);
     } catch (RuntimeException userException) {

File: core/src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -198,14 +198,14 @@ void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors
           injector.callInContext(new ContextualCallable<Void>() {
             Dependency<?> dependency = Dependency.get(binding.getKey());
             public Void call(InternalContext context) {
-              Dependency previous = context.setDependency(dependency);
+              Dependency previous = context.pushDependency(dependency, binding.getSource());
               Errors errorsForBinding = errors.withSource(dependency);
               try {
                 binding.getInternalFactory().get(errorsForBinding, context, dependency, false);
               } catch (ErrorsException e) {
                 errorsForBinding.merge(e.getErrors());
               } finally {
-                context.setDependency(previous);
+                context.popStateAndSetDependency(previous);
               }
 
               return null;

File: core/src/com/google/inject/internal/ProviderInternalFactory.java
Patch:
@@ -65,7 +65,7 @@ protected T circularGet(final Provider<? extends T> provider, final Errors error
     if (!provisionCallback.hasListeners()) {
       return provision(provider, errors, dependency, constructionContext);
     } else {
-      return provisionCallback.provision(errors, new ProvisionCallback<T>() {
+      return provisionCallback.provision(errors, context, new ProvisionCallback<T>() {
         public T call() throws ErrorsException {
           return provision(provider, errors, dependency, constructionContext);
         }

File: core/src/com/google/inject/internal/ConstructorInjectorStore.java
Patch:
@@ -30,7 +30,6 @@ final class ConstructorInjectorStore {
 
   private final FailableCache<InjectionPoint, ConstructorInjector<?>>  cache
       = new FailableCache<InjectionPoint, ConstructorInjector<?>> () {
-    @SuppressWarnings("unchecked")
     protected ConstructorInjector<?> create(InjectionPoint constructorInjector, Errors errors)
         throws ErrorsException {
       return createConstructor(constructorInjector, errors);

File: core/src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -106,7 +106,7 @@ public T get() {
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);
     } catch (InvocationTargetException e) {
-      throw Exceptions.throwCleanly(e);
+      throw Exceptions.rethrowCause(e);
     }
   }
 

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -90,6 +90,7 @@ public static Test suite() {
     suite.addTestSuite(PrivateModuleTest.class);
     suite.addTestSuite(ProviderInjectionTest.class);
     suite.addTestSuite(ProvisionExceptionTest.class);
+    suite.addTestSuite(ProvisionListenerTest.class);
     // ProxyFactoryTest is AOP-only
     suite.addTestSuite(ReflectionTest.class);
     suite.addTestSuite(RequestInjectionTest.class);

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -38,7 +38,8 @@
 import java.util.Map;
 import java.util.Set;
 
-final class ConstructorBindingImpl<T> extends BindingImpl<T> implements ConstructorBinding<T> {
+final class ConstructorBindingImpl<T> extends BindingImpl<T>
+    implements ConstructorBinding<T>, DelayedInitialize {
 
   private final Factory<T> factory;
   private final InjectionPoint constructorInjectionPoint;

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -100,7 +100,7 @@ public Boolean visit(ProviderInstanceBinding<? extends T> binding) {
         Set<InjectionPoint> injectionPoints = binding.getInjectionPoints();
         Initializable<Provider<? extends T>> initializable = initializer
             .<Provider<? extends T>>requestInjection(injector, provider, source, injectionPoints);
-        InternalFactory<T> factory = new InternalFactoryToInitializableAdapter<T>(key,
+        InternalFactory<T> factory = new InternalFactoryToInitializableAdapter<T>(
             initializable, source, !injector.options.disableCircularProxies);
         InternalFactory<? extends T> scopedFactory
             = Scoping.scope(key, injector, factory, source, scoping);
@@ -112,7 +112,7 @@ public Boolean visit(ProviderInstanceBinding<? extends T> binding) {
       public Boolean visit(ProviderKeyBinding<? extends T> binding) {
         prepareBinding();
         Key<? extends javax.inject.Provider<? extends T>> providerKey = binding.getProviderKey();
-        BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<T>(key,
+        BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<T>(
             injector, providerKey, source, !injector.options.disableCircularProxies);
         bindingData.addCreationListener(boundProviderFactory);
         InternalFactory<? extends T> scopedFactory = Scoping.scope(

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -30,12 +30,11 @@ final class BoundProviderFactory<T> extends ProviderInternalFactory<T> implement
   private InternalFactory<? extends javax.inject.Provider<? extends T>> providerFactory;
 
   BoundProviderFactory(
-      Key<T> key,
       InjectorImpl injector,
       Key<? extends javax.inject.Provider<? extends T>> providerKey,
       Object source,
       boolean allowProxy) {
-    super(key, source, allowProxy);
+    super(source, allowProxy);
     this.injector = injector;
     this.providerKey = providerKey;
   }

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -678,7 +678,7 @@ <T> BindingImpl<T> createProvidedByBinding(Key<T> key, Scoping scoping,
         = getBindingOrThrow(providerKey, errors, JitLimitation.NEW_OR_EXISTING_JIT);
 
     InternalFactory<T> internalFactory =
-        new ProviderInternalFactory<T>(key, providerKey, !options.disableCircularProxies) {
+        new ProviderInternalFactory<T>(providerKey, !options.disableCircularProxies) {
       public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
           throws ErrorsException {
         errors = errors.withSource(providerKey);

File: core/src/com/google/inject/internal/InternalFactoryToInitializableAdapter.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.inject.Key;
 import com.google.inject.Provider;
 import static com.google.inject.internal.util.Preconditions.checkNotNull;
 import com.google.inject.spi.Dependency;
@@ -33,9 +32,9 @@ final class InternalFactoryToInitializableAdapter<T> extends ProviderInternalFac
   private final Initializable<Provider<? extends T>> initializable;
 
   public InternalFactoryToInitializableAdapter(
-      Key<T> key, Initializable<Provider<? extends T>> initializable,
+      Initializable<Provider<? extends T>> initializable,
       Object source, boolean allowProxy) {
-    super(key, source, allowProxy);
+    super(source, allowProxy);
     this.initializable = checkNotNull(initializable, "provider");
   }
 

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -100,7 +100,7 @@ public Boolean visit(ProviderInstanceBinding<? extends T> binding) {
         Set<InjectionPoint> injectionPoints = binding.getInjectionPoints();
         Initializable<Provider<? extends T>> initializable = initializer
             .<Provider<? extends T>>requestInjection(injector, provider, source, injectionPoints);
-        InternalFactory<T> factory = new InternalFactoryToInitializableAdapter<T>(
+        InternalFactory<T> factory = new InternalFactoryToInitializableAdapter<T>(key,
             initializable, source, !injector.options.disableCircularProxies);
         InternalFactory<? extends T> scopedFactory
             = Scoping.scope(key, injector, factory, source, scoping);
@@ -112,7 +112,7 @@ public Boolean visit(ProviderInstanceBinding<? extends T> binding) {
       public Boolean visit(ProviderKeyBinding<? extends T> binding) {
         prepareBinding();
         Key<? extends javax.inject.Provider<? extends T>> providerKey = binding.getProviderKey();
-        BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<T>(
+        BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<T>(key,
             injector, providerKey, source, !injector.options.disableCircularProxies);
         bindingData.addCreationListener(boundProviderFactory);
         InternalFactory<? extends T> scopedFactory = Scoping.scope(

File: core/src/com/google/inject/internal/BoundProviderFactory.java
Patch:
@@ -30,11 +30,12 @@ final class BoundProviderFactory<T> extends ProviderInternalFactory<T> implement
   private InternalFactory<? extends javax.inject.Provider<? extends T>> providerFactory;
 
   BoundProviderFactory(
+      Key<T> key,
       InjectorImpl injector,
       Key<? extends javax.inject.Provider<? extends T>> providerKey,
       Object source,
       boolean allowProxy) {
-    super(source, allowProxy);
+    super(key, source, allowProxy);
     this.injector = injector;
     this.providerKey = providerKey;
   }

File: core/src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -678,7 +678,7 @@ <T> BindingImpl<T> createProvidedByBinding(Key<T> key, Scoping scoping,
         = getBindingOrThrow(providerKey, errors, JitLimitation.NEW_OR_EXISTING_JIT);
 
     InternalFactory<T> internalFactory =
-        new ProviderInternalFactory<T>(providerKey, !options.disableCircularProxies) {
+        new ProviderInternalFactory<T>(key, providerKey, !options.disableCircularProxies) {
       public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
           throws ErrorsException {
         errors = errors.withSource(providerKey);

File: core/src/com/google/inject/internal/DelegatingInvocationHandler.java
Patch:
@@ -34,6 +34,9 @@ public Object invoke(Object proxy, Method method, Object[] args)
     }
 
     try {
+      // TODO: method.setAccessible(true); ?
+      // this would fix visibility errors when we proxy a
+      // non-public interface.
       return method.invoke(delegate, args);
     } catch (IllegalAccessException e) {
       throw new RuntimeException(e);

File: core/src/com/google/inject/internal/Scoping.java
Patch:
@@ -239,8 +239,7 @@ static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector,
 
     Provider<T> scoped
         = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));
-    return new InternalFactoryToProviderAdapter<T>(
-        Initializables.<Provider<? extends T>>of(scoped), source);
+    return new InternalFactoryToProviderAdapter<T>(scoped, source);
   }
 
   /**

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -156,7 +156,8 @@ public void doFilter(ServletRequest servletRequest,
       ServletResponse servletResponse, FilterChainInvocation filterChainInvocation)
       throws IOException, ServletException {
 
-    final String path = ((HttpServletRequest) servletRequest).getServletPath();
+    final HttpServletRequest request = (HttpServletRequest) servletRequest;
+    final String path = request.getRequestURI().substring(request.getContextPath().length());
 
     if (shouldFilter(path)) {
       filter.get()

File: core/test/com/google/inject/MethodInterceptionTest.java
Patch:
@@ -172,7 +172,7 @@ protected void configure() {
       fail();
     } catch (Exception e) {
       // validate all causes.
-      for (Throwable t = e; t != null; t = e.getCause()) {
+      for (Throwable t = e; t != null; t = t.getCause()) {
         StackTraceElement[] stackTraceElement = t.getStackTrace();
         assertEquals("explode", stackTraceElement[0].getMethodName());
         assertEquals("invoke", stackTraceElement[1].getMethodName());

File: core/src/com/google/inject/internal/InheritingState.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * @author jessewilson@google.com (Jesse Wilson)
@@ -143,8 +144,8 @@ public boolean isBlacklisted(Key<?> key) {
     return blacklistedKeys.contains(key);
   }
   
-  public Object getSourceForBlacklistedKey(Key<?> key) {
-    return blacklistedKeys.getSource(key);
+  public Set<Object> getSourcesForBlacklistedKey(Key<?> key) {
+    return blacklistedKeys.getSources(key);
   }
 
   public Object lock() {

File: core/src/com/google/inject/internal/State.java
Patch:
@@ -28,6 +28,7 @@
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * The inheritable data within an injector. This class is intended to allow parent and local
@@ -100,7 +101,7 @@ public boolean isBlacklisted(Key<?> key) {
       return true;
     }
     
-    public Object getSourceForBlacklistedKey(Key<?> key) {
+    public Set<Object> getSourcesForBlacklistedKey(Key<?> key) {
       throw new UnsupportedOperationException();
     }
 
@@ -161,7 +162,7 @@ TypeConverterBinding getConverter(
   boolean isBlacklisted(Key<?> key);
   
   /** Returns the source of a blacklisted key. */
-  Object getSourceForBlacklistedKey(Key<?> key);
+  Set<Object> getSourcesForBlacklistedKey(Key<?> key);
 
   /**
    * Returns the shared lock for all injector data. This is a low-granularity, high-contention lock

File: core/src/com/google/inject/Injector.java
Patch:
@@ -213,7 +213,9 @@ public interface Injector {
    *
    * <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
    * whenever possible. This allows for scoped instances to be shared between injectors. Use
-   * explicit bindings to prevent bindings from being shared with the parent injector.
+   * explicit bindings to prevent bindings from being shared with the parent injector.  Optional
+   * injections in just-in-time bindings (created in the parent injector) may be silently
+   * ignored if the optional dependencies are from the child injector.
    *
    * <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
    * bindings. The lone exception is the key for {@code Injector.class}, which is bound by each

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -264,7 +264,7 @@ private void putBinding(BindingImpl<?> binding) {
     }
 
     // prevent the parent from creating a JIT binding for this key
-    injector.state.parent().blacklist(key);
+    injector.state.parent().blacklist(key, binding.getSource());
     injector.state.putBinding(key, binding);
   }
 

File: core/test/com/google/inject/ParentInjectorTest.java
Patch:
@@ -52,8 +52,8 @@ public void testParentJitBindingWontClobberChildBinding() {
       parent.getInstance(A.class);
       fail("Created a just-in-time binding on the parent that's the same as a child's binding");
     } catch (ConfigurationException e) {
-      assertContains(e.getMessage(), "A binding to ", A.class.getName(),
-          " already exists on a child injector.");
+      assertContains(e.getMessage(),
+          "A binding to " + A.class.getName() + " was already configured at " + bindsA.getClass().getName());
     }
   }
 

File: core/src/com/google/inject/internal/util/LineNumbers.java
Patch:
@@ -58,8 +58,9 @@ public LineNumbers(Class type) throws IOException {
 
     if (!type.isArray()) {
       InputStream in = type.getResourceAsStream("/" + type.getName().replace('.', '/') + ".class");
-      Preconditions.checkArgument(in != null, "Cannot find bytecode for %s", type);
-      new ClassReader(in).accept(new LineNumberReader(), ClassReader.SKIP_FRAMES);
+      if (in != null) {
+        new ClassReader(in).accept(new LineNumberReader(), ClassReader.SKIP_FRAMES);
+      }
     }
   }
 

File: core/src/com/google/inject/ProvisionException.java
Patch:
@@ -34,7 +34,7 @@ public final class ProvisionException extends RuntimeException {
 
   private final ImmutableSet<Message> messages;
 
-  /** Creates a ConfigurationException containing {@code messages}. */
+  /** Creates a ProvisionException containing {@code messages}. */
   public ProvisionException(Iterable<Message> messages) {
     this.messages = ImmutableSet.copyOf(messages);
     checkArgument(!this.messages.isEmpty());

File: core/src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -270,7 +270,7 @@ private void putBinding(BindingImpl<?> binding) {
 
   /**
    * We tolerate duplicate bindings if one exposes the other or if the two bindings
-   * are considered duplicates (see {@link Bindings#areDuplicates(BindingImpl, BindingImpl)}. 
+   * are considered duplicates (see {@link Bindings#areDuplicates(BindingImpl, BindingImpl)}.
    *
    * @param original the binding in the parent injector (candidate for an exposing binding)
    * @param binding the binding to check (candidate for the exposed binding)
@@ -295,7 +295,7 @@ private boolean isOkayDuplicate(BindingImpl<?> original, BindingImpl<?> binding,
   // It's unfortunate that we have to maintain a blacklist of specific
   // classes, but we can't easily block the whole package because of
   // all our unit tests.
-  private static final Set<Class<?>> FORBIDDEN_TYPES = ImmutableSet.of(
+  private static final Set<Class<?>> FORBIDDEN_TYPES = ImmutableSet.<Class<?>>of(
       AbstractModule.class,
       Binder.class,
       Binding.class,

File: core/src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -197,6 +197,7 @@ public Set<Dependency<?>> getDependencies() {
         null, key, getSource(), factory, getScoping(), factory, constructorInjectionPoint);
   }
 
+  @SuppressWarnings("unchecked") // the raw constructor member and declaring type always agree
   public void applyTo(Binder binder) {
     InjectionPoint constructor = getConstructor();
     getScoping().applyTo(binder.withSource(getSource()).bind(getKey()).toConstructor(

File: core/src/com/google/inject/internal/ProviderInstanceBindingImpl.java
Patch:
@@ -53,9 +53,11 @@ public ProviderInstanceBindingImpl(Object source, Key<T> key, Scoping scoping,
     this.providerInstance = providerInstance;
   }
 
+  @SuppressWarnings("unchecked") // the extension type is always consistent with the provider type
   public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     if(providerInstance instanceof ProviderWithExtensionVisitor) {
-      return ((ProviderWithExtensionVisitor<? extends T>)providerInstance).acceptExtensionVisitor(visitor, this);
+      return ((ProviderWithExtensionVisitor<? extends T>) providerInstance)
+          .acceptExtensionVisitor(visitor, this);
     } else {
       return visitor.visit(this);
     }

File: core/src/com/google/inject/internal/ProxyFactory.java
Patch:
@@ -248,7 +248,7 @@ private static class ProxyConstructor<T> implements ConstructionProxy<T> {
     }
 
     @SuppressWarnings("unchecked") // the constructor promises to produce 'T's
-    public T newInstance(Object[] arguments) throws InvocationTargetException {
+    public T newInstance(Object... arguments) throws InvocationTargetException {
       Enhancer.registerCallbacks(enhanced, callbacks);
       try {
         return (T) fastConstructor.newInstance(arguments);

File: extensions/persist/src/com/google/inject/persist/PersistModule.java
Patch:
@@ -35,7 +35,10 @@ protected final void configure() {
 
     requireBinding(PersistService.class);
     requireBinding(UnitOfWork.class);
+    /*if[AOP]*/
+    // wrapping in an if[AOP] just to allow this to compile in NO_AOP -- it won't be used
     bindInterceptor(any(), annotatedWith(Transactional.class), getTransactionInterceptor());
+    /*end[AOP]*/
   }
 
   protected abstract void configurePersistence();

File: core/src/com/google/inject/Injector.java
Patch:
@@ -252,8 +252,8 @@ public interface Injector {
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
 
   /**
-   * Returns a list containing all type converter bindings in the injector. The returned list
-   * is immutable.
+   * Returns a set containing all type converter bindings in the injector. The returned set is
+   * immutable.
    *
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    * 

File: core/src/com/google/inject/internal/TypeConverterBindingProcessor.java
Patch:
@@ -161,12 +161,12 @@ public boolean matches(TypeLiteral<?> typeLiteral) {
   private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter converter) {
     injector.state.addConverter(
-        new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE));
+        new TypeConverterBinding(SourceProvider.UNKNOWN_SOURCE, typeMatcher, converter));
   }
 
   @Override public Boolean visit(TypeConverterBinding command) {
-    injector.state.addConverter(new MatcherAndConverter(
-        command.getTypeMatcher(), command.getTypeConverter(), command.getSource()));
+    injector.state.addConverter(new TypeConverterBinding(
+        command.getSource(), command.getTypeMatcher(), command.getTypeConverter()));
     return true;
   }
 }

File: core/test/com/googlecode/guice/StrictContainerTestSuiteBuilder.java
Patch:
@@ -102,7 +102,8 @@ protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundE
           || name.startsWith("javax.")
           || name.startsWith("junit.")
           || name.startsWith("sun.")
-          || name.startsWith("com.sun.")) {
+          || name.startsWith("com.sun.")
+          || name.contains("cglib")) {
         return super.loadClass(name, resolve);
       }
 

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProvides.java
Patch:
@@ -31,11 +31,11 @@
  * @since 3.0
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
-public @interface ThrowingProvides {
+public @interface CheckedProvides {
   
   /**
-   * The interface that provides this value, a subinterface of ThrowingProvider.
+   * The interface that provides this value, a subinterface of {@link CheckedProvider}.
    */
-  Class<? extends ThrowingProvider> value();
+  Class<? extends CheckedProvider> value();
   
 }

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/ThrowingProvider.java
Patch:
@@ -32,7 +32,9 @@
  *
  * @author jmourits@google.com (Jerome Mourits)
  * @author jessewilson@google.com (Jesse Wilson)
+ * @deprecated use {@link CheckedProvider} instead.
  */
-public interface ThrowingProvider<T,E extends Exception> {
+@Deprecated
+public interface ThrowingProvider<T,E extends Exception> extends CheckedProvider<T> {
   T get() throws E;
 }

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -75,13 +75,13 @@ public <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
             new InstanceFilterBindingImpl(initParams,
                 pattern,
                 filterInstance,
-                patternMatcher.getPatternType()));        
+                patternMatcher));        
       } else {
         return ((ServletModuleTargetVisitor<B, V>)visitor).visit(
             new LinkedFilterBindingImpl(initParams,
                 pattern,
                 filterKey,
-                patternMatcher.getPatternType()));
+                patternMatcher));
       }
     } else {
       return visitor.visit(binding);

File: extensions/servlet/src/com/google/inject/servlet/InstanceFilterBindingImpl.java
Patch:
@@ -31,8 +31,8 @@ class InstanceFilterBindingImpl extends AbstractServletModuleBinding<Filter> imp
     InstanceFilterBinding {
 
   InstanceFilterBindingImpl(Map<String, String> initParams, String pattern,
-      Filter target, UriPatternType patternType) {
-    super(initParams, pattern, target, patternType);
+      Filter target, UriPatternMatcher patternMatcher) {
+    super(initParams, pattern, target, patternMatcher);
   }
 
   public Filter getFilterInstance() {

File: extensions/servlet/src/com/google/inject/servlet/InstanceServletBindingImpl.java
Patch:
@@ -31,8 +31,8 @@ class InstanceServletBindingImpl extends AbstractServletModuleBinding<HttpServle
     InstanceServletBinding {
 
   InstanceServletBindingImpl(Map<String, String> initParams, String pattern,
-      HttpServlet target, UriPatternType patternType) {
-    super(initParams, pattern, target, patternType);
+      HttpServlet target, UriPatternMatcher patternMatcher) {
+    super(initParams, pattern, target, patternMatcher);
   }
 
   public HttpServlet getServletInstance() {

File: extensions/servlet/src/com/google/inject/servlet/LinkedFilterBindingImpl.java
Patch:
@@ -32,8 +32,8 @@ class LinkedFilterBindingImpl extends AbstractServletModuleBinding<Key<? extends
     implements LinkedFilterBinding {
 
   LinkedFilterBindingImpl(Map<String, String> initParams, String pattern,
-      Key<? extends Filter> target, UriPatternType patternType) {
-    super(initParams, pattern, target, patternType);
+      Key<? extends Filter> target, UriPatternMatcher patternMatcher) {
+    super(initParams, pattern, target, patternMatcher);
   }
 
   public Key<? extends Filter> getLinkedKey() {

File: extensions/servlet/src/com/google/inject/servlet/LinkedServletBindingImpl.java
Patch:
@@ -32,8 +32,8 @@ class LinkedServletBindingImpl extends AbstractServletModuleBinding<Key<? extend
     implements LinkedServletBinding {
 
   LinkedServletBindingImpl(Map<String, String> initParams, String pattern,
-      Key<? extends HttpServlet> target, UriPatternType patternType) {
-    super(initParams, pattern, target, patternType);
+      Key<? extends HttpServlet> target, UriPatternMatcher patternMatcher) {
+    super(initParams, pattern, target, patternMatcher);
   }
 
   public Key<? extends HttpServlet> getLinkedKey() {

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -79,13 +79,13 @@ public <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
             new InstanceServletBindingImpl(initParams,
                 pattern,
                 servletInstance,
-                patternMatcher.getPatternType()));        
+                patternMatcher));        
       } else {
         return ((ServletModuleTargetVisitor<B, V>)visitor).visit(
             new LinkedServletBindingImpl(initParams,
                 pattern,
                 servletKey,
-                patternMatcher.getPatternType()));
+                patternMatcher));
       }
     } else {
       return visitor.visit(binding);

File: extensions/servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -269,7 +269,7 @@ protected final ServletKeyBindingBuilder serveRegex(String regex, String... rege
    * This method only works if you are using the {@linkplain GuiceServletContextListener} to
    * create your injector. Otherwise, it returns null.
    * @return The current servlet context.
-   * @since 2.1
+   * @since 3.0
    */
   protected final ServletContext getServletContext() {
     return GuiceFilter.getServletContext();

File: core/src/com/google/inject/internal/Errors.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.inject.ProvisionException;
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.util.Classes;
 import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.ImmutableSet;
 import com.google.inject.internal.util.Lists;
@@ -626,7 +627,7 @@ public String toString(Class c) {
       },
       new Converter<Member>(Member.class) {
         public String toString(Member member) {
-          return MoreTypes.toString(member);
+          return Classes.toString(member);
         }
       },
       new Converter<Key>(Key.class) {
@@ -683,7 +684,7 @@ public static void formatSource(Formatter formatter, Object source) {
   public static void formatInjectionPoint(Formatter formatter, Dependency<?> dependency,
       InjectionPoint injectionPoint) {
     Member member = injectionPoint.getMember();
-    Class<? extends Member> memberType = MoreTypes.memberType(member);
+    Class<? extends Member> memberType = Classes.memberType(member);
 
     if (memberType == Field.class) {
       dependency = injectionPoint.getDependencies().get(0);

File: core/src/com/google/inject/internal/util/StackTraceElements.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal.util;
 
-import com.google.inject.internal.MoreTypes;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;
@@ -61,7 +60,7 @@ public static Object forMember(Member member) {
     int lineNumber = -1;
     end[NO_AOP]*/
 
-    Class<? extends Member> memberType = MoreTypes.memberType(member);
+    Class<? extends Member> memberType = Classes.memberType(member);
     String memberName = memberType == Constructor.class ? "<init>" : member.getName();
     return new StackTraceElement(declaringClass.getName(), memberName, fileName, lineNumber);
   }

File: core/src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -23,9 +23,9 @@
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
-import com.google.inject.internal.MoreTypes;
 import static com.google.inject.internal.MoreTypes.getRawType;
 import com.google.inject.internal.Nullability;
+import com.google.inject.internal.util.Classes;
 import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.ImmutableSet;
 import com.google.inject.internal.util.Lists;
@@ -191,7 +191,7 @@ public TypeLiteral<?> getDeclaringType() {
   }
 
   @Override public String toString() {
-    return MoreTypes.toString(member);
+    return Classes.toString(member);
   }
 
   /**

File: extensions/throwingproviders/test/com/google/inject/throwingproviders/ThrowingProviderBinderTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
-import com.google.inject.internal.MoreTypes;
+import com.google.inject.internal.util.Classes;
 import com.google.inject.internal.util.Function;
 import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.ImmutableSet;
@@ -729,7 +729,7 @@ String foo() {
       fail();
     } catch(CreationException ce) {
       assertEquals(OneNoneGetMethod.class.getName() 
-          + " may not declare any new methods, but declared " + MoreTypes.toString(OneNoneGetMethod.class.getDeclaredMethods()[0]),
+          + " may not declare any new methods, but declared " + Classes.toString(OneNoneGetMethod.class.getDeclaredMethods()[0]),
           Iterables.getOnlyElement(ce.getErrorMessages()).getMessage());
     }
   }

File: core/src/com/google/inject/internal/Nullability.java
Patch:
@@ -22,7 +22,9 @@ private Nullability() {}
 
   public static boolean allowsNull(Annotation[] annotations) {
     for(Annotation a : annotations) {
-      if ("Nullable".equals(a.annotationType().getSimpleName())) {
+      String name = a.annotationType().getSimpleName();
+      // Check for $Nullable also because jarjar renames it.
+      if ("Nullable".equals(name) || "$Nullable".equals(name)) {
         return true;
       }
     }

File: core/test/com/google/inject/internal/util/FinalizableReferenceQueueTest.java
Patch:
@@ -140,7 +140,7 @@ protected synchronized Class<?> loadClass(String name, boolean resolve)
   }
 
   public void testGetFinalizerUrl() {
-    assertNotNull(getClass().getResource("Finalizer.class"));
+    assertNotNull(getClass().getResource(Finalizer.class.getSimpleName() + ".class"));
   }
 }
 

File: core/src/com/google/inject/internal/ConstructionProxyFactory.java
Patch:
@@ -26,5 +26,5 @@ interface ConstructionProxyFactory<T> {
   /**
    * Gets a construction proxy for the given constructor.
    */
-  ConstructionProxy<T> create();
+  ConstructionProxy<T> create() throws ErrorsException;
 }

File: core/src/com/google/inject/internal/ProxyFactory.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.inject.internal.util.Lists;
 import com.google.inject.internal.util.Maps;
 import com.google.inject.spi.InjectionPoint;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -147,7 +148,7 @@ public ImmutableMap<Method, List<MethodInterceptor>> getInterceptors() {
     return interceptors;
   }
 
-  public ConstructionProxy<T> create() {
+  public ConstructionProxy<T> create() throws ErrorsException {
     if (interceptors.isEmpty()) {
       return new DefaultConstructionProxyFactory<T>(injectionPoint).create();
     }
@@ -164,7 +165,7 @@ public ConstructionProxy<T> create() {
     enhancer.setCallbackTypes(callbackTypes);
     return new ProxyConstructor<T>(enhancer, injectionPoint, callbacks, interceptors);
     } catch (Throwable e) {
-      throw new ProvisionException("Unable to method intercept: " + declaringClass, e);
+      throw new Errors().errorEnhancingClass(declaringClass, e).toException();
     }
   }
 

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java
Patch:
@@ -92,6 +92,9 @@
  * that module can order its bindings appropriately. Avoid relying on the
  * iteration order of elements contributed by different modules, since there is
  * no equivalent mechanism to order modules.
+ * 
+ * <p>The map is unmodifiable.  Elements can only be added to the map by
+ * configuring the MapBinder.  Elements can never be removed from the map.
  *
  * <p>Values are resolved at map injection time. If a value is bound to a
  * provider, that provider's get method will be called each time the map is

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -81,6 +81,9 @@
  * that module can order its bindings appropriately. Avoid relying on the
  * iteration order of elements contributed by different modules, since there is
  * no equivalent mechanism to order modules.
+ * 
+ * <p>The set is unmodifiable.  Elements can only be added to the set by
+ * configuring the multibinder.  Elements can never be removed from the set.
  *
  * <p>Elements are resolved at set injection time. If an element is bound to a
  * provider, that provider's get method will be called each time the set is

File: extensions/assistedinject/src/com/google/inject/assistedinject/package-info.java
Patch:
@@ -16,6 +16,6 @@
 
 /**
  * Extension for combining factory interfaces with injection; this extension requires {@code
- * guice-jndi-2.0.jar}.
+ * guice-assistedinject-3.0.jar}.
  */
 package com.google.inject.assistedinject;
\ No newline at end of file

File: extensions/jmx/src/com/google/inject/tools/jmx/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * JMX integration; this extension requires {@code guice-jmx-2.0.jar}.
+ * JMX integration; this extension requires {@code guice-jmx-3.0.jar}.
  */
 package com.google.inject.tools.jmx;
\ No newline at end of file

File: extensions/jndi/src/com/google/inject/jndi/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * JNDI integration; this extension requires {@code guice-jndi-2.0.jar}.
+ * JNDI integration; this extension requires {@code guice-jndi-3.0.jar}.
  */
 package com.google.inject.jndi;
\ No newline at end of file

File: extensions/multibindings/src/com/google/inject/multibindings/package-info.java
Patch:
@@ -16,6 +16,6 @@
 
 /**
  * Extension for binding multiple instances in a collection; this extension requires {@code
- * guice-multibindings-2.0.jar}.
+ * guice-multibindings-3.0.jar}.
  */
 package com.google.inject.multibindings;
\ No newline at end of file

File: extensions/servlet/src/com/google/inject/servlet/package-info.java
Patch:
@@ -16,7 +16,7 @@
 
 /**
  * Servlet API scopes, bindings and registration; this extension requires {@code
- * guice-servlet-2.0.jar}.
+ * guice-servlet-3.0.jar}.
  *
  * <p>Apply {@link com.google.inject.servlet.GuiceFilter} to any servlets which will use the servlet
  * scopes. Install {@link com.google.inject.servlet.ServletModule} into your {@link

File: extensions/spring/src/com/google/inject/spring/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * Spring integration; this extension requires {@code guice-spring-2.0.jar}.
+ * Spring integration; this extension requires {@code guice-spring-3.0.jar}.
  */
 package com.google.inject.spring;
\ No newline at end of file

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/package-info.java
Patch:
@@ -16,6 +16,6 @@
 
 /**
  * Extension for injecting objects that may throw at provision time; this extension requires {@code
- * guice-throwingproviders-2.0.jar}.
+ * guice-throwingproviders-3.0.jar}.
  */
 package com.google.inject.throwingproviders;
\ No newline at end of file

File: core/src/com/google/inject/internal/InternalContext.java
Patch:
@@ -47,7 +47,7 @@ public Dependency getDependency() {
   }
 
   public Dependency setDependency(Dependency dependency) {
-    Dependency previous = dependency;
+    Dependency previous = this.dependency;
     this.dependency = dependency;
     return previous;
   }

File: core/src/com/google/inject/internal/ConstructionProxy.java
Patch:
@@ -22,7 +22,6 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
-import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * Proxies calls to a {@link java.lang.reflect.Constructor} for a class
@@ -52,6 +51,6 @@ interface ConstructionProxy<T> {
   /**
    * Returns the interceptors applied to each method, in order of invocation.
    */
-  ImmutableMap<Method, List<MethodInterceptor>> getMethodInterceptors();
+  ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors();
   /*end[AOP]*/
 }

File: core/src/com/google/inject/internal/DefaultConstructionProxyFactory.java
Patch:
@@ -24,7 +24,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.List;
-import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * Produces construction proxies that invoke the class constructor.
@@ -97,7 +96,7 @@ public Constructor<T> getConstructor() {
         return constructor;
       }
       /*if[AOP]*/
-      public ImmutableMap<Method, List<MethodInterceptor>>
+      public ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>>
           getMethodInterceptors() {
         return ImmutableMap.of();
       }

File: core/test/com/google/inject/AllTests.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.inject.internal.util.LineNumbersTest;
 import com.google.inject.internal.util.MapMakerTestSuite;
 import com.google.inject.internal.MoreTypesTest;
-import com.google.inject.internal.ProxyFactoryTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.name.NamedEquivalanceTest;
@@ -138,7 +137,7 @@ public static Test suite() {
     suite.addTestSuite(TypesTest.class);
 
     /*if[AOP]*/
-    suite.addTestSuite(ProxyFactoryTest.class);
+    suite.addTestSuite(com.google.inject.internal.ProxyFactoryTest.class);
     suite.addTestSuite(IntegrationTest.class);
     suite.addTestSuite(MethodInterceptionTest.class);
     suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);

File: core/test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -1127,7 +1127,9 @@ protected void configure() {
                 assertEquals(field,
                     getOnlyElement(constructorBinding.getInjectableMembers()).getMember());
                 assertEquals(2, constructorBinding.getDependencies().size());
+/*if[AOP]*/
                 assertEquals(ImmutableMap.of(), constructorBinding.getMethodInterceptors());
+/*end[AOP]*/
                 return null;
               }
             });

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -202,9 +202,9 @@ void doService(final ServletRequest servletRequest, ServletResponse servletRespo
       @Override
       public String getPathInfo() {
         if (!isPathInfoComputed()) {
-          final int servletPathLength = getServletPath().length();
-          pathInfo = getRequestURI().substring(getContextPath().length()).replaceAll("[/]{2,}", "/")
-              .substring(servletPathLength);
+          int servletPathLength = getServletPath().length();
+          pathInfo = getRequestURI().substring(getContextPath().length()).replaceAll("[/]{2,}", "/");
+          pathInfo = pathInfo.length() > servletPathLength ? pathInfo.substring(servletPathLength) : null;
 
           // Corner case: when servlet path and request path match exactly (without trailing '/'),
           // then pathinfo is null

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -303,7 +303,7 @@ public Collection<AssistedMethod> getAssistedMethods() {
   }
 
   @SuppressWarnings("unchecked")
-  public <V, T> V acceptExtensionVisitor(BindingTargetVisitor<T, V> visitor,
+  public <T, V> V acceptExtensionVisitor(BindingTargetVisitor<T, V> visitor,
       ProviderInstanceBinding<? extends T> binding) {
     if (visitor instanceof AssistedInjectTargetVisitor) {
       return ((AssistedInjectTargetVisitor<T, V>)visitor).visit((AssistedInjectBinding<T>)this);

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java
Patch:
@@ -394,7 +394,7 @@ public Set<Dependency<?>> getDependencies() {
         }
 
         @SuppressWarnings("unchecked")
-        public <R, B> R acceptExtensionVisitor(BindingTargetVisitor<B, R> visitor,
+        public <B, R> R acceptExtensionVisitor(BindingTargetVisitor<B, R> visitor,
             ProviderInstanceBinding<? extends B> binding) {
           if (visitor instanceof MultibindingsTargetVisitor) {
             return ((MultibindingsTargetVisitor<Map<K, V>, R>)visitor).visit(this);

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -328,7 +328,7 @@ public Set<T> get() {
     }
     
     @SuppressWarnings("unchecked")
-    public <V, B> V acceptExtensionVisitor(
+    public <B, V> V acceptExtensionVisitor(
         BindingTargetVisitor<B, V> visitor,
         ProviderInstanceBinding<? extends B> binding) {
       if(visitor instanceof MultibindingsTargetVisitor) {

File: extensions/servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -67,7 +67,7 @@ public FilterDefinition get() {
     return this;
   }
   
-  public <V, B> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
+  public <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
       ProviderInstanceBinding<? extends B> binding) {
     if(visitor instanceof ServletModuleTargetVisitor) {
       if(filterInstance != null) {

File: extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -71,7 +71,7 @@ public ServletDefinition get() {
     return this;
   }
   
-  public <V, B> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
+  public <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
       ProviderInstanceBinding<? extends B> binding) {
     if(visitor instanceof ServletModuleTargetVisitor) {
       if(servletInstance != null) {

File: src/com/google/inject/spi/ProviderWithExtensionVisitor.java
Patch:
@@ -55,6 +55,6 @@ public interface ProviderWithExtensionVisitor<T> extends Provider<T> {
    * relate to the type of the provider. In practice, the 'B' type will always
    * be a supertype of 'T'.
    */
-  <V, B> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
+  <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
       ProviderInstanceBinding<? extends B> binding);
 }

File: test/com/google/inject/spi/SpiBindingsTest.java
Patch:
@@ -353,7 +353,7 @@ public void testExtensionSpi() {
     final Injector injector = Guice.createInjector(new AbstractModule() {
       protected void configure() {
         bind(String.class).toProvider(new ProviderWithExtensionVisitor<String>() {
-          public <V, B> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
+          public <B, V> V acceptExtensionVisitor(BindingTargetVisitor<B, V> visitor,
               ProviderInstanceBinding<? extends B> binding) {
             assertSame(this, binding.getProviderInstance());
             // We can't always check for FailingSpiTargetVisitor,

File: extensions/servlet/test/com/google/inject/servlet/AllTests.java
Patch:
@@ -34,6 +34,7 @@ public static Test suite() {
     suite.addTestSuite(FilterPipelineTest.class);
 
     // Servlet + integration tests.
+    suite.addTestSuite(ServletModuleTest.class);
     suite.addTestSuite(ServletTest.class);
     suite.addTestSuite(ServletDefinitionTest.class);
     suite.addTestSuite(ServletDefinitionPathsTest.class);

File: extensions/service/src/com/google/inject/service/CompositeService.java
Patch:
@@ -104,13 +104,10 @@ private FutureTask<Service.State> futureGet(final List<Future<Service.State>> ta
       final Service.State state) {
     return new FutureTask<Service.State>(new Callable<Service.State>() {
       public Service.State call() {
-        System.out.println("GeT :--- ");
         boolean ok = true;
         for (Future<Service.State> task : tasks) {
           try {
-            System.out.println("GeT : " + task);
             ok = state == task.get();
-            System.out.println("OK : " + task);
           } catch (InterruptedException e) {
             return compositeState = Service.State.FAILED;
           } catch (ExecutionException e) {

File: extensions/mini/src/com/google/inject/mini/MiniGuice.java
Patch:
@@ -260,6 +260,7 @@ public Object get() {
 
   private void putBinding(Key key, Provider<Object> provider, boolean singleton) {
     if (singleton) {
+      singletons.add(key);
       final Provider<Object> unscoped = provider;
       provider = new Provider<Object>() {
         private Object onlyInstance = UNINITIALIZED;

File: extensions/persist/src/com/google/inject/persist/finder/Finder.java
Patch:
@@ -20,7 +20,6 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
-import java.util.ArrayList;
 import java.util.Collection;
 
 /**
@@ -29,7 +28,8 @@
  *
  * @author Dhanji R. Prasanna (dhanji@gmail.com)
  */
-@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
 public @interface Finder {
   /**
    * Returns the configured named query's name. Specify a named query's name
@@ -47,5 +47,5 @@
    * Use this clause to specify a collection impl to autobox result lists into. The impl must
    * have a default no-arg constructor and be a subclass of {@code java.util.Collection}.
    */
-  Class<? extends Collection> returnAs() default ArrayList.class;
+  Class<? extends Collection> returnAs() default Collection.class;
 }
\ No newline at end of file

File: extensions/persist/src/com/google/inject/persist/PersistenceFilter.java
Patch:
@@ -42,7 +42,6 @@
  * Example configuration:
  * <pre>{@code
  *  public class MyModule extends ServletModule {
- *   @literal @Override
  *    public void configureServlets() {
  *      filter("/*").through(PersistenceFilter.class);
  *

File: extensions/servlet/src/com/google/inject/servlet/UriPatternMatcher.java
Patch:
@@ -38,4 +38,7 @@ interface UriPatternMatcher {
    *         NOTE(dhanji): This method returns null for the regex pattern matcher.
    */
   String extractPath(String pattern);
+  
+  /** Returns the type of pattern this is. */
+  UriPatternType getPatternType();
 }

File: extensions/servlet/test/com/google/inject/servlet/AllTests.java
Patch:
@@ -47,6 +47,9 @@ public static Test suite() {
 
     // Multiple modules tests.
     suite.addTestSuite(MultiModuleDispatchIntegrationTest.class);
+    
+    // Extension SPI tests.
+    suite.addTestSuite(ExtensionSpiTest.class);
 
     return suite;
   }

File: extensions/servlet/test/com/google/inject/servlet/FilterDefinitionTest.java
Patch:
@@ -69,7 +69,7 @@ public final void testFilterInitAndConfig() throws ServletException {
 
     String pattern = "/*";
     final FilterDefinition filterDef = new FilterDefinition(pattern, Key.get(Filter.class),
-    		UriPatternType.get(UriPatternType.SERVLET, pattern), initParams);
+    		UriPatternType.get(UriPatternType.SERVLET, pattern), initParams, null);
     filterDef.init(servletContext, injector,
         Sets.newSetFromMap(Maps.<Filter, Boolean>newIdentityHashMap()));
 
@@ -112,7 +112,7 @@ public final void testFilterCreateDispatchDestroy() throws ServletException, IOE
 
     String pattern = "/*";
     final FilterDefinition filterDef = new FilterDefinition(pattern, Key.get(Filter.class),
-    		UriPatternType.get(UriPatternType.SERVLET, pattern), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.SERVLET, pattern), new HashMap<String, String>(), null);
     //should fire on mockfilter now
     filterDef.init(createMock(ServletContext.class), injector,
         Sets.newSetFromMap(Maps.<Filter, Boolean>newIdentityHashMap()));
@@ -169,7 +169,7 @@ public void doFilter(ServletRequest servletRequest, ServletResponse servletRespo
 
     String pattern = "/*";
     final FilterDefinition filterDef = new FilterDefinition(pattern, Key.get(Filter.class),
-        UriPatternType.get(UriPatternType.SERVLET, pattern), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.SERVLET, pattern), new HashMap<String, String>(), null);
     //should fire on mockfilter now
     filterDef.init(createMock(ServletContext.class), injector,
     		Sets.newSetFromMap(Maps.<Filter, Boolean>newIdentityHashMap()));

File: extensions/servlet/test/com/google/inject/servlet/ServletDefinitionPathsTest.java
Patch:
@@ -94,7 +94,7 @@ protected void service(HttpServletRequest servletRequest,
     replay(injector, binding, request);
 
     ServletDefinition servletDefinition = new ServletDefinition(mapping, Key.get(HttpServlet.class),
-        UriPatternType.get(UriPatternType.SERVLET, mapping), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.SERVLET, mapping), new HashMap<String, String>(), null);
 
     servletDefinition.init(null, injector,
         Sets.newSetFromMap(Maps.<HttpServlet, Boolean>newIdentityHashMap()));
@@ -187,7 +187,7 @@ protected void service(HttpServletRequest servletRequest,
     replay(injector, binding, request);
 
     ServletDefinition servletDefinition = new ServletDefinition(mapping, Key.get(HttpServlet.class),
-        UriPatternType.get(UriPatternType.SERVLET, mapping), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.SERVLET, mapping), new HashMap<String, String>(), null);
 
     servletDefinition.init(null, injector,
         Sets.newSetFromMap(Maps.<HttpServlet, Boolean>newIdentityHashMap()));
@@ -283,7 +283,7 @@ protected void service(HttpServletRequest servletRequest,
     replay(injector, binding, request);
 
     ServletDefinition servletDefinition = new ServletDefinition(mapping, Key.get(HttpServlet.class),
-        UriPatternType.get(UriPatternType.REGEX, mapping), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.REGEX, mapping), new HashMap<String, String>(), null);
 
     servletDefinition.init(null, injector,
         Sets.newSetFromMap(Maps.<HttpServlet, Boolean>newIdentityHashMap()));

File: extensions/servlet/test/com/google/inject/servlet/ServletDefinitionTest.java
Patch:
@@ -73,7 +73,7 @@ public final void testServletInitAndConfig() throws ServletException {
 
     String pattern = "/*";
     final ServletDefinition servletDefinition = new ServletDefinition(pattern,
-        Key.get(HttpServlet.class), UriPatternType.get(UriPatternType.SERVLET, pattern), initParams);
+        Key.get(HttpServlet.class), UriPatternType.get(UriPatternType.SERVLET, pattern), initParams, null);
 
     ServletContext servletContext = createMock(ServletContext.class);
     final String contextName = "thing__!@@44__SRV" + getClass();

File: extensions/persist/src/com/google/inject/persist/finder/NumResults.java
Patch:
@@ -22,9 +22,9 @@
 import java.lang.annotation.Target;
 
 /**
- * Annotate any dynamic finder method's integer argument with this to pass in the maximum
- * size of returned results. Used for paging result lists.
- * Complement of {@linkplain com.google.inject.persist.finder.FirstResult}
+ * Annotate any dynamic finder method's integer argument with this to pass in
+ * the maximum size of returned result window. Usefule for paging result sets.
+ * Complement of {@link FirstResult}.
  *
  * @author Dhanji R. Prasanna (dhanji@gmail.com)
  */

File: extensions/persist/test/com/google/inject/persist/EdslTest.java
Patch:
@@ -17,7 +17,7 @@ protected void configurePersistence() {
           workAcross(UnitOfWork.REQUEST).usingJpa("myunit");
         }
 
-      }).stage(Stage.TOOL)
+      }).stage(Stage.PRODUCTION)
         .requireExplicitBindings()
         .build();
   }

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerPerRequestProvisionTest.java
Patch:
@@ -109,11 +109,11 @@ public JpaDao(EntityManager em) {
 
     @Transactional
     public <T> void persist(T t) {
-      assert em.isOpen() : "em is not open!";
-      assert em.getTransaction().isActive() : "no active txn!";
+      assertTrue("em is not open!", em.isOpen());
+      assertTrue("no active txn!", em.getTransaction().isActive());
       em.persist(t);
 
-      assert em.contains(t) : "Persisting object failed";
+      assertTrue("Persisting object failed", em.contains(t));
     }
 
     @Transactional

File: extensions/persist/test/com/google/inject/persist/jpa/EntityManagerProvisionTest.java
Patch:
@@ -101,11 +101,11 @@ public JpaDao(EntityManager em) {
 
     @Transactional
     public <T> void persist(T t) {
-      assert em.isOpen() : "em is not open!";
-      assert em.getTransaction().isActive() : "no active txn!";
+      assertTrue("em is not open!", em.isOpen());
+      assertTrue("no active txn!", em.getTransaction().isActive());
       em.persist(t);
 
-      assert em.contains(t) : "Persisting object failed";
+      assertTrue("Persisting object failed", em.contains(t));
     }
 
     @Transactional

File: src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -105,7 +105,7 @@ public T get() {
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);
     } catch (InvocationTargetException e) {
-      throw new RuntimeException(e);
+      throw Exceptions.throwCleanly(e);
     }
   }
 

File: servlet/test/com/google/inject/servlet/FilterPipelineTest.java
Patch:
@@ -112,7 +112,7 @@ public void init(FilterConfig filterConfig) throws ServletException {
 
     public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
         FilterChain filterChain) throws IOException, ServletException {
-      assert false : "This filter should never have fired";
+      fail("This filter should never have fired");
     }
 
     public void destroy() {

File: servlet/test/com/google/inject/servlet/InjectedFilterPipelineTest.java
Patch:
@@ -159,7 +159,7 @@ public void init(FilterConfig filterConfig) throws ServletException {
 
     public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
         FilterChain filterChain) throws IOException, ServletException {
-      assert false : "This filter should never have fired";
+    	fail("This filter should never have fired");
     }
 
     public void destroy() {

File: servlet/test/com/google/inject/servlet/MultiModuleDispatchIntegrationTest.java
Patch:
@@ -83,9 +83,10 @@ protected void configureServlets() {
 
     verify(requestMock);
 
-    assert inits == 5 && doFilters == 3 && destroys == 5 : "lifecycle states did not"
+    assertTrue("lifecycle states did not"
           + " fire correct number of times-- inits: " + inits + "; dos: " + doFilters
-          + "; destroys: " + destroys;
+          + "; destroys: " + destroys,
+    		inits == 1 && doFilters == 3 && destroys == 1);
   }
 
   @Singleton

File: servlet/test/com/google/inject/servlet/ServletDefinitionTest.java
Patch:
@@ -34,6 +34,7 @@
 import static org.easymock.EasyMock.expect;
 import static org.easymock.EasyMock.replay;
 import static org.easymock.EasyMock.anyObject;
+import static org.easymock.EasyMock.verify;
 
 /**
  * Basic unit test for lifecycle of a ServletDefinition (wrapper).
@@ -96,5 +97,7 @@ public final void testServletInitAndConfig() throws ServletException {
       assertTrue(initParams.containsKey(name));
       assertEquals(initParams.get(name), servletConfig.getInitParameter(name));
     }
+    
+    verify(injector, binding, servletContext);
   }
 }

File: src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -540,8 +540,10 @@ private void removeFailedJitBinding(Key<?> key, InjectionPoint ip) {
   private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) {
     if(binding instanceof ConstructorBindingImpl) {
       return ((ConstructorBindingImpl)binding).getInternalDependencies();
-    } else {
+    } else if(binding instanceof HasDependencies) {
       return ((HasDependencies)binding).getDependencies();
+    } else {
+      return ImmutableSet.of();
     }
   }
 

File: src/com/google/inject/internal/ExposedBindingImpl.java
Patch:
@@ -58,4 +58,7 @@ public PrivateElements getPrivateElements() {
   public void applyTo(Binder binder) {
     throw new UnsupportedOperationException("This element represents a synthetic binding.");
   }
+  
+  // Purposely does not override equals/hashcode, because exposed bindings are only equal to
+  // themselves right now -- that is, there cannot be "duplicate" exposed bindings.
 }

File: src/com/google/inject/util/Modules.java
Patch:
@@ -35,6 +35,7 @@
 import com.google.inject.spi.PrivateElements;
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -139,7 +140,8 @@ public Module with(final Iterable<? extends Module> overrides) {
       return new AbstractModule() {
         @Override
         public void configure() {
-          final List<Element> elements = Elements.getElements(baseModules);
+          final LinkedHashSet<Element> elements =
+            new LinkedHashSet<Element>(Elements.getElements(baseModules));
           final List<Element> overrideElements = Elements.getElements(overrides);
 
           final Set<Key<?>> overriddenKeys = Sets.newHashSet();

File: test/com/google/inject/AllTests.java
Patch:
@@ -69,6 +69,7 @@ public static Test suite() {
     suite.addTestSuite(BoundInstanceInjectionTest.class);
     suite.addTestSuite(BoundProviderTest.class);
     suite.addTestSuite(CircularDependencyTest.class);
+    suite.addTestSuite(DuplicateBindingsTest.class);
     // ErrorHandlingTest.class is not a testcase
     suite.addTestSuite(EagerSingletonTest.class);
     suite.addTestSuite(GenericInjectionTest.class);

File: servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -75,9 +75,8 @@ public class GuiceFilter implements Filter {
           + " ServletModule in your web application. While you may "
           + "have more than one injector, you should only configure"
           + " guice-servlet in one of them. (Hint: look for legacy "
-          + "ServetModules or multiple calls to Servlets.configure())."
-          + "You typically see this error if are not using."
-          + GuiceServletContextListener.class.getSimpleName()
+          + "ServetModules). You typically see this error if are not"
+          + " using " + GuiceServletContextListener.class.getSimpleName()
           + " as described in the documentation.";
 
   //VisibleForTesting

File: test/com/google/inject/AllTests.java
Patch:
@@ -54,8 +54,7 @@ public class AllTests {
 
   private static final Set<String> SUPPRESSED_TEST_NAMES = ImmutableSet.of(
       "testUnscopedProviderWorksOutsideOfRequestedScope(" + ScopesTest.class.getName() + ")",
-      "testCannotConvertUnannotatedBindings(" + TypeConversionTest.class.getName() + ")",
-      "testCircularJitBindingsLeaveNoResidue(" + ImplicitBindingTest.class.getName() + ")"
+      "testCannotConvertUnannotatedBindings(" + TypeConversionTest.class.getName() + ")"
   );
 
   public static Test suite() {

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
 import com.google.inject.Module;
+import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 
 import java.lang.annotation.Annotation;
@@ -324,8 +325,8 @@ public <F> Module build(TypeLiteral<F> factoryInterface) {
   public <F> Module build(final Key<F> factoryInterface) {
     return new AbstractModule() {
       @Override protected void configure() {
-        bind(factoryInterface).toProvider(
-            new FactoryProvider2<F>(factoryInterface.getTypeLiteral(), bindings));
+        Provider<F> provider = new FactoryProvider2<F>(factoryInterface.getTypeLiteral(), bindings);  
+        bind(factoryInterface).toProvider(provider);
       }
     };
   }

File: src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -77,8 +77,8 @@ private MoreTypes() {}
   public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) {
     Type type = typeLiteral.getType();
     if (!isFullySpecified(type)) {
-      String message = typeLiteral + " cannot be used as a key; It is not fully specified.";
-      throw new ConfigurationException(ImmutableSet.of(new Message(message)));
+      Errors errors = new Errors().keyNotFullySpecified(typeLiteral);
+      throw new ConfigurationException(errors.getMessages());
     }
 
     if (typeLiteral.getRawType() == javax.inject.Provider.class) {

File: src/com/google/inject/Key.java
Patch:
@@ -349,7 +349,8 @@ static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType
     checkNotNull(annotationType, "annotation type");
     ensureRetainedAtRuntime(annotationType);
     ensureIsBindingAnnotation(annotationType);
-    return new AnnotationTypeStrategy(annotationType, null);
+    return new AnnotationTypeStrategy(Annotations.canonicalizeIfNamed(annotationType), null);
+
   }
 
   private static void ensureRetainedAtRuntime(

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -455,7 +455,7 @@ protected void configure() {
           if(constructor == null) {
             binder.bind(assistedReturnType).to((Key)returnType);
           } else {
-            binder.bind(assistedReturnType).toConstructor((Constructor)constructor);
+            binder.bind(assistedReturnType).toConstructor((Constructor)constructor, (TypeLiteral)returnType.getTypeLiteral());
           }
         }
       }

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 import static com.google.inject.internal.Annotations.getKey;
+import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ImmutableMap;
@@ -365,7 +366,7 @@ public Object[] gatherArgsForConstructor(
 
     @SuppressWarnings("unchecked") // we imprecisely treat the class literal of T as a Class<T>
     Class<F> factoryRawType = (Class) factoryType.getRawType();
-    return factoryRawType.cast(Proxy.newProxyInstance(factoryRawType.getClassLoader(),
+    return factoryRawType.cast(Proxy.newProxyInstance(BytecodeGen.getClassLoader(factoryRawType),
         new Class[] { factoryRawType }, invocationHandler));
   }
 

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.inject.ProvisionException;
 import com.google.inject.TypeLiteral;
 import static com.google.inject.internal.Annotations.getKey;
+import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ImmutableList;
@@ -214,7 +215,7 @@ public String toString() {
       throw new ConfigurationException(e.getErrors().getMessages());
     }
     
-    factory = factoryRawType.cast(Proxy.newProxyInstance(factoryRawType.getClassLoader(),
+    factory = factoryRawType.cast(Proxy.newProxyInstance(BytecodeGen.getClassLoader(factoryRawType),
         new Class[] { factoryRawType }, this));
   }
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -40,7 +40,6 @@
 import com.google.inject.util.NoopOverrideTest;
 import com.google.inject.util.ProvidersTest;
 import com.google.inject.util.TypesTest;
-import com.googlecode.guice.BytecodeGenTest;
 import com.googlecode.guice.Jsr330Test;
 import com.googlecode.guice.GuiceTck;
 import java.util.Enumeration;
@@ -143,11 +142,11 @@ public static Test suite() {
     suite.addTestSuite(IntegrationTest.class);
     suite.addTestSuite(MethodInterceptionTest.class);
     suite.addTestSuite(com.googlecode.guice.BytecodeGenTest.class);
-    suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
     /*end[AOP]*/
 
     // googlecode.guice
-    suite.addTestSuite(BytecodeGenTest.class);
+    suite.addTest(com.googlecode.guice.StrictContainerTestSuite.suite());
+    suite.addTestSuite(com.googlecode.guice.OSGiContainerTest.class);
     suite.addTestSuite(Jsr330Test.class);
 
     return removeSuppressedTests(suite, SUPPRESSED_TEST_NAMES);

File: test/com/google/inject/AllTests.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.inject.internal.Jsr166HashMapTest;
 import com.google.inject.internal.LineNumbersTest;
 import com.google.inject.internal.MapMakerTestSuite;
+import com.google.inject.internal.MoreTypesTest;
 import com.google.inject.internal.ProxyFactoryTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
 import com.google.inject.matcher.MatcherTest;
@@ -107,6 +108,7 @@ public static Test suite() {
     suite.addTestSuite(Jsr166HashMapTest.class);
     suite.addTestSuite(LineNumbersTest.class);
     suite.addTest(MapMakerTestSuite.suite());
+    suite.addTestSuite(MoreTypesTest.class);
     suite.addTestSuite(UniqueAnnotationsTest.class);
 
     // matcher

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -35,6 +35,7 @@
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.Toolable;
 import com.google.inject.util.Types;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -259,7 +260,7 @@ public Multibinder<T> permitDuplicates() {
      * element in this set. At this time the set's size is known, but its
      * contents are only evaluated when get() is invoked.
      */
-    @Inject void initialize(Injector injector) {
+    @Toolable @Inject void initialize(Injector injector) {
       providers = Lists.newArrayList();
       List<Dependency<?>> dependencies = Lists.newArrayList();
       for (Binding<?> entry : injector.findBindingsByType(elementType)) {

File: src/com/google/inject/Key.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.MoreTypes;
+
 import static com.google.inject.internal.Preconditions.checkArgument;
 import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.lang.annotation.Annotation;
@@ -334,11 +335,11 @@ static AnnotationStrategy strategyFor(Annotation annotation) {
     ensureRetainedAtRuntime(annotationType);
     ensureIsBindingAnnotation(annotationType);
 
-    if (annotationType.getDeclaredMethods().length == 0) {
+    if (isMarker(annotationType)) {
       return new AnnotationTypeStrategy(annotationType, annotation);
     }
 
-    return new AnnotationInstanceStrategy(annotation);
+    return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation));
   }
 
   /**

File: test/com/google/inject/AllTests.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.inject.internal.ProxyFactoryTest;
 import com.google.inject.internal.UniqueAnnotationsTest;
 import com.google.inject.matcher.MatcherTest;
+import com.google.inject.name.NamedEquivalanceTest;
 import com.google.inject.name.NamesTest;
 import com.google.inject.spi.BindingTargetVisitorTest;
 import com.google.inject.spi.ElementApplyToTest;
@@ -113,6 +114,7 @@ public static Test suite() {
 
     // names
     suite.addTestSuite(NamesTest.class);
+    suite.addTestSuite(NamedEquivalanceTest.class);
 
     // spi
     suite.addTestSuite(BindingTargetVisitorTest.class);

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -142,7 +142,10 @@
  * @author jmourits@google.com (Jerome Mourits)
  * @author jessewilson@google.com (Jesse Wilson)
  * @author dtm@google.com (Daniel Martin)
+ * 
+ * @deprecated use {@link FactoryModuleBuilder} instead.
  */
+@Deprecated
 public class FactoryProvider<F> implements Provider<F>, HasDependencies {
 
   /*

File: src/com/google/inject/internal/InternalInjectorCreator.java
Patch:
@@ -265,6 +265,9 @@ public <T> Binding<T> getBinding(Key<T> key) {
     public <T> Binding<T> getBinding(Class<T> type) {
       return this.delegateInjector.getBinding(type);
     }
+    public <T> Binding<T> getExistingBinding(Key<T> key) {
+      return this.delegateInjector.getExistingBinding(key);
+    }
     public <T> List<Binding<T>> findBindingsByType(TypeLiteral<T> type) {
       return this.delegateInjector.findBindingsByType(type);
     }

File: test/com/google/inject/AllTests.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.inject.spi.ElementsTest;
 import com.google.inject.spi.HasDependenciesTest;
 import com.google.inject.spi.InjectionPointTest;
+import com.google.inject.spi.InjectorSpiTest;
 import com.google.inject.spi.ModuleRewriterTest;
 import com.google.inject.spi.ProviderMethodsTest;
 import com.google.inject.spi.SpiBindingsTest;
@@ -119,6 +120,7 @@ public static Test suite() {
     suite.addTestSuite(ElementApplyToTest.class);
     suite.addTestSuite(HasDependenciesTest.class);
     suite.addTestSuite(InjectionPointTest.class);
+    suite.addTestSuite(InjectorSpiTest.class);
     suite.addTestSuite(ModuleRewriterTest.class);
     suite.addTestSuite(ProviderMethodsTest.class);
     suite.addTestSuite(SpiBindingsTest.class);

File: src/com/google/inject/Binder.java
Patch:
@@ -310,7 +310,7 @@ void bindInterceptor(Matcher<? super Class<?>> classMatcher,
 
   /**
    * Returns the provider used to obtain instances for the given injection key.
-   * The returned will not be valid until the {@link Injector} has been
+   * The returned provider will not be valid until the {@link Injector} has been
    * created. The provider will throw an {@code IllegalStateException} if you
    * try to use it beforehand.
    *

File: src/com/google/inject/spi/TypeConverterBinding.java
Patch:
@@ -26,7 +26,7 @@
  * explicitly in a module using {@link com.google.inject.Binder#convertToTypes(Matcher,
  * TypeConverter) convertToTypes()} statements:
  * <pre>
- *     convertToTypes(Matchers.only(DateTime.class), new DateTimeConverter());</pre>
+ *     convertToTypes(Matchers.only(TypeLiteral.get(DateTime.class)), new DateTimeConverter());</pre>
  *
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: src/com/google/inject/Scopes.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.annotation.Annotation;
 
 import com.google.inject.internal.CircularDependencyProxy;
-import com.google.inject.internal.InjectorBuilderImpl;
+import com.google.inject.internal.InternalInjectorCreator;
 import com.google.inject.internal.LinkedBindingImpl;
 import com.google.inject.spi.BindingScopingVisitor;
 
@@ -59,7 +59,7 @@ public T get() {
              *
              * This block is re-entrant for circular dependencies.
              */
-            synchronized (InjectorBuilderImpl.class) {
+            synchronized (InternalInjectorCreator.class) {
               if (instance == null) {
                 T provided = creator.get();
 

File: src/com/google/inject/internal/Initializer.java
Patch:
@@ -142,7 +142,7 @@ public T get(Errors errors) throws ErrorsException {
       if (pendingInjection.remove(instance) != null) {
         // if in Stage.TOOL, we only want to inject & notify toolable injection points.
         // (otherwise we'll inject all of them)
-        membersInjector.injectAndNotify(instance, errors.withSource(source), injector.stage == Stage.TOOL);
+        membersInjector.injectAndNotify(instance, errors.withSource(source), injector.options.stage == Stage.TOOL);
       }
 
       return instance;

File: src/com/google/inject/internal/InjectionRequestProcessor.java
Patch:
@@ -110,7 +110,7 @@ public Void call(InternalContext context) {
             for (SingleMemberInjector memberInjector : memberInjectors) {
               // Run injections if we're not in tool stage (ie, PRODUCTION or DEV),
               // or if we are in tool stage and the injection point is toolable.
-              if(injector.stage != Stage.TOOL || memberInjector.getInjectionPoint().isToolable()) {
+              if(injector.options.stage != Stage.TOOL || memberInjector.getInjectionPoint().isToolable()) {
                 memberInjector.inject(errors, context, null);
               }
             }

File: src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -88,7 +88,7 @@ final class BindingProcessor extends AbstractProcessor {
       public Void visit(ConstructorBinding<? extends T> binding) {
         try {
           ConstructorBindingImpl<T> onInjector = ConstructorBindingImpl.create(injector, key, 
-              binding.getConstructor(), source, scoping, errors);
+              binding.getConstructor(), source, scoping, errors, false);
           scheduleInitialization(onInjector);
           putBinding(onInjector);
         } catch (ErrorsException e) {
@@ -165,7 +165,7 @@ public Void visit(UntargettedBinding<? extends T> untargetted) {
         // This cast is safe after the preceeding check.
         try {
           BindingImpl<T> binding = injector.createUninitializedBinding(
-              key, scoping, source, errors);
+              key, scoping, source, errors, false);
           scheduleInitialization(binding);
           putBinding(binding);
         } catch (ErrorsException e) {

File: src/com/google/inject/internal/ConstantFactory.java
Patch:
@@ -29,7 +29,7 @@ public ConstantFactory(Initializable<T> initializable) {
     this.initializable = initializable;
   }
 
-  public T get(Errors errors, InternalContext context, Dependency dependency)
+  public T get(Errors errors, InternalContext context, Dependency dependency, boolean linked)
       throws ErrorsException {
     return initializable.get(errors);
   }

File: src/com/google/inject/internal/ExposedKeyFactory.java
Patch:
@@ -49,8 +49,8 @@ public void notify(Errors errors) {
     this.delegate = explicitBinding;
   }
 
-  public T get(Errors errors, InternalContext context, Dependency<?> dependency)
+  public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
-    return delegate.getInternalFactory().get(errors, context, dependency);
+    return delegate.getInternalFactory().get(errors, context, dependency, linked);
   }
 }

File: src/com/google/inject/internal/InternalFactory.java
Patch:
@@ -27,11 +27,12 @@ interface InternalFactory<T> {
 
   /**
    * Creates an object to be injected.
-   *
    * @param context of this injection
+   * @param linked true if getting as a result of a linked binding
+   *
    * @throws com.google.inject.internal.ErrorsException if a value cannot be provided
    * @return instance to be injected
    */
-  T get(Errors errors, InternalContext context, Dependency<?> dependency)
+  T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException;
 }

File: src/com/google/inject/internal/InternalFactoryToProviderAdapter.java
Patch:
@@ -34,7 +34,7 @@ public InternalFactoryToProviderAdapter(
     this.source = checkNotNull(source, "source");
   }
 
-  public T get(Errors errors, InternalContext context, Dependency<?> dependency)
+  public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked)
       throws ErrorsException {
     try {
       return errors.checkForNull(initializable.get(errors).get(), source, dependency);

File: src/com/google/inject/internal/ProviderToInternalFactoryAdapter.java
Patch:
@@ -40,7 +40,7 @@ public T get() {
       T t = injector.callInContext(new ContextualCallable<T>() {
         public T call(InternalContext context) throws ErrorsException {
           Dependency dependency = context.getDependency();
-          return internalFactory.get(errors, context, dependency);
+          return internalFactory.get(errors, context, dependency, false);
         }
       });
       errors.throwIfNewErrors(0);

File: src/com/google/inject/internal/SingleFieldInjector.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject.internal;
 
+import com.google.inject.internal.InjectorImpl.JitLimitation;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.Field;
@@ -37,7 +38,7 @@ public SingleFieldInjector(InjectorImpl injector, InjectionPoint injectionPoint,
 
     // Ewwwww...
     field.setAccessible(true);
-    factory = injector.getInternalFactory(dependency.getKey(), errors);
+    factory = injector.getInternalFactory(dependency.getKey(), errors, JitLimitation.NO_JIT);
   }
 
   public InjectionPoint getInjectionPoint() {
@@ -49,7 +50,7 @@ public void inject(Errors errors, InternalContext context, Object o) {
 
     Dependency previous = context.setDependency(dependency);
     try {
-      Object value = factory.get(errors, context, dependency);
+      Object value = factory.get(errors, context, dependency, false);
       field.set(o, value);
     } catch (ErrorsException e) {
       errors.withSource(injectionPoint).merge(e.getErrors());

File: src/com/google/inject/internal/SingleParameterInjector.java
Patch:
@@ -35,7 +35,7 @@ final class SingleParameterInjector<T> {
   private T inject(Errors errors, InternalContext context) throws ErrorsException {
     Dependency previous = context.setDependency(dependency);
     try {
-      return factory.get(errors.withSource(dependency), context, dependency);
+      return factory.get(errors.withSource(dependency), context, dependency, false);
     } finally {
       context.setDependency(previous);
     }

File: src/com/google/inject/internal/UntargettedBindingImpl.java
Patch:
@@ -26,7 +26,7 @@ final class UntargettedBindingImpl<T> extends BindingImpl<T> implements Untarget
 
   UntargettedBindingImpl(InjectorImpl injector, Key<T> key, Object source) {
     super(injector, key, source, new InternalFactory<T>() {
-      public T get(Errors errors, InternalContext context, Dependency<?> dependency) {
+      public T get(Errors errors, InternalContext context, Dependency<?> dependency, boolean linked) {
         throw new AssertionError();
       }
     }, Scoping.UNSCOPED);

File: test/com/google/inject/AllTests.java
Patch:
@@ -74,6 +74,7 @@ public static Test suite() {
     suite.addTestSuite(ImplicitBindingTest.class);
     suite.addTestSuite(TypeListenerTest.class);
     suite.addTestSuite(InjectorTest.class);
+    suite.addTestSuite(JitBindingsTest.class);
     // IntegrationTest is AOP-only
     suite.addTestSuite(KeyTest.class);
     suite.addTestSuite(LoggerInjectionTest.class);

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -36,6 +36,7 @@
 import com.google.inject.internal.Lists;
 import static com.google.inject.internal.Preconditions.checkState;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.Toolable;
 import com.google.inject.util.Providers;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
@@ -157,7 +158,7 @@ private <T> Key<T> assistKey(Method method, Key<T> key, Errors errors) throws Er
    * At injector-creation time, we initialize the invocation handler. At this time we make sure
    * all factory methods will be able to build the target types.
    */
-  @Inject
+  @Inject @Toolable
   void initialize(Injector injector) {
     if (this.injector != null) {
       throw new ConfigurationException(ImmutableList.of(new Message(FactoryProvider2.class,

File: src/com/google/inject/internal/ConstructorInjector.java
Patch:
@@ -86,7 +86,7 @@ Object construct(Errors errors, InternalContext context, Class<?> expectedType)
       // Store reference. If an injector re-enters this factory, they'll get the same reference.
       constructionContext.setCurrentReference(t);
 
-      membersInjector.injectMembers(t, errors, context);
+      membersInjector.injectMembers(t, errors, context, false);
       membersInjector.notifyListeners(t, errors);
 
       return t;

File: src/com/google/inject/internal/InjectorShell.java
Patch:
@@ -107,13 +107,13 @@ Object lock() {
      * returned if any modules contain {@link Binder#newPrivateBinder private environments}. The
      * primary injector will be first in the returned list.
      */
-    List<InjectorShell> build(Initializer initializer, BindingProcessor bindingProcessor,
+    List<InjectorShell> build(BindingProcessor bindingProcessor,
         Stopwatch stopwatch, Errors errors) {
       checkState(stage != null, "Stage not initialized");
       checkState(privateElements == null || parent != null, "PrivateElements with no parent");
       checkState(state != null, "no state. Did you remember to lock() ?");
 
-      InjectorImpl injector = new InjectorImpl(parent, state, initializer);
+      InjectorImpl injector = new InjectorImpl(parent, state, stage);
       if (privateElements != null) {
         privateElements.initInjector(injector);
       }
@@ -158,7 +158,7 @@ List<InjectorShell> build(Initializer initializer, BindingProcessor bindingProce
       PrivateElementProcessor processor = new PrivateElementProcessor(errors, stage);
       processor.process(injector, elements);
       for (Builder builder : processor.getInjectorShellBuilders()) {
-        injectorShells.addAll(builder.build(initializer, bindingProcessor, stopwatch, errors));
+        injectorShells.addAll(builder.build(bindingProcessor, stopwatch, errors));
       }
       stopwatch.resetAndLog("Private environment creation");
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -33,6 +33,7 @@
 import com.google.inject.spi.ModuleRewriterTest;
 import com.google.inject.spi.ProviderMethodsTest;
 import com.google.inject.spi.SpiBindingsTest;
+import com.google.inject.spi.ToolStageInjectorTest;
 import com.google.inject.util.NoopOverrideTest;
 import com.google.inject.util.ProvidersTest;
 import com.google.inject.util.TypesTest;
@@ -120,6 +121,7 @@ public static Test suite() {
     suite.addTestSuite(ModuleRewriterTest.class);
     suite.addTestSuite(ProviderMethodsTest.class);
     suite.addTestSuite(SpiBindingsTest.class);
+    suite.addTestSuite(ToolStageInjectorTest.class);
 
     // tools
     // suite.addTestSuite(JmxTest.class); not a testcase

File: extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java
Patch:
@@ -94,7 +94,7 @@ public Object getValue(Injector injector) {
       }
     }
 
-    return provider.get();
+    return isProvider ? provider : provider.get();
   }
 
   public boolean isBound(Injector injector) {

File: servlet/src/com/google/inject/servlet/ManagedServletPipeline.java
Patch:
@@ -173,8 +173,9 @@ public void include(ServletRequest servletRequest, ServletResponse servletRespon
   /**
    * A Marker constant attribute that when present in the request indicates to Guice servlet that
    * this request has been generated by a request dispatcher rather than the servlet pipeline.
+   * In accordance with section 8.4.2 of the Servlet 2.4 specification.
    */
-  public static final String REQUEST_DISPATCHER_REQUEST = "$$Guice$RDR";
+  public static final String REQUEST_DISPATCHER_REQUEST = "javax.servlet.forward.servlet_path";
 
   private static class RequestDispatcherRequestWrapper extends HttpServletRequestWrapper {
     private final String newRequestUri;

File: servlet/src/com/google/inject/servlet/UriPatternType.java
Patch:
@@ -94,7 +94,7 @@ public String extractPath(String path) {
   }
 
   /**
-   * Matchers URIs using a regular expression.
+   * Matches URIs using a regular expression.
    *
    * @author dhanji@gmail.com (Dhanji R. Prasanna)
    */

File: src/com/google/inject/Injector.java
Patch:
@@ -227,7 +227,7 @@ public interface Injector {
   /**
    * Returns a map containing all scopes in the injector. The maps keys are scoping annotations
    * like {@code Singleton.class}, and the values are scope instances, such as {@code
-   * Scopes.SINGLETON. The returned map is immutable.
+   * Scopes.SINGLETON}. The returned map is immutable.
    *
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    */

File: src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.inject.spi.Message;
 import com.google.inject.util.Types;
 import java.io.Serializable;
+import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
@@ -165,8 +166,8 @@ public static Class<?> getRawType(Type type) {
       return (Class<?>) rawType;
 
     } else if (type instanceof GenericArrayType) {
-      // TODO: Is this sufficient?
-      return Object[].class;
+      Type componentType = ((GenericArrayType)type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
 
     } else if (type instanceof TypeVariable) {
       // we could use the variable's bounds, but that'll won't work if there are multiple.

File: test/com/google/inject/AllTests.java
Patch:
@@ -51,7 +51,8 @@ public class AllTests {
 
   private static final Set<String> SUPPRESSED_TEST_NAMES = ImmutableSet.of(
       "testUnscopedProviderWorksOutsideOfRequestedScope(" + ScopesTest.class.getName() + ")",
-      "testCannotConvertUnannotatedBindings(" + TypeConversionTest.class.getName() + ")"
+      "testCannotConvertUnannotatedBindings(" + TypeConversionTest.class.getName() + ")",
+      "testCircularJitBindingsLeaveNoResidue(" + ImplicitBindingTest.class.getName() + ")"
   );
 
   public static Test suite() {

File: test/com/google/inject/AllTests.java
Patch:
@@ -50,7 +50,6 @@
 public class AllTests {
 
   private static final Set<String> SUPPRESSED_TEST_NAMES = ImmutableSet.of(
-      "testCircularlyDependentMultipleWays(" + CircularDependencyTest.class.getName() + ")",
       "testUnscopedProviderWorksOutsideOfRequestedScope(" + ScopesTest.class.getName() + ")",
       "testNullScopedAsASingleton(" + ScopesTest.class.getName() + ")",
       "testCannotConvertUnannotatedBindings(" + TypeConversionTest.class.getName() + ")"

File: src/com/google/inject/binder/LinkedBindingBuilder.java
Patch:
@@ -61,19 +61,19 @@ public interface LinkedBindingBuilder<T> extends ScopedBindingBuilder {
    * See the EDSL examples at {@link com.google.inject.Binder}.
    */
   ScopedBindingBuilder toProvider(
-      Class<? extends Provider<? extends T>> providerType);
+      Class<? extends javax.inject.Provider<? extends T>> providerType);
 
   /**
    * See the EDSL examples at {@link com.google.inject.Binder}.
    */
   ScopedBindingBuilder toProvider(
-      TypeLiteral<? extends Provider<? extends T>> providerType);
+      TypeLiteral<? extends javax.inject.Provider<? extends T>> providerType);
 
   /**
    * See the EDSL examples at {@link com.google.inject.Binder}.
    */
   ScopedBindingBuilder toProvider(
-      Key<? extends Provider<? extends T>> providerKey);
+      Key<? extends javax.inject.Provider<? extends T>> providerKey);
 
   /**
    * See the EDSL examples at {@link com.google.inject.Binder}.

File: src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -125,7 +125,7 @@ public Void visit(ProviderInstanceBinding<? extends T> binding) {
       }
 
       public Void visit(ProviderKeyBinding<? extends T> binding) {
-        Key<? extends Provider<? extends T>> providerKey = binding.getProviderKey();
+        Key<? extends javax.inject.Provider<? extends T>> providerKey = binding.getProviderKey();
         BoundProviderFactory<T> boundProviderFactory
             = new BoundProviderFactory<T>(injector, providerKey, source);
         creationListeners.add(boundProviderFactory);

File: src/com/google/inject/spi/ProviderKeyBinding.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.inject.Binding;
 import com.google.inject.Key;
-import com.google.inject.Provider;
 
 /**
  * A binding to a provider key. To resolve injections, the provider key is first resolved, then that
@@ -34,6 +33,6 @@ public interface ProviderKeyBinding<T> extends Binding<T> {
    * injector using {@link com.google.inject.Injector#getBinding(Key)
    * Injector.getBinding(providerKey)}
    */
-  Key<? extends Provider<? extends T>> getProviderKey();
+  Key<? extends javax.inject.Provider<? extends T>> getProviderKey();
 
 }
\ No newline at end of file

File: src/com/google/inject/Provider.java
Patch:
@@ -42,7 +42,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public interface Provider<T> {
+public interface Provider<T> extends javax.inject.Provider<T> {
 
   /**
    * Provides an instance of {@code T}. Must never return {@code null}.

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java
Patch:
@@ -123,7 +123,7 @@
  * }
  * ...
  * protected void configure() {
- *   install(new FactoryModuleBuilder().build(FruitFacory.class));
+ *   install(new FactoryModuleBuilder().build(FruitFactory.class));
  * }</pre>
  *
  * Note that any type returned by the factory in this manner needs to be an implementation class

File: extensions/assistedinject/src/com/google/inject/assistedinject/BindingCollector.java
Patch:
@@ -18,13 +18,14 @@
 import com.google.inject.ConfigurationException;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.Maps;
 import com.google.inject.spi.Message;
 import java.util.Collections;
 import java.util.Map;
 
 /**
- * Utility class for collecting factory bindings.  Used for configuring {@link FactoryProvider2}.
+ * Utility class for collecting factory bindings. Used for configuring {@link FactoryProvider2}.
  *
  * @author schmitt@google.com (Peter Schmitt)
  */
@@ -34,7 +35,7 @@ class BindingCollector {
 
   public BindingCollector addBinding(Key<?> key, TypeLiteral<?> target) {
     if (bindings.containsKey(key)) {
-      throw new ConfigurationException(Collections.singleton(
+      throw new ConfigurationException(ImmutableSet.of(
           new Message("Only one implementation can be specified for " + key)));
     }
 

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java
Patch:
@@ -50,6 +50,7 @@
  *
  * @author jessewilson@google.com (Jesse Wilson)
  * @author dtm@google.com (Daniel Martin)
+ * @author schmitt@google.com (Peter Schmitt)
  */
 final class FactoryProvider2<F> implements InvocationHandler, Provider<F> {
 

File: src/com/google/inject/internal/ConstructorBindingImpl.java
Patch:
@@ -102,7 +102,7 @@ static <T> ConstructorBindingImpl<T> create(InjectorImpl injector, Key<T> key,
 
     Factory<T> factoryFactory = new Factory<T>();
     InternalFactory<? extends T> scopedFactory
-        = Scoping.scope(key, injector, factoryFactory, scoping);
+        = Scoping.scope(key, injector, factoryFactory, source, scoping);
 
     return new ConstructorBindingImpl<T>(
         injector, key, source, scopedFactory, scoping, factoryFactory, constructorInjector);

File: src/com/google/inject/internal/Scoping.java
Patch:
@@ -211,7 +211,7 @@ private Scoping() {}
 
   /** Scopes an internal factory. */
   static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector,
-      InternalFactory<? extends T> creator, Scoping scoping) {
+      InternalFactory<? extends T> creator, Object source, Scoping scoping) {
 
     if (scoping.isNoScope()) {
       return creator;
@@ -222,7 +222,7 @@ static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector,
     Provider<T> scoped
         = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));
     return new InternalFactoryToProviderAdapter<T>(
-        Initializables.<Provider<? extends T>>of(scoped));
+        Initializables.<Provider<? extends T>>of(scoped), source);
   }
 
   /**

File: test/com/google/inject/NullableInjectionPointTest.java
Patch:
@@ -156,8 +156,8 @@ public Foo get() {
 
     try {
       injector.getInstance(FooField.class);
-    }
-    catch(ProvisionException expected) {
+      fail();
+    } catch(ProvisionException expected) {
       assertContains(expected.getMessage(), "null returned by binding "
           + "at com.google.inject.NullableInjectionPointTest");
     }

File: src/com/google/inject/internal/InjectorBuilder.java
Patch:
@@ -245,6 +245,9 @@ public void injectMembers(Object o) {
     public Map<Key<?>, Binding<?>> getBindings() {
       return this.delegateInjector.getBindings();
     }
+    public Map<Key<?>, Binding<?>> getAllBindings() {
+      return this.delegateInjector.getAllBindings();
+    }
     public <T> Binding<T> getBinding(Key<T> key) {
       return this.delegateInjector.getBinding(key);
     }

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -331,7 +331,7 @@ public Set<Dependency<?>> getDependencies() {
 
   /**
    * We install the permit duplicates configuration as its own binding, all by itself. This way,
-   * if only half of a multibinder user's remember to call permitDuplicates(), they're still
+   * if only one of a multibinder's users remember to call permitDuplicates(), they're still
    * permitted.
    */
   private static class PermitDuplicatesModule extends AbstractModule {

File: servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -17,8 +17,8 @@
 
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.Scopes;
 import com.google.inject.internal.Iterators;
-import static com.google.inject.servlet.ServletScopes.isSingletonBinding;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Enumeration;
@@ -63,7 +63,7 @@ public void init(final ServletContext servletContext, Injector injector,
       Set<Filter> initializedSoFar) throws ServletException {
 
     // This absolutely must be a singleton, and so is only initialized once.
-    if (!isSingletonBinding(injector.getBinding(filterKey))) {
+    if (!Scopes.isSingleton(injector.getBinding(filterKey))) {
       throw new ServletException("Filters must be bound as singletons. "
         + filterKey + " was not bound in singleton scope.");
     }

File: servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -17,8 +17,8 @@
 
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.Scopes;
 import com.google.inject.internal.Iterators;
-import static com.google.inject.servlet.ServletScopes.isSingletonBinding;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Enumeration;
@@ -66,7 +66,7 @@ public void init(final ServletContext servletContext, Injector injector,
       Set<HttpServlet> initializedSoFar) throws ServletException {
 
     // This absolutely must be a singleton, and so is only initialized once.
-    if (!isSingletonBinding(injector.getBinding(servletKey))) {
+    if (!Scopes.isSingleton(injector.getBinding(servletKey))) {
       throw new ServletException("Servlets must be bound as singletons. "
         + servletKey + " was not bound in singleton scope.");
     }

File: src/com/google/inject/internal/LinkedBindingImpl.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.LinkedKeyBinding;
 
-final class LinkedBindingImpl<T> extends BindingImpl<T> implements LinkedKeyBinding<T> {
+public final class LinkedBindingImpl<T> extends BindingImpl<T> implements LinkedKeyBinding<T> {
 
   final Key<? extends T> targetKey;
 

File: src/com/google/inject/internal/InjectorBuilder.java
Patch:
@@ -195,14 +195,14 @@ void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors
           injector.callInContext(new ContextualCallable<Void>() {
             Dependency<?> dependency = Dependency.get(binding.getKey());
             public Void call(InternalContext context) {
-              context.setDependency(dependency);
+              Dependency previous = context.setDependency(dependency);
               Errors errorsForBinding = errors.withSource(dependency);
               try {
                 binding.getInternalFactory().get(errorsForBinding, context, dependency);
               } catch (ErrorsException e) {
                 errorsForBinding.merge(e.getErrors());
               } finally {
-                context.setDependency(null);
+                context.setDependency(previous);
               }
 
               return null;

File: src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -727,11 +727,11 @@ public T get() {
         try {
           T t = callInContext(new ContextualCallable<T>() {
             public T call(InternalContext context) throws ErrorsException {
-              context.setDependency(dependency);
+              Dependency previous = context.setDependency(dependency);
               try {
                 return factory.get(errors, context, dependency);
               } finally {
-                context.setDependency(null);
+                context.setDependency(previous);
               }
             }
           });

File: src/com/google/inject/internal/InternalContext.java
Patch:
@@ -45,7 +45,9 @@ public Dependency getDependency() {
     return dependency;
   }
 
-  public void setDependency(Dependency dependency) {
+  public Dependency setDependency(Dependency dependency) {
+    Dependency previous = dependency;
     this.dependency = dependency;
+    return previous;
   }
 }

File: src/com/google/inject/internal/SingleFieldInjector.java
Patch:
@@ -47,7 +47,7 @@ public InjectionPoint getInjectionPoint() {
   public void inject(Errors errors, InternalContext context, Object o) {
     errors = errors.withSource(dependency);
 
-    context.setDependency(dependency);
+    Dependency previous = context.setDependency(dependency);
     try {
       Object value = factory.get(errors, context, dependency);
       field.set(o, value);
@@ -56,7 +56,7 @@ public void inject(Errors errors, InternalContext context, Object o) {
     } catch (IllegalAccessException e) {
       throw new AssertionError(e); // a security manager is blocking us, we're hosed
     } finally {
-      context.setDependency(null);
+      context.setDependency(previous);
     }
   }
 }

File: src/com/google/inject/internal/SingleParameterInjector.java
Patch:
@@ -33,11 +33,11 @@ final class SingleParameterInjector<T> {
   }
 
   private T inject(Errors errors, InternalContext context) throws ErrorsException {
-    context.setDependency(dependency);
+    Dependency previous = context.setDependency(dependency);
     try {
       return factory.get(errors.withSource(dependency), context, dependency);
     } finally {
-      context.setDependency(null);
+      context.setDependency(previous);
     }
   }
 

File: src/com/google/inject/spi/Dependency.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.Lists;
 import com.google.inject.internal.Objects;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.util.List;
 import java.util.Set;
 
@@ -39,10 +40,9 @@ public final class Dependency<T> {
   private final boolean nullable;
   private final int parameterIndex;
 
-  Dependency(InjectionPoint injectionPoint, Key<T> key,
-      boolean nullable, int parameterIndex) {
+  Dependency(InjectionPoint injectionPoint, Key<T> key, boolean nullable, int parameterIndex) {
     this.injectionPoint = injectionPoint;
-    this.key = key;
+    this.key = checkNotNull(key, "key");
     this.nullable = nullable;
     this.parameterIndex = parameterIndex;
   }

File: src/com/google/inject/internal/BindingProcessor.java
Patch:
@@ -161,7 +161,8 @@ public Void visit(UntargettedBinding<? extends T> untargetted) {
 
         // This cast is safe after the preceeding check.
         try {
-          BindingImpl<T> binding = injector.createUnitializedBinding(key, scoping, source, errors);
+          BindingImpl<T> binding = injector.createUninitializedBinding(
+              key, scoping, source, errors);
           scheduleInitialization(binding);
           putBinding(binding);
         } catch (ErrorsException e) {

File: src/com/google/inject/internal/InjectorImpl.java
Patch:
@@ -378,7 +378,7 @@ <T> void initializeBinding(BindingImpl<T> binding, Errors errors) throws ErrorsE
    * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if
    * none is specified.
    */
-  <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source,
+  <T> BindingImpl<T> createUninitializedBinding(Key<T> key, Scoping scoping, Object source,
       Errors errors) throws ErrorsException {
     Class<?> rawType = key.getTypeLiteral().getRawType();
 
@@ -614,7 +614,7 @@ private <T> BindingImpl<T> createJustInTimeBinding(Key<T> key, Errors errors)
     }
 
     Object source = key.getTypeLiteral().getRawType();
-    BindingImpl<T> binding = createUnitializedBinding(key, Scoping.UNSCOPED, source, errors);
+    BindingImpl<T> binding = createUninitializedBinding(key, Scoping.UNSCOPED, source, errors);
     errors.throwIfNewErrors(numErrorsBefore);
     initializeBinding(binding, errors);
     return binding;

File: src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -164,11 +164,12 @@ public TypeLiteral<?> getDeclaringType() {
 
   @Override public boolean equals(Object o) {
     return o instanceof InjectionPoint
-        && member.equals(((InjectionPoint) o).member);
+        && member.equals(((InjectionPoint) o).member)
+        && declaringType.equals(((InjectionPoint) o).declaringType);
   }
 
   @Override public int hashCode() {
-    return member.hashCode();
+    return member.hashCode() ^ declaringType.hashCode();
   }
 
   @Override public String toString() {

File: servlet/src/com/google/inject/servlet/GuiceFilter.java
Patch:
@@ -77,7 +77,7 @@ static void setPipeline(FilterPipeline pipeline, Stage stage) {
 
     // Multiple injectors with Servlet pipelines?!
     // We don't throw an exception in DEVELOPMENT stage, to allow for legacy
-    // tests that don't have a tearDown that calls GuiceFilter#reset().
+    // tests that don't have a tearDown that calls GuiceFilter#destroy().
     if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {
       if (Stage.PRODUCTION.equals(stage)) {
         throw new RuntimeException(MULTIPLE_INJECTORS_ERROR);

File: src/com/google/inject/Guice.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject;
 
 import java.util.Arrays;
+import com.google.inject.internal.InjectorBuilder;
 
 /**
  * The entry point to the Guice framework. Creates {@link Injector}s from

File: src/com/google/inject/TypeLiteral.java
Patch:
@@ -291,7 +291,7 @@ public List<TypeLiteral<?>> getParameterTypes(Member methodOrConstructor) {
       genericParameterTypes = method.getGenericParameterTypes();
 
     } else if (methodOrConstructor instanceof Constructor) {
-      Constructor constructor = (Constructor) methodOrConstructor;
+      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;
       checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType),
           "%s does not construct a supertype of %s", constructor, type);
       genericParameterTypes = constructor.getGenericParameterTypes();

File: src/com/google/inject/internal/AbstractProcessor.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
-import com.google.inject.internal.Errors;
+import com.google.inject.Binding;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.ElementVisitor;
 import com.google.inject.spi.InjectionRequest;
@@ -88,7 +88,7 @@ public Boolean visit(ScopeBinding scopeBinding) {
     return false;
   }
 
-  public Boolean visit(InjectionRequest injectionRequest) {
+  public Boolean visit(InjectionRequest<?> injectionRequest) {
     return false;
   }
 

File: src/com/google/inject/internal/BytecodeGen.java
Patch:
@@ -55,7 +55,7 @@
  * @author mcculls@gmail.com (Stuart McCulloch)
  * @author jessewilson@google.com (Jesse Wilson)
  */
-public final class BytecodeGen {
+final class BytecodeGen {
 
   private static final Logger logger = Logger.getLogger(BytecodeGen.class.getName());
 

File: src/com/google/inject/internal/Classes.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Class utilities.
  */
-public class Classes {
+final class Classes {
 
   public static boolean isInnerClass(Class<?> clazz) {
     return !Modifier.isStatic(clazz.getModifiers())

File: src/com/google/inject/internal/ConstructionContext.java
Patch:
@@ -28,7 +28,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public class ConstructionContext<T> {
+final class ConstructionContext<T> {
 
   T currentReference;
   boolean constructing;

File: src/com/google/inject/internal/ConstructionProxy.java
Patch:
@@ -14,9 +14,8 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
-import com.google.inject.internal.ImmutableMap;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;

File: src/com/google/inject/internal/ConstructionProxyFactory.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
 /**
  * Creates {@link ConstructionProxy} instances.

File: src/com/google/inject/internal/ErrorHandler.java
Patch:
@@ -23,7 +23,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public interface ErrorHandler {
+interface ErrorHandler {
 
   /**
    * Handles an error.

File: src/com/google/inject/internal/ExposedBindingImpl.java
Patch:
@@ -25,11 +25,11 @@
 import com.google.inject.spi.PrivateElements;
 import java.util.Set;
 
-public class ExposedBindingImpl<T> extends BindingImpl<T> implements ExposedBinding<T> {
+public final class ExposedBindingImpl<T> extends BindingImpl<T> implements ExposedBinding<T> {
 
   private final PrivateElements privateElements;
 
-  public ExposedBindingImpl(Injector injector, Object source, Key<T> key,
+  public ExposedBindingImpl(InjectorImpl injector, Object source, Key<T> key,
       InternalFactory<T> factory, PrivateElements privateElements) {
     super(injector, key, source, factory, Scoping.UNSCOPED);
     this.privateElements = privateElements;

File: src/com/google/inject/internal/InterceptorStackCallback.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Method;
@@ -28,7 +28,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-class InterceptorStackCallback implements net.sf.cglib.proxy.MethodInterceptor {
+final class InterceptorStackCallback implements net.sf.cglib.proxy.MethodInterceptor {
 
   final MethodInterceptor[] interceptors;
   final Method method;
@@ -44,7 +44,7 @@ public Object intercept(Object proxy, Method method, Object[] arguments,
     return new InterceptedMethodInvocation(proxy, methodProxy, arguments).proceed();
   }
 
-  class InterceptedMethodInvocation implements MethodInvocation {
+  private class InterceptedMethodInvocation implements MethodInvocation {
 
     final Object proxy;
     final Object[] arguments;

File: src/com/google/inject/internal/InternalContext.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public final class InternalContext {
+final class InternalContext {
 
   private Map<Object, ConstructionContext<?>> constructionContexts = Maps.newHashMap();
   private Dependency dependency;

File: src/com/google/inject/internal/InternalFactory.java
Patch:
@@ -23,7 +23,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public interface InternalFactory<T> {
+interface InternalFactory<T> {
 
   /**
    * Creates an object to be injected.

File: src/com/google/inject/internal/LineNumbers.java
Patch:
@@ -35,7 +35,7 @@
  *
  * @author Chris Nokleberg
  */
-public class LineNumbers {
+final class LineNumbers {
 
   private final Class type;
   private final Map<String, Integer> lines = Maps.newHashMap();

File: src/com/google/inject/internal/MatcherAndConverter.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * @author crazybob@google.com (Bob Lee)
  */
-public final class MatcherAndConverter {
+final class MatcherAndConverter {
 
   private final Matcher<? super TypeLiteral<?>> typeMatcher;
   private final TypeConverter typeConverter;

File: src/com/google/inject/internal/SingleMemberInjector.java
Patch:
@@ -14,10 +14,8 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
-import com.google.inject.internal.Errors;
-import com.google.inject.internal.InternalContext;
 import com.google.inject.spi.InjectionPoint;
 
 /**

File: src/com/google/inject/internal/Stopwatch.java
Patch:
@@ -23,7 +23,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public class Stopwatch {
+final class Stopwatch {
   private static final Logger logger = Logger.getLogger(Stopwatch.class.getName());
 
   private long start = System.currentTimeMillis();

File: src/com/google/inject/internal/WeakKeySet.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
-import com.google.inject.internal.Sets;
+import com.google.inject.Key;
 import java.util.Set;
 
 /**

File: src/com/google/inject/spi/DefaultElementVisitor.java
Patch:
@@ -63,7 +63,7 @@ public <T> V visit(ProviderLookup<T> providerLookup) {
     return visitOther(providerLookup);
   }
 
-  public V visit(InjectionRequest injectionRequest) {
+  public V visit(InjectionRequest<?> injectionRequest) {
     return visitOther(injectionRequest);
   }
 

File: src/com/google/inject/spi/ElementVisitor.java
Patch:
@@ -54,7 +54,7 @@ public interface ElementVisitor<V> {
   /**
    * Visit a request to inject the instance fields and methods of an instance.
    */
-  V visit(InjectionRequest request);
+  V visit(InjectionRequest<?> request);
 
   /**
    * Visit a request to inject the static fields and methods of type.

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -137,7 +137,7 @@ private RecordingBinder(Stage stage) {
       this.modules = Sets.newHashSet();
       this.elements = Lists.newArrayList();
       this.source = null;
-      this.sourceProvider = new SourceProvider().plusSkippedClasses(
+      this.sourceProvider = SourceProvider.DEFAULT_INSTANCE.plusSkippedClasses(
           Elements.class, RecordingBinder.class, AbstractModule.class,
           ConstantBindingBuilderImpl.class, AbstractBindingBuilder.class, BindingBuilder.class);
       this.parent = null;

File: test/com/google/inject/AllTests.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.inject.internal.LineNumbersTest;
 import com.google.inject.internal.MapMakerTestSuite;
 import com.google.inject.internal.UniqueAnnotationsTest;
+import com.google.inject.internal.ProxyFactoryTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.name.NamesTest;
 import com.google.inject.spi.BindingTargetVisitorTest;

File: test/com/google/inject/ReflectionTest.java
Patch:
@@ -19,6 +19,7 @@
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import junit.framework.TestCase;
+import com.google.inject.internal.InjectorBuilder;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: test/com/google/inject/internal/ProxyFactoryTest.java
Patch:
@@ -14,10 +14,9 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.internal;
 
-import com.google.inject.internal.ErrorsException;
-import com.google.inject.internal.Lists;
+import com.google.inject.Inject;
 import static com.google.inject.matcher.Matchers.annotatedWith;
 import static com.google.inject.matcher.Matchers.any;
 import static com.google.inject.matcher.Matchers.not;

File: test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -796,14 +796,14 @@ protected void configure() {
         },
 
         new FailingElementVisitor() {
-          @Override public Void visit(InjectionRequest command) {
+          @Override public Void visit(InjectionRequest<?> command) {
             assertEquals(firstObject, command.getInstance());
             return null;
           }
         },
 
         new FailingElementVisitor() {
-          @Override public Void visit(InjectionRequest command) {
+          @Override public Void visit(InjectionRequest<?> command) {
             assertEquals(secondObject, command.getInstance());
             return null;
           }

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -598,6 +598,8 @@ private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors e
    * @throws com.google.inject.internal.ErrorsException if the binding cannot be created.
    */
   <T> BindingImpl<T> createJustInTimeBinding(Key<T> key, Errors errors) throws ErrorsException {
+    int numErrorsBefore = errors.size();
+
     if (state.isBlacklisted(key)) {
       throw errors.childBindingAlreadySet(key).toException();
     }
@@ -642,6 +644,7 @@ <T> BindingImpl<T> createJustInTimeBinding(Key<T> key, Errors errors) throws Err
 
     Object source = key.getTypeLiteral().getRawType();
     BindingImpl<T> binding = createUnitializedBinding(key, Scoping.UNSCOPED, source, errors);
+    errors.throwIfNewErrors(numErrorsBefore);
     initializeBinding(binding, errors);
     return binding;
   }

File: extensions/assistedinject/src/com/google/inject/assistedinject/package-info.java
Patch:
@@ -15,6 +15,7 @@
  */
 
 /**
- * Extension for combining factory interfaces with injection.
+ * Extension for combining factory interfaces with injection; this extension requires {@code
+ * guice-jndi-2.0.jar}.
  */
 package com.google.inject.assistedinject;
\ No newline at end of file

File: extensions/jmx/src/com/google/inject/tools/jmx/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * JMX integration
+ * JMX integration; this extension requires {@code guice-jmx-2.0.jar}.
  */
 package com.google.inject.tools.jmx;
\ No newline at end of file

File: extensions/jndi/src/com/google/inject/jndi/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * JNDI integration
+ * JNDI integration; this extension requires {@code guice-jndi-2.0.jar}.
  */
 package com.google.inject.jndi;
\ No newline at end of file

File: extensions/multibindings/src/com/google/inject/multibindings/package-info.java
Patch:
@@ -15,6 +15,7 @@
  */
 
 /**
- * Extension for binding multiple instances in a collection.
+ * Extension for binding multiple instances in a collection; this extension requires {@code
+ * guice-multibindings-2.0.jar}.
  */
 package com.google.inject.multibindings;
\ No newline at end of file

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/package-info.java
Patch:
@@ -15,6 +15,7 @@
  */
 
 /**
- * Extension for injecting objects that may throw at provision time.
+ * Extension for injecting objects that may throw at provision time; this extension requires {@code
+ * guice-throwingproviders-2.0.jar}.
  */
 package com.google.inject.throwingproviders;
\ No newline at end of file

File: spring/src/com/google/inject/spring/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * Spring integration
+ * Spring integration; this extension requires {@code guice-spring-2.0.jar}.
  */
 package com.google.inject.spring;
\ No newline at end of file

File: src/com/google/inject/spi/Element.java
Patch:
@@ -23,8 +23,8 @@
  *
  * <p>The elements of a module can be inspected, validated and rewritten. Use {@link
  * Elements#getElements(com.google.inject.Module[]) Elements.getElements()} to read the elements
- * from a module, and {@link com.google.inject.spi.ModuleWriter} to rewrite them. This can be used
- * for static analysis and generation of Guice modules.
+ * from a module, and {@link Elements#getModule(Iterable) Elements.getModule()} to rewrite them.
+ * This can be used for static analysis and generation of Guice modules.
  *
  * <p>The elements of an injector can be inspected and exercised. Use {@link
  * com.google.inject.Injector#getBindings Injector.getBindings()} to reflect on Guice injectors.

File: src/com/google/inject/internal/LinkedProviderBindingImpl.java
Patch:
@@ -58,7 +58,8 @@ public BindingImpl<T> withKey(Key<T> key) {
   }
 
   public void applyTo(Binder binder) {
-    getScoping().applyTo(binder.bind(getKey()).toProvider(getProviderKey()));
+    getScoping().applyTo(binder.withSource(getSource())
+        .bind(getKey()).toProvider(getProviderKey()));
   }
 
   @Override public String toString() {

File: src/com/google/inject/spi/BindingTargetVisitor.java
Patch:
@@ -51,8 +51,8 @@ public interface BindingTargetVisitor<T, V> {
   V visit(LinkedKeyBinding<? extends T> binding);
 
   /**
-   * Visit a binding to a key exposed from an enclosed private environment. This target is found in
-   * both module and injector bindings.
+   * Visit a binding to a key exposed from an enclosed private environment. This target is only
+   * found in injector bindings.
    */
   V visit(ExposedBinding<? extends T> binding);
 

File: test/com/google/inject/PrivateModuleTest.java
Patch:
@@ -441,6 +441,8 @@ public void configure() {
     PrivateElements privateElements = binding.getPrivateElements();
     assertEquals(ImmutableSet.<Key<?>>of(Key.get(String.class, named("b"))),
         privateElements.getExposedKeys());
+    assertContains(privateElements.getExposedSource(Key.get(String.class, named("b"))).toString(),
+        PrivateModuleTest.class.getName(), ".configure(PrivateModuleTest.java:");
     Injector privateInjector = privateElements.getInjector();
     assertEquals("private", privateInjector.getInstance(Key.get(String.class, Names.named("a"))));
   }

File: servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -19,11 +19,10 @@
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.Lists;
-import static com.google.inject.name.Names.named;
+import com.google.inject.internal.UniqueAnnotations;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.UUID;
 import javax.servlet.Filter;
 
 /**
@@ -41,7 +40,7 @@ class FiltersModuleBuilder extends AbstractModule {
   protected void configure() {
     // Bind these filter definitions to a unique random key. Doesn't matter what it is,
     // coz it's never used.
-    bind(Key.get(new TypeLiteral<List<FilterDefinition>>() {}, named(UUID.randomUUID().toString())))
+    bind(Key.get(new TypeLiteral<List<FilterDefinition>>() {}, UniqueAnnotations.create()))
         .toInstance(filterDefinitions);
   }
 

File: src/com/google/inject/ConstructionProxy.java
Patch:
@@ -22,7 +22,6 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
-import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * Proxies calls to a {@link java.lang.reflect.Constructor} for a class
@@ -52,6 +51,6 @@ interface ConstructionProxy<T> {
   /**
    * Returns the interceptors applied to each method, in order of invocation.
    */
-  ImmutableMap<Method, List<MethodInterceptor>> getMethodInterceptors();
+  ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors();
   /*end[AOP]*/
 }

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -65,7 +65,6 @@ class InjectorImpl implements Injector, Lookups {
   final InjectorImpl parent;
   final BindingsMultimap bindingsMultimap = new BindingsMultimap();
   final Initializer initializer;
-  ImmutableList<MethodAspect> methodAspects;
 
   /** Just-in-time binding cache. Guarded by state.lock() */
   final Map<Key<?>, BindingImpl<?>> jitBindings = Maps.newHashMap();

File: src/com/google/inject/MembersInjectorStore.java
Patch:
@@ -96,8 +96,7 @@ private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Erro
     encounter.invalidate();
     errors.throwIfNewErrors(numErrorsBefore);
 
-    return new MembersInjectorImpl<T>(injector, type, injectors, encounter.getMembersInjectors(),
-        encounter.getInjectionListeners(), encounter.getAspects());
+    return new MembersInjectorImpl<T>(injector, type, encounter, injectors);
   }
 
   /**

File: src/com/google/inject/State.java
Patch:
@@ -77,7 +77,7 @@ public void addMethodAspect(MethodAspect methodAspect) {
       throw new UnsupportedOperationException();
     }
 
-    public List<MethodAspect> getMethodAspects() {
+    public ImmutableList<MethodAspect> getMethodAspects() {
       return ImmutableList.of();
     }
     /*end[AOP]*/
@@ -129,7 +129,7 @@ MatcherAndConverter getConverter(
   /*if[AOP]*/
   void addMethodAspect(MethodAspect methodAspect);
 
-  List<MethodAspect> getMethodAspects();
+  ImmutableList<MethodAspect> getMethodAspects();
   /*end[AOP]*/
 
   void addTypeListener(TypeListenerBinding typeListenerBinding);

File: src/com/google/inject/spi/ConstructorBinding.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * A binding to the constructor of a concrete clss. To resolve injections, an instance is
@@ -52,6 +51,6 @@ public interface ConstructorBinding<T> extends Binding<T>, HasDependencies {
    *
    * @return a possibly empty map
    */
-  Map<Method, List<MethodInterceptor>> getMethodInterceptors();
+  Map<Method, List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors();
   /*end[AOP]*/
 }
\ No newline at end of file

File: test/com/googlecode/guice/StrictContainerTestSuite.java
Patch:
@@ -51,7 +51,9 @@ public static Test suite() {
     };
 
     StrictContainerTestSuiteBuilder builder = new StrictContainerTestSuiteBuilder(securityManager);
+    /*if[AOP]*/
     builder.add(BytecodeGenTest.class.getName());
+    /*end[AOP]*/
     builder.addSuite(MapMakerTestSuite.class.getName());
     return builder.build();
   }

File: src/com/google/inject/AbstractProcessor.java
Patch:
@@ -20,14 +20,14 @@
 import com.google.inject.spi.Element;
 import com.google.inject.spi.ElementVisitor;
 import com.google.inject.spi.InjectionRequest;
+import com.google.inject.spi.MembersInjectorLookup;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.PrivateElements;
 import com.google.inject.spi.ProviderLookup;
 import com.google.inject.spi.ScopeBinding;
 import com.google.inject.spi.StaticInjectionRequest;
 import com.google.inject.spi.TypeConverterBinding;
-import com.google.inject.spi.MembersInjectorLookup;
-import com.google.inject.spi.InjectableTypeListenerBinding;
+import com.google.inject.spi.TypeListenerBinding;
 import java.util.Iterator;
 import java.util.List;
 
@@ -116,7 +116,7 @@ public <T> Boolean visit(MembersInjectorLookup<T> lookup) {
     return false;
   }
 
-  public Boolean visit(InjectableTypeListenerBinding binding) {
+  public Boolean visit(TypeListenerBinding binding) {
     return false;
   }
 }

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -141,8 +141,7 @@ public Object intercept(
   }
 
   /**
-   * Returns the interceptors that apply to the constructed type. When InjectableType.Listeners
-   * add additional interceptors, this builder will be thrown out and another created.n
+   * Returns the interceptors that apply to the constructed type.
    */
   public ImmutableMap<Method, List<MethodInterceptor>> getInterceptors() {
     return interceptors;

File: src/com/google/inject/spi/DefaultElementVisitor.java
Patch:
@@ -79,7 +79,7 @@ public <T> V visit(MembersInjectorLookup<T> lookup) {
     return visitOther(lookup);
   }
 
-  public V visit(InjectableTypeListenerBinding binding) {
+  public V visit(TypeListenerBinding binding) {
     return visitOther(binding);
   }
 }

File: src/com/google/inject/spi/ElementVisitor.java
Patch:
@@ -85,5 +85,5 @@ public interface ElementVisitor<V> {
   /**
    * Visit an injectable type listener binding.
    */
-  V visit(InjectableTypeListenerBinding binding);
+  V visit(TypeListenerBinding binding);
 }

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -189,7 +189,7 @@ public <T> MembersInjector<T> getMembersInjector(Class<T> type) {
     }
 
     public void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher, TypeListener listener) {
-      elements.add(new InjectableTypeListenerBinding(getSource(), listener, typeMatcher));
+      elements.add(new TypeListenerBinding(getSource(), listener, typeMatcher));
     }
 
     public void requestStaticInjection(Class<?>... types) {

File: src/com/google/inject/spi/InterceptorBinding.java
Patch:
@@ -34,7 +34,7 @@
  *         new MyTransactionInterceptor());</pre>
  *
  * or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
- * org.aopalliance.intercept.MethodInterceptor[]) InjectableType.Encounter.bindInterceptor()}.
+ * org.aopalliance.intercept.MethodInterceptor[]) TypeEncounter.bindInterceptor()}.
  *
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: src/com/google/inject/spi/ModuleWriter.java
Patch:
@@ -109,7 +109,7 @@ public <T> Void visit(MembersInjectorLookup<T> element) {
         return null;
       }
 
-      public Void visit(InjectableTypeListenerBinding element) {
+      public Void visit(TypeListenerBinding element) {
         writeBindListener(binder, element);
         return null;
       }
@@ -138,7 +138,7 @@ protected void writeBindInterceptor(Binder binder, InterceptorBinding element) {
   }
   /*end[AOP]*/
 
-  protected void writeBindListener(Binder binder, InjectableTypeListenerBinding element) {
+  protected void writeBindListener(Binder binder, TypeListenerBinding element) {
     binder.withSource(element.getSource())
         .bindListener(element.getTypeMatcher(), element.getListener());
   }

File: src/com/google/inject/spi/TypeListener.java
Patch:
@@ -37,7 +37,7 @@ public interface TypeListener {
    *
    * @param type encountered by Guice
    * @param encounter context of this encounter, enables reporting errors, registering injection
-   *     listeners and binding method interceptors for injectableType
+   *     listeners and binding method interceptors for {@code type}.
    *
    * @param <I> the injectable type
    */

File: test/com/google/inject/AllTests.java
Patch:
@@ -56,7 +56,7 @@ public static Test suite() {
     suite.addTestSuite(EagerSingletonTest.class);
     suite.addTestSuite(GenericInjectionTest.class);
     suite.addTestSuite(ImplicitBindingTest.class);
-    suite.addTestSuite(InjectableTypeListenerTest.class);
+    suite.addTestSuite(TypeListenerTest.class);
     suite.addTestSuite(InjectorTest.class);
     // IntegrationTest is AOP-only
     suite.addTestSuite(KeyTest.class);

File: test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -606,7 +606,7 @@ protected void configure() {
         },
 
         new FailingElementVisitor() {
-          @Override public Void visit(InjectableTypeListenerBinding binding) {
+          @Override public Void visit(TypeListenerBinding binding) {
             assertSame(typeMatcher, binding.getTypeMatcher());
             assertSame(listener, binding.getListener());
             return null;

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -24,7 +24,7 @@
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;
-import com.google.inject.spi.InjectableType;
+import com.google.inject.spi.TypeListener;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 
@@ -243,11 +243,11 @@ protected <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> type) {
 
   /**
    * @see Binder#bindListener(com.google.inject.matcher.Matcher,
-   *  com.google.inject.spi.InjectableType.Listener) 
+   *  com.google.inject.spi.TypeListener)
    * @since 2.0
    */
   protected void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher,
-      InjectableType.Listener listener) {
+      TypeListener listener) {
     binder.bindListener(typeMatcher, listener);
   }
 }

File: src/com/google/inject/Binder.java
Patch:
@@ -20,9 +20,9 @@
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.matcher.Matcher;
-import com.google.inject.spi.InjectableType;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;
+import com.google.inject.spi.TypeListener;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 
@@ -359,7 +359,7 @@ void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
    * @since 2.0
    */
   void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher,
-      InjectableType.Listener listener);
+      TypeListener listener);
 
   /**
    * Returns a binder that uses {@code source} as the reference location for

File: src/com/google/inject/ConstructionProxy.java
Patch:
@@ -16,12 +16,13 @@
 
 package com.google.inject;
 
+import com.google.inject.internal.ImmutableMap;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
-import java.util.Map;
+import org.aopalliance.intercept.MethodInterceptor;
 
 /**
  * Proxies calls to a {@link java.lang.reflect.Constructor} for a class
@@ -51,6 +52,6 @@ interface ConstructionProxy<T> {
   /**
    * Returns the interceptors applied to each method, in order of invocation.
    */
-  Map<Method, List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors();
+  ImmutableMap<Method, List<MethodInterceptor>> getMethodInterceptors();
   /*end[AOP]*/
 }

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -25,7 +25,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.List;
-import java.util.Map;
 
 /**
  * Produces construction proxies that invoke the class constructor.
@@ -66,7 +65,7 @@ public InjectionPoint getInjectionPoint() {
         public Constructor<T> getConstructor() {
           return constructor;
         }
-        public Map<Method, List<org.aopalliance.intercept.MethodInterceptor>>
+        public ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>>
             getMethodInterceptors() {
           return ImmutableMap.of();
         }
@@ -93,7 +92,7 @@ public Constructor<T> getConstructor() {
         return constructor;
       }
       /*if[AOP]*/
-      public Map<Method, List<org.aopalliance.intercept.MethodInterceptor>>
+      public ImmutableMap<Method, List<org.aopalliance.intercept.MethodInterceptor>>
           getMethodInterceptors() {
         return ImmutableMap.of();
       }

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -716,7 +716,7 @@ Object invoke(Object target, Object... parameters)
   }
 
   /** Cached constructor injectors for each type */
-  ConstructorInjectorStore constructors;
+  final ConstructorInjectorStore constructors = new ConstructorInjectorStore(this);
 
   /** Cached field and method injectors for each type. */
   MembersInjectorStore membersInjectorStore;

File: src/com/google/inject/InjectorShell.java
Patch:
@@ -150,9 +150,8 @@ List<InjectorShell> build(Initializer initializer, BindingProcessor bindingProce
       new InjectableTypeListenerBindingProcessor(errors).process(injector, elements);
       List<InjectableTypeListenerBinding> listenerBindings
           = injector.state.getInjectableTypeListenerBindings();
-      injector.constructors = new ConstructorInjectorStore(injector, listenerBindings);
       injector.membersInjectorStore = new MembersInjectorStore(injector, listenerBindings);
-      stopwatch.resetAndLog("InjectableType listeners creation");
+      stopwatch.resetAndLog("TypeListeners creation");
 
       new ScopeBindingProcessor(errors).process(injector, elements);
       stopwatch.resetAndLog("Scopes creation");

File: src/com/google/inject/PrivateModule.java
Patch:
@@ -24,7 +24,7 @@
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;
-import com.google.inject.spi.InjectableType;
+import com.google.inject.spi.TypeListener;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 
@@ -284,10 +284,10 @@ protected <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> type) {
   }
 
   /**
-   * @see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.InjectableType.Listener)
+   * @see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)
    */
   protected void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher,
-      InjectableType.Listener listener) {
+      TypeListener listener) {
     binder.bindListener(typeMatcher, listener);
   }
 }

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -261,7 +261,7 @@ public Constructor<T> getConstructor() {
       return constructor;
     }
 
-    public Map<Method, List<MethodInterceptor>> getMethodInterceptors() {
+    public ImmutableMap<Method, List<MethodInterceptor>> getMethodInterceptors() {
       return methodInterceptors;
     }
   }

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -188,8 +188,7 @@ public <T> MembersInjector<T> getMembersInjector(Class<T> type) {
       return getMembersInjector(TypeLiteral.get(type));
     }
 
-    public void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher,
-        InjectableType.Listener listener) {
+    public void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher, TypeListener listener) {
       elements.add(new InjectableTypeListenerBinding(getSource(), listener, typeMatcher));
     }
 

File: src/com/google/inject/spi/InterceptorBinding.java
Patch:
@@ -33,9 +33,8 @@
  *         Matchers.annotatedWith(Transactional.class),
  *         new MyTransactionInterceptor());</pre>
  *
- * or from an injectable type listener using
- * {@link com.google.inject.spi.InjectableType.Encounter#bindInterceptor(com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
- * InjectableType.Encounter.bindInterceptor()}.  
+ * or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
+ * org.aopalliance.intercept.MethodInterceptor[]) InjectableType.Encounter.bindInterceptor()}.
  *
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: test/com/google/inject/MethodInterceptionTest.java
Patch:
@@ -119,12 +119,12 @@ protected void configure() {
     assertEquals(ImmutableMap.<Method, List<MethodInterceptor>>of(
         fooMethod, ImmutableList.of(countingInterceptor, returnNullInterceptor),
         barMethod, ImmutableList.of(returnNullInterceptor)),
-        interceptedBinding.getInjectableType().getMethodInterceptors());
+        interceptedBinding.getMethodInterceptors());
 
     ConstructorBinding<?> nonInterceptedBinding
         = (ConstructorBinding<?>) injector.getBinding(Foo.class);
     assertEquals(ImmutableMap.<Method, List<MethodInterceptor>>of(),
-        nonInterceptedBinding.getInjectableType().getMethodInterceptors());
+        nonInterceptedBinding.getMethodInterceptors());
 
     injector.getInstance(Interceptable.class).foo();
     assertEquals("expected counting interceptor to be invoked first", 1, count.get());

File: test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -592,9 +592,8 @@ protected void configure() {
 
   public void testBindListener() {
     final Matcher<Object> typeMatcher = Matchers.only(TypeLiteral.get(String.class));
-    final InjectableType.Listener listener = new InjectableType.Listener() {
-      public <I> void hear(
-          InjectableType<I> injectableType, InjectableType.Encounter<I> encounter) {
+    final TypeListener listener = new TypeListener() {
+      public <I> void hear(TypeLiteral<I> type, TypeEncounter<I> encounter) {
         throw new UnsupportedOperationException();
       }
     };

File: test/com/google/inject/spi/SpiBindingsTest.java
Patch:
@@ -193,7 +193,8 @@ protected void configure() {
             binding.acceptTargetVisitor(new FailingTargetVisitor<T>() {
               @Override public Void visit(ConstructorBinding<? extends T> binding) {
                 Constructor<?> expected = D.class.getDeclaredConstructors()[0];
-                assertEquals(expected, binding.getConstructor());
+                assertEquals(expected, binding.getConstructor().getMember());
+                assertEquals(ImmutableSet.<InjectionPoint>of(), binding.getInjectableMembers());
                 return null;
               }
             });

File: src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -577,7 +577,7 @@ public static class WildcardTypeImpl implements WildcardType, Serializable, Comp
     private final Type lowerBound;
 
     public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      checkArgument(upperBounds.length <= 1, "Must have at most one lower bound.");
+      checkArgument(lowerBounds.length <= 1, "Must have at most one lower bound.");
       checkArgument(upperBounds.length == 1, "Must have exactly one upper bound.");
 
       if (lowerBounds.length == 1) {

File: src/com/google/inject/ConstructorInjectorStore.java
Patch:
@@ -92,6 +92,7 @@ private <T> ConstructorInjector<T> createConstructor(TypeLiteral<T> type, Errors
         }
       }
     }
+    encounter.invalidate();
 
     // rebuild the proxy factory and injectable type if new interceptors were added
     if (encounter.hasAddedAspects()) {

File: src/com/google/inject/MembersInjectorStore.java
Patch:
@@ -100,6 +100,7 @@ private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Erro
         }
       }
     }
+    encounter.invalidate();
 
     errors.throwIfNewErrors(numErrorsBefore);
     return membersInjector.withListeners(encounter.getInjectionListeners());

File: src/com/google/inject/spi/InjectableType.java
Patch:
@@ -148,7 +148,9 @@ public interface Listener {
 
   /**
    * Context of the injectable type encounter. Enables reporting errors, registering injection
-   * listeners and binding method interceptors for injectable type {@code I}.
+   * listeners and binding method interceptors for injectable type {@code I}. It is an error to use
+   * an encounter after the {@link Listener#hear(InjectableType,Encounter) hear()} method has
+   * returned.
    *
    * @param <I> the injectable type encountered
    */

File: src/com/google/inject/ConstructorInjectorStore.java
Patch:
@@ -79,7 +79,7 @@ private <T> ConstructorInjector<T> createConstructor(TypeLiteral<T> type, Errors
     ImmutableSet<InjectionPoint> injectableMembers = membersInjector.getInjectionPoints();
 
     ProxyFactory<T> proxyFactory = new ProxyFactory<T>(injectionPoint, injector.methodAspects);
-    EncounterImpl<T> encounter = new EncounterImpl<T>();
+    EncounterImpl<T> encounter = new EncounterImpl<T>(errors, injector.lookups);
     InjectableType<T> injectableType = new InjectableType<T>(
         injectionPoint, type, injectableMembers, proxyFactory.getInterceptors());
 

File: src/com/google/inject/InjectorBuilder.java
Patch:
@@ -138,6 +138,9 @@ private void initializeStatically() {
     stopwatch.resetAndLog("Instance member validation");
 
     new LookupProcessor(errors).process(shells);
+    for (InjectorShell shell : shells) {
+      ((DeferredLookups) shell.getInjector().lookups).initialize(errors);
+    }
     stopwatch.resetAndLog("Provider verification");
 
     for (InjectorShell shell : shells) {

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -60,7 +60,7 @@
  * @author crazybob@google.com (Bob Lee)
  * @see InjectorBuilder
  */
-class InjectorImpl implements Injector {
+class InjectorImpl implements Injector, Lookups {
   final State state;
   final InjectorImpl parent;
   final BindingsMultimap bindingsMultimap = new BindingsMultimap();
@@ -70,6 +70,8 @@ class InjectorImpl implements Injector {
   /** Just-in-time binding cache. Guarded by state.lock() */
   final Map<Key<?>, BindingImpl<?>> jitBindings = Maps.newHashMap();
 
+  Lookups lookups = new DeferredLookups(this);
+
   InjectorImpl(@Nullable InjectorImpl parent, State state, Initializer initializer) {
     this.parent = parent;
     this.state = state;

File: src/com/google/inject/InjectorShell.java
Patch:
@@ -148,11 +148,11 @@ List<InjectorShell> build(Initializer initializer, BindingProcessor bindingProce
       end[NO_AOP]*/
 
       new InjectableTypeListenerBindingProcessor(errors).process(injector, elements);
-      stopwatch.resetAndLog("InjectableType listeners creation");
       List<InjectableTypeListenerBinding> listenerBindings
           = injector.state.getInjectableTypeListenerBindings();
       injector.constructors = new ConstructorInjectorStore(injector, listenerBindings);
       injector.membersInjectorStore = new MembersInjectorStore(injector, listenerBindings);
+      stopwatch.resetAndLog("InjectableType listeners creation");
 
       new ScopeBindingProcessor(errors).process(injector, elements);
       stopwatch.resetAndLog("Scopes creation");

File: src/com/google/inject/spi/MembersInjectorLookup.java
Patch:
@@ -69,7 +69,7 @@ public void initializeDelegate(MembersInjector<T> delegate) {
   }
 
   public void applyTo(Binder binder) {
-    binder.withSource(getSource()).getMembersInjector(type);
+    initializeDelegate(binder.withSource(getSource()).getMembersInjector(type));
   }
 
   /**

File: src/com/google/inject/spi/ProviderLookup.java
Patch:
@@ -65,7 +65,7 @@ public void initializeDelegate(Provider<T> delegate) {
   }
 
   public void applyTo(Binder binder) {
-    binder.withSource(getSource()).getProvider(key);
+    initializeDelegate(binder.withSource(getSource()).getProvider(key));
   }
 
   /**

File: src/com/google/inject/BindingProcessor.java
Patch:
@@ -260,8 +260,9 @@ private boolean isOkayDuplicate(Binding<?> original, BindingImpl<?> binding) {
       Binding.class,
       Injector.class,
       Key.class,
+      MembersInjector.class,
       Module.class,
-      Provider.class, 
+      Provider.class,
       Scope.class,
       TypeLiteral.class);
   // TODO(jessewilson): fix BuiltInModule, then add Stage

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -284,7 +284,7 @@ private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors error
       return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
     } catch (ErrorsException e) {
       throw e;
-    } catch (Exception e) {
+    } catch (RuntimeException e) {
       throw errors.conversionError(stringValue, source, type, matchingConverter, e)
           .toException();
     }

File: extensions/assistedinject/src/com/google/inject/assistedinject/Assisted.java
Patch:
@@ -35,7 +35,7 @@
 
   /**
    * The unique name for this parameter. This is matched to the {@literal @Assisted} constructor 
-   * parameter with the same value.
+   * parameter with the same value. Names are not necessary when the parameter types are distinct.
    */
   String value() default "";
 }
\ No newline at end of file

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -37,6 +37,7 @@
 import com.google.inject.internal.ImmutableList;
 import com.google.inject.internal.Lists;
 import static com.google.inject.internal.Preconditions.checkArgument;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import static com.google.inject.internal.Preconditions.checkState;
 import com.google.inject.internal.PrivateElementsImpl;
 import com.google.inject.internal.ProviderMethodsModule;
@@ -181,6 +182,8 @@ public void requestStaticInjection(Class<?>... types) {
     }
 
     public void install(Module module) {
+      checkNotNull(module, "module");
+
       if (modules.add(module)) {
         Binder binder = this;
         if (module instanceof PrivateModule) {

File: src/com/google/inject/PrivateModule.java
Patch:
@@ -44,7 +44,7 @@
  *
  * <pre>
  * public class FooBarBazModule extends PrivateModule {
- *   protected void configurePrivateBindings() {
+ *   protected void configure() {
  *     bind(Foo.class).to(RealFoo.class);
  *     expose(Foo.class);
  *

File: extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.assistedinject;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import com.google.inject.BindingAnnotation;
 import com.google.inject.ConfigurationException;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Provider;
+import static com.google.inject.internal.Preconditions.checkArgument;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProviderTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.assistedinject;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.Binding;
@@ -28,6 +27,7 @@
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
 import com.google.inject.spi.Dependency;

File: extensions/grapher/src/com/google/inject/grapher/DependencyEdge.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject.grapher;
 
-import com.google.common.base.Nullable;
+import com.google.inject.internal.Nullable;
 import com.google.inject.spi.InjectionPoint;
 
 /**

File: extensions/grapher/src/com/google/inject/grapher/GraphingVisitor.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject.grapher;
 
-import com.google.common.base.Nullable;
-import com.google.common.collect.Lists;
 import com.google.inject.Binding;
 import com.google.inject.Inject;
 import com.google.inject.Key;
 import com.google.inject.Provider;
+import com.google.inject.internal.Lists;
+import com.google.inject.internal.Nullable;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.ConstructorBinding;
 import com.google.inject.spi.ConvertedConstantBinding;
@@ -35,7 +35,6 @@
 import com.google.inject.spi.ProviderInstanceBinding;
 import com.google.inject.spi.ProviderKeyBinding;
 import com.google.inject.spi.UntargettedBinding;
-
 import java.lang.reflect.Member;
 import java.util.Collection;
 import java.util.List;

File: extensions/grapher/src/com/google/inject/grapher/InjectorGrapher.java
Patch:
@@ -16,14 +16,13 @@
 
 package com.google.inject.grapher;
 
-import com.google.common.collect.Sets;
 import com.google.inject.Binding;
 import com.google.inject.Guice;
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.internal.Sets;
 import com.google.inject.spi.BindingTargetVisitor;
-
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Iterator;

File: extensions/grapher/src/com/google/inject/grapher/TransitiveDependencyVisitor.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.grapher;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.inject.Key;
+import com.google.inject.internal.ImmutableSet;
+import com.google.inject.internal.Sets;
 import com.google.inject.spi.BindingTargetVisitor;
 import com.google.inject.spi.ConstructorBinding;
 import com.google.inject.spi.ConvertedConstantBinding;
@@ -31,7 +31,6 @@
 import com.google.inject.spi.ProviderInstanceBinding;
 import com.google.inject.spi.ProviderKeyBinding;
 import com.google.inject.spi.UntargettedBinding;
-
 import java.util.Collection;
 import java.util.Set;
 

File: extensions/grapher/src/com/google/inject/grapher/graphviz/BindingEdgeFactory.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.grapher.graphviz;
 
-import com.google.common.collect.ImmutableList;
 import com.google.inject.Inject;
 import com.google.inject.grapher.BindingEdge;
+import com.google.inject.internal.ImmutableList;
 
 /**
  * Graphviz-specific implementation of {@link BindingEdge.Factory}. Uses a

File: extensions/grapher/src/com/google/inject/grapher/graphviz/DependencyEdgeFactory.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.grapher.graphviz;
 
-import com.google.common.collect.ImmutableList;
 import com.google.inject.Inject;
 import com.google.inject.grapher.DependencyEdge;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.spi.InjectionPoint;
 
 /**

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizEdge.java
Patch:
@@ -16,8 +16,7 @@
 
 package com.google.inject.grapher.graphviz;
 
-import com.google.common.collect.ImmutableList;
-
+import com.google.inject.internal.ImmutableList;
 import java.util.List;
 
 /**

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.multibindings;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Inject;
 import com.google.inject.Key;
 import com.google.inject.Module;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 import com.google.inject.binder.LinkedBindingBuilder;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.multibindings.Multibinder.RealMultibinder;
 import static com.google.inject.multibindings.Multibinder.checkConfiguration;
 import static com.google.inject.multibindings.Multibinder.checkNotNull;

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -16,9 +16,6 @@
 
 package com.google.inject.multibindings;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.inject.Binder;
 import com.google.inject.Binding;
 import com.google.inject.ConfigurationException;
@@ -30,6 +27,9 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableSet;
+import com.google.inject.internal.Lists;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.Message;

File: extensions/multibindings/test/com/google/inject/multibindings/MapBinderTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.multibindings;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.Binding;
@@ -29,6 +28,7 @@
 import com.google.inject.Provider;
 import com.google.inject.ProvisionException;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.name.Names;
 import static com.google.inject.name.Names.named;
 import com.google.inject.spi.Dependency;

File: extensions/multibindings/test/com/google/inject/multibindings/MultibinderTest.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.inject.multibindings;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.inject.AbstractModule;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.Binding;
@@ -30,6 +28,8 @@
 import com.google.inject.Provider;
 import com.google.inject.ProvisionException;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.ImmutableSet;
+import com.google.inject.internal.Sets;
 import com.google.inject.name.Names;
 import static com.google.inject.name.Names.named;
 import com.google.inject.spi.Dependency;

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/ThrowingProviderBinder.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.throwingproviders;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.Binder;
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 import com.google.inject.binder.ScopedBindingBuilder;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.internal.UniqueAnnotations;
 import com.google.inject.util.Types;
 import java.lang.annotation.Annotation;

File: servlet/src/com/google/inject/servlet/FilterDefinition.java
Patch:
@@ -15,9 +15,9 @@
  */
 package com.google.inject.servlet;
 
-import com.google.common.collect.Iterators;
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.internal.Iterators;
 import static com.google.inject.servlet.ServletScopes.isSingletonBinding;
 import java.io.IOException;
 import java.util.Collections;

File: servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -15,10 +15,10 @@
  */
 package com.google.inject.servlet;
 
-import com.google.common.collect.Lists;
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.Lists;
 import static com.google.inject.name.Names.named;
 import java.util.HashMap;
 import java.util.List;

File: servlet/src/com/google/inject/servlet/ServletDefinition.java
Patch:
@@ -15,9 +15,9 @@
  */
 package com.google.inject.servlet;
 
-import com.google.common.collect.Iterators;
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.internal.Iterators;
 import static com.google.inject.servlet.ServletScopes.isSingletonBinding;
 import java.io.IOException;
 import java.util.Collections;

File: servlet/src/com/google/inject/servlet/ServletsModuleBuilder.java
Patch:
@@ -15,11 +15,11 @@
  */
 package com.google.inject.servlet;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
+import com.google.inject.internal.Lists;
+import com.google.inject.internal.Sets;
 import static com.google.inject.name.Names.named;
 import java.util.HashMap;
 import java.util.List;

File: spring/src/com/google/inject/spring/SpringIntegration.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.spring;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.Binder;
 import com.google.inject.Inject;
 import com.google.inject.Provider;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.name.Names;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.ListableBeanFactory;

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
+import static com.google.inject.internal.Preconditions.checkNotNull;
+import static com.google.inject.internal.Preconditions.checkState;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;

File: src/com/google/inject/BindingProcessor.java
Patch:
@@ -16,17 +16,17 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.BindingImpl;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ExposedBindingImpl;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.InstanceBindingImpl;
 import com.google.inject.internal.InternalFactory;
 import com.google.inject.internal.LinkedBindingImpl;
 import com.google.inject.internal.LinkedProviderBindingImpl;
+import com.google.inject.internal.Lists;
 import com.google.inject.internal.ProviderInstanceBindingImpl;
 import com.google.inject.internal.Scoping;
 import com.google.inject.internal.UntargettedBindingImpl;

File: src/com/google/inject/ClassBindingImpl.java
Patch:
@@ -16,13 +16,13 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkState;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.InjectorImpl.LateBoundConstructor;
 import com.google.inject.internal.BindingImpl;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.InternalFactory;
+import static com.google.inject.internal.Preconditions.checkState;
 import com.google.inject.internal.Scoping;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.BindingTargetVisitor;

File: src/com/google/inject/ConfigurationException.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkState;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ImmutableSet;
+import static com.google.inject.internal.Preconditions.checkState;
 import com.google.inject.spi.Message;
 import java.util.Collection;
 

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.ConstructionContext;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.InternalContext;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.InvocationTargetException;

File: src/com/google/inject/CreationException.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ImmutableSet;
+import static com.google.inject.internal.Preconditions.checkArgument;
 import com.google.inject.spi.Message;
 import java.util.Collection;
 

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.BytecodeGen.Visibility;
+import com.google.inject.internal.ImmutableMap;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;

File: src/com/google/inject/InheritingState.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.inject.internal.BindingImpl;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.Lists;
+import com.google.inject.internal.Maps;
 import com.google.inject.internal.MatcherAndConverter;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.lang.annotation.Annotation;
 import java.util.Collections;
 import java.util.List;

File: src/com/google/inject/Initializer.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.Lists;
+import com.google.inject.internal.Maps;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.spi.InjectionPoint;
 import java.util.List;
 import java.util.Map;

File: src/com/google/inject/InjectionRequestProcessor.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.internal.InternalContext;
+import com.google.inject.internal.Lists;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.InjectionRequest;
 import com.google.inject.spi.StaticInjectionRequest;

File: src/com/google/inject/InjectorBuilder.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.inject.internal.BindingImpl;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.InternalContext;
+import com.google.inject.internal.Iterables;
 import com.google.inject.internal.Stopwatch;
 import com.google.inject.spi.Dependency;
 import java.util.Collection;

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.InternalContext;
 import com.google.inject.internal.InternalFactory;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.internal.SourceProvider;
 import com.google.inject.spi.Dependency;
 

File: src/com/google/inject/Key.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.MoreTypes;
+import static com.google.inject.internal.Preconditions.checkArgument;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.internal.ToStringBuilder;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;

File: src/com/google/inject/MethodAspect.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 import java.lang.reflect.Method;
 import java.util.Arrays;

File: src/com/google/inject/PrivateElementProcessor.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.Lists;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.Lists;
 import com.google.inject.spi.PrivateElements;
 import java.util.List;
 

File: src/com/google/inject/PrivateModule.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkState;
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.AnnotatedElementBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
+import static com.google.inject.internal.Preconditions.checkState;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;

File: src/com/google/inject/ProvisionException.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableSet;
+import static com.google.inject.internal.Preconditions.checkArgument;
 import com.google.inject.spi.Message;
 import java.util.Collection;
 

File: src/com/google/inject/ScopeBindingProcessor.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.Errors;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.spi.ScopeBinding;
 import java.lang.annotation.Annotation;
 

File: src/com/google/inject/SingleMethodInjector.java
Patch:
@@ -16,12 +16,12 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
 import com.google.inject.InjectorImpl.MethodInvoker;
 import com.google.inject.internal.BytecodeGen;
 import com.google.inject.internal.BytecodeGen.Visibility;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.internal.InternalContext;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.InvocationTargetException;

File: src/com/google/inject/State.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.BindingImpl;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.MatcherAndConverter;
 import java.lang.annotation.Annotation;
 import java.util.List;

File: src/com/google/inject/TypeLiteral.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.ImmutableList;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.internal.MoreTypes;
 import static com.google.inject.internal.MoreTypes.canonicalize;
+import static com.google.inject.internal.Preconditions.checkArgument;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.util.Types;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;

File: src/com/google/inject/WeakKeySet.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import com.google.common.collect.Sets;
+import com.google.inject.internal.Sets;
 import java.util.Set;
 
 /**

File: src/com/google/inject/internal/AbstractBindingBuilder.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.Scope;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.InstanceBinding;
 import java.lang.annotation.Annotation;

File: src/com/google/inject/internal/BindingBuilder.java
Patch:
@@ -16,15 +16,14 @@
 
 package com.google.inject.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.ConfigurationException;
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.AnnotatedElementBuilder;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.spi.Element;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;

File: src/com/google/inject/internal/ConstantBindingBuilderImpl.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;

File: src/com/google/inject/internal/Errors.java
Patch:
@@ -16,9 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.inject.ConfigurationException;
 import com.google.inject.CreationException;
 import com.google.inject.Key;

File: src/com/google/inject/internal/ExposedBindingImpl.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.spi.BindingTargetVisitor;

File: src/com/google/inject/internal/InstanceBindingImpl.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Provider;

File: src/com/google/inject/internal/LineNumbers.java
Patch:
@@ -16,8 +16,7 @@
 
 package com.google.inject.internal;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import com.google.common.collect.Maps;
+import static com.google.inject.internal.Preconditions.checkArgument;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Member;

File: src/com/google/inject/internal/MatcherAndConverter.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.TypeLiteral;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.TypeConverter;
 

File: src/com/google/inject/internal/Nullable.java
Patch:
@@ -33,5 +33,5 @@
  */
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.PARAMETER)
+@Target({ElementType.PARAMETER, ElementType.FIELD})
 public @interface Nullable { }

File: src/com/google/inject/internal/ProviderInstanceBindingImpl.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Provider;

File: src/com/google/inject/internal/ProviderMethod.java
Patch:
@@ -16,12 +16,11 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.Binder;
 import com.google.inject.Exposed;
 import com.google.inject.Key;
-import com.google.inject.Provider;
 import com.google.inject.PrivateBinder;
+import com.google.inject.Provider;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.ProviderWithDependencies;
 import java.lang.annotation.Annotation;

File: src/com/google/inject/internal/ProviderMethodsModule.java
Patch:
@@ -16,15 +16,13 @@
 
 package com.google.inject.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.inject.Binder;
 import com.google.inject.Key;
 import com.google.inject.Module;
 import com.google.inject.Provider;
 import com.google.inject.Provides;
 import com.google.inject.TypeLiteral;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.spi.Dependency;
 import com.google.inject.spi.Message;
 import com.google.inject.util.Modules;

File: src/com/google/inject/internal/SourceProvider.java
Patch:
@@ -16,9 +16,7 @@
 
 package com.google.inject.internal;
 
-import com.google.common.collect.ImmutableSet;
-import static com.google.common.collect.Iterables.concat;
-import com.google.common.collect.Lists;
+import static com.google.inject.internal.Iterables.concat;
 import java.util.List;
 
 /**

File: src/com/google/inject/matcher/Matchers.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.matcher;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.inject.internal.Preconditions.checkArgument;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;

File: src/com/google/inject/name/NamedImpl.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject.name;
 
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
-import static com.google.common.base.Preconditions.checkNotNull;
 
 class NamedImpl implements Named, Serializable {
 

File: src/com/google/inject/spi/Dependency.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.spi;
 
-import com.google.common.base.Objects;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.inject.Key;
+import com.google.inject.internal.ImmutableSet;
+import com.google.inject.internal.Lists;
+import com.google.inject.internal.Objects;
 import java.io.Serializable;
 import java.util.List;
 import java.util.Set;

File: src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -16,16 +16,16 @@
 
 package com.google.inject.spi;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.inject.ConfigurationException;
 import com.google.inject.Inject;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableSet;
+import com.google.inject.internal.Lists;
 import com.google.inject.internal.MoreTypes;
 import static com.google.inject.internal.MoreTypes.getRawType;
 import com.google.inject.internal.Nullability;

File: src/com/google/inject/spi/InjectionRequest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.ConfigurationException;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.util.Set;
 
 /**

File: src/com/google/inject/spi/InterceptorBinding.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 import java.lang.reflect.Method;
 import java.util.Arrays;

File: src/com/google/inject/spi/Message.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.spi;
 
-import com.google.common.base.Objects;
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.ImmutableList;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.Objects;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.internal.SourceProvider;
 import java.io.Serializable;
 import java.util.List;

File: src/com/google/inject/spi/ModuleWriter.java
Patch:
@@ -16,9 +16,6 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.common.collect.Maps;
 import com.google.inject.Binder;
 import com.google.inject.Binding;
 import com.google.inject.Key;
@@ -27,6 +24,9 @@
 import com.google.inject.Provider;
 import com.google.inject.Scope;
 import com.google.inject.binder.ScopedBindingBuilder;
+import com.google.inject.internal.Maps;
+import static com.google.inject.internal.Preconditions.checkArgument;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;

File: src/com/google/inject/spi/ProviderLookup.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import com.google.inject.Key;
 import com.google.inject.Provider;
+import static com.google.inject.internal.Preconditions.checkNotNull;
+import static com.google.inject.internal.Preconditions.checkState;
 
 /**
  * A lookup of the provider for a type. Lookups are created explicitly in a module using

File: src/com/google/inject/spi/ScopeBinding.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.Scope;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.lang.annotation.Annotation;
 
 /**

File: src/com/google/inject/spi/StaticInjectionRequest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.ConfigurationException;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.util.Set;
 
 /**

File: src/com/google/inject/spi/TypeConverterBinding.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.spi;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.TypeLiteral;
+import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 
 /**

File: test/com/google/inject/BinderTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import com.google.common.collect.Iterables;
 import static com.google.inject.Asserts.assertContains;
 import static com.google.inject.Asserts.assertNotSerializable;
+import com.google.inject.internal.Iterables;
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
 import com.google.inject.spi.Message;

File: test/com/google/inject/BinderTestSuite.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.ScopedBindingBuilder;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.Lists;
 import com.google.inject.name.Named;
 import static com.google.inject.name.Names.named;
 import com.google.inject.util.Providers;

File: test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
+import com.google.inject.internal.ImmutableMap;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.util.Modules;
 import java.util.Arrays;
 import java.util.Collection;

File: test/com/google/inject/MethodInterceptionTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableMap;
 import com.google.inject.matcher.Matchers;
 import static com.google.inject.matcher.Matchers.only;
 import com.google.inject.spi.ConstructorBinding;

File: test/com/google/inject/NullableInjectionPointTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.google.inject;
 
 import static com.google.inject.Asserts.assertContains;
+import com.google.inject.internal.Nullable;
 import junit.framework.TestCase;
 
 /**

File: test/com/google/inject/ParentInjectorTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
 import static com.google.inject.Asserts.assertContains;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.matcher.Matchers;
 import com.google.inject.name.Names;
 import com.google.inject.spi.TypeConverter;

File: test/com/google/inject/PrivateModuleTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableSet;
 import static com.google.inject.Asserts.assertContains;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
 import static com.google.inject.name.Names.named;

File: test/com/google/inject/ProxyFactoryTest.java
Patch:
@@ -17,8 +17,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.Lists;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.Lists;
 import static com.google.inject.matcher.Matchers.annotatedWith;
 import static com.google.inject.matcher.Matchers.any;
 import static com.google.inject.matcher.Matchers.not;

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.Maps;
 import static com.google.inject.Asserts.assertContains;
+import com.google.inject.internal.Maps;
 import java.io.IOException;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;

File: test/com/google/inject/TypeConversionTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.Iterables;
 import static com.google.inject.Asserts.assertContains;
+import com.google.inject.internal.Iterables;
 import com.google.inject.matcher.Matchers;
 import com.google.inject.spi.TypeConverter;
 import java.lang.annotation.Retention;

File: test/com/google/inject/TypeLiteralTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
 import static com.google.inject.Asserts.assertEqualsBothWays;
 import static com.google.inject.Asserts.assertNotSerializable;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.util.Types;
 import java.io.IOException;
 import java.lang.reflect.Type;

File: test/com/google/inject/TypeLiteralTypeResolutionTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableList;
 import static com.google.inject.Asserts.assertEqualsBothWays;
 import static com.google.inject.Asserts.assertNotSerializable;
+import com.google.inject.internal.ImmutableList;
 import com.google.inject.util.Types;
 import static com.google.inject.util.Types.arrayOf;
 import static com.google.inject.util.Types.listOf;

File: test/com/google/inject/name/NamesTest.java
Patch:
@@ -17,13 +17,13 @@
 
 package com.google.inject.name;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.inject.AbstractModule;
 import static com.google.inject.Asserts.assertEqualWhenReserialized;
 import static com.google.inject.Asserts.assertEqualsBothWays;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.internal.ImmutableMap;
 import java.io.IOException;
 import java.util.Map;
 import java.util.Properties;

File: test/com/google/inject/spi/ElementsTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.spi;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.Binding;
@@ -33,6 +32,7 @@
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.ConstantBindingBuilder;
 import com.google.inject.binder.ScopedBindingBuilder;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.matcher.Matchers;
 import com.google.inject.name.Names;

File: test/com/google/inject/spi/HasDependenciesTest.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.spi;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.inject.AbstractModule;
 import com.google.inject.Guice;
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.google.inject.Provider;
+import com.google.inject.internal.ImmutableSet;
+import com.google.inject.internal.Iterables;
 import java.util.Set;
 import junit.framework.TestCase;
 

File: test/com/google/inject/spi/InjectionPointTest.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.inject.spi;
 
-import com.google.common.collect.ImmutableSet;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.inject.Asserts.assertEqualsBothWays;
 import static com.google.inject.Asserts.assertSimilarWhenReserialized;
 import com.google.inject.Inject;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 import com.google.inject.internal.ErrorsException;
+import com.google.inject.internal.ImmutableSet;
+import static com.google.inject.internal.Iterables.getOnlyElement;
 import com.google.inject.name.Named;
 import static com.google.inject.name.Names.named;
 import java.io.IOException;

File: test/com/google/inject/spi/ProviderMethodsTest.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.inject.spi;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.inject.AbstractModule;
 import com.google.inject.Asserts;
 import com.google.inject.Binder;
@@ -31,6 +29,8 @@
 import com.google.inject.Provider;
 import com.google.inject.Provides;
 import com.google.inject.Singleton;
+import com.google.inject.internal.ImmutableList;
+import com.google.inject.internal.ImmutableSet;
 import com.google.inject.internal.ProviderMethod;
 import com.google.inject.internal.ProviderMethodsModule;
 import com.google.inject.name.Named;

File: src/com/google/inject/Binder.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
-import com.google.inject.PrivateBinder;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.TypeConverter;
@@ -188,6 +187,7 @@
  */
 public interface Binder {
 
+  /*if[AOP]*/
   /**
    * Binds a method interceptor to methods matched by class and method
    * matchers.
@@ -200,6 +200,7 @@ public interface Binder {
    */
   void bindInterceptor(Matcher<? super Class<?>> classMatcher,
       Matcher<? super Method> methodMatcher, MethodInterceptor... interceptors);
+  /*end[AOP]*/
 
   /**
    * Binds a scope to an annotation.

File: extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizRenderer.java
Patch:
@@ -143,7 +143,7 @@ protected String getNodeLabel(GraphvizNode node) {
     
     String subtitle = Join.join("<br align=\"left\"/>", node.getSubtitles());
     if (subtitle.length() != 0) {
-      html.append("<font align=\"left\" color=\"").append(node.getHeaderTextColor());
+      html.append("<font color=\"").append(node.getHeaderTextColor());
       html.append("\" point-size=\"10\">");
       html.append(subtitle).append("<br align=\"left\"/>").append("</font>");
     }

File: servlet/test/com/google/inject/servlet/ServletDispatchIntegrationTest.java
Patch:
@@ -93,7 +93,7 @@ protected void configureServlets() {
 
     assertTrue("lifecycle states did not fire correct number of times-- inits: " + inits + "; dos: "
             + services + "; destroys: " + destroys,
-        inits == 5 && services == 1 && destroys == 5);
+        inits == 2 && services == 1 && destroys == 2);
   }
 
   public final void testDispatchRequestToManagedPipelineWithFilter()
@@ -136,8 +136,8 @@ protected void configureServlets() {
     verify(requestMock);
 
     assertTrue("lifecycle states did not fire correct number of times-- inits: " + inits + "; dos: "
-            + services + "; destroys: " + destroys,
-        inits == 6 && services == 1 && destroys == 6 && doFilters == 1);
+            + services + "; destroys: " + destroys + "; doFilters: " + doFilters,
+        inits == 3 && services == 1 && destroys == 3 && doFilters == 1);
   }
 
   @Singleton

File: servlet/test/com/google/inject/servlet/VarargsServletDispatchIntegrationTest.java
Patch:
@@ -89,7 +89,7 @@ protected void configureServlets() {
 
     assertTrue("lifecycle states did not fire correct number of times-- inits: " + inits + "; dos: "
             + services + "; destroys: " + destroys,
-        inits == 6 && services == 1 && destroys == 6);
+        inits == 2 && services == 1 && destroys == 2);
   }
 
   public final void testVarargsSkipDispatchRequestToManagedPipelineServlets()
@@ -126,7 +126,7 @@ protected void configureServlets() {
 
     assertTrue("lifecycle states did not fire correct number of times-- inits: " + inits + "; dos: "
             + services + "; destroys: " + destroys,
-        inits == 7 && services == 1 && destroys == 7);
+        inits == 2 && services == 1 && destroys == 2);
   }
 
   public final void testDispatchRequestToManagedPipelineWithFilter()
@@ -167,7 +167,7 @@ protected void configureServlets() {
 
     assertTrue("lifecycle states did not fire correct number of times-- inits: " + inits + "; dos: "
             + services + "; destroys: " + destroys,
-        inits == 6 && services == 1 && destroys == 6 && doFilters == 1);
+        inits == 3 && services == 1 && destroys == 3 && doFilters == 1);
   }
 
   @Singleton

File: servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -73,8 +73,9 @@ protected final void configure() {
    *       <b>serve("/my/*").with(MyServlet.class)</b>
    * </pre>
    *
-   * Every servlet is required to be a singleton and will implicitly be bound as one if it isn't
-   * already. Mapping a servlet that is bound under any other scope is an error.
+   * Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
+   * directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in
+   * your module. Mapping a servlet that is bound under any other scope is an error.
    *
    * <p>
    * <h4>Dispatch Order</h4>

File: extensions/grapher/src/com/google/inject/grapher/NameFactory.java
Patch:
@@ -29,7 +29,7 @@
 public interface NameFactory {
   String getMemberName(Member member);
   String getClassName(Key<?> key);
-  String getClassName(Object instance);
+  String getInstanceName(Object instance);
   String getAnnotationName(Key<?> key);
   String getSourceName(Object source);
 }

File: extensions/grapher/src/com/google/inject/grapher/graphviz/ImplementationNodeFactory.java
Patch:
@@ -77,7 +77,7 @@ public void setClassKey(Key<?> key) {
     public void setInstance(Object instance) {
       node.setHeaderBackgroundColor("#aaaaaa");
       node.setHeaderTextColor("#ffffff");
-      node.setTitle(nameFactory.getClassName(instance));
+      node.setTitle(nameFactory.getInstanceName(instance));
     }
 
     public void setSource(Object source) {

File: src/com/google/inject/CreationException.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject;
 
-import com.google.common.collect.ImmutableSet;
 import static com.google.common.base.Preconditions.checkArgument;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.internal.Errors;
 import com.google.inject.spi.Message;
 import java.util.Collection;
@@ -33,7 +33,7 @@ public class CreationException extends RuntimeException {
   private final ImmutableSet<Message> messages;
 
   /** Creates a CreationException containing {@code messages}. */
-  public CreationException(Iterable<Message> messages) {
+  public CreationException(Collection<Message> messages) {
     this.messages = ImmutableSet.copyOf(messages);
     checkArgument(!this.messages.isEmpty());
     initCause(Errors.getOnlyCause(this.messages));

File: servlet/test/com/google/inject/servlet/ServletDispatchIntegrationTest.java
Patch:
@@ -65,7 +65,7 @@ protected void configureServlets() {
 
         // These servets should never fire... (ordering test)
         serve("*.html").with(NeverServlet.class);
-        serve("/*").with(Key.get(NeverServlet.class));
+        serve("/test/*").with(Key.get(NeverServlet.class));
         serve("/index/*").with(Key.get(NeverServlet.class));
         serve("*.jsp").with(Key.get(NeverServlet.class));
       }
@@ -108,7 +108,7 @@ protected void configureServlets() {
 
         // These servets should never fire...
         serve("*.html").with(NeverServlet.class);
-        serve("/*").with(Key.get(NeverServlet.class));
+        serve("/test/*").with(Key.get(NeverServlet.class));
         serve("/index/*").with(Key.get(NeverServlet.class));
         serve("*.jsp").with(Key.get(NeverServlet.class));
 

File: servlet/test/com/google/inject/servlet/VarargsServletDispatchIntegrationTest.java
Patch:
@@ -64,7 +64,7 @@ protected void configureServlets() {
         serve("/*", "/index.html").with(TestServlet.class);
 
         // These servets should never fire... (ordering test)
-        serve("*.html", "/*", "/index/*", "*.jsp").with(Key.get(NeverServlet.class));
+        serve("*.html", "/o/*", "/index/*", "*.jsp").with(Key.get(NeverServlet.class));
       }
     });
 
@@ -140,7 +140,7 @@ protected void configureServlets() {
         serve("/*").with(TestServlet.class);
 
         // These servets should never fire...
-        serve("*.html", "/*", "/index/*", "*.jsp").with(Key.get(NeverServlet.class));
+        serve("*.html", "/y/*", "/index/*", "*.jsp").with(Key.get(NeverServlet.class));
 
       }
     });

File: servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -73,6 +73,7 @@ public void through(Key<? extends Filter> filterKey) {
 
     public void through(Class<? extends Filter> filterKey,
         Map<String, String> contextParams) {
+      
       // Careful you don't accidentally make this method recursive, thank you IntelliJ IDEA!
       through(Key.get(filterKey), contextParams);
     }

File: servlet/test/com/google/inject/servlet/AllTests.java
Patch:
@@ -39,6 +39,7 @@ public static Test suite() {
     suite.addTestSuite(ServletDefinitionPathsTest.class);
     suite.addTestSuite(ServletPipelineRequestDispatcherTest.class);
     suite.addTestSuite(ServletDispatchIntegrationTest.class);
+    suite.addTestSuite(InvalidScopeBindingTest.class);
 
     // Varargs URL mapping tests.
     suite.addTestSuite(VarargsFilterDispatchIntegrationTest.class);

File: servlet/test/com/google/inject/servlet/FilterDispatchIntegrationTest.java
Patch:
@@ -39,7 +39,7 @@ public final void setUp() {
     doFilters = 0;
     destroys = 0;
 
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
   }
 
 

File: servlet/test/com/google/inject/servlet/FilterPipelineTest.java
Patch:
@@ -33,7 +33,7 @@ public class FilterPipelineTest extends TestCase {
 
   @Override
   public final void setUp() {
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
     
     Guice.createInjector(new ServletModule() {
 
@@ -53,7 +53,7 @@ protected void configureServlets() {
 
   @Override
   public final void tearDown() {
-    GuiceFilter.clearPipeline();    
+    GuiceFilter.reset();
   }
 
   public final void testDispatchThruGuiceFilter() throws ServletException, IOException {

File: servlet/test/com/google/inject/servlet/MultiModuleDispatchIntegrationTest.java
Patch:
@@ -38,7 +38,7 @@ public final void setUp() {
     doFilters = 0;
     destroys = 0;
 
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
   }
 
 

File: servlet/test/com/google/inject/servlet/ServletDefinitionTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import com.google.inject.Injector;
 import com.google.inject.Key;
+import com.google.inject.Binding;
 import junit.framework.TestCase;
 
 import java.util.Enumeration;
@@ -42,6 +43,8 @@ public class ServletDefinitionTest extends TestCase {
   public final void testServletInitAndConfig() throws ServletException {
     Injector injector = createMock(Injector.class);
 
+    expect(injector.getBinding(Key.get(HttpServlet.class)))
+        .andReturn(createMock(Binding.class));
     final HttpServlet mockServlet = new HttpServlet() {
     };
     expect(injector.getInstance(Key.get(HttpServlet.class)))

File: servlet/test/com/google/inject/servlet/ServletDispatchIntegrationTest.java
Patch:
@@ -52,7 +52,7 @@ public void setUp() {
     destroys = 0;
     doFilters = 0;
 
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
   }
 
   public final void testDispatchRequestToManagedPipelineServlets()

File: servlet/test/com/google/inject/servlet/ServletTest.java
Patch:
@@ -48,7 +48,7 @@ public class ServletTest extends TestCase {
   @Override
   public void setUp() {
     //we need to clear the reference to the pipeline every test =(
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
   }
 
   public void testNewRequestObject()

File: servlet/test/com/google/inject/servlet/VarargsFilterDispatchIntegrationTest.java
Patch:
@@ -38,7 +38,7 @@ public final void setUp() {
     doFilters = 0;
     destroys = 0;
 
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
   }
 
 

File: servlet/test/com/google/inject/servlet/VarargsServletDispatchIntegrationTest.java
Patch:
@@ -52,7 +52,7 @@ public void setUp() {
     destroys = 0;
     doFilters = 0;
 
-    GuiceFilter.clearPipeline();
+    GuiceFilter.reset();
   }
 
   public final void testDispatchRequestToManagedPipelineServlets()

File: src/com/google/inject/AbstractProcessor.java
Patch:
@@ -22,7 +22,7 @@
 import com.google.inject.spi.InjectionRequest;
 import com.google.inject.spi.InterceptorBinding;
 import com.google.inject.spi.Message;
-import com.google.inject.spi.PrivateEnvironment;
+import com.google.inject.spi.PrivateElements;
 import com.google.inject.spi.ProviderLookup;
 import com.google.inject.spi.ScopeBinding;
 import com.google.inject.spi.StaticInjectionRequest;
@@ -104,7 +104,7 @@ public <T> Boolean visitProviderLookup(ProviderLookup<T> providerLookup) {
     return false;
   }
 
-  public Boolean visitPrivateEnvironment(PrivateEnvironment privateEnvironment) {
+  public Boolean visitPrivateElements(PrivateElements privateElements) {
     return false;
   }
 }

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -22,8 +22,6 @@
 import com.google.inject.internal.InternalContext;
 import com.google.inject.internal.InternalFactory;
 import com.google.inject.spi.Dependency;
-import com.google.inject.spi.PrivateEnvironment;
-import java.util.Map;
 
 /**
  * Delegates to a custom factory which is also bound in the injector.
@@ -44,7 +42,7 @@ class BoundProviderFactory<T> implements InternalFactory<T>, CreationListener {
     this.source = source;
   }
 
-  public void notify(Map<PrivateEnvironment, InjectorImpl> privateInjectors, Errors errors) {
+  public void notify(Errors errors) {
     try {
       providerFactory = injector.getInternalFactory(providerKey, errors.withSource(source));
     } catch (ErrorsException e) {

File: src/com/google/inject/ClassBindingImpl.java
Patch:
@@ -69,8 +69,8 @@ public Set<Dependency<?>> getDependencies() {
   @Override public String toString() {
     return new ToStringBuilder(ConstructorBinding.class)
         .add("key", getKey())
-        .add("scope", getScoping())
         .add("source", getSource())
+        .add("scope", getScoping())
         .toString();
   }
 }

File: src/com/google/inject/FactoryProxy.java
Patch:
@@ -23,8 +23,6 @@
 import com.google.inject.internal.InternalFactory;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.Dependency;
-import com.google.inject.spi.PrivateEnvironment;
-import java.util.Map;
 
 /**
  * A placeholder which enables us to swap in the real factory once the injector is created.
@@ -45,7 +43,7 @@ class FactoryProxy<T> implements InternalFactory<T>, BindingProcessor.CreationLi
     this.source = source;
   }
 
-  public void notify(Map<PrivateEnvironment, InjectorImpl> privateInjectors, final Errors errors) {
+  public void notify(final Errors errors) {
     try {
       targetFactory = injector.getInternalFactory(targetKey, errors.withSource(source));
     } catch (ErrorsException e) {

File: src/com/google/inject/internal/BindingBuilder.java
Patch:
@@ -28,7 +28,7 @@
 import com.google.inject.spi.Element;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;
-import com.google.inject.spi.PrivateEnvironment;
+import com.google.inject.spi.PrivateElements;
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Set;
@@ -131,13 +131,13 @@ public BindingBuilder<T> toProvider(Key<? extends Provider<? extends T>> provide
     return this;
   }
 
-  public ExposureBuilder<T> usingKeyFrom(PrivateEnvironment privateEnvironment) {
+  public ExposureBuilder<T> usingKeyFrom(PrivateElements privateElements) {
     checkNotTargetted();
     checkNotScoped();
 
     BindingImpl<T> base = getBinding();
     ExposedBindingImpl<T> exposedBinding = new ExposedBindingImpl<T>(
-        base.getSource(), base.getKey(), base.getScoping(), privateEnvironment);
+        base.getSource(), base.getKey(), base.getScoping(), privateElements);
     setBinding(exposedBinding);
 
     return new ExposureBuilder<T>(this, exposedBinding);

File: src/com/google/inject/internal/InstanceBindingImpl.java
Patch:
@@ -84,8 +84,8 @@ public BindingImpl<T> withKey(Key<T> key) {
   @Override public String toString() {
     return new ToStringBuilder(InstanceBinding.class)
         .add("key", getKey())
-        .add("instance", instance)
         .add("source", getSource())
+        .add("instance", instance)
         .toString();
   }
 }

File: src/com/google/inject/internal/LinkedBindingImpl.java
Patch:
@@ -56,9 +56,9 @@ public BindingImpl<T> withKey(Key<T> key) {
   @Override public String toString() {
     return new ToStringBuilder(LinkedKeyBinding.class)
         .add("key", getKey())
-        .add("target", targetKey)
-        .add("scope", getScoping())
         .add("source", getSource())
+        .add("scope", getScoping())
+        .add("target", targetKey)
         .toString();
   }
 }

File: src/com/google/inject/internal/LinkedProviderBindingImpl.java
Patch:
@@ -59,9 +59,9 @@ public BindingImpl<T> withKey(Key<T> key) {
   @Override public String toString() {
     return new ToStringBuilder(ProviderKeyBinding.class)
         .add("key", getKey())
-        .add("provider", providerKey)
-        .add("scope", getScoping())
         .add("source", getSource())
+        .add("scope", getScoping())
+        .add("provider", providerKey)
         .toString();
   }
 }

File: src/com/google/inject/internal/ProviderInstanceBindingImpl.java
Patch:
@@ -81,9 +81,9 @@ public BindingImpl<T> withKey(Key<T> key) {
   public String toString() {
     return new ToStringBuilder(ProviderInstanceBinding.class)
         .add("key", getKey())
-        .add("provider", providerInstance)
-        .add("scope", getScoping())
         .add("source", getSource())
+        .add("scope", getScoping())
+        .add("provider", providerInstance)
         .toString();
   }
 }

File: src/com/google/inject/spi/DefaultElementVisitor.java
Patch:
@@ -69,7 +69,7 @@ public V visitStaticInjectionRequest(StaticInjectionRequest staticInjectionReque
     return visitElement(staticInjectionRequest);
   }
 
-  public V visitPrivateEnvironment(PrivateEnvironment privateEnvironment) {
-    return visitElement(privateEnvironment);
+  public V visitPrivateElements(PrivateElements privateElements) {
+    return visitElement(privateElements);
   }
 }

File: src/com/google/inject/spi/ElementVisitor.java
Patch:
@@ -72,5 +72,5 @@ public interface ElementVisitor<V> {
   /**
    * Visit a collection of configuration elements for a private environment.
    */
-  V visitPrivateEnvironment(PrivateEnvironment privateEnvironment);
+  V visitPrivateElements(PrivateElements privateElements);
 }

File: src/com/google/inject/spi/ExposedBinding.java
Patch:
@@ -29,6 +29,6 @@ public interface ExposedBinding<T> extends Binding<T>, HasDependencies {
   /**
    * Returns the enclosed environment that holds the original binding.
    */
-  PrivateEnvironment getPrivateEnvironment();
+  PrivateElements getPrivateElements();
 
 }
\ No newline at end of file

File: servlet/src/com/google/inject/servlet/FilterChainInvocation.java
Patch:
@@ -57,8 +57,7 @@ public void doFilter(ServletRequest servletRequest, ServletResponse servletRespo
     //dispatch down the chain while there are more filters
     if (index < filterDefinitions.size()) {
       filterDefinitions.get(index).doFilter(servletRequest, servletResponse, this);
-    }
-    else {
+    } else {
 
       //we've reached the end of the filterchain, let's try to dispatch to a servlet
       final boolean serviced = servletPipeline.service(servletRequest, servletResponse);

File: servlet/src/com/google/inject/servlet/FiltersModuleBuilder.java
Patch:
@@ -78,7 +78,7 @@ public void through(Key<? extends Filter> filterKey,
 
       for (String pattern : uriPatterns) {
         filterDefinitions.add(
-            new FilterDefinition(pattern, filterKey, UriPatternType.get(uriPatternType),
+            new FilterDefinition(pattern, filterKey, UriPatternType.get(uriPatternType, pattern),
                 contextParams));
       }
     }

File: servlet/src/com/google/inject/servlet/ManagedFilterPipeline.java
Patch:
@@ -41,7 +41,6 @@
 class ManagedFilterPipeline implements FilterPipeline{
   private final List<FilterDefinition> filterDefinitions;
 
-  //TODO make these setter for testing?
   @Inject
   private final ManagedServletPipeline servletPipeline = null;
 
@@ -86,7 +85,7 @@ public void dispatch(ServletRequest request, ServletResponse response,
       initPipeline(servletContext.get());
     }
 
-    //obtain the servlet pipeline to dispatch against (we use getInstance() to avoid holding refs)
+    //obtain the servlet pipeline to dispatch against
     new FilterChainInvocation(filterDefinitions, servletPipeline, proceedingFilterChain)
         .doFilter(withDispatcher(request, servletPipeline), response);
 

File: servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -38,8 +38,7 @@
  * objects so you can inject the request, response, session, etc.
  *
  * <p>
- * <strong>
- * As of Guice 2.0, you can subclass this module to register servlets and
+ * You should subclass this module to register servlets and
  * filters in the {@link #configureServlets()} method.
  *
  * @author crazybob@google.com (Bob Lee)

File: servlet/src/com/google/inject/servlet/ServletsModuleBuilder.java
Patch:
@@ -77,7 +77,7 @@ public void with(Key<? extends HttpServlet> servletKey,
 
       for (String pattern : uriPatterns) {
         servletDefinitions.add(
-            new ServletDefinition(pattern, servletKey, UriPatternType.get(uriPatternType),
+            new ServletDefinition(pattern, servletKey, UriPatternType.get(uriPatternType, pattern),
                 contextParams));
       }
     }

File: servlet/test/com/google/inject/servlet/ServletDefinitionPathsTest.java
Patch:
@@ -84,7 +84,7 @@ protected void service(HttpServletRequest servletRequest,
     replay(injector, request);
 
     ServletDefinition servletDefinition = new ServletDefinition(mapping, Key.get(HttpServlet.class),
-        UriPatternType.get(UriPatternType.SERVLET), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.SERVLET, mapping), new HashMap<String, String>());
 
     servletDefinition.init(null, injector);
     servletDefinition.doService(request, response);
@@ -167,7 +167,7 @@ protected void service(HttpServletRequest servletRequest,
     replay(injector, request);
 
     ServletDefinition servletDefinition = new ServletDefinition(mapping, Key.get(HttpServlet.class),
-        UriPatternType.get(UriPatternType.SERVLET), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.SERVLET, mapping), new HashMap<String, String>());
 
     servletDefinition.init(null, injector);
     servletDefinition.doService(request, response);
@@ -250,7 +250,7 @@ protected void service(HttpServletRequest servletRequest,
     replay(injector, request);
 
     ServletDefinition servletDefinition = new ServletDefinition(mapping, Key.get(HttpServlet.class),
-        UriPatternType.get(UriPatternType.REGEX), new HashMap<String, String>());
+        UriPatternType.get(UriPatternType.REGEX, mapping), new HashMap<String, String>());
 
     servletDefinition.init(null, injector);
     servletDefinition.doService(request, response);

File: servlet/test/com/google/inject/servlet/ServletDefinitionTest.java
Patch:
@@ -62,8 +62,9 @@ public final void testServletInitAndConfig() throws ServletException {
       }
     };
 
-    final ServletDefinition servletDefinition = new ServletDefinition("/*",
-        Key.get(HttpServlet.class), UriPatternType.get(UriPatternType.SERVLET), initParams);
+    String pattern = "/*";
+    final ServletDefinition servletDefinition = new ServletDefinition(pattern,
+        Key.get(HttpServlet.class), UriPatternType.get(UriPatternType.SERVLET, pattern), initParams);
 
     ServletContext servletContext = createMock(ServletContext.class);
     final String contextName = "thing__!@@44__SRV" + getClass();

File: extensions/commands/src/com/google/inject/commands/intercepting/InterceptingInjectorBuilder.java
Patch:
@@ -167,7 +167,8 @@ private class ModuleRewriter extends ModuleWriter {
       }
 
       binding.acceptTargetVisitor(new DefaultBindingTargetVisitor<T, Void>() {
-        @Override public Void visitUntargetted(UntargettedBinding<T> tUntargettedBinding) {
+        @Override public Void visitUntargetted(
+            UntargettedBinding<? extends T> tUntargettedBinding) {
           throw new UnsupportedOperationException(
               String.format("Cannot intercept bare binding of %s.", key));
         }

File: src/com/google/inject/Binding.java
Patch:
@@ -80,7 +80,7 @@ public interface Binding<T> extends Element {
    * @param visitor to call back on
    * @since 2.0
    */
-  <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor);
+  <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor);
 
   /**
    * Accepts a scoping visitor. Invokes the visitor method specific to this binding's scoping.

File: src/com/google/inject/ClassBindingImpl.java
Patch:
@@ -49,7 +49,7 @@ class ClassBindingImpl<T> extends BindingImpl<T> implements ConstructorBinding<T
     injectionPoints = lateBoundConstructor.constructorInjector.getInjectionPoints();
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     checkState(injectionPoints != null, "not initialized");
     return visitor.visitConstructor(this);
   }

File: src/com/google/inject/internal/ExposedBindingImpl.java
Patch:
@@ -41,7 +41,7 @@ public ExposedBindingImpl(Object source, Key<T> key, Scoping scoping,
     this.privateEnvironment = privateEnvironment;
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     return visitor.visitExposed(this);
   }
 

File: src/com/google/inject/internal/InstanceBindingImpl.java
Patch:
@@ -55,7 +55,7 @@ public InstanceBindingImpl(Object source, Key<T> key, Scoping scoping,
     return this.provider;
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     return visitor.visitInstance(this);
   }
 

File: src/com/google/inject/internal/LinkedBindingImpl.java
Patch:
@@ -37,7 +37,7 @@ public LinkedBindingImpl(Object source, Key<T> key, Scoping scoping, Key<? exten
     this.targetKey = targetKey;
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     return visitor.visitLinkedKey(this);
   }
 

File: src/com/google/inject/internal/LinkedProviderBindingImpl.java
Patch:
@@ -40,7 +40,7 @@ public LinkedProviderBindingImpl(Injector injector, Key<T> key, Object source,
     this.providerKey = providerKey;
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     return visitor.visitProviderKey(this);
   }
 

File: src/com/google/inject/internal/ProviderInstanceBindingImpl.java
Patch:
@@ -49,7 +49,7 @@ public ProviderInstanceBindingImpl(Object source, Key<T> key, Scoping scoping,
     this.providerInstance = providerInstance;
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     return visitor.visitProviderInstance(this);
   }
 

File: src/com/google/inject/internal/UntargettedBindingImpl.java
Patch:
@@ -36,7 +36,7 @@ public UntargettedBindingImpl(Object source, Key<T> key, Scoping scoping) {
     super(source, key, scoping);
   }
 
-  public <V> V acceptTargetVisitor(BindingTargetVisitor<T, V> visitor) {
+  public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {
     return visitor.visitUntargetted(this);
   }
 

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -61,11 +61,11 @@
 public final class Elements {
   private static final BindingTargetVisitor<Object, Object> GET_INSTANCE_VISITOR
       = new DefaultBindingTargetVisitor<Object, Object>() {
-    @Override public Object visitInstance(InstanceBinding<Object> binding) {
+    @Override public Object visitInstance(InstanceBinding<?> binding) {
       return binding.getInstance();
     }
 
-    @Override protected Object visitOther(Binding<Object> binding) {
+    @Override protected Object visitOther(Binding<?> binding) {
       throw new IllegalArgumentException();
     }
   };

File: src/com/google/inject/spi/ProviderBinding.java
Patch:
@@ -27,13 +27,12 @@
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0
  */
-public interface ProviderBinding<T> extends Binding<Provider<T>> {
+public interface ProviderBinding<T extends Provider<?>> extends Binding<T> {
 
   /**
    * Returns the key whose binding is used to {@link Provider#get provide instances}. That binding
    * can be retrieved from an injector using {@link com.google.inject.Injector#getBinding(Key)
    * Injector.getBinding(providedKey)}
    */
-  Key<? extends T> getProvidedKey();
-
+  Key<?> getProvidedKey();
 }
\ No newline at end of file

File: test/com/google/inject/spi/FailingTargetVisitor.java
Patch:
@@ -20,7 +20,7 @@
 import junit.framework.AssertionFailedError;
 
 public class FailingTargetVisitor<T> extends DefaultBindingTargetVisitor<T, Void> {
-  @Override protected Void visitOther(Binding<T> binding) {
+  @Override protected Void visitOther(Binding<? extends T> binding) {
     throw new AssertionFailedError();
   }
 }

File: extensions/assistedinject/src/com/google/inject/assistedinject/AssistedInject.java
Patch:
@@ -22,8 +22,8 @@
 import java.lang.annotation.Target;
 
 /**
- * <p>Constructors annotated with {@code @AssistedInject} indicate that will can be instantiated by
- * the {@link FactoryProvider}. Each constructor must exactly one corresponding factory method
+ * <p>Constructors annotated with {@code @AssistedInject} indicate that they can be instantiated by
+ * the {@link FactoryProvider}. Each constructor must exactly match one corresponding factory method
  * within the factory interface.
  * 
  * <p>Constructor parameters must be either supplied by the factory interface and marked with
@@ -40,4 +40,4 @@
 @Target({CONSTRUCTOR})
 @Retention(RUNTIME)
 @Deprecated
-public @interface AssistedInject {}
\ No newline at end of file
+public @interface AssistedInject {}

File: extensions/commands/src/com/google/inject/commands/intercepting/InterceptingInjectorBuilder.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.inject.Module;
 import com.google.inject.ProvidedBy;
 import com.google.inject.Provider;
+import com.google.inject.Provides;
 import com.google.inject.TypeLiteral;
 import com.google.inject.binder.ScopedBindingBuilder;
 import com.google.inject.internal.UniqueAnnotations;
@@ -59,8 +60,8 @@
  * <pre class="code">bind(MyServiceClass.class);</pre>
  *
  * <p>All intercepted bindings must be bound explicitly. Interception cannot
- * be applied to implicit bindings, or bindings that depend on
- * {@literal @}{@link ProvidedBy}, {@literal @}{@link ImplementedBy}
+ * be applied to implicit bindings, or bproindings that depend on
+ * {@literal @}{@link ProvidedBy}, {@literal @}{@link ImplementedBy}, {@literal @}{@link Provides}
  * annotations.
  *
  * <p><strong>Implementation note:</strong> To intercept provision, an

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java
Patch:
@@ -74,9 +74,9 @@
  *
  * <p>Values are resolved at map injection time. If a value is bound to a
  * provider, that provider's get method will be called each time the map is
- * injected (unless the binding is also scoped).
+ * injected (unless the binding is also scoped, or a map of providers is injected).
  *
- * <p>Annotations are be used to create different maps of the same key/value
+ * <p>Annotations are used to create different maps of the same key/value
  * type. Each distinct annotation gets its own independent map.
  *
  * <p><strong>Keys must be distinct.</strong> If the same key is bound more than

File: extensions/throwingproviders/src/com/google/inject/throwingproviders/ThrowingProviderBinder.java
Patch:
@@ -35,7 +35,7 @@
 import java.lang.reflect.TypeVariable;
 
 /**
- * <p>Builds a binding for an {@link ThrowingProvider} using a fluent API:
+ * <p>Builds a binding for a {@link ThrowingProvider} using a fluent API:
  * <pre><code>ThrowingProviderBinder.create(binder())
  *    .bind(RemoteProvider.class, Customer.class)
  *    .to(RemoteCustomerProvider.class)

File: src/com/google/inject/Guice.java
Patch:
@@ -63,7 +63,7 @@ public static Injector createInjector(Module... modules) {
    * Creates an injector for the given set of modules.
    *
    * @throws CreationException if one or more errors occur during Injector
-   *     construction
+   *     creation
    */
   public static Injector createInjector(Iterable<? extends Module> modules) {
     return createInjector(Stage.DEVELOPMENT, modules);
@@ -74,7 +74,7 @@ public static Injector createInjector(Iterable<? extends Module> modules) {
    * stage.
    *
    * @throws CreationException if one or more errors occur during Injector
-   *     construction
+   *     creation
    */
   public static Injector createInjector(Stage stage, Module... modules) {
     return createInjector(stage, Arrays.asList(modules));

File: src/com/google/inject/Module.java
Patch:
@@ -33,7 +33,7 @@
 public interface Module {
 
   /**
-   * Contributes bindings and other configurations for this module to a {@code Binder}.
+   * Contributes bindings and other configurations for this module to {@code binder}.
    *
    * <p><strong>Do not invoke this method directly</strong> to install submodules. Instead use
    * {@link Binder#install(Module)}, which ensures that {@link Provides provider methods} are

File: src/com/google/inject/Provider.java
Patch:
@@ -38,7 +38,7 @@
  * for a given key, via the {@link Injector#getProvider} methods.
  * </ul>
  *
- * @param <T> the type of object this provider provides
+ * @param <T> the type of object this provides
  *
  * @author crazybob@google.com (Bob Lee)
  */

File: src/com/google/inject/binder/PrivateBinder.java
Patch:
@@ -30,7 +30,7 @@
 public interface PrivateBinder extends Binder {
 
   /** Makes the binding for {@code key} available to the enclosing environment */
-  void expose(Key<?> type);
+  void expose(Key<?> key);
 
   /**
    * Makes a binding for {@code type} available to the enclosing environment. Use {@link

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -278,8 +278,8 @@ public PrivateBinder newPrivateBinder() {
       return new RecordingBinder(this, privateEnvironment);
     }
 
-    public void expose(Key<?> type) {
-      exposeInternal(type);
+    public void expose(Key<?> key) {
+      exposeInternal(key);
     }
 
     public AnnotatedElementBuilder expose(Class<?> type) {

File: servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -51,6 +51,7 @@ public class ServletModule extends AbstractModule {
   @Override
   protected final void configure() {
     // Install the filter and servlet bindings.
+    configureServlets();
     install(filtersModuleBuilder);
     install(servletsModuleBuilder);
 

File: servlet/src/com/google/inject/servlet/FilterPipeline.java
Patch:
@@ -29,19 +29,18 @@
  * words, we dispatch directly to the web.xml pipeline after setting up scopes.
  *
  * <p>
- * If on the other hand, {@link Servlets#configure} is used to register managed
+ * If on the other hand, {@link ServletModule} is used to register managed
  * servlets and/or filters, then a different pipeline is bound instead. Which,
  * after dispatching to Guice-injected filters and servlets continues to the web.xml
  * pipeline (if necessary).
  *
  * @author dhanji@gmail.com (Dhanji R. Prasanna)
- * @see com.google.inject.servlet.ManagedFilterPipeline Guice Servlet 2.0 Pipeline.
  */
 @ImplementedBy(DefaultFilterPipeline.class)
 interface FilterPipeline {
   void initPipeline(ServletContext context) throws ServletException;
   void destroyPipeline();
 
   void dispatch(ServletRequest request, ServletResponse response,
-      FilterChain proceedingFilterChain) throws IOException, ServletException;
+      FilterChain defaultFilterChain) throws IOException, ServletException;
 }

File: servlet/test/com/google/inject/servlet/ServletTest.java
Patch:
@@ -186,7 +186,7 @@ private Injector createInjector() throws CreationException {
 
       @Override
       protected void configure() {
-        install(Servlets.configure().filters().buildModule());
+        install(new ServletModule());
         bind(InSession.class);
         bind(InRequest.class);
       }

File: src/com/google/inject/Binder.java
Patch:
@@ -149,7 +149,7 @@
  * <pre>
  *   {@literal @}Color("red") Color red; // A member variable (field)
  *    . . .
- *     red = MyModule.class.getField("red").getAnnotation(Color.class);
+ *     red = MyModule.class.getDeclaredField("red").getAnnotation(Color.class);
  *     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>
  *
  * If your binding annotation has parameters you can apply different bindings to

File: src/com/google/inject/Guice.java
Patch:
@@ -39,7 +39,7 @@
  *         );
  *
  *         // Now just bootstrap the application and you're done
- *         MyStartClass starter = injector.getInstance(MyStartClass.class);
+ *         FooStarter starter = injector.getInstance(FooStarter.class);
  *         starter.runApplication();
  *       }
  *     }

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -68,7 +68,7 @@
  * <h3>Configuring factories</h3>
  * In your {@link com.google.inject.Module module}, bind the factory interface to the returned
  * factory:
- * <pre>bind(PaymentFactory.class).toInstance(
+ * <pre>bind(PaymentFactory.class).toProvider(
  *     FactoryProvider.newFactory(PaymentFactory.class, RealPayment.class));</pre>
  * As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
  * factory cannot be used until the injector has been initialized.

File: test/com/google/inject/BinderTestSuite.java
Patch:
@@ -419,7 +419,8 @@ public void test() throws IllegalAccessException, InstantiationException {
       injector = newInjector();
       nextId.set(201);
       for (Object value : expectedValues) {
-        assertEquals(value, injector.getInstance(injectsKey).value);
+        Injectable instance = injector.getInstance(injectsKey);
+        assertEquals(value, instance.value);
       }
 
       injector = newInjector();

File: test/com/google/inject/RequestInjectionTest.java
Patch:
@@ -130,7 +130,7 @@ protected void configure() {
       fail();
     } catch (CreationException expected) {
       assertContains(expected.getMessage(),
-          "1) Error injecting method, java.lang.UnsupportedOperationException: Pop\n",
+          "1) Error injecting method, java.lang.UnsupportedOperationException: Pop",
           "at " + BlowsUpOnInject.class.getName() + ".injectInstance(RequestInjectionTest.java:");
     }
   }

File: src/com/google/inject/TypeLiteral.java
Patch:
@@ -49,6 +49,7 @@
  * {@link Object#hashCode()} as value (as opposed to identity) comparison.
  *
  * @author crazybob@google.com (Bob Lee)
+ * @author jessewilson@google.com (Jesse Wilson)
  */
 public class TypeLiteral<T> {
 

File: src/com/google/inject/internal/BytecodeGen.java
Patch:
@@ -149,7 +149,6 @@ public static FastClass newFastClass(Class<?> type, Visibility visibility) {
   public static Enhancer newEnhancer(Class<?> type, Visibility visibility) {
     Enhancer enhancer = new Enhancer();
     enhancer.setSuperclass(type);
-    enhancer.setUseCache(false); // We do enough caching.
     enhancer.setUseFactory(false);
     if (visibility == Visibility.PUBLIC) {
       enhancer.setClassLoader(getClassLoader(type));

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -62,7 +62,7 @@ public Constructor<T> getConstructor() {
 
     return new ConstructionProxy<T>() {
       Class<T> classToConstruct = constructor.getDeclaringClass();
-      FastClass fastClass = newFastClass(classToConstruct, Visibility.PUBLIC);
+      FastClass fastClass = newFastClass(classToConstruct, Visibility.forMember(constructor));
       final FastConstructor fastConstructor = fastClass.getConstructor(constructor);
 
       @SuppressWarnings("unchecked")

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -94,7 +94,7 @@ <T> ConstructionProxy<T> createConstructionProxy(InjectionPoint injectionPoint)
       indices.put(method, i);
     }
 
-    // true if all the methods we're intercepting are public. This impacts which classloader we
+    // PUBLIC if all the methods we're intercepting are public. This impacts which classloader we
     // should use for loading the enhanced class
     Visibility visibility = Visibility.PUBLIC;
 
@@ -154,7 +154,7 @@ private <T> ConstructionProxy<T> createConstructionProxy(final Class<?> clazz,
       final InjectionPoint injectionPoint) {
     @SuppressWarnings("unchecked") // injection point's member must be a Constructor<T>
     final Constructor<T> standardConstructor = (Constructor<T>) injectionPoint.getMember();
-    FastClass fastClass = newFastClass(clazz, Visibility.PUBLIC);
+    FastClass fastClass = newFastClass(clazz, Visibility.forMember(standardConstructor));
     final FastConstructor fastConstructor
         = fastClass.getConstructor(standardConstructor.getParameterTypes());
 

File: test/com/googlecode/guice/PackageVisibilityTestModule.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.inject.AbstractModule;
 import com.google.inject.Inject;
 
-public class PackageVisilibityTestModule extends AbstractModule {
+public class PackageVisibilityTestModule extends AbstractModule {
 
   @Override
   protected void configure() {
@@ -12,6 +12,7 @@ protected void configure() {
 
   public static class PublicUserOfPackagePrivate {
     @Inject public PublicUserOfPackagePrivate(PackagePrivateInterface ppi) {}
+    @Inject public void acceptPackagePrivateParameter(PackagePrivateInterface ppi) {}
   }
 
   interface PackagePrivateInterface {}

File: test/com/google/inject/PrivateModuleTest.java
Patch:
@@ -147,13 +147,13 @@ public void configurePrivateBindings() {}
     assertEquals("i", injector.getInstance(Key.get(String.class, named("a"))));
 
     try {
-      injector.getInstance(Key.get(String.class, named("c")));
+      injector.getInstance(Key.get(String.class, named("b")));
       fail();
     } catch(ConfigurationException expected) {
     }
 
     try {
-      injector.getInstance(Key.get(String.class, named("d")));
+      injector.getInstance(Key.get(String.class, named("c")));
       fail();
     } catch(ConfigurationException expected) {
     }

File: extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.Provider;
+import com.google.inject.internal.Errors;
 import com.google.inject.spi.Message;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationHandler;
@@ -238,6 +239,6 @@ public Object[] gatherArgsForConstructor(
   }
 
   private ConfigurationException newConfigurationException(String format, Object... args) {
-    return new ConfigurationException(ImmutableSet.of(new Message(String.format(format, args))));
+    return new ConfigurationException(ImmutableSet.of(new Message(Errors.format(format, args))));
   }
 }

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
 import com.google.inject.binder.LinkedBindingBuilder;
+import com.google.inject.internal.Errors;
 import com.google.inject.spi.Message;
 import com.google.inject.util.Types;
 import java.lang.annotation.Annotation;
@@ -275,7 +276,7 @@ static void checkConfiguration(boolean condition, String format, Object... args)
       return;
     }
 
-    throw new ConfigurationException(ImmutableSet.of(new Message(String.format(format, args))));
+    throw new ConfigurationException(ImmutableSet.of(new Message(Errors.format(format, args))));
   }
 
   static <T> T checkNotNull(T reference, String name) {

File: src/com/google/inject/binder/PrivateBinder.java
Patch:
@@ -21,8 +21,8 @@
 import com.google.inject.TypeLiteral;
 
 /**
- * Returns a binder whose configuration information is hidden from its environment. See {@link
- * com.google.inject.privatemodules.PrivateModule} for details.
+ * Returns a binder whose configuration information is hidden from its environment by default. See
+ * {@link com.google.inject.PrivateModule PrivateModule} for details.
  * 
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: src/com/google/inject/internal/Errors.java
Patch:
@@ -235,7 +235,7 @@ public Errors duplicateBindingAnnotations(Member member,
 
   public Errors duplicateScopeAnnotations(
       Class<? extends Annotation> a, Class<? extends Annotation> b) {
-    return addMessage("More than one scope annotation was found: %s and %s", a, b);
+    return addMessage("More than one scope annotation was found: %s and %s.", a, b);
   }
 
   public Errors recursiveBinding() {
@@ -394,7 +394,7 @@ public Errors addMessage(Message message) {
     return this;
   }
 
-  private String format(String messageFormat, Object... arguments) {
+  public static String format(String messageFormat, Object... arguments) {
     for (int i = 0; i < arguments.length; i++) {
       arguments[i] = Errors.convert(arguments[i]);
     }

File: src/com/google/inject/internal/MoreTypes.java
Patch:
@@ -74,8 +74,7 @@ private MoreTypes() {}
   public static <T> TypeLiteral<T> makeKeySafe(TypeLiteral<T> type) {
     if (!isFullySpecified(type.getType())) {
       String message = type + " cannot be used as a key; It is not fully specified.";
-      throw new ConfigurationException(ImmutableSet.of(
-          new Message(SourceProvider.UNKNOWN_SOURCE, message)));
+      throw new ConfigurationException(ImmutableSet.of(new Message(message)));
     }
 
     @SuppressWarnings("unchecked")

File: src/com/google/inject/spi/PrivateEnvironment.java
Patch:
@@ -27,7 +27,8 @@
 import java.util.Set;
 
 /**
- * A private environment for configuration information.
+ * A private environment whose configuration information is hidden from the enclosing environment
+ * by default. See {@link com.google.inject.PrivateModule PrivateModule} for details.
  *
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0

File: extensions/commands/src/com/google/inject/commands/intercepting/InterceptingInjectorBuilder.java
Patch:
@@ -31,7 +31,6 @@
 import com.google.inject.ProvidedBy;
 import com.google.inject.Provider;
 import com.google.inject.TypeLiteral;
-import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.binder.ScopedBindingBuilder;
 import com.google.inject.internal.UniqueAnnotations;
 import com.google.inject.name.Names;
@@ -175,8 +174,7 @@ private class ModuleRewriter extends ModuleWriter {
       Key<T> anonymousKey = Key.get(key.getTypeLiteral(), UniqueAnnotations.create());
       binder.bind(key).toProvider(new InterceptingProvider<T>(key, anonymousKey));
 
-      LinkedBindingBuilder<T> linkedBindingBuilder = binder.bind(anonymousKey);
-      ScopedBindingBuilder scopedBindingBuilder = applyTarget(binding, linkedBindingBuilder);
+      ScopedBindingBuilder scopedBindingBuilder = bindKeyToTarget(binding, binder, anonymousKey);
 
       // we scope the user's provider, not the interceptor. This is dangerous,
       // but convenient. It means that although the user's provider will live

File: extensions/privatemodules/test/com/google/inject/privatemodules/AllTests.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject.privatemodules;
 
+import com.google.inject.PrivateModuleTest;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 

File: src/com/google/inject/Binder.java
Patch:
@@ -304,8 +304,7 @@ void bindInterceptor(Matcher<? super Class<?>> classMatcher,
    * @param converter converts values
    * @since 2.0
    */
-  void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter converter);
+  void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher, TypeConverter converter);
 
   /**
    * Returns a binder that uses {@code source} as the reference location for

File: src/com/google/inject/Exposed.java
Patch:
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.google.inject.privatemodules;
+package com.google.inject;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
-import java.lang.annotation.Documented;
 
 /**
  * Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a

File: src/com/google/inject/internal/FailableCache.java
Patch:
@@ -45,7 +45,9 @@ public V get(K key, Errors errors) throws ErrorsException {
       errors.merge((Errors) resultOrError);
       throw errors.toException();
     } else {
-      return (V) resultOrError;
+      @SuppressWarnings("unchecked") // create returned a non-error result, so this is safe
+      V result = (V) resultOrError;
+      return result;
     }
   }
 }

File: test/com/google/inject/AllTests.java
Patch:
@@ -66,6 +66,7 @@ public static Test suite() {
     suite.addTestSuite(OptionalBindingTest.class);
     suite.addTestSuite(OverrideModuleTest.class);
     suite.addTestSuite(ParentInjectorTest.class);
+    suite.addTestSuite(PrivateModuleTest.class);
     suite.addTestSuite(ProviderInjectionTest.class);
     suite.addTestSuite(ProviderMethodsTest.class);
     suite.addTestSuite(ProvisionExceptionTest.class);

File: src/com/google/inject/internal/Annotations.java
Patch:
@@ -19,11 +19,11 @@
 import com.google.inject.BindingAnnotation;
 import com.google.inject.Key;
 import com.google.inject.ScopeAnnotation;
+import com.google.inject.TypeLiteral;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Member;
-import java.lang.reflect.Type;
 
 /**
  * Annotation utilities.
@@ -83,8 +83,8 @@ public static void checkForMisplacedScopeAnnotations(Class<?> type, Object sourc
   }
 
   /** Gets a key for the given type, member and annotations. */
-  public static Key<?> getKey(Type type, Member member, Annotation[] annotations, Errors errors)
-      throws ErrorsException {
+  public static Key<?> getKey(TypeLiteral<?> type, Member member, Annotation[] annotations,
+      Errors errors) throws ErrorsException {
     int numErrorsBefore = errors.size();
     Annotation found = findBindingAnnotation(errors, member, annotations);
     errors.throwIfNewErrors(numErrorsBefore);

File: test/com/google/inject/AllTests.java
Patch:
@@ -77,6 +77,7 @@ public static Test suite() {
     suite.addTestSuite(RequestInjectionTest.class);
     suite.addTestSuite(SuperclassTest.class);
     suite.addTestSuite(TypeLiteralTest.class);
+    suite.addTestSuite(TypeLiteralTypeResolutionTest.class);
 
     // commands
     suite.addTestSuite(ElementsTest.class);

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -31,18 +31,18 @@
  */
 class ConstructorInjector<T> {
 
-  final Class<T> implementation;
+  final TypeLiteral<T> implementation;
   final InjectionPoint injectionPoint;
   final ImmutableList<SingleMemberInjector> memberInjectors;
   final ImmutableList<SingleParameterInjector<?>> parameterInjectors;
   final ConstructionProxy<T> constructionProxy;
 
-  ConstructorInjector(Errors errors, InjectorImpl injector, Class<T> implementation)
+  ConstructorInjector(Errors errors, InjectorImpl injector, TypeLiteral<T> implementation)
       throws ErrorsException {
     this.implementation = implementation;
 
     try {
-      this.injectionPoint = InjectionPoint.forConstructorOf(implementation);
+      this.injectionPoint = InjectionPoint.forConstructorOf(implementation.getType());
     } catch (ConfigurationException e) {
       throw errors.merge(e.getErrorMessages()).toException();
     }

File: src/com/google/inject/Initializer.java
Patch:
@@ -22,10 +22,9 @@
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;
-import com.google.inject.SingleMemberInjector;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.List;
 import java.util.concurrent.CountDownLatch;
 
 /**
@@ -119,7 +118,8 @@ public InjectableReference(T instance, Object source) {
     }
 
     public void validate(Errors errors) throws ErrorsException {
-      injectors = injector.injectors.get(instance.getClass(), errors.withSource(source));
+      injectors = injector.injectors.get(
+          TypeLiteral.get(instance.getClass()), errors.withSource(source));
     }
 
     /**

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -306,7 +306,7 @@ protected void configure() {
     } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "1) More than one scope annotation was found: ",
-          "while locating binding for " + SingletonAndCustomScoped.class.getName());
+          "while locating " + SingletonAndCustomScoped.class.getName());
     }
   }
 

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -41,7 +41,7 @@
  *   protected void configure() {
  *     bind(Foo.class).to(FooImpl.class).in(Scopes.SINGLETON);
  *     bind(BarImpl.class);
- *     link(Bar.class).to(BarImpl.class);
+ *     bind(Bar.class).to(BarImpl.class);
  *     bindConstant(named("port")).to(8080);
  *   }
  * }

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProviderTest.java
Patch:
@@ -515,7 +515,7 @@ public void testFactoryFailsWithMissingBinding() {
       fail();
     } catch (CreationException expected) {
       assertContains(expected.getMessage(),
-          "Parameter of type 'double' is not injectable or annotated with @Assisted");
+          "1) Parameter of type 'double' is not injectable or annotated with @Assisted");
     }
   }
   

File: extensions/multibindings/test/com/google/inject/multibindings/MapBinderTest.java
Patch:
@@ -250,8 +250,8 @@ public void testMapBinderMapForbidsNullValues() {
       injector.getInstance(Key.get(mapOfString));
       fail();
     } catch(ProvisionException expected) {
-      assertEquals("Map injection failed due to null value for key \"null\"",
-          expected.getCause().getMessage());
+      assertContains(expected.getMessage(),
+          "1) Map injection failed due to null value for key \"null\"");
     }
   }
 

File: src/com/google/inject/ProviderToInternalFactoryAdapter.java
Patch:
@@ -43,7 +43,7 @@ public T call(InternalContext context) throws ErrorsException {
           return internalFactory.get(errors, context, dependency);
         }
       });
-      errors.throwIfNecessary();
+      errors.throwIfNewErrors(0);
       return t;
     } catch (ErrorsException e) {
       throw new ProvisionException(errors.merge(e.getErrors()).getMessages());

File: src/com/google/inject/SingleParameterInjector.java
Patch:
@@ -51,6 +51,7 @@ static Object[] getAll(Errors errors, InternalContext context,
       return null;
     }
 
+    int numErrorsBefore = errors.size();
     Object[] parameters = new Object[parameterInjectors.size()];
 
     int i = 0;
@@ -62,7 +63,7 @@ static Object[] getAll(Errors errors, InternalContext context,
       }
     }
 
-    errors.throwIfNecessary();
+    errors.throwIfNewErrors(numErrorsBefore);
     return parameters;
   }
 }

File: src/com/google/inject/internal/Annotations.java
Patch:
@@ -85,8 +85,9 @@ public static void checkForMisplacedScopeAnnotations(Class<?> type, Object sourc
   /** Gets a key for the given type, member and annotations. */
   public static Key<?> getKey(Type type, Member member, Annotation[] annotations, Errors errors)
       throws ErrorsException {
+    int numErrorsBefore = errors.size();
     Annotation found = findBindingAnnotation(errors, member, annotations);
-    errors.throwIfNecessary();
+    errors.throwIfNewErrors(numErrorsBefore);
     return found == null ? Key.get(type) : Key.get(type, found);
   }
 

File: test/com/google/inject/BinderTest.java
Patch:
@@ -416,7 +416,7 @@ public void testInjectRawProvider() {
     } catch (ConfigurationException expected) {
       Asserts.assertContains(expected.getMessage(),
           "1) Cannot inject a Provider that has no type parameter",
-          "at binding for " + Provider.class.getName());
+          "while locating " + Provider.class.getName());
     }
   }
 }

File: test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -90,7 +90,7 @@ public void testNoImplicitBindingIsCreatedForAnnotatedKeys() {
       Asserts.assertContains(expected.getMessage(),
           "1) No implementation for " + I.class.getName(),
           "annotated with @" + Named.class.getName() + "(value=i) was bound.",
-          "at binding for " + I.class.getName(),
+          "while locating " + I.class.getName(),
           " annotated with @" + Named.class.getName() + "(value=i)");
     }
   }

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -306,7 +306,7 @@ protected void configure() {
     } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "1) More than one scope annotation was found: ",
-          "at binding for " + SingletonAndCustomScoped.class.getName(), ".class(ScopesTest.java:");
+          "while locating binding for " + SingletonAndCustomScoped.class.getName());
     }
   }
 

File: src/com/google/inject/BindingProcessor.java
Patch:
@@ -162,10 +162,9 @@ public Void visitKey(Key<? extends T> targetKey) {
 
         FactoryProxy<T> factory = new FactoryProxy<T>(key, targetKey, source);
         creationListeners.add(factory);
-        InternalFactory<? extends T> scopedFactory
-            = Scopes.scope(key, injector, factory, scope);
+        InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scope);
         putBinding(new LinkedBindingImpl<T>(
-                injector, key, source, scopedFactory, scope, targetKey, loadStrategy));
+            injector, key, source, scopedFactory, scope, targetKey, loadStrategy));
         return null;
       }
 

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -20,8 +20,6 @@
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.Dependency;
-import com.google.inject.spi.Message;
-import java.util.Collection;
 
 /**
  * Delegates to a custom factory which is also bound in the injector.
@@ -49,11 +47,12 @@ public void notify(final InjectorImpl injector, final Errors errors) {
 
   public T get(Errors errors, InternalContext context, Dependency<?> dependency)
       throws ErrorsException {
+    errors = errors.withSource(providerKey);
     Provider<? extends T> provider = providerFactory.get(errors, context, dependency);
     try {
       return errors.checkForNull(provider.get(), source, dependency);
     } catch(RuntimeException userException) {
-      throw errors.withSource(source).errorInProvider(userException).toException();
+      throw errors.errorInProvider(userException).toException();
     }
   }
 

File: src/com/google/inject/FactoryProxy.java
Patch:
@@ -50,7 +50,7 @@ public void notify(final InjectorImpl injector, final Errors errors) {
 
   public T get(Errors errors, InternalContext context, Dependency<?> dependency)
       throws ErrorsException {
-    return targetFactory.get(errors, context, dependency);
+    return targetFactory.get(errors.withSource(targetKey), context, dependency);
   }
 
   @Override public String toString() {

File: src/com/google/inject/Initializer.java
Patch:
@@ -22,7 +22,7 @@
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;
-import com.google.inject.InjectorImpl.SingleMemberInjector;
+import com.google.inject.SingleMemberInjector;
 import java.util.Map;
 import java.util.Set;
 import java.util.List;

File: src/com/google/inject/InjectionRequestProcessor.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.inject.InjectorImpl.SingleMemberInjector;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -21,8 +21,6 @@
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.SourceProvider;
 import com.google.inject.spi.Dependency;
-import com.google.inject.spi.Message;
-import java.util.Collection;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: src/com/google/inject/internal/FailableCache.java
Patch:
@@ -33,7 +33,7 @@ protected final Object create(K key) {
       } catch (ErrorsException e) {
         errors.merge(e.getErrors());
       }
-      return errors.hasErrors() ? errors.makeImmutable() : result;
+      return errors.hasErrors() ? errors : result;
     }
   };
 

File: src/com/google/inject/spi/Message.java
Patch:
@@ -59,7 +59,7 @@ public Message(String message) {
   public String getSource() {
     return sources.isEmpty()
         ? SourceProvider.UNKNOWN_SOURCE.toString()
-        : Errors.sourceToString(sources.get(sources.size() - 1));
+        : Errors.convert(sources.get(sources.size() - 1)).toString();
   }
 
   public List<Object> getSources() {

File: test/com/google/inject/AllTests.java
Patch:
@@ -53,7 +53,6 @@ public static Test suite() {
     suite.addTestSuite(CircularDependencyTest.class);
     suite.addTestSuite(TypeConversionTest.class);
     // suite.addTestSuite(ErrorHandlingTest.class); not a testcase
-    suite.addTestSuite(ErrorMessagesTest.class);
     suite.addTestSuite(GenericInjectionTest.class);
     suite.addTestSuite(ImplicitBindingTest.class);
     suite.addTestSuite(InjectionPointTest.class);

File: test/com/google/inject/BinderTest.java
Patch:
@@ -416,7 +416,7 @@ public void testInjectRawProvider() {
     } catch (ConfigurationException expected) {
       Asserts.assertContains(expected.getMessage(),
           "1) Cannot inject a Provider that has no type parameter",
-          "at " + Provider.class.getName());
+          "at binding for " + Provider.class.getName());
     }
   }
 }

File: test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -90,9 +90,9 @@ public void testNoImplicitBindingIsCreatedForAnnotatedKeys() {
       Asserts.assertContains(expected.getMessage(),
           "1) No implementation for " + I.class.getName(),
           "annotated with @" + Named.class.getName() + "(value=i) was bound.",
-          "at " + I.class.getName() + ".class(ImplicitBindingTest.java:");
+          "at binding for " + I.class.getName(),
+          " annotated with @" + Named.class.getName() + "(value=i)");
     }
-
   }
 
   static class ProvidedProvider implements Provider<Provided> {

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -306,7 +306,7 @@ protected void configure() {
     } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "1) More than one scope annotation was found: ",
-          "at " + SingletonAndCustomScoped.class.getName(), ".class(ScopesTest.java:");
+          "at binding for " + SingletonAndCustomScoped.class.getName(), ".class(ScopesTest.java:");
     }
   }
 

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -20,6 +20,8 @@
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.Dependency;
+import com.google.inject.spi.Message;
+import java.util.Collection;
 
 /**
  * Delegates to a custom factory which is also bound in the injector.
@@ -51,9 +53,7 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency)
     try {
       return errors.checkForNull(provider.get(), source, dependency);
     } catch(RuntimeException userException) {
-      Errors userErrors = ProvisionException.getErrors(userException);
-      throw errors.withSource(source)
-          .errorInProvider(userException, userErrors).toException();
+      throw errors.withSource(source).errorInProvider(userException).toException();
     }
   }
 

File: src/com/google/inject/InjectionRequestProcessor.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.inject.InjectorImpl.SingleMemberInjector;
-import com.google.inject.internal.ConfigurationException;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -21,6 +21,8 @@
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.SourceProvider;
 import com.google.inject.spi.Dependency;
+import com.google.inject.spi.Message;
+import java.util.Collection;
 
 /**
  * @author crazybob@google.com (Bob Lee)
@@ -45,9 +47,7 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency)
     try {
       return errors.checkForNull(initializable.get(errors).get(), source, dependency);
     } catch (RuntimeException userException) {
-      Errors userErrors = ProvisionException.getErrors(userException);
-      throw errors.withSource(source)
-          .errorInProvider(userException, userErrors).toException();
+      throw errors.withSource(source).errorInProvider(userException).toException();
     }
   }
 

File: src/com/google/inject/ProviderToInternalFactoryAdapter.java
Patch:
@@ -46,7 +46,7 @@ public T call(InternalContext context) throws ErrorsException {
       errors.throwIfNecessary();
       return t;
     } catch (ErrorsException e) {
-      throw new ProvisionException(errors.merge(e.getErrors()));
+      throw new ProvisionException(errors.merge(e.getErrors()).getMessages());
     }
   }
 

File: src/com/google/inject/RuntimeReflectionFactory.java
Patch:
@@ -18,7 +18,6 @@
 package com.google.inject;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import com.google.inject.internal.ConfigurationException;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;

File: src/com/google/inject/internal/ModuleBinding.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.common.collect.Lists;
 import com.google.inject.Binder;
 import com.google.inject.Binding;
+import com.google.inject.ConfigurationException;
 import com.google.inject.Key;
 import com.google.inject.Provider;
 import com.google.inject.Scope;

File: test/com/google/inject/BinderTest.java
Patch:
@@ -229,7 +229,7 @@ protected void configure() {
       assertContains(expected.getMessage(),
           "1) A binding to java.lang.String[] was already configured at " + getClass().getName(),
           "at " + getClass().getName(), ".configure(BinderTest.java:");
-      assertContains(expected.getMessage(), "1 error[s]");
+      assertContains(expected.getMessage(), "1 error");
     }
   }
 
@@ -289,7 +289,7 @@ public void testPartialInjectorGetInstance() {
     try {
       injector.getInstance(MissingParameter.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "1) Could not find a suitable constructor in " + NoInjectConstructor.class.getName(),
           "at " + MissingParameter.class.getName() + ".<init>(BinderTest.java:");
@@ -413,7 +413,7 @@ public void testInjectRawProvider() {
     try {
       Guice.createInjector().getInstance(Provider.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       Asserts.assertContains(expected.getMessage(),
           "1) Cannot inject a Provider that has no type parameter",
           "at " + Provider.class.getName());

File: test/com/google/inject/BindingTest.java
Patch:
@@ -183,7 +183,7 @@ private void assertBindingFails(final Class<?> clazz) throws NoSuchMethodExcepti
     try {
       Guice.createInjector().getInstance(clazz);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "Could not find a suitable constructor in " + PrivateNoArg.class.getName(),
           "at " + PrivateNoArg.class.getName() + ".class(BindingTest.java:");
@@ -194,7 +194,7 @@ public void testTooManyConstructors() {
     try {
       Guice.createInjector().getInstance(TooManyConstructors.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           TooManyConstructors.class.getName() + " has more than one constructor annotated with " 
               + "@Inject. Classes must have either one (and only one) constructor",

File: test/com/google/inject/ErrorMessagesTest.java
Patch:
@@ -51,7 +51,7 @@ public void testBindingAnnotationsOnMethodsAndConstructors() {
     try {
       Guice.createInjector().getInstance(B.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           B.class.getName() + ".injectMe() is annotated with @", Green.class.getName() + "(), ",
           "but binding annotations should be applied to its parameters instead.",
@@ -61,7 +61,7 @@ public void testBindingAnnotationsOnMethodsAndConstructors() {
     try {
       Guice.createInjector().getInstance(C.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           C.class.getName() + ".<init>() is annotated with @", Green.class.getName() + "(), ",
           "but binding annotations should be applied to its parameters instead.",

File: test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -86,7 +86,7 @@ public void testNoImplicitBindingIsCreatedForAnnotatedKeys() {
     try {
       Guice.createInjector().getInstance(Key.get(I.class, Names.named("i")));
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       Asserts.assertContains(expected.getMessage(),
           "1) No implementation for " + I.class.getName(),
           "annotated with @" + Named.class.getName() + "(value=i) was bound.",

File: test/com/google/inject/InjectorTest.java
Patch:
@@ -332,7 +332,7 @@ public void testNotASubtype() {
     try {
       Guice.createInjector().getInstance(PineTree.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           Tree.class.getName() + " doesn't extend " + PineTree.class.getName(),
           "at ", PineTree.class.getName() + ".class(InjectorTest.java:");
@@ -343,7 +343,7 @@ public void testRecursiveImplementationType() {
     try {
       Guice.createInjector().getInstance(SeaHorse.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "@ImplementedBy points to the same class it annotates.",
           "at ", SeaHorse.class.getName() + ".class(InjectorTest.java:");
@@ -354,7 +354,7 @@ public void testRecursiveProviderType() {
     try {
       Guice.createInjector().getInstance(Chicken.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "@ProvidedBy points to the same class it annotates",
           "at ", Chicken.class.getName() + ".class(InjectorTest.java:");

File: test/com/google/inject/OptionalBindingTest.java
Patch:
@@ -246,7 +246,7 @@ public void testOptionalConstructorBlowsUp() {
     try {
       Guice.createInjector().getInstance(HasOptionalConstructor.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(), "OptionalBindingTest$HasOptionalConstructor.<init>() "
           + "is annotated @Inject(optional=true), but constructors cannot be optional.");
     }

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -143,7 +143,7 @@ public void testScopingAnnotationsOnAbstractTypeViaImplementedBy() {
     try {
       Guice.createInjector().getInstance(D.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           D.class.getName() + " is annotated with " + Singleton.class.getName(),
           "but scope annotations are not supported for abstract types.",
@@ -159,7 +159,7 @@ public void testScopingAnnotationsOnAbstractTypeViaProvidedBy() {
     try {
       Guice.createInjector().getInstance(E.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           E.class.getName() + " is annotated with " + Singleton.class.getName(),
           "but scope annotations are not supported for abstract types.",
@@ -303,7 +303,7 @@ protected void configure() {
     try {
       injector.getInstance(SingletonAndCustomScoped.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(),
           "1) More than one scope annotation was found: ",
           "at " + SingletonAndCustomScoped.class.getName(), ".class(ScopesTest.java:");

File: test/com/google/inject/TypeConversionTest.java
Patch:
@@ -128,7 +128,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidInteger.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(), "Error converting 'invalid'");
       assertContains(expected.getMessage(), "bound at " + getClass().getName());
       assertContains(expected.getMessage(), "to java.lang.Integer");
@@ -149,7 +149,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidCharacter.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(), "Error converting 'invalid'");
       assertContains(expected.getMessage(), "bound at " + getClass().getName());
       assertContains(expected.getMessage(), "to java.lang.Character");
@@ -170,7 +170,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidEnum.class);
       fail();
-    } catch (ProvisionException expected) {
+    } catch (ConfigurationException expected) {
       assertContains(expected.getMessage(), "Error converting 'invalid'");
       assertContains(expected.getMessage(), "bound at " + getClass().getName());
       assertContains(expected.getMessage(), "to " + Bar.class.getName());

File: src/com/google/inject/internal/Errors.java
Patch:
@@ -381,8 +381,9 @@ public static String format(String heading, Collection<? extends Message> errorM
             } else {
               throw new AssertionError();
             }
+          } else {
+            fmt.format("  while locating %s%n", convert(dependency.getKey()));
           }
-          continue;
         }
 
         fmt.format("  at %s%n", sourceToString(source));

File: src/com/google/inject/spi/Elements.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.internal.ModuleBinding;
+import com.google.inject.internal.ProviderMethodsModule;
 import com.google.inject.internal.SourceProvider;
 import com.google.inject.matcher.Matcher;
 import java.lang.annotation.Annotation;
@@ -157,7 +158,7 @@ public void install(Module module) {
         } catch (RuntimeException e) {
           addError(e);
         }
-        install(ProviderMethods.from(module));
+        install(ProviderMethodsModule.forModule(module));
       }
     }
 

File: test/com/google/inject/KeyTest.java
Patch:
@@ -129,7 +129,7 @@ public void testSerialization() throws IOException, NoSuchFieldException {
     assertEqualWhenReserialized(Key.get(B[].class));
     assertEqualWhenReserialized(Key.get(new TypeLiteral<Map<List<B>, B>>() {}));
     assertEqualWhenReserialized(Key.get(new TypeLiteral<List<B[]>>() {}));
-    assertEqualWhenReserialized(new Key<List<B[]>>() {});
+    assertEquals(new Key<List<B[]>>() {}, Asserts.reserialize(new Key<List<B[]>>() {}));
     assertEqualWhenReserialized(Key.get(Types.listOf(Types.subtypeOf(CharSequence.class))));
   }
 

File: src/com/google/inject/BindingAnnotation.java
Patch:
@@ -28,7 +28,7 @@
  *
  * <pre>
  *   {@code @}Retention(RUNTIME)
- *   {@code @}Target({ FIELD, PARAMETER })
+ *   {@code @}Target({ FIELD, PARAMETER, METHOD })
  *   {@code @}BindingAnnotation
  *   public {@code @}interface Transactional {}
  * </pre>

File: src/com/google/inject/CreationException.java
Patch:
@@ -58,4 +58,6 @@ public Collection<Message> getErrorMessages() {
   @Override public String getMessage() {
     return Errors.format("Guice configuration errors", errorMessages);
   }
+
+  private static final long serialVersionUID = 0;
 }

File: src/com/google/inject/InjectorBuilder.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.inject.Reflection.Factory;
@@ -258,7 +259,7 @@ private void bindLogger() {
     injector.explicitBindings.put(key,
         new ProviderInstanceBindingImpl<Logger>(injector, key,
             SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scopes.NO_SCOPE,
-            loggerFactory, LoadStrategy.LAZY));
+            loggerFactory, LoadStrategy.LAZY, ImmutableSet.<InjectionPoint>of()));
   }
 
   static class LoggerFactory implements InternalFactory<Logger>, Provider<Logger> {

File: src/com/google/inject/ProvisionException.java
Patch:
@@ -92,4 +92,6 @@ static void throwNewIfNonEmpty(Errors errors) {
       throw new ProvisionException(errors.makeImmutable());
     }
   }
+
+  private static final long serialVersionUID = 0;
 }

File: src/com/google/inject/ScopeBindingProcessor.java
Patch:
@@ -43,7 +43,7 @@ class ScopeBindingProcessor extends AbstractProcessor {
     Scope scope = command.getScope();
     Class<? extends Annotation> annotationType = command.getAnnotationType();
 
-    if (!Scopes.isScopeAnnotation(annotationType)) {
+    if (!Annotations.isScopeAnnotation(annotationType)) {
       errors.withSource(annotationType).missingScopeAnnotation();
       // Go ahead and bind anyway so we don't get collateral errors.
     }

File: src/com/google/inject/spi/Dependency.java
Patch:
@@ -108,4 +108,6 @@ public int getParameterIndex() {
     }
     return builder.toString();
   }
+
+  private static final long serialVersionUID = 0;
 }

File: test/com/google/inject/AllTests.java
Patch:
@@ -24,8 +24,10 @@
 import com.google.inject.internal.UniqueAnnotationsTest;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.spi.ElementsTest;
+import com.google.inject.spi.InjectionPointTest;
 import com.google.inject.spi.ModuleRewriterTest;
 import com.google.inject.spi.ModuleWriterTest;
+import com.google.inject.spi.ProviderMethodsTest;
 import com.google.inject.spi.SpiBindingsTest;
 import com.google.inject.util.ProvidersTest;
 import com.google.inject.util.TypesTest;

File: extensions/multibindings/test/com/google/inject/multibindings/MultibinderTest.java
Patch:
@@ -250,8 +250,8 @@ public void testSourceLinesInMultibindings() {
       });
       fail();
     } catch (CreationException expected) {
-      assertContains(expected.getMessage(), "Error at " + getClass().getName());
-      assertContains(expected.getMessage(), "No implementation for java.lang.Integer");
+      assertContains(expected.getMessage(), "No implementation for java.lang.Integer", 
+          "at " + getClass().getName());
     }
   }
 

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -52,7 +52,8 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency)
       return errors.checkForNull(provider.get(), source, dependency);
     } catch(RuntimeException userException) {
       Errors userErrors = ProvisionException.getErrors(userException);
-      throw errors.errorInProvider(userException, userErrors).toException();
+      throw errors.withSource(source)
+          .errorInProvider(userException, userErrors).toException();
     }
   }
 

File: src/com/google/inject/InjectorBuilder.java
Patch:
@@ -191,14 +191,14 @@ public void loadEagerSingletons() {
             public Void call(InternalContext context) {
               Dependency<?> dependency = Dependency.get(binding.key);
               context.setDependency(dependency);
-              errors.pushInjectionPoint(dependency);
+              errors.pushSource(dependency);
               try {
                 binding.internalFactory.get(errors, context, dependency);
               } catch (ErrorsException e) {
                 errors.merge(e.getErrors());
               } finally {
                 context.setDependency(null);
-                errors.popInjectionPoint(dependency);
+                errors.popSource(dependency);
               }
 
               return null;

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -47,7 +47,8 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency)
       return errors.checkForNull(provider.get(), source, dependency);
     } catch (RuntimeException userException) {
       Errors userErrors = ProvisionException.getErrors(userException);
-      throw errors.errorInProvider(userException, userErrors).toException();
+      throw errors.withSource(source)
+          .errorInProvider(userException, userErrors).toException();
     }
   }
 

File: src/com/google/inject/internal/ConfigurationException.java
Patch:
@@ -32,7 +32,7 @@ public class ConfigurationException extends RuntimeException {
   /**
    * Constructs a new exception for the given errors.
    */
-  ConfigurationException(Errors errors) {
+  public ConfigurationException(Errors errors) {
     errors.makeImmutable();
     this.errors = errors;
 

File: test/com/google/inject/BindingAnnotationTest.java
Patch:
@@ -52,9 +52,9 @@ protected void configure() {
       });
       fail();
     } catch (CreationException expected) {
-      assertContains(expected.getMessage(), "BindingAnnotationTest$Foo.s",
-          "No implementation for java.lang.String annotated with",
-          "BindingAnnotationTest$Blue(value=5) was bound");
+      assertContains(expected.getMessage(), "No implementation for java.lang.String annotated with",
+          "BindingAnnotationTest$Blue(value=5) was bound",
+          "at " + BindingAnnotationTest.class.getName(), ".configure(BindingAnnotationTest.java:");
     }
   }
 

File: test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -88,9 +88,9 @@ public void testNoImplicitBindingIsCreatedForAnnotatedKeys() {
       fail();
     } catch (ProvisionException expected) {
       Asserts.assertContains(expected.getMessage(),
-          "1) Error at " + I.class.getName() + ".class(ImplicitBindingTest.java:",
-          "No implementation for " + I.class.getName(),
-          "annotated with @" + Named.class.getName() + "(value=i) was bound.");
+          "1) No implementation for " + I.class.getName(),
+          "annotated with @" + Named.class.getName() + "(value=i) was bound.",
+          "at " + I.class.getName() + ".class(ImplicitBindingTest.java:");
     }
 
   }

File: test/com/google/inject/NullableInjectionPointTest.java
Patch:
@@ -95,8 +95,9 @@ protected void configure() {
       });
       fail();
     } catch (CreationException expected) {
-      assertContains(expected.getMessage(), "Error at " + getClass().getName(),
-          "Binding to null instances is not allowed.");
+      assertContains(expected.getMessage(),
+          "Binding to null instances is not allowed.",
+          "at " + getClass().getName(), ".configure(NullableInjectionPointTest.java:");
     }
   }
 

File: test/com/google/inject/ProviderMethodsTest.java
Patch:
@@ -172,8 +172,8 @@ public String provideString() {
       fail();
     } catch (CreationException expected) {
       Asserts.assertContains(expected.getMessage(),
-          "Error at " + getClass().getName(), ".provideString()",
-          "more than one annotation annotated with @BindingAnnotation:", "Named", "Blue");
+          "more than one annotation annotated with @BindingAnnotation:", "Named", "Blue",
+          "at " + getClass().getName(), ".provideString(ProviderMethodsTest.java:");
     }
 
   }

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -49,8 +49,9 @@ public Object invoke(MethodInvocation methodInvocation) {
       fail();
     } catch (CreationException expected) {
       assertContains(expected.getMessage(),
-          "Error at " + A.class.getName() + ".<init>(LineNumbersTest.java",
-          "No implementation for " + B.class.getName() + " was bound.");
+          "1) No implementation for " + B.class.getName() + " was bound.",
+          "for parameter 0 at " + A.class.getName() + ".<init>(LineNumbersTest.java:",
+          "at " + LineNumbersTest.class.getName(), ".configure(LineNumbersTest.java:");
     }
   }
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -42,6 +42,7 @@ public static Test suite() {
     TestSuite suite = new TestSuite();
 
     suite.addTestSuite(BinderTest.class);
+    suite.addTest(BinderTestSuite.suite());
     suite.addTestSuite(BindingAnnotationTest.class);
     suite.addTestSuite(BindingOrderTest.class);
     suite.addTestSuite(BindingTest.class);

File: test/com/google/inject/spi/FailingBindingScopingVisitor.java
Patch:
@@ -20,7 +20,7 @@
 import java.lang.annotation.Annotation;
 import junit.framework.AssertionFailedError;
 
-class FailingBindingScopingVisitor implements BindingScopingVisitor<Void> {
+public class FailingBindingScopingVisitor implements BindingScopingVisitor<Void> {
 
   public Void visitEagerSingleton() {
     throw new AssertionFailedError();

File: src/com/google/inject/spi/DefaultElementVisitor.java
Patch:
@@ -14,7 +14,6 @@
  * limitations under the License.
  */
 
-
 package com.google.inject.spi;
 
 import com.google.inject.Binding;
@@ -30,8 +29,6 @@
  */
 public abstract class DefaultElementVisitor<V> implements ElementVisitor<V> {
 
-  protected DefaultElementVisitor() {}
-
   /**
    * Visit {@code element} and return a result.
    */

File: src/com/google/inject/internal/BytecodeGen.java
Patch:
@@ -78,7 +78,7 @@ public final class BytecodeGen {
 
   /** Use "-Dguice.custom.loader=false" to disable custom classloading. */
   static final boolean HOOK_ENABLED
-      = "true".equals(System.getProperty("guice.custom.loader", "true"));
+      = "true".equals(System.getProperty("guice.custom.loader", "false"));
 
   /**
    * Weak cache of bridge class loaders that make the Guice implementation

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.inject.InjectorImpl.SingleParameterInjector;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
-import com.google.inject.internal.StackTraceElements;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.List;
@@ -52,8 +51,7 @@ SingleParameterInjector<?>[] createParameterInjector(Errors errors,
       InjectorImpl injector, ConstructionProxy<T> constructionProxy)
       throws ErrorsException {
     Constructor constructor = constructionProxy.getConstructor();
-    Object source = StackTraceElements.forMember(constructor);
-    errors = errors.withSource(source);
+    errors = errors.withSource(constructor);
     return constructionProxy.getParameters().isEmpty()
         ? null // default constructor.
         : injector.getParametersInjectors(constructor,

File: src/com/google/inject/ProviderMethods.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.inject.binder.AnnotatedBindingBuilder;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.Keys;
-import com.google.inject.internal.StackTraceElements;
 import com.google.inject.internal.TypeResolver;
 import com.google.inject.spi.Message;
 import com.google.inject.util.Modules;
@@ -70,7 +69,7 @@ public synchronized void configure(Binder binder) {
             continue;
           }
 
-          this.binder = binder.withSource(StackTraceElements.forMember(method));
+          this.binder = binder.withSource(method);
           try {
             bindProviderMethod(method);
           } finally {
@@ -81,7 +80,7 @@ public synchronized void configure(Binder binder) {
     }
 
     <T> void bindProviderMethod(final Method method) {
-      Errors errors = new Errors(StackTraceElements.forMember(method));
+      Errors errors = new Errors(method);
 
       method.setAccessible(true);
 

File: src/com/google/inject/ScopeBindingProcessor.java
Patch:
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.StackTraceElements;
 import com.google.inject.spi.ScopeBinding;
 import java.lang.annotation.Annotation;
 import java.util.Map;
@@ -45,12 +44,12 @@ class ScopeBindingProcessor extends AbstractProcessor {
     Class<? extends Annotation> annotationType = command.getAnnotationType();
 
     if (!Scopes.isScopeAnnotation(annotationType)) {
-      errors.withSource(StackTraceElements.forType(annotationType)).missingScopeAnnotation();
+      errors.withSource(annotationType).missingScopeAnnotation();
       // Go ahead and bind anyway so we don't get collateral errors.
     }
 
     if (!Annotations.isRetainedAtRuntime(annotationType)) {
-      errors.withSource(StackTraceElements.forType(annotationType))
+      errors.withSource(annotationType)
           .missingRuntimeRetention(command.getSource());
       // Go ahead and bind anyway so we don't get collateral errors.
     }

File: src/com/google/inject/Scopes.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.inject.internal.Classes;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.StackTraceElements;
 import java.lang.annotation.Annotation;
 
 /**
@@ -136,8 +135,7 @@ static void checkForMisplacedScopeAnnotations(Class<?> type, Object source, Erro
 
     Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, type);
     if (scopeAnnotation != null) {
-      errors.withSource(StackTraceElements.forType(type))
-          .scopeAnnotationOnAbstractType(scopeAnnotation, type, source);
+      errors.withSource(type).scopeAnnotationOnAbstractType(scopeAnnotation, type, source);
     }
   }
 

File: src/com/google/inject/spi/Message.java
Patch:
@@ -44,7 +44,7 @@ public final class Message implements Serializable, Element {
 
   public Message(Object source, String message, List<InjectionPoint> injectionPoints,
       Throwable cause) {
-    this.source = Errors.convert(checkNotNull(source, "source")).toString();
+    this.source = Errors.sourceToString(source);
     this.message = checkNotNull(message, "message");
     this.injectionPoints = ImmutableList.copyOf(injectionPoints);
     this.cause = cause;

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -557,7 +557,6 @@ public T get(Errors errors, InternalContext context, InjectionPoint injectionPoi
   <T> BindingImpl<T> createImplementedByBinding(Class<T> type, Scope scope,
       ImplementedBy implementedBy, LoadStrategy loadStrategy, Errors errors)
       throws ErrorsException {
-    // TODO: Use scope annotation on type if present. Right now, we always use NO_SCOPE.
     Class<?> implementationType = implementedBy.value();
 
     // Make sure it's not the same type. TODO: Can we check for deeper cycles?

File: src/com/google/inject/InjectorBuilder.java
Patch:
@@ -184,7 +184,7 @@ public void loadEagerSingletons() {
     // load eager singletons, or all singletons if we're in Stage.PRODUCTION.
     for (final BindingImpl<?> binding
         : Iterables.concat(injector.explicitBindings.values(), injector.jitBindings.values())) {
-      if ((stage == Stage.PRODUCTION && binding.getScope() == Scopes.SINGLETON)
+      if ((stage == Stage.PRODUCTION && binding.getScope() == SINGLETON)
           || binding.getLoadStrategy() == LoadStrategy.EAGER) {
         try {
           injector.callInContext(new ContextualCallable<Void>() {

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -532,7 +532,8 @@ public T get(Errors errors, InternalContext context, InjectionPoint injectionPoi
         Provider<?> provider = providerBinding.internalFactory.get(errors, context, injectionPoint);
         Object o = provider.get();
         if (o != null && !type.isInstance(o)) {
-          throw errors.subtypeNotProvided(providerType, type).toException();
+          throw errors.withSource(StackTraceElements.forType(type))
+              .subtypeNotProvided(providerType, type).toException();
         }
 
         @SuppressWarnings("unchecked") // protected by isInstance() check above

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -49,7 +49,7 @@ public T get(Errors errors, InternalContext context, InjectionPoint<?> injection
       throws ErrorsException {
     Provider<? extends T> provider = providerFactory.get(errors, context, injectionPoint);
     try {
-      return injectionPoint.checkForNull(errors, provider.get(), source);
+      return errors.checkForNull(provider.get(), source, injectionPoint);
     } catch(RuntimeException userException) {
       Errors userErrors = ProvisionException.getErrors(userException);
       throw errors.errorInProvider(userException, userErrors).toException();

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -44,8 +44,7 @@ public T get(Errors errors, InternalContext context, InjectionPoint<?> injection
       throws ErrorsException {
     try {
       context.ensureMemberInjected(errors, provider);
-      T result = provider.get();
-      return injectionPoint.checkForNull(errors, result, source);
+      return errors.checkForNull(provider.get(), source, injectionPoint);
     } catch (RuntimeException userException) {
       Errors userErrors = ProvisionException.getErrors(userException);
       throw errors.errorInProvider(userException, userErrors).toException();

File: src/com/google/inject/Stage.java
Patch:
@@ -27,7 +27,8 @@ public enum Stage {
    * We're running in a tool (an IDE plugin for example). We need binding
    * meta data but not a functioning Injector. Do not inject members of
    * instances. Do not load eager singletons. Do as little as possible so
-   * our tools run nice and snappy.
+   * our tools run nice and snappy. Injectors created in this stage cannot
+   * be used to satisfy injections.
    */
   TOOL,
 

File: src/com/google/inject/BindingProcessor.java
Patch:
@@ -37,7 +37,7 @@
  * @author crazybob@google.com (Bob Lee)
  * @author jessewilson@google.com (Jesse Wilson)
  */
-class BindElementProcessor extends ElementProcessor {
+class BindingProcessor extends AbstractProcessor {
 
   private static final com.google.inject.Binding.ScopingVisitor<LoadStrategy> LOAD_STRATEGY_VISITOR
       = new com.google.inject.Binding.ScopingVisitor<LoadStrategy>() {
@@ -65,7 +65,7 @@ public LoadStrategy visitNoScoping() {
   private final CreationTimeMemberInjector memberInjector;
   private final List<Runnable> untargettedBindings = Lists.newArrayList();
 
-  BindElementProcessor(Errors errors,
+  BindingProcessor(Errors errors,
       InjectorImpl injector,
       Map<Class<? extends Annotation>, Scope> scopes,
       Map<Key<?>, BindingImpl<?>> bindings,

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import com.google.inject.BindElementProcessor.CreationListener;
+import com.google.inject.BindingProcessor.CreationListener;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;

File: src/com/google/inject/FactoryProxy.java
Patch:
@@ -26,7 +26,7 @@
  * A placeholder which enables us to swap in the real factory once the
  * container is created.
  */
-class FactoryProxy<T> implements InternalFactory<T>, BindElementProcessor.CreationListener {
+class FactoryProxy<T> implements InternalFactory<T>, BindingProcessor.CreationListener {
 
   private final Key<T> key;
   private final Key<? extends T> targetKey;

File: src/com/google/inject/MessageProcessor.java
Patch:
@@ -27,11 +27,11 @@
  * @author crazybob@google.com (Bob Lee)
  * @author jessewilson@google.com (Jesse Wilson)
  */
-class ErrorsElementProcessor extends ElementProcessor {
+class MessageProcessor extends AbstractProcessor {
 
   private static final Logger logger = Logger.getLogger(Guice.class.getName());
 
-  ErrorsElementProcessor(Errors errors) {
+  MessageProcessor(Errors errors) {
     super(errors);
   }
 

File: src/com/google/inject/commands/BindInterceptorCommand.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Immutable snapshot of a request to bind an interceptor.
  *
- * @deprecated replaced with {@link com.google.inject.spi.BindInterceptor}
+ * @deprecated replaced with {@link com.google.inject.spi.InterceptorBinding}
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: src/com/google/inject/commands/BindScopeCommand.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Immutable snapshot of a request to bind a scope.
  *
- * @deprecated replaced with {@link com.google.inject.spi.BindScope}
+ * @deprecated replaced with {@link com.google.inject.spi.ScopeBinding}
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: src/com/google/inject/commands/ConvertToTypesCommand.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Immutable snapshot of a request to convert binder types.
  *
- * @deprecated replaced with {@link com.google.inject.spi.ConvertToTypes}
+ * @deprecated replaced with {@link com.google.inject.spi.TypeConverterBinding}
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: src/com/google/inject/commands/GetProviderCommand.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Immutable snapshot of a request for a provider.
  *
- * @deprecated replaced with {@link com.google.inject.spi.GetProvider}
+ * @deprecated replaced with {@link com.google.inject.spi.ProviderLookup}
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: src/com/google/inject/commands/RequestInjectionCommand.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Immutable snapshot of a request for injection.
  *
- * @deprecated replaced with {@link com.google.inject.spi.RequestInjection}
+ * @deprecated replaced with {@link com.google.inject.spi.InjectionRequest}
  *
  * @author mikeward@google.com (Mike Ward)
  */

File: src/com/google/inject/commands/RequestStaticInjectionCommand.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Immutable snapshot of a request for static injection.
  * 
- * @deprecated replaced with {@link com.google.inject.spi.RequestStaticInjection}
+ * @deprecated replaced with {@link com.google.inject.spi.StaticInjectionRequest}
  *
  * @author jessewilson@google.com (Jesse Wilson)
  */

File: src/com/google/inject/BindCommandProcessor.java
Patch:
@@ -171,7 +171,8 @@ public Void visitUntargetted() {
         Class<T> clazz = (Class<T>) type;
         final BindingImpl<T> binding;
         try {
-          binding = injector.createUnitializedBinding(clazz, scope, source, loadStrategy, errors);
+          binding = injector.createUnitializedBinding(
+              key, clazz, scope, source, loadStrategy, errors);
           putBinding(binding);
         } catch (ErrorsException e) {
           errors.merge(e.getErrors());

File: test/com/google/inject/internal/TypeResolverTest.java
Patch:
@@ -153,7 +153,7 @@ static interface HasArray<T extends Number> {
   }
 
   public void testRelatedTypeVariables() {
-    TypeResolver resolver = new TypeResolver(arrayListOfString);
+    TypeResolver resolver = new TypeResolver(hasRelatedOfString);
     assertEquals(String.class, resolver.getParameterTypes(echo).get(0));
     assertEquals(String.class, resolver.getReturnType(echo));
   }

File: src/com/google/inject/internal/AbstractReferenceCache.java
Patch:
@@ -164,7 +164,7 @@ synchronized V get() {
      *
      * @return {@code true} if the thread was interrupted while waiting
      */
-    private synchronized boolean waitUntilSet() {
+    private boolean waitUntilSet() {
       boolean interrupted = false;
       while (!set) {
         try {

File: servlet/src/com/google/inject/servlet/RequestParameters.java
Patch:
@@ -29,6 +29,6 @@
  * @author crazybob@google.com (Bob Lee)
  */
 @Retention(RUNTIME)
-@Target({ ElementType.FIELD, ElementType.PARAMETER })
+@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @BindingAnnotation
 public @interface RequestParameters {}

File: src/com/google/inject/BindCommandProcessor.java
Patch:
@@ -110,7 +110,7 @@ public Void visitToInstance(T instance) {
         }
 
         ConstantFactory<? extends T> factory = new ConstantFactory<T>(instance);
-        memberInjector.add(instance);
+        memberInjector.requestInjection(instance, source);
         InternalFactory<? extends T> scopedFactory
             = Scopes.scope(key, injector, factory, scope);
         putBinding(new InstanceBindingImpl<T>(injector, key, source, scopedFactory, instance));
@@ -120,7 +120,7 @@ public Void visitToInstance(T instance) {
       public Void visitToProvider(Provider<? extends T> provider) {
         InternalFactoryToProviderAdapter<? extends T> factory
             = new InternalFactoryToProviderAdapter<T>(provider, source);
-        memberInjector.add(provider);
+        memberInjector.requestInjection(provider, source);
         InternalFactory<? extends T> scopedFactory
             = Scopes.scope(key, injector, factory, scope);
         putBinding(new ProviderInstanceBindingImpl<T>(
@@ -182,7 +182,7 @@ public Void visitUntargetted() {
         untargettedBindings.add(new Runnable() {
           public void run() {
             try {
-              injector.initializeBinding(binding, errors);
+              injector.initializeBinding(binding, errors.withSource(source));
             } catch (ErrorsException e) {
               errors.merge(e.getErrors());
             }

File: src/com/google/inject/InternalContext.java
Patch:
@@ -74,6 +74,6 @@ public void setInjectionPoint(InjectionPoint injectionPoint) {
    * been injected before its use.
    */
   public void ensureMemberInjected(Errors errors, Object toInject) throws ErrorsException {
-    injector.memberInjector.ensureInjected(errors, toInject);
+    injector.memberInjector.ensureInjected(toInject, errors);
   }
 }

File: src/com/google/inject/RequestInjectionCommandProcessor.java
Patch:
@@ -51,7 +51,7 @@ class RequestInjectionCommandProcessor extends CommandProcessor {
 
   @Override public Boolean visitRequestInjection(RequestInjectionCommand command) {
     for (Object instance : command.getInstances()) {
-      memberInjector.add(instance);
+      memberInjector.requestInjection(instance, command.getSource());
     }
     return true;
   }

File: src/com/google/inject/RuntimeReflectionFactory.java
Patch:
@@ -76,6 +76,7 @@ private <T> Constructor<T> findConstructorIn(Errors errors, Class<T> implementat
         if (Modifier.isPrivate(noArgCtor.getModifiers())
             && !Modifier.isPrivate(implementation.getModifiers())) {
           errors.missingConstructor(implementation);
+          throw errors.toException();
         }
         return noArgCtor;
       }

File: src/com/google/inject/ClassBindingImpl.java
Patch:
@@ -43,7 +43,7 @@ class ClassBindingImpl<T> extends BindingImpl<T>
   }
 
   @Override void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
-    lateBoundConstructor.bind(injector, getBoundClass());
+    lateBoundConstructor.bind(injector, getBoundClass(), errors);
   }
 
   public void accept(BindingVisitor<? super T> visitor) {

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -42,7 +42,8 @@ class ConstructorInjector<T> {
     this.implementation = implementation;
     constructionProxy = injector.reflection.getConstructionProxy(errors, implementation);
     parameterInjectors = createParameterInjector(errors, injector, constructionProxy);
-    List<SingleMemberInjector> memberInjectorsList = injector.getMemberInjectors(implementation);
+    List<SingleMemberInjector> memberInjectorsList
+        = injector.getMemberInjectors(implementation, errors);
     memberInjectors = memberInjectorsList.toArray(
         new SingleMemberInjector[memberInjectorsList.size()]);
   }

File: src/com/google/inject/CreationTimeMemberInjector.java
Patch:
@@ -54,7 +54,7 @@ public void add(Object instance) {
   void validateOustandingInjections(Errors errors) {
     for (Object toInject : outstandingInjections) {
       try {
-        injector.getMemberInjectors(toInject.getClass());
+        injector.getMemberInjectors(toInject.getClass(), errors);
       } catch (ErrorsException e) {
         errors.merge(e.getErrors());
       }

File: src/com/google/inject/RuntimeReflectionFactory.java
Patch:
@@ -72,8 +72,9 @@ private <T> Constructor<T> findConstructorIn(Errors errors, Class<T> implementat
       try {
         Constructor<T> noArgCtor = implementation.getDeclaredConstructor();
 
-        // Explicitly disallow private constructors that are missing @Inject
-        if (Modifier.isPrivate(noArgCtor.getModifiers())) {
+        // Disallow private constructors on non-private classes (unless they have @Inject)
+        if (Modifier.isPrivate(noArgCtor.getModifiers())
+            && !Modifier.isPrivate(implementation.getModifiers())) {
           errors.missingConstructor(implementation);
         }
         return noArgCtor;

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
+import com.google.inject.internal.BytecodeGen.Visibility;
 import static com.google.inject.internal.BytecodeGen.newFastClass;
 import com.google.inject.internal.Classes;
 import com.google.inject.internal.Errors;
@@ -884,7 +885,8 @@ public Object invoke(Object target, Object... parameters)
           }
         };
       } else {
-        FastClass fastClass = newFastClass(method.getDeclaringClass());
+        FastClass fastClass = newFastClass(method.getDeclaringClass(),
+            Visibility.forMember(method));
         final FastMethod fastMethod = fastClass.getMethod(method);
 
         methodInvoker = new MethodInvoker() {

File: src/com/google/inject/internal/Classes.java
Patch:
@@ -24,8 +24,8 @@
 public class Classes {
 
   public static boolean isInnerClass(Class<?> clazz) {
-    return clazz.getEnclosingClass() != null
-        && !Modifier.isStatic(clazz.getModifiers());
+    return !Modifier.isStatic(clazz.getModifiers())
+        && clazz.getEnclosingClass() != null;
   }
 
   public static boolean isConcrete(Class<?> clazz) {

File: src/com/google/inject/internal/BytecodeGen.java
Patch:
@@ -74,8 +74,9 @@ public final class BytecodeGen {
   };
 
   /** Use "-Dguice.custom.loader=false" to disable custom classloading. */
+  // disabled until assisted inject tests pass
   static final boolean HOOK_ENABLED
-      = "true".equals(System.getProperty("guice.custom.loader", "true"));
+      = "true".equals(System.getProperty("guice.custom.loader", "false"));
 
   /**
    * Weak cache of bridge class loaders that make the Guice implementation

File: src/com/google/inject/internal/Errors.java
Patch:
@@ -226,7 +226,7 @@ public Errors misplacedBindingAnnotation(Member member, Annotation bindingAnnota
 
   private static final String CONSTRUCTOR_RULES =
       "Classes must have either one (and only one) constructor "
-          + "annotated with @Inject or a zero-argument constructor.";
+          + "annotated with @Inject or a zero-argument constructor that is not private.";
 
   public Errors missingConstructor(Class<?> implementation) {
     return addMessage("Could not find a suitable constructor in %s. " + CONSTRUCTOR_RULES,

File: test/com/google/inject/AllTests.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.inject.commands.CommandRecorderTest;
 import com.google.inject.commands.CommandReplayerTest;
 import com.google.inject.commands.CommandRewriteTest;
-import com.google.inject.internal.BytecodeGenTest;
 import com.google.inject.internal.FinalizableReferenceQueueTest;
 import com.google.inject.internal.LineNumbersTest;
 import com.google.inject.internal.ReferenceCacheTest;
@@ -29,6 +28,7 @@
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.util.ProvidersTest;
 import com.google.inject.util.TypesTest;
+import com.googlecode.guice.BytecodeGenTest;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 

File: test/com/google/inject/ProviderMethodsTest.java
Patch:
@@ -184,7 +184,7 @@ public void testGenericProviderMethods() {
     Injector injector = Guice.createInjector(ProviderMethods.from(source));
     
     assertEquals("A", injector.getInstance(Key.get(String.class, Names.named("First"))));
-    assertEquals("B", injector.getInstance(Key.get(String.class, Names.named("First"))));
+    assertEquals("B", injector.getInstance(Key.get(String.class, Names.named("Second"))));
     assertEquals(ImmutableSet.of("A", "B"),
         injector.getInstance(Key.get(Types.setOf(String.class))));
   }

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
+import static com.google.inject.internal.BytecodeGen.newFastClass;
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ErrorsException;
-import com.google.inject.internal.GuiceFastClass;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Modifier;
@@ -67,7 +67,7 @@ public Constructor getConstructor() {
 
     return new ConstructionProxy<T>() {
       Class<T> classToConstruct = constructor.getDeclaringClass();
-      FastClass fastClass = GuiceFastClass.create(classToConstruct);
+      FastClass fastClass = newFastClass(classToConstruct);
       final FastConstructor fastConstructor = fastClass.getConstructor(constructor);
 
       @SuppressWarnings("unchecked")

File: test/com/google/inject/AllTests.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.inject.commands.CommandRecorderTest;
 import com.google.inject.commands.CommandReplayerTest;
 import com.google.inject.commands.CommandRewriteTest;
+import com.google.inject.internal.BytecodeGenTest;
 import com.google.inject.internal.FinalizableReferenceQueueTest;
 import com.google.inject.internal.LineNumbersTest;
 import com.google.inject.internal.ReferenceCacheTest;
@@ -84,6 +85,7 @@ public static Test suite() {
     suite.addTestSuite(ReferenceMapTest.class);
     suite.addTestSuite(TypesTest.class);
     suite.addTestSuite(UniqueAnnotationsTest.class);
+    suite.addTestSuite(BytecodeGenTest.class);
 
     // matcher
     suite.addTestSuite(MatcherTest.class);

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.inject.internal.GuiceFastClass;
 import com.google.inject.internal.GuiceNamingPolicy;
 import com.google.inject.internal.ReferenceCache;
+import com.google.inject.internal.StackTraceElements;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -61,7 +62,7 @@ public <T> ConstructionProxy<T> get(Errors errors, Constructor<T> constructor)
 
   Map<Constructor<?>, Object> constructionProxies = new ReferenceCache<Constructor<?>, Object>() {
     protected Object create(Constructor<?> constructor) {
-      Errors errors = new Errors();
+      Errors errors = new Errors(StackTraceElements.forMember(constructor));
       try {
         ConstructionProxy<?> result = createConstructionProxy(errors, constructor);
         errors.throwIfNecessary();

File: src/com/google/inject/ScopesCommandProcessor.java
Patch:
@@ -45,12 +45,12 @@ class ScopesCommandProcessor extends CommandProcessor {
     Class<? extends Annotation> annotationType = command.getAnnotationType();
 
     if (!Scopes.isScopeAnnotation(annotationType)) {
-      errors.at(StackTraceElements.forType(annotationType)).missingScopeAnnotation();
+      errors.withSource(StackTraceElements.forType(annotationType)).missingScopeAnnotation();
       // Go ahead and bind anyway so we don't get collateral errors.
     }
 
     if (!Annotations.isRetainedAtRuntime(annotationType)) {
-      errors.at(StackTraceElements.forType(annotationType))
+      errors.withSource(StackTraceElements.forType(annotationType))
           .missingRuntimeRetention(command.getSource());
       // Go ahead and bind anyway so we don't get collateral errors.
     }

File: src/com/google/inject/commands/Command.java
Patch:
@@ -29,8 +29,7 @@ public interface Command {
    * Visit commands.
    */
   public interface Visitor<V> {
-    V visitAddMessageError(AddMessageErrorCommand command);
-    V visitAddError(AddThrowableErrorCommand command);
+    V visitAddMessage(AddMessageCommand command);
     V visitBindInterceptor(BindInterceptorCommand command);
     V visitBindScope(BindScopeCommand command);
     V visitRequestStaticInjection(RequestStaticInjectionCommand command);

File: src/com/google/inject/commands/CommandRecorder.java
Patch:
@@ -138,15 +138,15 @@ public Stage currentStage() {
     }
 
     public void addError(String message, Object... arguments) {
-      commands.add(new AddMessageErrorCommand(getSource(), message, arguments));
+      commands.add(new AddMessageCommand(getSource(), message, arguments));
     }
 
     public void addError(Throwable t) {
-      commands.add(new AddThrowableErrorCommand(getSource(), t));
+      commands.add(new AddMessageCommand(getSource(), t));
     }
 
     public void addError(Message message) {
-      throw new UnsupportedOperationException("TODO");
+      commands.add(new AddMessageCommand(message));
     }
 
     public <T> BindCommand<T>.BindingBuilder bind(Key<T> key) {

File: test/com/google/inject/BinderTest.java
Patch:
@@ -201,9 +201,10 @@ protected void configure() {
       });
       fail();
     } catch (CreationException expected) {
-      Asserts.assertContains(expected.getMessage(),
+      assertContains(expected.getMessage(),
+          "Error at " + getClass().getName(), ".configure(BinderTest.java",
           "A binding to java.lang.String[] was already configured");
-      Asserts.assertContains(expected.getMessage(),
+      assertContains(expected.getMessage(),
           "1 error[s]");
     }
   }

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.inject.internal.GuiceFastClass;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Member;
 import java.lang.reflect.Modifier;
 import java.util.List;
 import net.sf.cglib.reflect.FastClass;
@@ -60,7 +59,7 @@ public T newInstance(Object... arguments) throws
         public List<Parameter<?>> getParameters() {
           return parameters;
         }
-        public Member getMember() {
+        public Constructor getConstructor() {
           return constructor;
         }
       };
@@ -78,7 +77,7 @@ public T newInstance(Object... arguments) throws InvocationTargetException {
       public List<Parameter<?>> getParameters() {
         return parameters;
       }
-      public Member getMember() {
+      public Constructor getConstructor() {
         return constructor;
       }
     };

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -25,7 +25,6 @@
 import com.google.inject.internal.ReferenceCache;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
@@ -188,7 +187,7 @@ public List<Parameter<?>> getParameters() {
         return parameters;
       }
 
-      public Member getMember() {
+      public Constructor getConstructor() {
         return standardConstructor;
       }
     };

File: src/com/google/inject/spi/SourceProviders.java
Patch:
@@ -86,8 +86,7 @@ public static Object defaultSource() {
    * Sets the default source provider, runs the given command, and then
    * restores the previous default source provider.
    */
-  public static void withDefault(
-      SourceProvider sourceProvider, Runnable r) {
+  private static void withDefault(SourceProvider sourceProvider, Runnable r) {
     // We use a holder so we perform only 1 thread local access instead of 3.
     SourceProvider[] holder = localSourceProvider.get();
     SourceProvider previous = holder[0];

File: extensions/compiletime/src/com/google/inject/CodeGenReflectionFactory.java
Patch:
@@ -20,7 +20,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.common.collect.Maps;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -82,7 +82,7 @@ private CodeGenReflection(Reflection delegate) {
     }
 
     public <T> ConstructionProxy<T> getConstructionProxy(Errors errors, Class<T> implementation)
-        throws ResolveFailedException {
+        throws ErrorsException {
       ConstructionProxy<T> result = delegate.getConstructionProxy(errors, implementation);
       constructionProxies.put(implementation, result);
       return result;

File: src/com/google/inject/BindingImpl.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.ProviderBinding;
 
@@ -91,7 +91,7 @@ LoadStrategy getLoadStrategy() {
    * Perform any post-creation initialization, that could require construction
    * of other bindings.
    */
-  void initialize(InjectorImpl injector, Errors errors) throws ResolveFailedException {}
+  void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {}
 
   public String toString() {
     return new ToStringBuilder(Binding.class)

File: src/com/google/inject/ClassBindingImpl.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.inject.InjectorImpl.SingleParameterInjector;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.BindingVisitor;
 import com.google.inject.spi.ClassBinding;
@@ -42,7 +42,7 @@ class ClassBindingImpl<T> extends BindingImpl<T>
     this.lateBoundConstructor = lateBoundConstructor;
   }
 
-  @Override void initialize(InjectorImpl injector, Errors errors) throws ResolveFailedException {
+  @Override void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {
     lateBoundConstructor.bind(injector, getBoundClass());
   }
 
@@ -65,7 +65,7 @@ public Collection<InjectionPoint<?>> getInjectionPoints() {
     Collection<InjectionPoint<?>> injectors;
     try {
       injectors = injector.getModifiableFieldAndMethodInjectionsFor(boundClass);
-    } catch (ResolveFailedException e) {
+    } catch (ErrorsException e) {
       throw new AssertionError("This should have failed at CreationTime");
     }
 

File: src/com/google/inject/ConstantFactory.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
-import com.google.inject.spi.InjectionPoint;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ToStringBuilder;
+import com.google.inject.spi.InjectionPoint;
 
 /**
  * @author crazybob@google.com (Bob Lee)
@@ -33,7 +33,7 @@ public ConstantFactory(T value) {
   }
 
   public T get(Errors errors, InternalContext context, InjectionPoint injectionPoint)
-      throws ResolveFailedException {
+      throws ErrorsException {
     context.ensureMemberInjected(errors, value);
     return value;
   }

File: src/com/google/inject/ConstructionContext.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -62,7 +62,7 @@ void finishConstruction() {
     invocationHandlers = null;
   }
 
-  Object createProxy(Errors errors, Class<?> expectedType) throws ResolveFailedException {
+  Object createProxy(Errors errors, Class<?> expectedType) throws ErrorsException {
     // TODO: if I create a proxy which implements all the interfaces of
     // the implementation type, I'll be able to get away with one proxy
     // instance (as opposed to one per caller).

File: src/com/google/inject/ConstructionProxyFactory.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import java.lang.reflect.Constructor;
 
 /**
@@ -31,5 +31,5 @@ interface ConstructionProxyFactory {
    * Gets a construction proxy for the given constructor.
    */
   <T> ConstructionProxy<T> get(Errors errors, Constructor<T> constructor)
-      throws ResolveFailedException;
+      throws ErrorsException;
 }

File: src/com/google/inject/ContextualCallable.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject;
 
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 
 /**
  * @author crazybob@google.com (Bob Lee)
 */
 interface ContextualCallable<T> {
-  T call(InternalContext context) throws ResolveFailedException;
+  T call(InternalContext context) throws ErrorsException;
 }

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.GuiceFastClass;
-import com.google.inject.internal.ResolveFailedException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Member;
@@ -37,7 +37,7 @@
 class DefaultConstructionProxyFactory implements ConstructionProxyFactory {
 
   public <T> ConstructionProxy<T> get(Errors errors, final Constructor<T> constructor)
-      throws ResolveFailedException {
+      throws ErrorsException {
     final List<Parameter<?>> parameters = Parameter.forConstructor(constructor, errors);
 
     // We can't use FastConstructor if the constructor is private or protected.

File: src/com/google/inject/ErrorsCommandProcessor.java
Patch:
@@ -33,12 +33,12 @@ class ErrorsCommandProcessor extends CommandProcessor {
   }
 
   @Override public Boolean visitAddMessageError(AddMessageErrorCommand command) {
-    errors.at(command.getSource()).userReportedError(command.getMessage(), command.getArguments());
+    errors.userReportedError(command.getMessage(), command.getArguments());
     return true;
   }
 
   @Override public Boolean visitAddError(AddThrowableErrorCommand command) {
-    errors.at(command.getSource()).exceptionReportedByModuleSeeLogs(command.getThrowable());
+    errors.exceptionReportedByModuleSeeLogs(command.getThrowable());
     return true;
   }
 }

File: src/com/google/inject/GetProviderProcessor.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.inject.commands.GetProviderCommand;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 
 /**
  * Handles {@link Binder#getProvider} commands.
@@ -39,7 +39,7 @@ class GetProviderProcessor extends CommandProcessor {
     // ensure the provider can be created
     try {
       injector.getProviderOrThrow(command.getKey(), errors);
-    } catch (ResolveFailedException e) {
+    } catch (ErrorsException e) {
       errors.merge(e.getErrors()); // TODO: source
     }
 

File: src/com/google/inject/InstanceBindingImpl.java
Patch:
@@ -17,7 +17,7 @@
 
 package com.google.inject;
 
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.BindingVisitor;
 import com.google.inject.spi.InjectionPoint;
@@ -54,7 +54,7 @@ public Collection<InjectionPoint<?>> getInjectionPoints() {
     try {
       return injector.getFieldAndMethodInjectionsFor(instance.getClass());
     }
-    catch (ResolveFailedException e) {
+    catch (ErrorsException e) {
       // this would have been a creation exception
       // TODO: initialize the dependencies via a callback
       throw new AssertionError(e);

File: src/com/google/inject/InternalContext.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;
-import com.google.inject.internal.ResolveFailedException;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -73,7 +73,7 @@ public void setInjectionPoint(InjectionPoint injectionPoint) {
    * Ensures that an object requiring injection at Injector-creation time has
    * been injected before its use.
    */
-  public void ensureMemberInjected(Errors errors, Object toInject) throws ResolveFailedException {
+  public void ensureMemberInjected(Errors errors, Object toInject) throws ErrorsException {
     if (!injector.outstandingInjections.remove(toInject)) {
       return;
     }

File: src/com/google/inject/InternalFactory.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.spi.InjectionPoint;
-import com.google.inject.internal.ResolveFailedException;
 
 /**
  * Creates objects which will be injected.
@@ -31,9 +31,9 @@ interface InternalFactory<T> {
    * Creates an object to be injected.
    *
    * @param context of this injection
-   * @throws ResolveFailedException if a value cannot be provided
+   * @throws com.google.inject.internal.ErrorsException if a value cannot be provided
    * @return instance to be injected
    */
   T get(Errors errors, InternalContext context, InjectionPoint<?> injectionPoint)
-      throws ResolveFailedException;
+      throws ErrorsException;
 }

File: src/com/google/inject/ProviderInstanceBindingImpl.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.BindingVisitor;
 import com.google.inject.spi.InjectionPoint;
@@ -52,7 +52,7 @@ public Collection<InjectionPoint<?>> getInjectionPoints() {
     try {
       return injector.getFieldAndMethodInjectionsFor(providerInstance.getClass());
     }
-    catch (ResolveFailedException e) {
+    catch (ErrorsException e) {
       // this would have been a creation exception
       // TODO: initialize the dependencies via a callback
       throw new AssertionError(e);

File: src/com/google/inject/Reflection.java
Patch:
@@ -18,7 +18,7 @@
 package com.google.inject;
 
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 
 /**
  * Abstraction for Java's reflection APIs. This interface exists to provide a
@@ -30,7 +30,7 @@
 interface Reflection {
 
   public <T> ConstructionProxy<T> getConstructionProxy(Errors errors, Class<T> implementation)
-      throws ResolveFailedException;
+      throws ErrorsException;
 
   interface Factory {
     Reflection create(ConstructionProxyFactory constructionProxyFactory);

File: src/com/google/inject/RuntimeReflectionFactory.java
Patch:
@@ -19,7 +19,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.internal.Errors;
-import com.google.inject.internal.ResolveFailedException;
+import com.google.inject.internal.ErrorsException;
 import java.lang.reflect.Constructor;
 
 /**
@@ -38,12 +38,12 @@ private RuntimeReflection(ConstructionProxyFactory constructionProxyFactory) {
     }
 
     public <T> ConstructionProxy<T> getConstructionProxy(Errors errors, Class<T> implementation)
-        throws ResolveFailedException {
+        throws ErrorsException {
       return constructionProxyFactory.get(errors, findConstructorIn(errors, implementation));
     }
 
     private <T> Constructor<T> findConstructorIn(Errors errors, Class<T> implementation)
-        throws ResolveFailedException{
+        throws ErrorsException {
       Constructor<T> found = null;
       @SuppressWarnings("unchecked")
       Constructor<T>[] constructors

File: src/com/google/inject/ScopesCommandProcessor.java
Patch:
@@ -57,7 +57,7 @@ class ScopesCommandProcessor extends CommandProcessor {
 
     Scope existing = scopes.get(checkNotNull(annotationType, "annotation type"));
     if (existing != null) {
-      errors.at(command.getSource()).duplicateScopes(existing, annotationType, scope);
+      errors.duplicateScopes(existing, annotationType, scope);
     } else {
       scopes.put(annotationType, checkNotNull(scope, "scope"));
     }

File: src/com/google/inject/internal/Keys.java
Patch:
@@ -29,7 +29,7 @@ public class Keys {
    * Gets a key for the given type, member and annotations.
    */
   public static Key<?> get(Type type, Member member, Annotation[] annotations, Errors errors)
-      throws ResolveFailedException {
+      throws ErrorsException {
     Annotation found = null;
     for (Annotation annotation : annotations) {
       if (annotation.annotationType().getAnnotation(BindingAnnotation.class) != null) {

File: src/com/google/inject/spi/InjectionPoint.java
Patch:
@@ -19,8 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import com.google.inject.Key;
 import com.google.inject.internal.Errors;
+import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.MoreTypes;
-import com.google.inject.internal.ResolveFailedException;
 import com.google.inject.internal.ToStringBuilder;
 import java.io.Serializable;
 import java.lang.reflect.Field;
@@ -69,7 +69,7 @@ public String toString() {
         .toString();
   }
 
-  public <T> T checkForNull(Errors errors, T value, Object source) throws ResolveFailedException {
+  public <T> T checkForNull(Errors errors, T value, Object source) throws ErrorsException {
     if (value != null
         || allowsNull()
         || allowNullsBadBadBad()) {

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -49,7 +49,7 @@ public Object invoke(MethodInvocation methodInvocation) {
       fail();
     } catch (CreationException expected) {
       assertContains(expected.getMessage(),
-          "Error at " + A.class.getName() + "<init>(LineNumbersTest:",
+          "Error at " + A.class.getName() + ".<init>(LineNumbersTest.java",
           "No implementation for " + B.class.getName() + " was bound.");
     }
   }

File: src/com/google/inject/ContextualCallable.java
Patch:
@@ -16,9 +16,11 @@
 
 package com.google.inject;
 
+import com.google.inject.internal.ResolveFailedException;
+
 /**
  * @author crazybob@google.com (Bob Lee)
 */
 interface ContextualCallable<T> {
-  T call(InternalContext context);
+  T call(InternalContext context) throws ResolveFailedException;
 }

File: src/com/google/inject/InvalidBindingImpl.java
Patch:
@@ -16,13 +16,15 @@
 
 package com.google.inject;
 
+import com.google.inject.internal.Errors;
+import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.BindingVisitor;
 
 class InvalidBindingImpl<T> extends BindingImpl<T> {
 
   InvalidBindingImpl(InjectorImpl injector, Key<T> key, Object source) {
     super(injector, key, source, new InternalFactory<T>() {
-      public T get(InternalContext context, InjectionPoint<?> injectionPoint) {
+      public T get(Errors errors, InternalContext context, InjectionPoint<?> injectionPoint) {
         throw new AssertionError();
       }
     }, Scopes.NO_SCOPE, LoadStrategy.LAZY);

File: test/com/google/inject/ConstantConversionTest.java
Patch:
@@ -123,7 +123,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidInteger.class);
       fail();
-    } catch (CreationException expected) { /* expected */ }
+    } catch (ProvisionException expected) { /* expected */ }
   }
 
   public static class InvalidInteger {
@@ -140,7 +140,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidCharacter.class);
       fail();
-    } catch (CreationException expected) { /* expected */ }
+    } catch (ProvisionException expected) { /* expected */ }
   }
 
   public static class InvalidCharacter {
@@ -157,7 +157,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidEnum.class);
       fail();
-    } catch (CreationException expected) { /* expected */ }
+    } catch (ProvisionException expected) { /* expected */ }
   }
 
   public static class InvalidEnum {

File: test/com/google/inject/OptionalBindingTest.java
Patch:
@@ -246,9 +246,9 @@ public void testOptionalConstructorBlowsUp() {
     try {
       Guice.createInjector().getInstance(HasOptionalConstructor.class);
       fail();
-    } catch (CreationException expected) {
-      assertContains(expected.getMessage(),
-          "@Inject(optional=true) is not allowed on constructors");
+    } catch (ProvisionException expected) {
+      assertContains(expected.getMessage(), "OptionalBindingTest$HasOptionalConstructor() "
+          + "is annotated @Inject(optional=true), but constructors cannot be optional.");
     }
   }
 

File: test/com/google/inject/TypeConversionTest.java
Patch:
@@ -132,7 +132,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidInteger.class);
       fail();
-    } catch (CreationException expected) {
+    } catch (ProvisionException expected) {
       assertContains(expected.getMessage(), "Error converting 'invalid'");
       assertContains(expected.getMessage(), "bound at " + getClass().getName());
       assertContains(expected.getMessage(), "to java.lang.Integer");
@@ -153,7 +153,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidCharacter.class);
       fail();
-    } catch (CreationException expected) {
+    } catch (ProvisionException expected) {
       assertContains(expected.getMessage(), "Error converting 'invalid'");
       assertContains(expected.getMessage(), "bound at " + getClass().getName());
       assertContains(expected.getMessage(), "to java.lang.Character");
@@ -174,7 +174,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidEnum.class);
       fail();
-    } catch (CreationException expected) {
+    } catch (ProvisionException expected) {
       assertContains(expected.getMessage(), "Error converting 'invalid'");
       assertContains(expected.getMessage(), "bound at " + getClass().getName());
       assertContains(expected.getMessage(), "to " + Bar.class.getName());

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -49,8 +49,8 @@ public Object invoke(MethodInvocation methodInvocation) {
       fail();
     } catch (CreationException expected) {
       assertContains(expected.getMessage(),
-          "Error at " + A.class.getName() + "(" + B.class.getName());
-      assertContains(expected.getMessage(), "Injecting into abstract types is not supported.");
+          "Error at " + A.class.getName() + "<init>(LineNumbersTest:",
+          "No implementation for " + B.class.getName() + " was bound.");
     }
   }
 

File: src/com/google/inject/BindingImpl.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject;
 
+import com.google.inject.internal.Errors;
 import com.google.inject.internal.ResolveFailedException;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.ProviderBinding;
@@ -90,7 +91,7 @@ LoadStrategy getLoadStrategy() {
    * Perform any post-creation initialization, that could require construction
    * of other bindings.
    */
-  void initialize(InjectorImpl injector) throws ResolveFailedException {}
+  void initialize(InjectorImpl injector, Errors errors) throws ResolveFailedException {}
 
   public String toString() {
     return new ToStringBuilder(Binding.class)

File: src/com/google/inject/commands/BindCommand.java
Patch:
@@ -26,7 +26,6 @@
 import com.google.inject.binder.ConstantBindingBuilder;
 import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.binder.ScopedBindingBuilder;
-import com.google.inject.internal.ErrorMessage;
 import com.google.inject.spi.SourceProviders;
 import java.lang.annotation.Annotation;
 
@@ -186,8 +185,6 @@ public <V> V acceptVisitor(Visitor<T, V> visitor) {
     }
 
     public void toInstance(final T instance) {
-      checkNotNull(instance, ErrorMessage.cannotBindToNullInstance().toString());
-
       checkNotTargetted();
       bindTarget = new AbstractTarget<T>() {
         public ScopedBindingBuilder execute(LinkedBindingBuilder<T> linkedBindingBuilder) {

File: src/com/google/inject/internal/ErrorHandler.java
Patch:
@@ -28,7 +28,7 @@ public interface ErrorHandler {
   /**
    * Handles an error.
    */
-  void handle(Object source, ErrorMessage errorMessage);
+  void handle(Object source, Errors errors);
 
   /**
    * Handles a user-reported error.

File: src/com/google/inject/spi/ClassBinding.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public interface ClassBinding<T> extends Binding<T>, HasDependencies {
+public interface ClassBinding<T> extends Binding<T>, HasInjections {
 
   /**
    * Gets the class associated with this binding.

File: src/com/google/inject/spi/InstanceBinding.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public interface InstanceBinding<T> extends Binding<T>, HasDependencies {
+public interface InstanceBinding<T> extends Binding<T>, HasInjections {
 
   /**
    * Gets the instance associated with this binding.

File: src/com/google/inject/spi/ProviderInstanceBinding.java
Patch:
@@ -26,8 +26,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-public interface ProviderInstanceBinding<T> extends Binding<T>,
-    HasDependencies {
+public interface ProviderInstanceBinding<T> extends Binding<T>, HasInjections {
 
   /**
    * Gets the raw (unscoped) provider instance associated with this binding.

File: src/com/google/inject/BoundProviderFactory.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject;
 
 import com.google.inject.BindCommandProcessor.CreationListener;
-import com.google.inject.internal.ErrorMessages;
+import com.google.inject.internal.ErrorMessage;
 import com.google.inject.internal.ResolveFailedException;
 
 /**
@@ -43,7 +43,7 @@ public void run() {
         try {
           providerFactory = injector.getInternalFactory(providerKey);
         } catch (ResolveFailedException e) {
-          injector.errorHandler.handle(source, e.getMessage());
+          injector.errorHandler.handle(e.getMessage(source));
         }
       }
     });
@@ -56,7 +56,7 @@ public T get(InternalContext context, InjectionPoint<?> injectionPoint) {
     } catch(ProvisionException e) {
       throw e;
     } catch(RuntimeException e) {
-      throw new ProvisionException(e, ErrorMessages.ERROR_IN_PROVIDER);
+      throw new ProvisionException(ErrorMessage.errorInProvider().toString(), e);
     }
   }
 

File: src/com/google/inject/FactoryProxy.java
Patch:
@@ -45,7 +45,7 @@ public void run() {
         try {
           targetFactory = injector.getInternalFactory(targetKey);
         } catch (ResolveFailedException e) {
-          injector.errorHandler.handle(source, e.getMessage());
+          injector.errorHandler.handle(e.getMessage(source));
         }
       }
     });

File: src/com/google/inject/GetProviderProcessor.java
Patch:
@@ -37,7 +37,7 @@ class GetProviderProcessor extends CommandProcessor {
     try {
       // ensure the provider can be created
       injector.getProvider(command.getKey());
-    } catch (ConfigurationException e) {
+    } catch (CreationException e) {
       injector.handleMissingBinding(command.getSource(), command.getKey());
     }
 

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.inject;
 
-import com.google.inject.internal.ErrorMessages;
-import com.google.inject.spi.SourceProviders;
 import static com.google.common.base.Preconditions.checkNotNull;
+import com.google.inject.internal.ErrorMessage;
+import com.google.inject.spi.SourceProviders;
 
 /**
  * @author crazybob@google.com (Bob Lee)
@@ -45,7 +45,7 @@ public T get(InternalContext context, InjectionPoint<?> injectionPoint) {
     } catch(ProvisionException e) {
       throw e;
     } catch(RuntimeException e) {
-      throw new ProvisionException(e, ErrorMessages.ERROR_IN_PROVIDER);
+      throw new ProvisionException(ErrorMessage.errorInProvider().toString(), e);
     }
   }
 

File: test/com/google/inject/ConstantConversionTest.java
Patch:
@@ -123,7 +123,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidInteger.class);
       fail();
-    } catch (ConfigurationException e) { /* expected */ }
+    } catch (CreationException expected) { /* expected */ }
   }
 
   public static class InvalidInteger {
@@ -140,7 +140,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidCharacter.class);
       fail();
-    } catch (ConfigurationException e) { /* expected */ }
+    } catch (CreationException expected) { /* expected */ }
   }
 
   public static class InvalidCharacter {
@@ -157,7 +157,7 @@ protected void configure() {
     try {
       injector.getInstance(InvalidEnum.class);
       fail();
-    } catch (ConfigurationException e) { /* expected */ }
+    } catch (CreationException expected) { /* expected */ }
   }
 
   public static class InvalidEnum {

File: test/com/google/inject/OptionalBindingTest.java
Patch:
@@ -246,7 +246,7 @@ public void testOptionalConstructorBlowsUp() {
     try {
       Guice.createInjector().getInstance(HasOptionalConstructor.class);
       fail();
-    } catch (ConfigurationException expected) {
+    } catch (CreationException expected) {
       assertContains(expected.getMessage(),
           "@Inject(optional=true) is not allowed on constructors");
     }

File: test/com/google/inject/ProvisionExceptionTest.java
Patch:
@@ -18,9 +18,8 @@
 
 import static com.google.inject.Asserts.assertContains;
 import static com.google.inject.Asserts.assertSimilarWhenReserialized;
-import junit.framework.TestCase;
-
 import java.io.IOException;
+import junit.framework.TestCase;
 
 /**
  * @author jessewilson@google.com (Jesse Wilson)
@@ -189,7 +188,7 @@ public D get() {
 
   static class F {
     @Inject public F() {
-      throw new ProvisionException(new RuntimeException(), "User Exception");
+      throw new ProvisionException("User Exception", new RuntimeException());
     }
   }
 

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -48,7 +48,8 @@ public Object invoke(MethodInvocation methodInvocation) {
       });
       fail();
     } catch (CreationException expected) {
-      assertContains(expected.getMessage(), "LineNumbersTest$B");
+      assertContains(expected.getMessage(),
+          "Error at " + A.class.getName() + "(" + B.class.getName());
       assertContains(expected.getMessage(), "Injecting into abstract types is not supported.");
     }
   }

File: extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java
Patch:
@@ -144,7 +144,7 @@ private static <K, V> TypeLiteral<Map<K, Provider<V>>> mapOfProviderOf(
   }
   
   private static Type entryOfProviderOf(Type keyType, final Type valueType) {
-    return Types.newParameterizedType(Map.Entry.class, keyType,
+    return Types.newParameterizedTypeWithOwner(Map.class, Map.Entry.class, keyType,
         Types.providerOf(valueType));
   }
 

File: extensions/multibindings/test/com/google/inject/multibindings/MapBinderTest.java
Patch:
@@ -241,9 +241,9 @@ public void testMapBinderMapForbidsNullValues() {
     try {
       injector.getInstance(Key.get(mapOfString));
       fail();
-    } catch(IllegalStateException expected) {
+    } catch(ProvisionException expected) {
       assertEquals("Map injection failed due to null value for key \"null\"",
-          expected.getMessage());
+          expected.getCause().getMessage());
     }
   }
 

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.inject.multibindings;
 
 import com.google.inject.*;
+import com.google.inject.util.Types;
 import com.google.inject.binder.LinkedBindingBuilder;
-import com.google.inject.internal.Types;
 import com.google.inject.spi.SourceProviders;
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -112,7 +112,7 @@ public static <T> Multibinder<T> newSetBinder(Binder binder, Type type,
 
   @SuppressWarnings("unchecked")
   private static <T> TypeLiteral<Set<T>> setOf(Type elementType) {
-    Type type = Types.newTypeWithArgument(Set.class, elementType);
+    Type type = Types.setOf(elementType);
     return (TypeLiteral<Set<T>>) TypeLiteral.get(type);
   }
 

File: src/com/google/inject/Key.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.inject.internal.Annotations;
 import com.google.inject.internal.ToStringBuilder;
-import com.google.inject.internal.Types;
+import com.google.inject.internal.MoreTypes;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import java.io.Serializable;
@@ -121,15 +121,15 @@ protected Key() {
   @SuppressWarnings("unchecked")
   private Key(Type type, AnnotationStrategy annotationStrategy) {
     this.annotationStrategy = annotationStrategy;
-    this.typeLiteral = Types.wrapPrimitives((TypeLiteral<T>) TypeLiteral.get(type));
+    this.typeLiteral = MoreTypes.wrapPrimitives((TypeLiteral<T>) TypeLiteral.get(type));
     this.hashCode = computeHashCode();
   }
 
   /** Constructs a key from a manually specified type. */
   private Key(TypeLiteral<T> typeLiteral,
       AnnotationStrategy annotationStrategy) {
     this.annotationStrategy = annotationStrategy;
-    this.typeLiteral = Types.wrapPrimitives(typeLiteral);
+    this.typeLiteral = MoreTypes.wrapPrimitives(typeLiteral);
     this.hashCode = computeHashCode();
   }
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.inject.internal.*;
 import com.google.inject.matcher.MatcherTest;
 import com.google.inject.util.ProvidersTest;
+import com.google.inject.util.TypesTest;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 

File: test/com/google/inject/TypeLiteralTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import static com.google.inject.Asserts.assertEqualWhenReserialized;
 import static com.google.inject.Asserts.assertEqualsBothWays;
-import com.google.inject.internal.Types;
+import com.google.inject.util.Types;
 import junit.framework.TestCase;
 
 import java.io.IOException;
@@ -32,7 +32,7 @@ public class TypeLiteralTest extends TestCase {
   public void testWithParameterizedType() {
     TypeLiteral<List<String>> a = new TypeLiteral<List<String>>() {};
     TypeLiteral<List<String>> b = new TypeLiteral<List<String>>(
-        Types.newTypeWithArgument(List.class, String.class)) {};
+        Types.listOf(String.class)) {};
     assertEqualsBothWays(a, b);
   }
 

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -944,7 +944,7 @@ T inject(InternalContext context) {
         throw new ProvisionException(runtimeException, ErrorMessages.ERROR_INJECTING_METHOD);
       }
       finally {
-        context.setInjectionPoint(injectionPoint);
+        context.setInjectionPoint(null);
       }
     }
   }

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -64,7 +64,6 @@ public void testSingletons() {
         injector.getInstance(LinkedSingleton.class),
         injector.getInstance(LinkedSingleton.class));
 
-
     assertSame(
         injector.getInstance(JustInTimeSingleton.class),
         injector.getInstance(JustInTimeSingleton.class));

File: test/com/google/inject/AllTests.java
Patch:
@@ -54,7 +54,6 @@ public static Test suite() {
     suite.addTestSuite(OptionalBindingTest.class);
     suite.addTestSuite(OverrideModuleTest.class);
     suite.addTestSuite(ParentInjectorTest.class);
-    suite.addTestSuite(PreloadingTest.class);
     suite.addTestSuite(ProviderInjectionTest.class);
     suite.addTestSuite(ProviderMethodsTest.class);
     suite.addTestSuite(ProvisionExceptionTest.class);

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProviderTest.java
Patch:
@@ -509,8 +509,8 @@ public void testFactoryFailsWithMissingBinding() {
       });
       fail();
     } catch (ProvisionException expected) {
-      assertContains(expected.getMessage(), "Parameter of type 'double' is not " +
-          "injectable or annotated with @Assisted");
+      assertContains(expected.getCause().getMessage(),
+          "Parameter of type 'double' is not injectable or annotated with @Assisted");
     }
   }
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -40,7 +40,7 @@ public static Test suite() {
     suite.addTestSuite(BoundInstanceInjectionTest.class);
     suite.addTestSuite(BoundProviderTest.class);
     suite.addTestSuite(CircularDependencyTest.class);
-    suite.addTestSuite(ConstantConversionTest.class);
+    suite.addTestSuite(TypeConversionTest.class);
     // suite.addTestSuite(ErrorHandlingTest.class); not a testcase
     suite.addTestSuite(ErrorMessagesTest.class);
     suite.addTestSuite(GenericInjectionTest.class);

File: src/com/google/inject/ProviderMethods.java
Patch:
@@ -16,10 +16,11 @@
 
 package com.google.inject;
 
-import com.google.inject.internal.StackTraceElements;
 import com.google.inject.internal.ErrorMessages;
+import com.google.inject.internal.StackTraceElements;
 import com.google.inject.spi.SourceProvider;
 import com.google.inject.spi.SourceProviders;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -28,7 +29,7 @@
 import java.util.List;
 
 /**
- * Creates bindings to methods annotated with
+ * Creates bindings to methods annotated with {@literal @}
  * {@link com.google.inject.Provides}. Use the scope and binding annotations
  * on the provider method to configure the binding.
  */

File: src/com/google/inject/matcher/Matchers.java
Patch:
@@ -300,7 +300,7 @@ public boolean matches(Class c) {
     }
 
     @Override public String toString() {
-      return "package(" + targetPackage.getName() + ")";
+      return "inPackage(" + targetPackage.getName() + ")";
     }
 
     public Object readResolve() {

File: test/com/google/inject/KeyTest.java
Patch:
@@ -80,6 +80,7 @@ public void testSerialization() throws IOException {
     assertEqualWhenReserialized(Key.get(B[].class));
     assertEqualWhenReserialized(Key.get(new TypeLiteral<Map<List<B>, B>>() {}));
     assertEqualWhenReserialized(Key.get(new TypeLiteral<List<B[]>>() {}));
+    assertEqualWhenReserialized(new Key<List<B[]>>() {});
   }
 
   interface B {}

File: test/com/google/inject/TypeLiteralTest.java
Patch:
@@ -73,9 +73,7 @@ public void testTypesInvolvingArraysForEquality() {
   public void testEqualityOfGenericArrayAndClassArray() {
     TypeLiteral<String[]> arrayAsClass = TypeLiteral.get(String[].class);
     TypeLiteral<String[]> arrayAsType = new TypeLiteral<String[]>() {};
-    assertEquals("Known failure. Although they're functionally equal, Java has two non-equal "
-        + "Types that can represent a String[]. We should probably choose a canonical form.",
-        arrayAsClass, arrayAsType);
+    assertEquals(arrayAsClass, arrayAsType);
   }
 
   public void testSerialization() throws IOException {

File: extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java
Patch:
@@ -19,7 +19,7 @@
 import com.google.inject.*;
 import com.google.inject.binder.LinkedBindingBuilder;
 import static com.google.inject.internal.Objects.nonNull;
-import com.google.inject.internal.TypeWithArgument;
+import com.google.inject.internal.Types;
 import com.google.inject.spi.SourceProviders;
 
 import java.lang.annotation.Annotation;
@@ -112,7 +112,7 @@ public static <T> Multibinder<T> newSetBinder(Binder binder, Type type,
 
   @SuppressWarnings("unchecked")
   private static <T> TypeLiteral<Set<T>> setOf(Type elementType) {
-    Type type = new TypeWithArgument(Set.class, elementType);
+    Type type = Types.newTypeWithArgument(Set.class, elementType);
     return (TypeLiteral<Set<T>>) TypeLiteral.get(type);
   }
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -77,7 +77,7 @@ public static Test suite() {
     suite.addTestSuite(LineNumbersTest.class);
     suite.addTestSuite(ReferenceCacheTest.class);
     suite.addTestSuite(ReferenceMapTest.class);
-    suite.addTestSuite(TypeWithArgumentTest.class);
+    suite.addTestSuite(TypesTest.class);
     suite.addTestSuite(UniqueAnnotationsTest.class);
 
     // matcher

File: test/com/google/inject/BinderTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject;
 
+import static com.google.inject.Asserts.assertContains;
 import com.google.inject.name.Names;
 import junit.framework.TestCase;
 
@@ -65,8 +66,8 @@ public void testDanglingConstantBinding() {
         }
       });
       fail();
-    } catch (CreationException e) {
-      assertTrue(e.getMessage().contains("Missing constant value."));
+    } catch (CreationException expected) {
+      assertContains(expected.getMessage(), "Missing constant value.");
     }
   }
 

File: test/com/google/inject/BindingTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject;
 
+import static com.google.inject.Asserts.assertContains;
 import com.google.inject.name.Names;
 import com.google.inject.spi.*;
 import junit.framework.TestCase;
@@ -204,8 +205,7 @@ protected void configure() {
       });
       fail();
     } catch (CreationException expected) {
-      assertTrue(expected.getMessage().contains(
-          "Injecting into abstract types is not supported."));
+      assertContains(expected.getMessage(), "Injecting into abstract types is not supported.");
     }
   }
 

File: test/com/google/inject/commands/CommandRecorderTest.java
Patch:
@@ -17,10 +17,11 @@
 package com.google.inject.commands;
 
 import com.google.inject.*;
+import static com.google.inject.Asserts.assertContains;
 import com.google.inject.binder.AnnotatedBindingBuilder;
-import com.google.inject.binder.ScopedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
 import com.google.inject.binder.ConstantBindingBuilder;
+import com.google.inject.binder.ScopedBindingBuilder;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.matcher.Matchers;
 import com.google.inject.name.Names;
@@ -712,7 +713,7 @@ protected void checkModule(Module module, Command.Visitor<?>... visitors) {
     for (int i = 0; i < visitors.length; i++) {
       Command.Visitor<?> visitor = visitors[i];
       Command command = commands.get(i);
-      assertTrue(command.getSource().toString().contains("CommandRecorderTest"));
+      assertContains(command.getSource().toString(), "CommandRecorderTest");
       command.acceptVisitor(visitor);
     }
   }

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -18,6 +18,7 @@
 package com.google.inject.internal;
 
 import com.google.inject.AbstractModule;
+import static com.google.inject.Asserts.assertContains;
 import com.google.inject.CreationException;
 import com.google.inject.Guice;
 import com.google.inject.Inject;
@@ -47,8 +48,8 @@ public Object invoke(MethodInvocation methodInvocation) {
       });
       fail();
     } catch (CreationException expected) {
-      assertTrue(expected.getMessage().contains("LineNumbersTest$B"));
-      assertTrue(expected.getMessage().contains("Injecting into abstract types is not supported."));
+      assertContains(expected.getMessage(), "LineNumbersTest$B");
+      assertContains(expected.getMessage(), "Injecting into abstract types is not supported.");
     }
   }
 

File: src/com/google/inject/FactoryProxy.java
Patch:
@@ -31,7 +31,7 @@ class FactoryProxy<T> implements InternalFactory<T>,
   private final Key<? extends T> targetKey;
   private final Object source;
 
-  InternalFactory<? extends T> targetFactory;
+  private InternalFactory<? extends T> targetFactory;
 
   FactoryProxy(Key<T> key, Key<? extends T> targetKey, Object source) {
     this.key = key;

File: src/com/google/inject/InternalFactory.java
Patch:
@@ -27,7 +27,8 @@ interface InternalFactory<T> {
    * Creates an object to be injected.
    *
    * @param context of this injection
-   * @return instance to be injected; never null
+   * @throws ProvisionException if a value cannot be provided
+   * @return instance to be injected
    */
   T get(InternalContext context, InjectionPoint<?> injectionPoint);
 }

File: src/com/google/inject/internal/TypeWithArgument.java
Patch:
@@ -66,7 +66,7 @@ public Type getOwnerType() {
 
   private String toString(Type type) {
     if (type instanceof Class<?>) {
-      return ((Class) type).getSimpleName();
+      return ((Class) type).getName();
     } else if (type instanceof ParameterizedType) {
       ParameterizedType parameterizedType = (ParameterizedType) type;
       Type[] arguments = parameterizedType.getActualTypeArguments();

File: test/com/google/inject/AllTests.java
Patch:
@@ -77,6 +77,7 @@ public static Test suite() {
     suite.addTestSuite(LineNumbersTest.class);
     suite.addTestSuite(ReferenceCacheTest.class);
     suite.addTestSuite(ReferenceMapTest.class);
+    suite.addTestSuite(TypeWithArgumentTest.class);
     suite.addTestSuite(UniqueAnnotationsTest.class);
 
     // matcher

File: src/com/google/inject/internal/UniqueAnnotations.java
Patch:
@@ -57,7 +57,7 @@ public Class<? extends Annotation> annotationType() {
       }
 
       @Override public int hashCode() {
-        return 127 * ("value".hashCode() ^ value);
+        return (127 * "value".hashCode()) ^ value;
       }
     };
   }

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -48,7 +48,7 @@ public Object invoke(MethodInvocation methodInvocation) {
       fail();
     } catch (CreationException expected) {
       assertTrue(expected.getMessage().contains("LineNumbersTest$B"));
-      assertTrue(expected.getMessage().contains("No bindings to that type were found."));
+      assertTrue(expected.getMessage().contains("Injecting into abstract types is not supported."));
     }
   }
 

File: test/com/google/inject/internal/UniqueAnnotationsTest.java
Patch:
@@ -36,6 +36,5 @@ public void testEqualsHashCodeToString() {
     assertEquals(expected.toString(), actual.toString());
     assertEquals(expected.hashCode(), actual.hashCode());
     assertEquals(expected, actual);
-
   }
 }

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -80,10 +80,10 @@ public T newInstance(Object... arguments)
         return (T) fastConstructor.newInstance(arguments);
       }
       public List<Parameter<?>> getParameters() {
-        return Parameter.forConstructor(errorHandler, fastConstructor);
+        return Parameter.forConstructor(errorHandler, constructor);
       }
       public Member getMember() {
-        return fastConstructor.getJavaConstructor();
+        return constructor;
       }
     };
   }

File: extensions/multibindings/test/com/google/inject/multibindings/MultibinderTest.java
Patch:
@@ -239,7 +239,7 @@ protected void configure() {
   @interface De {}
 
   private <T> Set<T> setOf(T... elements) {
-    HashSet<T> result = new HashSet<T>();
+    Set<T> result = new HashSet<T>();
     result.addAll(Arrays.asList(elements));
     return result;
   }

File: src/com/google/inject/BindCommandProcessor.java
Patch:
@@ -50,6 +50,7 @@ class BindCommandProcessor extends CommandProcessor {
       Stage stage,
       Map<Key<?>, BindingImpl<?>> bindings,
       Map<Object, Void> outstandingInjections) {
+    super(injector.errorHandler);
     this.injector = injector;
     this.scopes = scopes;
     this.stage = stage;

File: src/com/google/inject/BindInterceptorCommandProcessor.java
Patch:
@@ -30,6 +30,7 @@ class BindInterceptorCommandProcessor extends CommandProcessor {
   private final ProxyFactoryBuilder proxyFactoryBuilder;
 
   BindInterceptorCommandProcessor(ErrorHandler errorHandler) {
+    super(errorHandler);
     proxyFactoryBuilder = new ProxyFactoryBuilder(errorHandler);
   }
 

File: src/com/google/inject/GetProviderProcessor.java
Patch:
@@ -29,6 +29,7 @@ class GetProviderProcessor extends CommandProcessor {
   private final InjectorImpl injector;
 
   GetProviderProcessor(InjectorImpl injector) {
+    super(injector.errorHandler);
     this.injector = injector;
   }
 

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.internal.ConstructionProxy;
 import com.google.inject.internal.ErrorMessages;
+import com.google.inject.internal.ResolveFailedException;
 
 import java.lang.reflect.InvocationTargetException;
 
@@ -60,8 +61,8 @@ InjectorImpl.SingleParameterInjector<?>[] createParameterInjector(
               constructionProxy.getMember(),
               constructionProxy.getParameters());
     }
-    catch (InjectorImpl.MissingDependencyException e) {
-      e.handle(injector.errorHandler);
+    catch (ResolveFailedException e) {
+      injector.errorHandler.handle(constructionProxy.getMember(), e.getMessage());
       return null;
     }
   }

File: test/com/google/inject/BindingOrderTest.java
Patch:
@@ -51,7 +51,8 @@ protected void configure() {
     // injector time. This is because we use the injector's just-in-time
     // bindings to build these, rather than the bind command. This is a known
     // bug.
-    assertSame(injector.getInstance(A.class).b, injector.getInstance(A.class).b);
+    assertSame("known bug: untargetted binding out-of-order",
+        injector.getInstance(A.class).b, injector.getInstance(A.class).b);
   }
 
   static class A {

File: test/com/google/inject/BindingTest.java
Patch:
@@ -211,7 +211,7 @@ protected void configure() {
       });
       // Despite the fact that the binding to List.class cannot be resolved,
       // we successfully return a (broken) injector. This is a known bug.
-      fail("Dangling linked binding");
+      fail("known bug: Dangling linked binding");
     } catch (CreationException expected) {
     }
   }

File: test/com/google/inject/ErrorMessagesTest.java
Patch:
@@ -62,8 +62,8 @@ public void testGetInstanceOfAnAbstractClass() {
       // The error returned is "Missing binding to AbstractClass", which is
       // true, but as helpful as it could be in this context. This is a
       // known bug
-      assertTrue(e.getMessage().contains(
-          "Injecting into abstract types is not supported."));
+      assertTrue("known bug: unhelpful message for abstract classes",
+          e.getMessage().contains("Injecting into abstract types is not supported."));
     }
   }
 

File: test/com/google/inject/internal/LineNumbersTest.java
Patch:
@@ -35,8 +35,7 @@ public void testCanHandleLineNumbersForGuiceGeneratedClasses() {
     try {
       Guice.createInjector(new AbstractModule() {
         protected void configure() {
-          bindInterceptor(Matchers.only(A.class),
-              Matchers.any(),
+          bindInterceptor(Matchers.only(A.class), Matchers.any(),
               new MethodInterceptor() {
                 public Object invoke(MethodInvocation methodInvocation) {
                   return null;
@@ -48,8 +47,8 @@ public Object invoke(MethodInvocation methodInvocation) {
       });
       fail();
     } catch (CreationException expected) {
-      assertTrue(expected.getMessage().contains("No bindings to that type were found."));
       assertTrue(expected.getMessage().contains("LineNumbersTest$B"));
+      assertTrue(expected.getMessage().contains("No bindings to that type were found."));
     }
   }
 

File: test/com/google/inject/BindingTest.java
Patch:
@@ -209,6 +209,8 @@ protected void configure() {
           bind(Collection.class).to(List.class);
         }
       });
+      // Despite the fact that the binding to List.class cannot be resolved,
+      // we successfully return a (broken) injector. This is a known bug.
       fail("Dangling linked binding");
     } catch (CreationException expected) {
     }

File: test/com/google/inject/ErrorMessagesTest.java
Patch:
@@ -59,6 +59,9 @@ public void testGetInstanceOfAnAbstractClass() {
       injector.getInstance(AbstractClass.class);
       fail();
     } catch(ConfigurationException e) {
+      // The error returned is "Missing binding to AbstractClass", which is
+      // true, but as helpful as it could be in this context. This is a
+      // known bug
       assertTrue(e.getMessage().contains(
           "Injecting into abstract types is not supported."));
     }

File: extensions/compiletime/src/com/google/inject/CompileTimeGuice.java
Patch:
@@ -18,7 +18,6 @@
 package com.google.inject;
 
 import static com.google.inject.internal.Objects.nonNull;
-import com.google.inject.internal.Reflection;
 
 import java.io.File;
 import java.io.IOException;

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -1229,7 +1229,7 @@ <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {
   /**
    * Injects a field or method in a given object.
    */
-  interface SingleMemberInjector {
+  public interface SingleMemberInjector {
     void inject(InternalContext context, Object o);
     Collection<Dependency<?>> getDependencies();
   }

File: src/com/google/inject/RuntimeReflectionFactory.java
Patch:
@@ -15,17 +15,17 @@
  */
 
 
-package com.google.inject.internal;
+package com.google.inject;
 
-import com.google.inject.Inject;
+import com.google.inject.internal.*;
 import static com.google.inject.internal.Objects.nonNull;
 
 import java.lang.reflect.Constructor;
 
 /**
  * @author jessewilson@google.com (Jesse Wilson)
  */
-public class RuntimeReflectionFactory implements Reflection.Factory {
+class RuntimeReflectionFactory implements Reflection.Factory {
   public Reflection create(ErrorHandler errorHandler,
       ConstructionProxyFactory constructionProxyFactory) {
     return new RuntimeReflection(errorHandler, constructionProxyFactory);

File: src/com/google/inject/ProviderInstanceBindingImpl.java
Patch:
@@ -16,10 +16,11 @@
 
 package com.google.inject;
 
-import com.google.inject.spi.ProviderInstanceBinding;
+import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.spi.BindingVisitor;
 import com.google.inject.spi.Dependency;
-import com.google.inject.internal.ToStringBuilder;
+import com.google.inject.spi.ProviderInstanceBinding;
+
 import java.util.Collection;
 
 /**

File: src/com/google/inject/ConstantBindingImpl.java
Patch:
@@ -25,13 +25,13 @@
 /**
  * A constant binding.
  */
-class ContantBindingImpl<T> extends BindingImpl<T>
+class ConstantBindingImpl<T> extends BindingImpl<T>
     implements ConstantBinding<T> {
 
   final T value;
   final Provider<T> provider;
 
-  ContantBindingImpl(InjectorImpl injector, Key<T> key, Object source,
+  ConstantBindingImpl(InjectorImpl injector, Key<T> key, Object source,
       InternalFactory<T> internalFactory, T value) {
     super(injector, key, source, internalFactory, Scopes.NO_SCOPE);
     this.value = value;

File: src/com/google/inject/InjectorBuilder.java
Patch:
@@ -20,16 +20,16 @@
 import com.google.inject.commands.Command;
 import com.google.inject.commands.CommandRecorder;
 import com.google.inject.commands.FutureInjector;
-import com.google.inject.internal.Stopwatch;
 import com.google.inject.internal.Objects;
+import com.google.inject.internal.Stopwatch;
 import com.google.inject.spi.Message;
 import com.google.inject.spi.SourceProviders;
 
 import java.lang.reflect.Member;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.List;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.logging.Logger;
 
 /**
@@ -139,6 +139,7 @@ private void buildCoreInjector() {
         injector, injector.scopes, stage, injector.explicitBindings,
         injector.outstandingInjections);
     bindCommandProcesor.processCommands(commands, configurationErrorHandler);
+    bindCommandProcesor.createUntargettedBindings();
     stopwatch.resetAndLog("Binding creation");
 
     injector.index();

File: test/com/google/inject/ProviderInjectionTest.java
Patch:
@@ -111,7 +111,8 @@ public List get() {
 
   /**
    * This test ensures that regardless of binding order, instances are injected
-   * before they are used.
+   * before they are used. It injects mutable Count objects and records their
+   * value at the time that they're injected.
    */
   public void testCreationTimeInjectionOrdering() {
     Injector injector = Guice.createInjector(new AbstractModule() {

File: src/com/google/inject/ConstantFactory.java
Patch:
@@ -30,6 +30,7 @@ public ConstantFactory(T value) {
   }
 
   public T get(InternalContext context, InjectionPoint injectionPoint) {
+    context.ensureMemberInjected(value);
     return value;
   }
 

File: src/com/google/inject/InternalFactoryToProviderAdapter.java
Patch:
@@ -36,8 +36,9 @@ public InternalFactoryToProviderAdapter(
     this.provider = Objects.nonNull(provider, "provider");
     this.source = Objects.nonNull(source, "source");
   }
-  
+
   public T get(InternalContext context, InjectionPoint<?> injectionPoint) {
+    context.ensureMemberInjected(provider);
     T provided = provider.get();
     return injectionPoint.checkForNull(provided, source);
   }

File: extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProviderTest.java
Patch:
@@ -491,7 +491,7 @@ protected void configure() {
                 Fiat.class));
       }
     });
-    
+
     ColoredCarFactory coloredCarFactory = injector.getInstance(ColoredCarFactory.class);
     Fiat fiat = (Fiat) coloredCarFactory.create(Color.GREEN);
     assertEquals(Color.GREEN, fiat.color);

File: extensions/visitable/src/com/google/inject/visitable/Command.java
Patch:
@@ -24,6 +24,5 @@
  * @author jessewilson@google.com (Jesse Wilson)
  */
 public interface Command {
-  void execute(Binder binder);
   <T> T acceptVisitor(BinderVisitor<T> visitor);
 }

File: extensions/visitable/src/com/google/inject/visitable/FutureInjector.java
Patch:
@@ -26,6 +26,7 @@
  * @author jessewilson@google.com (Jesse Wilson)
  */
 public final class FutureInjector implements EarlyRequestsProvider {
+  /** manually initialized later */
   private Injector injector;
 
   public void initialize(Injector injector) {

File: test/com/google/inject/AllTests.java
Patch:
@@ -39,6 +39,7 @@ public static Test suite() {
     suite.addTestSuite(BoundProviderTest.class);
     suite.addTestSuite(CircularDependencyTest.class);
     suite.addTestSuite(ConstantConversionTest.class);
+    suite.addTestSuite(ErrorMessagesTest.class);
     suite.addTestSuite(InjectorTest.class);
     suite.addTestSuite(GenericInjectionTest.class);
     suite.addTestSuite(ImplicitBindingTest.class);

File: test/com/google/inject/AllTests.java
Patch:
@@ -44,6 +44,7 @@ public static Test suite() {
     suite.addTestSuite(ImplicitBindingTest.class);
     suite.addTestSuite(KeyTest.class);
     suite.addTestSuite(ModuleTest.class);
+    suite.addTestSuite(NullableInjectionPointTest.class);
     suite.addTestSuite(ProviderInjectionTest.class);
     suite.addTestSuite(ProviderMethodsTest.class);
     suite.addTestSuite(NotRequiredTest.class);

File: test/com/google/inject/ProviderInjectionTest.java
Patch:
@@ -48,7 +48,8 @@ public void testProvidersAreInjectedWhenBound() {
       @Override
       protected void configure() {
         bind(Bar.class).toProvider(new Provider<Bar>() {
-          @SuppressWarnings("unused") @Inject void cantBeCalled(Baz baz) {
+          @SuppressWarnings("unused")
+          @Inject void cantBeCalled(Baz baz) {
             fail("Can't have called this method since Baz is not bound.");
           }
           public Bar get() {
@@ -60,7 +61,7 @@ public Bar get() {
 
     try {
       Guice.createInjector(m);
-      fail("Should have thrown a ConfigurationException");
+      fail("Should have thrown a CreationException");
     }
     catch (CreationException expected) {
     }

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.inject.internal.GuiceFastClass;
 import com.google.inject.internal.ReferenceCache;
 import com.google.inject.internal.StackTraceElements;
-import com.google.inject.internal.Strings;
 import com.google.inject.internal.ToStringBuilder;
 import com.google.inject.internal.Classes;
 import com.google.inject.spi.SourceProviders;
@@ -343,8 +342,7 @@ private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key) {
     try {
       // This cast is safe because we double check below.
       @SuppressWarnings("unchecked")
-      T converted = (T) matchingConverter.typeConverter.convert(
-          key.getTypeLiteral(), stringValue);
+      T converted = (T) matchingConverter.typeConverter.convert(stringValue, key.getTypeLiteral());
 
       if (converted == null) {
         throw new RuntimeException("Converter returned null.");

File: src/com/google/inject/spi/TypeConverter.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.inject.spi;
 
-import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 
 /**
@@ -29,5 +28,5 @@ public interface TypeConverter {
   /**
    * Converts a string value. Throws an exception if a conversion error occurs.
    */
-  Object convert(TypeLiteral<?> requiredType, String value);
+  Object convert(String value, TypeLiteral<?> toType);
 }

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -343,8 +343,8 @@ private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key) {
     try {
       // This cast is safe because we double check below.
       @SuppressWarnings("unchecked")
-      T converted
-          = (T) matchingConverter.typeConverter.convert(key, stringValue);
+      T converted = (T) matchingConverter.typeConverter.convert(
+          key.getTypeLiteral(), stringValue);
 
       if (converted == null) {
         throw new RuntimeException("Converter returned null.");

File: src/com/google/inject/spi/TypeConverter.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject.spi;
 
 import com.google.inject.Key;
+import com.google.inject.TypeLiteral;
 
 /**
  * Converts constant string values to a different type.
@@ -28,5 +29,5 @@ public interface TypeConverter {
   /**
    * Converts a string value. Throws an exception if a conversion error occurs.
    */
-  Object convert(Key<?> key, String value);
+  Object convert(TypeLiteral<?> requiredType, String value);
 }

File: src/com/google/inject/BindingBuilderImpl.java
Patch:
@@ -285,7 +285,8 @@ BindingImpl<T> build(InjectorImpl injector) {
       Class<T> clazz = (Class<T>) type;
 
       BindingImpl<T> binding = injector.createBindingForInjectableType(
-          clazz, scope, source, false);
+          clazz, scope, source);
+      // TODO: Should we clean up the binding left behind in jitBindings? 
 
       if (binding == null) {
         injector.errorHandler.handle(source,

File: src/com/google/inject/ErrorMessages.java
Patch:
@@ -138,7 +138,7 @@ static void handleMissingBinding(InjectorImpl injector, Object source,
       + " types is not supported. Please use a concrete type instead of %s.";
 
   static final String CANNOT_INJECT_INNER_CLASS = "Injecting into inner"
-      + " classes is not supported.  Please use a static class (top-level or"
+      + " classes is not supported.  Please use a 'static' class (top-level or"
       + " nested) instead.";
 
   static final String ANNOTATION_ALREADY_SPECIFIED = "More than one annotation"

File: src/com/google/inject/spi/ClassBinding.java
Patch:
@@ -32,4 +32,6 @@ public interface ClassBinding<T> extends Binding<T>, HasDependencies {
    * Gets the class associated with this binding.
    */
   Class<T> getBoundClass();
+
+  // TODO: Expose information about method and constructor interceptors.
 }

File: test/com/google/inject/BindingTest.java
Patch:
@@ -67,7 +67,6 @@ public Foo get() {
       bind(Foo.class)
           .annotatedWith(Names.named("provider"))
           .toProvider(FooProvider.class);
-      bind(FooProvider.class);
 
       // Class.
       bind(Bar.class).in(Scopes.SINGLETON);

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -68,7 +68,7 @@ InjectorImpl.SingleParameterInjector<?>[] createParameterInjector(
     }
   }
 
-  private Constructor<T> findConstructorIn(InjectorImpl injector,
+  private static <T> Constructor<T> findConstructorIn(InjectorImpl injector,
       Class<T> implementation) {
     Constructor<T> found = null;
     @SuppressWarnings("unchecked")

File: src/com/google/inject/ProviderMethods.java
Patch:
@@ -27,9 +27,9 @@
 import java.util.List;
 
 /**
- * Creates bindings to methods annotated with {@link
- * @com.google.inject.Provides}. Use the scope and binding annotations on the
- * provider method to configure the binding.
+ * Creates bindings to methods annotated with
+ * {@link com.google.inject.Provides}. Use the scope and binding annotations
+ * on the provider method to configure the binding.
  */
 public class ProviderMethods {
 

File: src/com/google/inject/Scopes.java
Patch:
@@ -132,7 +132,7 @@ static <T> InternalFactory<? extends T> scope(Key<T> key,
       InjectorImpl injector, InternalFactory<? extends T> creator,
       Scope scope) {
     // No scope does nothing.
-    if (scope == null) {
+    if (scope == null || scope == Scopes.NO_SCOPE) {
       return creator;
     }
     Provider<T> scoped = scope.scope(key,

File: test/com/google/inject/AllTests.java
Patch:
@@ -34,6 +34,7 @@ public static Test suite() {
     TestSuite suite = new TestSuite();
 
     suite.addTestSuite(BinderTest.class);
+    suite.addTestSuite(BindingTest.class);
     suite.addTestSuite(BoundProviderTest.class);
     suite.addTestSuite(CircularDependencyTest.class);
     suite.addTestSuite(ConstantConversionTest.class);

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -41,7 +41,6 @@ public <T> ConstructionProxy<T> get(final Constructor<T> constructor) {
       return new ConstructionProxy<T>() {
         public T newInstance(Object... arguments) throws
             InvocationTargetException {
-          Objects.assertNoNulls(arguments);
           try {
             return constructor.newInstance(arguments);
           }
@@ -63,7 +62,6 @@ public T newInstance(Object... arguments) throws
       @SuppressWarnings("unchecked")
       public T newInstance(Object... arguments)
           throws InvocationTargetException {
-        Objects.assertNoNulls(arguments);
         return (T) fastConstructor.newInstance(arguments);
       }
     };

File: src/com/google/inject/InjectorImpl.java
Patch:
@@ -549,7 +549,6 @@ public SingleMethodInjector(InjectorImpl injector, final Method method)
         this.methodInvoker = new MethodInvoker() {
           public Object invoke(Object target, Object... parameters) throws
               IllegalAccessException, InvocationTargetException {
-            Objects.assertNoNulls(parameters);
             return method.invoke(target, parameters);
           }
         };
@@ -561,7 +560,6 @@ public Object invoke(Object target, Object... parameters) throws
         this.methodInvoker = new MethodInvoker() {
           public Object invoke(Object target, Object... parameters)
           throws IllegalAccessException, InvocationTargetException {
-            Objects.assertNoNulls(parameters);
             return fastMethod.invoke(target, parameters);
           }
         };

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -172,7 +172,6 @@ <T> ConstructionProxy<T> createConstructionProxy(Class<?> clazz,
       @SuppressWarnings("unchecked")
       public T newInstance(Object... arguments)
           throws InvocationTargetException {
-        Objects.assertNoNulls(arguments);
         return (T) fastConstructor.newInstance(arguments);
       }
     };

File: test/com/google/inject/AllTests.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.inject.internal.ReferenceMapTest;
 import com.google.inject.internal.ReferenceMapTestSuite;
 import com.google.inject.matcher.MatcherTest;
+import com.google.inject.util.ProvidersTest;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
@@ -63,6 +64,8 @@ public static Test suite() {
 
     suite.addTestSuite(IntegrationTest.class);
 
+    suite.addTestSuite(ProvidersTest.class);
+
     return suite;
   }
 }

File: test/com/google/inject/AllTests.java
Patch:
@@ -32,6 +32,7 @@ public class AllTests {
   public static Test suite() {
     TestSuite suite = new TestSuite();
 
+    suite.addTestSuite(BinderTest.class);
     suite.addTestSuite(BoundProviderTest.class);
     suite.addTestSuite(CircularDependencyTest.class);
     suite.addTestSuite(ConstantConversionTest.class);

File: servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -52,7 +52,7 @@ public T get() {
         }
 
         public String toString() {
-          return creator.toString();
+          return String.format("%s[%s]", creator, REQUEST);
         }
       };
     }
@@ -82,7 +82,7 @@ public T get() {
           }
         }
         public String toString() {
-          return creator.toString();
+          return String.format("%s[%s]", creator, SESSION);
         }
       };
     }

File: src/com/google/inject/Scopes.java
Patch:
@@ -58,7 +58,7 @@ public T get() {
         }
 
         public String toString() {
-          return creator.toString();
+          return String.format("%s[%s]", creator, SINGLETON);
         }
       };
     }

File: servlet/src/com/google/inject/servlet/RequestScoped.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject.servlet;
 
+import com.google.inject.ScopeAnnotation;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
-import com.google.inject.ScopeAnnotation;
 
 /**
  * Apply this to implementation classes when you want one instance per request.

File: servlet/src/com/google/inject/servlet/ServletModule.java
Patch:
@@ -17,13 +17,11 @@
 package com.google.inject.servlet;
 
 import com.google.inject.AbstractModule;
-import com.google.inject.TypeLiteral;
 import com.google.inject.Provider;
+import com.google.inject.TypeLiteral;
 import static com.google.inject.servlet.ServletScopes.REQUEST;
 import static com.google.inject.servlet.ServletScopes.SESSION;
-
 import java.util.Map;
-
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletRequest;

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -16,10 +16,9 @@
 
 package com.google.inject;
 
-import com.google.inject.binder.ConstantBindingBuilder;
 import com.google.inject.binder.AnnotatedBindingBuilder;
-import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
+import com.google.inject.binder.LinkedBindingBuilder;
 import com.google.inject.matcher.Matcher;
 import com.google.inject.spi.SourceProviders;
 import com.google.inject.util.Objects;

File: src/com/google/inject/BindingAnnotation.java
Patch:
@@ -16,11 +16,10 @@
 
 package com.google.inject;
 
-import java.lang.annotation.ElementType;
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
-import static java.lang.annotation.ElementType.*;
 
 /**
  * Annotates annotations which are used for binding. Only one such annotation

File: src/com/google/inject/BindingBuilderImpl.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.inject;
 
 import com.google.inject.BinderImpl.CreationListener;
-import com.google.inject.binder.ScopedBindingBuilder;
 import com.google.inject.binder.AnnotatedBindingBuilder;
+import com.google.inject.binder.ScopedBindingBuilder;
 import com.google.inject.util.Annotations;
 import com.google.inject.util.Objects;
 import com.google.inject.util.StackTraceElements;

File: src/com/google/inject/ConstantBindingBuilderImpl.java
Patch:
@@ -17,12 +17,11 @@
 package com.google.inject;
 
 import com.google.inject.Key.AnnotationStrategy;
-import com.google.inject.binder.ConstantBindingBuilder;
 import com.google.inject.binder.AnnotatedConstantBindingBuilder;
-import com.google.inject.spi.SourceProviders;
+import com.google.inject.binder.ConstantBindingBuilder;
 import com.google.inject.util.Annotations;
-import com.google.inject.util.StackTraceElements;
 import com.google.inject.util.Objects;
+import com.google.inject.util.StackTraceElements;
 import java.lang.annotation.Annotation;
 
 /**

File: src/com/google/inject/ImplementedBy.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject;
 
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
 import static java.lang.annotation.ElementType.TYPE;
+import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import java.lang.annotation.Target;
 
 /**
  * A pointer to the default implementation of a type.

File: src/com/google/inject/Key.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.inject;
 
+import com.google.inject.util.Annotations;
 import static com.google.inject.util.Objects.nonNull;
 import com.google.inject.util.StackTraceElements;
 import com.google.inject.util.ToStringBuilder;
-import com.google.inject.util.Annotations;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Member;
 import java.lang.reflect.Type;

File: src/com/google/inject/TypeLiteral.java
Patch:
@@ -17,11 +17,9 @@
 package com.google.inject;
 
 import static com.google.inject.util.Objects.nonNull;
+import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Array;
-import java.util.Arrays;
 
 /**
  * Represents a generic type {@code T}. Java doesn't yet provide a way to

File: src/com/google/inject/jndi/JndiIntegration.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.jndi;
 
-import com.google.inject.Provider;
 import com.google.inject.Inject;
+import com.google.inject.Provider;
 import javax.naming.Context;
 import javax.naming.NamingException;
 

File: src/com/google/inject/matcher/Matchers.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.inject.matcher;
 
 import com.google.inject.util.Objects;
-
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Method;

File: src/com/google/inject/name/NamedImpl.java
Patch:
@@ -16,9 +16,8 @@
 
 package com.google.inject.name;
 
-import java.lang.annotation.Annotation;
 import com.google.inject.util.Objects;
-import com.google.inject.name.Named;
+import java.lang.annotation.Annotation;
 
 class NamedImpl implements Named {
 

File: src/com/google/inject/name/Names.java
Patch:
@@ -18,8 +18,8 @@
 
 import com.google.inject.Binder;
 import com.google.inject.Key;
-import com.google.inject.spi.SourceProviders;
 import com.google.inject.spi.SourceProvider;
+import com.google.inject.spi.SourceProviders;
 import java.util.Map;
 import java.util.Properties;
 

File: src/com/google/inject/util/GuiceFastClass.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.inject.util;
 
 import net.sf.cglib.reflect.FastClass;
-import com.google.inject.util.GuiceNamingPolicy;
 
 /**
  * Gives Guice classes custom names.

File: src/com/google/inject/util/ReferenceMap.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.inject.util;
 
 import static com.google.inject.util.ReferenceType.STRONG;
-
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;

File: src/com/google/inject/util/ToStringBuilder.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.inject.util;
 
-import java.util.Map;
 import java.util.LinkedHashMap;
+import java.util.Map;
 
 /**
  * Helps with {@code toString()} methods.

File: struts2/example/src/com/google/inject/struts2/example/Count.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.inject.struts2.example;
 
 import com.google.inject.Inject;
-
 import static com.opensymphony.xwork2.Action.SUCCESS;
 
 public class Count {

File: struts2/example/src/com/google/inject/struts2/example/Main.java
Patch:
@@ -18,8 +18,8 @@
 
 import org.mortbay.jetty.Connector;
 import org.mortbay.jetty.Server;
-import org.mortbay.jetty.webapp.WebAppContext;
 import org.mortbay.jetty.nio.SelectChannelConnector;
+import org.mortbay.jetty.webapp.WebAppContext;
 
 /**
  * Starts the example web server on port 8080. Run from "./struts2/example".

File: test/com/google/inject/TypeLiteralTest.java
Patch:
@@ -16,10 +16,8 @@
 
 package com.google.inject;
 
-import junit.framework.TestCase;
-
 import java.util.List;
-import java.lang.reflect.Type;
+import junit.framework.TestCase;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: test/com/google/inject/example/ClientServiceWithDependencyInjection.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.inject.example;
 
 import static junit.framework.Assert.assertTrue;
-import junit.framework.Assert;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: test/com/google/inject/example/ClientServiceWithGuiceDefaults.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.inject.example;
 
-import com.google.inject.Inject;
 import com.google.inject.CreationException;
-import com.google.inject.Injector;
 import com.google.inject.Guice;
 import com.google.inject.ImplementedBy;
+import com.google.inject.Inject;
+import com.google.inject.Injector;
 import com.google.inject.Singleton;
 import junit.framework.Assert;
 

File: test/com/google/inject/util/ReferenceCacheTest.java
Patch:
@@ -19,10 +19,8 @@
 import static com.google.inject.util.ReferenceType.SOFT;
 import static com.google.inject.util.ReferenceType.STRONG;
 import static com.google.inject.util.ReferenceType.WEAK;
-
-import junit.framework.TestCase;
-
 import java.util.concurrent.CountDownLatch;
+import junit.framework.TestCase;
 
 /**
  * @author crazybob@google.com (Bob Lee)

File: test/com/google/inject/util/ReferenceMapTest.java
Patch:
@@ -19,12 +19,10 @@
 import static com.google.inject.util.ReferenceType.SOFT;
 import static com.google.inject.util.ReferenceType.STRONG;
 import static com.google.inject.util.ReferenceType.WEAK;
-
-import junit.framework.TestCase;
-
 import java.lang.ref.Reference;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentMap;
+import junit.framework.TestCase;
 
 /**
  * Tests for {@link ReferenceMap}.

File: servlet/src/com/google/inject/servlet/ServletScopes.java
Patch:
@@ -16,10 +16,9 @@
 
 package com.google.inject.servlet;
 
-import com.google.inject.Scope;
-import com.google.inject.Provider;
 import com.google.inject.Key;
-
+import com.google.inject.Provider;
+import com.google.inject.Scope;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpSession;
 

File: src/com/google/inject/Provider.java
Patch:
@@ -50,6 +50,9 @@ public interface Provider<T> {
 
   /**
    * Provides an instance of {@code T}. Must never return {@code null}.
+   *
+   * @throws OutOfScopeException when an attempt is made to access a scoped
+   *     object while the scope in question is not currently active
    */
   T get();
 }

File: struts2/example/src/com/google/inject/struts2/example/ExampleModule.java
Patch:
@@ -26,5 +26,6 @@
 public class ExampleModule extends AbstractModule {
 
   protected void configure() {
+    bind(Service.class).to(ServiceImpl.class);
   }
 }

File: src/com/google/inject/Binder.java
Patch:
@@ -55,10 +55,10 @@
  *     bind(Service.class).to(ServiceImpl.class);</pre>
  *
  * Specifies that a request for a {@code Service} instance with no binding
- * annotations should be treated as if it were a request for a {@code MyImpl}
- * instance. This <i>overrides</i> the function of any
+ * annotations should be treated as if it were a request for a
+ * {@code ServiceImpl} instance. This <i>overrides</i> the function of any
  * {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
- * annotations found on {@code MyInterface}, since Guice will have already
+ * annotations found on {@code Service}, since Guice will have already
  * "moved on" to {@code ServiceImpl} before it reaches the point when it starts
  * looking for these annotations.
  *

File: src/com/google/inject/ImplementedBy.java
Patch:
@@ -28,7 +28,7 @@
  */
 @Retention(RUNTIME)
 @Target(TYPE)
-public @interface DefaultImplementation {
+public @interface ImplementedBy {
 
   /**
    * The implementation type.

File: src/com/google/inject/ProvidedBy.java
Patch:
@@ -28,7 +28,7 @@
  */
 @Retention(RUNTIME)
 @Target(TYPE)
-public @interface DefaultProvider {
+public @interface ProvidedBy {
 
   /**
    * The implementation type.

File: test/com/google/inject/example/ClientServiceWithGuiceDefaults.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.inject.CreationException;
 import com.google.inject.Injector;
 import com.google.inject.Guice;
-import com.google.inject.DefaultImplementation;
+import com.google.inject.ImplementedBy;
 import com.google.inject.Singleton;
 import com.google.inject.example.ClientServiceWithGuice.MyModule;
 import junit.framework.Assert;
@@ -32,7 +32,7 @@ public class ClientServiceWithGuiceDefaults {
 
 // 44 lines
 
-@DefaultImplementation(ServiceImpl.class)
+@ImplementedBy(ServiceImpl.class)
 public interface Service {
   void go();
 }

File: src/com/google/inject/BinderImpl.java
Patch:
@@ -104,8 +104,6 @@ public String toString() {
     }
   };
 
-  static final String UNKNOWN_SOURCE = "[unknown source]";
-
   final ProxyFactoryBuilder proxyFactoryBuilder;
 
   /**

File: src/com/google/inject/BindingBuilderImpl.java
Patch:
@@ -130,7 +130,7 @@ BindingBuilderImpl<T> to(InternalFactory<? extends T> factory) {
 
   public BindingScopeBuilder toProvider(Provider<? extends T> provider) {
     ensureImplementationIsNotSet();
-    this.factory = new InternalFactoryToProviderAdapter<T>(provider);
+    this.factory = new InternalFactoryToProviderAdapter<T>(provider, source);
     registerInstanceForInjection(provider);
     return this;
   }

File: src/com/google/inject/ConstantBindingBuilderImpl.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.inject.Key.AnnotationStrategy;
 import com.google.inject.binder.ConstantBindingBuilder;
+import com.google.inject.spi.SourceProviders;
 
 /**
    * Builds a constant binding.
@@ -10,7 +11,7 @@ class ConstantBindingBuilderImpl implements ConstantBindingBuilder {
 
   BindingInfo<?> bindingInfo;
   final AnnotationStrategy annotationStrategy;
-  Object source = BinderImpl.UNKNOWN_SOURCE;
+  Object source = SourceProviders.UNKNOWN_SOURCE;
   private BinderImpl binder;
 
   ConstantBindingBuilderImpl(BinderImpl binder, AnnotationStrategy annotationStrategy) {

File: src/com/google/inject/DefaultConstructionProxyFactory.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject;
 
 import com.google.inject.util.GuiceFastClass;
+import com.google.inject.util.Objects;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Modifier;
@@ -40,6 +41,7 @@ public <T> ConstructionProxy<T> get(final Constructor<T> constructor) {
       return new ConstructionProxy<T>() {
         public T newInstance(Object... arguments) throws
             InvocationTargetException {
+          Objects.assertNoNulls(arguments);
           try {
             return constructor.newInstance(arguments);
           }
@@ -61,6 +63,7 @@ public T newInstance(Object... arguments) throws
       @SuppressWarnings("unchecked")
       public T newInstance(Object... arguments)
           throws InvocationTargetException {
+        Objects.assertNoNulls(arguments);
         return (T) fastConstructor.newInstance(arguments);
       }
     };

File: src/com/google/inject/ErrorMessages.java
Patch:
@@ -149,6 +149,9 @@ static void handleMissingBinding(ErrorHandler errorHandler, Member member,
   static final String EXCEPTION_WHILE_CREATING = "Error while locating"
       + " instance%n  bound to %s%n  for member at %s";
   
+  static final String NULL_PROVIDED = "Null value returned by custom provider"
+      + " at %s";
+
   static Object convert(Object o) {
     for (Converter<?> converter : converters) {
       if (converter.appliesTo(o)) {

File: src/com/google/inject/InternalFactory.java
Patch:
@@ -27,7 +27,7 @@ interface InternalFactory<T> {
    * Creates an object to be injected.
    *
    * @param context of this injection
-   * @return instance to be injected
+   * @return instance to be injected; never null
    */
   T get(InternalContext context);
 }

File: src/com/google/inject/LinkedBindingBuilderImpl.java
Patch:
@@ -1,6 +1,7 @@
 package com.google.inject;
 
 import com.google.inject.binder.LinkedBindingBuilder;
+import com.google.inject.spi.SourceProviders;
 
 /**
  * Links one binding to another.
@@ -9,7 +10,7 @@ class LinkedBindingBuilderImpl<T> implements LinkedBindingBuilder<T> {
 
   final Key<T> key;
   Key<? extends T> destination;
-  Object source = BinderImpl.UNKNOWN_SOURCE;
+  Object source = SourceProviders.UNKNOWN_SOURCE;
   private BinderImpl binder;
 
   LinkedBindingBuilderImpl(BinderImpl binder, Key<T> key) {

File: src/com/google/inject/Provider.java
Patch:
@@ -49,7 +49,7 @@
 public interface Provider<T> {
 
   /**
-   * Provides an instance of {@code T}.
+   * Provides an instance of {@code T}.  Must never return null.
    */
   T get();
 }

File: src/com/google/inject/ProxyFactory.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.inject.util.GuiceFastClass;
 import com.google.inject.util.GuiceNamingPolicy;
+import com.google.inject.util.Objects;
 import com.google.inject.util.ReferenceCache;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -171,6 +172,7 @@ <T> ConstructionProxy<T> createConstructionProxy(Class<?> clazz,
       @SuppressWarnings("unchecked")
       public T newInstance(Object... arguments)
           throws InvocationTargetException {
+        Objects.assertNoNulls(arguments);
         return (T) fastConstructor.newInstance(arguments);
       }
     };

File: src/com/google/inject/spi/Message.java
Patch:
@@ -35,7 +35,7 @@ public Message(Object source, String message) {
   }
 
   public Message(String message) {
-    this("[unknown source]", message);
+    this(SourceProviders.UNKNOWN_SOURCE, message);
   }
 
   /**

File: src/com/google/inject/spi/SourceProviders.java
Patch:
@@ -30,6 +30,8 @@ public class SourceProviders {
 
   private SourceProviders() {}
 
+  public static final Object UNKNOWN_SOURCE = "[unknown source]";
+  
   static final SourceProvider DEFAULT_INSTANCE = new StacktraceSourceProvider();
 
   static Set<String> skippedClassNames = Collections.emptySet();

File: src/com/google/inject/util/StackTraceElements.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.inject.util;
 
+import com.google.inject.spi.SourceProviders;
 import static com.google.inject.util.ReferenceType.SOFT;
 import static com.google.inject.util.ReferenceType.WEAK;
 import java.io.IOException;
@@ -44,7 +45,7 @@ protected LineNumbers create(Class<?> key) {
 
   public static Object forMember(Member member) {
     if (member == null) {
-      return "[unknown source]";  
+      return SourceProviders.UNKNOWN_SOURCE;
     }
 
     Class declaringClass = member.getDeclaringClass();

File: src/com/google/inject/ErrorMessages.java
Patch:
@@ -80,8 +80,8 @@ static void handleMissingBinding(ErrorHandler errorHandler, Member member,
   static final String CONSTANT_CONVERSION_ERROR = "Error converting String"
       + " constant bound at %s to %s: %s";
 
-  static final String CANNOT_BIND_TO_PROVIDER = "Binding to Provider<?> is not"
-      + " allowed.";
+  static final String CANNOT_BIND_TO_GUICE_TYPE = "Binding to core guice" 
+      + " framework type is not allowed: %s.";
 
   static final String SCOPE_NOT_FOUND = "No scope is bound to %s.";
 

File: test/com/google/inject/ErrorHandlingTest.java
Patch:
@@ -101,6 +101,8 @@ protected void configure() {
       } catch (Exception e) {
         addError(e);
       }
+
+      bind(Module.class).toInstance(this);
     }
   }
 }

File: struts2/plugin/src/com/google/inject/struts2/GuiceObjectFactory.java
Patch:
@@ -117,7 +117,7 @@ protected void configure() {
       }
     }
 
-    return injector.getProvider(clazz).get();
+    return injector.getInstance(clazz);
   }
 
   public Interceptor buildInterceptor(InterceptorConfig interceptorConfig,

File: test/com/google/inject/BindingAnnotationTest.java
Patch:
@@ -34,7 +34,7 @@ protected void configure() {
       }
     });
 
-    Foo foo = c.getProvider(Foo.class).get();
+    Foo foo = c.getInstance(Foo.class);
 
     assertEquals("foo", foo.s);
   }

File: test/com/google/inject/BoundInstanceInjectionTest.java
Patch:
@@ -59,7 +59,7 @@ public O get() {
       }
     });
 
-    assertEquals(5, injector.getProvider(O.class).get().fromMethod);
+    assertEquals(5, injector.getInstance(O.class).fromMethod);
   }
 
 }

File: test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -30,7 +30,7 @@ public void testCircularlyDependentConstructors()
     builder.bind(B.class).to(BImpl.class);
 
     Injector injector = builder.createInjector();
-    A a = injector.getProvider(AImpl.class).get();
+    A a = injector.getInstance(AImpl.class);
     assertNotNull(a.getB().getA());
   }
 

File: test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -30,7 +30,7 @@ public void testGenericInjection() throws CreationException {
     BinderImpl builder = new BinderImpl();
     builder.bind(new TypeLiteral<List<String>>() {}).toInstance(names);
     Injector injector = builder.createInjector();
-    Foo foo = injector.getProvider(Foo.class).get();
+    Foo foo = injector.getInstance(Foo.class);
     assertEquals(names, foo.names);
   }
 

File: test/com/google/inject/ImplicitBindingTest.java
Patch:
@@ -25,7 +25,7 @@ public class ImplicitBindingTest extends TestCase {
 
   public void testCircularDependency() throws CreationException {
     Injector injector = Guice.createInjector();
-    Foo foo = injector.getProvider(Foo.class).get();
+    Foo foo = injector.getInstance(Foo.class);
     assertSame(foo, foo.bar.foo);
   }
 

File: test/com/google/inject/IntegrationTest.java
Patch:
@@ -34,12 +34,12 @@ public void testIntegration() throws CreationException {
     binder.bindInterceptor(any(), any(), counter);
     Injector injector = binder.createInjector();
 
-    Foo foo = injector.getProvider(Key.get(Foo.class)).get();
+    Foo foo = injector.getInstance(Key.get(Foo.class));
     foo.foo();
     assertTrue(foo.invoked);
     assertEquals(1, counter.count);
 
-    foo = injector.getProvider(Foo.class).get();
+    foo = injector.getInstance(Foo.class);
     foo.foo();
     assertTrue(foo.invoked);
     assertEquals(2, counter.count);

File: test/com/google/inject/NotRequiredTest.java
Patch:
@@ -27,14 +27,14 @@ public void testProvided() throws CreationException {
     BinderImpl builder = new BinderImpl();
     builder.bind(Bar.class).to(BarImpl.class);
     Injector c = builder.createInjector();
-    Foo foo = c.getProvider(Foo.class).get();
+    Foo foo = c.getInstance(Foo.class);
     assertNotNull(foo.bar);
     assertNotNull(foo.fromMethod);
   }
 
   public void testNotProvided() throws CreationException {
     Injector c = Guice.createInjector();
-    Foo foo = c.getProvider(Foo.class).get();
+    Foo foo = c.getInstance(Foo.class);
     assertNull(foo.bar);
     assertNull(foo.fromMethod);
   }

File: test/com/google/inject/ProviderInjectionTest.java
Patch:
@@ -31,7 +31,7 @@ public void testProviderInjection() throws CreationException {
 
     Injector injector = builder.createInjector();
 
-    Foo foo = injector.getProvider(Foo.class).get();
+    Foo foo = injector.getInstance(Foo.class);
 
     Bar bar = foo.barProvider.get();
     assertNotNull(bar);

File: test/com/google/inject/example/ClientServiceWithGuice.java
Patch:
@@ -67,6 +67,6 @@ public static void main(String[] args) throws CreationException {
   new ClientServiceWithGuice().testClient();
 
   Injector injector = Guice.createInjector(new ServiceModule());
-  Client client = injector.getProvider(Client.class).get();
+  Client client = injector.getInstance(Client.class);
 }
 }

File: src/com/google/inject/tools/jmx/Manager.java
Patch:
@@ -57,7 +57,7 @@ public static void manage(MBeanServer server, String domain,
       StringBuilder name = new StringBuilder();
       name.append(domain).append(":");
       Key<?> key = binding.getKey();
-      name.append("type=").append(quote(key.getType().toString()));
+      name.append("type=").append(quote(key.getTypeLiteral().toString()));
       Annotation annotation = key.getAnnotation();
       if (annotation != null) {
         name.append(",annotation=").append(quote(annotation.toString()));

File: src/com/google/inject/util/StackTraceElements.java
Patch:
@@ -62,7 +62,7 @@ public static Object forType(Class<?> implementation) {
     LineNumbers lineNumbers = lineNumbersCache.get(implementation);
     return new StackTraceElement(
         implementation.getName(),
-        "",
+        "class",
         lineNumbers.getSource(),
         lineNumbers.getFirstLine());
   }

File: test/com/google/inject/AllTests.java
Patch:
@@ -51,6 +51,7 @@ public static Test suite() {
     suite.addTestSuite(SuperclassTest.class);
     suite.addTestSuite(TypeLiteralTest.class);
     suite.addTestSuite(BoundInstanceInjectionTest.class);
+    suite.addTestSuite(BindingAnnotationTest.class);
 
     suite.addTestSuite(MatcherTest.class);
 

File: test/com/google/inject/KeyTest.java
Patch:
@@ -52,8 +52,8 @@ public void testTypeEquality() throws Exception {
     Type[] types = m.getGenericParameterTypes();
     assertEquals(types[0], types[1]);
     Key<List<String>> k = new Key<List<String>>() {};
-    assertEquals(types[0], k.getType().getType());
+    assertEquals(types[0], k.getTypeLiteral().getType());
     assertFalse(types[0].equals(
-        new Key<List<Integer>>() {}.getType().getType()));
+        new Key<List<Integer>>() {}.getTypeLiteral().getType()));
   }
 }

File: src/com/google/inject/package-info.java
Patch:
@@ -38,9 +38,10 @@
  * <dd>The object that Guice passes into your {@link com.google.inject.Module}
  *     to collect these bindings.
  *
- * <dt>{@link com.google.inject.Factory}
+ * <dt>{@link com.google.inject.Provider}
  * <dd>The interface you will implement when you need to customize exactly how
- *     Guice creates instances for a particular binding.
+ *     Guice creates instances for a particular binding. Also the interface
+ *     used to retrieve instances of a binding from the {@code Container}.
  *
  * </dl>
  *

File: src/com/google/inject/BindingAnnotation.java
Patch:
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Target;
+import static java.lang.annotation.ElementType.*;
 
 /**
  * Annotates annotations which are used for binding. Only one such annotation
@@ -35,6 +36,6 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-@Target({ ElementType.ANNOTATION_TYPE })
+@Target(ANNOTATION_TYPE)
 @Retention(RUNTIME)
 public @interface BindingAnnotation {}

File: src/com/google/inject/ContainerScoped.java
Patch:
@@ -29,4 +29,5 @@
  */
 @Target(ElementType.TYPE)
 @Retention(RUNTIME)
+@ScopeAnnotation
 public @interface ContainerScoped {}

File: src/com/google/inject/ErrorMessages.java
Patch:
@@ -52,6 +52,9 @@ static void handleMissingBinding(ErrorHandler errorHandler, Member member,
     }
   }
 
+  static final String MISSING_SCOPE_ANNOTATION = "Please annotate %s with"
+      + " @ScopeAnnotation.";
+
   static final String OPTIONAL_CONSTRUCTOR = "@Inject(optional=true) is"
       + " not allowed on constructors.";
 

File: src/com/google/inject/servlet/RequestScoped.java
Patch:
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import com.google.inject.ScopeAnnotation;
 
 /**
  * Apply this to implementation classes when you want one instance per request.
@@ -28,4 +29,5 @@
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
+@ScopeAnnotation
 public @interface RequestScoped {}

File: src/com/google/inject/servlet/SessionScoped.java
Patch:
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import com.google.inject.ScopeAnnotation;
 
 /**
  * Apply this to implementation classes when you want one instance per session.
@@ -29,4 +30,5 @@
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
+@ScopeAnnotation
 public @interface SessionScoped {}

File: test/com/google/inject/ScopesTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.inject;
 
 import junit.framework.TestCase;
+import com.google.inject.servlet.ServletScopes;
 
 /**
  * @author crazybob@google.com (Bob Lee)
@@ -40,8 +41,8 @@ public void testOverriddingAnnotation()
     BinderImpl builder = new BinderImpl();
     BindingBuilderImpl<Singleton> bindingBuilder
         = builder.bind(Singleton.class);
-    bindingBuilder.in(Scopes.DEFAULT);
+    bindingBuilder.in(ServletScopes.REQUEST);
     builder.createContainer();
-    assertSame(Scopes.DEFAULT, bindingBuilder.scope);
+    assertSame(ServletScopes.REQUEST, bindingBuilder.scope);
   }
 }

File: src/com/google/inject/ErrorMessages.java
Patch:
@@ -124,6 +124,9 @@ static void handleMissingBinding(ErrorHandler errorHandler, Member member,
   static final String PRELOAD_NOT_ALLOWED = "Preloading is only supported for"
       + " container-scoped bindings.";
 
+  static final String EXCEPTION_WHILE_CREATING = "Error while locating"
+      + " instance%n  bound to %s%n  for member at %s";
+  
   static Object convert(Object o) {
     for (Converter<?> converter : converters) {
       if (converter.appliesTo(o)) {

File: src/com/google/inject/BindingBuilderImpl.java
Patch:
@@ -86,7 +86,6 @@ public void toInstance(T instance) {
     if (this.scope != null) {
       binder.addError(source, ErrorMessages.SINGLE_INSTANCE_AND_SCOPE);
     }
-    this.scope = Scopes.CONTAINER;
   }
 
   /**

File: test/com/google/inject/ReflectionTest.java
Patch:
@@ -37,7 +37,7 @@ public void testNormalBinding() throws CreationException {
     assertSame(foo, fooBinding.getLocator().get());
     assertNotNull(fooBinding.getSource());
     assertEquals(Key.get(Foo.class), fooBinding.getKey());
-    assertFalse(fooBinding.isConstant());
+    assertTrue(fooBinding.isConstant());
   }
 
   public void testConstantBinding() throws CreationException {
@@ -61,7 +61,7 @@ public void testLinkedBinding() throws CreationException {
     assertSame(bar, fooBinding.getLocator().get());
     assertNotNull(fooBinding.getSource());
     assertEquals(Key.get(Foo.class), fooBinding.getKey());
-    assertFalse(fooBinding.isConstant());
+    assertTrue(fooBinding.isConstant());
   }
 
   static class Foo {}

File: src/com/google/inject/AbstractErrorHandler.java
Patch:
@@ -23,10 +23,10 @@
  */
 abstract class AbstractErrorHandler implements ErrorHandler {
 
-  public final void handle(String message, Object... arguments) {
+  public final void handle(Object source, String message, Object... arguments) {
     for (int i = 0; i < arguments.length; i++) {
       arguments[i] = ErrorMessages.convert(arguments[i]);
     }
-    handle(String.format(message, arguments));
+    handle(source, String.format(message, arguments));
   }
 }

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -75,11 +75,11 @@ protected ContainerBuilder builder() {
   }
 
   /**
-   * @see ContainerBuilder#scope(Class, Scope)
+   * @see ContainerBuilder#bindScope(Class, Scope)
    */
   protected void scope(Class<? extends Annotation> scopeAnnotation,
       Scope scope) {
-    builder.scope(scopeAnnotation, scope);
+    builder.bindScope(scopeAnnotation, scope);
   }
 
   /**

File: src/com/google/inject/Key.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.inject.util.Objects.nonNull;
 import com.google.inject.util.ToStringBuilder;
+import com.google.inject.util.StackTraceElements;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Member;
 import java.lang.reflect.Type;
@@ -276,8 +277,8 @@ static Key<?> get(Type type, Member member, Annotation[] annotations,
         if (found == null) {
           found = annotation;
         } else {
-          errorHandler.handle(ErrorMessages.DUPLICATE_ANNOTATIONS, member,
-              found, annotation);
+          errorHandler.handle(StackTraceElements.forMember(member),
+              ErrorMessages.DUPLICATE_ANNOTATIONS, found, annotation);
         }
       }
     }

File: src/com/google/inject/Scopes.java
Patch:
@@ -18,6 +18,7 @@
 
 import java.lang.annotation.Annotation;
 import java.util.Map;
+import com.google.inject.util.StackTraceElements;
 
 /**
  * Built in scope implementations.
@@ -96,8 +97,8 @@ static Scope getScopeForType(Class<?> implementation,
       Scope scope = scopes.get(annotation.annotationType());
       if (scope != null) {
         if (found != null) {
-          errorHandler.handle(ErrorMessages.DUPLICATE_SCOPE_ANNOTATIONS,
-              implementation, found, scope);
+          errorHandler.handle(StackTraceElements.forType(implementation),
+              ErrorMessages.DUPLICATE_SCOPE_ANNOTATIONS, found, scope);
         } else {
           found = scope;
         }

File: src/com/google/inject/Key.java
Patch:
@@ -289,23 +289,23 @@ static Key<?> get(Type type, Member member, Annotation[] annotations,
    * Returns a new key of the specified type with the same annotation as this
    * key.
    */
-  public <T> Key<T> ofType(Class<T> type) {
+  <T> Key<T> ofType(Class<T> type) {
     return new SimpleKey<T>(type, annotationStrategy);
   }
 
   /**
    * Returns a new key of the specified type with the same annotation as this
    * key.
    */
-  public Key<?> ofType(Type type) {
+  Key<?> ofType(Type type) {
     return new SimpleKey<Object>(type, annotationStrategy);
   }
 
   /**
    * Returns a new key of the specified type with the same annotation as this
    * key.
    */
-  public <T> Key<T> ofType(TypeLiteral<T> type) {
+  <T> Key<T> ofType(TypeLiteral<T> type) {
     return new SimpleKey<T>(type, annotationStrategy);
   }
 

File: test/com/google/inject/AllTests.java
Patch:
@@ -49,6 +49,7 @@ public static Test suite() {
     suite.addTestSuite(ReflectionTest.class);
     suite.addTestSuite(ScopesTest.class);
     suite.addTestSuite(ImplicitBindingTest.class);
+    suite.addTestSuite(CustomFactoryTest.class);
 
     suite.addTestSuite(MatcherTest.class);
     suite.addTestSuite(ProxyFactoryTest.class);

File: src/com/google/inject/name/Names.java
Patch:
@@ -40,7 +40,7 @@ public static Named named(String name) {
   }
 
   /**
-   * Binds a string constant for each property.
+   * Creates a constant binding to {@code @Named(key)} for each property.
    */
   public static void bindProperties(ContainerBuilder builder,
       Map<String, String> properties) {
@@ -53,7 +53,7 @@ public static void bindProperties(ContainerBuilder builder,
   }
 
   /**
-   * Binds a string constant for each property.
+   * Creates a constant binding to {@code @Named(key)} for each property.
    */
   public static void bindProperties(ContainerBuilder builder,
       Properties properties) {

File: src/com/google/inject/name/Named.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.inject.name;
 
 import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.annotation.ElementType;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import com.google.inject.Binder;
 
@@ -26,6 +28,7 @@
  * @author crazybob@google.com (Bob Lee)
  */
 @Retention(RUNTIME)
+@Target({ ElementType.FIELD, ElementType.PARAMETER })
 @Binder
 public @interface Named {
   String value();

File: src/com/google/inject/name/NamedImpl.java
Patch:
@@ -47,7 +47,7 @@ public boolean equals(Object o) {
   }
 
   public String toString() {
-    return "@Named(\"" + value + "\")";
+    return "@" + Named.class.getName() + "(value=" + value + ")";
   }
 
   public Class<? extends Annotation> annotationType() {

File: src/com/google/inject/util/ToStringBuilder.java
Patch:
@@ -47,6 +47,6 @@ public ToStringBuilder add(String name, Object value) {
   }
 
   public String toString() {
-    return name + map.toString();
+    return name + map.toString().replace('{', '[').replace('}', ']');
   }
 }

File: test/com/google/inject/ErrorHandlingTest.java
Patch:
@@ -45,15 +45,15 @@ static class Bar {
     // Invalid constructor.
     Bar(String s) {}
 
-    @Inject @Named("numbers") void setNumbers(List<Integer> numbers) {}
+    @Inject void setNumbers(@Named("numbers") List<Integer> numbers) {}
 
     @Inject void bar(@Named("foo") String s) {}
   }
 
   static class Tee {
     @Inject String s;
 
-    @Inject @Named("foo") void tee(String s, int i) {}
+    @Inject void tee(String s, int i) {}
 
     @Inject Invalid invalid;
   }

File: src/com/google/inject/ContainerScoped.java
Patch:
@@ -27,7 +27,9 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-@Target(ElementType.TYPE) @Retention(RUNTIME) @Scoped(Scopes.CONTAINER_NAME)
+@Target(ElementType.TYPE)
+@Retention(RUNTIME)
+@Scoped(Scopes.CONTAINER_NAME)
 public @interface ContainerScoped {
 
 }

File: test/com/google/inject/AllTests.java
Patch:
@@ -46,8 +46,9 @@ public static Test suite() {
     suite.addTestSuite(FactoryInjectionTest.class);
     suite.addTestSuite(PreloadingTest.class);
     suite.addTestSuite(ReflectionTest.class);
-    suite.addTestSuite(QueryTest.class);
+    suite.addTestSuite(ScopesTest.class);
 
+    suite.addTestSuite(QueryTest.class);
     suite.addTestSuite(ProxyFactoryTest.class);
     suite.addTestSuite(IntegrationTest.class);
 

File: src/com/google/inject/AbstractErrorHandler.java
Patch:
@@ -60,8 +60,7 @@ public String toString(Constructor c) {
       },
       new Converter<Field>(Field.class) {
         public String toString(Field f) {
-          return "field " + f.getDeclaringClass().getName() + "."
-              + f.getName();
+          return "field " + f.getDeclaringClass().getName() + "." + f.getName();
         }
       },
       new Converter<Class>(Class.class) {

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -17,12 +17,11 @@
 package com.google.inject;
 
 import com.google.inject.util.Objects;
-
 import java.util.Map;
 import java.util.Properties;
 
 /**
- * A support class for {@link Module}s which reduces repetition and
+ * A support class for {@link Module Modules} which reduces repetition and
  * results in a more readable configuration. Simply extends this class,
  * implement {@link #configure()}, and call the inherited methods which mirror
  * those found in {@link ContainerBuilder}. For example:
@@ -53,7 +52,8 @@ public final synchronized void configure(ContainerBuilder builder) {
 
       configure();
 
-    } finally {
+    }
+    finally {
       this.builder = null;
     }
   }

File: src/com/google/inject/Binding.java
Patch:
@@ -30,8 +30,8 @@ public class Binding<T> {
   final Object source;
   final InternalFactory<? extends T> internalFactory;
 
-  Binding(ContainerImpl container, Key<T> key,
-      Object source, InternalFactory<? extends T> internalFactory) {
+  Binding(ContainerImpl container, Key<T> key, Object source,
+      InternalFactory<? extends T> internalFactory) {
     this.container = container;
     this.key = key;
     this.source = source;

File: src/com/google/inject/Context.java
Patch:
@@ -38,8 +38,8 @@ public interface Context {
   Member getMember();
 
   /**
-   * Gets the index of the parameter which is being injected. Returns
-   * {@code -1} if a parameter isn't being injected.
+   * Gets the index of the parameter which is being injected. Returns {@code -1}
+   * if a parameter isn't being injected.
    */
   int getParameterIndex();
 

File: src/com/google/inject/FactoryToInternalFactoryAdapter.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * @author crazybob@google.com (Bob Lee)
-*/
+ */
 class FactoryToInternalFactoryAdapter<T> implements Factory<T> {
 
   private final ContainerImpl container;
@@ -32,8 +32,7 @@ public FactoryToInternalFactoryAdapter(ContainerImpl container,
   }
 
   public T get() {
-    return container.callInContext(
-        new ContextualCallable<T>() {
+    return container.callInContext(new ContextualCallable<T>() {
       public T call(InternalContext context) {
         return internalFactory.get(context);
       }

File: src/com/google/inject/InternalToContextualFactoryAdapter.java
Patch:
@@ -19,8 +19,7 @@
 /**
  * @author crazybob@google.com (Bob Lee)
 */
-class InternalToContextualFactoryAdapter<T> 
-    implements InternalFactory<T> {
+class InternalToContextualFactoryAdapter<T> implements InternalFactory<T> {
 
   private final ContextualFactory<? extends T> factory;
 

File: src/com/google/inject/Binding.java
Patch:
@@ -77,7 +77,7 @@ static <T> Binding<T> newInstance(ContainerImpl container, Key<T> key,
   /**
    * Is this a constant binding?
    */
-  public boolean isConstant() {
+  boolean isConstant() {
     return internalFactory instanceof ConstantFactory<?>;
   }
 

File: src/com/google/inject/package-info.java
Patch:
@@ -15,6 +15,6 @@
  */
 
 /**
- * <i>Guice</i> (sounds like like "juice")
+ * <i>Guice</i> (sounds like "juice")
  */
 package com.google.inject;
\ No newline at end of file

File: src/com/google/inject/ContainerBuilder.java
Patch:
@@ -315,6 +315,8 @@ public synchronized Container create(boolean preload)
     createBindings(preload, preloaders);
     createLinkedBindings();
 
+    container.index();
+
     stopwatch.resetAndLog(logger, "Binding creation");
 
     // Run validations.

File: src/com/google/inject/TypeLiteral.java
Patch:
@@ -31,8 +31,8 @@
  * you can create an empty anonymous inner class:
  *
  * <pre>
- * TypeLiteral<List<String>> listOfString =
- *   new TypeLiteral<List<String>>() {};
+ * TypeLiteral&lt;List&lt;String>> listOfString =
+ *   new TypeLiteral&lt;List&lt;String>>() {};
  * </pre>
  *
  * <p>Assumes {@code Type} implements {@code equals()} and {@code hashCode()}

File: src/com/google/inject/ConstructorInjector.java
Patch:
@@ -57,7 +57,7 @@ private Constructor<T> findConstructorIn(Class<T> implementation) {
       if (constructor.getAnnotation(Inject.class) != null) {
         if (found != null) {
           container.errorHandler.handle(
-              ErrorMessage.TOO_MANY_CONSTRUCTORS, implementation);
+              ErrorMessages.TOO_MANY_CONSTRUCTORS, implementation);
           return ContainerImpl.invalidConstructor();
         }
         found = constructor;
@@ -72,7 +72,7 @@ private Constructor<T> findConstructorIn(Class<T> implementation) {
     try {
       return implementation.getDeclaredConstructor();
     } catch (NoSuchMethodException e) {
-      container.errorHandler.handle(ErrorMessage.MISSING_CONSTRUCTOR, implementation);
+      container.errorHandler.handle(ErrorMessages.MISSING_CONSTRUCTOR, implementation);
       return ContainerImpl.invalidConstructor();
     }
   }

File: test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -25,7 +25,8 @@
  */
 public class CircularDependencyTest extends TestCase {
 
-  public void testCircularlyDependentConstructors() {
+  public void testCircularlyDependentConstructors()
+      throws ContainerCreationException {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind(A.class).to(AImpl.class);
     builder.bind(B.class).to(BImpl.class);

File: test/com/google/inject/ErrorHandlingTest.java
Patch:
@@ -42,7 +42,7 @@ protected void configure() {
     }
   }
 
-  public static void main(String[] args) {
+  public static void main(String[] args) throws ContainerCreationException {
     ContainerBuilder builder = new ContainerBuilder();
     builder.apply(new MyModule());
     builder.create(true);

File: test/com/google/inject/FactoryInjectionTest.java
Patch:
@@ -9,7 +9,7 @@
  */
 public class FactoryInjectionTest extends TestCase {
 
-  public void testFactoryInjection() {
+  public void testFactoryInjection() throws ContainerCreationException {
     ContainerBuilder builder = new ContainerBuilder();
 
     builder.bind(Bar.class);

File: test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class GenericInjectionTest extends TestCase {
 
-  public void testGenericInjection() {
+  public void testGenericInjection() throws ContainerCreationException {
     List<String> names = Arrays.asList("foo", "bar", "bob");
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind(new TypeLiteral<List<String>>() {}).to(names);

File: test/com/google/inject/StaticInjectionTest.java
Patch:
@@ -23,7 +23,7 @@
  */
 public class StaticInjectionTest extends TestCase {
 
-  public void testInjectStatics() {
+  public void testInjectStatics() throws ContainerCreationException {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind("s").to("test");
     builder.bind("i").to(5);

File: test/com/google/inject/SuperclassTest.java
Patch:
@@ -23,7 +23,7 @@
  */
 public class SuperclassTest extends TestCase {
 
-  public void testSuperclassInjection() {
+  public void testSuperclassInjection() throws ContainerCreationException {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind(Foo.class);
     Container container = builder.create(false);

File: src/com/google/inject/AbstractErrorHandler.java
Patch:
@@ -58,8 +58,8 @@ public String toString(Class c) {
       new Converter<Key>(Key.class) {
         public String toString(Key k) {
           return k.hasDefaultName()
-              ? k.getTypeToken().toString()
-              : k.getTypeToken() + " named '" + k.getName() + "'";
+              ? k.getType().toString()
+              : k.getType() + " named '" + k.getName() + "'";
         }
       }
   );

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -64,10 +64,10 @@ protected <T> ContainerBuilder.BindingBuilder<T> bind(Key<T> key) {
   }
 
   /**
-   * @see ContainerBuilder#bind(TypeToken)
+   * @see ContainerBuilder#bind(TypeLiteral)
    */
-  protected <T> ContainerBuilder.BindingBuilder<T> bind(TypeToken<T> typeToken) {
-    return builder.bind(typeToken);
+  protected <T> ContainerBuilder.BindingBuilder<T> bind(TypeLiteral<T> typeLiteral) {
+    return builder.bind(typeLiteral);
   }
 
   /**

File: test/com/google/inject/AllTests.java
Patch:
@@ -32,7 +32,7 @@ public class AllTests {
   public static Test suite() {
     TestSuite suite = new TestSuite();
 
-    suite.addTestSuite(TypeTokenTest.class);
+    suite.addTestSuite(TypeLiteralTest.class);
     suite.addTestSuite(KeyTest.class);
     suite.addTestSuite(ConstantConversionTest.class);
     suite.addTestSuite(ContainerTest.class);

File: test/com/google/inject/FactoryTest.java
Patch:
@@ -71,7 +71,7 @@ <T> ContextualFactory<T> createFactory(
       public T get(Context context) {
         assertEquals(expectedMember, context.getMember());
         assertEquals(name, context.getKey().getName());
-        assertEquals(type, context.getKey().getTypeToken().getType());
+        assertEquals(type, context.getKey().getType().getType());
         return context.getContainer().getCreator(type).get();
       }
     };

File: test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -15,7 +15,7 @@ public class GenericInjectionTest extends TestCase {
   public void testGenericInjection() {
     List<String> names = Arrays.asList("foo", "bar", "bob");
     ContainerBuilder builder = new ContainerBuilder();
-    builder.bind(new TypeToken<List<String>>() {}).to(names);
+    builder.bind(new TypeLiteral<List<String>>() {}).to(names);
     Container container = builder.create(false);
     Foo foo = container.getCreator(Foo.class).get();
     assertEquals(names, foo.names);

File: test/com/google/inject/KeyTest.java
Patch:
@@ -32,7 +32,7 @@ public void foo(List<String> a, List<String> b) {}
   public void testEquality() {
     assertEquals(
       new Key<List<String>>("foo") {},
-      Key.get(new TypeToken<List<String>>() {}, "foo")
+      Key.get(new TypeLiteral<List<String>>() {}, "foo")
     );
   }
 
@@ -41,8 +41,8 @@ public void testTypeEquality() throws Exception {
     Type[] types = m.getGenericParameterTypes();
     assertEquals(types[0], types[1]);
     Key<List<String>> k = new Key<List<String>>() {};
-    assertEquals(types[0], k.getTypeToken().getType());
+    assertEquals(types[0], k.getType().getType());
     assertFalse(types[0].equals(
-        new Key<List<Integer>>() {}.getTypeToken().getType()));
+        new Key<List<Integer>>() {}.getType().getType()));
   }
 }

File: src/com/google/inject/ConstantFactory.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.google.inject;
 
+import com.google.inject.util.Objects;
+
 /**
  * @author crazybob@google.com (Bob Lee)
  */
@@ -24,7 +26,7 @@ class ConstantFactory<T> implements InternalFactory<T> {
   private final T value;
 
   public ConstantFactory(T value) {
-    this.value = value;
+    this.value = Objects.nonNull(value, "value");
   }
 
   public T get(InternalContext ignored) {

File: src/com/google/inject/Container.java
Patch:
@@ -21,9 +21,9 @@
  * &#64;{@link Inject}.
  *
  * <p>When injecting a method or constructor, you can additionally annotate
- * its parameters with {@link Inject} and specify a dependency name. When a
- * parameter has no annotation, the container uses the name from the method or
- * constructor's {@link Inject} annotation respectively.
+ * its parameters with &#64;{@link Inject} and specify a dependency name. When
+ * a parameter has no annotation, the container uses the name from the method
+ * or constructor's &#64;{@link Inject} annotation respectively.
  *
  * <p>For example:
  *

File: src/com/google/inject/Context.java
Patch:
@@ -32,8 +32,8 @@ public interface Context {
 
   /**
    * Gets the field, method or constructor which is being injected. Returns
-   * {@code null} if the object isn't being directly injected (i.e. it's
-   * a preloaded singleton, returned from {@link Factory#get()}, etc.
+   * {@code null} if the object isn't being injected into anywhere (i.e. it's
+   * preloaded, returned from {@link Factory#get()}, etc.).
    */
   Member getMember();
 

File: src/com/google/inject/Module.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.inject;
 
 /**
- * Implemented by classes which participate in building a container. Useful
+ * Implemented by classes which configure a container. Useful
  * for encapsulating and reusing configuration logic.
  */
 public interface Module {

File: src/com/google/inject/Scopes.java
Patch:
@@ -15,7 +15,7 @@ public class Scopes {
   public static final String DEFAULT = Key.DEFAULT_NAME;
 
   /**
-   * Singleton scope's name. One instance per {@link Container}.
+   * Container scope's name. One instance per {@link Container}.
    */
-  public static final String SINGLETON = "singleton";
+  public static final String CONTAINER = "container";
 }
\ No newline at end of file

File: src/com/google/inject/TypeToken.java
Patch:
@@ -22,8 +22,8 @@
 import java.lang.reflect.ParameterizedType;
 
 /**
- * Represents a generic type {@code T}. Due to erasure, Java doesn't provide
- * a way to represent generic types. This class enables that.
+ * Represents a generic type {@code T}. Java doesn't yet provide a way to
+ * represent generic types, so this class does.
  *
  * <p>Assumes {@code Type} implements {@code equals()} and {@code hashCode()}
  * as a value (as opposed to identity) comparison.

File: test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -39,7 +39,7 @@ interface A {
     B getB();
   }
 
-  @Scoped(SINGLETON)
+  @Scoped(CONTAINER)
   static class AImpl implements A {
     final B b;
     @Inject public AImpl(B b) {

File: test/com/google/inject/ContainerTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import static com.google.inject.Scopes.SINGLETON;
+import static com.google.inject.Scopes.CONTAINER;
 
 import junit.framework.TestCase;
 
@@ -95,7 +95,7 @@ interface Bar {
     int getI();
   }
 
-  @Scoped(SINGLETON)
+  @Scoped(CONTAINER)
   static class BarImpl implements Bar {
 
     @Inject("i") int i;
@@ -155,7 +155,7 @@ interface A {
     B getB();
   }
 
-  @Scoped(SINGLETON)
+  @Scoped(CONTAINER)
   static class AImpl implements A {
     final B b;
     @Inject public AImpl(B b) {

File: test/com/google/inject/FactoryTest.java
Patch:
@@ -32,11 +32,11 @@ public void testInjection() throws Exception {
     // Called from getInstance().
     cb.bind(Foo.class).to(createFactory(Foo.class, "default", null));
 
-    // Called during singleton loading.
+    // Called during preloading.
     cb.bind(Bar.class)
         .named("fooBar")
         .to(createFactory(Bar.class, "fooBar", null))
-        .in(Scopes.SINGLETON);
+        .in(Scopes.CONTAINER);
 
     cb.bind(Tee.class).named("tee1")
         .to(createFactory(Tee.class, "tee1",

File: test/com/google/inject/PerformanceComparison.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import static com.google.inject.Scopes.SINGLETON;
+import static com.google.inject.Scopes.CONTAINER;
 
 import static junit.framework.Assert.*;
 
@@ -206,7 +206,7 @@ interface Tee {
     String getS();
   }
 
-  @Scoped(SINGLETON)
+  @Scoped(CONTAINER)
   public static class TeeImpl implements Tee {
 
     final String s;

File: src/com/google/inject/AbstractModule.java
Patch:
@@ -3,6 +3,7 @@
 package com.google.inject;
 
 import com.google.inject.util.Objects;
+import com.google.inject.spi.ErrorMessage;
 
 import java.util.Map;
 import java.util.Properties;
@@ -102,7 +103,7 @@ protected void requestStaticInjection(Class<?>... types) {
   }
 
   /**
-   * @see ContainerBuilder#add(ErrorMessage)
+   * @see ContainerBuilder#add(com.google.inject.spi.ErrorMessage)
    */
   protected void add(ErrorMessage errorMessage) {
     builder.add(errorMessage);

File: src/com/google/inject/Container.java
Patch:
@@ -56,7 +56,7 @@
  *
  * <pre>
  *  Container c = ...;
- *  Key<Foo> fooKey = Key.get(Foo.class);
+ *  Key&lt;Foo> fooKey = Key.get(Foo.class);
  *  Factory&lt;Foo> fooFactory = c.getFactory(fooKey);
  *  Foo foo = fooFactory.get();
  * </pre>

File: src/com/google/inject/spi/ErrorMessage.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.inject;
+package com.google.inject.spi;
 
 import static com.google.inject.util.Objects.nonNull;
 

File: src/com/google/inject/Container.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * Injects dependencies into constructors, methods and fields annotated with
- * @{@link Inject}.
+ * &#64;{@link Inject}.
  *
  * <p>When injecting a method or constructor, you can additionally annotate
  * its parameters with {@link Inject} and specify a dependency name. When a

File: src/com/google/inject/Container.java
Patch:
@@ -71,9 +71,10 @@ public interface Container {
   void injectMembers(Object o);
 
   /**
-   * Creates and injects a new instance of type {@code implementation}.
+   * Gets a factory which injects the given class's constructor creating new
+   * instances.
    */
-  <T> T newInstance(Class<T> implementation);
+  <T> Factory<T> getCreator(Class<T> implementation);
 
   /**
    * Gets the factory bound to the given key.

File: src/com/google/inject/Key.java
Patch:
@@ -127,9 +127,8 @@ public int hashCode() {
     return this.hashCode;
   }
 
-  @Deprecated
-  Class<T> getRawType() {
-    return (Class<T>) typeToken.getRawType();
+  Class<? super T> getRawType() {
+    return typeToken.getRawType();
   }
 
   public boolean equals(Object o) {

File: test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -31,7 +31,7 @@ public void testCircularlyDependentConstructors() {
     builder.bind(B.class).to(BImpl.class);
 
     Container container = builder.create(false);
-    A a = container.newInstance(AImpl.class);
+    A a = container.getCreator(AImpl.class).get();
     assertNotNull(a.getB().getA());
   }
 

File: test/com/google/inject/ContainerTest.java
Patch:
@@ -27,7 +27,7 @@ public class ContainerTest extends TestCase {
 
   public void testInjection() {
     Container container = createFooContainer();
-    Foo foo = container.newInstance(Foo.class);
+    Foo foo = container.getCreator(Foo.class).get();
 
     assertEquals("test", foo.s);
     assertEquals("test", foo.bar.getTee().getS());
@@ -61,7 +61,7 @@ public void testIntAndIntegerAreInterchangeable() {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind("i").to(5);
     Container container = builder.create(false);
-    IntegerWrapper iw = container.newInstance(IntegerWrapper.class);
+    IntegerWrapper iw = container.getCreator(IntegerWrapper.class).get();
     assertEquals(5, (int) iw.i);
   }
 
@@ -142,7 +142,7 @@ public void testCircularlyDependentConstructors() {
     builder.bind(B.class).to(BImpl.class);
 
     Container container = builder.create(false);
-    A a = container.newInstance(AImpl.class);
+    A a = container.getCreator(AImpl.class).get();
     assertNotNull(a.getB().getA());
   }
 

File: test/com/google/inject/FactoryInjectionTest.java
Patch:
@@ -17,7 +17,7 @@ public void testFactoryInjection() {
 
     Container container = builder.create(false);
 
-    Foo foo = container.newInstance(Foo.class);
+    Foo foo = container.getCreator(Foo.class).get();
 
     Bar bar = foo.barFactory.get();
     assertNotNull(bar);

File: test/com/google/inject/FactoryTest.java
Patch:
@@ -72,7 +72,7 @@ public T get(Context context) {
         assertEquals(expectedMember, context.getMember());
         assertEquals(name, context.getKey().getName());
         assertEquals(type, context.getKey().getTypeToken().getType());
-        return context.getContainer().newInstance(type);
+        return context.getContainer().getCreator(type).get();
       }
     };
   }

File: test/com/google/inject/GenericInjectionTest.java
Patch:
@@ -17,7 +17,7 @@ public void testGenericInjection() {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind(new TypeToken<List<String>>() {}).to(names);
     Container container = builder.create(false);
-    Foo foo = container.newInstance(Foo.class);
+    Foo foo = container.getCreator(Foo.class).get();
     assertEquals(names, foo.names);
   }
 

File: test/com/google/inject/NotRequiredTest.java
Patch:
@@ -27,15 +27,15 @@ public void testProvided() {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind(Bar.class);
     Container c = builder.create(false);
-    Foo foo = c.newInstance(Foo.class);
+    Foo foo = c.getCreator(Foo.class).get();
     assertNotNull(foo.bar);
     assertNotNull(foo.fromMethod);
   }
 
   public void testNotProvided() {
     Container c = new ContainerBuilder()
         .create(false);
-    Foo foo = c.newInstance(Foo.class);
+    Foo foo = c.getCreator(Foo.class).get();
     assertNull(foo.bar);
     assertNull(foo.fromMethod);
   }

File: src/com/google/inject/ContainerBuilder.java
Patch:
@@ -258,7 +258,9 @@ public Container create(boolean loadSingletons) {
 
     for (ConstantBindingBuilder builder : constantBindingBuilders) {
       if (builder.hasValue()) {
-        factories.put(builder.getKey(), builder.getInternalFactory());
+        Key<?> key = builder.getKey();
+        InternalFactory<?> factory = builder.getInternalFactory();
+        factories.put(key, factory);
       } else {
         add(new ErrorMessage(builder.getSource(),
             "Constant value isn't set."));

File: src/com/google/inject/ConstantConversionException.java
Patch:
@@ -23,7 +23,7 @@
  *
  * @author crazybob@google.com (Bob Lee)
  */
-class ConstantConversionException extends DependencyException {
+class ConstantConversionException extends ConfigurationException {
 
   ConstantConversionException(Member member, Key<?> key, String value,
       String reason) {

File: src/com/google/inject/ConstructionContext.java
Patch:
@@ -66,7 +66,7 @@ Object createProxy(Class<? super T> expectedType) {
     // instance (as opposed to one per caller).
 
     if (!expectedType.isInterface()) {
-      throw new DependencyException(
+      throw new ConfigurationException(
           expectedType.getName() + " is not an interface.");
     }
 

File: src/com/google/inject/Key.java
Patch:
@@ -26,12 +26,12 @@
  *
  * <p>For example, <tt>new Key&lt;List&lt;String>>("cities") {}</tt> will match:
  *
- * <tt>
- *   @Inject("cities")
+ * <pre>
+ *   &#64;Inject("cities")
  *   public void setList(List&lt;String> cities) {
  *     ...
  *   }
- * </tt>
+ * </pre>
  *
  * @author crazybob@google.com (Bob Lee)
  */

File: src/com/google/inject/TypeToken.java
Patch:
@@ -22,7 +22,8 @@
 import java.lang.reflect.ParameterizedType;
 
 /**
- * Represents a generic type {@code T}.
+ * Represents a generic type {@code T}. Due to erasure, Java doesn't provide
+ * a way to represent generic types. This class enables that.
  *
  * <p>Assumes {@code Type} implements {@code equals()} and {@code hashCode()}
  * as a value (as opposed to identity) comparison.

File: test/com/google/inject/AllTests.java
Patch:
@@ -41,6 +41,7 @@ public static Test suite() {
     suite.addTestSuite(NotRequiredTest.class);
     suite.addTestSuite(FactoryTest.class);
     suite.addTestSuite(SuperclassTest.class);
+    suite.addTestSuite(FactoryInjectionTest.class);
 
     suite.addTestSuite(FinalizableReferenceQueueTest.class);
     suite.addTestSuite(ReferenceMapTest.class);

File: test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import static com.google.inject.Scope.SINGLETON;
+import static com.google.inject.Scopes.*;
 
 import junit.framework.TestCase;
 
@@ -31,7 +31,7 @@ public void testCircularlyDependentConstructors() {
     builder.bind(B.class).to(BImpl.class);
 
     Container container = builder.create(false);
-    A a = container.inject(AImpl.class);
+    A a = container.newInstance(AImpl.class);
     assertNotNull(a.getB().getA());
   }
 

File: test/com/google/inject/NotRequiredTest.java
Patch:
@@ -27,15 +27,15 @@ public void testProvided() {
     ContainerBuilder builder = new ContainerBuilder();
     builder.bind(Bar.class);
     Container c = builder.create(false);
-    Foo foo = c.inject(Foo.class);
+    Foo foo = c.newInstance(Foo.class);
     assertNotNull(foo.bar);
     assertNotNull(foo.fromMethod);
   }
 
   public void testNotProvided() {
     Container c = new ContainerBuilder()
         .create(false);
-    Foo foo = c.inject(Foo.class);
+    Foo foo = c.newInstance(Foo.class);
     assertNull(foo.bar);
     assertNull(foo.fromMethod);
   }

File: test/com/google/inject/SpringTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.inject;
 
-import static com.google.inject.Scope.*;
+import static com.google.inject.Scopes.SINGLETON;
 
 import junit.framework.TestCase;
 
@@ -86,7 +86,7 @@ public Foo call() throws Exception {
     }
 
     public Foo call() throws Exception {
-      return container.inject(Foo.class);
+      return container.newInstance(Foo.class);
     }
   };
 

File: src/com/google/inject/ConstantFactory.java
Patch:
@@ -27,7 +27,7 @@ public ConstantFactory(T value) {
     this.value = value;
   }
 
-  public T create(InternalContext ignored) {
+  public T get(InternalContext ignored) {
     return value;
   }
 

File: src/com/google/inject/InternalFactory.java
Patch:
@@ -29,5 +29,5 @@ interface InternalFactory<T> {
    * @param context of this injection
    * @return instance to be injected
    */
-  T create(InternalContext context);
+  T get(InternalContext context);
 }

File: test/com/google/inject/CircularDependencyTest.java
Patch:
@@ -27,9 +27,8 @@ public class CircularDependencyTest extends TestCase {
 
   public void testCircularlyDependentConstructors() {
     ContainerBuilder builder = new ContainerBuilder();
-    builder
-        .factory(A.class, AImpl.class)
-        .factory(B.class, BImpl.class);
+    builder.bind(A.class).to(AImpl.class);
+    builder.bind(B.class).to(BImpl.class);
 
     Container container = builder.create(false);
     A a = container.inject(AImpl.class);

File: test/com/google/inject/NotRequiredTest.java
Patch:
@@ -24,9 +24,9 @@
 public class NotRequiredTest extends TestCase {
 
   public void testProvided() {
-    Container c = new ContainerBuilder()
-        .factory(Bar.class)
-        .create(false);
+    ContainerBuilder builder = new ContainerBuilder();
+    builder.bind(Bar.class);
+    Container c = builder.create(false);
     Foo foo = c.inject(Foo.class);
     assertNotNull(foo.bar);
     assertNotNull(foo.fromMethod);

File: test/com/google/inject/SuperclassTest.java
Patch:
@@ -25,7 +25,7 @@ public class SuperclassTest extends TestCase {
 
   public void testSuperclassInjection() {
     ContainerBuilder builder = new ContainerBuilder();
-    builder.factory(Foo.class);
+    builder.bind(Foo.class);
     Container container = builder.create(false);
     Sub sub = container.inject(Sub.class);
     sub = container.inject(Sub.class);

File: src/com/google/inject/util/Function.java
Patch:
@@ -22,7 +22,7 @@
  * <code>Function&lt;String,Integer&gt;</code> and transform integers in String
  * format to Integer format.
  *
- * <p>The transformation on the source object does not necessarily result in
+ * <p>The transformation on the from object does not necessarily result in
  * an object of a different type.  For example, a
  * {@code FarenheitToCelciusFunction} may implement
  * <code>Function&lt;Float,Float&gt;</code>.
@@ -37,7 +37,7 @@ public interface Function<F,T> {
    * of type {@code T}.  Note that types {@code F} and {@code T} may or may not
    * be the same.
    *
-   * @param from The source object.
+   * @param from The from object.
    * @return The resulting object.
    */
   T apply(F from);

File: src/com/google/inject/Container.java
Patch:
@@ -81,7 +81,7 @@ public interface Container {
   <T> T getInstance(Class<T> type, String name);
 
   /**
-   * Convenience method.&nbsp;Equivalent to {@code getInstance(type,
+   * Convenience method.&nbsp;Equivalent to {@code get(type,
    * DEFAULT_NAME)}.
    */
   <T> T getInstance(Class<T> type);

File: test/com/google/inject/AllTests.java
Patch:
@@ -32,6 +32,7 @@ public class AllTests {
   public static Test suite() {
     TestSuite suite = new TestSuite();
 
+    suite.addTestSuite(TypeTokenTest.class);
     suite.addTestSuite(KeyTest.class);
     suite.addTestSuite(ConstantConversionTest.class);
     suite.addTestSuite(ContainerTest.class);

File: test/com/google/inject/FactoryTest.java
Patch:
@@ -29,7 +29,7 @@ public class FactoryTest extends TestCase {
   public void testInjection() throws Exception {
     ContainerBuilder cb = new ContainerBuilder();
 
-    // Called from getInstance().
+    // Called from get().
     cb.factory(Foo.class, createFactory(Foo.class, "default", null));
 
     // Called during singleton loading.

File: src/com/google/inject/BindingBuilder.java
Patch:
@@ -141,7 +141,7 @@ public I create(InternalContext context) {
         this.constructor =
             context.getContainerImpl().getConstructor(implementation);
       }
-      return (I) constructor.construct(context, key.getType());
+      return (I) constructor.construct(context, key.getRawType());
     }
 
     public String toString() {

File: src/com/google/inject/ConstantConversionException.java
Patch:
@@ -39,11 +39,11 @@ private static String createMessage(String value, Key<?> key, Member member,
       String reason) {
     return member == null
         ? "Error converting '" + value + "' to "
-            + key.getType().getSimpleName()
+            + key.getRawType().getSimpleName()
             + " while getting dependency named '" + key.getName()
             + "'. Reason: " + reason
         : "Error converting '" + value + "' to "
-            + key.getType().getSimpleName() + " while injecting "
+            + key.getRawType().getSimpleName() + " while injecting "
             + member.getName() + " with dependency named '" + key.getName()
             + "' in " + member.getDeclaringClass().getSimpleName()
             + ". Reason: " + reason;

File: src/com/google/inject/ContainerBuilder.java
Patch:
@@ -90,7 +90,7 @@ private <T> ContainerBuilder factory(final Key<T> key,
     ensureNotCreated();
     checkKey(key);
     final InternalFactory<? extends T> scopedFactory =
-        scope.scopeFactory(key.getType(), key.getName(), factory);
+        scope.scopeFactory(key.getRawType(), key.getName(), factory);
     factories.put(key, scopedFactory);
     if (scope == Scope.SINGLETON) {
       singletonFactories.add(new InternalFactory<T>() {

File: src/com/google/inject/ContainerImpl.java
Patch:
@@ -70,7 +70,7 @@ <T> InternalFactory<? extends T> getFactory(Member member, Key<T> key) {
       return null;
     }
 
-    Class<T> type = key.getType();
+    Class<T> type = key.getRawType();
 
     // We don't need do pass in an InternalContext because we know this is
     // a ConstantFactory which will not use it.

File: src/com/google/inject/ExternalContext.java
Patch:
@@ -38,7 +38,7 @@ public ExternalContext(Member member, Key<T> key, ContainerImpl container) {
   }
 
   public Class<T> getType() {
-    return key.getType();
+    return key.getRawType();
   }
 
   public Scope.Strategy getScopeStrategy() {

File: src/com/google/inject/ContainerImpl.java
Patch:
@@ -520,7 +520,7 @@ <T> T getInstance(Class<T> type, String name, InternalContext context) {
   }
 
   <T> T getInstance(Class<T> type, InternalContext context) {
-    return getInstance(type, DEFAULT_NAME, context);
+    return getInstance(type, Key.DEFAULT_NAME, context);
   }
 
   public boolean hasBindingFor(Key<?> key) {

File: test/com/google/inject/AllTests.java
Patch:
@@ -32,6 +32,7 @@ public class AllTests {
   public static Test suite() {
     TestSuite suite = new TestSuite();
 
+    suite.addTestSuite(KeyTest.class);
     suite.addTestSuite(ConstantConversionTest.class);
     suite.addTestSuite(ContainerTest.class);
     suite.addTestSuite(CircularDependencyTest.class);

File: test/com/google/inject/ContainerTest.java
Patch:
@@ -53,7 +53,7 @@ private Container createFooContainer() {
   public void testGetInstance() {
     Container container = createFooContainer();
 
-    Bar bar = container.getInstance(Bar.class, Container.DEFAULT_NAME);
+    Bar bar = container.getInstance(Bar.class, Key.DEFAULT_NAME);
     assertEquals("test", bar.getTee().getS());
     assertEquals(5, bar.getI());
   }

File: src/com/google/inject/Context.java
Patch:
@@ -51,7 +51,7 @@ public interface Context {
   Class<?> getType();
 
   /**
-   * Gets the name of the injection specified by {@link Inject#value()}.
+   * Gets the name of the injection specified by {@link @Inject#name()}.
    */
   String getName();
 }

File: src/com/google/inject/package-info.java
Patch:
@@ -27,4 +27,4 @@
  *   <li>externalize what needs to be and no more</li>
  * </ul>
  */
-package com.google.inject;
+package com.google.inject;
\ No newline at end of file

File: src/com/google/inject/util/FinalizableReferenceQueue.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.inject.util;
 
-import com.google.inject.util.FinalizableReference;
-
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.util.logging.Level;

File: test/com/google/inject/AllTests.java
Patch:
@@ -32,19 +32,18 @@ public class AllTests {
   public static Test suite() {
     TestSuite suite = new TestSuite();
 
+    suite.addTestSuite(ConstantConversionTest.class);
     suite.addTestSuite(ContainerTest.class);
     suite.addTestSuite(CircularDependencyTest.class);
     suite.addTestSuite(StaticInjectionTest.class);
     suite.addTestSuite(NotRequiredTest.class);
     suite.addTestSuite(FactoryTest.class);
     suite.addTestSuite(SuperclassTest.class);
 
-    // util.
     suite.addTestSuite(FinalizableReferenceQueueTest.class);
     suite.addTestSuite(ReferenceMapTest.class);
-    suite.addTestSuite(ReferenceCacheTest.class);
-
     suite.addTest(ReferenceMapTestSuite.suite());
+    suite.addTestSuite(ReferenceCacheTest.class);
 
     return suite;
   }

File: test/com/google/inject/ContainerTest.java
Patch:
@@ -166,7 +166,7 @@ public A getA() {
   }
 
   public void testInjectStatics() {
-    Container c = new ContainerBuilder()
+    new ContainerBuilder()
         .constant("s", "test")
         .constant("i", 5)
         .injectStatics(Static.class)
@@ -186,4 +186,4 @@ static class Static {
       Static.s = s;
     }
   }
-}
+}
\ No newline at end of file

File: test/com/google/inject/util/ReferenceMapTestSuite.java
Patch:
@@ -35,6 +35,7 @@
 /**
  * @author crazybob@google.com (Bob Lee)
  */
+@SuppressWarnings({"unchecked"})
 public class ReferenceMapTestSuite {
 
   public static Test suite() {

