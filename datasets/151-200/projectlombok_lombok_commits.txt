File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -364,7 +364,7 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 		if (addConstructorProperties && !isLocalType(typeNode) && LombokOptionsFactory.getDelombokOptions(typeNode.getContext()).getFormatPreferences().generateConstructorProperties()) {
 			addConstructorProperties(mods, typeNode, fieldsToParam);
 		}
-		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor));
+		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor, maker));
 		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("<init>"),
 			null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(),
 			maker.Block(0L, nullChecks.appendList(assigns).toList()), null), source);

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -190,7 +190,7 @@ public void generateMethods(JavacNode typeNode, JavacNode source, java.util.List
 		injectMethod(typeNode, equalsMethod);
 		
 		if (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {
-			JCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));
+			JCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam, typeNode.getTreeMaker()));
 			injectMethod(typeNode, canEqualMethod);
 		}
 		

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -250,7 +250,7 @@ public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker tr
 		
 		List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(field);
 		List<JCAnnotation> delegates = findDelegatesAndRemoveFromField(field);
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod).appendList(copyableAnnotations);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod, treeMaker).appendList(copyableAnnotations);
 		if (field.isFinal()) {
 			if (getCheckerFrameworkVersion(field).generatePure()) annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genTypeRef(field, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));
 		} else {

File: src/core/lombok/javac/handlers/HandleJacksonized.java
Patch:
@@ -136,7 +136,7 @@ public class HandleJacksonized extends JavacAnnotationHandler<Jacksonized> {
 		
 		// Copy annotations from the class to the builder class.
 		List<JCAnnotation> copyableAnnotations = findJacksonAnnotationsOnClass(tdNode);
-		List<JCAnnotation> copiedAnnotations = copyAnnotations(copyableAnnotations);
+		List<JCAnnotation> copiedAnnotations = copyAnnotations(copyableAnnotations, maker);
 		for (JCAnnotation anno : copiedAnnotations) {
 			recursiveSetGeneratedBy(anno, annotationNode);
 		}

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -241,7 +241,7 @@ public static JCMethodDecl createSetterWithRecv(long access, boolean deprecate,
 		List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(field);
 		
 		Name methodName = field.toName(setterName);
-		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
+		List<JCAnnotation> annsOnParam = copyAnnotations(onParam, treeMaker).appendList(copyableAnnotations);
 		
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		JCExpression pType = cloneType(treeMaker, fieldDecl.vartype, source);
@@ -274,7 +274,7 @@ public static JCMethodDecl createSetterWithRecv(long access, boolean deprecate,
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = mergeAnnotations(copyAnnotations(onMethod), findCopyableToSetterAnnotations(field));
+		List<JCAnnotation> annsOnMethod = mergeAnnotations(copyAnnotations(onMethod, treeMaker), findCopyableToSetterAnnotations(field));
 		if (isFieldDeprecated(field) || deprecate) {
 			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}

File: src/core/lombok/javac/handlers/HandleWith.java
Patch:
@@ -229,7 +229,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		
 		JCBlock methodBody = null;
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
-		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
+		List<JCAnnotation> annsOnParam = copyAnnotations(onParam, maker).appendList(copyableAnnotations);
 		
 		JCExpression pType = cloneType(maker, fieldDecl.vartype, source);
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, pType, null);
@@ -278,7 +278,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod, maker);
 		CheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(source);
 		if (checkerFramework.generateSideEffectFree()) annsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
 		

File: src/core/lombok/javac/handlers/HandleWithBy.java
Patch:
@@ -321,7 +321,7 @@ public JCMethodDecl createWithBy(long access, JavacNode field, JavacTreeMaker ma
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod, maker);
 		CheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(source);
 		if (checkerFramework.generateSideEffectFree()) annsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
 		

File: src/core/lombok/javac/handlers/JavacSingularsRecipes.java
Patch:
@@ -315,7 +315,7 @@ private void generateSingularMethod(CheckerFrameworkVersion cfv, boolean depreca
 			if (!setterPrefix.isEmpty()) name = builderType.toName(HandlerUtil.buildAccessorName(source, setterPrefix, name.toString()));
 			
 			statements.prepend(createConstructBuilderVarIfNeeded(maker, data, builderType, source));
-			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToBuilderSingularSetterAnnotations(data.annotation.up()));
+			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToBuilderSingularSetterAnnotations(data.annotation.up()), maker);
 			finishAndInjectMethod(cfv, maker, returnType, returnStatement, data, builderType, source, deprecate, statements, name, params, methodAnnotations, access, null);
 		}
 		
@@ -362,7 +362,7 @@ private void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate
 				statements.prepend(JavacHandlerUtil.generateNullCheck(maker, null, data.getPluralName(), builderType, "%s cannot be null"));
 			}
 
-			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToSetterAnnotations(data.annotation.up()));
+			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToSetterAnnotations(data.annotation.up()), maker);
 			
 			finishAndInjectMethod(cfv, maker, returnType, returnStatement, data, builderType, source, deprecate, statements, name, List.of(param), methodAnnotations, access, ignoreNullCollections);
 		}

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -364,7 +364,7 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 		if (addConstructorProperties && !isLocalType(typeNode) && LombokOptionsFactory.getDelombokOptions(typeNode.getContext()).getFormatPreferences().generateConstructorProperties()) {
 			addConstructorProperties(mods, typeNode, fieldsToParam);
 		}
-		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor));
+		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor, maker));
 		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("<init>"),
 			null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(),
 			maker.Block(0L, nullChecks.appendList(assigns).toList()), null), source);

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -190,7 +190,7 @@ public void generateMethods(JavacNode typeNode, JavacNode source, java.util.List
 		injectMethod(typeNode, equalsMethod);
 		
 		if (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {
-			JCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));
+			JCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam, typeNode.getTreeMaker()));
 			injectMethod(typeNode, canEqualMethod);
 		}
 		

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -250,7 +250,7 @@ public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker tr
 		
 		List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(field);
 		List<JCAnnotation> delegates = findDelegatesAndRemoveFromField(field);
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod).appendList(copyableAnnotations);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod, field.getTreeMaker()).appendList(copyableAnnotations);
 		if (field.isFinal()) {
 			if (getCheckerFrameworkVersion(field).generatePure()) annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genTypeRef(field, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));
 		} else {

File: src/core/lombok/javac/handlers/HandleJacksonized.java
Patch:
@@ -136,7 +136,7 @@ public class HandleJacksonized extends JavacAnnotationHandler<Jacksonized> {
 		
 		// Copy annotations from the class to the builder class.
 		List<JCAnnotation> copyableAnnotations = findJacksonAnnotationsOnClass(tdNode);
-		List<JCAnnotation> copiedAnnotations = copyAnnotations(copyableAnnotations);
+		List<JCAnnotation> copiedAnnotations = copyAnnotations(copyableAnnotations, maker);
 		for (JCAnnotation anno : copiedAnnotations) {
 			recursiveSetGeneratedBy(anno, annotationNode);
 		}

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -241,7 +241,7 @@ public static JCMethodDecl createSetterWithRecv(long access, boolean deprecate,
 		List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(field);
 		
 		Name methodName = field.toName(setterName);
-		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
+		List<JCAnnotation> annsOnParam = copyAnnotations(onParam, treeMaker).appendList(copyableAnnotations);
 		
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		JCExpression pType = cloneType(treeMaker, fieldDecl.vartype, source);
@@ -274,7 +274,7 @@ public static JCMethodDecl createSetterWithRecv(long access, boolean deprecate,
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = mergeAnnotations(copyAnnotations(onMethod), findCopyableToSetterAnnotations(field));
+		List<JCAnnotation> annsOnMethod = mergeAnnotations(copyAnnotations(onMethod, treeMaker), findCopyableToSetterAnnotations(field));
 		if (isFieldDeprecated(field) || deprecate) {
 			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}

File: src/core/lombok/javac/handlers/HandleWith.java
Patch:
@@ -229,7 +229,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		
 		JCBlock methodBody = null;
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
-		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
+		List<JCAnnotation> annsOnParam = copyAnnotations(onParam, maker).appendList(copyableAnnotations);
 		
 		JCExpression pType = cloneType(maker, fieldDecl.vartype, source);
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, pType, null);
@@ -278,7 +278,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod, maker);
 		CheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(source);
 		if (checkerFramework.generateSideEffectFree()) annsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
 		

File: src/core/lombok/javac/handlers/HandleWithBy.java
Patch:
@@ -321,7 +321,7 @@ public JCMethodDecl createWithBy(long access, JavacNode field, JavacTreeMaker ma
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod, maker);
 		CheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(source);
 		if (checkerFramework.generateSideEffectFree()) annsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
 		

File: src/core/lombok/javac/handlers/JavacSingularsRecipes.java
Patch:
@@ -315,7 +315,7 @@ private void generateSingularMethod(CheckerFrameworkVersion cfv, boolean depreca
 			if (!setterPrefix.isEmpty()) name = builderType.toName(HandlerUtil.buildAccessorName(source, setterPrefix, name.toString()));
 			
 			statements.prepend(createConstructBuilderVarIfNeeded(maker, data, builderType, source));
-			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToBuilderSingularSetterAnnotations(data.annotation.up()));
+			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToBuilderSingularSetterAnnotations(data.annotation.up()), maker);
 			finishAndInjectMethod(cfv, maker, returnType, returnStatement, data, builderType, source, deprecate, statements, name, params, methodAnnotations, access, null);
 		}
 		
@@ -362,7 +362,7 @@ private void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate
 				statements.prepend(JavacHandlerUtil.generateNullCheck(maker, null, data.getPluralName(), builderType, "%s cannot be null"));
 			}
 
-			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToSetterAnnotations(data.annotation.up()));
+			List<JCAnnotation> methodAnnotations = copyAnnotations(findCopyableToSetterAnnotations(data.annotation.up()), maker);
 			
 			finishAndInjectMethod(cfv, maker, returnType, returnStatement, data, builderType, source, deprecate, statements, name, List.of(param), methodAnnotations, access, ignoreNullCollections);
 		}

File: src/core/lombok/core/AnnotationValues.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2022 The Project Lombok Authors.
+ * Copyright (C) 2009-2024 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -182,6 +182,7 @@ public List<String> getAsStringList(String methodName) {
 					"I can't make sense of this annotation value. Try using a fully qualified literal.", idx);
 			}
 			out.add((String) result);
+			idx++;
 		}
 		
 		return Collections.unmodifiableList(out);

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -2838,6 +2838,7 @@ public static void setDocComment(CompilationUnitDeclaration cud, TypeDeclaration
 		if (doc == null) return;
 		
 		ICompilationUnit compilationUnit = cud.compilationResult.compilationUnit;
+		if (compilationUnit == null) return;
 		if (compilationUnit.getClass().equals(COMPILATION_UNIT)) {
 			try {
 				compilationUnit = (ICompilationUnit) Permit.invoke(COMPILATION_UNIT_ORIGINAL_FROM_CLONE, compilationUnit);

File: src/core/lombok/SneakyThrows.java
Patch:
@@ -27,10 +27,10 @@
 import java.lang.annotation.Target;
 
 /**
- * &#64;SneakyThrow will avoid javac's insistence that you either catch or throw onward any checked exceptions that
+ * &#64;SneakyThrows will avoid javac's insistence that you either catch or throw onward any checked exceptions that
  * statements in your method body declare they generate.
  * <p>
- * &#64;SneakyThrow does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed
+ * &#64;SneakyThrows does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed
  * checked exception types. The JVM does not check for the consistency of the checked exception system; javac does,
  * and this annotation lets you opt out of its mechanism.
  * <p>

File: test/transform/resource/after-ecj/StandardExceptions.java
Patch:
@@ -2,10 +2,10 @@
 import lombok.experimental.StandardException;
 @StandardException class EmptyException extends Exception {
   public @java.lang.SuppressWarnings("all") @lombok.Generated EmptyException() {
-    this(null, null);
+    this((java.lang.String) null, (java.lang.Throwable) null);
   }
   public @java.lang.SuppressWarnings("all") @lombok.Generated EmptyException(final java.lang.String message) {
-    this(message, null);
+    this(message, (java.lang.Throwable) null);
   }
   public @java.lang.SuppressWarnings("all") @lombok.Generated EmptyException(final java.lang.Throwable cause) {
     this(((cause != null) ? cause.getMessage() : null), cause);
@@ -21,7 +21,7 @@ public NoArgsException() {
     super();
   }
   protected @java.lang.SuppressWarnings("all") @lombok.Generated NoArgsException(final java.lang.String message) {
-    this(message, null);
+    this(message, (java.lang.Throwable) null);
   }
   protected @java.lang.SuppressWarnings("all") @lombok.Generated NoArgsException(final java.lang.Throwable cause) {
     this(((cause != null) ? cause.getMessage() : null), cause);

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -51,7 +51,7 @@
 import lombok.transform.TestSourceFiles;
 
 public abstract class AbstractRunTests {
-	public final FileTester createTester(final DirectoryRunner.TestParams params, final File file, String platform, int version, boolean copyToSource) throws IOException {
+	public final FileTester createTester(final DirectoryRunner.TestParams params, final File file, String platform, int version, final boolean copyToSource) throws IOException {
 		ConfigurationKeysLoader.LoaderLoader.loadAllConfigurationKeys();
 		AssertionError directiveFailure = null;
 		LombokTestSource sourceDirectives = null;

File: test/transform/resource/after-delombok/MixGetterVal.java
Patch:
@@ -9,6 +9,7 @@ public void test() {
 		m(a);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -3,7 +3,7 @@
 class LoggerFloggerRecord {
   public @Flogger record Inner(String x) {
 /* Implicit */    private final String x;
-	private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
+    private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
     <clinit>() {
     }
   }

File: test/transform/resource/after-delombok/TrickyTypeResolution.java
Patch:
@@ -14,6 +14,7 @@ class TrickyDoNothing2 {
 class TrickySuccess {
 	int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-ecj/DelegateGenerics.java
Patch:
@@ -3,13 +3,13 @@ public class DelegateGenerics<T> {
   public DelegateGenerics() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") T a(final T a) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated T a(final T a) {
     return this.target.a(a);
   }
-  public @java.lang.SuppressWarnings("all") java.lang.String i(final java.lang.String a) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated java.lang.String i(final java.lang.String a) {
     return this.target.i(a);
   }
-  public @java.lang.SuppressWarnings("all") java.lang.Integer t(final java.lang.Integer t) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated java.lang.Integer t(final java.lang.Integer t) {
     return this.target.t(t);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnGetter.java
Patch:
@@ -9,7 +9,7 @@ private interface Bar {
   DelegateOnGetter() {
     super();
   }
-  public @Delegate @java.lang.SuppressWarnings({"all", "unchecked"}) Bar getBar() {
+  public @Delegate @java.lang.SuppressWarnings({"all", "unchecked"}) @lombok.Generated Bar getBar() {
     java.lang.Object $value = this.bar.get();
     if (($value == null))
         {
@@ -35,10 +35,10 @@ public int getInt() {
         }
     return (Bar) (($value == this.bar) ? null : $value);
   }
-  public @java.lang.SuppressWarnings("all") int getInt() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getInt() {
     return this.getBar().getInt();
   }
-  public @java.lang.SuppressWarnings("all") void setList(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void setList(final java.util.ArrayList<java.lang.String> list) {
     this.getBar().setList(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnGetterNone.java
Patch:
@@ -10,10 +10,10 @@ private interface Bar {
   DelegateOnGetterNone() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") int getInt() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getInt() {
     return this.bar.getInt();
   }
-  public @java.lang.SuppressWarnings("all") void setList(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void setList(final java.util.ArrayList<java.lang.String> list) {
     this.bar.setList(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnMethods.java
Patch:
@@ -7,7 +7,7 @@ public static interface Bar {
     super();
   }
   public abstract @Delegate Bar getBar();
-  public @java.lang.SuppressWarnings("all") void bar(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void bar(final java.util.ArrayList<java.lang.String> list) {
     this.getBar().bar(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateTypesAndExcludes.java
Patch:
@@ -27,10 +27,10 @@ private static interface Bar {
   DelegatePlain() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") void bar(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void bar(final java.util.ArrayList<java.lang.String> list) {
     this.bar.bar(list);
   }
-  public @java.lang.SuppressWarnings("all") void foo() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void foo() {
     this.foo.foo();
   }
 }

File: test/transform/resource/after-ecj/DelegateWithDeprecated.java
Patch:
@@ -9,13 +9,13 @@ private interface Bar {
   DelegateWithDeprecated() {
     super();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void deprecatedAnnotation() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @lombok.Generated void deprecatedAnnotation() {
     this.bar.deprecatedAnnotation();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void deprecatedComment() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @lombok.Generated void deprecatedComment() {
     this.bar.deprecatedComment();
   }
-  public @java.lang.SuppressWarnings("all") void notDeprecated() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void notDeprecated() {
     this.bar.notDeprecated();
   }
 }

File: test/transform/resource/after-ecj/DelegateWithVarargs2.java
Patch:
@@ -11,7 +11,7 @@ public void varargs(Object[]... keys) {
   DelegateWithVarargs2() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") void varargs(final java.lang.Object[]... keys) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void varargs(final java.lang.Object[]... keys) {
     this.bar.varargs(keys);
   }
 }

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -3,7 +3,7 @@
 class LoggerFloggerRecord {
   public @Flogger record Inner(String x) {
 /* Implicit */    private final String x;
-    private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
+	private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
     <clinit>() {
     }
   }

File: test/transform/resource/after-ecj/MixGetterVal.java
Patch:
@@ -13,7 +13,7 @@ public void test() {
     final @val int a = getX();
     m(a);
   }
-  public @java.lang.SuppressWarnings("all") int getX() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getX() {
     return this.x;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/TrickyTypeResolution.java
Patch:
@@ -20,7 +20,7 @@ class TrickySuccess {
   TrickySuccess() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") int getX() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getX() {
     return this.x;
   }
 }

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -87,7 +87,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * If {@code true}, lombok generates {@code @lombok.Generated} on all fields, methods, and types that are generated.
 	 */
-	public static final ConfigurationKey<Boolean> ADD_LOMBOK_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addLombokGeneratedAnnotation", "Generate @lombok.Generated on all generated code (default: false).") {};
+	public static final ConfigurationKey<Boolean> ADD_LOMBOK_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addLombokGeneratedAnnotation", "Generate @lombok.Generated on all generated code (default: true).") {};
 	
 	/**
 	 * lombok configuration: {@code lombok.extern.findbugs.addSuppressFBWarnings} = {@code true} | {@code false}.

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -2098,7 +2098,7 @@ public static Annotation[] addGenerated(EclipseNode node, ASTNode source, Annota
 		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_JAKARTA_GENERATED_ANNOTATIONS))) {
 			result = addAnnotation(source, result, JAKARTA_ANNOTATION_GENERATED, new StringLiteral(LOMBOK, 0, 0, 0));
 		}
-		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
+		if (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
 			result = addAnnotation(source, result, LOMBOK_GENERATED);
 		}
 		return result;

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1542,7 +1542,7 @@ public static void addGenerated(JCModifiers mods, JavacNode node, JavacNode sour
 		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_JAKARTA_GENERATED_ANNOTATIONS))) {
 			addAnnotation(mods, node, source, "jakarta.annotation.Generated", node.getTreeMaker().Literal("lombok"));
 		}
-		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
+		if (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
 			addAnnotation(mods, node, source, "lombok.Generated", null);
 		}
 	}

File: test/transform/resource/before/GeneratedJavaxOnLombokOn.java
Patch:
@@ -1,5 +1,4 @@
 //CONF: lombok.addJavaxGeneratedAnnotation = true
-//CONF: lombok.addLombokGeneratedAnnotation = true
 class GeneratedJavaxOnLombokOn {
 	@lombok.Getter
 	int x;

File: test/transform/resource/before/GeneratedOffLombokOn.java
Patch:
@@ -1,5 +1,4 @@
 //CONF: lombok.addGeneratedAnnotation = false
-//CONF: lombok.addLombokGeneratedAnnotation = true
 class GeneratedOffLombokOn {
 	@lombok.Getter
 	int x;

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -218,7 +218,7 @@ public void createGetterForField(AccessLevel level,
 		
 		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
 		
-		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
+		injectMethod(fieldNode.up(), source, createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
 	}
 	
 	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod) {

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -51,7 +51,7 @@
 import lombok.transform.TestSourceFiles;
 
 public abstract class AbstractRunTests {
-	public final FileTester createTester(final DirectoryRunner.TestParams params, final File file, String platform, int version, boolean copyToSource) throws IOException {
+	public final FileTester createTester(final DirectoryRunner.TestParams params, final File file, String platform, int version, final boolean copyToSource) throws IOException {
 		ConfigurationKeysLoader.LoaderLoader.loadAllConfigurationKeys();
 		AssertionError directiveFailure = null;
 		LombokTestSource sourceDirectives = null;

File: test/transform/resource/after-delombok/MixGetterVal.java
Patch:
@@ -9,6 +9,7 @@ public void test() {
 		m(a);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -3,7 +3,7 @@
 class LoggerFloggerRecord {
   public @Flogger record Inner(String x) {
 /* Implicit */    private final String x;
-	private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
+    private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
     <clinit>() {
     }
   }

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -87,7 +87,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * If {@code true}, lombok generates {@code @lombok.Generated} on all fields, methods, and types that are generated.
 	 */
-	public static final ConfigurationKey<Boolean> ADD_LOMBOK_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addLombokGeneratedAnnotation", "Generate @lombok.Generated on all generated code (default: false).") {};
+	public static final ConfigurationKey<Boolean> ADD_LOMBOK_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addLombokGeneratedAnnotation", "Generate @lombok.Generated on all generated code (default: true).") {};
 	
 	/**
 	 * lombok configuration: {@code lombok.extern.findbugs.addSuppressFBWarnings} = {@code true} | {@code false}.

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -2098,7 +2098,7 @@ public static Annotation[] addGenerated(EclipseNode node, ASTNode source, Annota
 		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_JAKARTA_GENERATED_ANNOTATIONS))) {
 			result = addAnnotation(source, result, JAKARTA_ANNOTATION_GENERATED, new StringLiteral(LOMBOK, 0, 0, 0));
 		}
-		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
+		if (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
 			result = addAnnotation(source, result, LOMBOK_GENERATED);
 		}
 		return result;

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -215,7 +215,7 @@ public void createGetterForField(AccessLevel level,
 		
 		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
 		
-		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
+		injectMethod(fieldNode.up(), source, createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
 	}
 	
 	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod) {

File: test/transform/resource/after-delombok/AccessorsInAnonymousClass.java
Patch:
@@ -1,18 +1,17 @@
 public class AccessorsInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private String string;
-
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public String string() {
 				return this.string;
 			}
-
 			/**
 			 * @return {@code this}.
 			 */
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public Inner string(final String string) {
 				this.string = string;
 				return this;

File: test/transform/resource/after-delombok/AccessorsMakeFinal.java
Patch:
@@ -4,8 +4,9 @@ class AccessorsMakeFinal1 {
 	 * @return {@code this}.
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public final AccessorsMakeFinal1 test(final String test) {
 		this.test = test;
 		return this;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/AccessorsMakeFinalLombokConfig.java
Patch:
@@ -1,7 +1,8 @@
 class AccessorsMakeFinalLombokConfig {
 	private String test;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public final void setTest(final String test) {
 		this.test = test;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/AccessorsNoParamWarning.java
Patch:
@@ -1,14 +1,16 @@
 class AccessorsNoParams {
 	private String otherFieldWithOverride = "";
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public String otherFieldWithOverride() {
 		return this.otherFieldWithOverride;
 	}
 }
 class AccessorsNoParams2 {
 	private boolean foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setFoo(final boolean foo) {
 		this.foo = foo;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/ClassNamedAfterGetter.java
Patch:
@@ -1,6 +1,7 @@
 class GetFoo {
 	private int foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getFoo() {
 		return this.foo;
 	}

File: test/transform/resource/after-delombok/CommentsInterspersed.java
Patch:
@@ -12,6 +12,7 @@ public class CommentsInterspersed {
 		javascript;
 	}-*/
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public String getTest() {
 		return this.test;
 	}

File: test/transform/resource/after-delombok/ConstructorInner.java
Patch:
@@ -1,11 +1,13 @@
 class ConstructorInner {
 	static class Inner {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private Inner() {
 		}
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public static ConstructorInner.Inner of() {
 			return new ConstructorInner.Inner();
 		}
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/ConstructorsConfiguration.java
Patch:
@@ -1,6 +1,7 @@
 class ConstructorsConfiguration {
 	int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public ConstructorsConfiguration(final int x) {
 		this.x = x;
 	}

File: test/transform/resource/after-delombok/ConstructorsTypeAnnos.java
Patch:
@@ -12,6 +12,7 @@ class ConstructorsTypeAnnos {
 	@TB
 	List<String> foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public ConstructorsTypeAnnos(@TA final List<String> foo) {
 		this.foo = foo;
 	}

File: test/transform/resource/after-delombok/ConstructorsWithAccessors.java
Patch:
@@ -4,16 +4,15 @@ class ConstructorsWithAccessors {
 	int pUpper;
 	int _huh;
 	int __huh2;
-
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public ConstructorsWithAccessors(final int plower, final int upper, final int huh, final int _huh2) {
 		this.plower = plower;
 		this.pUpper = upper;
 		this._huh = huh;
 		this.__huh2 = _huh2;
 	}
 }
-
 class ConstructorsWithAccessorsNonNull {
 	@lombok.NonNull
 	Integer plower;
@@ -23,8 +22,8 @@ class ConstructorsWithAccessorsNonNull {
 	Integer _huh;
 	@lombok.NonNull
 	final Integer __huh2;
-
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public ConstructorsWithAccessorsNonNull(@lombok.NonNull final Integer plower, @lombok.NonNull final Integer upper, @lombok.NonNull final Integer huh, @lombok.NonNull final Integer _huh2) {
 		if (plower == null) {
 			throw new java.lang.NullPointerException("plower is marked non-null but is null");

File: test/transform/resource/after-delombok/DataOnEnum.java
Patch:
@@ -2,15 +2,18 @@ public enum DataOnEnum {
 	A("hello");
 	private final String someField;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public String getSomeField() {
 		return this.someField;
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "DataOnEnum." + this.name() + "(someField=" + this.getSomeField() + ")";
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private DataOnEnum(final String someField) {
 		this.someField = someField;
 	}

File: test/transform/resource/after-delombok/DelegateOnGetter.java
Patch:
@@ -5,6 +5,7 @@ private interface Bar {
 		int getInt();
 	}
 	@java.lang.SuppressWarnings({"all", "unchecked"})
+	@lombok.Generated
 	public Bar getBar() {
 		java.lang.Object $value = this.bar.get();
 		if ($value == null) {
@@ -26,10 +27,12 @@ public int getInt() {
 		return (Bar) ($value == this.bar ? null : $value);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setList(final java.util.ArrayList<java.lang.String> list) {
 		this.getBar().setList(list);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getInt() {
 		return this.getBar().getInt();
 	}

File: test/transform/resource/after-delombok/DelegateOnGetterNone.java
Patch:
@@ -5,10 +5,12 @@ private interface Bar {
 		int getInt();
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setList(final java.util.ArrayList<java.lang.String> list) {
 		this.bar.setList(list);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getInt() {
 		return this.bar.getInt();
 	}

File: test/transform/resource/after-delombok/DelegateWithDeprecated.java
Patch:
@@ -11,15 +11,18 @@ private interface Bar {
 	}
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void deprecatedAnnotation() {
 		this.bar.deprecatedAnnotation();
 	}
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void deprecatedComment() {
 		this.bar.deprecatedComment();
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void notDeprecated() {
 		this.bar.notDeprecated();
 	}

File: test/transform/resource/after-delombok/DelegateWithVarargs2.java
Patch:
@@ -5,8 +5,8 @@ public void varargs(Object[]... keys) {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void varargs(final java.lang.Object[]... keys) {
 		this.bar.varargs(keys);
 	}
 }
-

File: test/transform/resource/after-delombok/EncodingUsAscii.java
Patch:
@@ -3,6 +3,7 @@ class EncodingUsAscii {
 	String foo\u0e51\u0e51 = "\016\t\b ";
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "EncodingUsAscii(foo\u0e51\u0e51=" + this.foo\u0e51\u0e51 + ")";
 	}

File: test/transform/resource/after-delombok/EncodingUtf8.java
Patch:
@@ -2,6 +2,7 @@ class EncodingUtf8 {
 	String foo๑๑ = "\016\t\b ";
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "EncodingUtf8(foo๑๑=" + this.foo๑๑ + ")";
 	}

File: test/transform/resource/after-delombok/EqualsAndHashCodeNewStyle.java
Patch:
@@ -13,6 +13,7 @@ long i() {
 	int j;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof EqualsAndHashCodeNewStyle)) return false;
@@ -26,11 +27,13 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof EqualsAndHashCodeNewStyle;
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int hashCode() {
 		final int PRIME = 59;
 		int result = 1;

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithExistingMethods.java
Patch:
@@ -17,6 +17,7 @@ private boolean canEqual(Object other) {
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof EqualsAndHashCodeWithExistingMethods3)) return false;
@@ -28,6 +29,7 @@ public boolean equals(final java.lang.Object o) {
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int hashCode() {
 		final int PRIME = 59;
 		int result = super.hashCode();

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithGenericsOnInners.java
Patch:
@@ -4,6 +4,7 @@ class Inner<B> {
 		int x;
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public boolean equals(final java.lang.Object o) {
 			if (o == this) return true;
 			if (!(o instanceof EqualsAndHashCodeWithGenericsOnInners.Inner)) return false;
@@ -13,11 +14,13 @@ public boolean equals(final java.lang.Object o) {
 			return true;
 		}
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		protected boolean canEqual(final java.lang.Object other) {
 			return other instanceof EqualsAndHashCodeWithGenericsOnInners.Inner;
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public int hashCode() {
 			final int PRIME = 59;
 			int result = 1;
@@ -26,4 +29,3 @@ public int hashCode() {
 		}
 	}
 }
-

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithGenericsOnInnersInInterfaces.java
Patch:
@@ -3,6 +3,7 @@ class Inner<B> {
 		int x;
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public boolean equals(final java.lang.Object o) {
 			if (o == this) return true;
 			if (!(o instanceof EqualsAndHashCodeWithGenericsOnInnersInInterfaces.Inner)) return false;
@@ -12,11 +13,13 @@ public boolean equals(final java.lang.Object o) {
 			return true;
 		}
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		protected boolean canEqual(final java.lang.Object other) {
 			return other instanceof EqualsAndHashCodeWithGenericsOnInnersInInterfaces.Inner;
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public int hashCode() {
 			final int PRIME = 59;
 			int result = 1;

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithNonNullByDefault.java
Patch:
@@ -3,6 +3,7 @@
 class EqualsAndHashCodeWithNonNullByDefault {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public boolean equals(@javax.annotation.Nullable final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof EqualsAndHashCodeWithNonNullByDefault)) return false;
@@ -11,11 +12,13 @@ public boolean equals(@javax.annotation.Nullable final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	protected boolean canEqual(@javax.annotation.Nullable final java.lang.Object other) {
 		return other instanceof EqualsAndHashCodeWithNonNullByDefault;
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int hashCode() {
 		final int result = 1;
 		return result;

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithOnParam.java
Patch:
@@ -1,6 +1,5 @@
 @interface Nullable {
 }
-
 class EqualsAndHashCodeWithOnParam {
 	int x;
 	boolean[] y;
@@ -9,6 +8,7 @@ class EqualsAndHashCodeWithOnParam {
 	String b;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public boolean equals(@Nullable final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof EqualsAndHashCodeWithOnParam)) return false;
@@ -26,11 +26,13 @@ public boolean equals(@Nullable final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	protected boolean canEqual(@Nullable final java.lang.Object other) {
 		return other instanceof EqualsAndHashCodeWithOnParam;
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int hashCode() {
 		final int PRIME = 59;
 		int result = 1;

File: test/transform/resource/after-delombok/FieldDefaultsViaConfigAndRequiredArgsConstructor.java
Patch:
@@ -1,6 +1,7 @@
 class FieldDefaultsViaConfigAndRequiredArgsConstructor {
 	final int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public FieldDefaultsViaConfigAndRequiredArgsConstructor(final int x) {
 		this.x = x;
 	}

File: test/transform/resource/after-delombok/FieldNameConstantsBasic.java
Patch:
@@ -5,6 +5,7 @@ public class FieldNameConstantsBasic {
 	int andMe;
 	String butPrintMePlease;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	static final class Fields {
 		public static final java.lang.String iAmADvdPlayer = "iAmADvdPlayer";
 		public static final java.lang.String butPrintMePlease = "butPrintMePlease";

File: test/transform/resource/after-delombok/FieldNameConstantsConfigKeys.java
Patch:
@@ -1,7 +1,8 @@
 public class FieldNameConstantsConfigKeys {
 	String iAmADvdPlayer;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public static final class Foobar {
 		public static final java.lang.String iAmADvdPlayer = "iAmADvdPlayer";
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/FieldNameConstantsEnum.java
Patch:
@@ -4,6 +4,7 @@ public class FieldNameConstantsEnum {
 	static double alsoDontSkipMe;
 	int butSkipMe;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public enum TypeTest {
 		iAmADvdPlayer, $dontSkipMe, alsoDontSkipMe;
 	}

File: test/transform/resource/after-delombok/FieldNameConstantsOnRecord.java
Patch:
@@ -2,6 +2,7 @@
 public record FieldNameConstantsOnRecord(String iAmADvdPlayer, int $skipMe, int andMe, String butPrintMePlease) {
 	static double skipMeToo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	static final class Fields {
 		public static final java.lang.String iAmADvdPlayer = "iAmADvdPlayer";
 		public static final java.lang.String butPrintMePlease = "butPrintMePlease";

File: test/transform/resource/after-delombok/FieldNameConstantsUppercased.java
Patch:
@@ -5,6 +5,7 @@ public class FieldNameConstantsUppercased {
 	int andMe;
 	String butPrintMePlease;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	static final class Fields {
 		public static final java.lang.String I_AM_A_DVD_PLAYER = "iAmADvdPlayer";
 		public static final java.lang.String BUT_PRINT_ME_PLEASE = "butPrintMePlease";

File: test/transform/resource/after-delombok/GenerateSuppressFBWarnings.java
Patch:
@@ -3,6 +3,7 @@ class GenerateSuppressFBWarnings {
 	int y;
 	@java.lang.SuppressWarnings("all")
 	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = "generated code")
+	@lombok.Generated
 	public int getY() {
 		return this.y;
 	}

File: test/transform/resource/after-delombok/GeneratedJavaxJakarta.java
Patch:
@@ -1,9 +1,9 @@
 class GeneratedJavaxJakarta {
 	int x;
-
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
 	@jakarta.annotation.Generated("lombok")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/GeneratedJavaxOffLombokOff.java
Patch:
@@ -1,4 +1,4 @@
-class GeneratedJavaxOff {
+class GeneratedJavaxOffLombokOff {
 	int x;
 	@java.lang.SuppressWarnings("all")
 	public int getX() {

File: test/transform/resource/after-delombok/GeneratedOff.java
Patch:
@@ -1,6 +1,7 @@
 class GeneratedOff {
 	int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/GeneratedOffJavaxOn.java
Patch:
@@ -2,6 +2,7 @@ class GeneratedOffJavaxOn {
 	int x;
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/GeneratedOn.java
Patch:
@@ -1,8 +1,8 @@
 class GeneratedOn {
 	int x;
-
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/GetterDeprecated.java
Patch:
@@ -7,6 +7,7 @@ class GetterDeprecated {
 	int javadoc;
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getAnnotation() {
 		return this.annotation;
 	}
@@ -15,6 +16,7 @@ public int getAnnotation() {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getJavadoc() {
 		return this.javadoc;
 	}

File: test/transform/resource/after-delombok/GetterEnum.java
Patch:
@@ -3,15 +3,18 @@ enum GetterEnum {
 	private final int id;
 	private final String name;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private GetterEnum(final int id, final String name) {
 		this.id = id;
 		this.name = name;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getId() {
 		return this.id;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public String getName() {
 		return this.name;
 	}

File: test/transform/resource/after-delombok/GetterInAnonymousClass.java
Patch:
@@ -1,10 +1,9 @@
 public class GetterInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private String string;
-
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public String getString() {
 				return this.string;
 			}

File: test/transform/resource/after-delombok/GetterLazy.java
Patch:
@@ -3,6 +3,7 @@ static class ValueType {
 	}
 	private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> fieldName = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
 	@java.lang.SuppressWarnings({"all", "unchecked"})
+	@lombok.Generated
 	public ValueType getFieldName() {
 		java.lang.Object $value = this.fieldName.get();
 		if ($value == null) {

File: test/transform/resource/after-delombok/GetterLazyErrorPosition.java
Patch:
@@ -1,7 +1,7 @@
 class GetterLazyErrorPosition {
 	private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> field = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
-
 	@java.lang.SuppressWarnings({"all", "unchecked"})
+	@lombok.Generated
 	public String getField() {
 		java.lang.Object $value = this.field.get();
 		if ($value == null) {

File: test/transform/resource/after-delombok/GetterLazyGenerics.java
Patch:
@@ -5,6 +5,7 @@ public static <E> E getAny() {
 		return null;
 	}
 	@java.lang.SuppressWarnings({"all", "unchecked"})
+	@lombok.Generated
 	public E getField() {
 		java.lang.Object $value = this.field.get();
 		if ($value == null) {
@@ -20,6 +21,7 @@ public E getField() {
 		return (E) ($value == this.field ? null : $value);
 	}
 	@java.lang.SuppressWarnings({"all", "unchecked"})
+	@lombok.Generated
 	public long getField2() {
 		java.lang.Object $value = this.field2.get();
 		if ($value == null) {
@@ -34,4 +36,4 @@ public long getField2() {
 		}
 		return (java.lang.Long) $value;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/GetterLazyInAnonymousClass.java
Patch:
@@ -1,10 +1,9 @@
 public class GetterLazyInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> string = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
-
 			@java.lang.SuppressWarnings({"all", "unchecked"})
+			@lombok.Generated
 			public String getString() {
 				java.lang.Object $value = this.string.get();
 				if ($value == null) {

File: test/transform/resource/after-delombok/GetterLazyInvalid.java
Patch:
@@ -13,6 +13,7 @@ class GetterLazyInvalidNone {
 class GetterLazyInvalidClass {
 	private final String fieldName = "";
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public String getFieldName() {
 		return this.fieldName;
 	}

File: test/transform/resource/after-delombok/GetterLazyTransient.java
Patch:
@@ -3,6 +3,7 @@ class GetterLazyTransient {
 	private final transient int transientField = 2;
 	private final transient int nonLazyTransientField = 3;
 	@java.lang.SuppressWarnings({"all", "unchecked"})
+	@lombok.Generated
 	public int getNonTransientField() {
 		java.lang.Object $value = this.nonTransientField.get();
 		if ($value == null) {
@@ -18,6 +19,7 @@ public int getNonTransientField() {
 		return (java.lang.Integer) $value;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getNonLazyTransientField() {
 		return this.nonLazyTransientField;
 	}

File: test/transform/resource/after-delombok/GetterNone.java
Patch:
@@ -2,6 +2,7 @@ class GetterNone {
 	int i;
 	int foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getI() {
 		return this.i;
 	}

File: test/transform/resource/after-delombok/GetterOnMethod.java
Patch:
@@ -6,18 +6,21 @@ class GetterOnMethod {
 	}
 	@Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getI() {
 		return this.i;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getJ() {
 		return this.j;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getK() {
 		return this.k;
 	}

File: test/transform/resource/after-delombok/GetterOnMethodOnType.java
Patch:
@@ -3,11 +3,13 @@ class GetterOnMethodOnType {
 	private String name;
 	@Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getTest() {
 		return this.test;
 	}
 	@Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public String getName() {
 		return this.name;
 	}

File: test/transform/resource/after-delombok/GetterOnStatic.java
Patch:
@@ -2,10 +2,12 @@ class Getter {
 	static boolean foo;
 	static int bar;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public static boolean isFoo() {
 		return Getter.foo;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public static int getBar() {
 		return Getter.bar;
 	}

File: test/transform/resource/after-delombok/GetterPlain.java
Patch:
@@ -2,10 +2,12 @@ class GetterPlain {
 	int i;
 	int foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getI() {
 		return this.i;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getFoo() {
 		return this.foo;
 	}

File: test/transform/resource/after-delombok/GetterTypeAnnos.java
Patch:
@@ -13,6 +13,7 @@ class GetterTypeAnnos {
 	List<String> foo;
 	@TA
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public List<String> getFoo() {
 		return this.foo;
 	}

File: test/transform/resource/after-delombok/GetterWithDollar.java
Patch:
@@ -1,6 +1,7 @@
 class GetterWithDollar1 {
 	int $i;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int get$i() {
 		return this.$i;
 	}
@@ -9,10 +10,12 @@ class GetterWithDollar2 {
 	int $i;
 	int i;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int get$i() {
 		return this.$i;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getI() {
 		return this.i;
 	}

File: test/transform/resource/after-delombok/GetterWithJavaBeansSpecCapitalization.java
Patch:
@@ -2,11 +2,13 @@ class GetterWithJavaBeansSpecCapitalization {
 	int a;
 	int aField;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getA() {
 		return this.a;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getaField() {
 		return this.aField;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/LockedInInitializer.java
Patch:
@@ -1,6 +1,7 @@
 public class LockedInInitializer {
 	public static final Runnable LOCKED = new Runnable() {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private final java.util.concurrent.locks.Lock $lock = new java.util.concurrent.locks.ReentrantLock();
 		@Override
 		public void run() {
@@ -14,6 +15,7 @@ public void run() {
 	};
 	public static final Runnable LOCKED_READ = new Runnable() {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private final java.util.concurrent.locks.ReadWriteLock $lock = new java.util.concurrent.locks.ReentrantReadWriteLock();
 		@Override
 		public void run() {
@@ -27,6 +29,7 @@ public void run() {
 	};
 	public static final Runnable LOCKED_WRITE = new Runnable() {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private final java.util.concurrent.locks.ReadWriteLock $lock = new java.util.concurrent.locks.ReentrantReadWriteLock();
 		@Override
 		public void run() {

File: test/transform/resource/after-delombok/LockedStaticMix.java
Patch:
@@ -1,5 +1,6 @@
 class LockedGeneratedStaticMismatch {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final java.util.concurrent.locks.Lock $LOCK = new java.util.concurrent.locks.ReentrantLock();
 	static void test() {
 		LockedGeneratedStaticMismatch.$LOCK.lock();

File: test/transform/resource/after-delombok/LockedTypeMismatch.java
Patch:
@@ -1,5 +1,6 @@
 class LockedGeneratedTypeMismatch {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private final java.util.concurrent.locks.Lock $lock = new java.util.concurrent.locks.ReentrantLock();
 	void test() {
 		this.$lock.lock();

File: test/transform/resource/after-delombok/LoggerConfig.java
Patch:
@@ -1,4 +1,5 @@
 class LoggerWithConfig {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private final org.slf4j.Logger myLogger = org.slf4j.LoggerFactory.getLogger(LoggerWithConfig.class);
 }

File: test/transform/resource/after-delombok/LoggerCustom.java
Patch:
@@ -1,13 +1,12 @@
 class LoggerCustomLog {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final MyLogger log = MyLoggerFactory.create(LoggerCustomLog.class);
 }
-
 class MyLoggerFactory {
 	static MyLogger create(Class<?> clazz) {
 		return null;
 	}
 }
-
 class MyLogger {
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/LoggerCustomWithPackage.java
Patch:
@@ -1,14 +1,13 @@
 package before;
 class LoggerCustomLog {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final before.MyLogger log = before.MyLoggerFactory.create(LoggerCustomLog.class);
 }
-
 class MyLoggerFactory {
 	static MyLogger create(Class<?> clazz) {
 		return null;
 	}
 }
-
 class MyLogger {
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/LoggerCustomWithTopicAndName.java
Patch:
@@ -1,16 +1,16 @@
 class LoggerCustomLog {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final MyLoggerFactory log = MyLoggerFactory.create(LoggerCustomLog.class.getName(), "t", null, LoggerCustomLog.class, "t");
 }
-
 class LoggerCustomLogWithStaticField {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final MyLoggerFactory log = MyLoggerFactory.create(LoggerCustomLogWithStaticField.class.getName(), LoggerCustomLogWithStaticField.TOPIC, null, LoggerCustomLogWithStaticField.class, LoggerCustomLogWithStaticField.TOPIC);
 	static final String TOPIC = "StaticField";
 }
-
 class MyLoggerFactory {
 	static MyLoggerFactory create(String name, String t1, Object o, Class<?> clazz, String t2) {
 		return null;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/LoggerFloggerRecord.java
Patch:
@@ -2,6 +2,7 @@
 class LoggerFloggerRecord {
 	public record Inner(String x) {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/LoggerSlf4jOnRecord.java
Patch:
@@ -1,5 +1,6 @@
 // version 16: the SuppressWarnings is not emitted in java14/15 to work around a javac bug.
 public record LoggerSlf4jOnRecord(String a, String b) {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jOnRecord.class);
 }

File: test/transform/resource/after-delombok/LoggerSlf4jTypes.java
Patch:
@@ -5,16 +5,19 @@ interface LoggerSlf4jTypesInterface {
 enum LoggerSlf4jTypesEnum {
 	;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnum.class);
 }
 enum LoggerSlf4jTypesEnumWithElement {
 	FOO;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnumWithElement.class);
 }
 interface LoggerSlf4jTypesInterfaceOuter {
 	class Inner {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }

File: test/transform/resource/after-delombok/LoggerSlf4jWithPackage.java
Patch:
@@ -1,11 +1,13 @@
 package before;
 class LoggerSlf4jWithPackage {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jWithPackage.class);
 }
 class LoggerSlf4jWithPackageOuter {
 	static class Inner {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }

File: test/transform/resource/after-delombok/NoArgsConstructorForce.java
Patch:
@@ -1,11 +1,10 @@
-
 public class NoArgsConstructorForce {
 	private final int[] i;
 	private final Object[] o;
 	private final java.util.List<?>[] fullQualifiedList;
 	private final String alreadyInitialized = "yes";
-	
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public NoArgsConstructorForce() {
 		this.i = null;
 		this.o = null;

File: test/transform/resource/after-delombok/NonNullExistingConstructorOnRecord.java
Patch:
@@ -2,6 +2,7 @@
 import lombok.NonNull;
 public record NonNullExistingConstructorOnRecord(@NonNull String a, @NonNull String b) {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public NonNullExistingConstructorOnRecord {
 		if (a == null) {
 			throw new java.lang.NullPointerException("a is marked non-null but is null");

File: test/transform/resource/after-delombok/NonNullOnRecordSimple.java
Patch:
@@ -2,6 +2,7 @@
 import lombok.NonNull;
 public record NonNullOnRecordSimple(@NonNull String a, @NonNull String b) {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public NonNullOnRecordSimple {
 		if (a == null) {
 			throw new java.lang.NullPointerException("a is marked non-null but is null");

File: test/transform/resource/after-delombok/NonNullOnRecordTypeUse.java
Patch:
@@ -2,6 +2,7 @@
 import lombok.NonNull;
 public record NonNullOnRecordTypeUse(@NonNull int[] a, int @NonNull [] b, int[] @NonNull [] c) {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public NonNullOnRecordTypeUse {
 		if (a == null) {
 			throw new java.lang.NullPointerException("a is marked non-null but is null");

File: test/transform/resource/after-delombok/NonNullWithAlternateException.java
Patch:
@@ -9,6 +9,7 @@ public void testMethod(@lombok.NonNull String arg) {
 		System.out.println(arg);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setTest(@lombok.NonNull final String test) {
 		if (test == null) {
 			throw new java.lang.IllegalArgumentException("test is marked non-null but is null");

File: test/transform/resource/after-delombok/NonNullWithAssertion.java
Patch:
@@ -8,10 +8,11 @@ public void testMethod(@lombok.NonNull String arg) {
 	}
 	public void testMethodWithIf(@lombok.NonNull String arg) {
 		if (arg == null) throw new NullPointerException("Oops");
-	}	
+	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setTest(@lombok.NonNull final String test) {
 		assert test != null : "test is marked non-null but is null";
 		this.test = test;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/NonNullWithGuava.java
Patch:
@@ -29,8 +29,9 @@ public void testMethodWithFakeCheckAssign(@lombok.NonNull String arg) {
 		test = checkNotNull(test);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setTest(@lombok.NonNull final String test) {
 		com.google.common.base.Preconditions.checkNotNull(test, "test is marked non-null but is null");
 		this.test = test;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/NonNullWithJdk.java
Patch:
@@ -29,8 +29,9 @@ public void testMethodWithFakeCheckAssign(@lombok.NonNull String arg) {
 		test = requireNonNull(test);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setTest(@lombok.NonNull final String test) {
 		java.util.Objects.requireNonNull(test, "test is marked non-null but is null");
 		this.test = test;
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/SetterAlreadyExists.java
Patch:
@@ -23,6 +23,7 @@ class Setter5 {
 	void setFoo() {
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setFoo(final String foo) {
 		this.foo = foo;
 	}
@@ -32,6 +33,7 @@ class Setter6 {
 	void setFoo(String foo, int x) {
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setFoo(final String foo) {
 		this.foo = foo;
 	}

File: test/transform/resource/after-delombok/SetterDeprecated.java
Patch:
@@ -7,6 +7,7 @@ class SetterDeprecated {
 	int javadoc;
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setAnnotation(final int annotation) {
 		this.annotation = annotation;
 	}
@@ -15,6 +16,7 @@ public void setAnnotation(final int annotation) {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setJavadoc(final int javadoc) {
 		this.javadoc = javadoc;
 	}

File: test/transform/resource/after-delombok/SetterInAnonymousClass.java
Patch:
@@ -1,10 +1,9 @@
 public class SetterInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private String string;
-
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public void setString(final String string) {
 				this.string = string;
 			}

File: test/transform/resource/after-delombok/SetterOnMethodOnParam.java
Patch:
@@ -6,18 +6,21 @@ class SetterOnMethodOnParam {
 	}
 	@Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setI(final int i) {
 		this.i = i;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setJ(@Test final int j) {
 		this.j = j;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setK(@Test final int k) {
 		this.k = k;
 	}

File: test/transform/resource/after-delombok/SetterOnStatic.java
Patch:
@@ -2,10 +2,12 @@ class Setter {
 	static boolean foo;
 	static int bar;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public static void setFoo(final boolean foo) {
 		Setter.foo = foo;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public static void setBar(final int bar) {
 		Setter.bar = bar;
 	}

File: test/transform/resource/after-delombok/SetterPlain.java
Patch:
@@ -2,10 +2,12 @@ class SetterPlain {
 	int i;
 	int foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setI(final int i) {
 		this.i = i;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setFoo(final int foo) {
 		this.foo = foo;
 	}

File: test/transform/resource/after-delombok/SetterTypeAnnos.java
Patch:
@@ -12,6 +12,7 @@ class SetterTypeAnnos {
 	@TB
 	List<String> foo;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setFoo(@TA final List<String> foo) {
 		this.foo = foo;
 	}

File: test/transform/resource/after-delombok/SetterWithJavaBeansSpecCapitalization.java
Patch:
@@ -2,10 +2,12 @@ class SetterWithJavaBeansSpecCapitalization {
 	int a;
 	int aField;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setA(final int a) {
 		this.a = a;
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public void setaField(final int aField) {
 		this.aField = aField;
 	}

File: test/transform/resource/after-delombok/SimpleTypeResolution.java
Patch:
@@ -5,6 +5,7 @@ class SimpleTypeResolutionFail {
 class SimpleTypeResolutionSuccess {
 	private int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/SkipSuppressWarnings.java
Patch:
@@ -1,12 +1,12 @@
 class SkipSuppressWarnings {
 	private String field = "";
 	private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> field2 = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
-
+	@lombok.Generated
 	public String getField() {
 		return this.field;
 	}
-
 	@java.lang.SuppressWarnings({"unchecked"})
+	@lombok.Generated
 	public String getField2() {
 		java.lang.Object $value = this.field2.get();
 		if ($value == null) {
@@ -21,4 +21,4 @@ public String getField2() {
 		}
 		return (String) ($value == this.field2 ? null : $value);
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/StaticConstructor.java
Patch:
@@ -2,12 +2,14 @@
 public class StaticConstructor {
 	String name;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private StaticConstructor(final String name) {
 		this.name = name;
 	}
 	@org.checkerframework.checker.nullness.qual.NonNull
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public static StaticConstructor of(final String name) {
 		return new StaticConstructor(name);
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/SynchronizedInAnonymousClass.java
Patch:
@@ -1,10 +1,9 @@
 public class SynchronizedInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			private final java.lang.Object $lock = new java.lang.Object[0];
-
 			public void foo() {
 				synchronized (this.$lock) {
 					String foo = "bar";

File: test/transform/resource/after-delombok/SynchronizedInInitializer.java
Patch:
@@ -1,6 +1,7 @@
 public class SynchronizedInInitializer {
 	public static final Runnable SYNCHRONIZED = new Runnable() {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private final java.lang.Object $lock = new java.lang.Object[0];
 		@Override
 		public void run() {

File: test/transform/resource/after-delombok/SynchronizedPlain.java
Patch:
@@ -1,5 +1,6 @@
 class SynchronizedPlain1 {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private final java.lang.Object $lock = new java.lang.Object[0];
 	void test() {
 		synchronized (this.$lock) {
@@ -14,6 +15,7 @@ void test2() {
 }
 class SynchronizedPlain2 {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	private static final java.lang.Object $LOCK = new java.lang.Object[0];
 	static void test() {
 		synchronized (SynchronizedPlain2.$LOCK) {

File: test/transform/resource/after-delombok/ToStringArray.java
Patch:
@@ -1,12 +1,11 @@
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
-
 public class ToStringArray {
 	int[] primitiveArray;
 	Object[] objectArray;
-
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringArray(primitiveArray=" + java.util.Arrays.toString(this.primitiveArray) + ", objectArray=" + java.util.Arrays.deepToString(this.objectArray) + ")";
 	}

File: test/transform/resource/after-delombok/ToStringAutoExclude.java
Patch:
@@ -4,6 +4,7 @@ class ToStringAutoExclude {
 	transient String b;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringAutoExclude(x=" + this.x + ", b=" + this.b + ")";
 	}
@@ -14,7 +15,8 @@ class ToStringAutoExclude2 {
 	transient String b;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringAutoExclude2(x=" + this.x + ", $a=" + this.$a + ", b=" + this.b + ")";
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/ToStringAutoSuper.java
Patch:
@@ -1,14 +1,15 @@
 class ToStringAutoSuperWithNoParent {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringAutoSuperWithNoParent()";
 	}
 }
-
 class ToStringAutoSuperWithParent extends ToStringAutoSuperWithNoParent {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringAutoSuperWithParent(super=" + super.toString() + ")";
 	}

File: test/transform/resource/after-delombok/ToStringExplicitInclude.java
Patch:
@@ -2,7 +2,8 @@ class ToStringExplicitInclude {
 	int x;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringExplicitInclude()";
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/ToStringExplicitIncludeConf.java
Patch:
@@ -3,6 +3,7 @@ class ToStringExplicitIncludeConf {
 	int y;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringExplicitIncludeConf(y=" + this.y + ")";
 	}

File: test/transform/resource/after-delombok/ToStringInAnonymousClass.java
Patch:
@@ -1,11 +1,10 @@
 public class ToStringInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private String string;
-
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public java.lang.String toString() {
 				return "Inner(string=" + this.string + ")";
 			}

File: test/transform/resource/after-delombok/ToStringNewStyle.java
Patch:
@@ -12,6 +12,7 @@ int f() {
 	int j;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToStringNewStyle(a=" + this.b + ", c=" + this.c + ", e=" + this.d + ", f=" + this.f() + ", g=" + this.g + ", i=" + this.i + ", h=" + this.h + ")";
 	}

File: test/transform/resource/after-delombok/ToStringPlain.java
Patch:
@@ -3,6 +3,7 @@ class ToString1 {
 	String name;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToString1(x=" + this.x + ", name=" + this.name + ")";
 	}
@@ -12,6 +13,7 @@ class ToString2 {
 	String name;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public java.lang.String toString() {
 		return "ToString2(x=" + this.x + ", name=" + this.name + ")";
 	}

File: test/transform/resource/after-delombok/TrickyTypeResolution.java
Patch:
@@ -14,6 +14,7 @@ class TrickyDoNothing2 {
 class TrickySuccess {
 	int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/TypeUseAnnotations.java
Patch:
@@ -9,16 +9,15 @@
 class TypeUseAnnotations {
 	List<@TA(x = 5) String> foo;
 	List<TypeUseAnnotations.@TA(x = 5) Inner> bar;
-
 	class Inner {
 	}
-
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public List<@TA(x = 5) String> getFoo() {
 		return this.foo;
 	}
-	
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public List<TypeUseAnnotations.@TA(x = 5) Inner> getBar() {
 		return this.bar;
 	}

File: test/transform/resource/after-delombok/UtilityClassInner.java
Patch:
@@ -1,8 +1,9 @@
 class UtilityClassInner {
 	static final class UtilClass {
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		private UtilClass() {
 			throw new java.lang.UnsupportedOperationException("This is a utility class and cannot be instantiated");
 		}
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/after-delombok/WithAlreadyExists.java
Patch:
@@ -36,6 +36,7 @@ void withFoo() {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public With5 withFoo(final String foo) {
 		return this.foo == foo ? this : new With5(foo);
 	}
@@ -50,6 +51,7 @@ void withFoo(String foo, int x) {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public With6 withFoo(final String foo) {
 		return this.foo == foo ? this : new With6(foo);
 	}

File: test/transform/resource/after-delombok/WithAndAllArgsConstructor.java
Patch:
@@ -5,6 +5,7 @@ class WithAndAllArgsConstructor<T, J extends T, L extends java.lang.Number> {
 	int y = 20;
 	final int z;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithAndAllArgsConstructor(final J test, final java.util.List<L> test2, final int y, final int z) {
 		this.test = test;
 		this.test2 = test2;
@@ -15,13 +16,15 @@ public WithAndAllArgsConstructor(final J test, final java.util.List<L> test2, fi
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithAndAllArgsConstructor<T, J, L> withTest(final J test) {
 		return this.test == test ? this : new WithAndAllArgsConstructor<T, J, L>(test, this.test2, this.y, this.z);
 	}
 	/**
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithAndAllArgsConstructor<T, J, L> withTest2(final java.util.List<L> test2) {
 		return this.test2 == test2 ? this : new WithAndAllArgsConstructor<T, J, L>(this.test, test2, this.y, this.z);
 	}

File: test/transform/resource/after-delombok/WithByInAnonymousClass.java
Patch:
@@ -1,14 +1,12 @@
 //version 8:
 public class WithByInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private Inner(String string) {
 			}
-
 			private String string;
-
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public Inner withStringBy(final java.util.function.Function<? super String, ? extends String> transformer) {
 				return new Inner(transformer.apply(this.string));
 			}

File: test/transform/resource/after-delombok/WithByNullAnnos.java
Patch:
@@ -3,11 +3,13 @@
 public class WithByNullAnnos {
 	final List<String> test;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithByNullAnnos(final List<String> test) {
 		this.test = test;
 	}
 	@org.checkerframework.checker.nullness.qual.NonNull
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithByNullAnnos withTestBy(final java.util.function.@org.checkerframework.checker.nullness.qual.NonNull Function<? super List<String>, ? extends List<String>> transformer) {
 		return new WithByNullAnnos(transformer.apply(this.test));
 	}

File: test/transform/resource/after-delombok/WithByOnRecord.java
Patch:
@@ -1,10 +1,12 @@
 // version 14:
 public record WithByOnRecord(String a, String b) {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithByOnRecord withABy(final java.util.function.Function<? super String, ? extends String> transformer) {
 		return new WithByOnRecord(transformer.apply(this.a), this.b);
 	}
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithByOnRecord withBBy(final java.util.function.Function<? super String, ? extends String> transformer) {
 		return new WithByOnRecord(this.a, transformer.apply(this.b));
 	}

File: test/transform/resource/after-delombok/WithByOnRecordComponent.java
Patch:
@@ -1,6 +1,7 @@
 // version 14:
 public record WithByOnRecordComponent(String a, String b) {
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithByOnRecordComponent withABy(final java.util.function.Function<? super String, ? extends String> transformer) {
 		return new WithByOnRecordComponent(transformer.apply(this.a), this.b);
 	}

File: test/transform/resource/after-delombok/WithInAnonymousClass.java
Patch:
@@ -1,16 +1,14 @@
 public class WithInAnonymousClass {
 	Object annonymous = new Object() {
-
 		class Inner {
 			private Inner(String string) {
 			}
-
 			private String string;
-
 			/**
 			 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 			 */
 			@java.lang.SuppressWarnings("all")
+			@lombok.Generated
 			public Inner withString(final String string) {
 				return this.string == string ? this : new Inner(string);
 			}

File: test/transform/resource/after-delombok/WithMethodAbstract.java
Patch:
@@ -4,5 +4,6 @@ abstract class WithMethodAbstract {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public abstract WithMethodAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecated.java
Patch:
@@ -12,6 +12,7 @@ class WithMethodMarkedDeprecated {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithMethodMarkedDeprecated withAnnotation(final int annotation) {
 		return this.annotation == annotation ? this : new WithMethodMarkedDeprecated(annotation, this.javadoc);
 	}
@@ -21,6 +22,7 @@ public WithMethodMarkedDeprecated withAnnotation(final int annotation) {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithMethodMarkedDeprecated withJavadoc(final int javadoc) {
 		return this.javadoc == javadoc ? this : new WithMethodMarkedDeprecated(this.annotation, javadoc);
 	}

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecatedAnnOnly.java
Patch:
@@ -8,6 +8,7 @@ class WithMethodMarkedDeprecatedAnnOnly {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithMethodMarkedDeprecatedAnnOnly withAnnotation(final int annotation) {
 		return this.annotation == annotation ? this : new WithMethodMarkedDeprecatedAnnOnly(annotation);
 	}

File: test/transform/resource/after-delombok/WithNested.java
Patch:
@@ -2,13 +2,15 @@ public interface WithNested<Z> {
 	class IAmStaticReally {
 		final String x;
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public IAmStaticReally(final String x) {
 			this.x = x;
 		}
 		/**
 		 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 		 */
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public WithNested.IAmStaticReally withX(final String x) {
 			return this.x == x ? this : new WithNested.IAmStaticReally(x);
 		}

File: test/transform/resource/after-delombok/WithOnNestedRecord.java
Patch:
@@ -1,19 +1,19 @@
 // version 14:
 public record WithOnNestedRecord<T>() {
-
 	public record Nested(String a, String b) {
 		/**
 		 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 		 */
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public WithOnNestedRecord.Nested withA(final String a) {
 			return this.a == a ? this : new WithOnNestedRecord.Nested(a, this.b);
 		}
-
 		/**
 		 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 		 */
 		@java.lang.SuppressWarnings("all")
+		@lombok.Generated
 		public WithOnNestedRecord.Nested withB(final String b) {
 			return this.b == b ? this : new WithOnNestedRecord.Nested(this.a, b);
 		}

File: test/transform/resource/after-delombok/WithOnRecord.java
Patch:
@@ -4,13 +4,15 @@ public record WithOnRecord(String a, String b) {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithOnRecord withA(final String a) {
 		return this.a == a ? this : new WithOnRecord(a, this.b);
 	}
 	/**
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithOnRecord withB(final String b) {
 		return this.b == b ? this : new WithOnRecord(this.a, b);
 	}

File: test/transform/resource/after-delombok/WithOnRecordComponent.java
Patch:
@@ -4,6 +4,7 @@ public record WithOnRecordComponent(String a, String b) {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithOnRecordComponent withA(final String a) {
 		return this.a == a ? this : new WithOnRecordComponent(a, this.b);
 	}

File: test/transform/resource/after-delombok/WithPlain.java
Patch:
@@ -11,6 +11,7 @@ class WithPlain {
 	 */
 	@org.springframework.lang.NonNull
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithPlain withI(final int i) {
 		return this.i == i ? this : new WithPlain(i, this.foo);
 	}
@@ -19,6 +20,7 @@ public WithPlain withI(final int i) {
 	 */
 	@org.springframework.lang.NonNull
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithPlain withFoo(final int foo) {
 		return this.foo == foo ? this : new WithPlain(this.i, foo);
 	}

File: test/transform/resource/after-delombok/WithWithGenerics.java
Patch:
@@ -9,20 +9,23 @@ public WithWithGenerics(J test, java.util.List<L> test2, java.util.List<? extend
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithWithGenerics<T, J, L> withTest(final J test) {
 		return this.test == test ? this : new WithWithGenerics<T, J, L>(test, this.test2, this.test3);
 	}
 	/**
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithWithGenerics<T, J, L> withTest2(final java.util.List<L> test2) {
 		return this.test2 == test2 ? this : new WithWithGenerics<T, J, L>(this.test, test2, this.test3);
 	}
 	/**
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithWithGenerics<T, J, L> withTest3(final java.util.List<? extends L> test3) {
 		return this.test3 == test3 ? this : new WithWithGenerics<T, J, L>(this.test, this.test2, test3);
 	}

File: test/transform/resource/after-delombok/WithWithJavaBeansSpecCapitalization.java
Patch:
@@ -6,6 +6,7 @@ class WithWithJavaBeansSpecCapitalization {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithWithJavaBeansSpecCapitalization withaField(final int aField) {
 		return this.aField == aField ? this : new WithWithJavaBeansSpecCapitalization(aField);
 	}

File: test/transform/resource/after-delombok/WithWithTypeAnnos.java
Patch:
@@ -18,6 +18,7 @@ class WithWithTypeAnnos {
 	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public WithWithTypeAnnos withFoo(@TA final List<String> foo) {
 		return this.foo == foo ? this : new WithWithTypeAnnos(foo);
 	}

File: test/transform/resource/after-delombok/TrickyTypeResolution.java
Patch:
@@ -14,6 +14,7 @@ class TrickyDoNothing2 {
 class TrickySuccess {
 	int x;
 	@java.lang.SuppressWarnings("all")
+	@lombok.Generated
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-ecj/DelegateGenerics.java
Patch:
@@ -3,13 +3,13 @@ public class DelegateGenerics<T> {
   public DelegateGenerics() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") T a(final T a) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated T a(final T a) {
     return this.target.a(a);
   }
-  public @java.lang.SuppressWarnings("all") java.lang.String i(final java.lang.String a) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated java.lang.String i(final java.lang.String a) {
     return this.target.i(a);
   }
-  public @java.lang.SuppressWarnings("all") java.lang.Integer t(final java.lang.Integer t) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated java.lang.Integer t(final java.lang.Integer t) {
     return this.target.t(t);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnGetter.java
Patch:
@@ -9,7 +9,7 @@ private interface Bar {
   DelegateOnGetter() {
     super();
   }
-  public @Delegate @java.lang.SuppressWarnings({"all", "unchecked"}) Bar getBar() {
+  public @Delegate @java.lang.SuppressWarnings({"all", "unchecked"}) @lombok.Generated Bar getBar() {
     java.lang.Object $value = this.bar.get();
     if (($value == null))
         {
@@ -35,10 +35,10 @@ public int getInt() {
         }
     return (Bar) (($value == this.bar) ? null : $value);
   }
-  public @java.lang.SuppressWarnings("all") int getInt() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getInt() {
     return this.getBar().getInt();
   }
-  public @java.lang.SuppressWarnings("all") void setList(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void setList(final java.util.ArrayList<java.lang.String> list) {
     this.getBar().setList(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnGetterNone.java
Patch:
@@ -10,10 +10,10 @@ private interface Bar {
   DelegateOnGetterNone() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") int getInt() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getInt() {
     return this.bar.getInt();
   }
-  public @java.lang.SuppressWarnings("all") void setList(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void setList(final java.util.ArrayList<java.lang.String> list) {
     this.bar.setList(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnMethods.java
Patch:
@@ -7,7 +7,7 @@ public static interface Bar {
     super();
   }
   public abstract @Delegate Bar getBar();
-  public @java.lang.SuppressWarnings("all") void bar(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void bar(final java.util.ArrayList<java.lang.String> list) {
     this.getBar().bar(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateTypesAndExcludes.java
Patch:
@@ -27,10 +27,10 @@ private static interface Bar {
   DelegatePlain() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") void bar(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void bar(final java.util.ArrayList<java.lang.String> list) {
     this.bar.bar(list);
   }
-  public @java.lang.SuppressWarnings("all") void foo() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void foo() {
     this.foo.foo();
   }
 }

File: test/transform/resource/after-ecj/DelegateWithDeprecated.java
Patch:
@@ -9,13 +9,13 @@ private interface Bar {
   DelegateWithDeprecated() {
     super();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void deprecatedAnnotation() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @lombok.Generated void deprecatedAnnotation() {
     this.bar.deprecatedAnnotation();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void deprecatedComment() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @lombok.Generated void deprecatedComment() {
     this.bar.deprecatedComment();
   }
-  public @java.lang.SuppressWarnings("all") void notDeprecated() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void notDeprecated() {
     this.bar.notDeprecated();
   }
 }

File: test/transform/resource/after-ecj/DelegateWithVarargs2.java
Patch:
@@ -11,7 +11,7 @@ public void varargs(Object[]... keys) {
   DelegateWithVarargs2() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") void varargs(final java.lang.Object[]... keys) {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated void varargs(final java.lang.Object[]... keys) {
     this.bar.varargs(keys);
   }
 }

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -3,7 +3,7 @@
 class LoggerFloggerRecord {
   public @Flogger record Inner(String x) {
 /* Implicit */    private final String x;
-    private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
+	private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
     <clinit>() {
     }
   }

File: test/transform/resource/after-ecj/MixGetterVal.java
Patch:
@@ -13,7 +13,7 @@ public void test() {
     final @val int a = getX();
     m(a);
   }
-  public @java.lang.SuppressWarnings("all") int getX() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getX() {
     return this.x;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/TrickyTypeResolution.java
Patch:
@@ -20,7 +20,7 @@ class TrickySuccess {
   TrickySuccess() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") int getX() {
+  public @java.lang.SuppressWarnings("all") @lombok.Generated int getX() {
     return this.x;
   }
 }

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -87,7 +87,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * If {@code true}, lombok generates {@code @lombok.Generated} on all fields, methods, and types that are generated.
 	 */
-	public static final ConfigurationKey<Boolean> ADD_LOMBOK_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addLombokGeneratedAnnotation", "Generate @lombok.Generated on all generated code (default: false).") {};
+	public static final ConfigurationKey<Boolean> ADD_LOMBOK_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addLombokGeneratedAnnotation", "Generate @lombok.Generated on all generated code (default: true).") {};
 	
 	/**
 	 * lombok configuration: {@code lombok.extern.findbugs.addSuppressFBWarnings} = {@code true} | {@code false}.

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -2098,7 +2098,7 @@ public static Annotation[] addGenerated(EclipseNode node, ASTNode source, Annota
 		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_JAKARTA_GENERATED_ANNOTATIONS))) {
 			result = addAnnotation(source, result, JAKARTA_ANNOTATION_GENERATED, new StringLiteral(LOMBOK, 0, 0, 0));
 		}
-		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
+		if (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
 			result = addAnnotation(source, result, LOMBOK_GENERATED);
 		}
 		return result;

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1542,7 +1542,7 @@ public static void addGenerated(JCModifiers mods, JavacNode node, JavacNode sour
 		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_JAKARTA_GENERATED_ANNOTATIONS))) {
 			addAnnotation(mods, node, source, "jakarta.annotation.Generated", node.getTreeMaker().Literal("lombok"));
 		}
-		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
+		if (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
 			addAnnotation(mods, node, source, "lombok.Generated", null);
 		}
 	}

File: test/transform/resource/before/GeneratedJavaxOnLombokOn.java
Patch:
@@ -1,5 +1,4 @@
 //CONF: lombok.addJavaxGeneratedAnnotation = true
-//CONF: lombok.addLombokGeneratedAnnotation = true
 class GeneratedJavaxOnLombokOn {
 	@lombok.Getter
 	int x;

File: test/transform/resource/before/GeneratedOffLombokOn.java
Patch:
@@ -1,5 +1,4 @@
 //CONF: lombok.addGeneratedAnnotation = false
-//CONF: lombok.addLombokGeneratedAnnotation = true
 class GeneratedOffLombokOn {
 	@lombok.Getter
 	int x;

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -215,7 +215,7 @@ public void createGetterForField(AccessLevel level,
 		
 		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
 		
-		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
+		injectMethod(fieldNode.up(), source, createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
 	}
 	
 	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod) {

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -147,6 +147,9 @@ public void handle(AnnotationValues<Getter> annotation, Annotation ast, EclipseN
 		if (node == null) return;
 		
 		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Getter(onMethod", annotationNode);
+		if (!onMethod.isEmpty()) {
+			handleFlagUsage(annotationNode, ConfigurationKeys.ON_X_FLAG_USAGE, "@Getter(onMethod=...)");
+		}
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -144,6 +144,9 @@ public void generateGetterForField(JavacNode fieldNode, DiagnosticPosition pos,
 		if (node == null) return;
 		
 		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Getter(onMethod", annotationNode);
+		if (!onMethod.isEmpty()) {
+			handleFlagUsage(annotationNode, ConfigurationKeys.ON_X_FLAG_USAGE, "@Getter(onMethod=...)");
+		}
 		
 		switch (node.getKind()) {
 		case FIELD:

File: test/eclipse/src/lombok/eclipse/EclipseTests.java
Patch:
@@ -28,13 +28,14 @@
 import lombok.eclipse.cleanup.CleanupTest;
 import lombok.eclipse.compile.NoErrorsTest;
 import lombok.eclipse.edit.SelectTest;
+import lombok.eclipse.misc.JavadocTest;
 import lombok.eclipse.refactoring.ExtractInterfaceTest;
 import lombok.eclipse.refactoring.InlineTest;
 import lombok.eclipse.refactoring.RenameTest;
 import lombok.eclipse.references.FindReferencesTest;
 
 @RunWith(Suite.class)
-@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class, InlineTest.class, NoErrorsTest.class})
+@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class, InlineTest.class, NoErrorsTest.class, JavadocTest.class})
 public class EclipseTests {
 	
 }

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2022 The Project Lombok Authors.
+ * Copyright (C) 2009-2024 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -323,7 +323,7 @@ public Statement[] createSimpleGetterBody(ASTNode source, EclipseNode fieldNode)
 		TYPE_MAP = Collections.unmodifiableMap(m);
 	}
 	
-	private static char[] valueName = "value".toCharArray();
+	private static char[] valueName = "$value".toCharArray();
 	private static char[] actualValueName = "actualValue".toCharArray();
 	
 	private static final int PARENTHESIZED = (1 << ASTNode.ParenthesizedSHIFT) & ASTNode.ParenthesizedMASK;

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2022 The Project Lombok Authors.
+ * Copyright (C) 2009-2024 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -358,7 +358,7 @@ public List<JCStatement> createLazyGetterBody(JavacTreeMaker maker, JavacNode fi
 		}
 		if (copyOfBoxedFieldType == null) copyOfBoxedFieldType = copyType(maker, field, source);
 		
-		Name valueName = fieldNode.toName("value");
+		Name valueName = fieldNode.toName("$value");
 		Name actualValueName = fieldNode.toName("actualValue");
 		
 		/* java.lang.Object value = this.fieldName.get();*/ {

File: src/core/lombok/bytecode/PreventNullAnalysisRemover.java
Patch:
@@ -44,7 +44,7 @@ public class PreventNullAnalysisRemover implements PostCompilerTransformation {
 		byte[] fixedByteCode = fixJSRInlining(original);
 		
 		ClassReader reader = new ClassReader(fixedByteCode);
-		ClassWriter writer = new FixedClassWriter(reader, 0);
+		ClassWriter writer = new FixedClassWriter(0);
 		
 		final AtomicBoolean changesMade = new AtomicBoolean();
 		

File: src/core/lombok/bytecode/SneakyThrowsRemover.java
Patch:
@@ -46,7 +46,7 @@ public class SneakyThrowsRemover implements PostCompilerTransformation {
 		byte[] fixedByteCode = fixJSRInlining(original);
 		
 		ClassReader reader = new ClassReader(fixedByteCode);
-		ClassWriter writer = new ClassWriter(reader, 0);
+		ClassWriter writer = new ClassWriter(0);
 
 		final AtomicBoolean changesMade = new AtomicBoolean();
 		

File: src/core/lombok/bytecode/PreventNullAnalysisRemover.java
Patch:
@@ -44,7 +44,7 @@ public class PreventNullAnalysisRemover implements PostCompilerTransformation {
 		byte[] fixedByteCode = fixJSRInlining(original);
 		
 		ClassReader reader = new ClassReader(fixedByteCode);
-		ClassWriter writer = new FixedClassWriter(reader, 0);
+		ClassWriter writer = new FixedClassWriter(0);
 		
 		final AtomicBoolean changesMade = new AtomicBoolean();
 		

File: src/core/lombok/bytecode/SneakyThrowsRemover.java
Patch:
@@ -46,7 +46,7 @@ public class SneakyThrowsRemover implements PostCompilerTransformation {
 		byte[] fixedByteCode = fixJSRInlining(original);
 		
 		ClassReader reader = new ClassReader(fixedByteCode);
-		ClassWriter writer = new ClassWriter(reader, 0);
+		ClassWriter writer = new ClassWriter(0);
 
 		final AtomicBoolean changesMade = new AtomicBoolean();
 		

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -1108,6 +1108,8 @@ private ListBuffer<JCExpression> getTypeParamExpressions(List<? extends JCTree>
 				typeParamsForBuilderParameter.append(copySelect(maker, (JCFieldAccess) typeParam));
 			} else if (typeParam instanceof JCTypeApply) {
 				typeParamsForBuilderParameter.append(cloneType(maker, (JCTypeApply)typeParam, source));
+			} else if (JCAnnotatedTypeReflect.is(typeParam)) {
+				typeParamsForBuilderParameter.append(cloneType(maker, (JCExpression)typeParam, source));
 			}
 		}
 		return typeParamsForBuilderParameter;

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -1108,6 +1108,8 @@ private ListBuffer<JCExpression> getTypeParamExpressions(List<? extends JCTree>
 				typeParamsForBuilderParameter.append(copySelect(maker, (JCFieldAccess) typeParam));
 			} else if (typeParam instanceof JCTypeApply) {
 				typeParamsForBuilderParameter.append(cloneType(maker, (JCTypeApply)typeParam, source));
+			} else if (JCAnnotatedTypeReflect.is(typeParam)) {
+				typeParamsForBuilderParameter.append(cloneType(maker, (JCExpression)typeParam, source));
 			}
 		}
 		return typeParamsForBuilderParameter;

File: test/eclipse/src/lombok/eclipse/EclipseTests.java
Patch:
@@ -5,14 +5,15 @@
 import org.junit.runners.Suite.SuiteClasses;
 
 import lombok.eclipse.cleanup.CleanupTest;
+import lombok.eclipse.compile.NoErrorsTest;
 import lombok.eclipse.edit.SelectTest;
 import lombok.eclipse.refactoring.ExtractInterfaceTest;
 import lombok.eclipse.refactoring.InlineTest;
 import lombok.eclipse.refactoring.RenameTest;
 import lombok.eclipse.references.FindReferencesTest;
 
 @RunWith(Suite.class)
-@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class, InlineTest.class})
+@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class, InlineTest.class, NoErrorsTest.class})
 public class EclipseTests {
 	
 }

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1331,9 +1331,7 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a
 				expressions = new Expression[] { rhs };
 			}
 			if (expressions != null) for (Expression ex : expressions) {
-				StringBuffer sb = new StringBuffer();
-				ex.print(0, sb);
-				raws.add(sb.toString());
+				raws.add(ex.toString()); 
 				expressionValues.add(ex);
 				guesses.add(calculateValue(ex));
 			}

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -123,8 +123,8 @@ private ICompilationUnit getSourceUnit(File file, String source) {
 	}
 	
 	@Override
-	public TransformationResult transformCode(File file, TestParameters parameters) throws Throwable {
-		TransformationResult result = new TransformationResult();
+	public TransformationResult transformCode(File file, final TestParameters parameters) throws Throwable {
+		final TransformationResult result = new TransformationResult();
 		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
 		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
 		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {

File: src/core/lombok/eclipse/EclipseNode.java
Patch:
@@ -217,7 +217,7 @@ private Integer getModifiers() {
 		if (node instanceof TypeDeclaration) {
 			TypeDeclaration t = (TypeDeclaration) node;
 			int f = t.modifiers;
-			if (((ClassFileConstants.AccInterface | ClassFileConstants.AccEnum) & f) != 0) return true;
+			if (((ClassFileConstants.AccInterface | ClassFileConstants.AccEnum | Eclipse.AccRecord) & f) != 0) return true;
 			
 			EclipseNode directUp = directUp();
 			if (directUp == null || directUp.getKind() == Kind.COMPILATION_UNIT) return true;

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -941,7 +941,7 @@ public static TypeReference generateParameterizedTypeReference(EclipseNode paren
 		return new ParameterizedQualifiedTypeReference(tn, rr, 0, ps);
 	}
 	
-	private static final int MODIFIERS_INDICATING_STATIC = ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum;
+	private static final int MODIFIERS_INDICATING_STATIC = ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum | Eclipse.AccRecord;
 	
 	/**
 	 * This class will add type params to fully qualified chain of type references for inner types, such as {@code GrandParent.Parent.Child}; this is needed only as long as the chain does not involve static.

File: src/core/lombok/javac/JavacNode.java
Patch:
@@ -288,7 +288,7 @@ private JCModifiers getModifiers() {
 		if (node instanceof JCClassDecl) {
 			JCClassDecl t = (JCClassDecl) node;
 			long f = t.mods.flags;
-			if (((Flags.INTERFACE | Flags.ENUM) & f) != 0) return true;
+			if (((Flags.INTERFACE | Flags.ENUM | Javac.RECORD) & f) != 0) return true;
 			JavacNode directUp = directUp();
 			if (directUp == null || directUp.getKind() == Kind.COMPILATION_UNIT) return true;
 			if (!(directUp.get() instanceof JCClassDecl)) return false;

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -2033,13 +2033,13 @@ public static JCExpression removeTypeUseAnnotations(JCExpression from) {
 	
 	public static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {
 		JCClassDecl td = (JCClassDecl) type.get();
-		boolean instance = (td.mods.flags & Flags.STATIC) == 0;
+		boolean instance = !type.isStatic();
 		return namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());
 	}
 	
 	public static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {
 		JCClassDecl td = (JCClassDecl) type.get();
-		boolean instance = (td.mods.flags & Flags.STATIC) == 0;
+		boolean instance = !type.isStatic();
 		return namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);
 	}
 	
@@ -2051,7 +2051,7 @@ public static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker make
 		JCExpression r = null;
 		if (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {
 			JCClassDecl td = (JCClassDecl) parentType.get();
-			boolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);
+			boolean outerInstance = instance && !parentType.isStatic();
 			List<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();
 			r = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());
 		}

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -170,6 +170,9 @@ public static void transform(Parser parser, CompilationUnitDeclaration ast) {
 		if (fileName != null && String.valueOf(fileName).endsWith("module-info.java")) return;
 		
 		if (Symbols.hasSymbol("lombok.disable")) return;
+		// The IndexingParser only supports a single import statement, restricting lombok annotations to either fully qualified ones or
+		// those specified in the last import statement. To avoid handling hard to reproduce edge cases, we opt to ignore the entire parser.
+		if ("org.eclipse.jdt.internal.core.search.indexing.IndexingParser".equals(parser.getClass().getName())) return;
 		if (alreadyTransformed(ast)) return;
 		
 		// Do NOT abort if (ast.bits & ASTNode.HasAllMethodBodies) != 0 - that doesn't work.

File: src/core/lombok/core/configuration/ConfigurationFile.java
Patch:
@@ -183,7 +183,7 @@ CharSequence contents() throws IOException {
 		
 		private static String replaceEnvironmentVariables(String fileName) {
 			int start = 0;
-			StringBuilder result = new StringBuilder();
+			StringBuffer result = new StringBuffer();
 			if (fileName.startsWith("~")) {
 				start = 1;
 				result.append(System.getProperty("user.home", "~"));

File: src/core/lombok/core/configuration/ConfigurationFile.java
Patch:
@@ -183,7 +183,7 @@ CharSequence contents() throws IOException {
 		
 		private static String replaceEnvironmentVariables(String fileName) {
 			int start = 0;
-			StringBuffer result = new StringBuffer();
+			StringBuilder result = new StringBuilder();
 			if (fileName.startsWith("~")) {
 				start = 1;
 				result.append(System.getProperty("user.home", "~"));

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1331,9 +1331,7 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a
 				expressions = new Expression[] { rhs };
 			}
 			if (expressions != null) for (Expression ex : expressions) {
-				StringBuffer sb = new StringBuffer();
-				ex.print(0, sb);
-				raws.add(sb.toString());
+				raws.add(ex.toString()); 
 				expressionValues.add(ex);
 				guesses.add(calculateValue(ex));
 			}

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -112,6 +112,7 @@ class ShadowClassLoader extends ClassLoader {
 	public void prependParent(ClassLoader loader) {
 		if (loader == null) return;
 		if (loader == getParent()) return;
+		if (loader == this) return;
 		prependedParentLoaders.add(loader);
 	}
 	

File: test/eclipse/src/lombok/eclipse/EclipseTests.java
Patch:
@@ -7,11 +7,12 @@
 import lombok.eclipse.cleanup.CleanupTest;
 import lombok.eclipse.edit.SelectTest;
 import lombok.eclipse.refactoring.ExtractInterfaceTest;
+import lombok.eclipse.refactoring.InlineTest;
 import lombok.eclipse.refactoring.RenameTest;
 import lombok.eclipse.references.FindReferencesTest;
 
 @RunWith(Suite.class)
-@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class})
+@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class, InlineTest.class})
 public class EclipseTests {
 	
 }

File: src/core/lombok/javac/handlers/HandleBuilderDefaultRemove.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2021 The Project Lombok Authors.
+ * Copyright (C) 2018-2023 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -41,5 +41,6 @@ public class HandleBuilderDefaultRemove extends JavacAnnotationHandler<Builder.D
 	@Override public void handle(AnnotationValues<Default> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		deleteAnnotationIfNeccessary(annotationNode, Builder.Default.class);
 		deleteImportFromCompilationUnit(annotationNode, Builder.class.getName());
+		deleteImportFromCompilationUnit(annotationNode, Builder.Default.class.getName());
 	}
 }

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -108,7 +108,6 @@ class ConstructorWithToBuilder<T> {
 	private String mOne;
 	private String mTwo;
 	private T foo;
-	@lombok.Singular
 	private com.google.common.collect.ImmutableList<T> bars;
 	public ConstructorWithToBuilder(String mOne, T baz, com.google.common.collect.ImmutableList<T> bars) {
 	}

File: test/transform/resource/after-ecj/SingularCleanupForDelombok.java
Patch:
@@ -0,0 +1 @@
+// ignore: This tests specifically that delombok removes something; it does not apply to ecj

File: test/configuration/src/lombok/core/configuration/TestConfiguration.java
Patch:
@@ -76,7 +76,7 @@ public void testDisplayVerbose() throws Exception {
 	private void checkContent(File dir, String actual, String type) throws Exception {
 		String expected = fileToString(new File(dir, type + ".txt")).replace("\r", "").trim();
 		if (!expected.equals(actual)) {
-			System.out.printf("**** Expected %s:\n", type);
+			System.out.printf("**** Expected %s (@%s):\n", type, new File(dir, type + ".txt").getCanonicalPath());
 			System.out.println(expected);
 			System.out.printf("**** Actual %s:\n", type);
 			System.out.println(actual);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1521,6 +1521,9 @@ public static void addGenerated(JCModifiers mods, JavacNode node, JavacNode sour
 		if (HandlerUtil.shouldAddGenerated(node)) {
 			addAnnotation(mods, node, source, "javax.annotation.Generated", node.getTreeMaker().Literal("lombok"));
 		}
+		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_JAKARTA_GENERATED_ANNOTATIONS))) {
+			addAnnotation(mods, node, source, "jakarta.annotation.Generated", node.getTreeMaker().Literal("lombok"));
+		}
 		if (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {
 			addAnnotation(mods, node, source, "lombok.Generated", null);
 		}

File: test/transform/resource/after-delombok/GeneratedJavaxOnLombokOn.java
Patch:
@@ -1,4 +1,3 @@
-//version :8
 class GeneratedJavaxOnLombokOn {
 	int x;
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/GeneratedOffJavaxOn.java
Patch:
@@ -1,4 +1,3 @@
-//version :8
 class GeneratedOffJavaxOn {
 	int x;
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/before/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -1,4 +1,3 @@
-//CONF: lombok.addGeneratedAnnotation = false
 import lombok.*;
 import static lombok.AccessLevel.NONE;
 

File: test/transform/resource/before/GeneratedJavaxOnLombokOn.java
Patch:
@@ -1,6 +1,5 @@
 //CONF: lombok.addJavaxGeneratedAnnotation = true
 //CONF: lombok.addLombokGeneratedAnnotation = true
-//version :8
 class GeneratedJavaxOnLombokOn {
 	@lombok.Getter
 	int x;

File: test/transform/resource/before/GeneratedOffJavaxOn.java
Patch:
@@ -1,6 +1,5 @@
 //CONF: lombok.addGeneratedAnnotation = false
 //CONF: lombok.addJavaxGeneratedAnnotation = true
-//version :8
 class GeneratedOffJavaxOn {
 	@lombok.Getter
 	int x;

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -168,7 +168,7 @@ public void createGetterForFields(AccessLevel level, Collection<EclipseNode> fie
 	public void createGetterForField(AccessLevel level,
 			EclipseNode fieldNode, EclipseNode errorNode, ASTNode source, boolean whineIfExists, boolean lazy, List<Annotation> onMethod) {
 		
-		if (fieldNode.getKind() != Kind.FIELD) {
+		if (fieldNode.getKind() != Kind.FIELD || fieldNode.isEnumMember()) {
 			errorNode.addError(GETTER_NODE_NOT_SUPPORTED_ERR);
 			return;
 		}

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -165,7 +165,7 @@ public void createGetterForFields(AccessLevel level, Collection<JavacNode> field
 	public void createGetterForField(AccessLevel level,
 			JavacNode fieldNode, JavacNode source, boolean whineIfExists, boolean lazy, List<JCAnnotation> onMethod) {
 		
-		if (fieldNode.getKind() != Kind.FIELD) {
+		if (fieldNode.getKind() != Kind.FIELD || fieldNode.isEnumMember()) {
 			source.addError(GETTER_NODE_NOT_SUPPORTED_ERR);
 			return;
 		}

File: test/transform/resource/after-delombok/GetterEnumConstant.java
Patch:
@@ -0,0 +1,3 @@
+enum GetterEnumConstant {
+	ONE;
+}

File: src/core/lombok/javac/JavacAugments.java
Patch:
@@ -34,4 +34,5 @@ private JavacAugments() {
 	public static final FieldAugment<JCTree, Boolean> JCTree_handled = FieldAugment.augment(JCTree.class, boolean.class, "lombok$handled");
 	public static final FieldAugment<JCTree, JCTree> JCTree_generatedNode = FieldAugment.circularSafeAugment(JCTree.class, JCTree.class, "lombok$generatedNode");
 	public static final FieldAugment<JCImport, Boolean> JCImport_deletable = FieldAugment.circularSafeAugment(JCImport.class, Boolean.class, "lombok$deletable");
+	public static final FieldAugment<JCTree, Boolean> JCTree_keepPosition = FieldAugment.augment(JCTree.class, boolean.class, "lombok$keepPosition");
 }

File: test/transform/resource/before/GetterLazyArguments.java
Patch:
@@ -18,4 +18,7 @@ class GetterLazyArguments {
 	
 	@lombok.Getter(lazy=true)
 	private final String field5 = stringRunnable(("a"), () -> { });
+	
+	@lombok.Getter(lazy=true)
+	private final String field6 = true ? stringInt(true ? "a" : "b", true ? 1 : 0) : "";
 }

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -73,10 +73,10 @@ public void handle(final AnnotationValues<ExtensionMethod> annotation, final JCA
 		
 		deleteAnnotationIfNeccessary(annotationNode, ExtensionMethod.class);
 		JavacNode typeNode = annotationNode.up();
-		boolean isClassOrEnumOrInterface = isClassOrEnumOrInterface(typeNode);
+		boolean isClassEnumInterfaceOrRecord = isClassEnumInterfaceOrRecord(typeNode);
 		
-		if (!isClassOrEnumOrInterface) {
-			annotationNode.addError("@ExtensionMethod can only be used on a class or an enum or an interface");
+		if (!isClassEnumInterfaceOrRecord) {
+			annotationNode.addError("@ExtensionMethod can only be used on a class, an enum, an interface or a record");
 			return;
 		}
 		

File: src/core/lombok/bytecode/ClassFileMetaData.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2019 The Project Lombok Authors.
+ * Copyright (C) 2010-2023 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/launch/lombok/launch/ClassFileMetaData.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2019 The Project Lombok Authors.
+ * Copyright (C) 2010-2023 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2021 The Project Lombok Authors.
+ * Copyright (C) 2014-2023 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -34,7 +34,6 @@
 import java.net.URL;
 import java.net.URLDecoder;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;

File: src/core/lombok/javac/JavacImportList.java
Patch:
@@ -50,7 +50,7 @@ public JavacImportList(JCCompilationUnit cud) {
 	@Override public String getFullyQualifiedNameForSimpleNameNoAliasing(String unqualified) {
 		for (JCTree def : defs) {
 			if (!(def instanceof JCImport)) continue;
-			JCTree qual = ((JCImport) def).qualid;
+			JCTree qual = Javac.getQualid((JCImport) def);
 			if (!(qual instanceof JCFieldAccess)) continue;
 			String simpleName = ((JCFieldAccess) qual).name.toString();
 			if (simpleName.equals(unqualified)) {
@@ -68,7 +68,7 @@ public JavacImportList(JCCompilationUnit cud) {
 		for (JCTree def : defs) {
 			if (!(def instanceof JCImport)) continue;
 			if (((JCImport) def).staticImport) continue;
-			JCTree qual = ((JCImport) def).qualid;
+			JCTree qual = Javac.getQualid((JCImport) def);
 			if (!(qual instanceof JCFieldAccess)) continue;
 			String simpleName = ((JCFieldAccess) qual).name.toString();
 			if (!"*".equals(simpleName)) continue;
@@ -87,7 +87,7 @@ public JavacImportList(JCCompilationUnit cud) {
 		for (JCTree def : defs) {
 			if (!(def instanceof JCImport)) continue;
 			if (((JCImport) def).staticImport) continue;
-			JCTree qual = ((JCImport) def).qualid;
+			JCTree qual = Javac.getQualid((JCImport) def);
 			if (!(qual instanceof JCFieldAccess)) continue;
 			String simpleName = ((JCFieldAccess) qual).name.toString();
 			if (!"*".equals(simpleName)) continue;

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -561,7 +561,7 @@ public static void deleteImportFromCompilationUnit(JavacNode node, String name)
 			if (!(def instanceof JCImport)) continue;
 			JCImport imp0rt = (JCImport) def;
 			if (imp0rt.staticImport) continue;
-			if (!imp0rt.qualid.toString().equals(name)) continue;
+			if (!Javac.getQualid(imp0rt).toString().equals(name)) continue;
 			JavacAugments.JCImport_deletable.set(imp0rt, true);
 		}
 	}

File: test/transform/resource/after-delombok/HelperInMethod.java
Patch:
@@ -1,6 +1,6 @@
 public class HelperInMethod {
 	int someMethod(int arg1) {
-		int localVar = 5;
+		final int localVar = 5;
 
 		class Helpers {
 			int helperMethod(int arg) {

File: test/transform/resource/after-ecj/HelperInMethod.java
Patch:
@@ -4,7 +4,7 @@ public HelperInMethod() {
     super();
   }
   int someMethod(int arg1) {
-    int localVar = 5;
+    final int localVar = 5;
     @Helper class Helpers {
       Helpers() {
         super();

File: test/transform/resource/before/HelperInMethod.java
Patch:
@@ -2,7 +2,7 @@
 
 public class HelperInMethod {
 	int someMethod(int arg1) {
-		int localVar = 5;
+		final int localVar = 5;
 		
 		@Helper
 		class Helpers {

File: src/core/lombok/javac/handlers/HandleHelper.java
Patch:
@@ -40,6 +40,7 @@
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.tree.JCTree.JCIdent;
+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
@@ -61,12 +62,14 @@ public class HandleHelper extends JavacAnnotationHandler<Helper> {
 	private List<JCStatement> getStatementsFromJcNode(JCTree tree) {
 		if (tree instanceof JCBlock) return ((JCBlock) tree).stats;
 		if (tree instanceof JCCase) return ((JCCase) tree).stats;
+		if (tree instanceof JCMethodDecl) return ((JCMethodDecl) tree).body.stats;
 		return null;
 	}
 	
 	private void setStatementsOfJcNode(JCTree tree, List<JCStatement> statements) {
 		if (tree instanceof JCBlock) ((JCBlock) tree).stats = statements;
 		else if (tree instanceof JCCase) ((JCCase) tree).stats = statements;
+		else if (tree instanceof JCMethodDecl) ((JCMethodDecl) tree).body.stats = statements;
 		else throw new IllegalArgumentException("Can't set statements on node type: " + tree.getClass());
 	}
 	

File: test/transform/resource/after-delombok/HelperInInitializationBlock.java
Patch:
@@ -1,4 +1,4 @@
-class HelperTest {
+public class HelperInInitializationBlock {
 	{
 		final int z = 5;
 		if (Boolean.TRUE) {

File: test/transform/resource/after-ecj/HelperInInitializationBlock.java
Patch:
@@ -1,5 +1,5 @@
 import lombok.experimental.Helper;
-class HelperTest {
+public class HelperInInitializationBlock {
   {
     final int z = 5;
     if (Boolean.TRUE)
@@ -24,7 +24,7 @@ void bar() {
           }
         }
   }
-  HelperTest() {
+  public HelperInInitializationBlock() {
     super();
   }
 }

File: test/transform/resource/before/HelperInInitializationBlock.java
Patch:
@@ -1,6 +1,6 @@
 import lombok.experimental.Helper;
 
-class HelperTest {
+public class HelperInInitializationBlock {
 	{
 		final int z = 5;
 		if (Boolean.TRUE) {

File: test/transform/resource/after-delombok/ToStringArrayTypeAnnotations.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 

File: test/transform/resource/before/ToStringArrayTypeAnnotations.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -206,7 +206,7 @@ static JCMethodDecl createToString(JavacNode typeNode, Collection<Included<Javac
 				memberAccessor = createFieldAccessor(maker, memberNode, fieldAccess);
 			}
 			
-			JCExpression memberType = getFieldType(memberNode, fieldAccess);
+			JCExpression memberType = removeTypeUseAnnotations(getFieldType(memberNode, fieldAccess));
 			
 			// The distinction between primitive and object will be useful if we ever add a 'hideNulls' option.
 			@SuppressWarnings("unused")

File: test/transform/resource/after-ecj/LockedInRecord.java
Patch:
@@ -1,8 +1,8 @@
 import lombok.experimental.Locked;
-public record LockedInRecord(java lock, String a) {
-  private final java.util.concurrent.locks.ReentrantLock lock = new java.util.concurrent.locks.ReentrantLock();
+public record LockedInRecord(String a, String b) {
 /* Implicit */  private final String a;
 /* Implicit */  private final String b;
+  private final java.util.concurrent.locks.ReentrantLock lock = new java.util.concurrent.locks.ReentrantLock();
   public LockedInRecord(String a, String b) {
     super();
     .a = a;

File: test/eclipse/src/lombok/eclipse/EclipseTests.java
Patch:
@@ -8,9 +8,10 @@
 import lombok.eclipse.edit.SelectTest;
 import lombok.eclipse.refactoring.ExtractInterfaceTest;
 import lombok.eclipse.refactoring.RenameTest;
+import lombok.eclipse.references.FindReferencesTest;
 
 @RunWith(Suite.class)
-@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class})
+@SuiteClasses({ExtractInterfaceTest.class, RenameTest.class, SelectTest.class, CleanupTest.class, FindReferencesTest.class})
 public class EclipseTests {
 	
 }

File: test/eclipse/src/lombok/eclipse/SetupBeforeAfterTest.java
Patch:
@@ -32,7 +32,7 @@ protected void starting(Description description) {
 	protected void succeeded(Description description) {
 		try {
 			compareWithAfter();
-		} catch (Throwable e) {
+		} catch (Exception e) {
 			throw new RuntimeException(e);
 		}
 	}

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -796,10 +796,11 @@ private JCMethodDecl generateBuildMethod(BuilderJob job, Name staticName, JCExpr
 		List<JCAnnotation> annsOnMethod = job.checkerFramework.generateSideEffectFree() ? List.of(maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil())) : List.<JCAnnotation>nil();
 		JCVariableDecl recv = generateReceiver(job);
 		JCMethodDecl methodDef;
+		JCExpression returnTypeCopy = cloneType(maker, returnType, job.sourceNode);
 		if (recv != null && maker.hasMethodDefWithRecvParam()) {
-			methodDef = maker.MethodDefWithRecvParam(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnType, List.<JCTypeParameter>nil(), recv, List.<JCVariableDecl>nil(), thrownExceptions, body, null);
+			methodDef = maker.MethodDefWithRecvParam(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnTypeCopy, List.<JCTypeParameter>nil(), recv, List.<JCVariableDecl>nil(), thrownExceptions, body, null);
 		} else {
-			methodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnType, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);
+			methodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnTypeCopy, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);
 		}
 		if (staticName == null) createRelevantNonNullAnnotation(job.builderType, methodDef);
 		return methodDef;

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -440,7 +440,7 @@ public JCMethodDecl createStaticConstructor(String name, AccessLevel level, Java
 		
 		if (!type.typarams.isEmpty()) {
 			for (JCTypeParameter param : type.typarams) {
-				typeParams.append(maker.TypeParameter(param.name, param.bounds));
+				typeParams.append(maker.TypeParameter(param.name, cloneTypes(maker, param.bounds, source)));
 			}
 		}
 		List<JCAnnotation> annsOnReturnType = List.nil();

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -260,7 +260,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 			Name superclassName = ((JCFieldAccess) extendsClause).getIdentifier();
 			String builderClassNameTemplate = BuilderJob.getBuilderClassNameTemplate(annotationNode, null);
 			String superclassBuilderClassName = job.replaceBuilderClassName(superclassName.toString(), builderClassNameTemplate);
-			superclassBuilderClass = parent.getTreeMaker().Select((JCFieldAccess) extendsClause, parent.toName(superclassBuilderClassName));
+			superclassBuilderClass = parent.getTreeMaker().Select(cloneType(maker, (JCFieldAccess) extendsClause, annotationNode), parent.toName(superclassBuilderClassName));
 		} else if (extendsClause != null) {
 			String builderClassNameTemplate = BuilderJob.getBuilderClassNameTemplate(annotationNode, null);
 			String superclassBuilderClassName = job.replaceBuilderClassName(extendsClause.toString(), builderClassNameTemplate);
@@ -607,6 +607,7 @@ private JCMethodDecl generateBuilderMethod(SuperBuilderJob job) {
 		// Now add the <?, ?>.
 		JCWildcard wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);
 		typeParameterNames.append(wildcard);
+		wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);
 		typeParameterNames.append(wildcard);
 		// And return type annotations.
 		List<JCAnnotation> annsOnParamType = List.nil();
@@ -644,6 +645,7 @@ private JCMethodDecl generateToBuilderMethod(SuperBuilderJob job) {
 		// Now add the <?, ?>.
 		JCWildcard wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);
 		typeParameterNames.append(wildcard);
+		wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);
 		typeParameterNames.append(wildcard);
 		JCTypeApply returnType = maker.TypeApply(namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderAbstractClassName), false, List.<JCTypeParameter>nil()), typeParameterNames.toList());
 		

File: test/transform/resource/before/SuperBuilderCustomName.java
Patch:
@@ -2,6 +2,6 @@
 import java.util.List;
 
 @lombok.experimental.SuperBuilder
-class BuilderCustomName<T> {
+class SuperBuilderCustomName<T> {
 	private final int field;
 }

File: test/transform/resource/after-delombok/LoggerFloggerRecord.java
Patch:
@@ -1,4 +1,4 @@
-// version 14:
+// version 16:
 class LoggerFloggerRecord {
 	public record Inner(String x) {
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/before/LoggerFloggerRecord.java
Patch:
@@ -1,4 +1,4 @@
-// version 14:
+// version 16:
 
 import lombok.extern.flogger.Flogger;
 

File: test/transform/resource/after-delombok/ValSuperDefaultMethod.java
Patch:
@@ -1,4 +1,4 @@
-// version :9
+// version 8:9
 class ValSuperDefaultMethod implements Default {
 	public void test() {
 		final java.lang.String a = "";

File: test/transform/resource/before/ValSuperDefaultMethod.java
Patch:
@@ -1,4 +1,4 @@
-// version :9
+// version 8:9
 import lombok.val;
 
 class ValSuperDefaultMethod implements Default {

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2022 The Project Lombok Authors.
+ * Copyright (C) 2013-2023 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -103,6 +103,7 @@ private ConfigurationKeys() {}
 	 * Lombok generally copies relevant nullity annotations from your source code to the right places. However, sometimes lombok generates code where the nullability of some node is not dependent on something in your source code. You can configure lombok to add an appropriate nullity annotation in this case.<ul>
 	 * <li>{@code none} (the default) - no annotations are added.</li>
 	 * <li>{@code javax} - The annotations {@code javax.annotation.NonNull} and {@code javax.annotation.Nullable} are used.</li>
+	 * <li>{@code jakarta} - The annotations {@code jakarta.annotation.NonNull} and {@code jakarta.annotation.Nullable} are used.</li>
 	 * <li>{@code eclipse} - The annotations {@code org.eclipse.jdt.annotation.NonNull} and {@code org.eclipse.jdt.annotation.Nullable} are used.</li>
 	 * <li>{@code jetbrains} - The annotations {@code org.jetbrains.annotations.NotNull} and {@code org.jetbrains.annotations.Nullable} are used.</li>
 	 * <li>{@code netbeans} - The annotations {@code org.netbeans.api.annotations.common.NonNull} and {@code org.netbeans.api.annotations.common.NullAllowed} are used.</li>

File: src/core/lombok/core/configuration/NullAnnotationLibrary.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 The Project Lombok Authors.
+ * Copyright (C) 2020-2023 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -63,6 +63,7 @@ public boolean isTypeUse() {
 	
 	public static final NullAnnotationLibrary NONE = new NullAnnotationLibrary("none", null, null, false);
 	public static final NullAnnotationLibrary JAVAX = new NullAnnotationLibrary("javax", "javax.annotation.Nonnull", "javax.annotation.Nullable", false);
+	public static final NullAnnotationLibrary JAKARTA = new NullAnnotationLibrary("jakarta", "jakarta.annotation.Nonnull", "jakarta.annotation.Nullable", false);
 	public static final NullAnnotationLibrary ECLIPSE = new NullAnnotationLibrary("eclipse", "org.eclipse.jdt.annotation.NonNull", "org.eclipse.jdt.annotation.Nullable", true);
 	public static final NullAnnotationLibrary JETBRAINS = new NullAnnotationLibrary("jetbrains", "org.jetbrains.annotations.NotNull", "org.jetbrains.annotations.Nullable", false);
 	public static final NullAnnotationLibrary NETBEANS = new NullAnnotationLibrary("netbeans", "org.netbeans.api.annotations.common.NonNull", "org.netbeans.api.annotations.common.NullAllowed", false);

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -103,6 +103,7 @@ public static int primeForNull() {
 			"io.micrometer.core.lang.NonNull",
 			"io.reactivex.annotations.NonNull",
 			"io.reactivex.rxjava3.annotations.NonNull",
+			"jakarta.annotation.Nonnull",
 			"javax.annotation.Nonnull",
 			// "javax.validation.constraints.NotNull", // The field might contain a null value until it is persisted.
 			"libcore.util.NonNull",
@@ -160,9 +161,10 @@ public static int primeForNull() {
 			"io.reactivex.annotations.Nullable",
 			"io.reactivex.rxjava3.annotations.NonNull",
 			"io.reactivex.rxjava3.annotations.Nullable",
+			"jakarta.annotation.Nonnull",
+			"jakarta.annotation.Nullable",
 			"javax.annotation.CheckForNull",
 			"javax.annotation.Nonnull",
-			"javax.annotation.Nonnull",
 			"javax.annotation.Nullable",
 //			"javax.validation.constraints.NotNull", // - this should definitely not be included; validation is not about language-level nullity, therefore should not be in this core list.
 			"libcore.util.NonNull",

File: test/transform/resource/after-delombok/NonNullOnRecordExistingConstructor.java
Patch:
@@ -1,7 +1,7 @@
 // version 16:
 import lombok.NonNull;
-record NonNullOnRecord2(@NonNull String a) {
-	public NonNullOnRecord2 {
+public record NonNullOnRecordExistingConstructor(@NonNull String a) {
+	public NonNullOnRecordExistingConstructor {
 		if (a == null) {
 			throw new java.lang.NullPointerException("a is marked non-null but is null");
 		}

File: test/transform/resource/after-delombok/NonNullOnRecordExistingSetter.java
Patch:
@@ -1,7 +1,7 @@
 // version 14:
 import lombok.NonNull;
-public record NonNullOnRecord3(@NonNull String a) {
-	public NonNullOnRecord3(String a) {
+public record NonNullOnRecordExistingSetter(@NonNull String a) {
+	public NonNullOnRecordExistingSetter(String a) {
 		this.a = a;
 	}
 	public void method(@NonNull String param) {

File: test/transform/resource/after-delombok/NonNullOnRecordSimple.java
Patch:
@@ -1,8 +1,8 @@
 // version 16:
 import lombok.NonNull;
-public record NonNullOnRecord(@NonNull String a, @NonNull String b) {
+public record NonNullOnRecordSimple(@NonNull String a, @NonNull String b) {
 	@java.lang.SuppressWarnings("all")
-	public NonNullOnRecord {
+	public NonNullOnRecordSimple {
 		if (a == null) {
 			throw new java.lang.NullPointerException("a is marked non-null but is null");
 		}

File: test/transform/resource/after-ecj/NonNullOnRecordExistingConstructor.java
Patch:
@@ -1,8 +1,8 @@
 // version 14:
 import lombok.NonNull;
-record NonNullOnRecord2(String a) {
+public record NonNullOnRecordExistingConstructor(String a) {
 /* Implicit */  private final String a;
-  public NonNullOnRecord2(@NonNull String a) {
+  public NonNullOnRecordExistingConstructor(@NonNull String a) {
     super();
     if ((a == null))
         {

File: test/transform/resource/after-ecj/NonNullOnRecordExistingSetter.java
Patch:
@@ -1,8 +1,8 @@
 // version 19:
 import lombok.NonNull;
-public record NonNullOnRecord3(String a) {
+public record NonNullOnRecordExistingSetter(String a) {
 /* Implicit */  private final String a;
-  public NonNullOnRecord3(String a) {
+  public NonNullOnRecordExistingSetter(String a) {
     super();
     this.a = a;
   }

File: test/transform/resource/after-ecj/NonNullOnRecordSimple.java
Patch:
@@ -1,9 +1,9 @@
 // version 14:
 import lombok.NonNull;
-public record NonNullOnRecord(String a, String b) {
+public record NonNullOnRecordSimple(String a, String b) {
 /* Implicit */  private final String a;
 /* Implicit */  private final String b;
-  public @java.lang.SuppressWarnings("all") NonNullOnRecord(@NonNull String a, @NonNull String b) {
+  public @java.lang.SuppressWarnings("all") NonNullOnRecordSimple(@NonNull String a, @NonNull String b) {
     super();
     if ((a == null))
         {

File: test/transform/resource/before/NonNullOnRecordExistingSetter.java
Patch:
@@ -2,8 +2,8 @@
 
 import lombok.NonNull;
 
-public record NonNullOnRecord3(@NonNull String a) {
-	public NonNullOnRecord3(String a) {
+public record NonNullOnRecordExistingSetter(@NonNull String a) {
+	public NonNullOnRecordExistingSetter(String a) {
 		this.a = a;
 	}
 	

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -1,9 +1,9 @@
 // version 19:
 import lombok.extern.flogger.Flogger;
 class LoggerFloggerRecord {
-  public @Flogger record Inner(com log) {
-    private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
+  public @Flogger record Inner(String x) {
 /* Implicit */    private final String x;
+    private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
     <clinit>() {
     }
     public Inner(String x) {

File: test/transform/resource/after-ecj/LoggerSlf4jOnRecord.java
Patch:
@@ -1,9 +1,9 @@
 // version 14:
 import lombok.extern.slf4j.Slf4j;
-public @Slf4j record LoggerSlf4jOnRecord(org log, String a) {
-  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jOnRecord.class);
+public @Slf4j record LoggerSlf4jOnRecord(String a, String b) {
 /* Implicit */  private final String a;
 /* Implicit */  private final String b;
+  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jOnRecord.class);
   <clinit>() {
   }
   public LoggerSlf4jOnRecord(String a, String b) {

File: test/transform/resource/after-ecj/SynchronizedInRecord.java
Patch:
@@ -1,8 +1,8 @@
 import lombok.Synchronized;
-public record SynchronizedInRecord(java $lock, String a) {
-  private final java.lang.Object $lock = new java.lang.Object[0];
+public record SynchronizedInRecord(String a, String b) {
 /* Implicit */  private final String a;
 /* Implicit */  private final String b;
+  private final java.lang.Object $lock = new java.lang.Object[0];
   public SynchronizedInRecord(String a, String b) {
     super();
     .a = a;

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -140,7 +140,7 @@ public static int primeForNull() {
 			"androidx.annotation.RecentlyNullable",
 			"com.android.annotations.NonNull",
 			"com.android.annotations.Nullable",
-			// "com.google.api.server.spi.config.Nullable", - let's think about this one a litte, as it is targeted solely at parameters, so you can't even put it on fields. If we choose to support it, we should REMOVE it from the field, then - that's not something we currently support.
+			// "com.google.api.server.spi.config.Nullable", - let's think about this one a little, as it is targeted solely at parameters, so you can't even put it on fields. If we choose to support it, we should REMOVE it from the field, then - that's not something we currently support.
 			"com.google.firebase.database.annotations.NotNull",
 			"com.google.firebase.database.annotations.Nullable",
 			"com.mongodb.lang.NonNull",
@@ -197,7 +197,7 @@ public static int primeForNull() {
 			// Checker Framework annotations.
 			// To update Checker Framework annotations, run:
 			// grep --recursive --files-with-matches -e '^@Target\b.*TYPE_USE' $CHECKERFRAMEWORK/checker/src/main/java $CHECKERFRAMEWORK/checker-qual/src/main/java $CHECKERFRAMEWORK/checker-util/src/main/java $CHECKERFRAMEWORK/framework/src/main/java | grep '\.java$' | sed 's/.*\/java\//\t\t\t"/' | sed 's/\.java$/",/' | sed 's/\//./g' | sort
-			// Only add new annotations, do not remove annotations that have been removed from the lastest version of the Checker Framework.
+			// Only add new annotations, do not remove annotations that have been removed from the latest version of the Checker Framework.
 			"org.checkerframework.checker.builder.qual.CalledMethods",
 			"org.checkerframework.checker.builder.qual.NotCalledMethods",
 			"org.checkerframework.checker.calledmethods.qual.CalledMethods",

File: src/core/lombok/eclipse/handlers/HandleExtensionMethod.java
Patch:
@@ -50,10 +50,10 @@ public class HandleExtensionMethod extends EclipseAnnotationHandler<ExtensionMet
 		int modifiers = typeDecl == null ? 0 : typeDecl.modifiers;
 		
 		boolean notAClass = (modifiers &
-				(ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation)) != 0;
+				(ClassFileConstants.AccAnnotation)) != 0;
 		
 		if (typeDecl == null || notAClass) {
-			annotationNode.addError("@ExtensionMethod is legal only on classes and enums.");
+			annotationNode.addError("@ExtensionMethod is legal only on classes and enums and interfaces.");
 			return;
 		}
 		

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -73,10 +73,10 @@ public void handle(final AnnotationValues<ExtensionMethod> annotation, final JCA
 		
 		deleteAnnotationIfNeccessary(annotationNode, ExtensionMethod.class);
 		JavacNode typeNode = annotationNode.up();
-		boolean isClassOrEnum = isClassOrEnum(typeNode);
+		boolean isClassOrEnumOrInterface = isClassOrEnumOrInterface(typeNode);
 		
-		if (!isClassOrEnum) {
-			annotationNode.addError("@ExtensionMethod can only be used on a class or an enum");
+		if (!isClassOrEnumOrInterface) {
+			annotationNode.addError("@ExtensionMethod can only be used on a class or an enum or an interface");
 			return;
 		}
 		

File: src/core/lombok/Builder.java
Patch:
@@ -160,7 +160,7 @@
 	 * For example, a method normally generated as {@code someField(String someField)} would instead be
 	 * generated as {@code withSomeField(String someField)} if using {@code @Builder(setterPrefix = "with")}.
 	 *
-	 * Note that using "with" to prefix builder setter methods is strongly discouraged as as "with" normally
+	 * Note that using "with" to prefix builder setter methods is strongly discouraged as "with" normally
 	 * suggests immutable data structures, and builders by definition are mutable objects.
 	 * 
 	 * For {@code @Singular} fields, the generated methods are called {@code withName}, {@code withNames}, and {@code clearNames}, instead of

File: src/core/lombok/NoArgsConstructor.java
Patch:
@@ -75,7 +75,7 @@
 	 * If {@code true}, initializes all final fields to 0 / null / false.
 	 * Otherwise, a compile time error occurs.
 	 * 
-	 * @return Return {@code} true to force generation of a no-args constructor, picking defaults if necessary to assign required fields.
+	 * @return {@code} true to force generation of a no-args constructor, picking defaults if necessary to assign required fields.
 	 */
 	boolean force() default false;
 	

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -160,7 +160,7 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
-		// Do not apply field defaults to records if set using the the config system
+		// Do not apply field defaults to records if set using the config system
 		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;

File: src/core/lombok/experimental/SuperBuilder.java
Patch:
@@ -69,7 +69,7 @@
 	 * For example, a method normally generated as {@code someField(String someField)} would instead be
 	 * generated as {@code withSomeField(String someField)} if using {@code @SuperBuilder(setterPrefix = "with")}.
 	 *
-	 * Note that using "with" to prefix builder setter methods is strongly discouraged as as "with" normally
+	 * Note that using "with" to prefix builder setter methods is strongly discouraged as "with" normally
 	 * suggests immutable data structures, and builders by definition are mutable objects.
 	 * 
 	 * For {@code @Singular} fields, the generated methods are called {@code withName}, {@code withNames}, and {@code clearNames}, instead of

File: src/core/lombok/extern/jackson/Jacksonized.java
Patch:
@@ -49,7 +49,7 @@
  * <li>Insert {@code @JsonPOJOBuilder(withPrefix="")} on the generated builder
  * class to override Jackson's default prefix "with". If you configured a
  * different prefix in lombok using {@code setterPrefix}, this value is used. If
- * you changed the name of the {@code build()} method using using
+ * you changed the name of the {@code build()} method using
  * {@code buildMethodName}, this is also made known to Jackson.</li>
  * <li>For {@code @SuperBuilder}, make the builder implementation class
  * package-private.</li>

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -140,7 +140,7 @@ public void setFieldDefaultsForField(JavacNode fieldNode, AccessLevel level, boo
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
-		// Do not apply field defaults to records if set using the the config system
+		// Do not apply field defaults to records if set using the config system
 		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;

File: test/transform/resource/after-ecj/BuilderCustomName.java
Patch:
@@ -5,15 +5,15 @@
     public SimpleTestBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
     public @java.lang.SuppressWarnings("all") B field(final int field) {
       this.field = field;
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderCustomName.SimpleTestBuilder(field=" + this.field) + ")");
     }

File: test/transform/resource/after-ecj/ConstructorsWithSuperBuilderDefaults.java
Patch:
@@ -10,8 +10,6 @@
     public ConstructorsWithSuperBuilderDefaultsBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
@@ -27,6 +25,8 @@ public ConstructorsWithSuperBuilderDefaultsBuilder() {
       this.y = y;
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((("ConstructorsWithSuperBuilderDefaults.ConstructorsWithSuperBuilderDefaultsBuilder(x$value=" + this.x$value) + ", y=") + this.y) + ")");
     }

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderSimple.java
Patch:
@@ -5,15 +5,15 @@ public class JacksonizedSuperBuilderSimple {
       public ParentBuilder() {
         super();
       }
-      protected abstract @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.SuppressWarnings("all") C build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B field1(final int field1) {
         this.field1 = field1;
         return self();
       }
+      protected abstract @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.SuppressWarnings("all") C build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (("JacksonizedSuperBuilderSimple.Parent.ParentBuilder(field1=" + this.field1) + ")");
       }

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -4,15 +4,15 @@
     public JacksonizedSuperBuilderWithJsonDeserializeBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
     public @java.lang.SuppressWarnings("all") B field1(final int field1) {
       this.field1 = field1;
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("JacksonizedSuperBuilderWithJsonDeserialize.JacksonizedSuperBuilderWithJsonDeserializeBuilder(field1=" + this.field1) + ")");
     }

File: test/transform/resource/after-ecj/SuperBuilderCustomized.java
Patch:
@@ -60,15 +60,15 @@ private ChildBuilderImpl() {
       public ChildBuilder() {
         super();
       }
-      protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B field2(final double field2) {
         this.field2 = field2;
         return self();
       }
+      protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (((("SuperBuilderCustomized.Child.ChildBuilder(super=" + super.toString()) + ", field2=") + this.field2) + ")");
       }

File: test/transform/resource/after-ecj/SuperBuilderInitializer.java
Patch:
@@ -6,15 +6,15 @@ class SuperBuilderInitializer {
       public OneBuilder() {
         super();
       }
-      protected abstract @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.SuppressWarnings("all") C build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B world(final String world) {
         this.world = world;
         return self();
       }
+      protected abstract @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.SuppressWarnings("all") C build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (("SuperBuilderInitializer.One.OneBuilder(world=" + this.world) + ")");
       }

File: test/transform/resource/after-ecj/SuperBuilderNameClashes.java
Patch:
@@ -68,15 +68,15 @@ public C2() {
       public CBuilder() {
         super();
       }
-      protected abstract @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.SuppressWarnings("all") C3 build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B c2(final C2 c2) {
         this.c2 = c2;
         return self();
       }
+      protected abstract @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.SuppressWarnings("all") C3 build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (("SuperBuilderNameClashes.C.CBuilder(c2=" + this.c2) + ")");
       }

File: test/transform/resource/after-ecj/SuperBuilderSingularAnnotatedTypes.java
Patch:
@@ -14,8 +14,6 @@
     public SuperBuilderSingularAnnotatedTypesBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.SuppressWarnings("all") B foo(final @MyAnnotation @NonNull String foo) {
       if ((foo == null))
           {
@@ -84,6 +82,8 @@ public SuperBuilderSingularAnnotatedTypesBuilder() {
           }
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("SuperBuilderSingularAnnotatedTypes.SuperBuilderSingularAnnotatedTypesBuilder(foos=" + this.foos) + ", bars$key=") + this.bars$key) + ", bars$value=") + this.bars$value) + ")");
     }

File: test/transform/resource/after-ecj/SuperBuilderSingularCustomized.java
Patch:
@@ -8,8 +8,6 @@ public SuperBuilderSingularCustomizedBuilder() {
     public B custom(final String value) {
       return self();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.SuppressWarnings("all") B foo(final String foo) {
       if ((this.foos == null))
           this.foos = new java.util.ArrayList<String>();
@@ -31,6 +29,8 @@ public B custom(final String value) {
           this.foos.clear();
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("SuperBuilderSingularCustomized.SuperBuilderSingularCustomizedBuilder(foos=" + this.foos) + ")");
     }

File: test/transform/resource/after-ecj/SuperBuilderWithPrefixes.java
Patch:
@@ -6,8 +6,6 @@
     public SuperBuilderWithPrefixesBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
@@ -43,6 +41,8 @@ public SuperBuilderWithPrefixesBuilder() {
           this.items.clear();
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("SuperBuilderWithPrefixes.SuperBuilderWithPrefixesBuilder(field=" + this.field) + ", otherField=") + this.otherField) + ", items=") + this.items) + ")");
     }

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -1,7 +1,7 @@
-// version 14:
+// version 19:
 import lombok.extern.flogger.Flogger;
 class LoggerFloggerRecord {
-  public static @Flogger record Inner(com log) {
+  public @Flogger record Inner(com log) {
     private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
 /* Implicit */    private final String x;
     <clinit>() {

File: test/transform/resource/after-ecj/LoggerFloggerRecord.java
Patch:
@@ -1,7 +1,7 @@
-// version 14:
+// version 19:
 import lombok.extern.flogger.Flogger;
 class LoggerFloggerRecord {
-  public static @Flogger record Inner(com log) {
+  public @Flogger record Inner(com log) {
     private static final com.google.common.flogger.FluentLogger log = com.google.common.flogger.FluentLogger.forEnclosingClass();
 /* Implicit */    private final String x;
     <clinit>() {

File: src/stubs/com/sun/tools/javac/code/Symbol.java
Patch:
@@ -25,6 +25,7 @@ public abstract class Symbol implements Element {
 	public Type type;
 	public Name name;
 	public Symbol owner;
+	public Type erasure_field;
 
 	public long flags() { return 0; }
 	public boolean isStatic() { return false; }

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -117,7 +117,8 @@ public Extension getExtension(final JavacNode typeNode, final ClassType extensio
 		if (tsym != null) for (Symbol member : tsym.getEnclosedElements()) {
 			if (member.getKind() != ElementKind.METHOD) continue;
 			MethodSymbol method = (MethodSymbol) member;
-			if ((method.flags() & (STATIC | PUBLIC)) == 0) continue;
+			if ((method.flags() & STATIC) == 0) continue;
+			if ((method.flags() & PUBLIC) == 0) continue;
 			if (method.params().isEmpty()) continue;
 			extensionMethods.add(method);
 		}

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -140,7 +140,7 @@ public static int primeForNull() {
 			"androidx.annotation.RecentlyNullable",
 			"com.android.annotations.NonNull",
 			"com.android.annotations.Nullable",
-			// "com.google.api.server.spi.config.Nullable", - let's think about this one a litte, as it is targeted solely at parameters, so you can't even put it on fields. If we choose to support it, we should REMOVE it from the field, then - that's not something we currently support.
+			// "com.google.api.server.spi.config.Nullable", - let's think about this one a little, as it is targeted solely at parameters, so you can't even put it on fields. If we choose to support it, we should REMOVE it from the field, then - that's not something we currently support.
 			"com.google.firebase.database.annotations.NotNull",
 			"com.google.firebase.database.annotations.Nullable",
 			"com.mongodb.lang.NonNull",
@@ -197,7 +197,7 @@ public static int primeForNull() {
 			// Checker Framework annotations.
 			// To update Checker Framework annotations, run:
 			// grep --recursive --files-with-matches -e '^@Target\b.*TYPE_USE' $CHECKERFRAMEWORK/checker/src/main/java $CHECKERFRAMEWORK/checker-qual/src/main/java $CHECKERFRAMEWORK/checker-util/src/main/java $CHECKERFRAMEWORK/framework/src/main/java | grep '\.java$' | sed 's/.*\/java\//\t\t\t"/' | sed 's/\.java$/",/' | sed 's/\//./g' | sort
-			// Only add new annotations, do not remove annotations that have been removed from the lastest version of the Checker Framework.
+			// Only add new annotations, do not remove annotations that have been removed from the latest version of the Checker Framework.
 			"org.checkerframework.checker.builder.qual.CalledMethods",
 			"org.checkerframework.checker.builder.qual.NotCalledMethods",
 			"org.checkerframework.checker.calledmethods.qual.CalledMethods",

File: src/core/lombok/eclipse/handlers/HandleExtensionMethod.java
Patch:
@@ -50,10 +50,10 @@ public class HandleExtensionMethod extends EclipseAnnotationHandler<ExtensionMet
 		int modifiers = typeDecl == null ? 0 : typeDecl.modifiers;
 		
 		boolean notAClass = (modifiers &
-				(ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation)) != 0;
+				(ClassFileConstants.AccAnnotation)) != 0;
 		
 		if (typeDecl == null || notAClass) {
-			annotationNode.addError("@ExtensionMethod is legal only on classes and enums.");
+			annotationNode.addError("@ExtensionMethod is legal only on classes and enums and interfaces.");
 			return;
 		}
 		

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -73,10 +73,10 @@ public void handle(final AnnotationValues<ExtensionMethod> annotation, final JCA
 		
 		deleteAnnotationIfNeccessary(annotationNode, ExtensionMethod.class);
 		JavacNode typeNode = annotationNode.up();
-		boolean isClassOrEnum = isClassOrEnum(typeNode);
+		boolean isClassOrEnumOrInterface = isClassOrEnumOrInterface(typeNode);
 		
-		if (!isClassOrEnum) {
-			annotationNode.addError("@ExtensionMethod can only be used on a class or an enum");
+		if (!isClassOrEnumOrInterface) {
+			annotationNode.addError("@ExtensionMethod can only be used on a class or an enum or an interface");
 			return;
 		}
 		

File: src/core/lombok/Builder.java
Patch:
@@ -160,7 +160,7 @@
 	 * For example, a method normally generated as {@code someField(String someField)} would instead be
 	 * generated as {@code withSomeField(String someField)} if using {@code @Builder(setterPrefix = "with")}.
 	 *
-	 * Note that using "with" to prefix builder setter methods is strongly discouraged as as "with" normally
+	 * Note that using "with" to prefix builder setter methods is strongly discouraged as "with" normally
 	 * suggests immutable data structures, and builders by definition are mutable objects.
 	 * 
 	 * For {@code @Singular} fields, the generated methods are called {@code withName}, {@code withNames}, and {@code clearNames}, instead of

File: src/core/lombok/NoArgsConstructor.java
Patch:
@@ -75,7 +75,7 @@
 	 * If {@code true}, initializes all final fields to 0 / null / false.
 	 * Otherwise, a compile time error occurs.
 	 * 
-	 * @return Return {@code} true to force generation of a no-args constructor, picking defaults if necessary to assign required fields.
+	 * @return {@code} true to force generation of a no-args constructor, picking defaults if necessary to assign required fields.
 	 */
 	boolean force() default false;
 	

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -160,7 +160,7 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
-		// Do not apply field defaults to records if set using the the config system
+		// Do not apply field defaults to records if set using the config system
 		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;

File: src/core/lombok/experimental/SuperBuilder.java
Patch:
@@ -69,7 +69,7 @@
 	 * For example, a method normally generated as {@code someField(String someField)} would instead be
 	 * generated as {@code withSomeField(String someField)} if using {@code @SuperBuilder(setterPrefix = "with")}.
 	 *
-	 * Note that using "with" to prefix builder setter methods is strongly discouraged as as "with" normally
+	 * Note that using "with" to prefix builder setter methods is strongly discouraged as "with" normally
 	 * suggests immutable data structures, and builders by definition are mutable objects.
 	 * 
 	 * For {@code @Singular} fields, the generated methods are called {@code withName}, {@code withNames}, and {@code clearNames}, instead of

File: src/core/lombok/extern/jackson/Jacksonized.java
Patch:
@@ -49,7 +49,7 @@
  * <li>Insert {@code @JsonPOJOBuilder(withPrefix="")} on the generated builder
  * class to override Jackson's default prefix "with". If you configured a
  * different prefix in lombok using {@code setterPrefix}, this value is used. If
- * you changed the name of the {@code build()} method using using
+ * you changed the name of the {@code build()} method using
  * {@code buildMethodName}, this is also made known to Jackson.</li>
  * <li>For {@code @SuperBuilder}, make the builder implementation class
  * package-private.</li>

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -140,7 +140,7 @@ public void setFieldDefaultsForField(JavacNode fieldNode, AccessLevel level, boo
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
-		// Do not apply field defaults to records if set using the the config system
+		// Do not apply field defaults to records if set using the config system
 		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;

File: test/transform/resource/after-ecj/BuilderCustomName.java
Patch:
@@ -5,15 +5,15 @@
     public SimpleTestBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
     public @java.lang.SuppressWarnings("all") B field(final int field) {
       this.field = field;
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderCustomName.SimpleTestBuilder(field=" + this.field) + ")");
     }

File: test/transform/resource/after-ecj/ConstructorsWithSuperBuilderDefaults.java
Patch:
@@ -10,8 +10,6 @@
     public ConstructorsWithSuperBuilderDefaultsBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
@@ -27,6 +25,8 @@ public ConstructorsWithSuperBuilderDefaultsBuilder() {
       this.y = y;
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((("ConstructorsWithSuperBuilderDefaults.ConstructorsWithSuperBuilderDefaultsBuilder(x$value=" + this.x$value) + ", y=") + this.y) + ")");
     }

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderSimple.java
Patch:
@@ -5,15 +5,15 @@ public class JacksonizedSuperBuilderSimple {
       public ParentBuilder() {
         super();
       }
-      protected abstract @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.SuppressWarnings("all") C build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B field1(final int field1) {
         this.field1 = field1;
         return self();
       }
+      protected abstract @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.SuppressWarnings("all") C build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (("JacksonizedSuperBuilderSimple.Parent.ParentBuilder(field1=" + this.field1) + ")");
       }

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -4,15 +4,15 @@
     public JacksonizedSuperBuilderWithJsonDeserializeBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
     public @java.lang.SuppressWarnings("all") B field1(final int field1) {
       this.field1 = field1;
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("JacksonizedSuperBuilderWithJsonDeserialize.JacksonizedSuperBuilderWithJsonDeserializeBuilder(field1=" + this.field1) + ")");
     }

File: test/transform/resource/after-ecj/SuperBuilderCustomized.java
Patch:
@@ -60,15 +60,15 @@ private ChildBuilderImpl() {
       public ChildBuilder() {
         super();
       }
-      protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B field2(final double field2) {
         this.field2 = field2;
         return self();
       }
+      protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (((("SuperBuilderCustomized.Child.ChildBuilder(super=" + super.toString()) + ", field2=") + this.field2) + ")");
       }

File: test/transform/resource/after-ecj/SuperBuilderInitializer.java
Patch:
@@ -6,15 +6,15 @@ class SuperBuilderInitializer {
       public OneBuilder() {
         super();
       }
-      protected abstract @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.SuppressWarnings("all") C build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B world(final String world) {
         this.world = world;
         return self();
       }
+      protected abstract @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.SuppressWarnings("all") C build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (("SuperBuilderInitializer.One.OneBuilder(world=" + this.world) + ")");
       }

File: test/transform/resource/after-ecj/SuperBuilderNameClashes.java
Patch:
@@ -68,15 +68,15 @@ public C2() {
       public CBuilder() {
         super();
       }
-      protected abstract @java.lang.SuppressWarnings("all") B self();
-      public abstract @java.lang.SuppressWarnings("all") C3 build();
       /**
        * @return {@code this}.
        */
       public @java.lang.SuppressWarnings("all") B c2(final C2 c2) {
         this.c2 = c2;
         return self();
       }
+      protected abstract @java.lang.SuppressWarnings("all") B self();
+      public abstract @java.lang.SuppressWarnings("all") C3 build();
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (("SuperBuilderNameClashes.C.CBuilder(c2=" + this.c2) + ")");
       }

File: test/transform/resource/after-ecj/SuperBuilderSingularAnnotatedTypes.java
Patch:
@@ -14,8 +14,6 @@
     public SuperBuilderSingularAnnotatedTypesBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.SuppressWarnings("all") B foo(final @MyAnnotation @NonNull String foo) {
       if ((foo == null))
           {
@@ -84,6 +82,8 @@ public SuperBuilderSingularAnnotatedTypesBuilder() {
           }
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("SuperBuilderSingularAnnotatedTypes.SuperBuilderSingularAnnotatedTypesBuilder(foos=" + this.foos) + ", bars$key=") + this.bars$key) + ", bars$value=") + this.bars$value) + ")");
     }

File: test/transform/resource/after-ecj/SuperBuilderSingularCustomized.java
Patch:
@@ -8,8 +8,6 @@ public SuperBuilderSingularCustomizedBuilder() {
     public B custom(final String value) {
       return self();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.SuppressWarnings("all") B foo(final String foo) {
       if ((this.foos == null))
           this.foos = new java.util.ArrayList<String>();
@@ -31,6 +29,8 @@ public B custom(final String value) {
           this.foos.clear();
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("SuperBuilderSingularCustomized.SuperBuilderSingularCustomizedBuilder(foos=" + this.foos) + ")");
     }

File: test/transform/resource/after-ecj/SuperBuilderWithPrefixes.java
Patch:
@@ -6,8 +6,6 @@
     public SuperBuilderWithPrefixesBuilder() {
       super();
     }
-    protected abstract @java.lang.SuppressWarnings("all") B self();
-    public abstract @java.lang.SuppressWarnings("all") C build();
     /**
      * @return {@code this}.
      */
@@ -43,6 +41,8 @@ public SuperBuilderWithPrefixesBuilder() {
           this.items.clear();
       return self();
     }
+    protected abstract @java.lang.SuppressWarnings("all") B self();
+    public abstract @java.lang.SuppressWarnings("all") C build();
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("SuperBuilderWithPrefixes.SuperBuilderWithPrefixesBuilder(field=" + this.field) + ", otherField=") + this.otherField) + ", items=") + this.items) + ")");
     }

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -1063,6 +1063,9 @@ private java.util.HashSet<String> gatherUsedTypeNames(List<JCTypeParameter> type
 	private void addFirstToken(java.util.Set<String> usedNames, JCTree type) {
 		if (type == null) 
 			return;
+		if (type instanceof JCTypeApply) {
+			type = ((JCTypeApply)type).clazz;
+		}
 		while (type instanceof JCFieldAccess && ((JCFieldAccess)type).selected != null) {
 			// Add the first token, because only that can collide.
 			type = ((JCFieldAccess)type).selected;

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -983,7 +983,7 @@ public void generateBuilderFields(BuilderJob job) {
 				}
 				
 				if (field == null) {
-					FieldDeclaration fd = new FieldDeclaration(bfd.builderFieldName, 0, 0);
+					FieldDeclaration fd = new FieldDeclaration(bfd.builderFieldName.clone(), 0, 0);
 					fd.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
 					fd.modifiers = ClassFileConstants.AccPrivate;
 					fd.type = copyType(bfd.type);

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -948,7 +948,7 @@ private void generateBuilderFields(BuilderJob job) {
 				}
 				
 				if (field == null) {
-					FieldDeclaration fd = new FieldDeclaration(bfd.builderFieldName, 0, 0);
+					FieldDeclaration fd = new FieldDeclaration(bfd.builderFieldName.clone(), 0, 0);
 					fd.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
 					fd.modifiers = ClassFileConstants.AccPrivate;
 					fd.type = copyType(bfd.type);

File: test/transform/resource/after-delombok/ExtensionMethodFunctional.java
Patch:
@@ -11,6 +11,7 @@ public void test() {
 		test = ExtensionMethodFunctional.Extensions.map(test, s -> ExtensionMethodFunctional.Extensions.reverse(s));
 		ExtensionMethodFunctional.Extensions.consume(test, s -> System.out.println("1: " + s), s -> System.out.println("2: " + s));
 		ExtensionMethodFunctional.Extensions.consume(test, System.out::println, System.out::println);
+		ExtensionMethodFunctional.Extensions.consume(test, test.length() > 0 ? System.out::println : null);
 		ExtensionMethodFunctional.Extensions.toList1(Stream.of("a", "b", "c").map(String::toUpperCase));
 		List<Integer> i2 = ExtensionMethodFunctional.Extensions.toList2(Stream.of("a", "b", "c").map(String::toUpperCase));
 	}

File: test/transform/resource/after-ecj/ExtensionMethodFunctional.java
Patch:
@@ -36,6 +36,7 @@ public void test() {
     test = ExtensionMethodFunctional.Extensions.map(test, (<no type> s) -> ExtensionMethodFunctional.Extensions.reverse(s));
     ExtensionMethodFunctional.Extensions.consume(test, (<no type> s) -> System.out.println(("1: " + s)), (<no type> s) -> System.out.println(("2: " + s)));
     ExtensionMethodFunctional.Extensions.consume(test, System.out::println, System.out::println);
+    ExtensionMethodFunctional.Extensions.consume(test, ((test.length() > 0) ? System.out::println : null));
     ExtensionMethodFunctional.Extensions.toList1(Stream.of("a", "b", "c").map(String::toUpperCase));
     List<Integer> i2 = ExtensionMethodFunctional.Extensions.toList2(Stream.of("a", "b", "c").map(String::toUpperCase));
   }

File: test/transform/resource/before/ExtensionMethodFunctional.java
Patch:
@@ -16,6 +16,8 @@ public void test() {
 		test.consume(s -> System.out.println("1: " + s), s -> System.out.println("2: " + s));
 		test.consume(System.out::println, System.out::println);
 		
+		test.consume(test.length() > 0 ? System.out::println : null);
+		
 		Stream.of("a", "b", "c").map(String::toUpperCase).toList1();
 		List<Integer> i2 = Stream.of("a", "b", "c").map(String::toUpperCase).toList2();
 	}

File: src/core/lombok/eclipse/handlers/HandleWithBy.java
Patch:
@@ -373,7 +373,7 @@ public MethodDeclaration createWithBy(TypeDeclaration parent, EclipseNode fieldN
 			method.statements = statements.toArray(new Statement[0]);
 		}
 		
-		createRelevantNonNullAnnotation(sourceNode, param);
+		createRelevantNonNullAnnotation(sourceNode, param, method);
 		createRelevantNonNullAnnotation(fieldNode, method);
 		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -207,7 +207,7 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		paramType = addTypeArgs(getTypeArgumentsCount(), true, builderType, paramType, data.getTypeArgs());
 		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
 		
-		nullBehaviorize(builderType, data, statements, param);
+		nullBehaviorize(builderType, data, statements, param, md);
 		
 		if (returnStatement != null) statements.add(returnStatement);
 		

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSetSingularizer.java
Patch:
@@ -184,7 +184,7 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		paramType = addTypeArgs(1, true, builderType, paramType, data.getTypeArgs());
 		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
 		
-		nullBehaviorize(builderType, data, statements, param);
+		nullBehaviorize(builderType, data, statements, param, md);
 		if (returnStatement != null) statements.add(returnStatement);
 		
 		md.statements = statements.toArray(new Statement[0]);

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilMapSingularizer.java
Patch:
@@ -316,7 +316,7 @@ private void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate
 		paramType = addTypeArgs(2, true, builderType, paramType, data.getTypeArgs());
 		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
 		
-		nullBehaviorize(builderType, data, statements, param);
+		nullBehaviorize(builderType, data, statements, param, md);
 		
 		if (returnStatement != null) statements.add(returnStatement);
 		

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -80,7 +80,7 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue
 				return;
 			}
 			
-			if (!typeNode.isEnumType() && useStatic && !isStaticAllowed(typeNode)) {
+			if (useStatic && !isStaticAllowed(typeNode)) {
 				annotationNode.addError(framework.getAnnotationAsString() + " is not supported on non-static nested classes.");
 				return;
 			}

File: test/transform/resource/before/LoggerFlogger.java
Patch:
@@ -25,4 +25,4 @@ class LoggerFloggerWithInnerEnum {
 	enum Inner {
 		CONSTANT;
 	}
-}
\ No newline at end of file
+}

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -80,7 +80,7 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue
 				return;
 			}
 			
-			if (useStatic && !isStaticAllowed(typeNode)) {
+			if (!typeNode.isEnumType() && useStatic && !isStaticAllowed(typeNode)) {
 				annotationNode.addError(framework.getAnnotationAsString() + " is not supported on non-static nested classes.");
 				return;
 			}

File: src/core/lombok/eclipse/handlers/HandleWithBy.java
Patch:
@@ -373,7 +373,7 @@ public MethodDeclaration createWithBy(TypeDeclaration parent, EclipseNode fieldN
 			method.statements = statements.toArray(new Statement[0]);
 		}
 		
-		createRelevantNonNullAnnotation(sourceNode, param);
+		createRelevantNonNullAnnotation(sourceNode, param, method);
 		createRelevantNonNullAnnotation(fieldNode, method);
 		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -207,7 +207,7 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		paramType = addTypeArgs(getTypeArgumentsCount(), true, builderType, paramType, data.getTypeArgs());
 		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
 		
-		nullBehaviorize(builderType, data, statements, param);
+		nullBehaviorize(builderType, data, statements, param, md);
 		
 		if (returnStatement != null) statements.add(returnStatement);
 		

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSetSingularizer.java
Patch:
@@ -184,7 +184,7 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		paramType = addTypeArgs(1, true, builderType, paramType, data.getTypeArgs());
 		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
 		
-		nullBehaviorize(builderType, data, statements, param);
+		nullBehaviorize(builderType, data, statements, param, md);
 		if (returnStatement != null) statements.add(returnStatement);
 		
 		md.statements = statements.toArray(new Statement[0]);

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilMapSingularizer.java
Patch:
@@ -316,7 +316,7 @@ private void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate
 		paramType = addTypeArgs(2, true, builderType, paramType, data.getTypeArgs());
 		Argument param = new Argument(data.getPluralName(), 0, paramType, ClassFileConstants.AccFinal);
 		
-		nullBehaviorize(builderType, data, statements, param);
+		nullBehaviorize(builderType, data, statements, param, md);
 		
 		if (returnStatement != null) statements.add(returnStatement);
 		

File: src/utils/lombok/eclipse/Eclipse.java
Patch:
@@ -66,6 +66,7 @@ public class Eclipse {
 	public static final int AccRecord = ASTNode.Bit25; // ECM.AccRecord
 	public static final int IsCanonicalConstructor = ASTNode.Bit10; // ASTNode.IsCanonicalConstructor
 	public static final int IsImplicit = ASTNode.Bit11; // ASTNode.IsImplicit
+	public static final int HasTypeAnnotations = ASTNode.Bit21; // ASTNode.HasTypeAnnotations
 	
 	private static final Pattern SPLIT_AT_DOT = Pattern.compile("\\.");
 	

File: src/utils/lombok/eclipse/Eclipse.java
Patch:
@@ -66,6 +66,7 @@ public class Eclipse {
 	public static final int AccRecord = ASTNode.Bit25; // ECM.AccRecord
 	public static final int IsCanonicalConstructor = ASTNode.Bit10; // ASTNode.IsCanonicalConstructor
 	public static final int IsImplicit = ASTNode.Bit11; // ASTNode.IsImplicit
+	public static final int HasTypeAnnotations = ASTNode.Bit21; // ASTNode.HasTypeAnnotations
 	
 	private static final Pattern SPLIT_AT_DOT = Pattern.compile("\\.");
 	

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -80,7 +80,7 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue
 				return;
 			}
 			
-			if (useStatic && !isStaticAllowed(typeNode)) {
+			if (!typeNode.isEnumType() && useStatic && !isStaticAllowed(typeNode)) {
 				annotationNode.addError(framework.getAnnotationAsString() + " is not supported on non-static nested classes.");
 				return;
 			}

File: src/core/lombok/javac/handlers/HandleBuilderDefaultRemove.java
Patch:
@@ -40,5 +40,6 @@
 public class HandleBuilderDefaultRemove extends JavacAnnotationHandler<Builder.Default> {
 	@Override public void handle(AnnotationValues<Default> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		deleteAnnotationIfNeccessary(annotationNode, Builder.Default.class);
+		deleteImportFromCompilationUnit(annotationNode, Builder.class.getName());
 	}
 }

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -177,7 +177,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 		boolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation("lombok.experimental.Value", parent));
 		for (JavacNode fieldNode : HandleConstructor.findAllFields(parent, true)) {
 			JCVariableDecl fd = (JCVariableDecl) fieldNode.get();
-			JavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, true);
+			JavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, false);
 			boolean isFinal = (fd.mods.flags & Flags.FINAL) != 0 || (valuePresent && !hasAnnotation(NonFinal.class, fieldNode));
 			BuilderFieldData bfd = new BuilderFieldData();
 			bfd.rawName = fd.name;
@@ -190,11 +190,13 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 			
 			if (bfd.singularData != null && isDefault != null) {
 				isDefault.addError("@Builder.Default and @Singular cannot be mixed.");
+				findAnnotation(Builder.Default.class, fieldNode, true);
 				isDefault = null;
 			}
 			
 			if (fd.init == null && isDefault != null) {
 				isDefault.addWarning("@Builder.Default requires an initializing expression (' = something;').");
+				findAnnotation(Builder.Default.class, fieldNode, true);
 				isDefault = null;
 			}
 			

File: test/transform/resource/after-delombok/SuperBuilderWithDefaultsAndTargetTyping.java
Patch:
@@ -1,5 +1,4 @@
 import java.util.Arrays;
-import lombok.Builder;
 
 public class SuperBuilderWithDefaultsAndTargetTyping {
 

File: src/core/lombok/core/configuration/ConfigurationFile.java
Patch:
@@ -39,7 +39,7 @@
 public abstract class ConfigurationFile {
 	private static final Pattern VARIABLE = Pattern.compile("\\<(.+?)\\>");
 	private static final String LOMBOK_CONFIG_FILENAME = "lombok.config";
-	private static final Map<String, String> ENV = new HashMap<String, String>(System.getenv());;
+	private static final Map<String, String> ENV = new HashMap<String, String>(System.getenv());
 	
 	private static final ThreadLocal<byte[]> buffers = new ThreadLocal<byte[]>() {
 		protected byte[] initialValue() {
@@ -178,7 +178,7 @@ CharSequence contents() throws IOException {
 		}
 		
 		private static String replaceEnvironmentVariables(String fileName) {
-			int start = 0;;
+			int start = 0;
 			StringBuffer result = new StringBuffer();
 			if (fileName.startsWith("~")) {
 				start = 1;
@@ -331,4 +331,4 @@ private CharSequenceConfigurationFile(String identifier, CharSequence contents,
 			return null;
 		}
 	}
-}
\ No newline at end of file
+}

File: src/core/lombok/eclipse/handlers/HandleToString.java
Patch:
@@ -203,7 +203,7 @@ public static MethodDeclaration createToString(EclipseNode type, Collection<Incl
 			
 			if (!prefix.isEmpty()) {
 				StringLiteral px = new StringLiteral(prefix.toCharArray(), pS, pE, 0);
-				setGeneratedBy(px, source);				
+				setGeneratedBy(px, source);
 				current = new BinaryExpression(current, px, PLUS);
 				current.sourceStart = pS; current.sourceEnd = pE;
 				setGeneratedBy(current, source);

File: src/core/lombok/javac/HandlerLibrary.java
Patch:
@@ -104,13 +104,13 @@ private static class AnnotationHandlerContainer<T extends Annotation> {
 			this.handler = handler;
 			this.annotationClass = annotationClass;
 			HandlerPriority hp = handler.getClass().getAnnotation(HandlerPriority.class);
-			this.priority = hp == null ? 0L : (((long)hp.value()) << 32) + hp.subValue();
+			this.priority = hp == null ? 0L : (((long) hp.value()) << 32) + hp.subValue();
 			this.resolutionResetNeeded = handler.getClass().isAnnotationPresent(ResolutionResetNeeded.class);
 			this.evenIfAlreadyHandled = handler.getClass().isAnnotationPresent(AlreadyHandledAnnotations.class);
 		}
 		
 		public void handle(final JavacNode node) {
-			handler.handle(JavacHandlerUtil.createAnnotation(annotationClass, node), (JCAnnotation)node.get(), node);
+			handler.handle(JavacHandlerUtil.createAnnotation(annotationClass, node), (JCAnnotation) node.get(), node);
 		}
 		
 		public long getPriority() {

File: src/core/lombok/core/configuration/CheckerFrameworkVersion.java
Patch:
@@ -56,11 +56,11 @@ public boolean generatePure() {
 	}
 	
 	public boolean generateReturnsReceiver() {
-		return version > 3999;
+		return version >= 3100;
 	}
 	
 	public boolean generateCalledMethods() {
-		return version > 3999;
+		return version >= 3100;
 	}
 	
 	public static CheckerFrameworkVersion valueOf(String versionString) {

File: test/stubs/org/checkerframework/common/returnsreceiver/qual/This.java
Patch:
@@ -1,12 +1,10 @@
 package org.checkerframework.common.returnsreceiver.qual;
 
 import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
-@Inherited
+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
 public @interface This {}
\ No newline at end of file

File: test/transform/resource/after-delombok/CheckerFrameworkBasic.java
Patch:
@@ -1,3 +1,4 @@
+// skip-idempotent
 //version 8:
 class CheckerFrameworkBasic {
 	private final int x;
@@ -21,9 +22,8 @@ public int getZ() {
 	/**
 	 * @return {@code this}.
 	 */
-	@org.checkerframework.common.returnsreceiver.qual.This
 	@java.lang.SuppressWarnings("all")
-	public CheckerFrameworkBasic setZ(final int z) {
+	public @org.checkerframework.common.returnsreceiver.qual.This CheckerFrameworkBasic setZ(final int z) {
 		this.z = z;
 		return this;
 	}

File: test/transform/resource/after-ecj/CheckerFrameworkBasic.java
Patch:
@@ -24,7 +24,7 @@
   /**
    * @return {@code this}.
    */
-  public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBasic setZ(final int z) {
+  public @java.lang.SuppressWarnings("all") @org.checkerframework.common.returnsreceiver.qual.This CheckerFrameworkBasic setZ(final int z) {
     this.z = z;
     return this;
   }

File: src/core/lombok/core/configuration/CheckerFrameworkVersion.java
Patch:
@@ -33,7 +33,6 @@ public final class CheckerFrameworkVersion implements ConfigurationValueType {
 	public static final String NAME__PURE = "org.checkerframework.dataflow.qual.Pure";
 	public static final String NAME__UNIQUE = "org.checkerframework.common.aliasing.qual.Unique";
 	public static final String NAME__RETURNS_RECEIVER = "org.checkerframework.common.returnsreceiver.qual.This";
-	public static final String NAME__NOT_CALLED = "org.checkerframework.checker.calledmethods.qual.NotCalledMethods";
 	public static final String NAME__CALLED = "org.checkerframework.checker.calledmethods.qual.CalledMethods";
 	
 	public static final CheckerFrameworkVersion NONE = new CheckerFrameworkVersion(0);

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -1019,7 +1019,6 @@ private void generateSimpleSetterMethodForBuilder(BuilderJob job, boolean deprec
 		}
 		MethodDeclaration setter = HandleSetter.createSetter(td, deprecate, fieldNode, setterName, paramName, nameOfSetFlag, returnType, returnStatement, ClassFileConstants.AccPublic,
 			job.sourceNode, methodAnnsList, annosOnParam != null ? Arrays.asList(copyAnnotations(job.source, annosOnParam)) : Collections.<Annotation>emptyList());
-		if (job.checkerFramework.generateCalledMethods()) setter.receiver = generateNotCalledReceiver(job, setterName);
 		injectMethod(job.builderType, setter);
 	}
 	

File: test/transform/resource/after-delombok/CheckerFrameworkBuilder.java
Patch:
@@ -36,7 +36,7 @@ public static class CheckerFrameworkBuilderBuilder {
 		 */
 		@org.checkerframework.common.returnsreceiver.qual.This
 		@java.lang.SuppressWarnings("all")
-		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder x(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.NotCalledMethods("x") CheckerFrameworkBuilderBuilder this, final int x) {
+		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder x(final int x) {
 			this.x$value = x;
 			x$set = true;
 			return this;
@@ -46,7 +46,7 @@ public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder x(CheckerFramework
 		 */
 		@org.checkerframework.common.returnsreceiver.qual.This
 		@java.lang.SuppressWarnings("all")
-		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder y(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.NotCalledMethods("y") CheckerFrameworkBuilderBuilder this, final int y) {
+		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder y(final int y) {
 			this.y = y;
 			return this;
 		}
@@ -55,7 +55,7 @@ public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder y(CheckerFramework
 		 */
 		@org.checkerframework.common.returnsreceiver.qual.This
 		@java.lang.SuppressWarnings("all")
-		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder z(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.NotCalledMethods("z") CheckerFrameworkBuilderBuilder this, final int z) {
+		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder z(final int z) {
 			this.z = z;
 			return this;
 		}

File: test/transform/resource/after-ecj/CheckerFrameworkBuilder.java
Patch:
@@ -14,22 +14,22 @@
     /**
      * @return {@code this}.
      */
-    public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder x(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.NotCalledMethods("x") CheckerFrameworkBuilderBuilder this, final int x) {
+    public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder x(final int x) {
       this.x$value = x;
       x$set = true;
       return this;
     }
     /**
      * @return {@code this}.
      */
-    public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder y(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.NotCalledMethods("y") CheckerFrameworkBuilderBuilder this, final int y) {
+    public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder y(final int y) {
       this.y = y;
       return this;
     }
     /**
      * @return {@code this}.
      */
-    public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder z(CheckerFrameworkBuilder.@org.checkerframework.checker.calledmethods.qual.NotCalledMethods("z") CheckerFrameworkBuilderBuilder this, final int z) {
+    public @org.checkerframework.common.returnsreceiver.qual.This @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder z(final int z) {
       this.z = z;
       return this;
     }

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -93,7 +93,7 @@ protected char[][] makeGuavaTypeName(String simpleName, boolean addBuilder) {
 	}
 	
 	@Override protected char[][] getEmptyMakerReceiver(String targetFqn) {
-		return CGCC;
+		return makeGuavaTypeName(GuavaTypeMap.getGuavaTypeName(targetFqn), false);
 	}
 	
 	@Override public List<EclipseNode> generateFields(SingularData data, EclipseNode builderType) {

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -52,7 +52,7 @@ protected String getSimpleTargetTypeName(SingularData data) {
 	}
 	
 	@Override protected String getEmptyMaker(String target) {
-		return target + ".of";
+		return "com.google.common.collect." + GuavaTypeMap.getGuavaTypeName(target) + ".of";
 	}
 	
 	protected String getBuilderMethodName(SingularData data) {

File: src/core/lombok/core/configuration/ConfigurationApp.java
Patch:
@@ -232,6 +232,7 @@ public int display(Collection<ConfigurationKey<?>> keys, boolean verbose, Collec
 		if (!problems.isEmpty()) {
 			err.printf("Problems in the configuration files:%n");
 			for (String problem : problems) err.printf("- %s%n", problem);
+			return 2;
 		}
 		
 		return 0;

File: test/configuration/src/lombok/core/configuration/TestConfiguration.java
Patch:
@@ -70,7 +70,7 @@ public void testDisplayVerbose() throws Exception {
 		
 		checkContent(directory, out, "out");
 		checkContent(directory, err, "err");
-		assertEquals(0, result);
+		assertEquals(2, result);
 	}
 
 	private void checkContent(File dir, String actual, String type) throws Exception {

File: src/eclipseAgent/lombok/eclipse/agent/PatchVal.java
Patch:
@@ -359,7 +359,8 @@ private static Annotation[] addValAnnotation(Annotation[] originals, TypeReferen
 			newAnn = new Annotation[1];
 		}
 		
-		newAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(originalRef, originalRef.sourceStart);
+		TypeReference qualifiedTypeRef = generateQualifiedTypeRef(originalRef, originalRef.getTypeName());
+		newAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(qualifiedTypeRef, qualifiedTypeRef.sourceStart);
 		
 		return newAnn;
 	}

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -208,8 +208,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 				bfd.nameOfDefaultProvider = parent.toName(DEFAULT_PREFIX + bfd.name);
 				bfd.nameOfSetFlag = parent.toName(bfd.name + SET_PREFIX);
 				bfd.builderFieldName = parent.toName(bfd.name + VALUE_PREFIX);
-				JCMethodDecl md = HandleBuilder.generateDefaultProvider(bfd.nameOfDefaultProvider, fieldNode, td.typarams);
-				recursiveSetGeneratedBy(md, annotationNode);
+				JCMethodDecl md = HandleBuilder.generateDefaultProvider(bfd.nameOfDefaultProvider, fieldNode, td.typarams, job);
 				if (md != null) injectMethod(parent, md);
 			}
 			addObtainVia(bfd, fieldNode);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1820,6 +1820,7 @@ static List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, St
 	private static void clearTypes(JCTree tree) {
 		tree.accept(new TreeScanner() {
 			@Override public void scan(JCTree tree) {
+				if (tree == null) return;
 				tree.type = null;
 				super.scan(tree);
 			}

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -392,6 +392,7 @@ public static int getEndPosition(DiagnosticPosition pos, JCCompilationUnit top)
 	public static void storeEnd(JCTree tree, int pos, JCCompilationUnit top) {
 		try {
 			Object endPositions = JCCOMPILATIONUNIT_ENDPOSITIONS.get(top);
+			if (endPositions == null) return;
 			storeEnd.invoke(endPositions, tree, pos);
 		} catch (IllegalAccessException e) {
 			throw sneakyThrow(e);

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -40,7 +40,6 @@
 public class DirectoryRunner extends Runner {
 	/** Add 1 or more file names to reduce the testset to just the named file(s). No files = test it all. */
 	private static final List<String> DEBUG_FOCUS_ON_FILE = Arrays.asList(
-		"BuilderNestedInEnum.java"
 		);
 	
 	public enum Compiler {

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -40,6 +40,7 @@
 public class DirectoryRunner extends Runner {
 	/** Add 1 or more file names to reduce the testset to just the named file(s). No files = test it all. */
 	private static final List<String> DEBUG_FOCUS_ON_FILE = Arrays.asList(
+		"BuilderNestedInEnum.java"
 		);
 	
 	public enum Compiler {

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -160,6 +160,8 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
+		// Do not apply field defaults to records if set using the the config system
+		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;
 		

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -140,6 +140,8 @@ public void setFieldDefaultsForField(JavacNode fieldNode, AccessLevel level, boo
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
+		// Do not apply field defaults to records if set using the the config system
+		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;
 		

File: test/transform/resource/after-delombok/FieldDefaultsViaConfigOnRecord.java
Patch:
@@ -0,0 +1,3 @@
+// version 14:
+public record FieldDefaultsViaConfigOnRecord(String a, String b) {
+}

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -160,6 +160,8 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
+		// Do not apply field defaults to records if set using the the config system
+		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;
 		

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -140,6 +140,8 @@ public void setFieldDefaultsForField(JavacNode fieldNode, AccessLevel level, boo
 		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
+		// Do not apply field defaults to records if set using the the config system
+		if (fieldDefaults == null && !isClassOrEnum(typeNode)) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;
 		boolean fdToFinal = (fieldDefaults != null && makeFinalIsExplicit) ? fd.makeFinal() : defaultToFinal;
 		

File: test/transform/resource/after-delombok/FieldDefaultsViaConfigOnRecord.java
Patch:
@@ -0,0 +1,3 @@
+// version 14:
+public record FieldDefaultsViaConfigOnRecord(String a, String b) {
+}

File: test/transform/resource/after-ecj/WithWithJavaBeansSpecCapitalization.java
Patch:
@@ -1,4 +1,4 @@
-@lombok.With class WithOnJavaBeansSpecCapitalization {
+@lombok.With class WithWithJavaBeansSpecCapitalization {
   int aField;
   WithWithJavaBeansSpecCapitalization(int aField) {
     super();

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -764,6 +764,7 @@ private static void addPatchesForVal(ScriptManager sm) {
 		
 		sm.addScript(ScriptBuilder.replaceMethodCall()
 				.target(new MethodTarget(LOCALDECLARATION_SIG, "resolve", "void", BLOCKSCOPE_SIG))
+				.target(new MethodTarget(LOCALDECLARATION_SIG, "resolve", "void", BLOCKSCOPE_SIG, "boolean"))
 				.methodToReplace(new Hook(EXPRESSION_SIG, "resolveType", TYPEBINDING_SIG, BLOCKSCOPE_SIG))
 				.requestExtra(StackRequest.THIS)
 				.replacementMethod(new Hook("lombok.launch.PatchFixesHider$Val", "skipResolveInitializerIfAlreadyCalled2", TYPEBINDING_SIG, EXPRESSION_SIG, BLOCKSCOPE_SIG, LOCALDECLARATION_SIG))

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -55,7 +55,8 @@ public enum Compiler {
 		},
 		ECJ {
 			@Override public int getVersion() {
-				return Eclipse.getEcjCompilerVersion();
+				String javaVersionString = System.getProperty("compiler.compliance.level");
+				return javaVersionString != null ? Integer.parseInt(javaVersionString) : Eclipse.getEcjCompilerVersion();
 			}
 		};
 		

File: test/transform/resource/after-ecj/ValErrors.java
Patch:
@@ -4,9 +4,9 @@ public ValErrors() {
     super();
   }
   public void unresolvableExpression() {
-    val c = d;
+    final @val java.lang.Object c = d;
   }
   public void arrayInitializer() {
-    val e = {"foo", "bar"};
+    final @val java.lang.Object e = {"foo", "bar"};
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/WithWithJavaBeansSpecCapitalization.java
Patch:
@@ -1,4 +1,4 @@
-@lombok.With class WithOnJavaBeansSpecCapitalization {
+@lombok.With class WithWithJavaBeansSpecCapitalization {
   int aField;
   WithWithJavaBeansSpecCapitalization(int aField) {
     super();

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -199,6 +199,7 @@ private static void patchSyntaxAndOccurrencesHighlighting(ScriptManager sm) {
 				.target(new MethodTarget("org.eclipse.jdt.internal.ui.search.OccurrencesFinder", "addUsage"))
 				.target(new MethodTarget("org.eclipse.jdt.internal.ui.search.OccurrencesFinder", "addWrite"))
 				.target(new MethodTarget("org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightingReconciler$PositionCollector", "visit", "boolean", "org.eclipse.jdt.core.dom.SimpleName"))
+				.target(new MethodTarget("org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightingReconciler$PositionCollector", "visitLiteral", "boolean", "org.eclipse.jdt.core.dom.Expression"))
 				.decisionMethod(new Hook("lombok.launch.PatchFixesHider$PatchFixes", "isGenerated", "boolean", "org.eclipse.jdt.core.dom.ASTNode"))
 				.valueMethod(new Hook("lombok.launch.PatchFixesHider$PatchFixes", "returnFalse", "boolean", "java.lang.Object"))
 				.request(StackRequest.PARAM1)

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -323,6 +323,7 @@ public static int primeForNull() {
 			"com.fasterxml.jackson.annotation.JsonSetter",
 			"com.fasterxml.jackson.annotation.JsonSubTypes",
 			"com.fasterxml.jackson.annotation.JsonTypeInfo",
+			"com.fasterxml.jackson.annotation.JsonUnwrapped",
 			"com.fasterxml.jackson.annotation.JsonView",
 			"com.fasterxml.jackson.databind.annotation.JsonDeserialize",
 			"com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper",

File: src/installer/lombok/installer/eclipse/StandardProductDescriptor.java
Patch:
@@ -35,6 +35,7 @@
 public class StandardProductDescriptor implements EclipseProductDescriptor {
 	
 	private static final String USER_HOME = System.getProperty("user.home", ".");
+	private static final String[] BASE_WINDOWS_ROOTS = {"\\", "\\Program Files", "\\Program Files (x86)", "\\ProgramData\\Chocolatey\\lib"};
 	private static final String[] WINDOWS_ROOTS = windowsRoots();
 	private static final String[] MAC_ROOTS = {"/Applications", USER_HOME};
 	private static final String[] UNIX_ROOTS = {USER_HOME};
@@ -157,7 +158,6 @@ private static String concat(String base, String pathSeparator, String alternati
 		return base + pathSeparator + alternative.replaceAll("[\\/]", "\\" + pathSeparator);
 	}
 	
-	private static final String[] BASE_WINDOWS_ROOTS = {"\\", "\\Program Files", "\\Program Files (x86)", "\\ProgramData\\Chocolatey\\lib"};
 	private static String[] windowsRoots() {
 		String localAppData = windowsLocalAppData();
 		String[] out = new String[BASE_WINDOWS_ROOTS.length + (localAppData == null ? 1 : 2)];

File: src/eclipseAgent/lombok/launch/PatchFixesHider.java
Patch:
@@ -419,6 +419,7 @@ public static boolean isRefactoringVisitorAndGenerated(org.eclipse.jdt.core.dom.
 			
 			String className = visitor.getClass().getName();
 			if (!(className.startsWith("org.eclipse.jdt.internal.corext.fix") || className.startsWith("org.eclipse.jdt.internal.ui.fix"))) return false;
+			if (className.equals("org.eclipse.jdt.internal.corext.fix.VariableDeclarationFixCore$WrittenNamesFinder")) return false;
 			
 			boolean result = false;
 			try {

File: src/installer/lombok/installer/eclipse/EclipseProductLocation.java
Patch:
@@ -347,8 +347,10 @@ public String install() throws InstallException {
 				pathPrefix = pathToLombokJarPrefix;
 			}
 			
+			// NB: You may be tempted to escape this, but don't; there is no possibility to escape this, but
+			// eclipse/java reads the string following the colon in 'raw' fashion. Spaces, colons - all works fine.
 			newContents.append(String.format(
-					"-javaagent:%s", escapePath(pathPrefix + "lombok.jar"))).append(OS_NEWLINE);
+				"-javaagent:%s", pathPrefix + "lombok.jar")).append(OS_NEWLINE);
 			
 			FileOutputStream fos = new FileOutputStream(eclipseIniPath);
 			try {

File: test/pretty/resource/after/ThisParameter.java
Patch:
@@ -16,17 +16,17 @@ void classTagged(@ClassTagged("class") ThisParameter this) {
 	void runtimeTagged(@RuntimeTagged("runtime") ThisParameter this) {
 		// no content
 	}
-	@Target(ElementType.PARAMETER)
+	@Target(ElementType.TYPE_USE)
 	@Retention(RetentionPolicy.SOURCE)
 	@interface SourceTagged {
 		String value();
 	}
-	@Target(ElementType.PARAMETER)
+	@Target(ElementType.TYPE_USE)
 	@Retention(RetentionPolicy.CLASS)
 	@interface ClassTagged {
 		String value();
 	}
-	@Target(ElementType.PARAMETER)
+	@Target(ElementType.TYPE_USE)
 	@Retention(RetentionPolicy.RUNTIME)
 	@interface RuntimeTagged {
 		String value();

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -99,7 +99,6 @@ private JCMethodDecl createRecordArgslessConstructor(JavacNode typeNode, JavacNo
 			return recursiveSetGeneratedBy(constr, source);
 		} else {
 			existingCtr.mods = mods;
-			existingCtr.params = params.toList();
 			existingCtr.body = body;
 			existingCtr = recursiveSetGeneratedBy(existingCtr, source);
 			addSuppressWarningsAll(existingCtr.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(existingCtr)), typeNode.getContext());

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -43,9 +43,9 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
@@ -733,7 +733,7 @@ public boolean delombok() throws IOException {
 		List<JCCompilationUnit> roots = new ArrayList<JCCompilationUnit>();
 		Map<JCCompilationUnit, File> baseMap = new IdentityHashMap<JCCompilationUnit, File>();
 		
-		Set<AbstractProcessor> processors = new HashSet<AbstractProcessor>();
+		Set<AbstractProcessor> processors = new LinkedHashSet<AbstractProcessor>();
 		processors.add(new lombok.javac.apt.LombokProcessor());
 		processors.addAll(additionalAnnotationProcessors);
 		

File: src/eclipseAgent/lombok/launch/PatchFixesHider.java
Patch:
@@ -419,6 +419,7 @@ public static boolean isRefactoringVisitorAndGenerated(org.eclipse.jdt.core.dom.
 			
 			String className = visitor.getClass().getName();
 			if (!(className.startsWith("org.eclipse.jdt.internal.corext.fix") || className.startsWith("org.eclipse.jdt.internal.ui.fix"))) return false;
+			if (className.equals("org.eclipse.jdt.internal.corext.fix.VariableDeclarationFixCore$WrittenNamesFinder")) return false;
 			
 			boolean result = false;
 			try {

File: src/core/lombok/SneakyThrows.java
Patch:
@@ -39,14 +39,14 @@
  * Example:
  * <pre>
  * &#64;SneakyThrows(UnsupportedEncodingException.class)
- * public void utf8ToString(byte[] bytes) {
+ * public String utf8ToString(byte[] bytes) {
  *     return new String(bytes, "UTF-8");
  * }
  * </pre>
  * 
  * Becomes:
  * <pre>
- * public void utf8ToString(byte[] bytes) {
+ * public String utf8ToString(byte[] bytes) {
  *     try {
  *         return new String(bytes, "UTF-8");
  *     } catch (UnsupportedEncodingException $uniqueName) {

File: test/transform/resource/after-delombok/ConstructorsInAnonymousClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import lombok.NonNull;
 
 public class ConstructorsInAnonymousClass {

File: test/transform/resource/after-delombok/WithByInAnonymousClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 public class WithByInAnonymousClass {
 	Object annonymous = new Object() {
 

File: test/transform/resource/before/ConstructorsInAnonymousClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import lombok.AllArgsConstructor;
 import lombok.NoArgsConstructor;
 import lombok.NonNull;

File: test/transform/resource/before/WithByInAnonymousClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import lombok.experimental.WithBy;
 
 public class WithByInAnonymousClass {

File: src/stubsstubs/com/sun/tools/javac/tree/JCTree.java
Patch:
@@ -2,4 +2,5 @@
 
 public class JCTree {
 	public static class JCCompilationUnit extends JCTree {}
+	public static abstract class Visitor {}
 }

File: src/core/lombok/eclipse/handlers/HandleLog.java
Patch:
@@ -302,7 +302,7 @@ public static class HandleCustomLog extends EclipseAnnotationHandler<lombok.Cust
 			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_CUSTOM_FLAG_USAGE, "@CustomLog", ConfigurationKeys.LOG_ANY_FLAG_USAGE, "any @Log");
 			LogDeclaration logDeclaration = annotationNode.getAst().readConfiguration(ConfigurationKeys.LOG_CUSTOM_DECLARATION);
 			if (logDeclaration == null) {
-				annotationNode.addError("The @CustomLog annotation is not configured; please set log.custom.declaration in lombok.config.");
+				annotationNode.addError("The @CustomLog annotation is not configured; please set lombok.log.custom.declaration in lombok.config.");
 				return;
 			}
 			LoggingFramework framework = new LoggingFramework(lombok.CustomLog.class, logDeclaration);

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -260,7 +260,7 @@ public static class HandleCustomLog extends JavacAnnotationHandler<lombok.Custom
 			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_CUSTOM_FLAG_USAGE, "@CustomLog", ConfigurationKeys.LOG_ANY_FLAG_USAGE, "any @Log");
 			LogDeclaration logDeclaration = annotationNode.getAst().readConfiguration(ConfigurationKeys.LOG_CUSTOM_DECLARATION);
 			if (logDeclaration == null) {
-				annotationNode.addError("The @CustomLog is not configured; please set log.custom.declaration in lombok.config.");
+				annotationNode.addError("The @CustomLog is not configured; please set lombok.log.custom.declaration in lombok.config.");
 				return;
 			}
 			LoggingFramework framework = new LoggingFramework(lombok.CustomLog.class, logDeclaration);

File: src/core/lombok/eclipse/handlers/HandleToString.java
Patch:
@@ -315,7 +315,9 @@ public static String getTypeName(EclipseNode type) {
 		String typeName = getSingleTypeName(type);
 		EclipseNode upType = type.up();
 		while (upType.getKind() == Kind.TYPE) {
-			typeName = getSingleTypeName(upType) + "." + typeName;
+			String upTypeName = getSingleTypeName(upType);
+			if (upTypeName.isEmpty()) break;
+			typeName = upTypeName + "." + typeName;
 			upType = upType.up();
 		}
 		return typeName;

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -385,7 +385,7 @@ public JCExpression createTypeReference(JavacNode type, boolean addWildcards) {
 		boolean staticContext = (((JCClassDecl) type.get()).getModifiers().flags & Flags.STATIC) != 0;
 		JavacNode tNode = type.up();
 		
-		while (tNode != null && tNode.getKind() == Kind.TYPE) {
+		while (tNode != null && tNode.getKind() == Kind.TYPE && !tNode.getName().isEmpty()) {
 			list.add(tNode.getName());
 			if (addWildcards) genericsCount.add(staticContext ? 0 : ((JCClassDecl) tNode.get()).typarams.size());
 			if (!staticContext) staticContext = (((JCClassDecl) tNode.get()).getModifiers().flags & Flags.STATIC) != 0;

File: src/utils/lombok/javac/TreeMirrorMaker.java
Patch:
@@ -109,6 +109,8 @@ public Map<JCTree, JCTree> getOriginalToCopyMap() {
 			if (wipeSymAndType) {
 				copy.sym = null;
 				copy.type = null;
+			} else {
+				if (original.vartype != null) copy.vartype.type = original.vartype.type;
 			}
 		}
 		

File: src/core/lombok/eclipse/handlers/HandleLog.java
Patch:
@@ -302,7 +302,7 @@ public static class HandleCustomLog extends EclipseAnnotationHandler<lombok.Cust
 			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_CUSTOM_FLAG_USAGE, "@CustomLog", ConfigurationKeys.LOG_ANY_FLAG_USAGE, "any @Log");
 			LogDeclaration logDeclaration = annotationNode.getAst().readConfiguration(ConfigurationKeys.LOG_CUSTOM_DECLARATION);
 			if (logDeclaration == null) {
-				annotationNode.addError("The @CustomLog annotation is not configured; please set log.custom.declaration in lombok.config.");
+				annotationNode.addError("The @CustomLog annotation is not configured; please set lombok.log.custom.declaration in lombok.config.");
 				return;
 			}
 			LoggingFramework framework = new LoggingFramework(lombok.CustomLog.class, logDeclaration);

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -260,7 +260,7 @@ public static class HandleCustomLog extends JavacAnnotationHandler<lombok.Custom
 			handleFlagUsage(annotationNode, ConfigurationKeys.LOG_CUSTOM_FLAG_USAGE, "@CustomLog", ConfigurationKeys.LOG_ANY_FLAG_USAGE, "any @Log");
 			LogDeclaration logDeclaration = annotationNode.getAst().readConfiguration(ConfigurationKeys.LOG_CUSTOM_DECLARATION);
 			if (logDeclaration == null) {
-				annotationNode.addError("The @CustomLog is not configured; please set log.custom.declaration in lombok.config.");
+				annotationNode.addError("The @CustomLog is not configured; please set lombok.log.custom.declaration in lombok.config.");
 				return;
 			}
 			LoggingFramework framework = new LoggingFramework(lombok.CustomLog.class, logDeclaration);

File: src/core/lombok/javac/handlers/HandleStandardException.java
Patch:
@@ -33,6 +33,7 @@
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.delombok.LombokOptionsFactory;
+import lombok.javac.Javac;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
@@ -57,8 +58,8 @@ public void handle(AnnotationValues<StandardException> annotation, JCAnnotation
 			return;
 		}
 		
-		JCClassDecl classDef = (JCClassDecl) typeNode.get();
-		if (classDef.extending == null) {
+		JCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());
+		if (extending == null) {
 			annotationNode.addError("@StandardException requires that you extend a Throwable type");
 			return;
 		}

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -260,6 +260,9 @@ private static Method getMethod(Class<?> clazz, String name, String... paramType
 		}
 	}
 	
+	/**
+	 * In some versions, the field's type is {@code JCTree}, in others it is {@code JCExpression}, which at the JVM level are not the same.
+	 */
 	public static JCTree getExtendsClause(JCClassDecl decl) {
 		try {
 			return (JCTree) getExtendsClause.invoke(decl);

File: src/utils/lombok/permit/Permit.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2019 The Project Lombok Authors.
+ * Copyright (C) 2018-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -46,7 +46,6 @@
 import lombok.spi.Provides;
 
 import com.sun.tools.javac.code.Flags;
-import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCBinary;
@@ -214,7 +213,7 @@ public void createGetterForField(AccessLevel level,
 		
 		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
 		
-		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod), List.<Type>nil(), getMirrorForFieldType(fieldNode));
+		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
 	}
 	
 	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod) {

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -583,7 +583,7 @@ private void generateBuilderBasedConstructor(SuperBuilderJob job, boolean callBu
 			null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(),
 			maker.Block(0L, statements.toList()), null), job.sourceNode);
 		
-		injectMethod(job.parentType, constr, null, Javac.createVoidType(job.builderType.getSymbolTable(), CTC_VOID));
+		injectMethod(job.parentType, constr);
 	}
 	
 	private JCMethodDecl generateBuilderMethod(SuperBuilderJob job) {

File: test/transform/resource/before/StandardExceptions.java
Patch:
@@ -1,8 +1,9 @@
+import lombok.AccessLevel;
 import lombok.experimental.StandardException;
 
 @StandardException class EmptyException extends Exception {
 }
-@StandardException class NoArgsException extends Exception {
+@StandardException(access = AccessLevel.PROTECTED) class NoArgsException extends Exception {
 	public NoArgsException() {
 	}
 }

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -58,7 +58,7 @@ private static boolean eq(String typeTreeToString, String key) {
 	}
 	
 	@SuppressWarnings("deprecation") @Override
-	public void visitLocal(JavacNode localNode, JCVariableDecl local) {
+	public void endVisitLocal(JavacNode localNode, JCVariableDecl local) {
 		JCTree typeTree = local.vartype;
 		if (typeTree == null) return;
 		String typeTreeToString = typeTree.toString();

File: test/transform/resource/after-ecj/SuperBuilderWithExistingConstructor.java
Patch:
@@ -1,5 +1,5 @@
 public @lombok.experimental.SuperBuilder class SuperBuilderWithExistingConstructor {
-  public static abstract @java.lang.SuppressWarnings("all") class SuperBuilderWithExistingConstructor<C extends SuperBuilderWithExistingConstructor, B extends SuperBuilderWithExistingConstructor.SuperBuilderWithExistingConstructorBuilder<C, B>> {
+  public static abstract @java.lang.SuppressWarnings("all") class SuperBuilderWithExistingConstructorBuilder<C extends SuperBuilderWithExistingConstructor, B extends SuperBuilderWithExistingConstructor.SuperBuilderWithExistingConstructorBuilder<C, B>> {
     public SuperBuilderWithExistingConstructorBuilder() {
       super();
     }

File: src/core/lombok/javac/handlers/HandleBuilderDefaultRemove.java
Patch:
@@ -35,7 +35,7 @@
 import lombok.spi.Provides;
 
 @Provides
-@HandlerPriority(65536)
+@HandlerPriority(32768)
 @AlreadyHandledAnnotations
 public class HandleBuilderDefaultRemove extends JavacAnnotationHandler<Builder.Default> {
 	@Override public void handle(AnnotationValues<Default> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleBuilderRemove.java
Patch:
@@ -34,7 +34,7 @@
 import lombok.spi.Provides;
 
 @Provides
-@HandlerPriority(65536)
+@HandlerPriority(32768)
 @AlreadyHandledAnnotations
 public class HandleBuilderRemove extends JavacAnnotationHandler<Builder> {
 	@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleSuperBuilderRemove.java
Patch:
@@ -34,7 +34,7 @@
 import lombok.spi.Provides;
 
 @Provides
-@HandlerPriority(65536)
+@HandlerPriority(32768)
 @AlreadyHandledAnnotations
 public class HandleSuperBuilderRemove extends JavacAnnotationHandler<SuperBuilder> {
 	@Override public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: test/transform/resource/after-delombok/BuilderDefaultsWarnings.java
Patch:
@@ -1,6 +1,4 @@
 //skip-idempotent
-import lombok.Builder;
-@Builder
 public class BuilderDefaultsWarnings {
 	long x = System.currentTimeMillis();
 	final int y = 5;
@@ -87,7 +85,6 @@ public static BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder builder() {
 }
 class NoBuilderButHasDefaults {
 	private final long z = 5;
-	@Builder
 	public NoBuilderButHasDefaults() {
 	}
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderSingularNoAuto.java
Patch:
@@ -1,6 +1,5 @@
 //skip-idempotent
 import java.util.List;
-@lombok.Builder
 class BuilderSingularNoAuto {
 	private List<String> things;
 	private List<String> widgets;

File: test/transform/resource/after-delombok/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -1,6 +1,5 @@
 //skip-idempotent
 import java.util.List;
-@lombok.Builder(setterPrefix = "with")
 class BuilderSingularNoAutoWithSetterPrefix {
 	private List<String> things;
 	private List<String> widgets;

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -1,5 +1,4 @@
 //skip-idempotent
-@lombok.experimental.SuperBuilder
 @com.fasterxml.jackson.databind.annotation.JsonDeserialize
 public class JacksonizedSuperBuilderWithJsonDeserialize {
 	int field1;

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -302,7 +302,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 				if (sd == null) continue;
 				JavacSingularizer singularizer = sd.getSingularizer();
 				if (singularizer == null) continue;
-				if (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderType, sd)) {
+				if (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderAbstractType, sd)) {
 					bfd.singularData = null;
 				}
 			}

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -1204,7 +1204,7 @@ private boolean constructorExists(EclipseNode type, String builderClassName) {
 					if ((def.bits & ASTNode.IsDefaultConstructor) != 0) continue;
 					if (!def.isConstructor()) continue;
 					if (isTolerate(type, def)) continue;
-					if (def.arguments.length != 1) continue;
+					if (def.arguments == null || def.arguments.length != 1) continue;
 					
 					// Cannot use typeMatches() here, because the parameter could be fully-qualified, partially-qualified, or not qualified.
 					// A string-compare of the last part should work. If it's a false-positive, users could still @Tolerate it.

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -36,7 +36,6 @@
 import java.util.jar.JarFile;
 
 import lombok.core.LombokApp;
-import lombok.javac.apt.LombokProcessor;
 import lombok.permit.Permit;
 import lombok.spi.Provides;
 
@@ -174,7 +173,6 @@ private Class<?> loadStreamAsClass(String name, boolean resolve, InputStream in)
 	}
 	
 	private void runDirectly(List<String> args) {
-		LombokProcessor.addOpensForLombok();
 		Delombok.main(args.toArray(new String[0]));
 	}
 	

File: src/core/lombok/javac/handlers/HandleBuilderDefaultRemove.java
Patch:
@@ -35,7 +35,7 @@
 import lombok.spi.Provides;
 
 @Provides
-@HandlerPriority(65536)
+@HandlerPriority(32768)
 @AlreadyHandledAnnotations
 public class HandleBuilderDefaultRemove extends JavacAnnotationHandler<Builder.Default> {
 	@Override public void handle(AnnotationValues<Default> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleBuilderRemove.java
Patch:
@@ -34,7 +34,7 @@
 import lombok.spi.Provides;
 
 @Provides
-@HandlerPriority(65536)
+@HandlerPriority(32768)
 @AlreadyHandledAnnotations
 public class HandleBuilderRemove extends JavacAnnotationHandler<Builder> {
 	@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleSuperBuilderRemove.java
Patch:
@@ -34,7 +34,7 @@
 import lombok.spi.Provides;
 
 @Provides
-@HandlerPriority(65536)
+@HandlerPriority(32768)
 @AlreadyHandledAnnotations
 public class HandleSuperBuilderRemove extends JavacAnnotationHandler<SuperBuilder> {
 	@Override public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: test/transform/resource/after-delombok/BuilderDefaultsWarnings.java
Patch:
@@ -1,6 +1,4 @@
 //skip-idempotent
-import lombok.Builder;
-@Builder
 public class BuilderDefaultsWarnings {
 	long x = System.currentTimeMillis();
 	final int y = 5;
@@ -87,7 +85,6 @@ public static BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder builder() {
 }
 class NoBuilderButHasDefaults {
 	private final long z = 5;
-	@Builder
 	public NoBuilderButHasDefaults() {
 	}
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderSingularNoAuto.java
Patch:
@@ -1,6 +1,5 @@
 //skip-idempotent
 import java.util.List;
-@lombok.Builder
 class BuilderSingularNoAuto {
 	private List<String> things;
 	private List<String> widgets;

File: test/transform/resource/after-delombok/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -1,6 +1,5 @@
 //skip-idempotent
 import java.util.List;
-@lombok.Builder(setterPrefix = "with")
 class BuilderSingularNoAutoWithSetterPrefix {
 	private List<String> things;
 	private List<String> widgets;

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -1,5 +1,4 @@
 //skip-idempotent
-@lombok.experimental.SuperBuilder
 @com.fasterxml.jackson.databind.annotation.JsonDeserialize
 public class JacksonizedSuperBuilderWithJsonDeserialize {
 	int field1;

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -228,6 +228,7 @@ private FileSystem createFileSystem(File file, int minVersion) {
 		}
 		if (new File("bin/main").exists()) classpath.add("bin/main");
 		classpath.add("dist/lombok.jar");
+		classpath.add("build/teststubs");
 		if (bootRuntimePath == null || bootRuntimePath.isEmpty()) throw new IllegalStateException("System property delombok.bootclasspath is not set; set it to the rt of java6 or java8");
 		classpath.add(bootRuntimePath);
 		for (File f : new File("lib/test").listFiles()) {

File: test/transform/resource/after-delombok/ExtensionMethodFunctional.java
Patch:
@@ -11,7 +11,7 @@ public void test() {
 		test = ExtensionMethodFunctional.Extensions.map(test, s -> ExtensionMethodFunctional.Extensions.reverse(s));
 		ExtensionMethodFunctional.Extensions.consume(test, s -> System.out.println("1: " + s), s -> System.out.println("2: " + s));
 		ExtensionMethodFunctional.Extensions.consume(test, System.out::println, System.out::println);
-		ExtensionMethodFunctional.Extensions.toList(Stream.of("a", "b", "c").map(String::toUpperCase));
+		ExtensionMethodFunctional.Extensions.toList1(Stream.of("a", "b", "c").map(String::toUpperCase));
 		List<Integer> i2 = ExtensionMethodFunctional.Extensions.toList2(Stream.of("a", "b", "c").map(String::toUpperCase));
 	}
 
@@ -31,7 +31,7 @@ public static <T> void consume(T o, Consumer<T>... consumer) {
 			}
 		}
 		
-		public static <T> List<T> toList(Stream<T> stream) {
+		public static <T> List<T> toList1(Stream<T> stream) {
 			return (List<T>) stream.collect(Collectors.toList());
 		}
 

File: test/transform/resource/after-ecj/ExtensionMethodFunctional.java
Patch:
@@ -21,7 +21,7 @@ public static String reverse(String string) {
           consumer[i].accept(o);
         }
     }
-    public static <T>List<T> toList(Stream<T> stream) {
+    public static <T>List<T> toList1(Stream<T> stream) {
       return (List<T>) stream.collect(Collectors.toList());
     }
     public static <T, U>List<U> toList2(Stream<T> stream) {
@@ -36,7 +36,7 @@ public void test() {
     test = ExtensionMethodFunctional.Extensions.map(test, (<no type> s) -> ExtensionMethodFunctional.Extensions.reverse(s));
     ExtensionMethodFunctional.Extensions.consume(test, (<no type> s) -> System.out.println(("1: " + s)), (<no type> s) -> System.out.println(("2: " + s)));
     ExtensionMethodFunctional.Extensions.consume(test, System.out::println, System.out::println);
-    ExtensionMethodFunctional.Extensions.toList(Stream.of("a", "b", "c").map(String::toUpperCase));
+    ExtensionMethodFunctional.Extensions.toList1(Stream.of("a", "b", "c").map(String::toUpperCase));
     List<Integer> i2 = ExtensionMethodFunctional.Extensions.toList2(Stream.of("a", "b", "c").map(String::toUpperCase));
   }
 }

File: test/transform/resource/before/ExtensionMethodFunctional.java
Patch:
@@ -16,7 +16,7 @@ public void test() {
 		test.consume(s -> System.out.println("1: " + s), s -> System.out.println("2: " + s));
 		test.consume(System.out::println, System.out::println);
 		
-		Stream.of("a", "b", "c").map(String::toUpperCase).toList();
+		Stream.of("a", "b", "c").map(String::toUpperCase).toList1();
 		List<Integer> i2 = Stream.of("a", "b", "c").map(String::toUpperCase).toList2();
 	}
 	
@@ -36,7 +36,7 @@ public static <T> void consume(T o, Consumer<T>... consumer) {
 			}
 		}
 		
-		public static <T> List<T> toList(Stream<T> stream) {
+		public static <T> List<T> toList1(Stream<T> stream) {
 			return (List<T>) stream.collect(Collectors.toList());
 		}
 		

File: src/core/lombok/javac/apt/LombokProcessor.java
Patch:
@@ -480,7 +480,7 @@ private static Object getJdkCompilerModule() {
 	}
 	
 	/** Useful from jdk9 and up; required from jdk16 and up. This code is supposed to gracefully do nothing on jdk8 and below, as this operation isn't needed there. */
-	private static void addOpensForLombok() {
+	public static void addOpensForLombok() {
 		Class<?> cModule;
 		try {
 			cModule = Class.forName("java.lang.Module");

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -61,6 +61,7 @@
 import lombok.javac.CommentCatcher;
 import lombok.javac.Javac;
 import lombok.javac.LombokOptions;
+import lombok.javac.apt.LombokProcessor;
 import lombok.permit.Permit;
 
 import com.sun.tools.javac.code.Symtab;
@@ -314,6 +315,7 @@ public static void main(String[] rawArgs) {
 				}
 			}
 			
+			LombokProcessor.addOpensForLombok();
 			delombok.delombok();
 		} catch (Exception e) {
 			if (!args.quiet) {

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.jar.JarFile;
 
 import lombok.core.LombokApp;
+import lombok.javac.apt.LombokProcessor;
 import lombok.permit.Permit;
 import lombok.spi.Provides;
 
@@ -173,6 +174,7 @@ private Class<?> loadStreamAsClass(String name, boolean resolve, InputStream in)
 	}
 	
 	private void runDirectly(List<String> args) {
+		LombokProcessor.addOpensForLombok();
 		Delombok.main(args.toArray(new String[0]));
 	}
 	

File: test/transform/resource/after-delombok/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Javac 6 will error out due to `ChildBuilder` not existing before properly running lombok. Giving j6 support status, not worth fixing.
 import java.util.List;
 public class SuperBuilderWithCustomBuilderMethod {
 	public static class Parent<A> {

File: test/transform/resource/before/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -1,5 +1,5 @@
 //version 8: Javac 6 will error out due to `ChildBuilder` not existing before properly running lombok. Giving j6 support status, not worth fixing.
-iimport java.util.List;
+import java.util.List;
 
 public class SuperBuilderWithCustomBuilderMethod {
 	@lombok.experimental.SuperBuilder

File: src/spiProcessor/lombok/spi/SpiProcessor.java
Patch:
@@ -222,7 +222,7 @@ else if (list instanceof List<?>) {
 		}
 		
 		for (TypeMirror spiType : spiTypes) {
-			String spiTypeName = toElement(spiType).getQualifiedName().toString();
+			String spiTypeName = createProperQualifiedName(toElement(spiType));
 			String createProperQualifiedName = createProperQualifiedName(elem);
 			data.getService(spiTypeName).addProvider(createProperQualifiedName);
 		}

File: src/core/lombok/bytecode/PreventNullAnalysisRemover.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 The Project Lombok Authors.
+ * Copyright (C) 2010-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,15 +27,15 @@
 
 import lombok.core.DiagnosticsReceiver;
 import lombok.core.PostCompilerTransformation;
+import lombok.spi.Provides;
 
-import org.mangosdk.spi.ProviderFor;
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-@ProviderFor(PostCompilerTransformation.class)
+@Provides
 public class PreventNullAnalysisRemover implements PostCompilerTransformation {
 	
 	@Override public byte[] applyTransformations(byte[] original, String fileName, DiagnosticsReceiver diagnostics) {

File: src/core/lombok/bytecode/SneakyThrowsRemover.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 The Project Lombok Authors.
+ * Copyright (C) 2010-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,8 +27,8 @@
 
 import lombok.core.DiagnosticsReceiver;
 import lombok.core.PostCompilerTransformation;
+import lombok.spi.Provides;
 
-import org.mangosdk.spi.ProviderFor;
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
@@ -37,7 +37,7 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-@ProviderFor(PostCompilerTransformation.class)
+@Provides
 public class SneakyThrowsRemover implements PostCompilerTransformation {
 	
 	@Override public byte[] applyTransformations(byte[] original, String fileName, final DiagnosticsReceiver diagnostics) {

File: src/core/lombok/eclipse/handlers/HandleAccessors.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Project Lombok Authors.
+ * Copyright (C) 2014-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,11 +28,11 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.Accessors;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.mangosdk.spi.ProviderFor;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(65536)
 public class HandleAccessors extends EclipseAnnotationHandler<Accessors> {
 	@Override public void handle(AnnotationValues<Accessors> annotation, Annotation ast, EclipseNode annotationNode) {

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2020 The Project Lombok Authors.
+ * Copyright (C) 2013-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -74,7 +74,6 @@
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
 import lombok.Builder;
@@ -98,8 +97,9 @@
 import lombok.eclipse.handlers.EclipseSingularsRecipes.SingularData;
 import lombok.eclipse.handlers.HandleConstructor.SkipIfConstructorExists;
 import lombok.experimental.NonFinal;
+import lombok.spi.Provides;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleBuilder extends EclipseAnnotationHandler<Builder> {
 	private HandleConstructor handleConstructor = new HandleConstructor();

File: src/core/lombok/eclipse/handlers/HandleBuilderDefault.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017-2018 The Project Lombok Authors.
+ * Copyright (C) 2017-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -23,7 +23,6 @@
 
 import static lombok.eclipse.handlers.EclipseHandlerUtil.*;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.Builder;
 import lombok.core.AST.Kind;
@@ -32,8 +31,9 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.SuperBuilder;
+import lombok.spi.Provides;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(-1025) //HandleBuilder's level, minus one.
 public class HandleBuilderDefault extends EclipseAnnotationHandler<Builder.Default> {
 	@Override public void handle(AnnotationValues<Builder.Default> annotation, Annotation ast, EclipseNode annotationNode) {

File: src/core/lombok/eclipse/handlers/HandleCleanup.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2014 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,6 +32,7 @@
 import lombok.core.AST.Kind;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
@@ -52,12 +53,11 @@
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.SwitchStatement;
 import org.eclipse.jdt.internal.compiler.ast.TryStatement;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.Cleanup} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleCleanup extends EclipseAnnotationHandler<Cleanup> {
 	public void handle(AnnotationValues<Cleanup> annotation, Annotation ast, EclipseNode annotationNode) {
 		handleFlagUsage(annotationNode, ConfigurationKeys.CLEANUP_FLAG_USAGE, "@Cleanup");

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2014 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,16 +32,16 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.eclipse.handlers.HandleConstructor.SkipIfConstructorExists;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.Data} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleData extends EclipseAnnotationHandler<Data> {
 	private HandleGetter handleGetter = new HandleGetter();
 	private HandleSetter handleSetter = new HandleSetter();

File: src/core/lombok/eclipse/handlers/HandleDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Project Lombok Authors.
+ * Copyright (C) 2014-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,14 +27,14 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.Delegate;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * This class just handles basic error cases. The real meat of eclipse '@Delegate' support is in {@code PatchDelegate}.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleDelegate extends EclipseAnnotationHandler<Delegate> {
 	public void handle(AnnotationValues<Delegate> annotation, Annotation ast, EclipseNode annotationNode) {
 		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.DELEGATE_FLAG_USAGE, "@Delegate");

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2020 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -48,6 +48,7 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.eclipse.handlers.EclipseHandlerUtil.MemberExistsResult;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
@@ -89,12 +90,11 @@
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code EqualsAndHashCode} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleEqualsAndHashCode extends EclipseAnnotationHandler<EqualsAndHashCode> {
 	
 	private static final String HASH_CODE_CACHE_NAME = "$hashCodeCache";

File: src/core/lombok/eclipse/handlers/HandleExtensionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,17 +28,17 @@
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.ExtensionMethod;
+import lombok.spi.Provides;
 
 // This handler just does some additional error checking; the real work is done in the agent.
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(66560) // 2^16 + 2^10; we must run AFTER HandleVal which is at 2^16
 public class HandleExtensionMethod extends EclipseAnnotationHandler<ExtensionMethod> {
 	@Override public void handle(AnnotationValues<ExtensionMethod> annotation, Annotation ast, EclipseNode annotationNode) {

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2016 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -38,6 +38,7 @@
 import lombok.experimental.FieldDefaults;
 import lombok.experimental.NonFinal;
 import lombok.experimental.PackagePrivate;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
@@ -47,12 +48,11 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.FieldDefaults} annotation for eclipse.
  */
-@ProviderFor(EclipseASTVisitor.class)
+@Provides(EclipseASTVisitor.class)
 @HandlerPriority(-2048) //-2^11; to ensure @Value picks up on messing with the fields' 'final' state, run earlier.
 public class HandleFieldDefaults extends EclipseASTAdapter {
 	public boolean generateFieldDefaultsForType(EclipseNode typeNode, EclipseNode pos, AccessLevel level, boolean makeFinal, boolean checkForTypeLevelFieldDefaults) {

File: src/core/lombok/eclipse/handlers/HandleFieldNameConstants.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2019 The Project Lombok Authors.
+ * Copyright (C) 2014-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -41,7 +41,6 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
 import lombok.ConfigurationKeys;
@@ -54,8 +53,9 @@
 import lombok.eclipse.EclipseNode;
 import lombok.eclipse.handlers.EclipseHandlerUtil.MemberExistsResult;
 import lombok.experimental.FieldNameConstants;
+import lombok.spi.Provides;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleFieldNameConstants extends EclipseAnnotationHandler<FieldNameConstants> {
 	private static final IdentifierName FIELDS = IdentifierName.valueOf("Fields");
 

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2020 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -35,6 +35,7 @@
 import lombok.AccessLevel;
 import lombok.ConfigurationKeys;
 import lombok.experimental.Delegate;
+import lombok.spi.Provides;
 import lombok.Getter;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -73,12 +74,11 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.Getter} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleGetter extends EclipseAnnotationHandler<Getter> {
 	private static final Annotation[] EMPTY_ANNOTATIONS_ARRAY = new Annotation[0];
 

File: src/core/lombok/eclipse/handlers/HandleHelper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2016 The Project Lombok Authors.
+ * Copyright (C) 2015-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -45,19 +45,19 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.Helper;
+import lombok.spi.Provides;
 
 /**
  * Handles the {@code lombok.Cleanup} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleHelper extends EclipseAnnotationHandler<Helper> {
 	private Statement[] getStatementsFromAstNode(ASTNode node) {
 		if (node instanceof Block) return ((Block) node).statements;

File: src/core/lombok/eclipse/handlers/HandleNonNull.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2019 The Project Lombok Authors.
+ * Copyright (C) 2013-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -46,7 +46,6 @@
 import org.eclipse.jdt.internal.compiler.ast.ThrowStatement;
 import org.eclipse.jdt.internal.compiler.ast.TryStatement;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.ConfigurationKeys;
 import lombok.NonNull;
@@ -57,9 +56,10 @@
 import lombok.eclipse.EclipseAST;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 @DeferUntilPostDiet
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(value = 512) // 2^9; onParameter=@__(@NonNull) has to run first.
 public class HandleNonNull extends EclipseAnnotationHandler<NonNull> {
 	private static final char[] REQUIRE_NON_NULL = "requireNonNull".toCharArray();

File: src/core/lombok/eclipse/handlers/HandlePrintAST.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2014 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -26,7 +26,6 @@
 import java.io.PrintStream;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.Lombok;
 import lombok.core.AnnotationValues;
@@ -36,11 +35,12 @@
 import lombok.eclipse.EclipseASTVisitor;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 /**
  * Handles the {@code lombok.core.PrintAST} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @DeferUntilPostDiet
 @HandlerPriority(536870912) // 2^29; this handler is customarily run at the very end.
 public class HandlePrintAST extends EclipseAnnotationHandler<PrintAST> {

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -38,6 +38,7 @@
 import lombok.core.AnnotationValues;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
@@ -56,12 +57,11 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.Setter} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleSetter extends EclipseAnnotationHandler<Setter> {
 	public boolean generateSetterForType(EclipseNode typeNode, EclipseNode pos, AccessLevel level, boolean checkForTypeLevelSetter, List<Annotation> onMethod, List<Annotation> onParam) {
 		if (checkForTypeLevelSetter) {

File: src/core/lombok/eclipse/handlers/HandleSneakyThrows.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2014 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -36,6 +36,7 @@
 import lombok.eclipse.DeferUntilPostDiet;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
@@ -56,12 +57,11 @@
 import org.eclipse.jdt.internal.compiler.ast.ThrowStatement;
 import org.eclipse.jdt.internal.compiler.ast.TryStatement;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.HandleSneakyThrows} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @DeferUntilPostDiet
 @HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSneakyThrows extends EclipseAnnotationHandler<SneakyThrows> {

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -75,7 +75,6 @@
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
 import lombok.Builder;
@@ -101,8 +100,9 @@
 import lombok.eclipse.handlers.HandleBuilder.BuilderJob;
 import lombok.experimental.NonFinal;
 import lombok.experimental.SuperBuilder;
+import lombok.spi.Provides;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleSuperBuilder extends EclipseAnnotationHandler<SuperBuilder> {
 	private static final char[] SELF_METHOD_NAME = "self".toCharArray();

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2020 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -36,6 +36,7 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.eclipse.handlers.EclipseHandlerUtil.MemberExistsResult;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
@@ -51,12 +52,11 @@
 import org.eclipse.jdt.internal.compiler.ast.ThisReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.Synchronized} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @DeferUntilPostDiet
 @HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSynchronized extends EclipseAnnotationHandler<Synchronized> {

File: src/core/lombok/eclipse/handlers/HandleToString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2020 The Project Lombok Authors.
+ * Copyright (C) 2009-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -52,7 +52,6 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
 import lombok.ConfigurationKeys;
@@ -67,11 +66,12 @@
 import lombok.eclipse.Eclipse;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 /**
  * Handles the {@code ToString} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleToString extends EclipseAnnotationHandler<ToString> {
 	public void handle(AnnotationValues<ToString> annotation, Annotation ast, EclipseNode annotationNode) {
 		handleFlagUsage(annotationNode, ConfigurationKeys.TO_STRING_FLAG_USAGE, "@ToString");

File: src/core/lombok/eclipse/handlers/HandleUtilityClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2020 The Project Lombok Authors.
+ * Copyright (C) 2015-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -43,7 +43,6 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
@@ -52,12 +51,13 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.UtilityClass;
+import lombok.spi.Provides;
 
 /**
  * Handles the {@code lombok.experimental.UtilityClass} annotation for eclipse.
  */
+@Provides
 @HandlerPriority(-4096) //-2^12; to ensure @FieldDefaults picks up on the 'static' we set here.
-@ProviderFor(EclipseAnnotationHandler.class)
 public class HandleUtilityClass extends EclipseAnnotationHandler<UtilityClass> {
 	@Override public void handle(AnnotationValues<UtilityClass> annotation, Annotation ast, EclipseNode annotationNode) {
 		handleFlagUsage(annotationNode, ConfigurationKeys.UTILITY_CLASS_FLAG_USAGE, "@UtilityClass");

File: src/core/lombok/eclipse/handlers/HandleVal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2018 The Project Lombok Authors.
+ * Copyright (C) 2010-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -31,6 +31,7 @@
 import lombok.eclipse.EclipseASTAdapter;
 import lombok.eclipse.EclipseASTVisitor;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
@@ -39,12 +40,11 @@
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.mangosdk.spi.ProviderFor;
 
 /*
  * This class just handles 3 basic error cases. The real meat of eclipse 'val' support is in {@code PatchVal} and {@code PatchValEclipse}.
  */
-@ProviderFor(EclipseASTVisitor.class)
+@Provides(EclipseASTVisitor.class)
 @DeferUntilPostDiet
 @HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
 public class HandleVal extends EclipseASTAdapter {

File: src/core/lombok/eclipse/handlers/HandleValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -34,17 +34,17 @@
 import lombok.eclipse.EclipseNode;
 import lombok.eclipse.handlers.HandleConstructor.SkipIfConstructorExists;
 import lombok.experimental.NonFinal;
+import lombok.spi.Provides;
 import lombok.Value;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.mangosdk.spi.ProviderFor;
 
 /**
  * Handles the {@code lombok.Value} annotation for eclipse.
  */
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 @HandlerPriority(-512) //-2^9; to ensure @EqualsAndHashCode and such pick up on this handler making the class final and messing with the fields' access levels, run earlier.
 public class HandleValue extends EclipseAnnotationHandler<Value> {
 	private HandleFieldDefaults handleFieldDefaults = new HandleFieldDefaults();

File: src/core/lombok/eclipse/handlers/HandleWith.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2020 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -38,6 +38,7 @@
 import lombok.core.AnnotationValues;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
@@ -57,9 +58,8 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
-import org.mangosdk.spi.ProviderFor;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleWith extends EclipseAnnotationHandler<With> {
 	public boolean generateWithForType(EclipseNode typeNode, EclipseNode pos, AccessLevel level, boolean checkForTypeLevelWith) {
 		if (checkForTypeLevelWith) {

File: src/core/lombok/eclipse/handlers/HandleWithBy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 The Project Lombok Authors.
+ * Copyright (C) 2020-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,7 +51,6 @@
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
 import lombok.ConfigurationKeys;
@@ -63,8 +62,9 @@
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.WithBy;
+import lombok.spi.Provides;
 
-@ProviderFor(EclipseAnnotationHandler.class)
+@Provides
 public class HandleWithBy extends EclipseAnnotationHandler<WithBy> {
 	public boolean generateWithByForType(EclipseNode typeNode, EclipseNode pos, AccessLevel level, boolean checkForTypeLevelWithBy) {
 		if (checkForTypeLevelWithBy) {

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilMapSingularizer.java
Patch:
@@ -50,7 +50,6 @@
 import org.eclipse.jdt.internal.compiler.ast.ThisReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
 import lombok.core.LombokImmutableList;
@@ -62,8 +61,9 @@
 import lombok.eclipse.handlers.EclipseSingularsRecipes.StatementMaker;
 import lombok.eclipse.handlers.EclipseSingularsRecipes.TypeReferenceMaker;
 import lombok.eclipse.handlers.HandleNonNull;
+import lombok.spi.Provides;
 
-@ProviderFor(EclipseSingularizer.class)
+@Provides(EclipseSingularizer.class)
 public class EclipseJavaUtilMapSingularizer extends EclipseJavaUtilSingularizer {
 	@Override public LombokImmutableList<String> getSupportedTypes() {
 		return LombokImmutableList.of("java.util.Map", "java.util.SortedMap", "java.util.NavigableMap");

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilSetSingularizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2019 The Project Lombok Authors.
+ * Copyright (C) 2015-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,11 +27,11 @@
 import lombok.eclipse.EclipseNode;
 import lombok.eclipse.handlers.EclipseSingularsRecipes.EclipseSingularizer;
 import lombok.eclipse.handlers.EclipseSingularsRecipes.SingularData;
+import lombok.spi.Provides;
 
 import org.eclipse.jdt.internal.compiler.ast.Statement;
-import org.mangosdk.spi.ProviderFor;
 
-@ProviderFor(EclipseSingularizer.class)
+@Provides(EclipseSingularizer.class)
 public class EclipseJavaUtilSetSingularizer extends EclipseJavaUtilListSetSingularizer {
 	@Override public LombokImmutableList<String> getSupportedTypes() {
 		return LombokImmutableList.of("java.util.Set", "java.util.SortedSet", "java.util.NavigableSet");

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -30,8 +30,6 @@
 
 import javax.lang.model.element.Modifier;
 
-import org.mangosdk.spi.ProviderFor;
-
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
@@ -81,8 +79,9 @@
 import lombok.javac.handlers.JavacHandlerUtil.MemberExistsResult;
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
+import lombok.spi.Provides;
 
-@ProviderFor(JavacAnnotationHandler.class)
+@Provides
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleBuilder extends JavacAnnotationHandler<Builder> {
 	private HandleConstructor handleConstructor = new HandleConstructor();

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -39,8 +39,7 @@
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacResolution;
-
-import org.mangosdk.spi.ProviderFor;
+import lombok.spi.Provides;
 
 import com.sun.source.tree.MethodInvocationTree;
 import com.sun.source.util.TreeScanner;
@@ -65,7 +64,7 @@
 /**
  * Handles the {@link ExtensionMethod} annotation for javac.
  */
-@ProviderFor(JavacAnnotationHandler.class)
+@Provides
 @HandlerPriority(66560) // 2^16 + 2^10; we must run AFTER HandleVal which is at 2^16
 public class HandleExtensionMethod extends JavacAnnotationHandler<ExtensionMethod> {
 	@Override

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -43,8 +43,7 @@
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.JavacTreeMaker.TypeTag;
-
-import org.mangosdk.spi.ProviderFor;
+import lombok.spi.Provides;
 
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Type;
@@ -71,7 +70,7 @@
 /**
  * Handles the {@code lombok.Getter} annotation for javac.
  */
-@ProviderFor(JavacAnnotationHandler.class)
+@Provides
 public class HandleGetter extends JavacAnnotationHandler<Getter> {
 	public void generateGetterForType(JavacNode typeNode, JavacNode errorNode, AccessLevel level, boolean checkForTypeLevelGetter, List<JCAnnotation> onMethod) {
 		if (checkForTypeLevelGetter) {

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -32,8 +32,6 @@
 
 import javax.lang.model.element.Modifier;
 
-import org.mangosdk.spi.ProviderFor;
-
 import com.sun.tools.javac.code.BoundKind;
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.tree.JCTree;
@@ -84,8 +82,9 @@
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
 import lombok.javac.handlers.JavacSingularsRecipes.StatementMaker;
+import lombok.spi.Provides;
 
-@ProviderFor(JavacAnnotationHandler.class)
+@Provides
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleSuperBuilder extends JavacAnnotationHandler<SuperBuilder> {
 	private static final String SELF_METHOD = "self";

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2020 The Project Lombok Authors.
+ * Copyright (C) 2015-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -279,7 +279,7 @@ protected Statement createConstructBuilderVarIfNeeded(SingularData data, Eclipse
 	protected abstract String getAddMethodName();
 	protected abstract String getAddAllTypeName();
 	
-	protected int getTypeArgumentsCount() {
+	@Override protected int getTypeArgumentsCount() {
 		return getArgumentSuffixes().size();
 	}
 }

File: test/transform/resource/after-delombok/SuperBuilderBasicToBuilder.java
Patch:
@@ -35,7 +35,7 @@ public static abstract class ParentBuilder<C extends SuperBuilderBasicToBuilder.
 				b.obtainViaField(instance.field1);
 				b.obtainViaMethod(instance.method());
 				b.obtainViaStaticMethod(SuperBuilderBasicToBuilder.Parent.staticMethod(instance));
-				b.items(instance.items == null ? java.util.Collections.emptyList() : instance.items);
+				b.items(instance.items == null ? java.util.Collections.<String>emptyList() : instance.items);
 			}
 			@java.lang.SuppressWarnings("all")
 			protected abstract B self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -19,7 +19,7 @@ public static abstract class ParentBuilder<A, C extends SuperBuilderWithGenerics
 			@java.lang.SuppressWarnings("all")
 			private static <A> void $fillValuesFromInstanceIntoBuilder(final SuperBuilderWithGenericsAndToBuilder.Parent<A> instance, final SuperBuilderWithGenericsAndToBuilder.Parent.ParentBuilder<A, ?, ?> b) {
 				b.field1(instance.field1);
-				b.items(instance.items == null ? java.util.Collections.emptyMap() : instance.items);
+				b.items(instance.items == null ? java.util.Collections.<Integer, String>emptyMap() : instance.items);
 			}
 			@java.lang.SuppressWarnings("all")
 			protected abstract B self();

File: test/transform/resource/after-delombok/SuperBuilderWithSetterPrefix.java
Patch:
@@ -35,7 +35,7 @@ public static abstract class ParentBuilder<C extends SuperBuilderWithSetterPrefi
 				b.withObtainViaField(instance.field1);
 				b.withObtainViaMethod(instance.method());
 				b.withObtainViaStaticMethod(SuperBuilderWithSetterPrefix.Parent.staticMethod(instance));
-				b.withItems(instance.items == null ? java.util.Collections.emptyList() : instance.items);
+				b.withItems(instance.items == null ? java.util.Collections.<String>emptyList() : instance.items);
 			}
 			@java.lang.SuppressWarnings("all")
 			protected abstract B self();

File: test/transform/resource/after-ecj/SuperBuilderBasicToBuilder.java
Patch:
@@ -19,7 +19,7 @@ public ParentBuilder() {
         b.obtainViaField(instance.field1);
         b.obtainViaMethod(instance.method());
         b.obtainViaStaticMethod(SuperBuilderBasicToBuilder.Parent.staticMethod(instance));
-        b.items(((instance.items == null) ? java.util.Collections.emptyList() : instance.items));
+        b.items(((instance.items == null) ? java.util.Collections.<String>emptyList() : instance.items));
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C build();

File: test/transform/resource/after-ecj/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -14,7 +14,7 @@ public ParentBuilder() {
       }
       private static @java.lang.SuppressWarnings("all") <A>void $fillValuesFromInstanceIntoBuilder(final SuperBuilderWithGenericsAndToBuilder.Parent<A> instance, final SuperBuilderWithGenericsAndToBuilder.Parent.ParentBuilder<A, ?, ?> b) {
         b.field1(instance.field1);
-        b.items(((instance.items == null) ? java.util.Collections.emptyMap() : instance.items));
+        b.items(((instance.items == null) ? java.util.Collections.<Integer, String>emptyMap() : instance.items));
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C build();

File: test/transform/resource/after-ecj/SuperBuilderWithSetterPrefix.java
Patch:
@@ -19,7 +19,7 @@ public ParentBuilder() {
         b.withObtainViaField(instance.field1);
         b.withObtainViaMethod(instance.method());
         b.withObtainViaStaticMethod(SuperBuilderWithSetterPrefix.Parent.staticMethod(instance));
-        b.withItems(((instance.items == null) ? java.util.Collections.emptyList() : instance.items));
+        b.withItems(((instance.items == null) ? java.util.Collections.<String>emptyList() : instance.items));
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C build();

File: test/transform/resource/after-delombok/JacksonBuilderSingular.java
Patch:
@@ -1,4 +1,4 @@
-//version 8:
+//version 8: Jackson deps are at least Java7+.
 import java.util.List;
 import java.util.Map;
 import com.fasterxml.jackson.annotation.JsonAnySetter;

File: test/transform/resource/after-delombok/JacksonJsonProperty.java
Patch:
@@ -1,4 +1,4 @@
-//version 8:
+//version 8: Jackson deps are at least Java7+.
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonSetter;
 import com.fasterxml.jackson.annotation.Nulls;

File: test/transform/resource/after-delombok/JacksonizedBuilderComplex.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 //CONF: lombok.builder.className = Test*Name
 import java.util.List;
 @com.fasterxml.jackson.databind.annotation.JsonDeserialize(builder = JacksonizedBuilderComplex.TestVoidName.class)

File: test/transform/resource/after-delombok/JacksonizedBuilderSimple.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 import java.util.List;
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
 @JsonIgnoreProperties(ignoreUnknown = true)

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderSimple.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 public class JacksonizedSuperBuilderSimple {
 	@com.fasterxml.jackson.annotation.JsonIgnoreProperties(ignoreUnknown = true)
 	@com.fasterxml.jackson.databind.annotation.JsonDeserialize(builder = JacksonizedSuperBuilderSimple.Parent.ParentBuilderImpl.class)

File: test/transform/resource/before/JacksonBuilderSingular.java
Patch:
@@ -1,4 +1,4 @@
-//version 8:
+//version 8: Jackson deps are at least Java7+.
 import java.util.List;
 import java.util.Map;
 

File: test/transform/resource/before/JacksonJsonProperty.java
Patch:
@@ -1,4 +1,4 @@
-//version 8:
+//version 8: Jackson deps are at least Java7+.
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonSetter;
 import com.fasterxml.jackson.annotation.Nulls;

File: test/transform/resource/before/JacksonizedBuilderComplex.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 //CONF: lombok.builder.className = Test*Name
 import java.util.List;
 import lombok.Builder;

File: test/transform/resource/before/JacksonizedBuilderSimple.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 import java.util.List;
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
 

File: test/transform/resource/before/JacksonizedSuperBuilderSimple.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 public class JacksonizedSuperBuilderSimple {
 	@lombok.extern.jackson.Jacksonized
 	@lombok.experimental.SuperBuilder

File: test/transform/resource/before/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -1,3 +1,4 @@
+//version 8: Jackson deps are at least Java7+.
 @lombok.extern.jackson.Jacksonized
 @lombok.experimental.SuperBuilder
 @com.fasterxml.jackson.databind.annotation.JsonDeserialize

File: test/transform/resource/before/SuperBuilderBasicToBuilder.java
Patch:
@@ -15,7 +15,7 @@ public static class Parent {
 		private int method() {
 			return 2;
 		}
-
+		
 		private static String staticMethod(Parent instance) {
 			return "staticMethod";
 		}

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -91,7 +91,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 					}
 				});
 				
-				boolean changed = transformCode(messages, writer, file, sourceDirectives_.getSpecifiedEncoding(), sourceDirectives_.getFormatPreferences(), sourceDirectives_.minVersion());
+				boolean changed = transformCode(messages, writer, file, sourceDirectives_.getSpecifiedEncoding(), sourceDirectives_.getFormatPreferences(), sourceDirectives_.minVersion(), params instanceof TestLombokFilesIdempotent);
 				boolean forceUnchanged = sourceDirectives_.forceUnchanged() || sourceDirectives_.isSkipCompareContent();
 				if (params.expectChanges() && !forceUnchanged && !changed) messages.add(new CompilerMessage(-1, -1, true, "not flagged modified"));
 				if (!params.expectChanges() && changed) messages.add(new CompilerMessage(-1, -1, true, "unexpected modification"));
@@ -101,7 +101,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 		};
 	}
 	
-	protected abstract boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion) throws Throwable;
+	protected abstract boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion, boolean idempotentCheck) throws Throwable;
 	
 	protected String readFile(File file) throws IOException {
 		BufferedReader reader;

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -109,7 +109,7 @@ public boolean ignoreAllErrors() {
 	}
 	
 	@Override
-	public boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion) throws Throwable {
+	public boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion, boolean idempotentCheck) throws Throwable {
 		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
 		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
 		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {

File: test/transform/resource/after-delombok/BuilderSingularAnnotatedTypes.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 import java.util.Set;

File: test/transform/resource/after-delombok/BuilderSingularAnnotatedTypesWithSetterPrefix.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 import java.util.Set;

File: test/transform/resource/after-delombok/CheckerFrameworkBasic.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class CheckerFrameworkBasic {
 	private final int x;
 	private final int y;

File: test/transform/resource/after-delombok/CheckerFrameworkSuperBuilder.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 class CheckerFrameworkSuperBuilder {
 	public static class Parent {

File: test/transform/resource/after-delombok/EqualsAndHashCodeAnnotated.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.*;
 
 class EqualsAndHashCodeAnnotated {

File: test/transform/resource/after-delombok/ExtensionMethodFunctional.java
Patch:
@@ -1,3 +1,4 @@
+// version 8:
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.List;

File: test/transform/resource/after-delombok/GetterLazyArguments.java
Patch:
@@ -1,3 +1,4 @@
+// version 8:
 class GetterLazyArguments {
 	static String fun() {
 		return null;

File: test/transform/resource/after-delombok/JacksonBuilderSingular.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 import java.util.Map;
 import com.fasterxml.jackson.annotation.JsonAnySetter;

File: test/transform/resource/after-delombok/JacksonJsonProperty.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonSetter;
 import com.fasterxml.jackson.annotation.Nulls;

File: test/transform/resource/after-delombok/LoggerLog4j2.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class LoggerLog4j2 {
 	@java.lang.SuppressWarnings("all")
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LoggerLog4j2.class);

File: test/transform/resource/after-delombok/NonNullTypeUse.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import lombok.NonNull;
 class NonNullTypeUse {
 	void test1(@NonNull String[][][] args) {

File: test/transform/resource/after-delombok/NullLibrary1.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 public class NullLibrary1 {
 	String foo;
 	@java.lang.Override

File: test/transform/resource/after-delombok/SuperBuilderSingularAnnotatedTypes.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 import java.util.Set;

File: test/transform/resource/after-delombok/TypeUseAnnotations.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 import java.util.List;

File: test/transform/resource/after-delombok/ValDelegateMethodReference.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.function.Function;
 
 public class ValDelegateMethodReference {

File: test/transform/resource/after-delombok/WithByNullAnnos.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 public class WithByNullAnnos {
 	final List<String> test;

File: test/transform/resource/after-delombok/WithByTypes.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 public class WithByTypes<T> {
 	private final int a;
 	private final long b;

File: test/transform/resource/before/BuilderSingularNullBehavior2.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations = spring
 //CONF: lombok.nonNull.exceptionType = JDK
 import java.util.List;

File: test/transform/resource/before/CheckerFrameworkBasic.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: checkerframework = 4.0
 import lombok.AllArgsConstructor;
 import lombok.Data;

File: test/transform/resource/before/CheckerFrameworkBuilder.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: checkerframework = 4.0
 import java.util.List;
 import lombok.Builder;

File: test/transform/resource/before/CheckerFrameworkSuperBuilder.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: checkerframework = 4.0
 import java.util.List;
 import lombok.Singular;

File: test/transform/resource/before/EqualsAndHashCodeAnnotated.java
Patch:
@@ -1,4 +1,4 @@
-//version 8
+//version 8:
 import java.lang.annotation.*;
 
 @lombok.EqualsAndHashCode

File: test/transform/resource/before/JacksonBuilderSingular.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 import java.util.Map;
 

File: test/transform/resource/before/JacksonJsonProperty.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonSetter;
 import com.fasterxml.jackson.annotation.Nulls;

File: test/transform/resource/before/LoggerLog4j2.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import lombok.extern.log4j.Log4j2;
 
 @lombok.extern.log4j.Log4j2

File: test/transform/resource/before/NullLibrary1.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations = eclipse
 @lombok.EqualsAndHashCode
 @lombok.ToString

File: test/transform/resource/before/SuperBuilderSingularAnnotatedTypes.java
Patch:
@@ -1,4 +1,4 @@
-//VERSION 8:
+//version 8:
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Target;
 import java.util.Set;

File: test/transform/resource/before/ValDelegateMethodReference.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.Getter;
 import lombok.Setter;

File: test/transform/resource/before/WithByNullAnnos.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations=checkerframework
 import java.util.List;
 @lombok.RequiredArgsConstructor

File: test/transform/resource/before/WithByTypes.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 @lombok.RequiredArgsConstructor
 @lombok.experimental.FieldDefaults(level = lombok.AccessLevel.PRIVATE, makeFinal = true)
 @lombok.experimental.WithBy

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -303,7 +303,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 				if (sd == null) continue;
 				JavacSingularizer singularizer = sd.getSingularizer();
 				if (singularizer == null) continue;
-				if (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderType, sd)) {
+				if (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderAbstractType, sd)) {
 					bfd.singularData = null;
 				}
 			}

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -325,7 +325,9 @@ public static int primeForNull() {
 			"com.fasterxml.jackson.annotation.JsonTypeInfo",
 			"com.fasterxml.jackson.annotation.JsonView",
 			"com.fasterxml.jackson.databind.annotation.JsonDeserialize",
+			"com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper",
 			"com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty",
+			"com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText",
 		}));
 		COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS = Collections.unmodifiableList(Arrays.asList(new String[] {
 			"com.fasterxml.jackson.annotation.JsonAnySetter",

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -1206,7 +1206,7 @@ private boolean constructorExists(EclipseNode type, String builderClassName) {
 					if ((def.bits & ASTNode.IsDefaultConstructor) != 0) continue;
 					if (!def.isConstructor()) continue;
 					if (isTolerate(type, def)) continue;
-					if (def.arguments.length != 1) continue;
+					if (def.arguments == null || def.arguments.length != 1) continue;
 					
 					// Cannot use typeMatches() here, because the parameter could be fully-qualified, partially-qualified, or not qualified.
 					// A string-compare of the last part should work. If it's a false-positive, users could still @Tolerate it.

File: test/bytecode/src/lombok/bytecode/TestClassFileMetaData.java
Patch:
@@ -76,7 +76,7 @@ public void testGetSuperClassName() {
 	}
 	
 	
-	
+
 	@Test
 	public void testUsesClass() {
 		assertTrue(foo.usesClass("java/lang/System"));
@@ -199,7 +199,7 @@ static byte[] compile(File file) {
 			
 			CompilationTask task = compiler.getTask(captureWarnings, null, diagnostics, options, null, Collections.singleton(new ContentBasedJavaFileObject(file.getPath(), readFileAsString(file))));
 			Boolean taskResult = task.call();
-			assertTrue("Compilation task didn't succeed: \n<Warnings and Errors>\n" + compilerErrors.toString() + "\n</Warnings and Errors>", taskResult);
+			assertTrue("Compilation task didn't succeed: \n<Warnings and Errors>\n" + compilerErrors.toString() + "\n" + captureWarnings.toString() + "\n</Warnings and Errors>", taskResult);
 			return PostCompilerApp.readFile(new File(tempDir, file.getName().replaceAll("\\.java$", ".class")));
 		} catch (Exception e) {
 			throw Lombok.sneakyThrow(e);

File: test/transform/resource/after-delombok/BuilderSingularNullBehavior1.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 import java.util.Collection;
 class BuilderSingularNullBehavior1 {

File: test/transform/resource/after-delombok/BuilderWithNonNull.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class BuilderWithNonNull {
 	@lombok.NonNull
 	private final String id;

File: test/transform/resource/after-delombok/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class BuilderWithNonNullWithSetterPrefix {
 	@lombok.NonNull
 	private final String id;

File: test/transform/resource/after-delombok/ConstructorsWithAccessors.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class ConstructorsWithAccessors {
 	int plower;
 	int pUpper;

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class DataOnLocalClass1 {
 	public static void main(String[] args) {
 		class Local {

File: test/transform/resource/after-delombok/GetterOnClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class GetterOnClass1 {
 	boolean isNone;
 	boolean isPublic;

File: test/transform/resource/after-delombok/NonNullOnParameter.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class NonNullOnParameter extends Thread {
 	NonNullOnParameter(@lombok.NonNull String arg) {
 		this(arg, "");

File: test/transform/resource/after-delombok/NonNullOnParameterAbstract.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 abstract class NonNullOnParameterAbstract {
 	public void test(@lombok.NonNull String arg) {
 		if (arg == null) {

File: test/transform/resource/after-delombok/NonNullPlain.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.*;
 class NonNullPlain {
 	@lombok.NonNull

File: test/transform/resource/after-delombok/NonNullWithAlternateException.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 public class NonNullWithAlternateException {
 	@lombok.NonNull
 	private String test;

File: test/transform/resource/after-delombok/NonNullWithAssertion.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 public class NonNullWithAssertion {
 	@lombok.NonNull
 	private String test;

File: test/transform/resource/after-delombok/NonNullWithGuava.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import static com.google.common.base.Preconditions.*;
 public class NonNullWithGuava {
 	@lombok.NonNull

File: test/transform/resource/after-delombok/NonNullWithJdk.java
Patch:
@@ -1,4 +1,4 @@
-//version 7:
+//version 8:
 import static java.util.Objects.*;
 public class NonNullWithJdk {
 	@lombok.NonNull

File: test/transform/resource/after-delombok/NonNullWithSneakyThrows.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class NonNullWithSneakyThrows {
 	void test(@lombok.NonNull String in) {
 		try {

File: test/transform/resource/after-delombok/NullAnnotatedCheckerFrameworkSuperBuilder.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations = checkerframework
 import java.util.List;
 

File: test/transform/resource/after-delombok/SetterOnClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class SetterOnClass1 {
 	boolean isNone;
 	boolean isPublic;

File: test/transform/resource/after-delombok/StaticConstructor.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 public class StaticConstructor {
 	String name;
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/SuperBuilderWithNonNull.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 public class SuperBuilderWithNonNull {
 	public static class Parent {

File: test/transform/resource/after-delombok/WithOnClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class WithOnClass1 {
 	boolean isNone;
 	boolean isPublic;

File: test/transform/resource/before/BuilderSingularNullBehavior1.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations = checkerframework
 //CONF: lombok.nonNull.exceptionType = assertion
 import java.util.List;

File: test/transform/resource/before/BuilderWithNonNull.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 @lombok.Builder
 class BuilderWithNonNull {
 	@lombok.NonNull

File: test/transform/resource/before/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 @lombok.Builder(setterPrefix = "with")
 class BuilderWithNonNullWithSetterPrefix {
 	@lombok.NonNull

File: test/transform/resource/before/ConstructorsWithAccessors.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 @lombok.AllArgsConstructor @lombok.experimental.Accessors(prefix={"p", "_"}) class ConstructorsWithAccessors {
 	int plower;
 	int pUpper;
@@ -11,4 +12,3 @@
 	@lombok.NonNull Integer _huh;
 	@lombok.NonNull final Integer __huh2;
 }
-

File: test/transform/resource/before/DataOnLocalClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import lombok.Data;
 class DataOnLocalClass1 {
 	public static void main(String[] args) {

File: test/transform/resource/before/GetterOnClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 @lombok.Getter
 class GetterOnClass1 {
 	@lombok.Getter(lombok.AccessLevel.NONE)

File: test/transform/resource/before/NonNullOnParameter.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class NonNullOnParameter extends Thread {
 	NonNullOnParameter(@lombok.NonNull String arg) {
 		this(arg, "");

File: test/transform/resource/before/NonNullOnParameterAbstract.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 abstract class NonNullOnParameterAbstract {
 	public void test(@lombok.NonNull String arg) {
 		System.out.println("Hey");

File: test/transform/resource/before/NonNullPlain.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.lang.annotation.*;
 
 @lombok.RequiredArgsConstructor

File: test/transform/resource/before/NonNullWithAlternateException.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.nonNull.exceptionType = IllegalArgumentException
 
 public class NonNullWithAlternateException {

File: test/transform/resource/before/NonNullWithAssertion.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.nonNull.exceptionType = Assertion
 
 public class NonNullWithAssertion {

File: test/transform/resource/before/NonNullWithGuava.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.nonNull.exceptionType = Guava
 import static com.google.common.base.Preconditions.*;
 public class NonNullWithGuava {

File: test/transform/resource/before/NonNullWithJdk.java
Patch:
@@ -1,4 +1,4 @@
-//version 7:
+//version 8:
 //CONF: lombok.nonNull.exceptionType = Jdk
 import static java.util.Objects.*;
 public class NonNullWithJdk {

File: test/transform/resource/before/NonNullWithSneakyThrows.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class NonNullWithSneakyThrows {
 	@lombok.SneakyThrows void test(@lombok.NonNull String in) {
 		System.out.println(in);

File: test/transform/resource/before/NullAnnotatedCheckerFrameworkSuperBuilder.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations = checkerframework
 import java.util.List;
 import lombok.Singular;

File: test/transform/resource/before/SetterOnClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 @lombok.Setter
 class SetterOnClass1 {
 	@lombok.Setter(lombok.AccessLevel.NONE)

File: test/transform/resource/before/StaticConstructor.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 //CONF: lombok.addNullAnnotations = checkerframework
 import lombok.AllArgsConstructor;
 @AllArgsConstructor(staticName = "of")

File: test/transform/resource/before/SuperBuilderWithNonNull.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 import java.util.List;
 
 public class SuperBuilderWithNonNull {

File: test/transform/resource/before/WithOnClass.java
Patch:
@@ -1,3 +1,5 @@
+//version 8:
+
 @lombok.With
 class WithOnClass1 {
 	@lombok.With(lombok.AccessLevel.NONE)

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -83,6 +83,8 @@ protected CompilerOptions ecjCompilerOptions() {
 		warnings.put(CompilerOptions.OPTION_ReportUnusedLabel, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedImport, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, "ignore");
+		warnings.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, "warning");
+		warnings.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, "warning");
 		int ecjVersion = Eclipse.getEcjCompilerVersion();
 		warnings.put(CompilerOptions.OPTION_Source, (ecjVersion < 9 ? "1." : "") + ecjVersion);
 		options.set(warnings);

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2020 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -246,7 +246,7 @@ public static void nonStaticAccessToStaticMethod(ProblemReporter problemReporter
 		MessageSend_postponedErrors.set(messageSend, new PostponedNonStaticAccessToStaticMethodError(problemReporter, location, method));
 	}
 	
-	public static Object resolveType(Object resolvedType, MessageSend methodCall, BlockScope scope) {
+	public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend methodCall, BlockScope scope) {
 		List<Extension> extensions = new ArrayList<Extension>();
 		TypeDeclaration decl = scope.classScope().referenceContext;
 		

File: src/launch/lombok/launch/Main.java
Patch:
@@ -36,7 +36,7 @@ static synchronized ClassLoader getShadowClassLoader() {
 	
 	static synchronized void prependClassLoader(ClassLoader loader) {
 		getShadowClassLoader();
-		classLoader.prepend(loader);
+		classLoader.prependParent(loader);
 	}
 	
 	public static void main(String[] args) throws Throwable {

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -83,6 +83,8 @@ protected CompilerOptions ecjCompilerOptions() {
 		warnings.put(CompilerOptions.OPTION_ReportUnusedLabel, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedImport, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, "ignore");
+		warnings.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, "warning");
+		warnings.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, "warning");
 		int ecjVersion = Eclipse.getEcjCompilerVersion();
 		warnings.put(CompilerOptions.OPTION_Source, (ecjVersion < 9 ? "1." : "") + ecjVersion);
 		options.set(warnings);

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -152,8 +152,9 @@ public void replace() {
 		
 		@Override
 		public Void visitMethodInvocation(final MethodInvocationTree tree, final Void p) {
+			super.visitMethodInvocation(tree, p);
 			handleMethodCall((JCMethodInvocation) tree);
-			return super.visitMethodInvocation(tree, p);
+			return null;
 		}
 		
 		private void handleMethodCall(final JCMethodInvocation methodCall) {

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2020 The Project Lombok Authors.
+ * Copyright (C) 2012-2021 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -246,7 +246,7 @@ public static void nonStaticAccessToStaticMethod(ProblemReporter problemReporter
 		MessageSend_postponedErrors.set(messageSend, new PostponedNonStaticAccessToStaticMethodError(problemReporter, location, method));
 	}
 	
-	public static Object resolveType(Object resolvedType, MessageSend methodCall, BlockScope scope) {
+	public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend methodCall, BlockScope scope) {
 		List<Extension> extensions = new ArrayList<Extension>();
 		TypeDeclaration decl = scope.classScope().referenceContext;
 		

File: src/launch/lombok/launch/Main.java
Patch:
@@ -36,7 +36,7 @@ static synchronized ClassLoader getShadowClassLoader() {
 	
 	static synchronized void prependClassLoader(ClassLoader loader) {
 		getShadowClassLoader();
-		classLoader.prepend(loader);
+		classLoader.prependParent(loader);
 	}
 	
 	public static void main(String[] args) throws Throwable {

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -50,6 +50,7 @@
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldReference;
 import org.eclipse.jdt.internal.compiler.ast.IfStatement;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
@@ -1102,6 +1103,7 @@ private java.util.Set<String> gatherUsedTypeNames(TypeParameter[] typeParams, Ty
 		// 3. Add used type names.
 		if (td.fields != null) {
 			for (FieldDeclaration field : td.fields) {
+				if (field instanceof Initializer) continue; 
 				char[][] typeName = field.type.getTypeName();
 				if (typeName.length >= 1) // Add the first token, because only that can collide.
 					usedNames.add(String.valueOf(typeName[0]));

File: src/delombok/lombok/delombok/DocCommentIntegrator.java
Patch:
@@ -89,7 +89,7 @@ public List<CommentInfo> integrate(List<CommentInfo> comments, JCCompilationUnit
 			((Map<JCTree, String>) map_).put(node, docCommentContent);
 			return true;
 		} else if (Javac.instanceOfDocCommentTable(map_)) {
-			CommentAttacher_8.attach(node, docCommentContent, map_);
+			CommentAttacher_8.attach(node, docCommentContent, cmt.pos, map_);
 			return true;
 		}
 		
@@ -98,15 +98,15 @@ public List<CommentInfo> integrate(List<CommentInfo> comments, JCCompilationUnit
 	
 	/* Container for code which will cause class loader exceptions on javac below 8. By being in a separate class, we avoid the problem. */
 	private static class CommentAttacher_8 {
-		static void attach(final JCTree node, String docCommentContent, Object map_) {
+		static void attach(final JCTree node, String docCommentContent, final int pos, Object map_) {
 			final String docCommentContent_ = docCommentContent;
 			((DocCommentTable) map_).putComment(node, new Comment() {
 				@Override public String getText() {
 					return docCommentContent_;
 				}
 				
 				@Override public int getSourcePos(int index) {
-					return -1;
+					return pos + index;
 				}
 				
 				@Override public CommentStyle getStyle() {

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -47,7 +47,6 @@
 import org.mangosdk.spi.ProviderFor;
 
 import com.sun.tools.javac.code.Flags;
-import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCBinary;
@@ -219,7 +218,7 @@ public void createGetterForField(AccessLevel level,
 		
 		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
 		
-		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod), List.<Type>nil(), getMirrorForFieldType(fieldNode));
+		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source, lazy, onMethod));
 	}
 	
 	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, boolean lazy, List<JCAnnotation> onMethod) {

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -585,7 +585,7 @@ private void generateBuilderBasedConstructor(SuperBuilderJob job, boolean callBu
 			null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(),
 			maker.Block(0L, statements.toList()), null), job.sourceNode);
 		
-		injectMethod(job.parentType, constr, null, Javac.createVoidType(job.builderType.getSymbolTable(), CTC_VOID));
+		injectMethod(job.parentType, constr);
 	}
 	
 	private JCMethodDecl generateBuilderMethod(SuperBuilderJob job) {

File: test/transform/resource/after-delombok/CheckerFrameworkSuperBuilder.java
Patch:
@@ -1,4 +1,3 @@
-// skip-idempotent
 import java.util.List;
 class CheckerFrameworkSuperBuilder {
 	public static class Parent {
@@ -128,7 +127,7 @@ protected Parent(final CheckerFrameworkSuperBuilder.Parent.ParentBuilder<?, ?> b
 		}
 		@org.checkerframework.dataflow.qual.SideEffectFree
 		@java.lang.SuppressWarnings("all")
-		public static CheckerFrameworkSuperBuilder.Parent.ParentBuilder<?, ?> builder() {
+		public static CheckerFrameworkSuperBuilder.Parent.@org.checkerframework.common.aliasing.qual.Unique ParentBuilder<?, ?> builder() {
 			return new CheckerFrameworkSuperBuilder.Parent.ParentBuilderImpl();
 		}
 	}
@@ -211,7 +210,7 @@ protected ZChild(final CheckerFrameworkSuperBuilder.ZChild.ZChildBuilder<?, ?> b
 		}
 		@org.checkerframework.dataflow.qual.SideEffectFree
 		@java.lang.SuppressWarnings("all")
-		public static CheckerFrameworkSuperBuilder.ZChild.ZChildBuilder<?, ?> builder() {
+		public static CheckerFrameworkSuperBuilder.ZChild.@org.checkerframework.common.aliasing.qual.Unique ZChildBuilder<?, ?> builder() {
 			return new CheckerFrameworkSuperBuilder.ZChild.ZChildBuilderImpl();
 		}
 	}

File: src/core/lombok/javac/handlers/HandleBuilderDefault.java
Patch:
@@ -55,6 +55,7 @@ public class HandleBuilderDefault extends JavacAnnotationHandler<Builder.Default
 			JCFieldAccess jfa = (JCFieldAccess) ast.annotationType;
 			if (jfa.selected instanceof JCIdent && ((JCIdent) jfa.selected).name.contentEquals("Builder") && jfa.name.contentEquals("Default")) {
 				JCFieldAccess newJfaSel = annotationNode.getTreeMaker().Select(annotationNode.getTreeMaker().Ident(annotationNode.toName("lombok")), ((JCIdent) jfa.selected).name);
+				recursiveSetGeneratedBy(newJfaSel, annotationNode);
 				jfa.selected = newJfaSel;
 			}
 		}

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -349,7 +349,7 @@ public JCMethodDecl createDelegateMethod(MethodSig sig, JavacNode annotation, Na
 		JCStatement body = useReturn ? maker.Return(delegateCall) : maker.Exec(delegateCall);
 		JCBlock bodyBlock = maker.Block(0, com.sun.tools.javac.util.List.of(body));
 		
-		return recursiveSetGeneratedBy(maker.MethodDef(mods, sig.name, returnType, toList(typeParams), toList(params), toList(thrown), bodyBlock, null), annotation.get(), annotation.getContext());
+		return recursiveSetGeneratedBy(maker.MethodDef(mods, sig.name, returnType, toList(typeParams), toList(params), toList(thrown), bodyBlock, null), annotation);
 	}
 	
 	public static <T> com.sun.tools.javac.util.List<T> toList(ListBuffer<T> collection) {

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -202,6 +202,7 @@ private void handleMethodCall(final JCMethodInvocation methodCall) {
 					if (!types.isAssignable(receiverType, firstArgType)) continue;
 					methodCall.args = methodCall.args.prepend(receiver);
 					methodCall.meth = chainDotsString(annotationNode, extensionProvider.toString() + "." + methodName);
+					recursiveSetGeneratedBy(methodCall.meth, methodCallNode);
 					return;
 				}
 			}

File: src/core/lombok/javac/handlers/HandleHelper.java
Patch:
@@ -71,7 +71,7 @@ private void setStatementsOfJcNode(JCTree tree, List<JCStatement> statements) {
 		else throw new IllegalArgumentException("Can't set statements on node type: " + tree.getClass());
 	}
 	
-	@Override public void handle(AnnotationValues<Helper> annotation, JCAnnotation ast, JavacNode annotationNode) {
+	@Override public void handle(AnnotationValues<Helper> annotation, JCAnnotation ast, final JavacNode annotationNode) {
 		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.HELPER_FLAG_USAGE, "@Helper");
 		
 		deleteAnnotationIfNeccessary(annotationNode, Helper.class);
@@ -120,6 +120,7 @@ private void apply(JCMethodInvocation jcmi) {
 				JCIdent jci = (JCIdent) jcmi.meth;
 				if (Arrays.binarySearch(knownMethodNames_, jci.name.toString()) < 0) return;
 				jcmi.meth = maker.Select(maker.Ident(helperName), jci.name);
+				recursiveSetGeneratedBy(jcmi.meth, annotationNode);
 				helperUsed[0] = true;
 			}
 		};
@@ -144,6 +145,7 @@ private void apply(JCMethodInvocation jcmi) {
 			JCExpression init = maker.NewClass(null, List.<JCExpression>nil(), maker.Ident(annotatedType_.name), List.<JCExpression>nil(), null);
 			JCExpression varType = maker.Ident(annotatedType_.name);
 			JCVariableDecl decl = maker.VarDef(maker.Modifiers(Flags.FINAL), helperName, varType, init);
+			recursiveSetGeneratedBy(decl, annotationNode);
 			newStatements.append(decl);
 		}
 		setStatementsOfJcNode(containingBlock.get(), newStatements.toList());

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -111,7 +111,7 @@ public class HandleNonNull extends JavacAnnotationHandler<NonNull> {
 		// and if they exist, create a new method in the class: 'private static <T> T lombok$nullCheck(T expr, String msg) {if (expr == null) throw NPE; return expr;}' and
 		// wrap all references to it in the super/this to a call to this method.
 		
-		JCStatement nullCheck = recursiveSetGeneratedBy(generateNullCheck(annotationNode.getTreeMaker(), paramNode, annotationNode), ast, annotationNode.getContext());
+		JCStatement nullCheck = recursiveSetGeneratedBy(generateNullCheck(annotationNode.getTreeMaker(), paramNode, annotationNode), annotationNode);
 		
 		if (nullCheck == null) {
 			// @NonNull applied to a primitive. Kinda pointless. Let's generate a warning.

File: src/core/lombok/javac/handlers/HandleUtilityClass.java
Patch:
@@ -146,7 +146,7 @@ private void createPrivateDefaultConstructor(JavacNode typeNode) {
 		Name name = typeNode.toName("<init>");
 		JCBlock block = maker.Block(0L, createThrowStatement(typeNode, maker));
 		JCMethodDecl methodDef = maker.MethodDef(mods, name, null, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), block, null);
-		JCMethodDecl constructor = recursiveSetGeneratedBy(methodDef, typeNode.get(), typeNode.getContext());
+		JCMethodDecl constructor = recursiveSetGeneratedBy(methodDef, typeNode);
 		JavacHandlerUtil.injectMethod(typeNode, constructor, List.<Type>nil(), Javac.createVoidType(typeNode.getSymbolTable(), CTC_VOID));
 	}
 	

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -63,6 +63,7 @@ public void visitLocal(JavacNode localNode, JCVariableDecl local) {
 		JCTree typeTree = local.vartype;
 		if (typeTree == null) return;
 		String typeTreeToString = typeTree.toString();
+		JavacNode typeNode = localNode.getNodeFor(typeTree);
 		
 		if (!(eq(typeTreeToString, "val") || eq(typeTreeToString, "var"))) return;
 		boolean isVal = typeMatches(val.class, localNode, typeTree);
@@ -111,7 +112,7 @@ public void visitLocal(JavacNode localNode, JCVariableDecl local) {
 		if (isVal) local.mods.flags |= Flags.FINAL;
 		
 		if (!localNode.shouldDeleteLombokAnnotations()) {
-			JCAnnotation valAnnotation = recursiveSetGeneratedBy(localNode.getTreeMaker().Annotation(local.vartype, List.<JCExpression>nil()), typeTree, localNode.getContext());
+			JCAnnotation valAnnotation = recursiveSetGeneratedBy(localNode.getTreeMaker().Annotation(local.vartype, List.<JCExpression>nil()), typeNode);
 			local.mods.annotations = local.mods.annotations == null ? List.of(valAnnotation) : local.mods.annotations.append(valAnnotation);
 		}
 		
@@ -182,7 +183,7 @@ public void visitLocal(JavacNode localNode, JCVariableDecl local) {
 			local.vartype = JavacResolution.createJavaLangObject(localNode.getAst());
 			throw e;
 		} finally {
-			recursiveSetGeneratedBy(local.vartype, typeTree, localNode.getContext());
+			recursiveSetGeneratedBy(local.vartype, typeNode);
 		}
 	}
 }

File: src/core/lombok/javac/handlers/HandleValue.java
Patch:
@@ -72,7 +72,6 @@ public class HandleValue extends JavacAnnotationHandler<Value> {
 			JCModifiers jcm = ((JCClassDecl) typeNode.get()).mods;
 			if ((jcm.flags & Flags.FINAL) == 0) {
 				jcm.flags |= Flags.FINAL;
-				typeNode.rebuild();
 			}
 		}
 		handleFieldDefaults.generateFieldDefaultsForType(typeNode, annotationNode, AccessLevel.PRIVATE, true, true);

File: src/core/lombok/javac/handlers/HandleWith.java
Patch:
@@ -215,6 +215,7 @@ public void createWithForField(AccessLevel level, JavacNode fieldNode, JavacNode
 		ClassSymbol sym = ((JCClassDecl) fieldNode.up().get()).sym;
 		Type returnType = sym == null ? null : sym.type;
 		
+		recursiveSetGeneratedBy(createdWith, source);
 		injectMethod(typeNode, createdWith, List.<Type>of(getMirrorForFieldType(fieldNode)), returnType);
 	}
 	
@@ -234,7 +235,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
 		
-		JCExpression pType = cloneType(maker, fieldDecl.vartype, source.get(), source.getContext());
+		JCExpression pType = cloneType(maker, fieldDecl.vartype, source);
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, pType, null);
 		
 		if (!makeAbstract) {
@@ -289,7 +290,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		
 		if (makeAbstract) access = access | Flags.ABSTRACT;
 		JCMethodDecl decl = recursiveSetGeneratedBy(maker.MethodDef(maker.Modifiers(access, annsOnMethod), methodName, returnType,
-			methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source.get(), field.getContext());
+			methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source);
 		copyJavadoc(field, decl, CopyJavadoc.WITH);
 		return decl;
 	}

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSingularizer.java
Patch:
@@ -32,7 +32,6 @@
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
 
-import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCCase;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
@@ -50,7 +49,7 @@ public class JavacJavaUtilListSingularizer extends JavacJavaUtilListSetSingulari
 		return "java.util.Collections.emptyList";
 	}
 	
-	@Override public void appendBuildCode(SingularData data, JavacNode builderType, JCTree source, ListBuffer<JCStatement> statements, Name targetVariableName, String builderVariable) {
+	@Override public void appendBuildCode(SingularData data, JavacNode builderType, JavacNode source, ListBuffer<JCStatement> statements, Name targetVariableName, String builderVariable) {
 		JavacTreeMaker maker = builderType.getTreeMaker();
 		List<JCExpression> jceBlank = List.nil();
 		ListBuffer<JCCase> cases = new ListBuffer<JCCase>();
@@ -94,7 +93,7 @@ public class JavacJavaUtilListSingularizer extends JavacJavaUtilListSetSingulari
 		statements.append(switchStat);
 	}
 	
-	private List<JCStatement> createListCopy(JavacTreeMaker maker, SingularData data, JavacNode builderType, JCTree source, String builderVariable) {
+	private List<JCStatement> createListCopy(JavacTreeMaker maker, SingularData data, JavacNode builderType, JavacNode source, String builderVariable) {
 		List<JCExpression> jceBlank = List.nil();
 		Name thisName = builderType.toName(builderVariable);
 		

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilSetSingularizer.java
Patch:
@@ -29,7 +29,6 @@
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
 
-import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
 import com.sun.tools.javac.util.ListBuffer;
 import com.sun.tools.javac.util.Name;
@@ -46,7 +45,7 @@ public class JavacJavaUtilSetSingularizer extends JavacJavaUtilListSetSingulariz
 		return "java.util.Collections.emptySet";
 	}
 	
-	@Override public void appendBuildCode(SingularData data, JavacNode builderType, JCTree source, ListBuffer<JCStatement> statements, Name targetVariableName, String builderVariable) {
+	@Override public void appendBuildCode(SingularData data, JavacNode builderType, JavacNode source, ListBuffer<JCStatement> statements, Name targetVariableName, String builderVariable) {
 		JavacTreeMaker maker = builderType.getTreeMaker();
 		
 		if (data.getTargetFqn().equals("java.util.Set")) {

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -50,6 +50,7 @@
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldReference;
 import org.eclipse.jdt.internal.compiler.ast.IfStatement;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
@@ -1093,6 +1094,7 @@ private java.util.Set<String> gatherUsedTypeNames(TypeParameter[] typeParams, Ty
 		// 3. Add used type names.
 		if (td.fields != null) {
 			for (FieldDeclaration field : td.fields) {
+				if (field instanceof Initializer) continue; 
 				char[][] typeName = field.type.getTypeName();
 				if (typeName.length >= 1) // Add the first token, because only that can collide.
 					usedNames.add(String.valueOf(typeName[0]));

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -274,7 +274,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * For any class with an {@code @ToString} annotation which extends a class other than {@code java.lang.Object}, should a call to superclass's implementation of {@code toString} be included in the generated method? (Default = skip)
 	 */
-	public static final ConfigurationKey<CallSuperType> TO_STRING_CALL_SUPER = new ConfigurationKey<CallSuperType>("lombok.toString.callSuper", "When generating toString for classes that extend something (other than Object), either automatically take into account superclass implementation (call), or don't (skip), or warn and don't (warn). (default = warn).") {};
+	public static final ConfigurationKey<CallSuperType> TO_STRING_CALL_SUPER = new ConfigurationKey<CallSuperType>("lombok.toString.callSuper", "When generating toString for classes that extend something (other than Object), either automatically take into account superclass implementation (call), or don't (skip), or warn and don't (warn). (default = skip).") {};
 	
 	/**
 	 * lombok configuration: {@code lombok.toString.flagUsage} = {@code WARNING} | {@code ERROR}.

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -2688,7 +2688,7 @@ public static enum CopyJavadoc {
 				String out = getJavadocSection(javadoc, "GETTER");
 				final boolean sectionBased = out != null;
 				if (!sectionBased) {
-					out = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), "@param(?:eter)?\\s+.*");
+					out = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);
 				}
 				return out;
 			}
@@ -2718,7 +2718,7 @@ private static String applySetter(final CompilationUnitDeclaration cu, EclipseNo
 			String out = getJavadocSection(javadoc, sectionName);
 			final boolean sectionBased = out != null;
 			if (!sectionBased) {
-				out = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), "@returns?\\s+.*");
+				out = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);
 			}
 			return shouldReturnThis(node) ? addReturnsThisIfNeeded(out) : out;
 		}

File: test/transform/resource/after-delombok/BuilderJavadoc.java
Patch:
@@ -3,7 +3,6 @@ class BuilderJavadoc<T> {
 	/**
 	 * basic gets only a builder setter.
 	 * @see #getsetwith
-	 *
 	 * @return tag is removed from the setter.
 	 */
 	private final int basic;
@@ -92,7 +91,6 @@ public static <T> BuilderJavadoc.BuilderJavadocBuilder<T> builder() {
 	}
 	/**
 	 * getsetwith gets a builder setter, an instance getter and setter, and a wither.
-	 *
 	 * @return tag is moved to the getter.
 	 */
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-ecj/BuilderJavadoc.java
Patch:
@@ -58,7 +58,6 @@ public BuilderJavadocBuilder<T> predefWithJavadoc(final int x) {
   }
   /**
    * getsetwith gets a builder setter, an instance getter and setter, and a wither.
-   *
    * @return tag is moved to the getter.
    */
   public @java.lang.SuppressWarnings("all") int getGetsetwith() {

File: src/core/lombok/javac/handlers/JavacSingularsRecipes.java
Patch:
@@ -471,7 +471,7 @@ protected JCExpression getSize(JavacTreeMaker maker, JavacNode builderType, Name
 			JCExpression fn = maker.Select(maker.Select(maker.Ident(thisName), name), builderType.toName("size"));
 			JCExpression sizeInvoke = maker.Apply(List.<JCExpression>nil(), fn, List.<JCExpression>nil());
 			if (nullGuard) {
-				JCExpression isNull = maker.Binary(CTC_EQUAL, maker.Select(maker.Ident(thisName), name), maker.Literal(CTC_BOT, 0));
+				JCExpression isNull = maker.Binary(CTC_EQUAL, maker.Select(maker.Ident(thisName), name), maker.Literal(CTC_BOT, null));
 				JCExpression out = maker.Conditional(isNull, maker.Literal(CTC_INT, 0), sizeInvoke);
 				if (parens) return maker.Parens(out);
 				return out;

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -372,7 +372,7 @@ private static void patchRefactorScripts(ScriptManager sm) {
 	}
 	
 	private static void patchCatchReparse(ScriptManager sm) {
-		sm.addScriptIfWitness(OSGI_TYPES, ScriptBuilder.wrapReturnValue()
+		sm.addScript(ScriptBuilder.wrapReturnValue()
 				.target(new MethodTarget("org.eclipse.jdt.core.dom.ASTConverter", "retrieveStartingCatchPosition"))
 				.wrapMethod(new Hook("lombok.launch.PatchFixesHider$PatchFixes", "fixRetrieveStartingCatchPosition", "int", "int", "int"))
 				.transplant().request(StackRequest.RETURN_VALUE, StackRequest.PARAM1).build());

File: src/core/lombok/eclipse/EcjAugments.java
Patch:
@@ -28,6 +28,7 @@
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.core.CompilationUnit;
 import org.eclipse.jdt.internal.core.SourceMethod;
 
@@ -42,13 +43,13 @@ private EcjAugments() {
 	public static final FieldAugment<ASTNode, Boolean> ASTNode_handled = FieldAugment.augment(ASTNode.class, boolean.class, "lombok$handled");
 	public static final FieldAugment<ASTNode, ASTNode> ASTNode_generatedBy = FieldAugment.augment(ASTNode.class, ASTNode.class, "$generatedBy");
 	public static final FieldAugment<Annotation, Boolean> Annotation_applied = FieldAugment.augment(Annotation.class, boolean.class, "lombok$applied");
+	public static final FieldAugment<ICompilationUnit, Map<String, String>> CompilationUnit_javadoc = FieldAugment.augment(ICompilationUnit.class, Map.class, "$javadoc");
 	
 	public static final class EclipseAugments {
 		private EclipseAugments() {
 			// Prevent instantiation
 		}
 		
-		public static final FieldAugment<CompilationUnit, Map<String, String>> CompilationUnit_javadoc = FieldAugment.augment(CompilationUnit.class, Map.class, "$javadoc");
 		public static final FieldAugment<CompilationUnit, ConcurrentMap<String, List<SourceMethod>>> CompilationUnit_delegateMethods = FieldAugment.augment(CompilationUnit.class, ConcurrentMap.class, "$delegateMethods");
 	}
 }

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -2120,10 +2120,10 @@ public static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode,
 		try {
 			JCCompilationUnit cu = ((JCCompilationUnit) from.top().get());
 			String newJavadoc = copyMode.apply(cu, from);
-			if (newJavadoc != null) {
-				if (forceAddReturn) newJavadoc = addReturnsThisIfNeeded(newJavadoc);
-				Javac.setDocComment(cu, to, newJavadoc);
+			if (forceAddReturn) {
+				newJavadoc = addReturnsThisIfNeeded(newJavadoc);
 			}
+			Javac.setDocComment(cu, to, newJavadoc);
 		} catch (Exception ignore) {}
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -916,7 +916,7 @@ private static void patchJavadoc(ScriptManager sm) {
 				.requestExtra(StackRequest.PARAM1)
 				.build());
 		
-		sm.addScriptIfWitness(OSGI_TYPES, ScriptBuilder.replaceMethodCall()
+		sm.addScript(ScriptBuilder.replaceMethodCall()
 				.target(new MethodTarget("org.eclipse.jdt.internal.compiler.ast.TypeDeclaration", "printBody", "java.lang.StringBuffer", "int", "java.lang.StringBuffer"))
 				.methodToReplace(new Hook("org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration", "print", "java.lang.StringBuffer", "int", "java.lang.StringBuffer"))
 				.replacementMethod(new Hook("lombok.launch.PatchFixesHider$Javadoc", "printMethod", "java.lang.StringBuffer", "org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration", "int", "java.lang.StringBuffer", "org.eclipse.jdt.internal.compiler.ast.TypeDeclaration"))

File: src/eclipseAgent/lombok/launch/PatchFixesHider.java
Patch:
@@ -332,7 +332,7 @@ public static final class Javadoc {
 		
 		static {
 			Class<?> shadowed = Util.shadowLoadClass("lombok.eclipse.agent.PatchJavadoc");
-			GET_HTML = Util.findMethod(shadowed, "getHTMLContentFromSource", String.class, IJavaElement.class);
+			GET_HTML = Util.findMethod(shadowed, "getHTMLContentFromSource", String.class, Object.class);
 			PRINT_METHOD = Util.findMethod(shadowed, "printMethod", AbstractMethodDeclaration.class, Integer.class, StringBuffer.class, TypeDeclaration.class);
 		}
 		

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -281,6 +281,7 @@ public static String getDocComment(JCCompilationUnit cu, JCTree node) {
 	
 	@SuppressWarnings("unchecked")
 	public static void setDocComment(JCCompilationUnit cu, JCTree node, String javadoc) {
+		if (javadoc == null) return;
 		Object dc = getDocComments(cu);
 		if (dc instanceof Map) {
 			((Map<JCTree, String>) dc).put(node, javadoc);

File: test/transform/resource/after-delombok/AccessorsConfiguration.java
Patch:
@@ -18,6 +18,9 @@ public void setM_FieldName(final String m_FieldName) {
 }
 class AccessorsConfiguration3 {
 	private String fFieldName = "";
+	/**
+	 * @return {@code this}.
+	 */
 	@java.lang.SuppressWarnings("all")
 	public AccessorsConfiguration3 setFieldName(final String fFieldName) {
 		this.fFieldName = fFieldName;

File: test/transform/resource/after-delombok/BuilderCustomName.java
Patch:
@@ -9,6 +9,9 @@ public static abstract class SimpleTestBuilder<T, C extends BuilderCustomName<T>
 		protected abstract B self();
 		@java.lang.SuppressWarnings("all")
 		public abstract C build();
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public B field(final int field) {
 			this.field = field;

File: test/transform/resource/after-delombok/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -12,6 +12,9 @@ protected static class BuilderSimpleWithSetterPrefixBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		BuilderSimpleWithSetterPrefixBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
 			this.unprefixed = unprefixed;

File: test/transform/resource/after-delombok/BuilderTypeAnnos.java
Patch:
@@ -22,6 +22,9 @@ public static class BuilderTypeAnnosBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderTypeAnnosBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(@TA final List<String> foo) {
 			this.foo = foo;

File: test/transform/resource/after-delombok/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -22,6 +22,9 @@ public static class BuilderTypeAnnosWithSetterPrefixBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderTypeAnnosWithSetterPrefixBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder withFoo(@TA final List<String> foo) {
 			this.foo = foo;

File: test/transform/resource/after-delombok/BuilderWithDeprecated.java
Patch:
@@ -40,6 +40,9 @@ public BuilderWithDeprecated.BuilderWithDeprecatedBuilder dep1(final String dep1
 			this.dep1 = dep1;
 			return this;
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithDeprecated.BuilderWithDeprecatedBuilder dep2(final int dep2) {

File: test/transform/resource/after-delombok/BuilderWithDeprecatedAnnOnly.java
Patch:
@@ -23,6 +23,9 @@ public static class BuilderWithDeprecatedAnnOnlyBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithDeprecatedAnnOnlyBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithDeprecatedAnnOnly.BuilderWithDeprecatedAnnOnlyBuilder dep1(final int dep1) {

File: test/transform/resource/after-delombok/BuilderWithNoBuilderMethod.java
Patch:
@@ -11,6 +11,9 @@ public static class BuilderWithNoBuilderMethodBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithNoBuilderMethodBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final String a) {
 			this.a = a;

File: test/transform/resource/after-delombok/BuilderWithNonNull.java
Patch:
@@ -15,6 +15,9 @@ public static class BuilderWithNonNullBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithNonNullBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNonNull.BuilderWithNonNullBuilder id(@lombok.NonNull final String id) {
 			if (id == null) {

File: test/transform/resource/after-delombok/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -15,6 +15,9 @@ public static class BuilderWithNonNullWithSetterPrefixBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithNonNullWithSetterPrefixBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder withId(@lombok.NonNull final String id) {
 			if (id == null) {

File: test/transform/resource/after-delombok/BuilderWithTolerate.java
Patch:
@@ -14,6 +14,9 @@ public BuilderWithTolerateBuilder value(String s) {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithTolerateBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
 			this.value = value;

File: test/transform/resource/after-delombok/JacksonJsonProperty.java
Patch:
@@ -16,6 +16,9 @@ public static class JacksonJsonPropertyBuilder {
 		@java.lang.SuppressWarnings("all")
 		JacksonJsonPropertyBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@JsonProperty("kebab-case-prop")
 		@JsonSetter(nulls = Nulls.SKIP)
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderSimple.java
Patch:
@@ -11,6 +11,9 @@ public static abstract class ParentBuilder<C extends JacksonizedSuperBuilderSimp
 			protected abstract B self();
 			@java.lang.SuppressWarnings("all")
 			public abstract C build();
+			/**
+			 * @return {@code this}.
+			 */
 			@java.lang.SuppressWarnings("all")
 			public B field1(final int field1) {
 				this.field1 = field1;

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -11,6 +11,9 @@ public static abstract class JacksonizedSuperBuilderWithJsonDeserializeBuilder<C
 		protected abstract B self();
 		@java.lang.SuppressWarnings("all")
 		public abstract C build();
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public B field1(final int field1) {
 			this.field1 = field1;

File: test/transform/resource/after-delombok/NullLibrary1.java
Patch:
@@ -34,6 +34,9 @@ public int hashCode() {
 	public NullLibrary1(final String foo) {
 		this.foo = foo;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@org.eclipse.jdt.annotation.NonNull
 	@java.lang.SuppressWarnings("all")
 	public NullLibrary1 withFoo(final String foo) {

File: test/transform/resource/after-delombok/NullLibrary2.java
Patch:
@@ -35,6 +35,9 @@ public java.lang.String toString() {
 	public NullLibrary2(final String foo) {
 		this.foo = foo;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@org.springframework.lang.NonNull
 	@java.lang.SuppressWarnings("all")
 	public NullLibrary2 withFoo(final String foo) {

File: test/transform/resource/after-delombok/SuperBuilderCustomized.java
Patch:
@@ -77,6 +77,9 @@ public static abstract class ChildBuilder<C extends SuperBuilderCustomized.Child
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public abstract C build();
+			/**
+			 * @return {@code this}.
+			 */
 			@java.lang.SuppressWarnings("all")
 			public B field2(final double field2) {
 				this.field2 = field2;

File: test/transform/resource/after-delombok/SuperBuilderNameClashes.java
Patch:
@@ -85,6 +85,9 @@ public static abstract class CBuilder<C3 extends SuperBuilderNameClashes.C, B ex
 			protected abstract B self();
 			@java.lang.SuppressWarnings("all")
 			public abstract C3 build();
+			/**
+			 * @return {@code this}.
+			 */
 			@java.lang.SuppressWarnings("all")
 			public B c2(final C2 c2) {
 				this.c2 = c2;

File: test/transform/resource/after-delombok/WithMethodAbstract.java
Patch:
@@ -1,5 +1,8 @@
 abstract class WithMethodAbstract {
 	String foo;
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.SuppressWarnings("all")
 	public abstract WithMethodAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecated.java
Patch:
@@ -7,6 +7,9 @@ class WithMethodMarkedDeprecated {
 	int javadoc;
 	WithMethodMarkedDeprecated(int annotation, int javadoc) {
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public WithMethodMarkedDeprecated withAnnotation(final int annotation) {

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecatedAnnOnly.java
Patch:
@@ -3,6 +3,9 @@ class WithMethodMarkedDeprecatedAnnOnly {
 	int annotation;
 	WithMethodMarkedDeprecatedAnnOnly(int annotation) {
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public WithMethodMarkedDeprecatedAnnOnly withAnnotation(final int annotation) {

File: test/transform/resource/after-delombok/WithNested.java
Patch:
@@ -5,6 +5,9 @@ class IAmStaticReally {
 		public IAmStaticReally(final String x) {
 			this.x = x;
 		}
+		/**
+		 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+		 */
 		@java.lang.SuppressWarnings("all")
 		public WithNested.IAmStaticReally withX(final String x) {
 			return this.x == x ? this : new WithNested.IAmStaticReally(x);

File: test/transform/resource/after-delombok/WithWithTypeAnnos.java
Patch:
@@ -14,6 +14,9 @@ class WithWithTypeAnnos {
 	WithWithTypeAnnos(@TA @TB List<String> foo) {
 		this.foo = foo;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.SuppressWarnings("all")
 	public WithWithTypeAnnos withFoo(@TA final List<String> foo) {
 		return this.foo == foo ? this : new WithWithTypeAnnos(foo);

File: test/transform/resource/after-delombok/WitherLegacyStar.java
Patch:
@@ -3,6 +3,9 @@ class WitherLegacyStar {
 	WitherLegacyStar(int i) {
 		this.i = i;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.SuppressWarnings("all")
 	public WitherLegacyStar withI(final int i) {
 		return this.i == i ? this : new WitherLegacyStar(i);

File: test/transform/resource/after-ecj/AccessorsConfiguration.java
Patch:
@@ -24,6 +24,9 @@ class AccessorsConfiguration {
   AccessorsConfiguration3() {
     super();
   }
+  /**
+   * @return {@code this}.
+   */
   public @java.lang.SuppressWarnings("all") AccessorsConfiguration3 setFieldName(final String fFieldName) {
     this.fFieldName = fFieldName;
     return this;

File: test/transform/resource/after-ecj/BuilderCustomName.java
Patch:
@@ -7,6 +7,9 @@ public SimpleTestBuilder() {
     }
     protected abstract @java.lang.SuppressWarnings("all") B self();
     public abstract @java.lang.SuppressWarnings("all") C build();
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") B field(final int field) {
       this.field = field;
       return self();

File: test/transform/resource/after-ecj/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -5,6 +5,9 @@
     @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefixBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
       this.unprefixed = unprefixed;
       return this;

File: test/transform/resource/after-ecj/BuilderTypeAnnos.java
Patch:
@@ -11,6 +11,9 @@
     @java.lang.SuppressWarnings("all") BuilderTypeAnnosBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(final @TA List<String> foo) {
       this.foo = foo;
       return this;

File: test/transform/resource/after-ecj/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -11,6 +11,9 @@
     @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefixBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder withFoo(final @TA List<String> foo) {
       this.foo = foo;
       return this;

File: test/transform/resource/after-ecj/BuilderWithDeprecated.java
Patch:
@@ -18,6 +18,9 @@
       this.dep1 = dep1;
       return this;
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.Deprecated @java.lang.SuppressWarnings("all") BuilderWithDeprecated.BuilderWithDeprecatedBuilder dep2(final int dep2) {
       this.dep2 = dep2;
       return this;

File: test/transform/resource/after-ecj/BuilderWithDeprecatedAnnOnly.java
Patch:
@@ -9,6 +9,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithDeprecatedAnnOnlyBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.Deprecated @java.lang.SuppressWarnings("all") BuilderWithDeprecatedAnnOnly.BuilderWithDeprecatedAnnOnlyBuilder dep1(final int dep1) {
       this.dep1 = dep1;
       return this;

File: test/transform/resource/after-ecj/BuilderWithNoBuilderMethod.java
Patch:
@@ -5,6 +5,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethodBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final String a) {
       this.a = a;
       return this;

File: test/transform/resource/after-ecj/BuilderWithNonNull.java
Patch:
@@ -4,6 +4,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithNonNullBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithNonNull.BuilderWithNonNullBuilder id(final @lombok.NonNull String id) {
       if ((id == null))
           {

File: test/transform/resource/after-ecj/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -4,6 +4,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefixBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder withId(final @lombok.NonNull String id) {
       if ((id == null))
           {

File: test/transform/resource/after-ecj/BuilderWithTolerate.java
Patch:
@@ -9,6 +9,9 @@ public static class BuilderWithTolerateBuilder {
     @java.lang.SuppressWarnings("all") BuilderWithTolerateBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
       this.value = value;
       return this;

File: test/transform/resource/after-ecj/JacksonJsonProperty.java
Patch:
@@ -9,6 +9,9 @@
     @java.lang.SuppressWarnings("all") JacksonJsonPropertyBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @JsonProperty("kebab-case-prop") @JsonSetter(nulls = Nulls.SKIP) @java.lang.SuppressWarnings("all") JacksonJsonProperty.JacksonJsonPropertyBuilder kebabCaseProp(final String kebabCaseProp) {
       this.kebabCaseProp = kebabCaseProp;
       return this;

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderSimple.java
Patch:
@@ -7,6 +7,9 @@ public ParentBuilder() {
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C build();
+      /**
+       * @return {@code this}.
+       */
       public @java.lang.SuppressWarnings("all") B field1(final int field1) {
         this.field1 = field1;
         return self();

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -6,6 +6,9 @@ public JacksonizedSuperBuilderWithJsonDeserializeBuilder() {
     }
     protected abstract @java.lang.SuppressWarnings("all") B self();
     public abstract @java.lang.SuppressWarnings("all") C build();
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") B field1(final int field1) {
       this.field1 = field1;
       return self();

File: test/transform/resource/after-ecj/NullLibrary1.java
Patch:
@@ -1,5 +1,8 @@
 public @lombok.EqualsAndHashCode @lombok.ToString @lombok.AllArgsConstructor class NullLibrary1 {
   @lombok.With String foo;
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @org.eclipse.jdt.annotation.NonNull @java.lang.SuppressWarnings("all") NullLibrary1 withFoo(final String foo) {
     return ((this.foo == foo) ? this : new NullLibrary1(foo));
   }

File: test/transform/resource/after-ecj/NullLibrary2.java
Patch:
@@ -1,5 +1,8 @@
 public @lombok.EqualsAndHashCode @lombok.ToString @lombok.AllArgsConstructor class NullLibrary2 {
   @lombok.With String foo;
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @org.springframework.lang.NonNull @java.lang.SuppressWarnings("all") NullLibrary2 withFoo(final String foo) {
     return ((this.foo == foo) ? this : new NullLibrary2(foo));
   }

File: test/transform/resource/after-ecj/SuperBuilderCustomized.java
Patch:
@@ -62,6 +62,9 @@ public ChildBuilder() {
       }
       protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
+      /**
+       * @return {@code this}.
+       */
       public @java.lang.SuppressWarnings("all") B field2(final double field2) {
         this.field2 = field2;
         return self();

File: test/transform/resource/after-ecj/SuperBuilderNameClashes.java
Patch:
@@ -70,6 +70,9 @@ public CBuilder() {
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C3 build();
+      /**
+       * @return {@code this}.
+       */
       public @java.lang.SuppressWarnings("all") B c2(final C2 c2) {
         this.c2 = c2;
         return self();

File: test/transform/resource/after-ecj/Tolerate.java
Patch:
@@ -25,6 +25,9 @@ public Tolerate2 withPattern(String nameGlob, String extensionGlob) {
   public @java.lang.SuppressWarnings("all") Pattern getPattern() {
     return this.pattern;
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.SuppressWarnings("all") Tolerate2 withPattern(final Pattern pattern) {
     return ((this.pattern == pattern) ? this : new Tolerate2(pattern));
   }

File: test/transform/resource/after-ecj/WithMethodAbstract.java
Patch:
@@ -3,5 +3,8 @@ abstract class WithMethodAbstract {
   WithMethodAbstract() {
     super();
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public abstract @java.lang.SuppressWarnings("all") WithMethodAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-ecj/WithMethodMarkedDeprecated.java
Patch:
@@ -5,6 +5,9 @@ class WithMethodMarkedDeprecated {
   WithMethodMarkedDeprecated(int annotation, int javadoc) {
     super();
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") WithMethodMarkedDeprecated withAnnotation(final int annotation) {
     return ((this.annotation == annotation) ? this : new WithMethodMarkedDeprecated(annotation, this.javadoc));
   }

File: test/transform/resource/after-ecj/WithMethodMarkedDeprecatedAnnOnly.java
Patch:
@@ -4,6 +4,9 @@ class WithMethodMarkedDeprecatedAnnOnly {
   WithMethodMarkedDeprecatedAnnOnly(int annotation) {
     super();
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") WithMethodMarkedDeprecatedAnnOnly withAnnotation(final int annotation) {
     return ((this.annotation == annotation) ? this : new WithMethodMarkedDeprecatedAnnOnly(annotation));
   }

File: test/transform/resource/after-ecj/WithNested.java
Patch:
@@ -1,6 +1,9 @@
 public interface WithNested<Z> {
   @lombok.RequiredArgsConstructor class IAmStaticReally {
     final @lombok.With String x;
+    /**
+     * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+     */
     public @java.lang.SuppressWarnings("all") WithNested.IAmStaticReally withX(final String x) {
       return ((this.x == x) ? this : new WithNested.IAmStaticReally(x));
     }

File: test/transform/resource/after-ecj/WithWithTypeAnnos.java
Patch:
@@ -12,6 +12,9 @@ class WithWithTypeAnnos {
     super();
     this.foo = foo;
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.SuppressWarnings("all") WithWithTypeAnnos withFoo(final @TA List<String> foo) {
     return ((this.foo == foo) ? this : new WithWithTypeAnnos(foo));
   }

File: test/transform/resource/after-ecj/WitherLegacyStar.java
Patch:
@@ -5,6 +5,9 @@ class WitherLegacyStar {
     super();
     this.i = i;
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.SuppressWarnings("all") WitherLegacyStar withI(final int i) {
     return ((this.i == i) ? this : new WitherLegacyStar(i));
   }

File: test/transform/resource/before/BuilderJavadoc.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 import java.util.List;
 
 @lombok.Builder

File: test/transform/resource/before/BuilderWithDeprecated.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 import com.google.common.collect.ImmutableList;
 import lombok.Builder;
 import lombok.Singular;

File: test/transform/resource/before/GetterDeprecated.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 import lombok.Getter;
 class GetterDeprecated {
 	

File: test/transform/resource/before/GetterSetterJavadoc.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 @lombok.Data
 class GetterSetterJavadoc1 {
 	/**

File: test/transform/resource/before/SetterAndWithMethodJavadoc.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 import lombok.With;
 class SetterAndWithMethodJavadoc {
 	/**

File: test/transform/resource/before/SetterDeprecated.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 import lombok.Setter;
 class SetterDeprecated {
 	

File: test/transform/resource/before/WithMethodMarkedDeprecated.java
Patch:
@@ -1,4 +1,3 @@
-//platform !ecj: Javadoc copying not supported on ecj
 import lombok.With;
 
 class WithMethodMarkedDeprecated {

File: test/configuration/src/lombok/core/configuration/TestConfiguration.java
Patch:
@@ -65,8 +65,8 @@ public void testDisplayVerbose() throws Exception {
 		outStream.flush();
 		errStream.flush();
 		
-		String out = new String(rawOut.toByteArray()).replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
-		String err = new String(rawErr.toByteArray()).replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
+		String out = new String(rawOut.toByteArray()).replace('\\', '/').replace("\r", "").replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
+		String err = new String(rawErr.toByteArray()).replace('\\', '/').replace("\r", "").replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
 		
 		checkContent(directory, out, "out");
 		checkContent(directory, err, "err");

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -2120,10 +2120,10 @@ public static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode,
 		try {
 			JCCompilationUnit cu = ((JCCompilationUnit) from.top().get());
 			String newJavadoc = copyMode.apply(cu, from);
-			if (newJavadoc != null) {
-				if (forceAddReturn) newJavadoc = addReturnsThisIfNeeded(newJavadoc);
-				Javac.setDocComment(cu, to, newJavadoc);
+			if (forceAddReturn) {
+				newJavadoc = addReturnsThisIfNeeded(newJavadoc);
 			}
+			Javac.setDocComment(cu, to, newJavadoc);
 		} catch (Exception ignore) {}
 	}
 	

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -281,6 +281,7 @@ public static String getDocComment(JCCompilationUnit cu, JCTree node) {
 	
 	@SuppressWarnings("unchecked")
 	public static void setDocComment(JCCompilationUnit cu, JCTree node, String javadoc) {
+		if (javadoc == null) return;
 		Object dc = getDocComments(cu);
 		if (dc instanceof Map) {
 			((Map<JCTree, String>) dc).put(node, javadoc);

File: test/transform/resource/after-delombok/AccessorsConfiguration.java
Patch:
@@ -18,6 +18,9 @@ public void setM_FieldName(final String m_FieldName) {
 }
 class AccessorsConfiguration3 {
 	private String fFieldName = "";
+	/**
+	 * @return {@code this}.
+	 */
 	@java.lang.SuppressWarnings("all")
 	public AccessorsConfiguration3 setFieldName(final String fFieldName) {
 		this.fFieldName = fFieldName;

File: test/transform/resource/after-delombok/BuilderCustomName.java
Patch:
@@ -9,6 +9,9 @@ public static abstract class SimpleTestBuilder<T, C extends BuilderCustomName<T>
 		protected abstract B self();
 		@java.lang.SuppressWarnings("all")
 		public abstract C build();
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public B field(final int field) {
 			this.field = field;

File: test/transform/resource/after-delombok/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -12,6 +12,9 @@ protected static class BuilderSimpleWithSetterPrefixBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		BuilderSimpleWithSetterPrefixBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
 			this.unprefixed = unprefixed;

File: test/transform/resource/after-delombok/BuilderTypeAnnos.java
Patch:
@@ -22,6 +22,9 @@ public static class BuilderTypeAnnosBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderTypeAnnosBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(@TA final List<String> foo) {
 			this.foo = foo;

File: test/transform/resource/after-delombok/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -22,6 +22,9 @@ public static class BuilderTypeAnnosWithSetterPrefixBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderTypeAnnosWithSetterPrefixBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder withFoo(@TA final List<String> foo) {
 			this.foo = foo;

File: test/transform/resource/after-delombok/BuilderWithDeprecated.java
Patch:
@@ -40,6 +40,9 @@ public BuilderWithDeprecated.BuilderWithDeprecatedBuilder dep1(final String dep1
 			this.dep1 = dep1;
 			return this;
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithDeprecated.BuilderWithDeprecatedBuilder dep2(final int dep2) {

File: test/transform/resource/after-delombok/BuilderWithDeprecatedAnnOnly.java
Patch:
@@ -23,6 +23,9 @@ public static class BuilderWithDeprecatedAnnOnlyBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithDeprecatedAnnOnlyBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithDeprecatedAnnOnly.BuilderWithDeprecatedAnnOnlyBuilder dep1(final int dep1) {

File: test/transform/resource/after-delombok/BuilderWithNoBuilderMethod.java
Patch:
@@ -11,6 +11,9 @@ public static class BuilderWithNoBuilderMethodBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithNoBuilderMethodBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final String a) {
 			this.a = a;

File: test/transform/resource/after-delombok/BuilderWithNonNull.java
Patch:
@@ -15,6 +15,9 @@ public static class BuilderWithNonNullBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithNonNullBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNonNull.BuilderWithNonNullBuilder id(@lombok.NonNull final String id) {
 			if (id == null) {

File: test/transform/resource/after-delombok/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -15,6 +15,9 @@ public static class BuilderWithNonNullWithSetterPrefixBuilder {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithNonNullWithSetterPrefixBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder withId(@lombok.NonNull final String id) {
 			if (id == null) {

File: test/transform/resource/after-delombok/BuilderWithTolerate.java
Patch:
@@ -14,6 +14,9 @@ public BuilderWithTolerateBuilder value(String s) {
 		@java.lang.SuppressWarnings("all")
 		BuilderWithTolerateBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
 			this.value = value;

File: test/transform/resource/after-delombok/JacksonJsonProperty.java
Patch:
@@ -16,6 +16,9 @@ public static class JacksonJsonPropertyBuilder {
 		@java.lang.SuppressWarnings("all")
 		JacksonJsonPropertyBuilder() {
 		}
+		/**
+		 * @return {@code this}.
+		 */
 		@JsonProperty("kebab-case-prop")
 		@JsonSetter(nulls = Nulls.SKIP)
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderSimple.java
Patch:
@@ -11,6 +11,9 @@ public static abstract class ParentBuilder<C extends JacksonizedSuperBuilderSimp
 			protected abstract B self();
 			@java.lang.SuppressWarnings("all")
 			public abstract C build();
+			/**
+			 * @return {@code this}.
+			 */
 			@java.lang.SuppressWarnings("all")
 			public B field1(final int field1) {
 				this.field1 = field1;

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -11,6 +11,9 @@ public static abstract class JacksonizedSuperBuilderWithJsonDeserializeBuilder<C
 		protected abstract B self();
 		@java.lang.SuppressWarnings("all")
 		public abstract C build();
+		/**
+		 * @return {@code this}.
+		 */
 		@java.lang.SuppressWarnings("all")
 		public B field1(final int field1) {
 			this.field1 = field1;

File: test/transform/resource/after-delombok/NullLibrary1.java
Patch:
@@ -34,6 +34,9 @@ public int hashCode() {
 	public NullLibrary1(final String foo) {
 		this.foo = foo;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@org.eclipse.jdt.annotation.NonNull
 	@java.lang.SuppressWarnings("all")
 	public NullLibrary1 withFoo(final String foo) {

File: test/transform/resource/after-delombok/NullLibrary2.java
Patch:
@@ -35,6 +35,9 @@ public java.lang.String toString() {
 	public NullLibrary2(final String foo) {
 		this.foo = foo;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@org.springframework.lang.NonNull
 	@java.lang.SuppressWarnings("all")
 	public NullLibrary2 withFoo(final String foo) {

File: test/transform/resource/after-delombok/SuperBuilderCustomized.java
Patch:
@@ -77,6 +77,9 @@ public static abstract class ChildBuilder<C extends SuperBuilderCustomized.Child
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public abstract C build();
+			/**
+			 * @return {@code this}.
+			 */
 			@java.lang.SuppressWarnings("all")
 			public B field2(final double field2) {
 				this.field2 = field2;

File: test/transform/resource/after-delombok/SuperBuilderNameClashes.java
Patch:
@@ -85,6 +85,9 @@ public static abstract class CBuilder<C3 extends SuperBuilderNameClashes.C, B ex
 			protected abstract B self();
 			@java.lang.SuppressWarnings("all")
 			public abstract C3 build();
+			/**
+			 * @return {@code this}.
+			 */
 			@java.lang.SuppressWarnings("all")
 			public B c2(final C2 c2) {
 				this.c2 = c2;

File: test/transform/resource/after-delombok/WithMethodAbstract.java
Patch:
@@ -1,5 +1,8 @@
 abstract class WithMethodAbstract {
 	String foo;
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.SuppressWarnings("all")
 	public abstract WithMethodAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecated.java
Patch:
@@ -7,6 +7,9 @@ class WithMethodMarkedDeprecated {
 	int javadoc;
 	WithMethodMarkedDeprecated(int annotation, int javadoc) {
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public WithMethodMarkedDeprecated withAnnotation(final int annotation) {

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecatedAnnOnly.java
Patch:
@@ -3,6 +3,9 @@ class WithMethodMarkedDeprecatedAnnOnly {
 	int annotation;
 	WithMethodMarkedDeprecatedAnnOnly(int annotation) {
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public WithMethodMarkedDeprecatedAnnOnly withAnnotation(final int annotation) {

File: test/transform/resource/after-delombok/WithNested.java
Patch:
@@ -5,6 +5,9 @@ class IAmStaticReally {
 		public IAmStaticReally(final String x) {
 			this.x = x;
 		}
+		/**
+		 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+		 */
 		@java.lang.SuppressWarnings("all")
 		public WithNested.IAmStaticReally withX(final String x) {
 			return this.x == x ? this : new WithNested.IAmStaticReally(x);

File: test/transform/resource/after-delombok/WithWithTypeAnnos.java
Patch:
@@ -14,6 +14,9 @@ class WithWithTypeAnnos {
 	WithWithTypeAnnos(@TA @TB List<String> foo) {
 		this.foo = foo;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.SuppressWarnings("all")
 	public WithWithTypeAnnos withFoo(@TA final List<String> foo) {
 		return this.foo == foo ? this : new WithWithTypeAnnos(foo);

File: test/transform/resource/after-delombok/WitherLegacyStar.java
Patch:
@@ -3,6 +3,9 @@ class WitherLegacyStar {
 	WitherLegacyStar(int i) {
 		this.i = i;
 	}
+	/**
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+	 */
 	@java.lang.SuppressWarnings("all")
 	public WitherLegacyStar withI(final int i) {
 		return this.i == i ? this : new WitherLegacyStar(i);

File: test/transform/resource/after-ecj/AccessorsConfiguration.java
Patch:
@@ -24,6 +24,9 @@ class AccessorsConfiguration {
   AccessorsConfiguration3() {
     super();
   }
+  /**
+   * @return {@code this}.
+   */
   public @java.lang.SuppressWarnings("all") AccessorsConfiguration3 setFieldName(final String fFieldName) {
     this.fFieldName = fFieldName;
     return this;

File: test/transform/resource/after-ecj/BuilderCustomName.java
Patch:
@@ -7,6 +7,9 @@ public SimpleTestBuilder() {
     }
     protected abstract @java.lang.SuppressWarnings("all") B self();
     public abstract @java.lang.SuppressWarnings("all") C build();
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") B field(final int field) {
       this.field = field;
       return self();

File: test/transform/resource/after-ecj/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -5,6 +5,9 @@
     @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefixBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
       this.unprefixed = unprefixed;
       return this;

File: test/transform/resource/after-ecj/BuilderTypeAnnos.java
Patch:
@@ -11,6 +11,9 @@
     @java.lang.SuppressWarnings("all") BuilderTypeAnnosBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(final @TA List<String> foo) {
       this.foo = foo;
       return this;

File: test/transform/resource/after-ecj/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -11,6 +11,9 @@
     @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefixBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder withFoo(final @TA List<String> foo) {
       this.foo = foo;
       return this;

File: test/transform/resource/after-ecj/BuilderWithDeprecated.java
Patch:
@@ -18,6 +18,9 @@
       this.dep1 = dep1;
       return this;
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.Deprecated @java.lang.SuppressWarnings("all") BuilderWithDeprecated.BuilderWithDeprecatedBuilder dep2(final int dep2) {
       this.dep2 = dep2;
       return this;

File: test/transform/resource/after-ecj/BuilderWithDeprecatedAnnOnly.java
Patch:
@@ -9,6 +9,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithDeprecatedAnnOnlyBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.Deprecated @java.lang.SuppressWarnings("all") BuilderWithDeprecatedAnnOnly.BuilderWithDeprecatedAnnOnlyBuilder dep1(final int dep1) {
       this.dep1 = dep1;
       return this;

File: test/transform/resource/after-ecj/BuilderWithNoBuilderMethod.java
Patch:
@@ -5,6 +5,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethodBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final String a) {
       this.a = a;
       return this;

File: test/transform/resource/after-ecj/BuilderWithNonNull.java
Patch:
@@ -4,6 +4,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithNonNullBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithNonNull.BuilderWithNonNullBuilder id(final @lombok.NonNull String id) {
       if ((id == null))
           {

File: test/transform/resource/after-ecj/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -4,6 +4,9 @@
     @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefixBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder withId(final @lombok.NonNull String id) {
       if ((id == null))
           {

File: test/transform/resource/after-ecj/BuilderWithTolerate.java
Patch:
@@ -9,6 +9,9 @@ public static class BuilderWithTolerateBuilder {
     @java.lang.SuppressWarnings("all") BuilderWithTolerateBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
       this.value = value;
       return this;

File: test/transform/resource/after-ecj/JacksonJsonProperty.java
Patch:
@@ -9,6 +9,9 @@
     @java.lang.SuppressWarnings("all") JacksonJsonPropertyBuilder() {
       super();
     }
+    /**
+     * @return {@code this}.
+     */
     public @JsonProperty("kebab-case-prop") @JsonSetter(nulls = Nulls.SKIP) @java.lang.SuppressWarnings("all") JacksonJsonProperty.JacksonJsonPropertyBuilder kebabCaseProp(final String kebabCaseProp) {
       this.kebabCaseProp = kebabCaseProp;
       return this;

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderSimple.java
Patch:
@@ -7,6 +7,9 @@ public ParentBuilder() {
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C build();
+      /**
+       * @return {@code this}.
+       */
       public @java.lang.SuppressWarnings("all") B field1(final int field1) {
         this.field1 = field1;
         return self();

File: test/transform/resource/after-ecj/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -6,6 +6,9 @@ public JacksonizedSuperBuilderWithJsonDeserializeBuilder() {
     }
     protected abstract @java.lang.SuppressWarnings("all") B self();
     public abstract @java.lang.SuppressWarnings("all") C build();
+    /**
+     * @return {@code this}.
+     */
     public @java.lang.SuppressWarnings("all") B field1(final int field1) {
       this.field1 = field1;
       return self();

File: test/transform/resource/after-ecj/NullLibrary1.java
Patch:
@@ -1,5 +1,8 @@
 public @lombok.EqualsAndHashCode @lombok.ToString @lombok.AllArgsConstructor class NullLibrary1 {
   @lombok.With String foo;
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @org.eclipse.jdt.annotation.NonNull @java.lang.SuppressWarnings("all") NullLibrary1 withFoo(final String foo) {
     return ((this.foo == foo) ? this : new NullLibrary1(foo));
   }

File: test/transform/resource/after-ecj/NullLibrary2.java
Patch:
@@ -1,5 +1,8 @@
 public @lombok.EqualsAndHashCode @lombok.ToString @lombok.AllArgsConstructor class NullLibrary2 {
   @lombok.With String foo;
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @org.springframework.lang.NonNull @java.lang.SuppressWarnings("all") NullLibrary2 withFoo(final String foo) {
     return ((this.foo == foo) ? this : new NullLibrary2(foo));
   }

File: test/transform/resource/after-ecj/SuperBuilderCustomized.java
Patch:
@@ -62,6 +62,9 @@ public ChildBuilder() {
       }
       protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
+      /**
+       * @return {@code this}.
+       */
       public @java.lang.SuppressWarnings("all") B field2(final double field2) {
         this.field2 = field2;
         return self();

File: test/transform/resource/after-ecj/SuperBuilderNameClashes.java
Patch:
@@ -70,6 +70,9 @@ public CBuilder() {
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C3 build();
+      /**
+       * @return {@code this}.
+       */
       public @java.lang.SuppressWarnings("all") B c2(final C2 c2) {
         this.c2 = c2;
         return self();

File: test/transform/resource/after-ecj/Tolerate.java
Patch:
@@ -25,6 +25,9 @@ public Tolerate2 withPattern(String nameGlob, String extensionGlob) {
   public @java.lang.SuppressWarnings("all") Pattern getPattern() {
     return this.pattern;
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.SuppressWarnings("all") Tolerate2 withPattern(final Pattern pattern) {
     return ((this.pattern == pattern) ? this : new Tolerate2(pattern));
   }

File: test/transform/resource/after-ecj/WithMethodAbstract.java
Patch:
@@ -3,5 +3,8 @@ abstract class WithMethodAbstract {
   WithMethodAbstract() {
     super();
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public abstract @java.lang.SuppressWarnings("all") WithMethodAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-ecj/WithMethodMarkedDeprecated.java
Patch:
@@ -5,6 +5,9 @@ class WithMethodMarkedDeprecated {
   WithMethodMarkedDeprecated(int annotation, int javadoc) {
     super();
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") WithMethodMarkedDeprecated withAnnotation(final int annotation) {
     return ((this.annotation == annotation) ? this : new WithMethodMarkedDeprecated(annotation, this.javadoc));
   }

File: test/transform/resource/after-ecj/WithMethodMarkedDeprecatedAnnOnly.java
Patch:
@@ -4,6 +4,9 @@ class WithMethodMarkedDeprecatedAnnOnly {
   WithMethodMarkedDeprecatedAnnOnly(int annotation) {
     super();
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") WithMethodMarkedDeprecatedAnnOnly withAnnotation(final int annotation) {
     return ((this.annotation == annotation) ? this : new WithMethodMarkedDeprecatedAnnOnly(annotation));
   }

File: test/transform/resource/after-ecj/WithNested.java
Patch:
@@ -1,6 +1,9 @@
 public interface WithNested<Z> {
   @lombok.RequiredArgsConstructor class IAmStaticReally {
     final @lombok.With String x;
+    /**
+     * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+     */
     public @java.lang.SuppressWarnings("all") WithNested.IAmStaticReally withX(final String x) {
       return ((this.x == x) ? this : new WithNested.IAmStaticReally(x));
     }

File: test/transform/resource/after-ecj/WithWithTypeAnnos.java
Patch:
@@ -12,6 +12,9 @@ class WithWithTypeAnnos {
     super();
     this.foo = foo;
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.SuppressWarnings("all") WithWithTypeAnnos withFoo(final @TA List<String> foo) {
     return ((this.foo == foo) ? this : new WithWithTypeAnnos(foo));
   }

File: test/transform/resource/after-ecj/WitherLegacyStar.java
Patch:
@@ -5,6 +5,9 @@ class WitherLegacyStar {
     super();
     this.i = i;
   }
+  /**
+   * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
+   */
   public @java.lang.SuppressWarnings("all") WitherLegacyStar withI(final int i) {
     return ((this.i == i) ? this : new WitherLegacyStar(i));
   }

File: src/utils/lombok/permit/Permit.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-20199 The Project Lombok Authors.
+ * Copyright (C) 2018-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -371,7 +371,7 @@ static class BuilderFieldData {
 				}
 				
 				List<JCTypeParameter> tpOnMethod = jmd.typarams;
-				List<JCTypeParameter> tpOnType = ((JCClassDecl) job.builderType.get()).typarams;
+				List<JCTypeParameter> tpOnType = ((JCClassDecl) job.parentType.get()).typarams;
 				typeArgsForToBuilder = new ArrayList<Name>();
 				
 				for (JCTypeParameter tp : tpOnMethod) {

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethod.java
Patch:
@@ -246,7 +246,7 @@ public static void nonStaticAccessToStaticMethod(ProblemReporter problemReporter
 		MessageSend_postponedErrors.set(messageSend, new PostponedNonStaticAccessToStaticMethodError(problemReporter, location, method));
 	}
 	
-	public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend methodCall, BlockScope scope) {
+	public static Object resolveType(Object resolvedType, MessageSend methodCall, BlockScope scope) {
 		List<Extension> extensions = new ArrayList<Extension>();
 		TypeDeclaration decl = scope.classScope().referenceContext;
 		

File: src/eclipseAgent/lombok/eclipse/agent/PatchJavadoc.java
Patch:
@@ -51,7 +51,9 @@ public static String getHTMLContentFromSource(String original, IJavaElement memb
 			ICompilationUnit iCompilationUnit = sourceMethod.getCompilationUnit();
 			if (iCompilationUnit instanceof CompilationUnit) {
 				CompilationUnit compilationUnit = (CompilationUnit) iCompilationUnit;
+				
 				Map<String, String> docs = CompilationUnit_javadoc.get(compilationUnit);
+				if (docs == null) return null;
 				
 				String signature = getSignature(sourceMethod);
 				String rawJavadoc = docs.get(signature);

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -377,7 +377,6 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 			addConstructorProperties(mods, typeNode, fieldsToParam);
 		}
 		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor));
-		if (getCheckerFrameworkVersion(source).generateUnique()) mods.annotations = mods.annotations.prepend(maker.Annotation(genTypeRef(source, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));
 		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("<init>"),
 			null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(),
 			maker.Block(0L, nullChecks.appendList(assigns).toList()), null), source.get(), typeNode.getContext());
@@ -456,7 +455,6 @@ public JCMethodDecl createStaticConstructor(String name, AccessLevel level, Java
 		JCClassDecl type = (JCClassDecl) typeNode.get();
 		
 		JCModifiers mods = maker.Modifiers(Flags.STATIC | toJavacModifier(level));
-		if (getCheckerFrameworkVersion(typeNode).generateUnique()) mods.annotations = mods.annotations.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));
 		
 		JCExpression returnType, constructorType;
 		
@@ -469,7 +467,9 @@ public JCMethodDecl createStaticConstructor(String name, AccessLevel level, Java
 				typeParams.append(maker.TypeParameter(param.name, param.bounds));
 			}
 		}
-		returnType = namePlusTypeParamsToTypeReference(maker, typeNode, type.typarams);
+		List<JCAnnotation> annsOnReturnType = List.nil();
+		if (getCheckerFrameworkVersion(typeNode).generateUnique()) annsOnReturnType = List.of(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));
+		returnType = namePlusTypeParamsToTypeReference(maker, typeNode, type.typarams, annsOnReturnType);
 		constructorType = namePlusTypeParamsToTypeReference(maker, typeNode, type.typarams);
 		
 		for (JavacNode fieldNode : fields) {

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -234,7 +234,7 @@ public JCMethodDecl createHashCode(JavacNode typeNode, java.util.List<Included<J
 				/* ... 1; */
 				init = maker.Literal(1);
 			}
-			statements.append(maker.VarDef(maker.Modifiers(isEmpty ? finalFlag : 0), resultName, maker.TypeIdent(CTC_INT), init));
+			statements.append(maker.VarDef(maker.Modifiers(isEmpty ? finalFlag : 0L), resultName, maker.TypeIdent(CTC_INT), init));
 		}
 		
 		for (Included<JavacNode, EqualsAndHashCode.Include> member : members) {

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -380,7 +380,7 @@ public List<JCStatement> createLazyGetterBody(JavacTreeMaker maker, JavacNode fi
 		
 		/* java.lang.Object value = this.fieldName.get();*/ {
 			JCExpression valueVarType = genJavaLangTypeRef(fieldNode, "Object");
-			statements.append(maker.VarDef(maker.Modifiers(0), valueName, valueVarType, callGet(fieldNode, createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD))));
+			statements.append(maker.VarDef(maker.Modifiers(0L), valueName, valueVarType, callGet(fieldNode, createFieldAccessor(maker, fieldNode, FieldAccess.ALWAYS_FIELD))));
 		}
 		
 		/* if (value == null) { */ {

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -151,7 +151,7 @@ protected JCExpression getPluralMethodParamType(JavacNode builderType) {
 		
 		JCExpression init = maker.Conditional(isNull, empty, invokeBuild); // this.pluralName == null ? ImmutableX.of() : this.pluralName.build()
 		
-		JCStatement jcs = maker.VarDef(maker.Modifiers(0), data.getPluralName(), varType, init);
+		JCStatement jcs = maker.VarDef(maker.Modifiers(0L), data.getPluralName(), varType, init);
 		statements.append(jcs);
 	}
 

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSingularizer.java
Patch:
@@ -89,7 +89,7 @@ public class JavacJavaUtilListSingularizer extends JavacJavaUtilListSetSingulari
 		JCStatement switchStat = maker.Switch(getSize(maker,  builderType, data.getPluralName(), true, false, builderVariable), cases.toList());
 		JCExpression localShadowerType = chainDotsString(builderType, data.getTargetFqn());
 		localShadowerType = addTypeArgs(1, false, builderType, localShadowerType, data.getTypeArgs(), source);
-		JCStatement varDefStat = maker.VarDef(maker.Modifiers(0), data.getPluralName(), localShadowerType, null);
+		JCStatement varDefStat = maker.VarDef(maker.Modifiers(0L), data.getPluralName(), localShadowerType, null);
 		statements.append(varDefStat);
 		statements.append(switchStat);
 	}

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilSingularizer.java
Patch:
@@ -84,7 +84,7 @@ protected List<JCStatement> createJavaUtilSetMapInitialCapacitySwitchStatements(
 		JCStatement switchStat = maker.Switch(getSize(maker,  builderType, mapMode ? builderType.toName(data.getPluralName() + "$key") : data.getPluralName(), true, false, builderVariable), cases.toList());
 		JCExpression localShadowerType = chainDotsString(builderType, data.getTargetFqn());
 		localShadowerType = addTypeArgs(mapMode ? 2 : 1, false, builderType, localShadowerType, data.getTypeArgs(), source);
-		JCStatement varDefStat = maker.VarDef(maker.Modifiers(0), data.getPluralName(), localShadowerType, null);
+		JCStatement varDefStat = maker.VarDef(maker.Modifiers(0L), data.getPluralName(), localShadowerType, null);
 		return List.of(varDefStat, switchStat);
 	}
 	
@@ -143,7 +143,7 @@ protected List<JCStatement> createJavaUtilSimpleCreationAndFillStatements(JavacT
 			if (defineVar) {
 				JCExpression localShadowerType = chainDotsString(builderType, data.getTargetFqn());
 				localShadowerType = addTypeArgs(mapMode ? 2 : 1, false, builderType, localShadowerType, data.getTypeArgs(), source);
-				createStat = maker.VarDef(maker.Modifiers(0), data.getPluralName(), localShadowerType, constructorCall);
+				createStat = maker.VarDef(maker.Modifiers(0L), data.getPluralName(), localShadowerType, constructorCall);
 			} else {
 				createStat = maker.Exec(maker.Assign(maker.Ident(data.getPluralName()), constructorCall));
 			}
@@ -161,7 +161,7 @@ protected List<JCStatement> createJavaUtilSimpleCreationAndFillStatements(JavacT
 				//   error: method put in interface Map<K#2,V#2> cannot be applied to given types;
 				arg2 = maker.TypeCast(createTypeArgs(2, false, builderType, data.getTypeArgs(), source).get(1), arg2);
 				JCStatement putStatement = maker.Exec(maker.Apply(jceBlank, pluralnameDotPut, List.of(arg1, arg2)));
-				JCStatement forInit = maker.VarDef(maker.Modifiers(0), ivar, maker.TypeIdent(CTC_INT), maker.Literal(CTC_INT, 0));
+				JCStatement forInit = maker.VarDef(maker.Modifiers(0L), ivar, maker.TypeIdent(CTC_INT), maker.Literal(CTC_INT, 0));
 				JCExpression checkExpr = maker.Binary(CTC_LESS_THAN, maker.Ident(ivar), getSize(maker, builderType, keyVarName, nullGuard, true, builderVariable));
 				JCExpression incrementExpr = maker.Unary(CTC_POSTINC, maker.Ident(ivar));
 				fillStat = maker.ForLoop(List.of(forInit), checkExpr, List.of(maker.Exec(incrementExpr)), putStatement);

File: test/transform/resource/before/CheckerFrameworkBasic.java
Patch:
@@ -1,9 +1,10 @@
 //CONF: checkerframework = 4.0
+import lombok.AllArgsConstructor;
 import lombok.Data;
 import lombok.experimental.Accessors;
 import lombok.With;
 
-@Data @Accessors(chain = true)
+@Data @AllArgsConstructor @Accessors(chain = true)
 class CheckerFrameworkBasic {
 	@With private final int x;
 	private final int y;

File: src/core/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -23,7 +23,7 @@
 
 import static lombok.eclipse.Eclipse.*;
 import static lombok.eclipse.handlers.EclipseHandlerUtil.*;
-import static lombok.eclipse.EclipseAugments.ASTNode_handled;
+import static lombok.eclipse.EcjAugments.ASTNode_handled;
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -22,7 +22,7 @@
 package lombok.eclipse.agent;
 
 import static lombok.eclipse.Eclipse.*;
-import static lombok.eclipse.EclipseAugments.*;
+import static lombok.eclipse.EcjAugments.*;
 import static lombok.eclipse.handlers.EclipseHandlerUtil.*;
 
 import java.lang.reflect.Method;
@@ -724,7 +724,7 @@ argName, pos(source),
 	private static void cleanupDelegateMethods(CompilationUnitDeclaration cud) {
 		CompilationUnit compilationUnit = getCompilationUnit(cud);
 		if (compilationUnit != null) {
-			CompilationUnit_delegateMethods.clear(compilationUnit);
+			EclipseAugments.CompilationUnit_delegateMethods.clear(compilationUnit);
 		}
 	}
 	
@@ -819,7 +819,7 @@ private static List<SourceMethod> getDelegateMethods(SourceType sourceType) {
 		if (sourceType != null) {
 			CompilationUnit compilationUnit = getCompilationUnit(sourceType.getCompilationUnit());
 			if (compilationUnit != null) {
-				ConcurrentMap<String, List<SourceMethod>> map = CompilationUnit_delegateMethods.setIfAbsent(compilationUnit, new ConcurrentHashMap<String, List<SourceMethod>>());
+				ConcurrentMap<String, List<SourceMethod>> map = EclipseAugments.CompilationUnit_delegateMethods.setIfAbsent(compilationUnit, new ConcurrentHashMap<String, List<SourceMethod>>());
 				List<SourceMethod> newList = new ArrayList<SourceMethod>();
 				List<SourceMethod> oldList = map.putIfAbsent(sourceType.getTypeQualifiedName(), newList);
 				return oldList != null ? oldList : newList;

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -180,7 +180,8 @@ private FileTester createTester(String fileName) throws IOException {
 		case DELOMBOK:
 			return new RunTestsViaDelombok().createTester(params, file, "javac", params.getVersion());
 		case ECJ:
-			return new RunTestsViaEcj().createTester(params, file, "ecj", params.getVersion());
+			String platform = RunTestsViaEcj.eclipseAvailable() ? "eclipse" : "ecj";
+			return new RunTestsViaEcj().createTester(params, file, platform, params.getVersion());
 		default:
 		case JAVAC:
 			throw new UnsupportedOperationException();

File: test/transform/resource/before/BuilderJavadoc.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 import java.util.List;
 
 @lombok.Builder

File: test/transform/resource/before/BuilderWithDeprecated.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 import com.google.common.collect.ImmutableList;
 import lombok.Builder;
 import lombok.Singular;

File: test/transform/resource/before/DelegateAlreadyImplemented.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 public class DelegateAlreadyImplemented<T> {
 	
 	@lombok.experimental.Delegate

File: test/transform/resource/before/DelegateFlagUsage.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 //conf: lombok.delegate.flagUsage = warning
 //skip compare content: We're just checking if the flagUsage key works.
 public class DelegateFlagUsage {

File: test/transform/resource/before/DelegateGenerics.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 public class DelegateGenerics<T> {
 	@lombok.experimental.Delegate
 	I1<T> target;

File: test/transform/resource/before/DelegateOnGetter.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.Delegate;
 import lombok.Getter;
 

File: test/transform/resource/before/DelegateOnGetterNone.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.AccessLevel;
 import lombok.experimental.Delegate;
 import lombok.Getter;

File: test/transform/resource/before/DelegateOnMethods.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.experimental.Delegate;
 
 abstract class DelegateOnMethods {

File: test/transform/resource/before/DelegateOnStatic.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 //skip compare content
 import lombok.experimental.Delegate;
 import lombok.Getter;

File: test/transform/resource/before/DelegateRecursion.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 //skip compare content: This test is to see if the 'delegate recursion is not supported' error pops up.
 import lombok.experimental.Delegate;
 class DelegateRecursionOuterMost {

File: test/transform/resource/before/DelegateTypesAndExcludes.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.experimental.Delegate;
 class DelegatePlain {
 	@Delegate(types = Bar.class)

File: test/transform/resource/before/DelegateWithDeprecated.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.experimental.Delegate;
 
 class DelegateWithDeprecated {

File: test/transform/resource/before/DelegateWithVarargs.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.experimental.Delegate;
 
 class DelegateWithVarargs {

File: test/transform/resource/before/DelegateWithVarargs2.java
Patch:
@@ -1,3 +1,4 @@
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.experimental.Delegate;
 
 class DelegateWithVarargs2 {

File: test/transform/resource/before/GetterDeprecated.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 import lombok.Getter;
 class GetterDeprecated {
 	
@@ -8,4 +9,4 @@ class GetterDeprecated {
 	 * @deprecated
 	 */
 	@Getter int javadoc;
-}
\ No newline at end of file
+}

File: test/transform/resource/before/GetterSetterJavadoc.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 @lombok.Data
 class GetterSetterJavadoc1 {
 	/**

File: test/transform/resource/before/OnXJava7StyleOn8.java
Patch:
@@ -1,4 +1,4 @@
-//platform ecj
+//platform ecj,eclipse
 //version 8:
 
 public class OnXJava7StyleOn8 {

File: test/transform/resource/before/OnXJava8StyleOn7.java
Patch:
@@ -1,4 +1,4 @@
-//platform ecj
+//platform ecj,eclipse
 //version :7
 
 public class OnXJava8StyleOn7 {

File: test/transform/resource/before/SetterAndWithMethodJavadoc.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 import lombok.With;
 class SetterAndWithMethodJavadoc {
 	/**

File: test/transform/resource/before/SetterDeprecated.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 import lombok.Setter;
 class SetterDeprecated {
 	
@@ -8,4 +9,4 @@ class SetterDeprecated {
 	 * @deprecated
 	 */
 	@Setter int javadoc;
-}
\ No newline at end of file
+}

File: test/transform/resource/before/ValDelegateMethodReference.java
Patch:
@@ -1,4 +1,4 @@
-
+//platform !eclipse: Requires a 'full' eclipse with intialized workspace, and we don't (yet) have that set up properly in the test run.
 import lombok.Getter;
 import lombok.Setter;
 import lombok.experimental.Delegate;

File: test/transform/resource/before/WithMethodMarkedDeprecated.java
Patch:
@@ -1,3 +1,4 @@
+//platform !ecj: Javadoc copying not supported on ecj
 import lombok.With;
 
 class WithMethodMarkedDeprecated {

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -304,7 +304,7 @@ public MethodDeclaration createHashCode(EclipseNode type, Collection<Included<Ec
 				setGeneratedBy(hashCodeCacheRef.receiver, source);
 				EqualExpression cacheNotZero = new EqualExpression(hashCodeCacheRef, makeIntLiteral("0".toCharArray(), source), OperatorIds.NOT_EQUAL);
 				setGeneratedBy(cacheNotZero, source);
-				ReturnStatement returnCache = new ReturnStatement(hashCodeCacheRef, pS, pS);
+				ReturnStatement returnCache = new ReturnStatement(hashCodeCacheRef, pS, pE);
 				setGeneratedBy(returnCache, source);
 				IfStatement ifStatement = new IfStatement(cacheNotZero, returnCache, pS, pE);
 				setGeneratedBy(ifStatement, source);

File: src/core/lombok/EqualsAndHashCode.java
Patch:
@@ -148,7 +148,7 @@ public enum CacheStrategy {
 		NEVER,
 		/**
 		 * Cache the result of the first invocation of {@code hashCode} and use it for subsequent invocations.
-		 * This can improve performance in if all fields used for calculating the {@code hashCode} are immutable
+		 * This can improve performance if all fields used for calculating the {@code hashCode} are immutable
 		 * and thus every invocation of {@code hashCode} will always return the same value.
 		 * <strong>Do not use this if there's <em>any</em> chance that different invocations of {@code hashCode}
 		 * might return different values.</strong>

File: test/transform/resource/after-delombok/EqualsAndHashCodeCache.java
Patch:
@@ -126,7 +126,7 @@ public int hashCode() {
 		return result;
 	}
 }
-class EqualsAndHashCode5 extends EqualsAndHashCode {
+final class EqualsAndHashCode5 extends EqualsAndHashCode {
 	@java.lang.SuppressWarnings("all")
 	private transient int $hashCodeCache = 0;
 	@java.lang.Override

File: src/stubs/com/sun/tools/javac/main/Arguments.java
Patch:
@@ -10,4 +10,7 @@ public class Arguments {
 	public void init(String ownName, String... argv) {}
 	public Map<Option, String> getDeferredFileManagerOptions() { return null; }
 	public boolean validate() { return false; }
+	
+	// JDK15
+	public void init(String ownName, Iterable<String> args) {}
 }

File: test/pretty/resource/before/ThisParameter.java
Patch:
@@ -1,3 +1,4 @@
+// version 9: the 'this' param option exists in java8, but is bugged, in that annotations are not allowed on them, even without a @Target. The only purpose of the this param is annotations, so, boy, isn't that a punch in the face?
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -741,6 +741,7 @@ private MethodDeclaration generateStaticFillValuesMethod(EclipseNode tdParent, S
 		}
 		
 		out.statements = body.isEmpty() ? null : body.toArray(new Statement[0]);
+		out.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);
 		
 		return out;
 	}

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -741,6 +741,7 @@ private MethodDeclaration generateStaticFillValuesMethod(EclipseNode tdParent, S
 		}
 		
 		out.statements = body.isEmpty() ? null : body.toArray(new Statement[0]);
+		out.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);
 		
 		return out;
 	}

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -140,7 +140,7 @@ private ConfigurationKeys() {}
 	 * NB: GWT projects, and probably android projects, should explicitly set this key to {@code true} for the entire project.
 	 * 
 	 * <br>
-	 * <em>BREAKING CHANGE</em>: Starting with lombok v1.16.20, defaults to {@code false} instead of {@code true}, as {@code @ConstructorProperties} requires extra modules in JDK9.
+	 * <em>BREAKING CHANGE</em>: Starting with lombok v1.16.20, defaults to {@code true} instead of {@code false}, as {@code @ConstructorProperties} requires extra modules in JDK9.
 	 * 
 	 * @see ConfigurationKeys#ANY_CONSTRUCTOR_ADD_CONSTRUCTOR_PROPERTIES
 	 * @deprecated Since version 2.0, use {@link #ANY_CONSTRUCTOR_ADD_CONSTRUCTOR_PROPERTIES} instead.

File: test/configuration/src/lombok/core/configuration/TestConfiguration.java
Patch:
@@ -65,8 +65,8 @@ public void testDisplayVerbose() throws Exception {
 		outStream.flush();
 		errStream.flush();
 		
-		String out = new String(rawOut.toByteArray()).replace("\r\n", "\n").replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
-		String err = new String(rawErr.toByteArray()).replace("\r\n", "\n").replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
+		String out = new String(rawOut.toByteArray()).replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
+		String err = new String(rawErr.toByteArray()).replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
 		
 		checkContent(directory, out, "out");
 		checkContent(directory, err, "err");

File: src/stubs/com/sun/tools/javac/code/Symtab.java
Patch:
@@ -5,6 +5,7 @@
 
 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
+import com.sun.tools.javac.code.Symbol.TypeSymbol;
 import com.sun.tools.javac.util.Context;
 
 public class Symtab {
@@ -14,6 +15,7 @@ public class Symtab {
 	public Type objectType;
 	public static Symtab instance(Context context) {return null;}
 	public Type unknownType;
+	public TypeSymbol noSymbol;
 	
 	// JDK 9
 	public ModuleSymbol unnamedModule;

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -285,7 +285,7 @@ private static String trimRight(String in) {
 			endIdx--;
 		}
 		
-		return in.substring(0, endIdx);
+		return in.substring(0, endIdx + 1);
 	}
 	
 	private static String[] removeBlanks(String[] in) {

File: test/transform/resource/after-delombok/GetterSetterJavadoc.java
Patch:
@@ -115,7 +115,7 @@ public int fieldName() {
 	/**
 	 * Some text
 	 * 
-	 * @param fieldName Hello, World5
+	 * @param fieldName Hello, World4
 	 * @return {@code this}.
 	 */
 	@java.lang.SuppressWarnings("all")

File: test/configuration/src/lombok/core/configuration/TestConfiguration.java
Patch:
@@ -65,8 +65,8 @@ public void testDisplayVerbose() throws Exception {
 		outStream.flush();
 		errStream.flush();
 		
-		String out = new String(rawOut.toByteArray()).replace("\r\n", "\n").replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
-		String err = new String(rawErr.toByteArray()).replace("\r\n", "\n").replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
+		String out = new String(rawOut.toByteArray()).replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
+		String err = new String(rawErr.toByteArray()).replace('\\', '/').replaceAll(Pattern.quote(normalizedName) + "|" + Pattern.quote(baseName), "BASE/").trim();
 		
 		checkContent(directory, out, "out");
 		checkContent(directory, err, "err");

File: test/transform/resource/after-delombok/CheckerFrameworkSuperBuilder.java
Patch:
@@ -132,7 +132,7 @@ public static class ZChild extends Parent {
 			return 1;
 		}
 		@java.lang.SuppressWarnings("all")
-		public static abstract class ChildBuilder<C extends CheckerFrameworkSuperBuilder.ZChild, B extends CheckerFrameworkSuperBuilder.ZChild.ZChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
+		public static abstract class ZChildBuilder<C extends CheckerFrameworkSuperBuilder.ZChild, B extends CheckerFrameworkSuperBuilder.ZChild.ZChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
 			@java.lang.SuppressWarnings("all")
 			private boolean a$set;
 			@java.lang.SuppressWarnings("all")
@@ -169,7 +169,7 @@ public java.lang.String toString() {
 			}
 		}
 		@java.lang.SuppressWarnings("all")
-		private static final class ZChildBuilderImpl extends CheckerFrameworkSuperBuilder.ZChild.ZChildBuilder<CheckerFrameworkSuperBuilder.ZChild, CheckerFrameworkSuperBuilder.ZChild.ChildBuilderImpl> {
+		private static final class ZChildBuilderImpl extends CheckerFrameworkSuperBuilder.ZChild.ZChildBuilder<CheckerFrameworkSuperBuilder.ZChild, CheckerFrameworkSuperBuilder.ZChild.ZChildBuilderImpl> {
 			@org.checkerframework.common.aliasing.qual.Unique
 			@java.lang.SuppressWarnings("all")
 			private ZChildBuilderImpl() {

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1205,9 +1205,10 @@ public static void injectMethod(JavacNode typeNode, JCMethodDecl method, List<Ty
 		if (method.getParameters() != null && !method.getParameters().isEmpty()) {
 			ListBuffer<Symbol.VarSymbol> newParams = new ListBuffer<Symbol.VarSymbol>();
 			for (JCTree.JCVariableDecl param : method.getParameters()) {
-				newParams.append(param.sym);
+				if (param.sym != null) newParams.append(param.sym);
 			}
 			params = newParams.toList();
+			if (params.length() != method.getParameters().length()) params = null;
 		}
 
 		fixMethodMirror(typeNode.getContext(), typeNode.getElement(), method.getModifiers().flags, method.getName(), paramTypes, params, returnType);

File: src/delombok/lombok/delombok/PrettyPrinter.java
Patch:
@@ -1614,7 +1614,7 @@ public void visitTypeBoundKind(TypeBoundKind tree) {
 			printAnnotatedType0(tree);
 		} else if (className.endsWith("$JCPackageDecl")) {
 			// Starting with JDK9, this is inside the import list, but we've already printed it. Just ignore it.
-		} else if (className.endsWith(".JCSwitchExpression")) { // Introduced as preview feature in JDK12
+		} else if (className.endsWith("$JCSwitchExpression")) { // Introduced as preview feature in JDK12
 			printSwitchExpression(tree);
 		} else if (className.endsWith("$JCYield")) { // Introduced as preview feature in JDK13, part of switch expressions.
 			printYieldExpression(tree);

File: src/support/lombok/eclipseCreate/CreateEclipseDebugTarget.java
Patch:
@@ -132,13 +132,13 @@ private void epilogue() throws InvalidCommandLineException {
 			if (!entry.getKey().startsWith("conf.")) continue;
 			launchContent.append(File.pathSeparator).append(entry.getValue());
 		}
-		if (bootpath != null) launchContent.append(" -Ddelombok.bootclasspath=" + bootpath + "\"/>\n");
-		launchContent.append("</launchConfiguration>\n");
+		if (bootpath != null) launchContent.append(" -Ddelombok.bootclasspath=" + bootpath);
+		launchContent.append("\"/>\n</launchConfiguration>\n");
 	}
 	
 	private String getBootPath() {
 		String bp = args.get("bootpath");
-		if (bp == null) return null;
+		if (bp == null || bp.isEmpty() || bp.equals("0")) return null;
 		File f = new File(bp);
 		if (!f.isAbsolute()) return bp;
 		String r = new File(".").getAbsolutePath();

File: test/core/src/lombok/TestJavac.java
Patch:
@@ -26,7 +26,6 @@
 import org.junit.runners.Suite.SuiteClasses;
 
 @RunWith(Suite.class)
-//@SuiteClasses({lombok.bytecode.RunBytecodeTests.class, lombok.transform.TestLombokFilesIdempotent.class, lombok.transform.TestSourceFiles.class, lombok.transform.TestWithDelombok.class})
-@SuiteClasses({lombok.transform.TestLombokFilesIdempotent.class})
+@SuiteClasses({lombok.bytecode.RunBytecodeTests.class, lombok.transform.TestLombokFilesIdempotent.class, lombok.transform.TestSourceFiles.class, lombok.transform.TestWithDelombok.class})
 public class TestJavac {
 }

File: src/stubs/com/sun/tools/javac/code/Symbol.java
Patch:
@@ -18,6 +18,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
+import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.Name;
 
 public abstract class Symbol implements Element {
@@ -41,6 +42,7 @@ public abstract class Symbol implements Element {
 	public static abstract class TypeSymbol extends Symbol {}
 	
 	public static class MethodSymbol extends Symbol implements ExecutableElement {
+		public List<Symbol.VarSymbol> params = null;
 		public MethodSymbol(long flags, Name name, Type type, Symbol owner) {}
 		@Override public ElementKind getKind() { return null; }
 		@Override public Set<Modifier> getModifiers() { return null; }

File: src/utils/lombok/eclipse/Eclipse.java
Patch:
@@ -29,7 +29,7 @@
 
 import lombok.core.ClassLiteral;
 import lombok.core.FieldSelect;
-import lombok.core.handlers.HandlerUtil;
+import lombok.core.JavaIdentifiers;
 import lombok.permit.Permit;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -164,7 +164,7 @@ public static Annotation[] findAnnotations(AbstractVariableDeclaration field, Pa
 	 */
 	public static boolean isPrimitive(TypeReference ref) {
 		if (ref.dimensions() > 0) return false;
-		return HandlerUtil.isPrimitive(toQualifiedName(ref.getTypeName()));
+		return JavaIdentifiers.isPrimitive(toQualifiedName(ref.getTypeName()));
 	}
 	
 	/**

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -57,7 +57,7 @@
 
 import lombok.core.ClassLiteral;
 import lombok.core.FieldSelect;
-import lombok.core.handlers.HandlerUtil;
+import lombok.core.JavaIdentifiers;
 import lombok.javac.JavacTreeMaker.TreeTag;
 import lombok.javac.JavacTreeMaker.TypeTag;
 import lombok.permit.Permit;
@@ -133,7 +133,7 @@ public static boolean instanceOfDocCommentTable(Object o) {
 	 * expression) represents a primitive type.
 	 */
 	public static boolean isPrimitive(JCExpression ref) {
-		return HandlerUtil.isPrimitive(ref.toString());
+		return JavaIdentifiers.isPrimitive(ref.toString());
 	}
 	
 	/**

File: test/transform/resource/after-ecj/SimpleTypeResolution.java
Patch:
@@ -1,11 +1,13 @@
 class SimpleTypeResolutionFail {
   private @Getter int x;
   SimpleTypeResolutionFail() {
+    super();
   }
 }
 class SimpleTypeResolutionSuccess {
   private @lombok.Getter int x;
   SimpleTypeResolutionSuccess() {
+    super();
   }
   public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -321,6 +321,8 @@ private static void fillMethodBindingsForMethods(CompilationUnitDeclaration cud,
 	
 	private static boolean isDelegate(Annotation ann, TypeDeclaration decl) {
 		if (ann.type == null) return false;
+		if (!charArrayEquals("Delegate", ann.type.getLastToken())) return false;
+		
 		TypeBinding tb = ann.type.resolveType(decl.initializerScope);
 		if (tb == null) return false;
 		if (!charArrayEquals("lombok", tb.qualifiedPackageName()) && !charArrayEquals("lombok.experimental", tb.qualifiedPackageName())) return false;

File: src/utils/lombok/javac/java8/CommentCollectingTokenizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2019 The Project Lombok Authors.
+ * Copyright (C) 2013-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -59,7 +59,7 @@ int pos() {
 	@Override public Token readToken() {
 		Token token = super.readToken();
 		prevEndPosition = pos();
-		if (textBlockStarts != null && (prevEndPosition - token.pos > 5) && token.getClass().getSimpleName().equals("StringToken")) {
+		if (textBlockStarts != null && (prevEndPosition - token.pos > 5) && token.getClass().getName().endsWith("$StringToken")) {
 			char[] start = reader.getRawCharacters(token.pos, token.pos + 3);
 			if (start[0] == '"' && start[1] == '"' && start[2] == '"') textBlockStarts.add(token.pos);
 		}

File: src/core/lombok/eclipse/handlers/HandleUtilityClass.java
Patch:
@@ -113,7 +113,7 @@ private void changeModifiersAndGenerateConstructor(EclipseNode typeNode, Eclipse
 		if (typeNode.up().getKind() == Kind.COMPILATION_UNIT) markStatic = false;
 		if (markStatic && typeNode.up().getKind() == Kind.TYPE) {
 			TypeDeclaration typeDecl = (TypeDeclaration) typeNode.up().get();
-			if ((typeDecl.modifiers & (ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation | ClassFileConstants.AccEnum)) != 0) markStatic = false;
+			if ((typeDecl.modifiers & (ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation)) != 0) markStatic = false;
 		}
 		
 		if (markStatic) classDecl.modifiers |= ClassFileConstants.AccStatic;

File: src/core/lombok/javac/handlers/HandleUtilityClass.java
Patch:
@@ -110,7 +110,7 @@ private void changeModifiersAndGenerateConstructor(JavacNode typeNode, JavacNode
 		if (typeNode.up().getKind() == Kind.COMPILATION_UNIT) markStatic = false;
 		if (markStatic && typeNode.up().getKind() == Kind.TYPE) {
 			JCClassDecl typeDecl = (JCClassDecl) typeNode.up().get();
-			if ((typeDecl.mods.flags & (Flags.INTERFACE | Flags.ANNOTATION | Flags.ENUM)) != 0) markStatic = false;
+			if ((typeDecl.mods.flags & (Flags.INTERFACE | Flags.ANNOTATION)) != 0) markStatic = false;
 		}
 		
 		if (markStatic) classDecl.mods.flags |= Flags.STATIC;

File: src/core/lombok/EqualsAndHashCode.java
Patch:
@@ -125,7 +125,9 @@
 
 		/**
 		 * Higher ranks are considered first. Members of the same rank are considered in the order they appear in the source file.
-		 *
+		 * 
+		 * If not explicitly set, the {@code default} rank for primitives is 1000.
+		 * 
 		 * @return ordering within the generating {@code equals} and {@code hashCode} methods; higher numbers are considered first.
 		 */
 		int rank() default 0;

File: src/core/lombok/core/LombokNode.java
Patch:
@@ -288,6 +288,7 @@ public boolean isStructurallySignificant() {
 	public abstract boolean isStatic();
 	public abstract boolean isFinal();
 	public abstract boolean isTransient();
+	public abstract boolean isPrimitive();
 	public abstract boolean isEnumMember();
 	public abstract boolean isEnumType();
 	

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -485,7 +485,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 			List<Included<EclipseNode, ToString.Include>> fieldNodes = new ArrayList<Included<EclipseNode, ToString.Include>>();
 			for (BuilderFieldData bfd : builderFields) {
 				for (EclipseNode f : bfd.createdFields) {
-					fieldNodes.add(new Included<EclipseNode, ToString.Include>(f, null, true));
+					fieldNodes.add(new Included<EclipseNode, ToString.Include>(f, null, true, false));
 				}
 			}
 			MethodDeclaration md = HandleToString.createToString(builderType, fieldNodes, true, false, ast, FieldAccess.ALWAYS_FIELD);

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -354,7 +354,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec
 			List<Included<EclipseNode, ToString.Include>> fieldNodes = new ArrayList<Included<EclipseNode, ToString.Include>>();
 			for (BuilderFieldData bfd : builderFields) {
 				for (EclipseNode f : bfd.createdFields) {
-					fieldNodes.add(new Included<EclipseNode, ToString.Include>(f, null, true));
+					fieldNodes.add(new Included<EclipseNode, ToString.Include>(f, null, true, false));
 				}
 			}
 			// Let toString() call super.toString() if there is a superclass, so that it also shows fields from the superclass' builder.

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -435,7 +435,7 @@ static class BuilderFieldData {
 			java.util.List<Included<JavacNode, ToString.Include>> fieldNodes = new ArrayList<Included<JavacNode, ToString.Include>>();
 			for (BuilderFieldData bfd : builderFields) {
 				for (JavacNode f : bfd.createdFields) {
-					fieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true));
+					fieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true, false));
 				}
 			}
 			

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -304,7 +304,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,
 		java.util.List<Included<JavacNode, ToString.Include>> fieldNodes = new ArrayList<Included<JavacNode, ToString.Include>>();
 		for (BuilderFieldData bfd : builderFields) {
 			for (JavacNode f : bfd.createdFields) {
-				fieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true));
+				fieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true, false));
 			}
 		}
 		

File: test/transform/resource/after-delombok/EqualsAndHashCodeRank.java
Patch:
@@ -9,9 +9,9 @@ public boolean equals(final java.lang.Object o) {
 		if (!(o instanceof EqualsAndHashCodeRank)) return false;
 		final EqualsAndHashCodeRank other = (EqualsAndHashCodeRank) o;
 		if (!other.canEqual((java.lang.Object) this)) return false;
-		if (this.b != other.b) return false;
 		if (this.a != other.a) return false;
 		if (this.c != other.c) return false;
+		if (this.b != other.b) return false;
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
@@ -23,9 +23,9 @@ protected boolean canEqual(final java.lang.Object other) {
 	public int hashCode() {
 		final int PRIME = 59;
 		int result = 1;
-		result = result * PRIME + this.b;
 		result = result * PRIME + this.a;
 		result = result * PRIME + this.c;
+		result = result * PRIME + this.b;
 		return result;
 	}
-}
+}
\ No newline at end of file

File: src/core/lombok/javac/handlers/HandleWith.java
Patch:
@@ -234,7 +234,7 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
 		
-		JCExpression pType = cloneType(treeMaker, fieldDecl.vartype, source.get(), source.getContext());
+		JCExpression pType = cloneType(maker, fieldDecl.vartype, source.get(), source.getContext());
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, pType, null);
 		
 		if (!makeAbstract) {

File: src/core/lombok/javac/handlers/HandleWith.java
Patch:
@@ -234,7 +234,8 @@ public JCMethodDecl createWith(long access, JavacNode field, JavacTreeMaker make
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
 		
-		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, fieldDecl.vartype, null);
+		JCExpression pType = cloneType(treeMaker, fieldDecl.vartype, source.get(), source.getContext());
+		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, pType, null);
 		
 		if (!makeAbstract) {
 			ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -314,11 +314,11 @@ public static int primeForNull() {
 		COPY_TO_SETTER_ANNOTATIONS = Collections.unmodifiableList(Arrays.asList(new String[] {
 			"com.fasterxml.jackson.annotation.JsonProperty",
 			"com.fasterxml.jackson.annotation.JsonSetter",
-			"com.fasterxml.jackson.annotation.JsonDeserialize",
 			"com.fasterxml.jackson.annotation.JsonIgnore",
 			"com.fasterxml.jackson.annotation.JsonAlias",
 			"com.fasterxml.jackson.annotation.JsonView",
 			"com.fasterxml.jackson.annotation.JacksonInject",
+			"com.fasterxml.jackson.databind.annotation.JsonDeserialize",
 			"com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty",
 		}));
 		COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS = Collections.unmodifiableList(Arrays.asList(new String[] {

File: src/core/lombok/eclipse/handlers/HandleFieldNameConstants.java
Patch:
@@ -136,9 +136,8 @@ private void createInnerTypeFieldNameConstants(EclipseNode typeNode, EclipseNode
 		EclipseNode fieldsType = findInnerClass(typeNode, innerTypeName.getName());
 		boolean genConstr = false, genClinit = false;
 		char[] name = innerTypeName.getCharArray();
-		TypeDeclaration generatedInnerType = null;
 		if (fieldsType == null) {
-			generatedInnerType = new TypeDeclaration(parent.compilationResult);
+			TypeDeclaration generatedInnerType = new TypeDeclaration(parent.compilationResult);
 			generatedInnerType.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
 			generatedInnerType.modifiers = toEclipseModifier(level) | (asEnum ? ClassFileConstants.AccEnum : (ClassFileConstants.AccStatic | ClassFileConstants.AccFinal));
 			generatedInnerType.name = name;
@@ -194,6 +193,7 @@ private void createInnerTypeFieldNameConstants(EclipseNode typeNode, EclipseNode
 				ac.sourceEnd = source.sourceEnd;
 				constantField.initialization = ac;
 				constantField.modifiers = 0;
+				((TypeDeclaration) fieldsType.get()).enumConstantsCounter++;
 			} else {
 				constantField.type = new QualifiedTypeReference(TypeConstants.JAVA_LANG_STRING, new long[] {p, p, p});
 				constantField.initialization = new StringLiteral(field.name, pS, pE, 0);

File: src/installer/lombok/installer/IdeLocation.java
Patch:
@@ -66,7 +66,7 @@ public static String canonical(File p) {
 	}
 	
 	private static final String LEGAL_PATH_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_/";
-	private static final String LEGAL_PATH_CHARS_WINDOWS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_/:\\ ";
+	private static final String LEGAL_PATH_CHARS_WINDOWS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,/;'[]{}!@#$^&()-_+= :\\";
 	public static String escapePath(String path) {
 		StringBuilder out = new StringBuilder();
 		String legalChars = OsUtils.getOS() == OsUtils.OS.UNIX ? LEGAL_PATH_CHARS : LEGAL_PATH_CHARS_WINDOWS; 

File: test/transform/resource/before/TypeUseAnnotations.java
Patch:
@@ -8,4 +8,6 @@
 }
 class TypeUseAnnotations {
 	@lombok.Getter List<@TA(x=5) String> foo;
+	@lombok.Getter List<TypeUseAnnotations.@TA(x=5) Inner> bar;
+	class Inner { }
 }

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -321,8 +321,9 @@ private static boolean sclFileContainsSuffix(InputStream in, String suffix) thro
 	}
 	
 	private static String urlDecode(String in) {
+		final String plusFixed = in.replaceAll("\\+", "%2B");
 		try {
-			return URLDecoder.decode(in, "UTF-8");
+			return URLDecoder.decode(plusFixed, "UTF-8");
 		} catch (UnsupportedEncodingException e) {
 			throw new InternalError("UTF-8 not supported");
 		}

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -242,7 +242,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec
 			String superclassBuilderClassName = builderClassNameTemplate.replace("*", superclassClassName);
 			
 			char[][] tokens = Arrays.copyOf(qualifiedTypeReference.tokens, qualifiedTypeReference.tokens.length + 1);
-			tokens[tokens.length] = superclassBuilderClassName.toCharArray();
+			tokens[tokens.length-1] = superclassBuilderClassName.toCharArray();
 			long[] poss = new long[tokens.length];
 			Arrays.fill(poss, p);
 			

File: test/transform/resource/after-delombok/SuperBuilderBasic.java
Patch:
@@ -81,10 +81,10 @@ protected Parent(final SuperBuilderBasic.Parent.ParentBuilder<?, ?> b) {
 			return new SuperBuilderBasic.Parent.ParentBuilderImpl();
 		}
 	}
-	public static class Child extends Parent {
+	public static class Child extends SuperBuilderBasic.Parent {
 		double field3;
 		@java.lang.SuppressWarnings("all")
-		public static abstract class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
+		public static abstract class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends SuperBuilderBasic.Parent.ParentBuilder<C, B> {
 			@java.lang.SuppressWarnings("all")
 			private double field3;
 			@java.lang.Override

File: test/transform/resource/after-ecj/SuperBuilderBasic.java
Patch:
@@ -71,8 +71,8 @@ private ParentBuilderImpl() {
       return new SuperBuilderBasic.Parent.ParentBuilderImpl();
     }
   }
-  public static @lombok.experimental.SuperBuilder class Child extends Parent {
-    public static abstract @java.lang.SuppressWarnings("all") class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
+  public static @lombok.experimental.SuperBuilder class Child extends SuperBuilderBasic.Parent {
+    public static abstract @java.lang.SuppressWarnings("all") class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends SuperBuilderBasic.Parent.ParentBuilder<C, B> {
       private @java.lang.SuppressWarnings("all") double field3;
       public ChildBuilder() {
         super();

File: test/transform/resource/before/SuperBuilderBasic.java
Patch:
@@ -8,7 +8,7 @@ public static class Parent {
 	}
 	
 	@lombok.experimental.SuperBuilder
-	public static class Child extends Parent {
+	public static class Child extends SuperBuilderBasic.Parent {
 		double field3;
 	}
 	

File: test/transform/resource/before/TypeUseAnnotations.java
Patch:
@@ -8,4 +8,6 @@
 }
 class TypeUseAnnotations {
 	@lombok.Getter List<@TA(x=5) String> foo;
+	@lombok.Getter List<TypeUseAnnotations.@TA(x=5) Inner> bar;
+	class Inner { }
 }

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -321,8 +321,9 @@ private static boolean sclFileContainsSuffix(InputStream in, String suffix) thro
 	}
 	
 	private static String urlDecode(String in) {
+		final String plusFixed = in.replaceAll("\\+", "%2B");
 		try {
-			return URLDecoder.decode(in, "UTF-8");
+			return URLDecoder.decode(plusFixed, "UTF-8");
 		} catch (UnsupportedEncodingException e) {
 			throw new InternalError("UTF-8 not supported");
 		}

File: test/transform/resource/after-delombok/SuperBuilderBasic.java
Patch:
@@ -81,10 +81,10 @@ protected Parent(final SuperBuilderBasic.Parent.ParentBuilder<?, ?> b) {
 			return new SuperBuilderBasic.Parent.ParentBuilderImpl();
 		}
 	}
-	public static class Child extends Parent {
+	public static class Child extends SuperBuilderBasic.Parent {
 		double field3;
 		@java.lang.SuppressWarnings("all")
-		public static abstract class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
+		public static abstract class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends SuperBuilderBasic.Parent.ParentBuilder<C, B> {
 			@java.lang.SuppressWarnings("all")
 			private double field3;
 			@java.lang.Override

File: test/transform/resource/after-ecj/SuperBuilderBasic.java
Patch:
@@ -71,8 +71,8 @@ private ParentBuilderImpl() {
       return new SuperBuilderBasic.Parent.ParentBuilderImpl();
     }
   }
-  public static @lombok.experimental.SuperBuilder class Child extends Parent {
-    public static abstract @java.lang.SuppressWarnings("all") class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends Parent.ParentBuilder<C, B> {
+  public static @lombok.experimental.SuperBuilder class Child extends SuperBuilderBasic.Parent {
+    public static abstract @java.lang.SuppressWarnings("all") class ChildBuilder<C extends SuperBuilderBasic.Child, B extends SuperBuilderBasic.Child.ChildBuilder<C, B>> extends SuperBuilderBasic.Parent.ParentBuilder<C, B> {
       private @java.lang.SuppressWarnings("all") double field3;
       public ChildBuilder() {
         super();

File: test/transform/resource/before/SuperBuilderBasic.java
Patch:
@@ -8,7 +8,7 @@ public static class Parent {
 	}
 	
 	@lombok.experimental.SuperBuilder
-	public static class Child extends Parent {
+	public static class Child extends SuperBuilderBasic.Parent {
 		double field3;
 	}
 	

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -242,7 +242,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec
 			String superclassBuilderClassName = builderClassNameTemplate.replace("*", superclassClassName);
 			
 			char[][] tokens = Arrays.copyOf(qualifiedTypeReference.tokens, qualifiedTypeReference.tokens.length + 1);
-			tokens[tokens.length] = superclassBuilderClassName.toCharArray();
+			tokens[tokens.length-1] = superclassBuilderClassName.toCharArray();
 			long[] poss = new long[tokens.length];
 			Arrays.fill(poss, p);
 			

File: src/core/lombok/eclipse/handlers/HandleUtilityClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Project Lombok Authors.
+ * Copyright (C) 2015-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -113,7 +113,7 @@ private void changeModifiersAndGenerateConstructor(EclipseNode typeNode, Eclipse
 		if (typeNode.up().getKind() == Kind.COMPILATION_UNIT) markStatic = false;
 		if (markStatic && typeNode.up().getKind() == Kind.TYPE) {
 			TypeDeclaration typeDecl = (TypeDeclaration) typeNode.up().get();
-			if ((typeDecl.modifiers & ClassFileConstants.AccInterface) != 0) markStatic = false;
+			if ((typeDecl.modifiers & (ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation | ClassFileConstants.AccEnum)) != 0) markStatic = false;
 		}
 		
 		if (markStatic) classDecl.modifiers |= ClassFileConstants.AccStatic;

File: src/core/lombok/javac/handlers/HandleUtilityClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Project Lombok Authors.
+ * Copyright (C) 2015-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -110,7 +110,7 @@ private void changeModifiersAndGenerateConstructor(JavacNode typeNode, JavacNode
 		if (typeNode.up().getKind() == Kind.COMPILATION_UNIT) markStatic = false;
 		if (markStatic && typeNode.up().getKind() == Kind.TYPE) {
 			JCClassDecl typeDecl = (JCClassDecl) typeNode.up().get();
-			if ((typeDecl.mods.flags & Flags.INTERFACE) != 0) markStatic = false;
+			if ((typeDecl.mods.flags & (Flags.INTERFACE | Flags.ANNOTATION | Flags.ENUM)) != 0) markStatic = false;
 		}
 		
 		if (markStatic) classDecl.mods.flags |= Flags.STATIC;

File: src/core/lombok/core/LombokNode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2018 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -286,6 +286,7 @@ public boolean isStructurallySignificant() {
 	public abstract <Z extends Annotation> AnnotationValues<Z> findAnnotation(Class<Z> type);
 	
 	public abstract boolean isStatic();
+	public abstract boolean isFinal();
 	public abstract boolean isTransient();
 	public abstract boolean isEnumMember();
 	public abstract boolean isEnumType();

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -824,7 +824,7 @@ public MethodDeclaration createCanEqual(EclipseNode type, ASTNode source, List<A
 		setGeneratedBy(returnStatement, source);
 		
 		method.statements = new Statement[] {returnStatement};
-		if (getCheckerFrameworkVersion(type).generateSideEffectFree()) method.annotations = new Annotation[] { generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE) };
+		if (getCheckerFrameworkVersion(type).generatePure()) method.annotations = new Annotation[] { generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__PURE) };
 		return method;
 	}
 

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -785,7 +785,7 @@ private MethodDeclaration generateAbstractSelfMethod(CheckerFrameworkVersion cfv
 		out.modifiers = ClassFileConstants.AccAbstract | ClassFileConstants.AccProtected | ExtraCompilerModifiers.AccSemicolonBody;
 		Annotation overrideAnn = override ? makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, tdParent.get()) : null;
 		Annotation rrAnn = cfv.generateReturnsReceiver() ? generateNamedAnnotation(tdParent.get(), CheckerFrameworkVersion.NAME__RETURNS_RECEIVER): null;
-		Annotation sefAnn = cfv.generateSideEffectFree() ? generateNamedAnnotation(tdParent.get(), CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE): null;
+		Annotation sefAnn = cfv.generatePure() ? generateNamedAnnotation(tdParent.get(), CheckerFrameworkVersion.NAME__PURE): null;
 		if (overrideAnn != null && rrAnn != null && sefAnn != null) out.annotations = new Annotation[] {overrideAnn, rrAnn, sefAnn};
 		else if (overrideAnn != null && rrAnn != null) out.annotations = new Annotation[] {overrideAnn, rrAnn};
 		else if (overrideAnn != null && sefAnn != null) out.annotations = new Annotation[] {overrideAnn, sefAnn};
@@ -804,7 +804,7 @@ private MethodDeclaration generateSelfMethod(CheckerFrameworkVersion cfv, Eclips
 		out.modifiers = ClassFileConstants.AccProtected;
 		Annotation overrideAnn = makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, builderImplType.get());
 		Annotation rrAnn = cfv.generateReturnsReceiver() ? generateNamedAnnotation(builderImplType.get(), CheckerFrameworkVersion.NAME__RETURNS_RECEIVER): null;
-		Annotation sefAnn = cfv.generateSideEffectFree() ? generateNamedAnnotation(builderImplType.get(), CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE): null;
+		Annotation sefAnn = cfv.generatePure() ? generateNamedAnnotation(builderImplType.get(), CheckerFrameworkVersion.NAME__PURE): null;
 		if (rrAnn != null && sefAnn != null) out.annotations = new Annotation[] {overrideAnn, rrAnn, sefAnn};
 		else if (rrAnn != null) out.annotations = new Annotation[] {overrideAnn, rrAnn};
 		else if (sefAnn != null) out.annotations = new Annotation[] {overrideAnn, sefAnn};

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -520,8 +520,8 @@ public JCMethodDecl createCanEqual(JavacNode typeNode, JCTree source, List<JCAnn
 		
 		List<JCAnnotation> annsOnMethod = List.nil();
 		CheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);
-		if (checkerFramework.generateSideEffectFree()) {
-			annsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));
+		if (checkerFramework.generatePure()) {
+			annsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));
 		}
 		JCModifiers mods = maker.Modifiers(Flags.PROTECTED, annsOnMethod);
 		JCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -750,7 +750,7 @@ private JCMethodDecl generateAbstractSelfMethod(CheckerFrameworkVersion cfv, Jav
 		List<JCAnnotation> annotations = List.nil();
 		JCAnnotation overrideAnnotation = override ? maker.Annotation(genJavaLangTypeRef(type, "Override"), List.<JCExpression>nil()) : null;
 		JCAnnotation rrAnnotation = cfv.generateReturnsReceiver() ? maker.Annotation(genTypeRef(type, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil()) : null;
-		JCAnnotation sefAnnotation = cfv.generateSideEffectFree() ? maker.Annotation(genTypeRef(type, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()) : null;
+		JCAnnotation sefAnnotation = cfv.generatePure() ? maker.Annotation(genTypeRef(type, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()) : null;
 		if (sefAnnotation != null) annotations = annotations.prepend(sefAnnotation);
 		if (rrAnnotation != null) annotations = annotations.prepend(rrAnnotation);
 		if (overrideAnnotation != null) annotations = annotations.prepend(overrideAnnotation);
@@ -766,7 +766,7 @@ private JCMethodDecl generateSelfMethod(CheckerFrameworkVersion cfv, JavacNode b
 		
 		JCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(builderImplType, "Override"), List.<JCExpression>nil());
 		JCAnnotation rrAnnotation = cfv.generateReturnsReceiver() ? maker.Annotation(genTypeRef(builderImplType, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil()) : null;
-		JCAnnotation sefAnnotation = cfv.generateSideEffectFree() ? maker.Annotation(genTypeRef(builderImplType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()) : null;
+		JCAnnotation sefAnnotation = cfv.generatePure() ? maker.Annotation(genTypeRef(builderImplType, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()) : null;
 		List<JCAnnotation> annsOnMethod = List.nil();
 		if (sefAnnotation != null) annsOnMethod = annsOnMethod.prepend(sefAnnotation);
 		if (rrAnnotation != null) annsOnMethod = annsOnMethod.prepend(rrAnnotation);

File: test/transform/resource/after-delombok/CheckerFrameworkBasic.java
Patch:
@@ -8,12 +8,12 @@ public CheckerFrameworkBasic(final int x, final int y) {
 		this.x = x;
 		this.y = y;
 	}
-	@org.checkerframework.dataflow.qual.SideEffectFree
+	@org.checkerframework.dataflow.qual.Pure
 	@java.lang.SuppressWarnings("all")
 	public int getX() {
 		return this.x;
 	}
-	@org.checkerframework.dataflow.qual.SideEffectFree
+	@org.checkerframework.dataflow.qual.Pure
 	@java.lang.SuppressWarnings("all")
 	public int getY() {
 		return this.y;
@@ -42,7 +42,7 @@ public boolean equals(final java.lang.Object o) {
 		if (this.getZ() != other.getZ()) return false;
 		return true;
 	}
-	@org.checkerframework.dataflow.qual.SideEffectFree
+	@org.checkerframework.dataflow.qual.Pure
 	@java.lang.SuppressWarnings("all")
 	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof CheckerFrameworkBasic;

File: test/transform/resource/after-ecj/CheckerFrameworkBasic.java
Patch:
@@ -8,10 +8,10 @@
   public @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") CheckerFrameworkBasic withX(final int x) {
     return ((this.x == x) ? this : new CheckerFrameworkBasic(x, this.y, this.z));
   }
-  public @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") int getX() {
+  public @org.checkerframework.dataflow.qual.Pure @java.lang.SuppressWarnings("all") int getX() {
     return this.x;
   }
-  public @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") int getY() {
+  public @org.checkerframework.dataflow.qual.Pure @java.lang.SuppressWarnings("all") int getY() {
     return this.y;
   }
   public @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") int getZ() {
@@ -37,7 +37,7 @@
         return false;
     return true;
   }
-  protected @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @org.checkerframework.dataflow.qual.Pure @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof CheckerFrameworkBasic);
   }
   public @java.lang.Override @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/before/CheckerFrameworkBasic.java
Patch:
@@ -1,4 +1,4 @@
-//CONF: checkerframework = 3.0
+//CONF: checkerframework = 4.0
 import lombok.Data;
 import lombok.experimental.Accessors;
 import lombok.With;

File: test/transform/resource/before/CheckerFrameworkBuilder.java
Patch:
@@ -1,4 +1,4 @@
-//CONF: checkerframework = true
+//CONF: checkerframework = 4.0
 import java.util.List;
 import lombok.Builder;
 import lombok.Singular;

File: test/transform/resource/before/CheckerFrameworkSuperBuilder.java
Patch:
@@ -1,4 +1,4 @@
-//CONF: checkerframework = true
+//CONF: checkerframework = 4.0
 import java.util.List;
 import lombok.Singular;
 

File: test/transform/resource/after-delombok/ValWeirdTypes.java
Patch:
@@ -37,6 +37,7 @@ public void testBounds(List<? extends Number> lower, List<? super Number> upper)
 		final java.util.List<? super java.lang.Number> d = upper;
 		List<?> unbound = lower;
 		final java.util.List<?> e = unbound;
+		final java.lang.Object f = unbound.get(0);
 	}
 	public void testCompound() {
 		final java.util.ArrayList<java.lang.String> a = new ArrayList<String>();

File: test/transform/resource/after-ecj/ValWeirdTypes.java
Patch:
@@ -44,6 +44,7 @@ public void testBounds(List<? extends Number> lower, List<? super Number> upper)
     final @val java.util.List<? super java.lang.Number> d = upper;
     List<?> unbound = lower;
     final @val java.util.List<?> e = unbound;
+    final @val java.lang.Object f = unbound.get(0);
   }
   public void testCompound() {
     final @val java.util.ArrayList<java.lang.String> a = new ArrayList<String>();

File: test/transform/resource/before/ValWeirdTypes.java
Patch:
@@ -44,6 +44,7 @@ public void testBounds(List<? extends Number> lower, List<? super Number> upper)
 		val d = upper;
 		List<?> unbound = lower;
 		val e = unbound;
+		val f = unbound.get(0);
 	}
 	
 	public void testCompound() {

File: test/transform/resource/after-delombok/BuilderDefaultsWarnings.java
Patch:
@@ -1,3 +1,4 @@
+//skip-idempotent
 import lombok.Builder;
 @Builder
 public class BuilderDefaultsWarnings {

File: test/transform/resource/after-delombok/BuilderSingularNoAuto.java
Patch:
@@ -1,3 +1,4 @@
+//skip-idempotent
 import java.util.List;
 @lombok.Builder
 class BuilderSingularNoAuto {

File: test/transform/resource/after-delombok/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -1,3 +1,4 @@
+//skip-idempotent
 import java.util.List;
 @lombok.Builder(setterPrefix = "with")
 class BuilderSingularNoAutoWithSetterPrefix {

File: test/transform/resource/after-delombok/JacksonizedSuperBuilderWithJsonDeserialize.java
Patch:
@@ -1,3 +1,4 @@
+//skip-idempotent
 @lombok.experimental.SuperBuilder
 @com.fasterxml.jackson.databind.annotation.JsonDeserialize
 public class JacksonizedSuperBuilderWithJsonDeserialize {

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -166,9 +166,9 @@ private ConfigurationKeys() {}
 	/**
 	 * lombok configuration: {@code lombok.noArgsConstructor.extraPrivate} = {@code true} | {@code false}.
 	 * 
-	 * If {@code true} (default), @Data and @Value will also generate a private no-args constructor, if there isn't already one, setting all fields to their default values. 
+	 * If {@code true}, @Data and @Value will also generate a private no-args constructor, if there isn't already one, setting all fields to their default values.
 	 */
-	public static final ConfigurationKey<Boolean> NO_ARGS_CONSTRUCTOR_EXTRA_PRIVATE = new ConfigurationKey<Boolean>("lombok.noArgsConstructor.extraPrivate", "Generate a private no-args constructor for @Data and @Value (default: true).") {};
+	public static final ConfigurationKey<Boolean> NO_ARGS_CONSTRUCTOR_EXTRA_PRIVATE = new ConfigurationKey<Boolean>("lombok.noArgsConstructor.extraPrivate", "Generate a private no-args constructor for @Data and @Value (default: false).") {};
 	
 	/**
 	 * lombok configuration: {@code lombok.requiredArgsConstructor.flagUsage} = {@code WARNING} | {@code ERROR}.

File: src/core/lombok/core/configuration/NullAnnotationLibrary.java
Patch:
@@ -126,11 +126,11 @@ public static NullAnnotationLibrary valueOf(String in) {
 		int start = typeUse ? 16 : 7;
 		int split = ci.indexOf(':', start);
 		if (split == -1) {
-			String nonNullAnnotation = ci.substring(start);
+			String nonNullAnnotation = in.substring(start);
 			return custom(verifyTypeName(nonNullAnnotation), null, typeUse);
 		}
-		String nonNullAnnotation = ci.substring(start, split);
-		String nullableAnnotation = ci.substring(split + 1);
+		String nonNullAnnotation = in.substring(start, split);
+		String nullableAnnotation = in.substring(split + 1);
 		return custom(verifyTypeName(nonNullAnnotation), verifyTypeName(nullableAnnotation), typeUse);
 	}
 	

File: src/core/lombok/core/configuration/NullAnnotationLibrary.java
Patch:
@@ -126,11 +126,11 @@ public static NullAnnotationLibrary valueOf(String in) {
 		int start = typeUse ? 16 : 7;
 		int split = ci.indexOf(':', start);
 		if (split == -1) {
-			String nonNullAnnotation = ci.substring(start);
+			String nonNullAnnotation = in.substring(start);
 			return custom(verifyTypeName(nonNullAnnotation), null, typeUse);
 		}
-		String nonNullAnnotation = ci.substring(start, split);
-		String nullableAnnotation = ci.substring(split + 1);
+		String nonNullAnnotation = in.substring(start, split);
+		String nullableAnnotation = in.substring(split + 1);
 		return custom(verifyTypeName(nonNullAnnotation), verifyTypeName(nullableAnnotation), typeUse);
 	}
 	

File: test/transform/resource/after-delombok/SynchronizedName.java
Patch:
@@ -8,7 +8,7 @@ void test1() {
 		}
 	}
 	void test4() {
-		synchronized (this.READ) {
+		synchronized (SynchronizedName.READ) {
 			System.out.println("four");
 		}
 	}

File: test/transform/resource/after-delombok/SynchronizedNameStaticToInstanceRef.java
Patch:
@@ -2,8 +2,6 @@ class SynchronizedNameStaticToInstanceRef {
 	private Object read = new Object();
 	private static Object READ = new Object();
 	static void test3() {
-		synchronized (SynchronizedNameStaticToInstanceRef.read) {
-			System.out.println("three");
-		}
+		System.out.println("three");
 	}
 }

File: test/transform/resource/after-ecj/SynchronizedName.java
Patch:
@@ -13,7 +13,7 @@ class SynchronizedName {
       }
   }
   @lombok.Synchronized("READ") void test4() {
-    synchronized (this.READ)
+    synchronized (SynchronizedName.READ)
       {
         System.out.println("four");
       }

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1904,7 +1904,8 @@ public static EclipseNode injectType(final EclipseNode typeNode, final TypeDecla
 		return typeNode.add(type, Kind.TYPE);
 	}
 	
-	private static final char[] ALL = "all".toCharArray();
+	static final char[] ALL = "all".toCharArray();
+	static final char[] UNCHECKED = "unchecked".toCharArray();
 	private static final char[] JUSTIFICATION = "justification".toCharArray();
 	private static final char[] GENERATED_CODE = "generated code".toCharArray();
 	private static final char[] LOMBOK = "lombok".toCharArray();
@@ -1934,7 +1935,7 @@ public static Annotation[] addGenerated(EclipseNode node, ASTNode source, Annota
 		return result;
 	}
 	
-	private static Annotation[] addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn, ASTNode arg) {
+	static Annotation[] addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn, ASTNode arg) {
 		char[] simpleName = annotationTypeFqn[annotationTypeFqn.length - 1];
 		
 		if (originalAnnotationArray != null) for (Annotation ann : originalAnnotationArray) {

File: test/transform/resource/after-delombok/DelegateOnGetter.java
Patch:
@@ -4,7 +4,7 @@ private interface Bar {
 		void setList(java.util.ArrayList<java.lang.String> list);
 		int getInt();
 	}
-	@java.lang.SuppressWarnings("all")
+	@java.lang.SuppressWarnings({"all", "unchecked"})
 	public Bar getBar() {
 		java.lang.Object value = this.bar.get();
 		if (value == null) {

File: test/transform/resource/after-delombok/GetterLazy.java
Patch:
@@ -2,7 +2,7 @@ class GetterLazy {
 	static class ValueType {
 	}
 	private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> fieldName = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
-	@java.lang.SuppressWarnings("all")
+	@java.lang.SuppressWarnings({"all", "unchecked"})
 	public ValueType getFieldName() {
 		java.lang.Object value = this.fieldName.get();
 		if (value == null) {

File: test/transform/resource/after-delombok/GetterLazyBoolean.java
Patch:
@@ -31,7 +31,7 @@ public int hashCode() {
 	public java.lang.String toString() {
 		return "GetterLazyBoolean(booleanValue=" + this.isBooleanValue() + ")";
 	}
-	@java.lang.SuppressWarnings("all")
+	@java.lang.SuppressWarnings({"all", "unchecked"})
 	public boolean isBooleanValue() {
 		java.lang.Object value = this.booleanValue.get();
 		if (value == null) {
@@ -46,7 +46,7 @@ public boolean isBooleanValue() {
 		}
 		return (java.lang.Boolean) value;
 	}
-	@java.lang.SuppressWarnings("all")
+	@java.lang.SuppressWarnings({"all", "unchecked"})
 	public boolean isOtherBooleanValue() {
 		java.lang.Object value = this.otherBooleanValue.get();
 		if (value == null) {

File: test/transform/resource/after-delombok/GetterLazyEahcToString.java
Patch:
@@ -44,9 +44,7 @@ public java.lang.String toString() {
 		return "GetterLazyEahcToString(value=" + this.getValue() + ", value2=" + this.value2 + ")";
 	}
 	
-	@java.lang.SuppressWarnings("all")
-	
-	
+	@java.lang.SuppressWarnings({"all", "unchecked"})
 	public String getValue() {
 		java.lang.Object value = this.value.get();
 		if (value == null) {

File: test/transform/resource/after-delombok/GetterLazyTransient.java
Patch:
@@ -2,7 +2,7 @@ class GetterLazyTransient {
 	private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> nonTransientField = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
 	private final transient int transientField = 2;
 	private final transient int nonLazyTransientField = 3;
-	@java.lang.SuppressWarnings("all")
+	@java.lang.SuppressWarnings({"all", "unchecked"})
 	public int getNonTransientField() {
 		java.lang.Object value = this.nonTransientField.get();
 		if (value == null) {

File: test/transform/resource/after-ecj/DelegateOnGetter.java
Patch:
@@ -9,7 +9,7 @@ private interface Bar {
   DelegateOnGetter() {
     super();
   }
-  public @Delegate @java.lang.SuppressWarnings("all") Bar getBar() {
+  public @Delegate @java.lang.SuppressWarnings({"all", "unchecked"}) Bar getBar() {
     java.lang.Object value = this.bar.get();
     if ((value == null))
         {

File: test/transform/resource/after-ecj/GetterLazy.java
Patch:
@@ -8,7 +8,7 @@ static class ValueType {
   GetterLazy() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") ValueType getFieldName() {
+  public @java.lang.SuppressWarnings({"all", "unchecked"}) ValueType getFieldName() {
     java.lang.Object value = this.fieldName.get();
     if ((value == null))
         {

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -7,7 +7,7 @@
   private static boolean calculateBoolean() {
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean isBooleanValue() {
+  public @java.lang.SuppressWarnings({"all", "unchecked"}) boolean isBooleanValue() {
     java.lang.Object value = this.booleanValue.get();
     if ((value == null))
         {
@@ -24,7 +24,7 @@ private static boolean calculateBoolean() {
         }
     return (java.lang.Boolean) value;
   }
-  public @java.lang.SuppressWarnings("all") boolean isOtherBooleanValue() {
+  public @java.lang.SuppressWarnings({"all", "unchecked"}) boolean isOtherBooleanValue() {
     java.lang.Object value = this.otherBooleanValue.get();
     if ((value == null))
         {

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -4,7 +4,7 @@
   GetterLazyEahcToString() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") String getValue() {
+  public @java.lang.SuppressWarnings({"all", "unchecked"}) String getValue() {
     java.lang.Object value = this.value.get();
     if ((value == null))
         {

File: test/transform/resource/after-ecj/GetterLazyTransient.java
Patch:
@@ -5,7 +5,7 @@ class GetterLazyTransient {
   GetterLazyTransient() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") int getNonTransientField() {
+  public @java.lang.SuppressWarnings({"all", "unchecked"}) int getNonTransientField() {
     java.lang.Object value = this.nonTransientField.get();
     if ((value == null))
         {

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -650,6 +650,7 @@ private MethodDeclaration generateToBuilderMethod(CheckerFrameworkVersion cfv, b
 			out.annotations = new Annotation[] {generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__UNIQUE)};
 		}
 		
+		createRelevantNonNullAnnotation(type, out);
 		out.traverse(new SetGeneratedByVisitor(source), ((TypeDeclaration) type.get()).scope);
 		return out;
 	}
@@ -796,6 +797,7 @@ public MethodDeclaration generateBuildMethod(CheckerFrameworkVersion cfv, Eclips
 			out.annotations = new Annotation[] {generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE)};
 		}
 		out.arguments = generateBuildArgs(cfv, type, builderFields, source);
+		if (staticName == null) createRelevantNonNullAnnotation(type, out);
 		out.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);
 		return out;
 	}
@@ -864,6 +866,7 @@ public MethodDeclaration generateBuilderMethod(CheckerFrameworkVersion cfv, bool
 		} else if (sefAnn != null) {
 			out.annotations = new Annotation[] {sefAnn};
 		}
+		createRelevantNonNullAnnotation(type, out);
 		out.traverse(new SetGeneratedByVisitor(source), ((TypeDeclaration) type.get()).scope);
 		return out;
 	}

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -562,6 +562,7 @@ public MethodDeclaration createStaticConstructor(AccessLevel level, String name,
 		constructor.arguments = params.isEmpty() ? null : params.toArray(new Argument[0]);
 		constructor.statements = new Statement[] { new ReturnStatement(statement, (int) (p >> 32), (int)p) };
 		
+		createRelevantNonNullAnnotation(type, constructor);
 		constructor.traverse(new SetGeneratedByVisitor(source), typeDecl.scope);
 		return constructor;
 	}

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -260,6 +260,8 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		method.statements = statements.toArray(new Statement[0]);
 		param.annotations = copyAnnotations(source, copyableAnnotations, onParam.toArray(new Annotation[0]));
 		
+		if (returnType != null && returnStatement != null) createRelevantNonNullAnnotation(sourceNode, method);
+		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);
 		return method;
 	}

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -132,6 +132,7 @@ void generateClearMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRef
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
 		data.setGeneratedByRecursive(md);
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		injectMethod(builderType, md);
 	}
 	
@@ -176,6 +177,7 @@ void generateSingularMethod(CheckerFrameworkVersion cfv, boolean deprecate, Type
 		md.selector = fluent ? prefixedSingularName : HandlerUtil.buildAccessorName("add", new String(data.getSingularName())).toCharArray();
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		HandleNonNull.INSTANCE.fix(injectMethod(builderType, md));
 	}
@@ -207,13 +209,13 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		
 		md.statements = statements.toArray(new Statement[0]);
 		
-		
 		md.arguments = new Argument[] {param};
 		md.returnType = returnType;
 		char[] prefixedSelector = data.getSetterPrefix().length == 0 ? data.getPluralName() : HandlerUtil.buildAccessorName(new String(data.getSetterPrefix()), new String(data.getPluralName())).toCharArray();
 		md.selector = fluent ? prefixedSelector : HandlerUtil.buildAccessorName("addAll", new String(data.getPluralName())).toCharArray();
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSetSingularizer.java
Patch:
@@ -122,6 +122,7 @@ private void generateClearMethod(CheckerFrameworkVersion cfv, boolean deprecate,
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
 		data.setGeneratedByRecursive(md);
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		injectMethod(builderType, md);
 	}
 	
@@ -154,6 +155,7 @@ void generateSingularMethod(CheckerFrameworkVersion cfv, boolean deprecate, Type
 		md.selector = fluent ? prefixedSingularName : HandlerUtil.buildAccessorName("add", new String(data.getSingularName())).toCharArray();
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		HandleNonNull.INSTANCE.fix(injectMethod(builderType, md));
 	}
@@ -189,6 +191,7 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		md.selector = fluent ? prefixedSelector : HandlerUtil.buildAccessorName("addAll", new String(data.getPluralName())).toCharArray();
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilMapSingularizer.java
Patch:
@@ -191,6 +191,7 @@ private void generateClearMethod(CheckerFrameworkVersion cfv, boolean deprecate,
 		md.returnType = returnType;
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}
@@ -253,6 +254,7 @@ private void generateSingularMethod(CheckerFrameworkVersion cfv, boolean depreca
 		md.selector = setterName.toCharArray();
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		HandleNonNull.INSTANCE.fix(injectMethod(builderType, md));
 	}
@@ -326,6 +328,7 @@ private void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate
 		md.selector = setterName.toCharArray();
 		md.annotations = generateSelfReturnAnnotations(deprecate, cfv, data.getSource());
 		
+		if (returnStatement != null) createRelevantNonNullAnnotation(builderType, md);
 		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -489,6 +489,8 @@ public JCMethodDecl createStaticConstructor(String name, AccessLevel level, Java
 		JCReturn returnStatement = maker.Return(maker.NewClass(null, List.<JCExpression>nil(), constructorType, args.toList(), null));
 		JCBlock body = maker.Block(0, List.<JCStatement>of(returnStatement));
 		
-		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(name), returnType, typeParams.toList(), params.toList(), List.<JCExpression>nil(), body, null), source, typeNode.getContext());
+		JCMethodDecl methodDef = maker.MethodDef(mods, typeNode.toName(name), returnType, typeParams.toList(), params.toList(), List.<JCExpression>nil(), body, null);
+		createRelevantNonNullAnnotation(typeNode, methodDef);
+		return recursiveSetGeneratedBy(methodDef, source, typeNode.getContext());
 	}
 }

File: src/core/lombok/javac/handlers/JavacSingularsRecipes.java
Patch:
@@ -288,6 +288,7 @@ private void finishAndInjectMethod(CheckerFrameworkVersion cfv, JavacTreeMaker m
 			
 			JCMethodDecl method = maker.MethodDef(mods, methodName, returnType, typeParams, jcVariableDecls, thrown, body, null);
 			recursiveSetGeneratedBy(method, source, builderType.getContext());
+			if (returnStatement != null) createRelevantNonNullAnnotation(builderType, method);
 			injectMethod(builderType, method);
 		}
 		

File: test/transform/resource/after-delombok/WithPlain.java
Patch:
@@ -5,10 +5,12 @@ class WithPlain {
 		this.i = i;
 		this.foo = foo;
 	}
+	@org.springframework.lang.NonNull
 	@java.lang.SuppressWarnings("all")
 	public WithPlain withI(final int i) {
 		return this.i == i ? this : new WithPlain(i, this.foo);
 	}
+	@org.springframework.lang.NonNull
 	@java.lang.SuppressWarnings("all")
 	public WithPlain withFoo(final int foo) {
 		return this.foo == foo ? this : new WithPlain(this.i, foo);

File: test/transform/resource/after-ecj/WithPlain.java
Patch:
@@ -7,10 +7,10 @@ class WithPlain {
     this.i = i;
     this.foo = foo;
   }
-  public @java.lang.SuppressWarnings("all") WithPlain withI(final int i) {
+  public @org.springframework.lang.NonNull @java.lang.SuppressWarnings("all") WithPlain withI(final int i) {
     return ((this.i == i) ? this : new WithPlain(i, this.foo));
   }
-  public @java.lang.SuppressWarnings("all") WithPlain withFoo(final int foo) {
+  public @org.springframework.lang.NonNull @java.lang.SuppressWarnings("all") WithPlain withFoo(final int foo) {
     return ((this.foo == foo) ? this : new WithPlain(this.i, foo));
   }
 }

File: test/transform/resource/before/WithPlain.java
Patch:
@@ -1,3 +1,4 @@
+//CONF: lombok.addNullAnnotations = spring
 import lombok.With;
 class WithPlain {
 	@lombok.With int i;

File: src/core/lombok/core/configuration/NullCheckExceptionType.java
Patch:
@@ -74,8 +74,9 @@ public enum NullCheckExceptionType {
 	private static final LombokImmutableList<String> METHOD_JDK = LombokImmutableList.of("java", "util", "Objects", "requireNonNull");
 	private static final LombokImmutableList<String> METHOD_GUAVA = LombokImmutableList.of("com", "google", "common", "base", "Preconditions", "checkNotNull");
 	
-	public String toExceptionMessage(String fieldName) {
-		return fieldName + " is marked non-null but is null";
+	public String toExceptionMessage(String fieldName, String customMessage) {
+		if (customMessage == null) return fieldName + " is marked non-null but is null";
+		return customMessage.replace("%s", fieldName);
 	}
 	
 	public abstract String getExceptionType();

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -411,7 +411,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 			Argument parameter = new Argument(fieldName, fieldPos, copyType(field.type, source), Modifier.FINAL);
 			Annotation[] copyableAnnotations = findCopyableAnnotations(fieldNode);
 			if (hasNonNullAnnotations(fieldNode)) {
-				Statement nullCheck = generateNullCheck(parameter, sourceNode);
+				Statement nullCheck = generateNullCheck(parameter, sourceNode, null);
 				if (nullCheck != null) nullChecks.add(nullCheck);
 			}
 			parameter.annotations = copyAnnotations(source, copyableAnnotations);

File: src/core/lombok/eclipse/handlers/HandleNonNull.java
Patch:
@@ -145,7 +145,7 @@ private void handle0(Annotation ast, EclipseNode annotationNode, boolean force)
 		// and if they exist, create a new method in the class: 'private static <T> T lombok$nullCheck(T expr, String msg) {if (expr == null) throw NPE; return expr;}' and
 		// wrap all references to it in the super/this to a call to this method.
 		
-		Statement nullCheck = generateNullCheck(param, annotationNode);
+		Statement nullCheck = generateNullCheck(param, annotationNode, null);
 		
 		if (nullCheck == null) {
 			// @NonNull applied to a primitive. Kinda pointless. Let's generate a warning.

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -245,7 +245,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		if (!hasNonNullAnnotations(fieldNode) && !hasNonNullAnnotations(fieldNode, onParam)) {
 			statements.add(assignment);
 		} else {
-			Statement nullCheck = generateNullCheck(field.type, paramName, sourceNode);
+			Statement nullCheck = generateNullCheck(field.type, paramName, sourceNode, null);
 			if (nullCheck != null) statements.add(nullCheck);
 			statements.add(assignment);
 		}

File: src/core/lombok/eclipse/handlers/HandleWith.java
Patch:
@@ -278,7 +278,7 @@ public MethodDeclaration createWith(TypeDeclaration parent, EclipseNode fieldNod
 			
 			List<Statement> statements = new ArrayList<Statement>(5);
 			if (hasNonNullAnnotations(fieldNode)) {
-				Statement nullCheck = generateNullCheck(field, sourceNode);
+				Statement nullCheck = generateNullCheck(field, sourceNode, null);
 				if (nullCheck != null) statements.add(nullCheck);
 			}
 			statements.add(returnStatement);

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -248,7 +248,7 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		if (!hasNonNullAnnotations(field) && !hasNonNullAnnotations(field, onParam)) {
 			statements.append(treeMaker.Exec(assign));
 		} else {
-			JCStatement nullCheck = generateNullCheck(treeMaker, fieldDecl.vartype, paramName, source);
+			JCStatement nullCheck = generateNullCheck(treeMaker, fieldDecl.vartype, paramName, source, null);
 			if (nullCheck != null) statements.append(nullCheck);
 			statements.append(treeMaker.Exec(assign));
 		}

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -59,7 +59,6 @@
 import lombok.AccessLevel;
 import lombok.Builder;
 import lombok.Builder.ObtainVia;
-import lombok.Singular.NullCollectionBehavior;
 import lombok.ConfigurationKeys;
 import lombok.Singular;
 import lombok.ToString;
@@ -976,8 +975,7 @@ private SingularData getSingularData(JavacNode node) {
 				return null;
 			}
 			
-			NullCollectionBehavior behavior = HandleBuilder.getNullBehaviorFor(ann, singularInstance, node);
-			return new SingularData(child, singularName, pluralName, typeArgs, targetFqn, singularizer, behavior);
+			return new SingularData(child, singularName, pluralName, typeArgs, targetFqn, singularizer, singularInstance.ignoreNullCollections());
 		}
 		
 		return null;

File: test/transform/resource/after-delombok/BuilderDefaultsWarnings.java
Patch:
@@ -38,7 +38,9 @@ public BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder item(final String
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder items(final java.util.Collection<? extends String> items) {
-			if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+			if (items == null) {
+				throw new java.lang.NullPointerException("items cannot be null");
+			}
 			if (this.items == null) this.items = new java.util.ArrayList<String>();
 			this.items.addAll(items);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNull.java
Patch:
@@ -22,7 +22,9 @@ public BuilderSingularToBuilderWithNull.BuilderSingularToBuilderWithNullBuilder
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularToBuilderWithNull.BuilderSingularToBuilderWithNullBuilder elems(final java.util.Collection<? extends String> elems) {
-			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
+			if (elems == null) {
+				throw new java.lang.NullPointerException("elems cannot be null");
+			}
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -22,7 +22,9 @@ public BuilderSingularToBuilderWithNullWithSetterPrefix.BuilderSingularToBuilder
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularToBuilderWithNullWithSetterPrefix.BuilderSingularToBuilderWithNullWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
-			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
+			if (elems == null) {
+				throw new java.lang.NullPointerException("elems cannot be null");
+			}
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularWithPrefixes.java
Patch:
@@ -19,7 +19,9 @@ public BuilderSingularWithPrefixes.BuilderSingularWithPrefixesBuilder elem(final
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularWithPrefixes.BuilderSingularWithPrefixesBuilder elems(final java.util.Collection<? extends String> elems) {
-			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
+			if (elems == null) {
+				throw new java.lang.NullPointerException("elems cannot be null");
+			}
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularWithPrefixesWithSetterPrefix.java
Patch:
@@ -19,7 +19,9 @@ public BuilderSingularWithPrefixesWithSetterPrefix.BuilderSingularWithPrefixesWi
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularWithPrefixesWithSetterPrefix.BuilderSingularWithPrefixesWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
-			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
+			if (elems == null) {
+				throw new java.lang.NullPointerException("elems cannot be null");
+			}
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -50,7 +50,9 @@ public BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> bar(final T bar) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> bars(final java.util.Collection<? extends T> bars) {
-			if (bars == null) throw new java.lang.NullPointerException("bars cannot be null");
+			if (bars == null) {
+				throw new java.lang.NullPointerException("bars cannot be null");
+			}
 			if (this.bars == null) this.bars = new java.util.ArrayList<T>();
 			this.bars.addAll(bars);
 			return this;

File: test/transform/resource/after-delombok/CheckerFrameworkBuilder.java
Patch:
@@ -62,7 +62,9 @@ public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder name(final String
 		@org.checkerframework.checker.builder.qual.ReturnsReceiver
 		@java.lang.SuppressWarnings("all")
 		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder names(final java.util.Collection<? extends String> names) {
-			if (names == null) throw new java.lang.NullPointerException("names cannot be null");
+			if (names == null) {
+				throw new java.lang.NullPointerException("names cannot be null");
+			}
 			if (this.names == null) this.names = new java.util.ArrayList<String>();
 			this.names.addAll(names);
 			return this;

File: test/transform/resource/after-delombok/CheckerFrameworkSuperBuilder.java
Patch:
@@ -58,7 +58,9 @@ public B name(final String name) {
 			@org.checkerframework.checker.builder.qual.ReturnsReceiver
 			@java.lang.SuppressWarnings("all")
 			public B names(final java.util.Collection<? extends String> names) {
-				if (names == null) throw new java.lang.NullPointerException("names cannot be null");
+				if (names == null) {
+					throw new java.lang.NullPointerException("names cannot be null");
+				}
 				if (this.names == null) this.names = new java.util.ArrayList<String>();
 				this.names.addAll(names);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderBasic.java
Patch:
@@ -26,7 +26,9 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
-				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+				if (items == null) {
+					throw new java.lang.NullPointerException("items cannot be null");
+				}
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderBasicToBuilder.java
Patch:
@@ -69,7 +69,9 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
-				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+				if (items == null) {
+					throw new java.lang.NullPointerException("items cannot be null");
+				}
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -26,7 +26,9 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
-				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+				if (items == null) {
+					throw new java.lang.NullPointerException("items cannot be null");
+				}
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics.java
Patch:
@@ -26,7 +26,9 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
-				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+				if (items == null) {
+					throw new java.lang.NullPointerException("items cannot be null");
+				}
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics2.java
Patch:
@@ -26,7 +26,9 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
-				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+				if (items == null) {
+					throw new java.lang.NullPointerException("items cannot be null");
+				}
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -42,7 +42,9 @@ public B item(final Integer itemKey, final String itemValue) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Map<? extends Integer, ? extends String> items) {
-				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+				if (items == null) {
+					throw new java.lang.NullPointerException("items cannot be null");
+				}
 				if (this.items$key == null) {
 					this.items$key = new java.util.ArrayList<Integer>();
 					this.items$value = new java.util.ArrayList<String>();

File: test/transform/resource/after-delombok/SuperBuilderWithPrefixes.java
Patch:
@@ -32,7 +32,9 @@ public B item(final String item) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public B items(final java.util.Collection<? extends String> items) {
-			if (items == null) throw new java.lang.NullPointerException("items cannot be null");
+			if (items == null) {
+				throw new java.lang.NullPointerException("items cannot be null");
+			}
 			if (this.items == null) this.items = new java.util.ArrayList<String>();
 			this.items.addAll(items);
 			return self();

File: test/transform/resource/after-ecj/BuilderDefaultsWarnings.java
Patch:
@@ -24,7 +24,9 @@
     }
     public @java.lang.SuppressWarnings("all") BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder items(final java.util.Collection<? extends String> items) {
       if ((items == null))
-          throw new java.lang.NullPointerException("items cannot be null");
+          {
+            throw new java.lang.NullPointerException("items cannot be null");
+          }
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.addAll(items);

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNull.java
Patch:
@@ -13,7 +13,9 @@
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNull.BuilderSingularToBuilderWithNullBuilder elems(final java.util.Collection<? extends String> elems) {
       if ((elems == null))
-          throw new java.lang.NullPointerException("elems cannot be null");
+          {
+            throw new java.lang.NullPointerException("elems cannot be null");
+          }
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -13,7 +13,9 @@
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullWithSetterPrefix.BuilderSingularToBuilderWithNullWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
       if ((elems == null))
-          throw new java.lang.NullPointerException("elems cannot be null");
+          {
+            throw new java.lang.NullPointerException("elems cannot be null");
+          }
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularWithPrefixes.java
Patch:
@@ -13,7 +13,9 @@
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixes.BuilderSingularWithPrefixesBuilder elems(final java.util.Collection<? extends String> elems) {
       if ((elems == null))
-          throw new java.lang.NullPointerException("elems cannot be null");
+          {
+            throw new java.lang.NullPointerException("elems cannot be null");
+          }
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularWithPrefixesWithSetterPrefix.java
Patch:
@@ -13,7 +13,9 @@
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesWithSetterPrefix.BuilderSingularWithPrefixesWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
       if ((elems == null))
-          throw new java.lang.NullPointerException("elems cannot be null");
+          {
+            throw new java.lang.NullPointerException("elems cannot be null");
+          }
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -29,7 +29,9 @@
     }
     public @java.lang.SuppressWarnings("all") BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> bars(final java.util.Collection<? extends T> bars) {
       if ((bars == null))
-          throw new java.lang.NullPointerException("bars cannot be null");
+          {
+            throw new java.lang.NullPointerException("bars cannot be null");
+          }
       if ((this.bars == null))
           this.bars = new java.util.ArrayList<T>();
       this.bars.addAll(bars);

File: test/transform/resource/after-ecj/CheckerFrameworkBuilder.java
Patch:
@@ -32,7 +32,9 @@
     }
     public @org.checkerframework.checker.builder.qual.ReturnsReceiver @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder names(final java.util.Collection<? extends String> names) {
       if ((names == null))
-          throw new java.lang.NullPointerException("names cannot be null");
+          {
+            throw new java.lang.NullPointerException("names cannot be null");
+          }
       if ((this.names == null))
           this.names = new java.util.ArrayList<String>();
       this.names.addAll(names);

File: test/transform/resource/after-ecj/CheckerFrameworkSuperBuilder.java
Patch:
@@ -33,7 +33,9 @@ public ParentBuilder() {
       }
       public @org.checkerframework.checker.builder.qual.ReturnsReceiver @java.lang.SuppressWarnings("all") B names(final java.util.Collection<? extends String> names) {
         if ((names == null))
-            throw new java.lang.NullPointerException("names cannot be null");
+            {
+              throw new java.lang.NullPointerException("names cannot be null");
+            }
         if ((this.names == null))
             this.names = new java.util.ArrayList<String>();
         this.names.addAll(names);

File: test/transform/resource/after-ecj/SuperBuilderBasic.java
Patch:
@@ -21,7 +21,9 @@ public ParentBuilder() {
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((items == null))
-            throw new java.lang.NullPointerException("items cannot be null");
+            {
+              throw new java.lang.NullPointerException("items cannot be null");
+            }
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderBasicToBuilder.java
Patch:
@@ -47,7 +47,9 @@ public ParentBuilder() {
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((items == null))
-            throw new java.lang.NullPointerException("items cannot be null");
+            {
+              throw new java.lang.NullPointerException("items cannot be null");
+            }
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -21,7 +21,9 @@ public ParentBuilder() {
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((items == null))
-            throw new java.lang.NullPointerException("items cannot be null");
+            {
+              throw new java.lang.NullPointerException("items cannot be null");
+            }
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics.java
Patch:
@@ -21,7 +21,9 @@ public ParentBuilder() {
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((items == null))
-            throw new java.lang.NullPointerException("items cannot be null");
+            {
+              throw new java.lang.NullPointerException("items cannot be null");
+            }
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics2.java
Patch:
@@ -21,7 +21,9 @@ public ParentBuilder() {
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((items == null))
-            throw new java.lang.NullPointerException("items cannot be null");
+            {
+              throw new java.lang.NullPointerException("items cannot be null");
+            }
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -34,7 +34,9 @@ public ParentBuilder() {
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Map<? extends Integer, ? extends String> items) {
         if ((items == null))
-            throw new java.lang.NullPointerException("items cannot be null");
+            {
+              throw new java.lang.NullPointerException("items cannot be null");
+            }
         if ((this.items$key == null))
             {
               this.items$key = new java.util.ArrayList<Integer>();

File: test/transform/resource/after-ecj/SuperBuilderWithPrefixes.java
Patch:
@@ -24,7 +24,9 @@ public SuperBuilderWithPrefixesBuilder() {
     }
     public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
       if ((items == null))
-          throw new java.lang.NullPointerException("items cannot be null");
+          {
+            throw new java.lang.NullPointerException("items cannot be null");
+          }
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.addAll(items);

File: test/transform/resource/before/BuilderSingularMapsWithSetterPrefix.java
Patch:
@@ -1,7 +1,6 @@
 //FORMAT: javaLangAsFQN = skip
 //FORMAT: generated = skip
 //FORMAT: finalParams = skip
-//CONF: lombok.singular.nullCollections = ignore
 import java.util.Map;
 import java.util.SortedMap;
 
@@ -11,6 +10,6 @@
 class BuilderSingularMapsWithSetterPrefix<K, V> {
 	@Singular private Map<K, V> women;
 	@Singular private SortedMap<K, ? extends Number> men;
-	@SuppressWarnings("all") @Singular("rawMap") private Map rawMap;
+	@SuppressWarnings("all") @Singular(value = "rawMap", ignoreNullCollections = true) private Map rawMap;
 	@Singular("stringMap") private Map<String, V> stringMap;
 }

File: src/core/lombok/core/TypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -57,7 +57,7 @@ public String typeRefToFullyQualifiedName(LombokNode<?, ?, ?> context, TypeLibra
 		int firstDot = typeRef.indexOf('.');
 		if (firstDot == -1) firstDot = typeRef.length();
 		String firstTypeRef = typeRef.substring(0, firstDot);
-		String fromExplicitImport = imports.getFullyQualifiedNameForSimpleName(firstTypeRef);
+		String fromExplicitImport = imports.getFullyQualifiedNameForSimpleNameNoAliasing(firstTypeRef);
 		if (fromExplicitImport != null) {
 			String fqn = fromExplicitImport + typeRef.substring(firstDot);
 			if (qualifieds.contains(fqn)) return LombokInternalAliasing.processAliases(fqn);

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -81,7 +81,7 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea
 		sm.registerTransformer(instrumentation);
 		sm.setFilter(new Filter() {
 			@Override public boolean shouldTransform(ClassLoader loader, String className, Class<?> classBeingDefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
-				if (loader != null && loader.getClass().toString().startsWith("org.sonar.classloader")) return false; // Relevant to bug #2351
+				if (loader != null && loader.getClass().getName().startsWith("org.sonar.classloader.")) return false; // Relevant to bug #2351
 				if (!(loader instanceof URLClassLoader)) return true;
 				ClassLoader parent = loader.getParent();
 				if (parent == null) return true;

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -57,6 +57,7 @@ public class EclipsePatcher implements AgentLauncher.AgentLaunchable {
 		String[] args = agentArgs == null ? new String[0] : agentArgs.split(":");
 		boolean forceEcj = false;
 		boolean forceEclipse = false;
+		
 		for (String arg : args) {
 			if (arg.trim().equalsIgnoreCase("ECJ")) forceEcj = true;
 			if (arg.trim().equalsIgnoreCase("ECLIPSE")) forceEclipse = true;
@@ -80,6 +81,7 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea
 		sm.registerTransformer(instrumentation);
 		sm.setFilter(new Filter() {
 			@Override public boolean shouldTransform(ClassLoader loader, String className, Class<?> classBeingDefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
+				if (loader != null && loader.getClass().toString().startsWith("org.sonar.classloader")) return false; // Relevant to bug #2351
 				if (!(loader instanceof URLClassLoader)) return true;
 				ClassLoader parent = loader.getParent();
 				if (parent == null) return true;

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -557,6 +557,7 @@ public MethodDeclaration createEquals(EclipseNode type, Collection<Included<Ecli
 		method.arguments = new Argument[] {new Argument(new char[] { 'o' }, 0, objectRef, Modifier.FINAL)};
 		method.arguments[0].sourceStart = pS; method.arguments[0].sourceEnd = pE;
 		if (!onParam.isEmpty()) method.arguments[0].annotations = onParam.toArray(new Annotation[0]);
+		EclipseHandlerUtil.createRelevantNullableAnnotation(type, method.arguments[0]);
 		setGeneratedBy(method.arguments[0], source);
 		
 		List<Statement> statements = new ArrayList<Statement>();
@@ -806,6 +807,7 @@ public MethodDeclaration createCanEqual(EclipseNode type, ASTNode source, List<A
 		method.arguments = new Argument[] {new Argument(otherName, 0, objectRef, Modifier.FINAL)};
 		method.arguments[0].sourceStart = pS; method.arguments[0].sourceEnd = pE;
 		if (!onParam.isEmpty()) method.arguments[0].annotations = onParam.toArray(new Annotation[0]);
+		EclipseHandlerUtil.createRelevantNullableAnnotation(type, method.arguments[0]);
 		setGeneratedBy(method.arguments[0], source);
 		
 		SingleNameReference otherRef = new SingleNameReference(otherName, p);

File: src/core/lombok/eclipse/handlers/HandleToString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -315,6 +315,7 @@ public static MethodDeclaration createToString(EclipseNode type, Collection<Incl
 		method.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;
 		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;
 		method.statements = new Statement[] { returnStatement };
+		EclipseHandlerUtil.createRelevantNonNullAnnotation(type, method);
 		return method;
 	}
 	

File: src/core/lombok/eclipse/handlers/HandleWith.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2019 The Project Lombok Authors.
+ * Copyright (C) 2012-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -287,6 +287,8 @@ public MethodDeclaration createWith(TypeDeclaration parent, EclipseNode fieldNod
 		}
 		param.annotations = copyAnnotations(source, copyableAnnotations, onParam.toArray(new Annotation[0]));
 		
+		EclipseHandlerUtil.createRelevantNonNullAnnotation(fieldNode, method);
+		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);
 		return method;
 	}

File: src/core/lombok/javac/handlers/HandleWith.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2019 The Project Lombok Authors.
+ * Copyright (C) 2012-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -211,6 +211,7 @@ public void createWithForField(AccessLevel level, JavacNode fieldNode, JavacNode
 		long access = toJavacModifier(level);
 		
 		JCMethodDecl createdWith = createWith(access, fieldNode, fieldNode.getTreeMaker(), source, onMethod, onParam, makeAbstract);
+		createRelevantNonNullAnnotation(fieldNode, createdWith);
 		ClassSymbol sym = ((JCClassDecl) fieldNode.up().get()).sym;
 		Type returnType = sym == null ? null : sym.type;
 		

File: src/core/lombok/core/configuration/NullCheckExceptionType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2019 The Project Lombok Authors.
+ * Copyright (C) 2014-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -23,7 +23,7 @@
 
 import lombok.core.LombokImmutableList;
 
-@ExampleValueString("[NullPointerException | IllegalArgumentException | Assertion | JDK | GUAVA]")
+@ExampleValueString("[NullPointerException | IllegalArgumentException | Assertion | JDK | Guava]")
 public enum NullCheckExceptionType {
 	ILLEGAL_ARGUMENT_EXCEPTION {
 		@Override public String getExceptionType() {

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSetSingularizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2019 The Project Lombok Authors.
+ * Copyright (C) 2015-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -173,6 +173,8 @@ void generatePluralMethod(CheckerFrameworkVersion cfv, boolean deprecate, TypeRe
 		thisDotFieldDotAddAll.receiver = thisDotField;
 		thisDotFieldDotAddAll.selector = "addAll".toCharArray();
 		statements.add(thisDotFieldDotAddAll);
+		
+		nullBehaviorize(data, statements);
 		if (returnStatement != null) statements.add(returnStatement);
 		
 		md.statements = statements.toArray(new Statement[0]);

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -77,7 +77,7 @@ public boolean accept(File file) {
 			return true;
 		}
 		
-		public abstract boolean expectChanges(); 
+		public abstract boolean expectChanges();
 	}
 	
 	private static final FileFilter JAVA_FILE_FILTER = new FileFilter() {

File: test/transform/resource/after-delombok/BuilderDefaultsWarnings.java
Patch:
@@ -38,6 +38,7 @@ public BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder item(final String
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder items(final java.util.Collection<? extends String> items) {
+			if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 			if (this.items == null) this.items = new java.util.ArrayList<String>();
 			this.items.addAll(items);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularAnnotatedTypes.java
Patch:
@@ -36,6 +36,7 @@ public BuilderSingularAnnotatedTypes.BuilderSingularAnnotatedTypesBuilder foo(@M
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularAnnotatedTypes.BuilderSingularAnnotatedTypesBuilder foos(final java.util.Collection<? extends @MyAnnotation @NonNull String> foos) {
+			if (foos == null) throw new java.lang.NullPointerException("foos cannot be null");
 			if (this.foos == null) this.foos = new java.util.ArrayList<@MyAnnotation @NonNull String>();
 			this.foos.addAll(foos);
 			return this;
@@ -63,6 +64,7 @@ public BuilderSingularAnnotatedTypes.BuilderSingularAnnotatedTypesBuilder bar(@M
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularAnnotatedTypes.BuilderSingularAnnotatedTypesBuilder bars(final java.util.Map<? extends @MyAnnotation @NonNull String, ? extends @MyAnnotation @NonNull Integer> bars) {
+			if (bars == null) throw new java.lang.NullPointerException("bars cannot be null");
 			if (this.bars$key == null) {
 				this.bars$key = new java.util.ArrayList<@MyAnnotation @NonNull String>();
 				this.bars$value = new java.util.ArrayList<@MyAnnotation @NonNull Integer>();

File: test/transform/resource/after-delombok/BuilderSingularAnnotatedTypesWithSetterPrefix.java
Patch:
@@ -36,6 +36,7 @@ public BuilderSingularAnnotatedTypesWithSetterPrefix.BuilderSingularAnnotatedTyp
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularAnnotatedTypesWithSetterPrefix.BuilderSingularAnnotatedTypesWithSetterPrefixBuilder withFoos(final java.util.Collection<? extends @MyAnnotation @NonNull String> foos) {
+			if (foos == null) throw new java.lang.NullPointerException("foos cannot be null");
 			if (this.foos == null) this.foos = new java.util.ArrayList<@MyAnnotation @NonNull String>();
 			this.foos.addAll(foos);
 			return this;
@@ -63,6 +64,7 @@ public BuilderSingularAnnotatedTypesWithSetterPrefix.BuilderSingularAnnotatedTyp
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularAnnotatedTypesWithSetterPrefix.BuilderSingularAnnotatedTypesWithSetterPrefixBuilder withBars(final java.util.Map<? extends @MyAnnotation @NonNull String, ? extends @MyAnnotation @NonNull Integer> bars) {
+			if (bars == null) throw new java.lang.NullPointerException("bars cannot be null");
 			if (this.bars$key == null) {
 				this.bars$key = new java.util.ArrayList<@MyAnnotation @NonNull String>();
 				this.bars$value = new java.util.ArrayList<@MyAnnotation @NonNull Integer>();

File: test/transform/resource/after-delombok/BuilderSingularGuavaMaps.java
Patch:
@@ -31,6 +31,7 @@ public BuilderSingularGuavaMaps.BuilderSingularGuavaMapsBuilder<K, V> battleaxe(
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularGuavaMaps.BuilderSingularGuavaMapsBuilder<K, V> battleaxes(final java.util.Map<? extends K, ? extends V> battleaxes) {
+			if (battleaxes == null) throw new java.lang.NullPointerException("battleaxes cannot be null");
 			if (this.battleaxes == null) this.battleaxes = com.google.common.collect.ImmutableMap.builder();
 			this.battleaxes.putAll(battleaxes);
 			return this;
@@ -48,6 +49,7 @@ public BuilderSingularGuavaMaps.BuilderSingularGuavaMapsBuilder<K, V> vertex(fin
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularGuavaMaps.BuilderSingularGuavaMapsBuilder<K, V> vertices(final java.util.Map<? extends Integer, ? extends V> vertices) {
+			if (vertices == null) throw new java.lang.NullPointerException("vertices cannot be null");
 			if (this.vertices == null) this.vertices = com.google.common.collect.ImmutableSortedMap.naturalOrder();
 			this.vertices.putAll(vertices);
 			return this;
@@ -65,6 +67,7 @@ public BuilderSingularGuavaMaps.BuilderSingularGuavaMapsBuilder<K, V> rawMap(fin
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularGuavaMaps.BuilderSingularGuavaMapsBuilder<K, V> rawMap(final java.util.Map<?, ?> rawMap) {
+			if (rawMap == null) throw new java.lang.NullPointerException("rawMap cannot be null");
 			if (this.rawMap == null) this.rawMap = com.google.common.collect.ImmutableBiMap.builder();
 			this.rawMap.putAll(rawMap);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularLists.java
Patch:
@@ -30,6 +30,7 @@ public BuilderSingularLists.BuilderSingularListsBuilder<T> child(final T child)
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularLists.BuilderSingularListsBuilder<T> children(final java.util.Collection<? extends T> children) {
+			if (children == null) throw new java.lang.NullPointerException("children cannot be null");
 			if (this.children == null) this.children = new java.util.ArrayList<T>();
 			this.children.addAll(children);
 			return this;
@@ -47,6 +48,7 @@ public BuilderSingularLists.BuilderSingularListsBuilder<T> scarf(final Number sc
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularLists.BuilderSingularListsBuilder<T> scarves(final java.util.Collection<? extends Number> scarves) {
+			if (scarves == null) throw new java.lang.NullPointerException("scarves cannot be null");
 			if (this.scarves == null) this.scarves = new java.util.ArrayList<Number>();
 			this.scarves.addAll(scarves);
 			return this;
@@ -64,6 +66,7 @@ public BuilderSingularLists.BuilderSingularListsBuilder<T> rawList(final java.la
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularLists.BuilderSingularListsBuilder<T> rawList(final java.util.Collection<?> rawList) {
+			if (rawList == null) throw new java.lang.NullPointerException("rawList cannot be null");
 			if (this.rawList == null) this.rawList = new java.util.ArrayList<java.lang.Object>();
 			this.rawList.addAll(rawList);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularNoAuto.java
Patch:
@@ -28,6 +28,7 @@ public BuilderSingularNoAuto.BuilderSingularNoAutoBuilder things(final String th
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAuto.BuilderSingularNoAutoBuilder things(final java.util.Collection<? extends String> things) {
+			if (things == null) throw new java.lang.NullPointerException("things cannot be null");
 			if (this.things == null) this.things = new java.util.ArrayList<String>();
 			this.things.addAll(things);
 			return this;
@@ -45,6 +46,7 @@ public BuilderSingularNoAuto.BuilderSingularNoAutoBuilder widget(final String wi
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAuto.BuilderSingularNoAutoBuilder widgets(final java.util.Collection<? extends String> widgets) {
+			if (widgets == null) throw new java.lang.NullPointerException("widgets cannot be null");
 			if (this.widgets == null) this.widgets = new java.util.ArrayList<String>();
 			this.widgets.addAll(widgets);
 			return this;
@@ -62,6 +64,7 @@ public BuilderSingularNoAuto.BuilderSingularNoAutoBuilder items(final String ite
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAuto.BuilderSingularNoAutoBuilder items(final java.util.Collection<? extends String> items) {
+			if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 			if (this.items == null) this.items = new java.util.ArrayList<String>();
 			this.items.addAll(items);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -28,6 +28,7 @@ public BuilderSingularNoAutoWithSetterPrefix.BuilderSingularNoAutoWithSetterPref
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAutoWithSetterPrefix.BuilderSingularNoAutoWithSetterPrefixBuilder withThings(final java.util.Collection<? extends String> things) {
+			if (things == null) throw new java.lang.NullPointerException("things cannot be null");
 			if (this.things == null) this.things = new java.util.ArrayList<String>();
 			this.things.addAll(things);
 			return this;
@@ -45,6 +46,7 @@ public BuilderSingularNoAutoWithSetterPrefix.BuilderSingularNoAutoWithSetterPref
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAutoWithSetterPrefix.BuilderSingularNoAutoWithSetterPrefixBuilder withWidgets(final java.util.Collection<? extends String> widgets) {
+			if (widgets == null) throw new java.lang.NullPointerException("widgets cannot be null");
 			if (this.widgets == null) this.widgets = new java.util.ArrayList<String>();
 			this.widgets.addAll(widgets);
 			return this;
@@ -62,6 +64,7 @@ public BuilderSingularNoAutoWithSetterPrefix.BuilderSingularNoAutoWithSetterPref
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAutoWithSetterPrefix.BuilderSingularNoAutoWithSetterPrefixBuilder withItems(final java.util.Collection<? extends String> items) {
+			if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 			if (this.items == null) this.items = new java.util.ArrayList<String>();
 			this.items.addAll(items);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularRedirectToGuava.java
Patch:
@@ -30,6 +30,7 @@ public BuilderSingularRedirectToGuava.BuilderSingularRedirectToGuavaBuilder dang
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularRedirectToGuava.BuilderSingularRedirectToGuavaBuilder dangerMice(final java.lang.Iterable<? extends String> dangerMice) {
+			if (dangerMice == null) throw new java.lang.NullPointerException("dangerMice cannot be null");
 			if (this.dangerMice == null) this.dangerMice = com.google.common.collect.ImmutableSet.builder();
 			this.dangerMice.addAll(dangerMice);
 			return this;
@@ -47,6 +48,7 @@ public BuilderSingularRedirectToGuava.BuilderSingularRedirectToGuavaBuilder thin
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularRedirectToGuava.BuilderSingularRedirectToGuavaBuilder things(final java.util.Map<? extends Integer, ? extends Number> things) {
+			if (things == null) throw new java.lang.NullPointerException("things cannot be null");
 			if (this.things == null) this.things = com.google.common.collect.ImmutableSortedMap.naturalOrder();
 			this.things.putAll(things);
 			return this;
@@ -64,6 +66,7 @@ public BuilderSingularRedirectToGuava.BuilderSingularRedirectToGuavaBuilder dooh
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularRedirectToGuava.BuilderSingularRedirectToGuavaBuilder doohickeys(final java.lang.Iterable<? extends Class<?>> doohickeys) {
+			if (doohickeys == null) throw new java.lang.NullPointerException("doohickeys cannot be null");
 			if (this.doohickeys == null) this.doohickeys = com.google.common.collect.ImmutableList.builder();
 			this.doohickeys.addAll(doohickeys);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNull.java
Patch:
@@ -22,6 +22,7 @@ public BuilderSingularToBuilderWithNull.BuilderSingularToBuilderWithNullBuilder
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularToBuilderWithNull.BuilderSingularToBuilderWithNullBuilder elems(final java.util.Collection<? extends String> elems) {
+			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -22,6 +22,7 @@ public BuilderSingularToBuilderWithNullWithSetterPrefix.BuilderSingularToBuilder
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularToBuilderWithNullWithSetterPrefix.BuilderSingularToBuilderWithNullWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
+			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularWildcardListsWithToBuilder.java
Patch:
@@ -25,6 +25,7 @@ public BuilderSingularWildcardListsWithToBuilder.BuilderSingularWildcardListsWit
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularWildcardListsWithToBuilder.BuilderSingularWildcardListsWithToBuilderBuilder objects(final java.util.Collection<?> objects) {
+			if (objects == null) throw new java.lang.NullPointerException("objects cannot be null");
 			if (this.objects == null) this.objects = new java.util.ArrayList<java.lang.Object>();
 			this.objects.addAll(objects);
 			return this;
@@ -42,6 +43,7 @@ public BuilderSingularWildcardListsWithToBuilder.BuilderSingularWildcardListsWit
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularWildcardListsWithToBuilder.BuilderSingularWildcardListsWithToBuilderBuilder numbers(final java.util.Collection<? extends Number> numbers) {
+			if (numbers == null) throw new java.lang.NullPointerException("numbers cannot be null");
 			if (this.numbers == null) this.numbers = new java.util.ArrayList<Number>();
 			this.numbers.addAll(numbers);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularWithPrefixes.java
Patch:
@@ -19,6 +19,7 @@ public BuilderSingularWithPrefixes.BuilderSingularWithPrefixesBuilder elem(final
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularWithPrefixes.BuilderSingularWithPrefixesBuilder elems(final java.util.Collection<? extends String> elems) {
+			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderSingularWithPrefixesWithSetterPrefix.java
Patch:
@@ -19,6 +19,7 @@ public BuilderSingularWithPrefixesWithSetterPrefix.BuilderSingularWithPrefixesWi
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularWithPrefixesWithSetterPrefix.BuilderSingularWithPrefixesWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
+			if (elems == null) throw new java.lang.NullPointerException("elems cannot be null");
 			if (this.elems == null) this.elems = new java.util.ArrayList<String>();
 			this.elems.addAll(elems);
 			return this;

File: test/transform/resource/after-delombok/BuilderWithDeprecated.java
Patch:
@@ -56,6 +56,7 @@ public BuilderWithDeprecated.BuilderWithDeprecatedBuilder string(final String st
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithDeprecated.BuilderWithDeprecatedBuilder strings(final java.util.Collection<? extends String> strings) {
+			if (strings == null) throw new java.lang.NullPointerException("strings cannot be null");
 			if (this.strings == null) this.strings = new java.util.ArrayList<String>();
 			this.strings.addAll(strings);
 			return this;
@@ -76,6 +77,7 @@ public BuilderWithDeprecated.BuilderWithDeprecatedBuilder number(final Integer n
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithDeprecated.BuilderWithDeprecatedBuilder numbers(final java.lang.Iterable<? extends Integer> numbers) {
+			if (numbers == null) throw new java.lang.NullPointerException("numbers cannot be null");
 			if (this.numbers == null) this.numbers = com.google.common.collect.ImmutableList.builder();
 			this.numbers.addAll(numbers);
 			return this;

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -50,6 +50,7 @@ public BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> bar(final T bar) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> bars(final java.util.Collection<? extends T> bars) {
+			if (bars == null) throw new java.lang.NullPointerException("bars cannot be null");
 			if (this.bars == null) this.bars = new java.util.ArrayList<T>();
 			this.bars.addAll(bars);
 			return this;

File: test/transform/resource/after-delombok/CheckerFrameworkBuilder.java
Patch:
@@ -62,6 +62,7 @@ public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder name(final String
 		@org.checkerframework.checker.builder.qual.ReturnsReceiver
 		@java.lang.SuppressWarnings("all")
 		public CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder names(final java.util.Collection<? extends String> names) {
+			if (names == null) throw new java.lang.NullPointerException("names cannot be null");
 			if (this.names == null) this.names = new java.util.ArrayList<String>();
 			this.names.addAll(names);
 			return this;

File: test/transform/resource/after-delombok/CheckerFrameworkSuperBuilder.java
Patch:
@@ -58,6 +58,7 @@ public B name(final String name) {
 			@org.checkerframework.checker.builder.qual.ReturnsReceiver
 			@java.lang.SuppressWarnings("all")
 			public B names(final java.util.Collection<? extends String> names) {
+				if (names == null) throw new java.lang.NullPointerException("names cannot be null");
 				if (this.names == null) this.names = new java.util.ArrayList<String>();
 				this.names.addAll(names);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderBasic.java
Patch:
@@ -26,6 +26,7 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
+				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderBasicToBuilder.java
Patch:
@@ -69,6 +69,7 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
+				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderSingularAnnotatedTypes.java
Patch:
@@ -32,6 +32,7 @@ public B foo(@MyAnnotation @NonNull final String foo) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public B foos(final java.util.Collection<? extends @MyAnnotation @NonNull String> foos) {
+			if (foos == null) throw new java.lang.NullPointerException("foos cannot be null");
 			if (this.foos == null) this.foos = new java.util.ArrayList<@MyAnnotation @NonNull String>();
 			this.foos.addAll(foos);
 			return self();
@@ -59,6 +60,7 @@ public B bar(@MyAnnotation @NonNull final String barKey, @MyAnnotation @NonNull
 		}
 		@java.lang.SuppressWarnings("all")
 		public B bars(final java.util.Map<? extends @MyAnnotation @NonNull String, ? extends @MyAnnotation @NonNull Integer> bars) {
+			if (bars == null) throw new java.lang.NullPointerException("bars cannot be null");
 			if (this.bars$key == null) {
 				this.bars$key = new java.util.ArrayList<@MyAnnotation @NonNull String>();
 				this.bars$value = new java.util.ArrayList<@MyAnnotation @NonNull Integer>();

File: test/transform/resource/after-delombok/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -26,6 +26,7 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
+				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics.java
Patch:
@@ -26,6 +26,7 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
+				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics2.java
Patch:
@@ -26,6 +26,7 @@ public B item(final String item) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Collection<? extends String> items) {
+				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 				if (this.items == null) this.items = new java.util.ArrayList<String>();
 				this.items.addAll(items);
 				return self();

File: test/transform/resource/after-delombok/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -42,6 +42,7 @@ public B item(final Integer itemKey, final String itemValue) {
 			}
 			@java.lang.SuppressWarnings("all")
 			public B items(final java.util.Map<? extends Integer, ? extends String> items) {
+				if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 				if (this.items$key == null) {
 					this.items$key = new java.util.ArrayList<Integer>();
 					this.items$value = new java.util.ArrayList<String>();

File: test/transform/resource/after-delombok/SuperBuilderWithPrefixes.java
Patch:
@@ -32,6 +32,7 @@ public B item(final String item) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public B items(final java.util.Collection<? extends String> items) {
+			if (items == null) throw new java.lang.NullPointerException("items cannot be null");
 			if (this.items == null) this.items = new java.util.ArrayList<String>();
 			this.items.addAll(items);
 			return self();

File: test/transform/resource/after-ecj/BuilderDefaultsWarnings.java
Patch:
@@ -23,6 +23,8 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder items(final java.util.Collection<? extends String> items) {
+      if ((items == null))
+          throw new java.lang.NullPointerException("items cannot be null");
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.addAll(items);

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNull.java
Patch:
@@ -12,6 +12,8 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNull.BuilderSingularToBuilderWithNullBuilder elems(final java.util.Collection<? extends String> elems) {
+      if ((elems == null))
+          throw new java.lang.NullPointerException("elems cannot be null");
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -12,6 +12,8 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullWithSetterPrefix.BuilderSingularToBuilderWithNullWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
+      if ((elems == null))
+          throw new java.lang.NullPointerException("elems cannot be null");
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularWithPrefixes.java
Patch:
@@ -12,6 +12,8 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixes.BuilderSingularWithPrefixesBuilder elems(final java.util.Collection<? extends String> elems) {
+      if ((elems == null))
+          throw new java.lang.NullPointerException("elems cannot be null");
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularWithPrefixesWithSetterPrefix.java
Patch:
@@ -12,6 +12,8 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesWithSetterPrefix.BuilderSingularWithPrefixesWithSetterPrefixBuilder withElems(final java.util.Collection<? extends String> elems) {
+      if ((elems == null))
+          throw new java.lang.NullPointerException("elems cannot be null");
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -28,6 +28,8 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> bars(final java.util.Collection<? extends T> bars) {
+      if ((bars == null))
+          throw new java.lang.NullPointerException("bars cannot be null");
       if ((this.bars == null))
           this.bars = new java.util.ArrayList<T>();
       this.bars.addAll(bars);

File: test/transform/resource/after-ecj/CheckerFrameworkBuilder.java
Patch:
@@ -31,6 +31,8 @@
       return this;
     }
     public @org.checkerframework.checker.builder.qual.ReturnsReceiver @java.lang.SuppressWarnings("all") CheckerFrameworkBuilder.CheckerFrameworkBuilderBuilder names(final java.util.Collection<? extends String> names) {
+      if ((names == null))
+          throw new java.lang.NullPointerException("names cannot be null");
       if ((this.names == null))
           this.names = new java.util.ArrayList<String>();
       this.names.addAll(names);

File: test/transform/resource/after-ecj/CheckerFrameworkSuperBuilder.java
Patch:
@@ -32,6 +32,8 @@ public ParentBuilder() {
         return self();
       }
       public @org.checkerframework.checker.builder.qual.ReturnsReceiver @java.lang.SuppressWarnings("all") B names(final java.util.Collection<? extends String> names) {
+        if ((names == null))
+            throw new java.lang.NullPointerException("names cannot be null");
         if ((this.names == null))
             this.names = new java.util.ArrayList<String>();
         this.names.addAll(names);

File: test/transform/resource/after-ecj/I2335_BuilderMultipleObtainVia.java
Patch:
@@ -44,8 +44,8 @@ public void setTheLong(Long theLong) {
     return new I2335_BuilderMultipleObtainVia.I2335_BuilderMultipleObtainViaBuilder();
   }
   public @java.lang.SuppressWarnings("all") I2335_BuilderMultipleObtainVia.I2335_BuilderMultipleObtainViaBuilder toBuilder() {
-    String theString = this.getTheString();
-    Long theLong = this.getTheLong();
+    final String theString = this.getTheString();
+    final Long theLong = this.getTheLong();
     return new I2335_BuilderMultipleObtainVia.I2335_BuilderMultipleObtainViaBuilder().theString(theString).theLong(theLong);
   }
 }

File: test/transform/resource/after-ecj/SuperBuilderBasic.java
Patch:
@@ -20,6 +20,8 @@ public ParentBuilder() {
         return self();
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
+        if ((items == null))
+            throw new java.lang.NullPointerException("items cannot be null");
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderBasicToBuilder.java
Patch:
@@ -46,6 +46,8 @@ public ParentBuilder() {
         return self();
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
+        if ((items == null))
+            throw new java.lang.NullPointerException("items cannot be null");
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -20,6 +20,8 @@ public ParentBuilder() {
         return self();
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
+        if ((items == null))
+            throw new java.lang.NullPointerException("items cannot be null");
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics.java
Patch:
@@ -20,6 +20,8 @@ public ParentBuilder() {
         return self();
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
+        if ((items == null))
+            throw new java.lang.NullPointerException("items cannot be null");
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics2.java
Patch:
@@ -20,6 +20,8 @@ public ParentBuilder() {
         return self();
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
+        if ((items == null))
+            throw new java.lang.NullPointerException("items cannot be null");
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -33,6 +33,8 @@ public ParentBuilder() {
         return self();
       }
       public @java.lang.SuppressWarnings("all") B items(final java.util.Map<? extends Integer, ? extends String> items) {
+        if ((items == null))
+            throw new java.lang.NullPointerException("items cannot be null");
         if ((this.items$key == null))
             {
               this.items$key = new java.util.ArrayList<Integer>();

File: test/transform/resource/after-ecj/SuperBuilderWithPrefixes.java
Patch:
@@ -23,6 +23,8 @@ public SuperBuilderWithPrefixesBuilder() {
       return self();
     }
     public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
+      if ((items == null))
+          throw new java.lang.NullPointerException("items cannot be null");
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.addAll(items);

File: test/transform/resource/before/BuilderSingularMapsWithSetterPrefix.java
Patch:
@@ -1,6 +1,7 @@
 //FORMAT: javaLangAsFQN = skip
 //FORMAT: generated = skip
 //FORMAT: finalParams = skip
+//CONF: lombok.singular.nullCollections = ignore
 import java.util.Map;
 import java.util.SortedMap;
 

File: src/core/lombok/core/configuration/BubblingConfigurationResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Project Lombok Authors.
+ * Copyright (C) 2014-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/core/configuration/CheckerFrameworkVersion.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2019 The Project Lombok Authors.
+ * Copyright (C) 2019-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: test/configuration/src/lombok/core/configuration/TestConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Project Lombok Authors.
+ * Copyright (C) 2014-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -52,7 +52,7 @@ public void testDisplayVerbose() throws Exception {
 		PrintStream outStream = new PrintStream(rawOut);
 		PrintStream errStream = new PrintStream(rawErr);
 		
-		int result = new ConfigurationApp().redirectOutput(outStream, errStream).display(keys, true, paths, true);
+		int result = new ConfigurationApp().redirectOutput(outStream, errStream).display(keys, true, paths, true, false);
 		
 		outStream.flush();
 		errStream.flush();

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -86,7 +86,8 @@ public static <T> BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> builder()
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> toBuilder() {
-		final BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilder.BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.<T>rrr(this));
+		final T foo = BuilderWithToBuilder.<T>rrr(this);
+		final BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilder.BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(foo);
 		if (this.bars != null) builder.bars(this.bars);
 		return builder;
 	}

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -74,7 +74,8 @@ public static <K>K rrr(BuilderWithToBuilder<K> x) {
     return new BuilderWithToBuilder.BuilderWithToBuilderBuilder<T>();
   }
   public @java.lang.SuppressWarnings("all") BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> toBuilder() {
-    final BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilder.BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.<T>rrr(this));
+    final T foo = BuilderWithToBuilder.<T>rrr(this);
+    final BuilderWithToBuilder.BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilder.BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(foo);
     if ((this.bars != null))
         builder.bars(this.bars);
     return builder;

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -819,7 +819,7 @@ private void makePrefixedSetterMethodForBuilder(CheckerFrameworkVersion cfv, Jav
 			newMethod.params = List.of(recv, newMethod.params.get(0));
 		}
 		recursiveSetGeneratedBy(newMethod, source.get(), builderType.getContext());
-		copyJavadoc(originalFieldNode, newMethod, CopyJavadoc.SETTER);
+		copyJavadoc(originalFieldNode, newMethod, CopyJavadoc.SETTER, true);
 		
 		injectMethod(builderType, newMethod);
 	}

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -279,7 +279,7 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		
 		JCMethodDecl decl = recursiveSetGeneratedBy(treeMaker.MethodDef(treeMaker.Modifiers(access, annsOnMethod), methodName, methodType,
 			methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source.get(), field.getContext());
-		copyJavadoc(field, decl, CopyJavadoc.SETTER);
+		copyJavadoc(field, decl, CopyJavadoc.SETTER, returnStatement != null);
 		return decl;
 	}
 }

File: test/transform/resource/after-delombok/BuilderJavadoc.java
Patch:
@@ -52,6 +52,7 @@ public BuilderJavadocBuilder<T> predefWithJavadoc(final int x) {
 		 * basic gets only a builder setter.
 		 * @see #getsetwith
 		 * @param tag is moved to the setter.
+		 * @return {@code this}.
 		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderJavadoc.BuilderJavadocBuilder<T> basic(final int basic) {
@@ -61,6 +62,7 @@ public BuilderJavadoc.BuilderJavadocBuilder<T> basic(final int basic) {
 		/**
 		 * getsetwith gets a builder setter, an instance getter and setter, and a wither.
 		 * @param tag is moved to the setters and wither.
+		 * @return {@code this}.
 		 */
 		@java.lang.SuppressWarnings("all")
 		public BuilderJavadoc.BuilderJavadocBuilder<T> getsetwith(final int getsetwith) {
@@ -108,6 +110,7 @@ public void setGetsetwith(final int getsetwith) {
 	/**
 	 * getsetwith gets a builder setter, an instance getter and setter, and a wither.
 	 * @param tag is moved to the setters and wither.
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
 	public BuilderJavadoc<T> withGetsetwith(final int getsetwith) {

File: test/transform/resource/after-delombok/BuilderWithDeprecated.java
Patch:
@@ -32,6 +32,7 @@ public static class BuilderWithDeprecatedBuilder {
 		}
 		/**
 		 * @deprecated since always
+		 * @return {@code this}.
 		 */
 		@java.lang.Deprecated
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/GetterSetterJavadoc.java
Patch:
@@ -116,7 +116,7 @@ public int fieldName() {
 	 * Some text
 	 * 
 	 * @param fieldName Hello, World5
-	 * @return this
+	 * @return {@code this}.
 	 */
 	@java.lang.SuppressWarnings("all")
 	public GetterSetterJavadoc4 fieldName(final int fieldName) {

File: test/transform/resource/after-delombok/SetterAndWithMethodJavadoc.java
Patch:
@@ -22,6 +22,7 @@ public void setI(final int i) {
 	/**
 	 * Some value.
 	 * @param the new value
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
 	public SetterAndWithMethodJavadoc withI(final int i) {
@@ -38,6 +39,7 @@ public void setJ(final int j) {
 	/**
 	 * Reinstantiate with some other value.
 	 * @param the other new other value
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.SuppressWarnings("all")
 	public SetterAndWithMethodJavadoc withJ(final int j) {

File: test/transform/resource/after-delombok/WithMethodMarkedDeprecated.java
Patch:
@@ -14,6 +14,7 @@ public WithMethodMarkedDeprecated withAnnotation(final int annotation) {
 	}
 	/**
 	 * @deprecated
+	 * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2019 The Project Lombok Authors.
+ * Copyright (C) 2010-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2019 The Project Lombok Authors.
+ * Copyright (C) 2013-2020 The Project Lombok Authors.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2019 The Project Lombok Authors.
+ * Copyright (C) 2013-2020 The Project Lombok Authors.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2019 The Project Lombok Authors.
+ * Copyright (C) 2009-2020 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: test/transform/resource/after-delombok/BuilderComplex.java
Patch:
@@ -37,7 +37,7 @@ public BuilderComplex.TestVoidName<T> selfRef(final BuilderComplex selfRef) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public void execute() {
-			BuilderComplex.<T>testVoidWithGenerics(number, arg2, arg3, selfRef);
+			BuilderComplex.<T>testVoidWithGenerics(this.number, this.arg2, this.arg3, this.selfRef);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderDefaults.java
Patch:
@@ -51,10 +51,10 @@ public BuilderDefaults.BuilderDefaultsBuilder z(final long z) {
 		@java.lang.SuppressWarnings("all")
 		public BuilderDefaults build() {
 			int x$value = this.x$value;
-			if (!x$set) x$value = BuilderDefaults.$default$x();
+			if (!this.x$set) x$value = BuilderDefaults.$default$x();
 			long z$value = this.z$value;
-			if (!z$set) z$value = BuilderDefaults.$default$z();
-			return new BuilderDefaults(x$value, name, z$value);
+			if (!this.z$set) z$value = BuilderDefaults.$default$z();
+			return new BuilderDefaults(x$value, this.name, z$value);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderDefaultsGenerics.java
Patch:
@@ -59,11 +59,11 @@ public BuilderDefaultsGenerics.BuilderDefaultsGenericsBuilder<N, T, R> arrr(fina
 		@java.lang.SuppressWarnings("all")
 		public BuilderDefaultsGenerics<N, T, R> build() {
 			java.util.concurrent.Callable<N> callable$value = this.callable$value;
-			if (!callable$set) callable$value = BuilderDefaultsGenerics.<N, T, R>$default$callable();
+			if (!this.callable$set) callable$value = BuilderDefaultsGenerics.<N, T, R>$default$callable();
 			T tee$value = this.tee$value;
-			if (!tee$set) tee$value = BuilderDefaultsGenerics.<N, T, R>$default$tee();
+			if (!this.tee$set) tee$value = BuilderDefaultsGenerics.<N, T, R>$default$tee();
 			R arrr$value = this.arrr$value;
-			if (!arrr$set) arrr$value = BuilderDefaultsGenerics.<N, T, R>$default$arrr();
+			if (!this.arrr$set) arrr$value = BuilderDefaultsGenerics.<N, T, R>$default$arrr();
 			return new BuilderDefaultsGenerics<N, T, R>(callable$value, tee$value, arrr$value);
 		}
 		@java.lang.Override

File: test/transform/resource/after-delombok/BuilderDefaultsWarnings.java
Patch:
@@ -60,7 +60,7 @@ public BuilderDefaultsWarnings build() {
 			default: 
 				items = java.util.Collections.unmodifiableList(new java.util.ArrayList<String>(this.items));
 			}
-			return new BuilderDefaultsWarnings(x, z, items);
+			return new BuilderDefaultsWarnings(this.x, this.z, items);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderGenericMethod.java
Patch:
@@ -25,7 +25,7 @@ public BuilderGenericMethod<T>.MapBuilder<N> b(final long b) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public Map<N, T> build() {
-			return BuilderGenericMethod.this.<N>foo(a, b);
+			return BuilderGenericMethod.this.<N>foo(this.a, this.b);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderInstanceMethod.java
Patch:
@@ -38,7 +38,7 @@ public BuilderInstanceMethod<T>.StringBuilder also(final List<T> also) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public String build() {
-			return BuilderInstanceMethod.this.create(show, yes, also, $andMe);
+			return BuilderInstanceMethod.this.create(this.show, this.yes, this.also, this.$andMe);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderJavadoc.java
Patch:
@@ -69,7 +69,7 @@ public BuilderJavadoc.BuilderJavadocBuilder<T> getsetwith(final int getsetwith)
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderJavadoc<T> build() {
-			return new BuilderJavadoc<T>(basic, getsetwith, predef, predefWithJavadoc);
+			return new BuilderJavadoc<T>(this.basic, this.getsetwith, this.predef, this.predefWithJavadoc);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderSimple.java
Patch:
@@ -30,7 +30,7 @@ public BuilderSimple.BuilderSimpleBuilder<T> also(final List<T> also) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSimple<T> build() {
-			return new BuilderSimple<T>(yes, also);
+			return new BuilderSimple<T>(this.yes, this.also);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -19,7 +19,7 @@ public BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> wit
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSimpleWithSetterPrefix<T> build() {
-			return new BuilderSimpleWithSetterPrefix<T>(unprefixed);
+			return new BuilderSimpleWithSetterPrefix<T>(this.unprefixed);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderTypeAnnos.java
Patch:
@@ -29,7 +29,7 @@ public BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(@TA final List<String> foo)
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderTypeAnnos build() {
-			return new BuilderTypeAnnos(foo);
+			return new BuilderTypeAnnos(this.foo);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -29,7 +29,7 @@ public BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderTypeAnnosWithSetterPrefix build() {
-			return new BuilderTypeAnnosWithSetterPrefix(foo);
+			return new BuilderTypeAnnosWithSetterPrefix(this.foo);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithAccessors.java
Patch:
@@ -45,7 +45,7 @@ public BuilderWithAccessors.BuilderWithAccessorsBuilder _bar(final int _bar) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithAccessors build() {
-			return new BuilderWithAccessors(plower, upper, foo, _bar);
+			return new BuilderWithAccessors(this.plower, this.upper, this.foo, this._bar);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithBadNames.java
Patch:
@@ -27,7 +27,7 @@ public BuilderWithBadNames.BuilderWithBadNamesBuilder toString(final String toSt
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithBadNames build() {
-			return new BuilderWithBadNames(build, toString);
+			return new BuilderWithBadNames(this.build, this.toString);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithDeprecated.java
Patch:
@@ -99,7 +99,7 @@ public BuilderWithDeprecated build() {
 				strings = java.util.Collections.unmodifiableList(new java.util.ArrayList<String>(this.strings));
 			}
 			com.google.common.collect.ImmutableList<Integer> numbers = this.numbers == null ? com.google.common.collect.ImmutableList.<Integer>of() : this.numbers.build();
-			return new BuilderWithDeprecated(dep1, dep2, strings, numbers);
+			return new BuilderWithDeprecated(this.dep1, this.dep2, strings, numbers);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithExistingBuilderClass.java
Patch:
@@ -25,7 +25,7 @@ public BuilderWithExistingBuilderClass.BuilderWithExistingBuilderClassBuilder<Z>
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithExistingBuilderClass<String, Z> build() {
-			return BuilderWithExistingBuilderClass.<Z>staticMethod(arg1, arg2, arg3);
+			return BuilderWithExistingBuilderClass.<Z>staticMethod(this.arg1, this.arg2, this.arg3);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -25,7 +25,7 @@ public BuilderWithExistingBuilderClassWithSetterPrefix.BuilderWithExistingBuilde
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithExistingBuilderClassWithSetterPrefix<String, Z> build() {
-			return BuilderWithExistingBuilderClassWithSetterPrefix.<Z>staticMethod(arg1, arg2, arg3);
+			return BuilderWithExistingBuilderClassWithSetterPrefix.<Z>staticMethod(this.arg1, this.arg2, this.arg3);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithNoBuilderMethod.java
Patch:
@@ -18,7 +18,7 @@ public BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final Stri
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNoBuilderMethod build() {
-			return new BuilderWithNoBuilderMethod(a);
+			return new BuilderWithNoBuilderMethod(this.a);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithNonNull.java
Patch:
@@ -25,7 +25,7 @@ public BuilderWithNonNull.BuilderWithNonNullBuilder id(@lombok.NonNull final Str
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNonNull build() {
-			return new BuilderWithNonNull(id);
+			return new BuilderWithNonNull(this.id);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -25,7 +25,7 @@ public BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuil
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithNonNullWithSetterPrefix build() {
-			return new BuilderWithNonNullWithSetterPrefix(id);
+			return new BuilderWithNonNullWithSetterPrefix(this.id);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithRecursiveGenerics.java
Patch:
@@ -31,7 +31,7 @@ public BuilderWithRecursiveGenerics.Test.TestBuilder<Foo, Bar, Quz> bar(final Ba
 			}
 			@java.lang.SuppressWarnings("all")
 			public BuilderWithRecursiveGenerics.Test<Foo, Bar, Quz> build() {
-				return new BuilderWithRecursiveGenerics.Test<Foo, Bar, Quz>(foo, bar);
+				return new BuilderWithRecursiveGenerics.Test<Foo, Bar, Quz>(this.foo, this.bar);
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -72,7 +72,7 @@ public BuilderWithToBuilder<T> build() {
 			default: 
 				bars = java.util.Collections.unmodifiableList(new java.util.ArrayList<T>(this.bars));
 			}
-			return new BuilderWithToBuilder<T>(one, two, foo, bars);
+			return new BuilderWithToBuilder<T>(this.one, this.two, this.foo, bars);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
@@ -127,7 +127,7 @@ public ConstructorWithToBuilder.ConstructorWithToBuilderBuilder<T> bars(final co
 		}
 		@java.lang.SuppressWarnings("all")
 		public ConstructorWithToBuilder<T> build() {
-			return new ConstructorWithToBuilder<T>(mOne, baz, bars);
+			return new ConstructorWithToBuilder<T>(this.mOne, this.baz, this.bars);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithTolerate.java
Patch:
@@ -21,7 +21,7 @@ public BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithTolerate build() {
-			return new BuilderWithTolerate(value);
+			return new BuilderWithTolerate(this.value);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/CheckerFrameworkBuilder.java
Patch:
@@ -87,8 +87,8 @@ public CheckerFrameworkBuilder build(@org.checkerframework.checker.builder.qual.
 				names = java.util.Collections.unmodifiableList(new java.util.ArrayList<String>(this.names));
 			}
 			int x$value = this.x$value;
-			if (!x$set) x$value = CheckerFrameworkBuilder.$default$x();
-			return new CheckerFrameworkBuilder(x$value, y, z, names);
+			if (!this.x$set) x$value = CheckerFrameworkBuilder.$default$x();
+			return new CheckerFrameworkBuilder(x$value, this.y, this.z, names);
 		}
 		@org.checkerframework.dataflow.qual.SideEffectFree
 		@java.lang.Override

File: test/transform/resource/after-delombok/ConstructorsWithBuilderDefaults.java
Patch:
@@ -30,8 +30,8 @@ public ConstructorsWithBuilderDefaults.ConstructorsWithBuilderDefaultsBuilder y(
 		@java.lang.SuppressWarnings("all")
 		public ConstructorsWithBuilderDefaults build() {
 			int x$value = this.x$value;
-			if (!x$set) x$value = ConstructorsWithBuilderDefaults.$default$x();
-			return new ConstructorsWithBuilderDefaults(x$value, y);
+			if (!this.x$set) x$value = ConstructorsWithBuilderDefaults.$default$x();
+			return new ConstructorsWithBuilderDefaults(x$value, this.y);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/ConstructorsWithBuilderDefaults2.java
Patch:
@@ -54,10 +54,10 @@ public ConstructorsWithBuilderDefaults.ConstructorsWithBuilderDefaultsBuilder<T>
 		@java.lang.SuppressWarnings("all")
 		public ConstructorsWithBuilderDefaults<T> build() {
 			java.util.List<T> z$value = this.z$value;
-			if (!z$set) z$value = ConstructorsWithBuilderDefaults.<T>$default$z();
+			if (!this.z$set) z$value = ConstructorsWithBuilderDefaults.<T>$default$z();
 			T x$value = this.x$value;
-			if (!x$set) x$value = ConstructorsWithBuilderDefaults.<T>$default$x();
-			return new ConstructorsWithBuilderDefaults<T>(z$value, x$value, q);
+			if (!this.x$set) x$value = ConstructorsWithBuilderDefaults.<T>$default$x();
+			return new ConstructorsWithBuilderDefaults<T>(z$value, x$value, this.q);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/JacksonJsonProperty.java
Patch:
@@ -25,7 +25,7 @@ public JacksonJsonProperty.JacksonJsonPropertyBuilder kebabCaseProp(final String
 		}
 		@java.lang.SuppressWarnings("all")
 		public JacksonJsonProperty build() {
-			return new JacksonJsonProperty(kebabCaseProp);
+			return new JacksonJsonProperty(this.kebabCaseProp);
 		}
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-ecj/BuilderComplex.java
Patch:
@@ -26,7 +26,7 @@ class BuilderComplex {
       return this;
     }
     public @java.lang.SuppressWarnings("all") void execute() {
-      BuilderComplex.<T>testVoidWithGenerics(number, arg2, arg3, selfRef);
+      BuilderComplex.<T>testVoidWithGenerics(this.number, this.arg2, this.arg3, this.selfRef);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((((("BuilderComplex.TestVoidName(number=" + this.number) + ", arg2=") + this.arg2) + ", arg3=") + this.arg3) + ", selfRef=") + this.selfRef) + ")");

File: test/transform/resource/after-ecj/BuilderDefaultsWarnings.java
Patch:
@@ -45,7 +45,7 @@
       default :
           items = java.util.Collections.unmodifiableList(new java.util.ArrayList<String>(this.items));
       }
-      return new BuilderDefaultsWarnings(x, z, items);
+      return new BuilderDefaultsWarnings(this.x, this.z, items);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("BuilderDefaultsWarnings.BuilderDefaultsWarningsBuilder(x=" + this.x) + ", z=") + this.z) + ", items=") + this.items) + ")");

File: test/transform/resource/after-ecj/BuilderGenericMethod.java
Patch:
@@ -17,7 +17,7 @@ class BuilderGenericMethod<T> {
       return this;
     }
     public @java.lang.SuppressWarnings("all") Map<N, T> build() {
-      return BuilderGenericMethod.this.<N>foo(a, b);
+      return BuilderGenericMethod.this.<N>foo(this.a, this.b);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((("BuilderGenericMethod.MapBuilder(a=" + this.a) + ", b=") + this.b) + ")");

File: test/transform/resource/after-ecj/BuilderInstanceMethod.java
Patch:
@@ -25,7 +25,7 @@ class BuilderInstanceMethod<T> {
       return this;
     }
     public @java.lang.SuppressWarnings("all") String build() {
-      return BuilderInstanceMethod.this.create(show, yes, also, $andMe);
+      return BuilderInstanceMethod.this.create(this.show, this.yes, this.also, this.$andMe);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((((("BuilderInstanceMethod.StringBuilder(show=" + this.show) + ", yes=") + this.yes) + ", also=") + this.also) + ", $andMe=") + this.$andMe) + ")");

File: test/transform/resource/after-ecj/BuilderJavadoc.java
Patch:
@@ -25,7 +25,7 @@ public BuilderJavadocBuilder<T> predefWithJavadoc(final int x) {
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderJavadoc<T> build() {
-      return new BuilderJavadoc<T>(basic, getsetwith, predef, predefWithJavadoc);
+      return new BuilderJavadoc<T>(this.basic, this.getsetwith, this.predef, this.predefWithJavadoc);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((((("BuilderJavadoc.BuilderJavadocBuilder(basic=" + this.basic) + ", getsetwith=") + this.getsetwith) + ", predef=") + this.predef) + ", predefWithJavadoc=") + this.predefWithJavadoc) + ")");

File: test/transform/resource/after-ecj/BuilderSimple.java
Patch:
@@ -15,7 +15,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSimple<T> build() {
-      return new BuilderSimple<T>(yes, also);
+      return new BuilderSimple<T>(this.yes, this.also);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((("BuilderSimple.BuilderSimpleBuilder(yes=" + this.yes) + ", also=") + this.also) + ")");

File: test/transform/resource/after-ecj/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -10,7 +10,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefix<T> build() {
-      return new BuilderSimpleWithSetterPrefix<T>(unprefixed);
+      return new BuilderSimpleWithSetterPrefix<T>(this.unprefixed);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder(unprefixed=" + this.unprefixed) + ")");

File: test/transform/resource/after-ecj/BuilderTypeAnnos.java
Patch:
@@ -16,7 +16,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderTypeAnnos build() {
-      return new BuilderTypeAnnos(foo);
+      return new BuilderTypeAnnos(this.foo);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderTypeAnnos.BuilderTypeAnnosBuilder(foo=" + this.foo) + ")");

File: test/transform/resource/after-ecj/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -16,7 +16,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefix build() {
-      return new BuilderTypeAnnosWithSetterPrefix(foo);
+      return new BuilderTypeAnnosWithSetterPrefix(this.foo);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder(foo=" + this.foo) + ")");

File: test/transform/resource/after-ecj/BuilderWithAccessors.java
Patch:
@@ -24,7 +24,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithAccessors build() {
-      return new BuilderWithAccessors(plower, upper, foo, _bar);
+      return new BuilderWithAccessors(this.plower, this.upper, this.foo, this._bar);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((((("BuilderWithAccessors.BuilderWithAccessorsBuilder(plower=" + this.plower) + ", upper=") + this.upper) + ", foo=") + this.foo) + ", _bar=") + this._bar) + ")");

File: test/transform/resource/after-ecj/BuilderWithBadNames.java
Patch:
@@ -14,7 +14,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithBadNames build() {
-      return new BuilderWithBadNames(build, toString);
+      return new BuilderWithBadNames(this.build, this.toString);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((("BuilderWithBadNames.BuilderWithBadNamesBuilder(build=" + this.build) + ", toString=") + this.toString) + ")");

File: test/transform/resource/after-ecj/BuilderWithDeprecated.java
Patch:
@@ -64,7 +64,7 @@
           strings = java.util.Collections.unmodifiableList(new java.util.ArrayList<String>(this.strings));
       }
       com.google.common.collect.ImmutableList<Integer> numbers = ((this.numbers == null) ? com.google.common.collect.ImmutableList.<Integer>of() : this.numbers.build());
-      return new BuilderWithDeprecated(dep1, dep2, strings, numbers);
+      return new BuilderWithDeprecated(this.dep1, this.dep2, strings, numbers);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((((("BuilderWithDeprecated.BuilderWithDeprecatedBuilder(dep1=" + this.dep1) + ", dep2=") + this.dep2) + ", strings=") + this.strings) + ", numbers=") + this.numbers) + ")");

File: test/transform/resource/after-ecj/BuilderWithExistingBuilderClass.java
Patch:
@@ -18,7 +18,7 @@ public void arg2(boolean arg) {
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithExistingBuilderClass<String, Z> build() {
-      return BuilderWithExistingBuilderClass.<Z>staticMethod(arg1, arg2, arg3);
+      return BuilderWithExistingBuilderClass.<Z>staticMethod(this.arg1, this.arg2, this.arg3);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("BuilderWithExistingBuilderClass.BuilderWithExistingBuilderClassBuilder(arg1=" + this.arg1) + ", arg2=") + this.arg2) + ", arg3=") + this.arg3) + ")");

File: test/transform/resource/after-ecj/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -18,7 +18,7 @@ public void withArg2(boolean arg) {
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithExistingBuilderClassWithSetterPrefix<String, Z> build() {
-      return BuilderWithExistingBuilderClassWithSetterPrefix.<Z>staticMethod(arg1, arg2, arg3);
+      return BuilderWithExistingBuilderClassWithSetterPrefix.<Z>staticMethod(this.arg1, this.arg2, this.arg3);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("BuilderWithExistingBuilderClassWithSetterPrefix.BuilderWithExistingBuilderClassWithSetterPrefixBuilder(arg1=" + this.arg1) + ", arg2=") + this.arg2) + ", arg3=") + this.arg3) + ")");

File: test/transform/resource/after-ecj/BuilderWithNoBuilderMethod.java
Patch:
@@ -10,7 +10,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethod build() {
-      return new BuilderWithNoBuilderMethod(a);
+      return new BuilderWithNoBuilderMethod(this.a);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder(a=" + this.a) + ")");

File: test/transform/resource/after-ecj/BuilderWithNonNull.java
Patch:
@@ -13,7 +13,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithNonNull build() {
-      return new BuilderWithNonNull(id);
+      return new BuilderWithNonNull(this.id);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderWithNonNull.BuilderWithNonNullBuilder(id=" + this.id) + ")");

File: test/transform/resource/after-ecj/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -13,7 +13,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefix build() {
-      return new BuilderWithNonNullWithSetterPrefix(id);
+      return new BuilderWithNonNullWithSetterPrefix(this.id);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder(id=" + this.id) + ")");

File: test/transform/resource/after-ecj/BuilderWithRecursiveGenerics.java
Patch:
@@ -20,7 +20,7 @@ interface Inter<T, U extends Inter<T, U>> {
         return this;
       }
       public @java.lang.SuppressWarnings("all") BuilderWithRecursiveGenerics.Test<Foo, Bar, Quz> build() {
-        return new BuilderWithRecursiveGenerics.Test<Foo, Bar, Quz>(foo, bar);
+        return new BuilderWithRecursiveGenerics.Test<Foo, Bar, Quz>(this.foo, this.bar);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
         return (((("BuilderWithRecursiveGenerics.Test.TestBuilder(foo=" + this.foo) + ", bar=") + this.bar) + ")");

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -50,7 +50,7 @@
       default :
           bars = java.util.Collections.unmodifiableList(new java.util.ArrayList<T>(this.bars));
       }
-      return new BuilderWithToBuilder<T>(one, two, foo, bars);
+      return new BuilderWithToBuilder<T>(this.one, this.two, this.foo, bars);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((((("BuilderWithToBuilder.BuilderWithToBuilderBuilder(one=" + this.one) + ", two=") + this.two) + ", foo=") + this.foo) + ", bars=") + this.bars) + ")");
@@ -101,7 +101,7 @@ public static <K>K rrr(BuilderWithToBuilder<K> x) {
       return this;
     }
     public @java.lang.SuppressWarnings("all") ConstructorWithToBuilder<T> build() {
-      return new ConstructorWithToBuilder<T>(mOne, baz, bars);
+      return new ConstructorWithToBuilder<T>(this.mOne, this.baz, this.bars);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (((((("ConstructorWithToBuilder.ConstructorWithToBuilderBuilder(mOne=" + this.mOne) + ", baz=") + this.baz) + ", bars=") + this.bars) + ")");

File: test/transform/resource/after-ecj/BuilderWithTolerate.java
Patch:
@@ -14,7 +14,7 @@ public static class BuilderWithTolerateBuilder {
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderWithTolerate build() {
-      return new BuilderWithTolerate(value);
+      return new BuilderWithTolerate(this.value);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("BuilderWithTolerate.BuilderWithTolerateBuilder(value=" + this.value) + ")");

File: test/transform/resource/after-ecj/JacksonJsonProperty.java
Patch:
@@ -14,7 +14,7 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") JacksonJsonProperty build() {
-      return new JacksonJsonProperty(kebabCaseProp);
+      return new JacksonJsonProperty(this.kebabCaseProp);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
       return (("JacksonJsonProperty.JacksonJsonPropertyBuilder(kebabCaseProp=" + this.kebabCaseProp) + ")");

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -530,7 +530,7 @@ public MethodDeclaration createStaticConstructor(AccessLevel level, String name,
 		
 		constructor.modifiers = toEclipseModifier(level) | ClassFileConstants.AccStatic;
 		TypeDeclaration typeDecl = (TypeDeclaration) type.get();
-		constructor.returnType = EclipseHandlerUtil.namePlusTypeParamsToTypeReference(typeDecl.name, typeDecl.typeParameters, p);
+		constructor.returnType = EclipseHandlerUtil.namePlusTypeParamsToTypeReference(type, typeDecl.typeParameters, p);
 		constructor.annotations = null;
 		constructor.selector = name.toCharArray();
 		constructor.thrownExceptions = null;

File: test/transform/resource/after-delombok/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -13,7 +13,7 @@ protected static class BuilderSimpleWithSetterPrefixBuilder<T> {
 		BuilderSimpleWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
+		public BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
 			this.unprefixed = unprefixed;
 			return this;
 		}
@@ -28,7 +28,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	protected static <T> BuilderSimpleWithSetterPrefixBuilder<T> builder() {
-		return new BuilderSimpleWithSetterPrefixBuilder<T>();
+	protected static <T> BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> builder() {
+		return new BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T>();
 	}
 }

File: test/transform/resource/after-delombok/BuilderTypeAnnos.java
Patch:
@@ -23,7 +23,7 @@ public static class BuilderTypeAnnosBuilder {
 		BuilderTypeAnnosBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderTypeAnnosBuilder foo(@TA final List<String> foo) {
+		public BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(@TA final List<String> foo) {
 			this.foo = foo;
 			return this;
 		}
@@ -38,8 +38,8 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static BuilderTypeAnnosBuilder builder() {
-		return new BuilderTypeAnnosBuilder();
+	public static BuilderTypeAnnos.BuilderTypeAnnosBuilder builder() {
+		return new BuilderTypeAnnos.BuilderTypeAnnosBuilder();
 	}
 }
 

File: test/transform/resource/after-delombok/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -23,7 +23,7 @@ public static class BuilderTypeAnnosWithSetterPrefixBuilder {
 		BuilderTypeAnnosWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderTypeAnnosWithSetterPrefixBuilder withFoo(@TA final List<String> foo) {
+		public BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder withFoo(@TA final List<String> foo) {
 			this.foo = foo;
 			return this;
 		}
@@ -38,8 +38,8 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static BuilderTypeAnnosWithSetterPrefixBuilder builder() {
-		return new BuilderTypeAnnosWithSetterPrefixBuilder();
+	public static BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder builder() {
+		return new BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder();
 	}
 }
 

File: test/transform/resource/after-delombok/BuilderWithNoBuilderMethod.java
Patch:
@@ -12,7 +12,7 @@ public static class BuilderWithNoBuilderMethodBuilder {
 		BuilderWithNoBuilderMethodBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderWithNoBuilderMethodBuilder a(final String a) {
+		public BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final String a) {
 			this.a = a;
 			return this;
 		}
@@ -27,7 +27,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public BuilderWithNoBuilderMethodBuilder toBuilder() {
-		return new BuilderWithNoBuilderMethodBuilder().a(this.a);
+	public BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder toBuilder() {
+		return new BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder().a(this.a);
 	}
 }

File: test/transform/resource/after-delombok/BuilderWithNonNull.java
Patch:
@@ -16,7 +16,7 @@ public static class BuilderWithNonNullBuilder {
 		BuilderWithNonNullBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderWithNonNullBuilder id(@lombok.NonNull final String id) {
+		public BuilderWithNonNull.BuilderWithNonNullBuilder id(@lombok.NonNull final String id) {
 			if (id == null) {
 				throw new java.lang.NullPointerException("id is marked non-null but is null");
 			}
@@ -34,7 +34,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static BuilderWithNonNullBuilder builder() {
-		return new BuilderWithNonNullBuilder();
+	public static BuilderWithNonNull.BuilderWithNonNullBuilder builder() {
+		return new BuilderWithNonNull.BuilderWithNonNullBuilder();
 	}
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -16,7 +16,7 @@ public static class BuilderWithNonNullWithSetterPrefixBuilder {
 		BuilderWithNonNullWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderWithNonNullWithSetterPrefixBuilder withId(@lombok.NonNull final String id) {
+		public BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder withId(@lombok.NonNull final String id) {
 			if (id == null) {
 				throw new java.lang.NullPointerException("id is marked non-null but is null");
 			}
@@ -34,7 +34,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static BuilderWithNonNullWithSetterPrefixBuilder builder() {
-		return new BuilderWithNonNullWithSetterPrefixBuilder();
+	public static BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder builder() {
+		return new BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder();
 	}
 }

File: test/transform/resource/after-delombok/BuilderWithTolerate.java
Patch:
@@ -15,7 +15,7 @@ public BuilderWithTolerateBuilder value(String s) {
 		BuilderWithTolerateBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderWithTolerateBuilder value(final int value) {
+		public BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
 			this.value = value;
 			return this;
 		}
@@ -34,7 +34,7 @@ public java.lang.String toString() {
 		this.value = value;
 	}
 	@java.lang.SuppressWarnings("all")
-	public static BuilderWithTolerateBuilder builder() {
-		return new BuilderWithTolerateBuilder();
+	public static BuilderWithTolerate.BuilderWithTolerateBuilder builder() {
+		return new BuilderWithTolerate.BuilderWithTolerateBuilder();
 	}
 }

File: test/transform/resource/after-delombok/JacksonJsonProperty.java
Patch:
@@ -19,7 +19,7 @@ public static class JacksonJsonPropertyBuilder {
 		@JsonProperty("kebab-case-prop")
 		@JsonSetter(nulls = Nulls.SKIP)
 		@java.lang.SuppressWarnings("all")
-		public JacksonJsonPropertyBuilder kebabCaseProp(final String kebabCaseProp) {
+		public JacksonJsonProperty.JacksonJsonPropertyBuilder kebabCaseProp(final String kebabCaseProp) {
 			this.kebabCaseProp = kebabCaseProp;
 			return this;
 		}
@@ -34,8 +34,8 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static JacksonJsonPropertyBuilder builder() {
-		return new JacksonJsonPropertyBuilder();
+	public static JacksonJsonProperty.JacksonJsonPropertyBuilder builder() {
+		return new JacksonJsonProperty.JacksonJsonPropertyBuilder();
 	}
 	@JsonProperty("kebab-case-prop")
 	@JsonSetter(nulls = Nulls.SKIP)

File: test/transform/resource/after-ecj/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -5,7 +5,7 @@
     @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefixBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
+    public @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {
       this.unprefixed = unprefixed;
       return this;
     }
@@ -21,7 +21,7 @@
     super();
     this.unprefixed = unprefixed;
   }
-  protected static @java.lang.SuppressWarnings("all") <T>BuilderSimpleWithSetterPrefixBuilder<T> builder() {
-    return new BuilderSimpleWithSetterPrefixBuilder<T>();
+  protected static @java.lang.SuppressWarnings("all") <T>BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T> builder() {
+    return new BuilderSimpleWithSetterPrefix.BuilderSimpleWithSetterPrefixBuilder<T>();
   }
 }

File: test/transform/resource/after-ecj/BuilderTypeAnnos.java
Patch:
@@ -11,7 +11,7 @@
     @java.lang.SuppressWarnings("all") BuilderTypeAnnosBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderTypeAnnosBuilder foo(final @TA List<String> foo) {
+    public @java.lang.SuppressWarnings("all") BuilderTypeAnnos.BuilderTypeAnnosBuilder foo(final @TA List<String> foo) {
       this.foo = foo;
       return this;
     }
@@ -27,7 +27,7 @@
     super();
     this.foo = foo;
   }
-  public static @java.lang.SuppressWarnings("all") BuilderTypeAnnosBuilder builder() {
-    return new BuilderTypeAnnosBuilder();
+  public static @java.lang.SuppressWarnings("all") BuilderTypeAnnos.BuilderTypeAnnosBuilder builder() {
+    return new BuilderTypeAnnos.BuilderTypeAnnosBuilder();
   }
 }

File: test/transform/resource/after-ecj/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -11,7 +11,7 @@
     @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefixBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefixBuilder withFoo(final @TA List<String> foo) {
+    public @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder withFoo(final @TA List<String> foo) {
       this.foo = foo;
       return this;
     }
@@ -27,7 +27,7 @@
     super();
     this.foo = foo;
   }
-  public static @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefixBuilder builder() {
-    return new BuilderTypeAnnosWithSetterPrefixBuilder();
+  public static @java.lang.SuppressWarnings("all") BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder builder() {
+    return new BuilderTypeAnnosWithSetterPrefix.BuilderTypeAnnosWithSetterPrefixBuilder();
   }
 }

File: test/transform/resource/after-ecj/BuilderWithNoBuilderMethod.java
Patch:
@@ -5,7 +5,7 @@
     @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethodBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethodBuilder a(final String a) {
+    public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder a(final String a) {
       this.a = a;
       return this;
     }
@@ -21,7 +21,7 @@
     super();
     this.a = a;
   }
-  public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethodBuilder toBuilder() {
-    return new BuilderWithNoBuilderMethodBuilder().a(this.a);
+  public @java.lang.SuppressWarnings("all") BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder toBuilder() {
+    return new BuilderWithNoBuilderMethod.BuilderWithNoBuilderMethodBuilder().a(this.a);
   }
 }

File: test/transform/resource/after-ecj/BuilderWithNonNull.java
Patch:
@@ -4,7 +4,7 @@
     @java.lang.SuppressWarnings("all") BuilderWithNonNullBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithNonNullBuilder id(final @lombok.NonNull String id) {
+    public @java.lang.SuppressWarnings("all") BuilderWithNonNull.BuilderWithNonNullBuilder id(final @lombok.NonNull String id) {
       if ((id == null))
           {
             throw new java.lang.NullPointerException("id is marked non-null but is null");
@@ -28,7 +28,7 @@
         }
     this.id = id;
   }
-  public static @java.lang.SuppressWarnings("all") BuilderWithNonNullBuilder builder() {
-    return new BuilderWithNonNullBuilder();
+  public static @java.lang.SuppressWarnings("all") BuilderWithNonNull.BuilderWithNonNullBuilder builder() {
+    return new BuilderWithNonNull.BuilderWithNonNullBuilder();
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
     @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefixBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefixBuilder withId(final @lombok.NonNull String id) {
+    public @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder withId(final @lombok.NonNull String id) {
       if ((id == null))
           {
             throw new java.lang.NullPointerException("id is marked non-null but is null");
@@ -28,7 +28,7 @@
         }
     this.id = id;
   }
-  public static @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefixBuilder builder() {
-    return new BuilderWithNonNullWithSetterPrefixBuilder();
+  public static @java.lang.SuppressWarnings("all") BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder builder() {
+    return new BuilderWithNonNullWithSetterPrefix.BuilderWithNonNullWithSetterPrefixBuilder();
   }
 }

File: test/transform/resource/after-ecj/BuilderWithTolerate.java
Patch:
@@ -9,7 +9,7 @@ public static class BuilderWithTolerateBuilder {
     @java.lang.SuppressWarnings("all") BuilderWithTolerateBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithTolerateBuilder value(final int value) {
+    public @java.lang.SuppressWarnings("all") BuilderWithTolerate.BuilderWithTolerateBuilder value(final int value) {
       this.value = value;
       return this;
     }
@@ -28,7 +28,7 @@ public static void main(String[] args) {
     super();
     this.value = value;
   }
-  public static @java.lang.SuppressWarnings("all") BuilderWithTolerateBuilder builder() {
-    return new BuilderWithTolerateBuilder();
+  public static @java.lang.SuppressWarnings("all") BuilderWithTolerate.BuilderWithTolerateBuilder builder() {
+    return new BuilderWithTolerate.BuilderWithTolerateBuilder();
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/JacksonJsonProperty.java
Patch:
@@ -9,7 +9,7 @@
     @java.lang.SuppressWarnings("all") JacksonJsonPropertyBuilder() {
       super();
     }
-    public @JsonProperty("kebab-case-prop") @JsonSetter(nulls = Nulls.SKIP) @java.lang.SuppressWarnings("all") JacksonJsonPropertyBuilder kebabCaseProp(final String kebabCaseProp) {
+    public @JsonProperty("kebab-case-prop") @JsonSetter(nulls = Nulls.SKIP) @java.lang.SuppressWarnings("all") JacksonJsonProperty.JacksonJsonPropertyBuilder kebabCaseProp(final String kebabCaseProp) {
       this.kebabCaseProp = kebabCaseProp;
       return this;
     }
@@ -25,8 +25,8 @@
     super();
     this.kebabCaseProp = kebabCaseProp;
   }
-  public static @java.lang.SuppressWarnings("all") JacksonJsonPropertyBuilder builder() {
-    return new JacksonJsonPropertyBuilder();
+  public static @java.lang.SuppressWarnings("all") JacksonJsonProperty.JacksonJsonPropertyBuilder builder() {
+    return new JacksonJsonProperty.JacksonJsonPropertyBuilder();
   }
   public @JsonProperty("kebab-case-prop") @JsonSetter(nulls = Nulls.SKIP) @java.lang.SuppressWarnings("all") void setKebabCaseProp(final String kebabCaseProp) {
     this.kebabCaseProp = kebabCaseProp;

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -568,7 +568,6 @@ private MethodDeclaration generateToBuilderMethod(CheckerFrameworkVersion cfv, S
 		List<Statement> statements = null;
 		for (BuilderFieldData bfd : builderFields) {
 			String setterPrefix = prefix.isEmpty() ? "set" : prefix;
-			//char[] setterName = fluent ? bfd.name : HandlerUtil.buildAccessorName("set", new String(bfd.name)).toCharArray();
 			String setterName;
 			if(fluent) {
 				setterName = prefix.isEmpty() ? new String(bfd.name) : HandlerUtil.buildAccessorName(setterPrefix, new String(bfd.name));

File: test/transform/resource/before/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -6,7 +6,7 @@ public static <Z extends Number> BuilderWithExistingBuilderClassWithSetterPrefix
 		return null;
 	}
 	
-	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder<Z extends Number> {
+	public static class BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z extends Number> {
 		private Z arg1;
 		
 		public void withArg2(boolean arg) {

File: test/transform/resource/after-delombok/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,6 +1,5 @@
 import java.util.List;
 import java.util.Collection;
-@Builder(toBuilder = true, setterPrefix = "with")
 class BuilderSingularWildcardListsWithToBuilderWithSetterPrefix {
 	private List<?> objects;
 	private Collection<? extends Number> numbers;

File: test/transform/resource/after-delombok/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -2,7 +2,7 @@ class BuilderWithExistingBuilderClassWithSetterPrefix<T, K extends Number> {
 	public static <Z extends Number> BuilderWithExistingBuilderClassWithSetterPrefix<String, Z> staticMethod(Z arg1, boolean arg2, String arg3) {
 		return null;
 	}
-	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder<Z extends Number> {
+	public static class BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z extends Number> {
 		@java.lang.SuppressWarnings("all")
 		private boolean arg2;
 		@java.lang.SuppressWarnings("all")
@@ -11,7 +11,7 @@ public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilde
 		public void withArg2(boolean arg) {
 		}
 		@java.lang.SuppressWarnings("all")
-		BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder() {
+		BuilderWithExistingBuilderClassWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z> withArg1(final Z arg1) {

File: test/transform/resource/after-delombok/BuilderWithNoBuilderMethodWithSetterPrefix.java
Patch:
@@ -1,4 +1,3 @@
-import lombok.Builder
 class BuilderWithNoBuilderMethodWithSetterPrefix {
 	private String a = "";
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,5 +1,4 @@
 import java.util.List;
-import lombok.Builder;
 class BuilderWithToBuilderWithSetterPrefix<T> {
 	private String mOne;
 	private String mTwo;

File: test/transform/resource/after-ecj/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -1,6 +1,6 @@
 import lombok.Builder;
 class BuilderWithExistingBuilderClassWithSetterPrefix<T, K extends Number> {
-  public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder<Z extends Number> {
+  public static class BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z extends Number> {
     private @java.lang.SuppressWarnings("all") boolean arg2;
     private @java.lang.SuppressWarnings("all") String arg3;
     private Z arg1;

File: test/transform/resource/after-ecj/BuilderWithRecursiveGenericsWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 public class BuilderWithRecursiveGenericsWithSetterPrefix {
   interface Inter<T, U extends Inter<T, U>> {
   }
-  public static final @Builder(setterPrefix = "with(setterPrefix = "with")") @Value class Test<Foo, Bar extends Set<Foo>, Quz extends Inter<Bar, Quz>> {
+  public static final @Builder(setterPrefix = "with") @Value class Test<Foo, Bar extends Set<Foo>, Quz extends Inter<Bar, Quz>> {
     public static @java.lang.SuppressWarnings("all") class TestBuilder<Foo, Bar extends Set<Foo>, Quz extends Inter<Bar, Quz>> {
       private @java.lang.SuppressWarnings("all") Foo foo;
       private @java.lang.SuppressWarnings("all") Bar bar;

File: test/transform/resource/before/BuilderWithNoBuilderMethodWithSetterPrefix.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Builder
+import lombok.Builder;
 @Builder(toBuilder = true, builderMethodName = "",setterPrefix = "with")
 class BuilderWithNoBuilderMethodWithSetterPrefix {
 	private String a = "";

File: test/transform/resource/before/BuilderWithToBuilderWithSetterPrefix.java
Patch:
@@ -5,7 +5,7 @@ class BuilderWithToBuilderWithSetterPrefix<T> {
 	private String mOne, mTwo;
 	@Builder.ObtainVia(method = "rrr", isStatic = true) private T foo;
 	@lombok.Singular private List<T> bars;
-	public static <K> K rrr(BuilderWithToBuilder<K> x) {
+	public static <K> K rrr(BuilderWithToBuilderWithSetterPrefix<K> x) {
 		return x.foo;
 	}
 }
@@ -15,6 +15,6 @@ class ConstructorWithToBuilderWithSetterPrefix<T> {
 	private T foo;
 	@lombok.Singular private com.google.common.collect.ImmutableList<T> bars;
 	@Builder(toBuilder = true, setterPrefix = "with")
-	public ConstructorWithToBuilder(String mOne, @Builder.ObtainVia(field = "foo") T baz, com.google.common.collect.ImmutableList<T> bars) {
+	public ConstructorWithToBuilderWithSetterPrefix(String mOne, @Builder.ObtainVia(field = "foo") T baz, com.google.common.collect.ImmutableList<T> bars) {
 	}
 }

File: test/transform/resource/before/BuilderWithTolerateWithSetterPrefix.java
Patch:
@@ -12,7 +12,7 @@ public static void main(String[] args) {
 	public static class BuilderWithTolerateWithSetterPrefixBuilder {
 		@Tolerate
 		public BuilderWithTolerateWithSetterPrefixBuilder withValue(String s) {
-			return this.value(Integer.parseInt(s));
+			return this.withValue(Integer.parseInt(s));
 		}
 	}
 }

File: src/core/lombok/core/TypeResolver.java
Patch:
@@ -48,7 +48,7 @@ public boolean typeMatches(LombokNode<?, ?, ?> context, String fqn, String typeR
 	public String typeRefToFullyQualifiedName(LombokNode<?, ?, ?> context, TypeLibrary library, String typeRef) {
 		// When asking if 'Foo' could possibly be referring to 'bar.Baz', the answer is obviously no.
 		List<String> qualifieds = library.toQualifieds(typeRef);
-		if (qualifieds.isEmpty()) return null;
+		if (qualifieds == null || qualifieds.isEmpty()) return null;
 		
 		// When asking if 'lombok.Getter' could possibly be referring to 'lombok.Getter', the answer is obviously yes.
 		if (qualifieds.contains(typeRef)) return LombokInternalAliasing.processAliases(typeRef);

File: test/transform/resource/after-delombok/BuilderSingularMapsWithSetterPrefix.java
Patch:
@@ -95,7 +95,7 @@ public BuilderSingularMapsWithSetterPrefixBuilder<K, V> clearMen() {
 			return this;
 		}
 		@SuppressWarnings("all")
-		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> withRawMan(Object rawMapKey, Object rawMapValue) {
+		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> withRawMap(Object rawMapKey, Object rawMapValue) {
 			if (this.rawMap$key == null) {
 				this.rawMap$key = new java.util.ArrayList<Object>();
 				this.rawMap$value = new java.util.ArrayList<Object>();
@@ -125,7 +125,7 @@ public BuilderSingularMapsWithSetterPrefixBuilder<K, V> clearRawMap() {
 			return this;
 		}
 		@SuppressWarnings("all")
-		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> stringMap(String stringMapKey, V stringMapValue) {
+		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> withStringMap(String stringMapKey, V stringMapValue) {
 			if (this.stringMap$key == null) {
 				this.stringMap$key = new java.util.ArrayList<String>();
 				this.stringMap$value = new java.util.ArrayList<V>();
@@ -135,7 +135,7 @@ public BuilderSingularMapsWithSetterPrefixBuilder<K, V> stringMap(String stringM
 			return this;
 		}
 		@SuppressWarnings("all")
-		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> stringMap(java.util.Map<? extends String, ? extends V> stringMap) {
+		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> withStringMap(java.util.Map<? extends String, ? extends V> stringMap) {
 			if (this.stringMap$key == null) {
 				this.stringMap$key = new java.util.ArrayList<String>();
 				this.stringMap$value = new java.util.ArrayList<V>();

File: test/transform/resource/after-delombok/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,5 +1,6 @@
 import java.util.List;
 import java.util.Collection;
+@Builder(toBuilder = true, setterPrefix = "with")
 class BuilderSingularWildcardListsWithToBuilderWithSetterPrefix {
 	private List<?> objects;
 	private Collection<? extends Number> numbers;

File: test/transform/resource/after-delombok/BuilderWithAccessorsWithSetterPrefix.java
Patch:
@@ -39,7 +39,7 @@ public BuilderWithAccessorsWithSetterPrefixBuilder withFoo(final int foo) {
 			return this;
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderWithAccessorsWithSetterPrefixBuilder with_Bar(final int _bar) {
+		public BuilderWithAccessorsWithSetterPrefixBuilder with_bar(final int _bar) {
 			this._bar = _bar;
 			return this;
 		}

File: test/transform/resource/after-delombok/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -2,7 +2,7 @@ class BuilderWithExistingBuilderClassWithSetterPrefix<T, K extends Number> {
 	public static <Z extends Number> BuilderWithExistingBuilderClassWithSetterPrefix<String, Z> staticMethod(Z arg1, boolean arg2, String arg3) {
 		return null;
 	}
-	public static class BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z extends Number> {
+	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder<Z extends Number> {
 		@java.lang.SuppressWarnings("all")
 		private boolean arg2;
 		@java.lang.SuppressWarnings("all")
@@ -11,7 +11,7 @@ public static class BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z ext
 		public void withArg2(boolean arg) {
 		}
 		@java.lang.SuppressWarnings("all")
-		BuilderWithExistingBuilderClassWithSetterPrefixBuilder() {
+		BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z> withArg1(final Z arg1) {

File: test/transform/resource/after-delombok/BuilderWithNoBuilderMethodWithSetterPrefix.java
Patch:
@@ -1,3 +1,4 @@
+import lombok.Builder
 class BuilderWithNoBuilderMethodWithSetterPrefix {
 	private String a = "";
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/BuilderWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,4 +1,5 @@
 import java.util.List;
+import lombok.Builder;
 class BuilderWithToBuilderWithSetterPrefix<T> {
 	private String mOne;
 	private String mTwo;

File: test/transform/resource/after-ecj/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -1,8 +1,8 @@
 import java.util.List;
 @lombok.Builder(access = lombok.AccessLevel.PROTECTED,setterPrefix = "with") class BuilderSimpleWithSetterPrefix<T> {
-  protected static @java.lang.SuppressWarnings("all") class BuilderSimpleWithSetterPrefix<T> {
+  protected static @java.lang.SuppressWarnings("all") class BuilderSimpleWithSetterPrefixBuilder<T> {
     private @java.lang.SuppressWarnings("all") int unprefixed;
-    @java.lang.SuppressWarnings("all") BuilderWithPrefixBuilder() {
+    @java.lang.SuppressWarnings("all") BuilderSimpleWithSetterPrefixBuilder() {
       super();
     }
     public @java.lang.SuppressWarnings("all") BuilderWithPrefixBuilder<T> withUnprefixed(final int unprefixed) {

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 import lombok.Singular;
-@lombok.Builder(toBuilder = true, setterPrefix = "with") class BuilderSingularToBuilderWithNullWithSetterPrefix {
+@lombok.Builder(toBuilder = true,setterPrefix = "with") class BuilderSingularToBuilderWithNullWithSetterPrefix {
   public static @java.lang.SuppressWarnings("all") class BuilderSingularToBuilderWithNullWithSetterPrefixBuilder {
     private @java.lang.SuppressWarnings("all") java.util.ArrayList<String> elems;
     @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullWithSetterPrefixBuilder() {

File: test/transform/resource/after-ecj/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,7 +1,7 @@
 import java.util.List;
 import java.util.Collection;
 import lombok.Singular;
-@lombok.Builder(toBuilder = true, setterPrefix = "with") class BuilderSingularWildcardListsWithToBuilderWithSetterPrefix {
+@lombok.Builder(toBuilder = true,setterPrefix = "with") class BuilderSingularWildcardListsWithToBuilderWithSetterPrefix {
   public static @java.lang.SuppressWarnings("all") class BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder {
     private @java.lang.SuppressWarnings("all") java.util.ArrayList<java.lang.Object> objects;
     private @java.lang.SuppressWarnings("all") java.util.ArrayList<Number> numbers;

File: test/transform/resource/after-ecj/BuilderValueDataWithSetterPrefix.java
Patch:
@@ -41,7 +41,7 @@
     return (("BuilderAndValueWithSetterPrefix(zero=" + this.getZero()) + ")");
   }
 }
-@lombok.Builder @lombok.Data class BuilderAndDataWithSetterPrefix {
+@lombok.Builder(setterPrefix = "with") @lombok.Data class BuilderAndDataWithSetterPrefix {
   public static @java.lang.SuppressWarnings("all") class BuilderAndDataWithSetterPrefixBuilder {
     @java.lang.SuppressWarnings("all") BuilderAndDataWithSetterPrefixBuilder() {
       super();

File: test/transform/resource/after-ecj/BuilderWithAccessorsWithSetterPrefix.java
Patch:
@@ -19,7 +19,7 @@
       this.foo = foo;
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithAccessorsWithSetterPrefixBuilder with_Bar(final int _bar) {
+    public @java.lang.SuppressWarnings("all") BuilderWithAccessorsWithSetterPrefixBuilder with_bar(final int _bar) {
       this._bar = _bar;
       return this;
     }

File: test/transform/resource/after-ecj/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -1,6 +1,6 @@
 import lombok.Builder;
 class BuilderWithExistingBuilderClassWithSetterPrefix<T, K extends Number> {
-  public static class BuilderWithExistingBuilderClassWithSetterPrefixBuilder<Z extends Number> {
+  public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder<Z extends Number> {
     private @java.lang.SuppressWarnings("all") boolean arg2;
     private @java.lang.SuppressWarnings("all") String arg3;
     private Z arg1;

File: test/transform/resource/before/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -6,7 +6,7 @@ public static <Z extends Number> BuilderWithExistingBuilderClassWithSetterPrefix
 		return null;
 	}
 	
-	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefix<Z extends Number> {
+	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefixBuilder<Z extends Number> {
 		private Z arg1;
 		
 		public void withArg2(boolean arg) {

File: test/transform/resource/before/BuilderWithNoBuilderMethodWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
-import lombok.Builder(setterPrefix = "with");
-@Builder(toBuilder = true, builderMethodName = "", setterPrefix = "with")
+import lombok.Builder
+@Builder(toBuilder = true, builderMethodName = "",setterPrefix = "with")
 class BuilderWithNoBuilderMethodWithSetterPrefix {
 	private String a = "";
 }

File: test/transform/resource/after-ecj/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 import java.util.List;
-@lombok.Builder(access = lombok.AccessLevel.PROTECTED,setterPrefix = "with") class BulderSimpleWithSetterPrefix<T> {
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED,setterPrefix = "with") class BuilderSimpleWithSetterPrefix<T> {
   protected static @java.lang.SuppressWarnings("all") class BuilderSimpleWithSetterPrefix<T> {
     private @java.lang.SuppressWarnings("all") int unprefixed;
     @java.lang.SuppressWarnings("all") BuilderWithPrefixBuilder() {

File: test/transform/resource/before/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -5,6 +5,6 @@ class BuilderSingularToBuilderWithNullWithSetterPrefix {
 	@Singular private java.util.List<String> elems;
 	
 	public static void test() {
-		new BuilderSingularToBuilderWithNull(null).toBuilder();
+		new BuilderSingularToBuilderWithNullWithSetterPrefix(null).toBuilder();
 	}
 }

File: test/transform/resource/after-delombok/BuilderSingularAnnotatedTypesWithSetterPrefix.java
Patch:
@@ -119,6 +119,6 @@ public java.lang.String toString() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public static BuilderSingularAnnotatedTypesWithSetterPrefixBuilder builder() {
-		return new BuilderSingularAnnotatedTypesBuilder();
+		return new BuilderSingularAnnotatedTypesWithSetterPrefixBuilder();
 	}
 }

File: test/transform/resource/after-delombok/BuilderSingularGuavaListsSetsWithSetterPrefix.java
Patch:
@@ -31,7 +31,7 @@ public static class BuilderSingularGuavaListsSetsWithSetterPrefixBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		private com.google.common.collect.ImmutableTable.Builder<Number, Number, String> users;
 		@java.lang.SuppressWarnings("all")
-		BuilderSingularGuavaListsSetsBuilder() {
+		BuilderSingularGuavaListsSetsWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularGuavaListsSetsWithSetterPrefixBuilder<T> withCard(final T card) {

File: test/transform/resource/after-delombok/BuilderSingularListsWithSetterPrefix.java
Patch:
@@ -20,7 +20,7 @@ public static class BuilderSingularListsWithSetterPrefixBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		private java.util.ArrayList<java.lang.Object> rawList;
 		@java.lang.SuppressWarnings("all")
-		BuilderSingularListsBuilder() {
+		BuilderSingularListsWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularListsWithSetterPrefixBuilder<T> withChild(final T child) {

File: test/transform/resource/after-delombok/BuilderSingularMapsWithSetterPrefix.java
Patch:
@@ -7,7 +7,7 @@ class BuilderSingularMapsWithSetterPrefix<K, V> {
 	private Map rawMap;
 	private Map<String, V> stringMap;
 	@SuppressWarnings("all")
-	BuilderSingularMaps(Map<K, V> women, SortedMap<K, ? extends Number> men, Map rawMap, Map<String, V> stringMap) {
+	BuilderSingularMapsWithSetterPrefix(Map<K, V> women, SortedMap<K, ? extends Number> men, Map rawMap, Map<String, V> stringMap) {
 		this.women = women;
 		this.men = men;
 		this.rawMap = rawMap;
@@ -32,7 +32,7 @@ public static class BuilderSingularMapsWithSetterPrefixBuilder<K, V> {
 		@SuppressWarnings("all")
 		private java.util.ArrayList<V> stringMap$value;
 		@SuppressWarnings("all")
-		BuilderSingularMapsBuilder() {
+		BuilderSingularMapsWithSetterPrefixBuilder() {
 		}
 		@SuppressWarnings("all")
 		public BuilderSingularMapsWithSetterPrefixBuilder<K, V> withWoman(K womanKey, V womanValue) {

File: test/transform/resource/after-delombok/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -18,7 +18,7 @@ public static class BuilderSingularNoAutoWithSetterPrefixBuilder {
 		@java.lang.SuppressWarnings("all")
 		private java.util.ArrayList<String> items;
 		@java.lang.SuppressWarnings("all")
-		BuilderSingularNoAutoBuilder() {
+		BuilderSingularNoAutoWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularNoAutoWithSetterPrefixBuilder withThings(final String things) {

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -59,7 +59,7 @@ public static BuilderSingularToBuilderWithNullWithSetterPrefixBuilder builder()
 	@java.lang.SuppressWarnings("all")
 	public BuilderSingularToBuilderWithNullWithSetterPrefixBuilder toBuilder() {
 		final BuilderSingularToBuilderWithNullWithSetterPrefixBuilder builder = new BuilderSingularToBuilderWithNullWithSetterPrefixBuilder();
-		if (this.elems != null) builder.elems(this.elems);
+		if (this.elems != null) builder.withElems(this.elems);
 		return builder;
 	}
 }

File: test/transform/resource/after-delombok/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -90,8 +90,8 @@ public static BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder b
 	@java.lang.SuppressWarnings("all")
 	public BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder toBuilder() {
 		final BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder builder = new BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder();
-		if (this.objects != null) builder.objects(this.objects);
-		if (this.numbers != null) builder.numbers(this.numbers);
+		if (this.objects != null) builder.withObjects(this.objects);
+		if (this.numbers != null) builder.withNumbers(this.numbers);
 		return builder;
 	}
 }

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -54,7 +54,7 @@ public static void test() {
   public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullWithSetterPrefixBuilder toBuilder() {
     final BuilderSingularToBuilderWithNullWithSetterPrefixBuilder builder = new BuilderSingularToBuilderWithNullWithSetterPrefixBuilder();
     if ((this.elems != null))
-        builder.elems(this.elems);
+        builder.withElems(this.elems);
     return builder;
   }
 }

File: test/transform/resource/after-ecj/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -84,9 +84,9 @@
   public @java.lang.SuppressWarnings("all") BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder toBuilder() {
     final BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder builder = new BuilderSingularWildcardListsWithToBuilderWithSetterPrefixBuilder();
     if ((this.objects != null))
-        builder.objects(this.objects);
+        builder.withObjects(this.objects);
     if ((this.numbers != null))
-        builder.numbers(this.numbers);
+        builder.withNumbers(this.numbers);
     return builder;
   }
 }

File: test/transform/resource/after-delombok/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -10,7 +10,7 @@ protected static class BuilderSimpleWithSetterPrefixBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		private int unprefixed;
 		@java.lang.SuppressWarnings("all")
-		BuilderSimpelWithSetterPrefixBuilder() {
+		BuilderSimpleWithSetterPrefixBuilder() {
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSimpleWithSetterPrefixBuilder<T> withUnprefixed(final int unprefixed) {

File: src/core/lombok/eclipse/handlers/EclipseSingularsRecipes.java
Patch:
@@ -109,7 +109,9 @@ public static EclipseSingularsRecipes get() {
 	}
 	
 	public String toQualified(String typeReference) {
-		return singularizableTypes.toQualified(typeReference);
+		List<String> q = singularizableTypes.toQualifieds(typeReference);
+		if (q.isEmpty()) return null;
+		return q.get(0);
 	}
 	
 	public EclipseSingularizer getSingularizer(String fqn) {

File: src/core/lombok/javac/handlers/JavacSingularsRecipes.java
Patch:
@@ -101,7 +101,9 @@ public static JavacSingularsRecipes get() {
 	}
 	
 	public String toQualified(String typeReference) {
-		return singularizableTypes.toQualified(typeReference);
+		java.util.List<String> q = singularizableTypes.toQualifieds(typeReference);
+		if (q.isEmpty()) return null;
+		return q.get(0);
 	}
 	
 	public JavacSingularizer getSingularizer(String fqn, JavacNode node) {

File: test/transform/resource/before/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
 
 @lombok.Builder(access = lombok.AccessLevel.PROTECTED, setterPrefix = "with")
-class BuilderWithPrefix<T> {
+class BuilderSimpleWithSetterPrefix<T> {
 	private int unprefixed;
 }

File: test/transform/resource/before/BuilderSingularAnnotatedTypesWithSetterPrefix.java
Patch:
@@ -8,7 +8,7 @@
 @Target(ElementType.TYPE_USE)
 @interface MyAnnotation {}
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularAnnotatedTypes {
+class BuilderSingularAnnotatedTypesWithSetterPrefix {
 	@Singular private Set<@MyAnnotation @NonNull String> foos;
 	@Singular private Map<@MyAnnotation @NonNull String, @MyAnnotation @NonNull Integer> bars;
 }

File: test/transform/resource/before/BuilderSingularGuavaListsSetsWithSetterPrefix.java
Patch:
@@ -7,7 +7,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularGuavaListsSets<T> {
+class BuilderSingularGuavaListsSetsWithSetterPrefix<T> {
 	@Singular private ImmutableList<T> cards;
 	@Singular private ImmutableCollection<? extends Number> frogs;
 	@SuppressWarnings("all") @Singular("rawSet") private ImmutableSet rawSet;

File: test/transform/resource/before/BuilderSingularGuavaMapsWithPrefix.java
Patch:
@@ -5,7 +5,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularGuavaMaps<K, V> {
+class BuilderSingularGuavaMapsWithSetterPrefix<K, V> {
 	@Singular private ImmutableMap<K, V> battleaxes;
 	@Singular private ImmutableSortedMap<Integer, ? extends V> vertices;
 	@SuppressWarnings("all") @Singular("rawMap") private ImmutableBiMap rawMap;

File: test/transform/resource/before/BuilderSingularListsWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularLists<T> {
+class BuilderSingularListsWithSetterPrefix<T> {
 	@Singular private List<T> children;
 	@Singular private Collection<? extends Number> scarves;
 	@SuppressWarnings("all") @Singular("rawList") private List rawList;

File: test/transform/resource/before/BuilderSingularMapsWithSetterPrefix.java
Patch:
@@ -7,7 +7,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularMaps<K, V> {
+class BuilderSingularMapsWithSetterPrefix<K, V> {
 	@Singular private Map<K, V> women;
 	@Singular private SortedMap<K, ? extends Number> men;
 	@SuppressWarnings("all") @Singular("rawMap") private Map rawMap;

File: test/transform/resource/before/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularNoAuto {
+class BuilderSingularNoAutoWithSetterPrefix {
 	@Singular private List<String> things;
 	@Singular("widget") private List<String> widgets;
 	@Singular private List<String> items;

File: test/transform/resource/before/BuilderSingularRedirectToGuavaWithSetterPrefix.java
Patch:
@@ -6,7 +6,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularRedirectToGuava {
+class BuilderSingularRedirectToGuavaWithSetterPrefix {
 	@Singular private Set<String> dangerMice;
 	@Singular private NavigableMap<Integer, Number> things;
 	@Singular private Collection<Class<?>> doohickeys;

File: test/transform/resource/before/BuilderSingularSetsWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularSets<T> {
+class BuilderSingularSetsWithSetterPrefix<T> {
 	@Singular private Set<T> dangerMice;
 	@Singular private SortedSet<? extends Number> octopodes;
 	@SuppressWarnings("all") @Singular("rawSet") private Set rawSet;

File: test/transform/resource/before/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -1,7 +1,7 @@
 import lombok.Singular;
 
 @lombok.Builder(toBuilder = true, setterPrefix = "with")
-class BuilderSingularToBuilderWithNull {
+class BuilderSingularToBuilderWithNullWithSetterPrefix {
 	@Singular private java.util.List<String> elems;
 	
 	public static void test() {

File: test/transform/resource/before/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(toBuilder = true, setterPrefix = "with")
-class BuilderSingularWildcardListsWithToBuilder {
+class BuilderSingularWildcardListsWithToBuilderWithSetterPrefix {
 	@Singular private List<?> objects;
 	@Singular private Collection<? extends Number> numbers;
 }

File: test/transform/resource/before/BuilderSingularWithPrefixesWithSetterPrefix.java
Patch:
@@ -2,6 +2,6 @@
 
 @lombok.Builder(setterPrefix = "with")
 @lombok.experimental.Accessors(prefix = "_")
-class BuilderSingularWithPrefixes {
+class BuilderSingularWithPrefixesWithSetterPrefix {
 	@Singular private java.util.List<String> _elems;
 }

File: test/transform/resource/before/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -9,6 +9,6 @@
 @interface TB {
 }
 @lombok.Builder(setterPrefix = "with")
-class BuilderTypeAnnos {
+class BuilderTypeAnnosWithSetterPrefix {
 	private @TA @TB List<String> foo;
 }

File: test/transform/resource/before/BuilderValueDataWithSetterPrefix.java
Patch:
@@ -1,11 +1,11 @@
 import java.util.List;
 
-@lombok.Builder @lombok.Value
-class BuilderAndValue {
+@lombok.Builder(setterPrefix = "with") @lombok.Value
+class BuilderAndValueWithSetterPrefix {
 	private final int zero = 0;
 }
 
 @lombok.Builder(setterPrefix = "with") @lombok.Data
-class BuilderAndData {
+class BuilderAndDataWithSetterPrefix {
 	private final int zero = 0;
 }

File: test/transform/resource/before/BuilderWithAccessorsWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 @lombok.Builder(setterPrefix = "with") @lombok.experimental.Accessors(prefix={"p", "_"})
-class BuilderWithAccessors {
+class BuilderWithAccessorsWithSetterPrefix {
 	private final int plower;
 	private final int pUpper;
 	private int _foo;

File: test/transform/resource/before/BuilderWithBadNamesWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 @lombok.Builder(setterPrefix = "with")
-public class BuilderWithBadNames {
+public class BuilderWithBadNamesWithSetterPrefix {
 	String build;
 	String toString;
 }

File: test/transform/resource/before/BuilderWithDeprecatedWithSetterPrefix.java
Patch:
@@ -3,7 +3,7 @@
 import lombok.Singular;
 
 @Builder(setterPrefix = "with")
-public class BuilderWithDeprecated {
+public class BuilderWithDeprecatedWithSetterPrefix {
 	/** @deprecated since always */ String dep1;
 	@Deprecated int dep2;
 	@Singular @Deprecated java.util.List<String> strings;

File: test/transform/resource/before/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -1,12 +1,12 @@
 import lombok.Builder;
 
-class BuilderWithExistingBuilderClass<T, K extends Number> {
+class BuilderWithExistingBuilderClassWithSetterPrefix<T, K extends Number> {
 	@Builder(setterPrefix = "with")
-	public static <Z extends Number> BuilderWithExistingBuilderClass<String, Z> staticMethod(Z arg1, boolean arg2, String arg3) {
+	public static <Z extends Number> BuilderWithExistingBuilderClassWithSetterPrefix<String, Z> staticMethod(Z arg1, boolean arg2, String arg3) {
 		return null;
 	}
 	
-	public static class BuilderWithExistingBuilderClassBuilder<Z extends Number> {
+	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefix<Z extends Number> {
 		private Z arg1;
 		
 		public void withArg2(boolean arg) {

File: test/transform/resource/before/BuilderWithNoBuilderMethodWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 import lombok.Builder(setterPrefix = "with");
 @Builder(toBuilder = true, builderMethodName = "", setterPrefix = "with")
-class BuilderWithNoBuilderMethod {
+class BuilderWithNoBuilderMethodWithSetterPrefix {
 	private String a = "";
 }

File: test/transform/resource/before/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 @lombok.Builder(setterPrefix = "with")
-class BuilderWithNonNull {
+class BuilderWithNonNullWithSetterPrefix {
 	@lombok.NonNull
 	private final String id;
 }

File: test/transform/resource/before/BuilderWithRecursiveGenericsWithSetterPrefix.java
Patch:
@@ -3,7 +3,7 @@
 import lombok.Builder;
 import lombok.Value;
 
-public class BuilderWithRecursiveGenerics {
+public class BuilderWithRecursiveGenericsWithSetterPrefix {
 	interface Inter<T, U extends Inter<T, U>> {}
 	
 	@Builder(setterPrefix = "with") @Value public static class Test<Foo, Bar extends Set<Foo>, Quz extends Inter<Bar, Quz>> {

File: test/transform/resource/before/BuilderWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,7 +1,7 @@
 import java.util.List;
 import lombok.Builder;
 @Builder(toBuilder = true, setterPrefix = "with") @lombok.experimental.Accessors(prefix = "m")
-class BuilderWithToBuilder<T> {
+class BuilderWithToBuilderWithSetterPrefix<T> {
 	private String mOne, mTwo;
 	@Builder.ObtainVia(method = "rrr", isStatic = true) private T foo;
 	@lombok.Singular private List<T> bars;
@@ -10,11 +10,11 @@ public static <K> K rrr(BuilderWithToBuilder<K> x) {
 	}
 }
 @lombok.experimental.Accessors(prefix = "m")
-class ConstructorWithToBuilder<T> {
+class ConstructorWithToBuilderWithSetterPrefix<T> {
 	private String mOne, mTwo;
 	private T foo;
 	@lombok.Singular private com.google.common.collect.ImmutableList<T> bars;
-	@Builder(toBuilder = true)
+	@Builder(toBuilder = true, setterPrefix = "with")
 	public ConstructorWithToBuilder(String mOne, @Builder.ObtainVia(field = "foo") T baz, com.google.common.collect.ImmutableList<T> bars) {
 	}
 }

File: test/transform/resource/before/BuilderSingularAnnotatedTypesWithSetterPrefix.java
Patch:
@@ -8,7 +8,7 @@
 @Target(ElementType.TYPE_USE)
 @interface MyAnnotation {}
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularAnnotatedTypes {
+class BuilderSingularAnnotatedTypesWithSetterPrefix {
 	@Singular private Set<@MyAnnotation @NonNull String> foos;
 	@Singular private Map<@MyAnnotation @NonNull String, @MyAnnotation @NonNull Integer> bars;
 }

File: test/transform/resource/before/BuilderSingularGuavaListsSetsWithSetterPrefix.java
Patch:
@@ -7,7 +7,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularGuavaListsSets<T> {
+class BuilderSingularGuavaListsSetsWithSetterPrefix<T> {
 	@Singular private ImmutableList<T> cards;
 	@Singular private ImmutableCollection<? extends Number> frogs;
 	@SuppressWarnings("all") @Singular("rawSet") private ImmutableSet rawSet;

File: test/transform/resource/before/BuilderSingularGuavaMapsWithPrefix.java
Patch:
@@ -5,7 +5,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularGuavaMaps<K, V> {
+class BuilderSingularGuavaMapsWithSetterPrefix<K, V> {
 	@Singular private ImmutableMap<K, V> battleaxes;
 	@Singular private ImmutableSortedMap<Integer, ? extends V> vertices;
 	@SuppressWarnings("all") @Singular("rawMap") private ImmutableBiMap rawMap;

File: test/transform/resource/before/BuilderSingularListsWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularLists<T> {
+class BuilderSingularListsWithSetterPrefix<T> {
 	@Singular private List<T> children;
 	@Singular private Collection<? extends Number> scarves;
 	@SuppressWarnings("all") @Singular("rawList") private List rawList;

File: test/transform/resource/before/BuilderSingularMapsWithSetterPrefix.java
Patch:
@@ -7,7 +7,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularMaps<K, V> {
+class BuilderSingularMapsWithSetterPrefix<K, V> {
 	@Singular private Map<K, V> women;
 	@Singular private SortedMap<K, ? extends Number> men;
 	@SuppressWarnings("all") @Singular("rawMap") private Map rawMap;

File: test/transform/resource/before/BuilderSingularNoAutoWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularNoAuto {
+class BuilderSingularNoAutoWithSetterPrefix {
 	@Singular private List<String> things;
 	@Singular("widget") private List<String> widgets;
 	@Singular private List<String> items;

File: test/transform/resource/before/BuilderSingularRedirectToGuavaWithSetterPrefix.java
Patch:
@@ -6,7 +6,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularRedirectToGuava {
+class BuilderSingularRedirectToGuavaWithSetterPrefix {
 	@Singular private Set<String> dangerMice;
 	@Singular private NavigableMap<Integer, Number> things;
 	@Singular private Collection<Class<?>> doohickeys;

File: test/transform/resource/before/BuilderSingularSetsWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(setterPrefix = "with")
-class BuilderSingularSets<T> {
+class BuilderSingularSetsWithSetterPrefix<T> {
 	@Singular private Set<T> dangerMice;
 	@Singular private SortedSet<? extends Number> octopodes;
 	@SuppressWarnings("all") @Singular("rawSet") private Set rawSet;

File: test/transform/resource/before/BuilderSingularToBuilderWithNullWithSetterPrefix.java
Patch:
@@ -1,7 +1,7 @@
 import lombok.Singular;
 
 @lombok.Builder(toBuilder = true, setterPrefix = "with")
-class BuilderSingularToBuilderWithNull {
+class BuilderSingularToBuilderWithNullWithSetterPrefix {
 	@Singular private java.util.List<String> elems;
 	
 	public static void test() {

File: test/transform/resource/before/BuilderSingularWildcardListsWithToBuilderWithSetterPrefix.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder(toBuilder = true, setterPrefix = "with")
-class BuilderSingularWildcardListsWithToBuilder {
+class BuilderSingularWildcardListsWithToBuilderWithSetterPrefix {
 	@Singular private List<?> objects;
 	@Singular private Collection<? extends Number> numbers;
 }

File: test/transform/resource/before/BuilderSingularWithPrefixesWithSetterPrefix.java
Patch:
@@ -2,6 +2,6 @@
 
 @lombok.Builder(setterPrefix = "with")
 @lombok.experimental.Accessors(prefix = "_")
-class BuilderSingularWithPrefixes {
+class BuilderSingularWithPrefixesWithSetterPrefix {
 	@Singular private java.util.List<String> _elems;
 }

File: test/transform/resource/before/BuilderTypeAnnosWithSetterPrefix.java
Patch:
@@ -9,6 +9,6 @@
 @interface TB {
 }
 @lombok.Builder(setterPrefix = "with")
-class BuilderTypeAnnos {
+class BuilderTypeAnnosWithSetterPrefix {
 	private @TA @TB List<String> foo;
 }

File: test/transform/resource/before/BuilderValueDataWithSetterPrefix.java
Patch:
@@ -1,11 +1,11 @@
 import java.util.List;
 
-@lombok.Builder @lombok.Value
-class BuilderAndValue {
+@lombok.Builder(setterPrefix = "with") @lombok.Value
+class BuilderAndValueWithSetterPrefix {
 	private final int zero = 0;
 }
 
 @lombok.Builder(setterPrefix = "with") @lombok.Data
-class BuilderAndData {
+class BuilderAndDataWithSetterPrefix {
 	private final int zero = 0;
 }

File: test/transform/resource/before/BuilderWithAccessorsWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 @lombok.Builder(setterPrefix = "with") @lombok.experimental.Accessors(prefix={"p", "_"})
-class BuilderWithAccessors {
+class BuilderWithAccessorsWithSetterPrefix {
 	private final int plower;
 	private final int pUpper;
 	private int _foo;

File: test/transform/resource/before/BuilderWithBadNamesWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 @lombok.Builder(setterPrefix = "with")
-public class BuilderWithBadNames {
+public class BuilderWithBadNamesWithSetterPrefix {
 	String build;
 	String toString;
 }

File: test/transform/resource/before/BuilderWithDeprecatedWithSetterPrefix.java
Patch:
@@ -3,7 +3,7 @@
 import lombok.Singular;
 
 @Builder(setterPrefix = "with")
-public class BuilderWithDeprecated {
+public class BuilderWithDeprecatedWithSetterPrefix {
 	/** @deprecated since always */ String dep1;
 	@Deprecated int dep2;
 	@Singular @Deprecated java.util.List<String> strings;

File: test/transform/resource/before/BuilderWithExistingBuilderClassWithSetterPrefix.java
Patch:
@@ -1,12 +1,12 @@
 import lombok.Builder;
 
-class BuilderWithExistingBuilderClass<T, K extends Number> {
+class BuilderWithExistingBuilderClassWithSetterPrefix<T, K extends Number> {
 	@Builder(setterPrefix = "with")
-	public static <Z extends Number> BuilderWithExistingBuilderClass<String, Z> staticMethod(Z arg1, boolean arg2, String arg3) {
+	public static <Z extends Number> BuilderWithExistingBuilderClassWithSetterPrefix<String, Z> staticMethod(Z arg1, boolean arg2, String arg3) {
 		return null;
 	}
 	
-	public static class BuilderWithExistingBuilderClassBuilder<Z extends Number> {
+	public static class BuilderWithExistingBuilderClassBuilderWithSetterPrefix<Z extends Number> {
 		private Z arg1;
 		
 		public void withArg2(boolean arg) {

File: test/transform/resource/before/BuilderWithNoBuilderMethodWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 import lombok.Builder(setterPrefix = "with");
 @Builder(toBuilder = true, builderMethodName = "", setterPrefix = "with")
-class BuilderWithNoBuilderMethod {
+class BuilderWithNoBuilderMethodWithSetterPrefix {
 	private String a = "";
 }

File: test/transform/resource/before/BuilderWithNonNullWithSetterPrefix.java
Patch:
@@ -1,5 +1,5 @@
 @lombok.Builder(setterPrefix = "with")
-class BuilderWithNonNull {
+class BuilderWithNonNullWithSetterPrefix {
 	@lombok.NonNull
 	private final String id;
 }

File: test/transform/resource/before/BuilderWithRecursiveGenericsWithSetterPrefix.java
Patch:
@@ -3,7 +3,7 @@
 import lombok.Builder;
 import lombok.Value;
 
-public class BuilderWithRecursiveGenerics {
+public class BuilderWithRecursiveGenericsWithSetterPrefix {
 	interface Inter<T, U extends Inter<T, U>> {}
 	
 	@Builder(setterPrefix = "with") @Value public static class Test<Foo, Bar extends Set<Foo>, Quz extends Inter<Bar, Quz>> {

File: test/transform/resource/before/BuilderWithToBuilderWithSetterPrefix.java
Patch:
@@ -1,7 +1,7 @@
 import java.util.List;
 import lombok.Builder;
 @Builder(toBuilder = true, setterPrefix = "with") @lombok.experimental.Accessors(prefix = "m")
-class BuilderWithToBuilder<T> {
+class BuilderWithToBuilderWithSetterPrefix<T> {
 	private String mOne, mTwo;
 	@Builder.ObtainVia(method = "rrr", isStatic = true) private T foo;
 	@lombok.Singular private List<T> bars;
@@ -10,11 +10,11 @@ public static <K> K rrr(BuilderWithToBuilder<K> x) {
 	}
 }
 @lombok.experimental.Accessors(prefix = "m")
-class ConstructorWithToBuilder<T> {
+class ConstructorWithToBuilderWithSetterPrefix<T> {
 	private String mOne, mTwo;
 	private T foo;
 	@lombok.Singular private com.google.common.collect.ImmutableList<T> bars;
-	@Builder(toBuilder = true)
+	@Builder(toBuilder = true, setterPrefix = "with")
 	public ConstructorWithToBuilder(String mOne, @Builder.ObtainVia(field = "foo") T baz, com.google.common.collect.ImmutableList<T> bars) {
 	}
 }

File: test/transform/resource/before/BuilderSimpleWithSetterPrefix.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
 
 @lombok.Builder(access = lombok.AccessLevel.PROTECTED, setterPrefix = "with")
-class BuilderWithPrefix<T> {
+class BuilderSimpleWithSetterPrefix<T> {
 	private int unprefixed;
 }

File: src/core/lombok/Builder.java
Patch:
@@ -160,6 +160,9 @@
 	 *
 	 * For example, a method normally generated as {@code someField(String someField)} would instead be generated as {@code withSomeField(String someField)}
 	 *
+	 * Note that using "with" to prefix builder setter methods is strongly discouraged as as "with" normally
+	 * suggests immutable data structures, and builders by definition are mutable objects.
+	 *
 	 * @return The prefix to prepend to generated method names.
 	 */
 	String setterPrefix() default "";

File: src/core/lombok/core/TypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2015 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -45,7 +45,7 @@ public boolean typeMatches(LombokNode<?, ?, ?> context, String fqn, String typeR
 	
 	public String typeRefToFullyQualifiedName(LombokNode<?, ?, ?> context, TypeLibrary library, String typeRef) {
 		typeRef = LombokInternalAliasing.processAliases(typeRef);
-		// When asking if 'Foo' could possibly  be referring to 'bar.Baz', the answer is obviously no.
+		// When asking if 'Foo' could possibly be referring to 'bar.Baz', the answer is obviously no.
 		String qualified = library.toQualified(typeRef);
 		if (qualified == null) return null;
 		

File: src/core/lombok/core/Version.java
Patch:
@@ -30,7 +30,7 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "1.18.9";
+	private static final String VERSION = "1.18.11";
 	private static final String RELEASE_NAME = "Edgy Guinea Pig";
 //	private static final String RELEASE_NAME = "Envious Ferret";
 	

File: src/core/lombok/experimental/Wither.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2017 The Project Lombok Authors.
+ * Copyright (C) 2012-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -50,6 +50,8 @@
  * <p>
  * This annotation can also be applied to a class, in which case it'll be as if all non-static fields that don't already have
  * a {@code Wither} annotation have the annotation.
+ * 
+ * @deprecated {@link lombok.With} has been promoted to the main package, so use that one instead.
  */
 @Target({ElementType.FIELD, ElementType.TYPE})
 @Retention(RetentionPolicy.SOURCE)

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -29,6 +29,7 @@
 import lombok.AccessLevel;
 import lombok.core.GuavaTypeMap;
 import lombok.core.LombokImmutableList;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -71,8 +72,8 @@ protected String getBuilderMethodName(SingularData data) {
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSetSingularizer.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Collections;
 
 import lombok.AccessLevel;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -66,8 +67,8 @@ abstract class JavacJavaUtilListSetSingularizer extends JavacJavaUtilSingularize
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilMapSingularizer.java
Patch:
@@ -28,6 +28,7 @@
 
 import lombok.AccessLevel;
 import lombok.core.LombokImmutableList;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -97,8 +98,8 @@ public class JavacJavaUtilMapSingularizer extends JavacJavaUtilSingularizer {
 		return Arrays.asList(keyFieldNode, valueFieldNode);
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -436,14 +436,14 @@ private boolean isPartOfShadowSuffix(String url, String name, String suffix) {
 		Enumeration<URL> sec = super.getResources(name);
 		while (sec.hasMoreElements()) {
 			URL item = sec.nextElement();
-			if (!partOfShadow(item.toString(), name)) vector.add(item);
+			if (isPartOfShadowSuffix(item.toString(), name, sclSuffix)) vector.add(item);
 		}
 		
 		if (altName != null) {
 			Enumeration<URL> tern = super.getResources(altName);
 			while (tern.hasMoreElements()) {
 				URL item = tern.nextElement();
-				if (!partOfShadow(item.toString(), altName)) vector.add(item);
+				if (isPartOfShadowSuffix(item.toString(), altName, sclSuffix)) vector.add(item);
 			}
 		}
 		

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -47,6 +47,7 @@
 import lombok.core.configuration.ConfigurationResolver;
 import lombok.core.configuration.ConfigurationResolverFactory;
 import lombok.javac.CapturingDiagnosticListener.CompilerMessage;
+import lombok.transform.TestLombokFilesIdempotent;
 
 public abstract class AbstractRunTests {
 	private final File dumpActualFilesHere;
@@ -74,6 +75,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 		if (expected.isIgnore()) return null;
 		if (!expected.versionWithinLimit(params.getVersion())) return null;
 		if (!expected.versionWithinLimit(version)) return null;
+		if (expected.isSkipIdempotent() && params instanceof TestLombokFilesIdempotent) return null;
 		
 		final LombokTestSource sourceDirectives_ = sourceDirectives;
 		final AssertionError directiveFailure_ = directiveFailure;

File: test/core/src/lombok/CompilerMessageMatcher.java
Patch:
@@ -88,7 +88,7 @@ public static List<CompilerMessageMatcher> readAll(InputStream rawIn) throws IOE
 		return out;
 	}
 	
-	private static final Pattern PATTERN = Pattern.compile("^(\\d+) (.*)$");
+	private static final Pattern PATTERN = Pattern.compile("^(-?\\d+) (.*)$");
 	
 	private static CompilerMessageMatcher read(String line) {
 		line = line.trim();

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -36,7 +36,8 @@
 import org.junit.runner.notification.RunNotifier;
 
 public class DirectoryRunner extends Runner {
-	private static final String DEBUG_FOCUS_ON_FILE = null;
+	/** Fill in a file name (or multiple, space separated) to reduce the testset to just the named file(s). */
+	private static final String DEBUG_FOCUS_ON_FILE = "";
 	
 	public enum Compiler {
 		DELOMBOK {
@@ -79,7 +80,7 @@ public boolean accept(File file) {
 	private static final FileFilter JAVA_FILE_FILTER = new FileFilter() {
 		@Override public boolean accept(File file) {
 			return file.isFile() && file.getName().endsWith(".java") &&
-				(DEBUG_FOCUS_ON_FILE == null || file.getName().equals(DEBUG_FOCUS_ON_FILE));
+				(DEBUG_FOCUS_ON_FILE.isEmpty() || (" " + DEBUG_FOCUS_ON_FILE + " ").contains(" " + file.getName() + " "));
 		}
 	};
 	

File: test/transform/resource/after-delombok/WithOnStatic.java
Patch:
@@ -1,4 +1,4 @@
-class WitherOnStatic {
+class WithOnStatic {
 	static boolean foo;
 	static int bar;
 }

File: test/transform/resource/after-delombok/WithWithDollar.java
Patch:
@@ -0,0 +1,3 @@
+class WithWithDollar {
+	int $i;
+}

File: test/transform/resource/after-delombok/WitherWithDollar.java
Patch:
@@ -1,3 +0,0 @@
-class WitherWithDollar {
-	int $i;
-}

File: test/transform/resource/before/BuilderInvalidUse.java
Patch:
@@ -3,7 +3,7 @@
 class BuilderInvalidUse {
 	private int something;
 
-	@lombok.Getter @lombok.Setter @lombok.experimental.FieldDefaults(makeFinal = true) @lombok.experimental.Wither @lombok.Data @lombok.ToString @lombok.EqualsAndHashCode
+	@lombok.Getter @lombok.Setter @lombok.experimental.FieldDefaults(makeFinal = true) @lombok.With @lombok.Data @lombok.ToString @lombok.EqualsAndHashCode
 	@lombok.AllArgsConstructor
 	public static class BuilderInvalidUseBuilder {
 

File: test/transform/resource/before/FlagUsages.java
Patch:
@@ -1,10 +1,11 @@
 //skip compare content
 //CONF: lombok.Getter.flagUsage = WARNING
 //CONF: lombok.experimental.flagUsage = ERROR
+@lombok.experimental.FieldNameConstants
 public class FlagUsages {
 	@lombok.Getter String x;
 
-	@lombok.experimental.Wither String z;
+	String z;
 
 	public FlagUsages(String x, String y) {
 	}

File: test/transform/resource/before/WithMethodAbstract.java
Patch:
@@ -0,0 +1,3 @@
+abstract class WithMethodAbstract {
+	@lombok.With String foo;
+}
\ No newline at end of file

File: test/transform/resource/before/WithWithDollar.java
Patch:
@@ -0,0 +1,3 @@
+class WithWithDollar {
+	@lombok.With int $i;
+}

File: test/transform/resource/before/WitherWithAbstract.java
Patch:
@@ -1,3 +0,0 @@
-abstract class WitherWithAbstract {
-	@lombok.experimental.Wither String foo;
-}
\ No newline at end of file

File: test/transform/resource/before/WitherWithDollar.java
Patch:
@@ -1,3 +0,0 @@
-class WitherWithDollar {
-	@lombok.experimental.Wither int $i;
-}

File: src/core/lombok/core/TypeResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2015 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -45,7 +45,7 @@ public boolean typeMatches(LombokNode<?, ?, ?> context, String fqn, String typeR
 	
 	public String typeRefToFullyQualifiedName(LombokNode<?, ?, ?> context, TypeLibrary library, String typeRef) {
 		typeRef = LombokInternalAliasing.processAliases(typeRef);
-		// When asking if 'Foo' could possibly  be referring to 'bar.Baz', the answer is obviously no.
+		// When asking if 'Foo' could possibly be referring to 'bar.Baz', the answer is obviously no.
 		String qualified = library.toQualified(typeRef);
 		if (qualified == null) return null;
 		

File: test/transform/resource/after-ecj/CheckerFrameworkSuperBuilder.java
Patch:
@@ -96,7 +96,7 @@ private ParentBuilderImpl() {
       public ChildBuilder() {
       }
       protected abstract @java.lang.Override @org.checkerframework.checker.builder.qual.ReturnsReceiver @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") B self();
-      protected abstract @java.lang.Override @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") C build(final @org.checkerframework.checker.builder.qual.CalledMethods("b") ChildBuilder this);
+      public abstract @java.lang.Override @org.checkerframework.dataflow.qual.SideEffectFree @java.lang.SuppressWarnings("all") C build(final @org.checkerframework.checker.builder.qual.CalledMethods("b") ChildBuilder this);
       public @org.checkerframework.checker.builder.qual.ReturnsReceiver @java.lang.SuppressWarnings("all") B a(final @org.checkerframework.checker.builder.qual.NotCalledMethods("a") ChildBuilder this, final int a) {
         this.a$value = a;
         a$set = true;

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -226,7 +226,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		if (isFieldDeprecated(fieldNode) || deprecate) {
 			deprecated = new Annotation[] { generateDeprecatedAnnotation(source) };
 		}
-		method.annotations = mergeAnnotations(copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated), findCopyableToSetterAnnotations(fieldNode));
+		method.annotations = copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated, findCopyableToSetterAnnotations(fieldNode));
 		Argument param = new Argument(paramName, p, copyType(field.type, source), Modifier.FINAL);
 		param.sourceStart = pS; param.sourceEnd = pE;
 		method.arguments = new Argument[] { param };

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -339,7 +339,8 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 			Name rawName = field.name;
 			List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(fieldNode);
 			long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());
-			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, copyableAnnotations), fieldName, field.vartype, null);
+			JCExpression pType = cloneType(fieldNode.getTreeMaker(), field.vartype, source.get(), source.getContext());
+			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, copyableAnnotations), fieldName, pType, null);
 			params.append(param);
 			if (hasNonNullAnnotations(fieldNode)) {
 				JCStatement nullCheck = generateNullCheck(maker, param, source);

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -225,7 +225,7 @@ public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker tr
 		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
 		
 		// Remember the type; lazy will change it
-		JCExpression methodType = copyType(treeMaker, fieldNode);
+		JCExpression methodType = cloneType(treeMaker, copyType(treeMaker, fieldNode), source, field.getContext());
 		// Generate the methodName; lazy will change the field type
 		Name methodName = field.toName(toGetterName(field));
 		

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -242,7 +242,8 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
 		
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
-		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), paramName, fieldDecl.vartype, null);
+		JCExpression pType = cloneType(treeMaker, fieldDecl.vartype, source.get(), source.getContext());
+		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), paramName, pType, null);
 		
 		if (!hasNonNullAnnotations(field) && !hasNonNullAnnotations(field, onParam)) {
 			statements.append(treeMaker.Exec(assign));

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -29,6 +29,7 @@
 import lombok.AccessLevel;
 import lombok.core.GuavaTypeMap;
 import lombok.core.LombokImmutableList;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -71,8 +72,8 @@ protected String getBuilderMethodName(SingularData data) {
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSetSingularizer.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Collections;
 
 import lombok.AccessLevel;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -66,8 +67,8 @@ abstract class JavacJavaUtilListSetSingularizer extends JavacJavaUtilSingularize
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilMapSingularizer.java
Patch:
@@ -28,6 +28,7 @@
 
 import lombok.AccessLevel;
 import lombok.core.LombokImmutableList;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -97,8 +98,8 @@ public class JavacJavaUtilMapSingularizer extends JavacJavaUtilSingularizer {
 		return Arrays.asList(keyFieldNode, valueFieldNode);
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -436,14 +436,14 @@ private boolean isPartOfShadowSuffix(String url, String name, String suffix) {
 		Enumeration<URL> sec = super.getResources(name);
 		while (sec.hasMoreElements()) {
 			URL item = sec.nextElement();
-			if (!partOfShadow(item.toString(), name)) vector.add(item);
+			if (isPartOfShadowSuffix(item.toString(), name, sclSuffix)) vector.add(item);
 		}
 		
 		if (altName != null) {
 			Enumeration<URL> tern = super.getResources(altName);
 			while (tern.hasMoreElements()) {
 				URL item = tern.nextElement();
-				if (!partOfShadow(item.toString(), altName)) vector.add(item);
+				if (isPartOfShadowSuffix(item.toString(), altName, sclSuffix)) vector.add(item);
 			}
 		}
 		

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -47,6 +47,7 @@
 import lombok.core.configuration.ConfigurationResolver;
 import lombok.core.configuration.ConfigurationResolverFactory;
 import lombok.javac.CapturingDiagnosticListener.CompilerMessage;
+import lombok.transform.TestLombokFilesIdempotent;
 
 public abstract class AbstractRunTests {
 	private final File dumpActualFilesHere;
@@ -74,6 +75,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 		if (expected.isIgnore()) return null;
 		if (!expected.versionWithinLimit(params.getVersion())) return null;
 		if (!expected.versionWithinLimit(version)) return null;
+		if (expected.isSkipIdempotent() && params instanceof TestLombokFilesIdempotent) return null;
 		
 		final LombokTestSource sourceDirectives_ = sourceDirectives;
 		final AssertionError directiveFailure_ = directiveFailure;

File: test/core/src/lombok/CompilerMessageMatcher.java
Patch:
@@ -88,7 +88,7 @@ public static List<CompilerMessageMatcher> readAll(InputStream rawIn) throws IOE
 		return out;
 	}
 	
-	private static final Pattern PATTERN = Pattern.compile("^(\\d+) (.*)$");
+	private static final Pattern PATTERN = Pattern.compile("^(-?\\d+) (.*)$");
 	
 	private static CompilerMessageMatcher read(String line) {
 		line = line.trim();

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -36,7 +36,8 @@
 import org.junit.runner.notification.RunNotifier;
 
 public class DirectoryRunner extends Runner {
-	private static final String DEBUG_FOCUS_ON_FILE = null;
+	/** Fill in a file name (or multiple, space separated) to reduce the testset to just the named file(s). */
+	private static final String DEBUG_FOCUS_ON_FILE = "";
 	
 	public enum Compiler {
 		DELOMBOK {
@@ -79,7 +80,7 @@ public boolean accept(File file) {
 	private static final FileFilter JAVA_FILE_FILTER = new FileFilter() {
 		@Override public boolean accept(File file) {
 			return file.isFile() && file.getName().endsWith(".java") &&
-				(DEBUG_FOCUS_ON_FILE == null || file.getName().equals(DEBUG_FOCUS_ON_FILE));
+				(DEBUG_FOCUS_ON_FILE.isEmpty() || (" " + DEBUG_FOCUS_ON_FILE + " ").contains(" " + file.getName() + " "));
 		}
 	};
 	

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -436,14 +436,14 @@ private boolean isPartOfShadowSuffix(String url, String name, String suffix) {
 		Enumeration<URL> sec = super.getResources(name);
 		while (sec.hasMoreElements()) {
 			URL item = sec.nextElement();
-			if (!partOfShadow(item.toString(), name)) vector.add(item);
+			if (isPartOfShadowSuffix(item.toString(), name, sclSuffix)) vector.add(item);
 		}
 		
 		if (altName != null) {
 			Enumeration<URL> tern = super.getResources(altName);
 			while (tern.hasMoreElements()) {
 				URL item = tern.nextElement();
-				if (!partOfShadow(item.toString(), altName)) vector.add(item);
+				if (isPartOfShadowSuffix(item.toString(), altName, sclSuffix)) vector.add(item);
 			}
 		}
 		

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -29,6 +29,7 @@
 import lombok.AccessLevel;
 import lombok.core.GuavaTypeMap;
 import lombok.core.LombokImmutableList;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -71,8 +72,8 @@ protected String getBuilderMethodName(SingularData data) {
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSetSingularizer.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Collections;
 
 import lombok.AccessLevel;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -66,8 +67,8 @@ abstract class JavacJavaUtilListSetSingularizer extends JavacJavaUtilSingularize
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilMapSingularizer.java
Patch:
@@ -28,6 +28,7 @@
 
 import lombok.AccessLevel;
 import lombok.core.LombokImmutableList;
+import lombok.core.configuration.CheckerFrameworkVersion;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacHandlerUtil;
@@ -97,8 +98,8 @@ public class JavacJavaUtilMapSingularizer extends JavacJavaUtilSingularizer {
 		return Arrays.asList(keyFieldNode, valueFieldNode);
 	}
 	
-	@Override public void generateMethods(SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
-		doGenerateMethods(data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
+	@Override public void generateMethods(CheckerFrameworkVersion cfv, SingularData data, boolean deprecate, JavacNode builderType, JCTree source, boolean fluent, ExpressionMaker returnTypeMaker, StatementMaker returnStatementMaker, AccessLevel access) {
+		doGenerateMethods(cfv, data, deprecate, builderType, source, fluent, returnTypeMaker, returnStatementMaker, access);
 	}
 	
 	@Override

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -47,6 +47,7 @@
 import lombok.core.configuration.ConfigurationResolver;
 import lombok.core.configuration.ConfigurationResolverFactory;
 import lombok.javac.CapturingDiagnosticListener.CompilerMessage;
+import lombok.transform.TestLombokFilesIdempotent;
 
 public abstract class AbstractRunTests {
 	private final File dumpActualFilesHere;
@@ -74,6 +75,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 		if (expected.isIgnore()) return null;
 		if (!expected.versionWithinLimit(params.getVersion())) return null;
 		if (!expected.versionWithinLimit(version)) return null;
+		if (expected.isSkipIdempotent() && params instanceof TestLombokFilesIdempotent) return null;
 		
 		final LombokTestSource sourceDirectives_ = sourceDirectives;
 		final AssertionError directiveFailure_ = directiveFailure;

File: test/core/src/lombok/CompilerMessageMatcher.java
Patch:
@@ -88,7 +88,7 @@ public static List<CompilerMessageMatcher> readAll(InputStream rawIn) throws IOE
 		return out;
 	}
 	
-	private static final Pattern PATTERN = Pattern.compile("^(\\d+) (.*)$");
+	private static final Pattern PATTERN = Pattern.compile("^(-?\\d+) (.*)$");
 	
 	private static CompilerMessageMatcher read(String line) {
 		line = line.trim();

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -36,7 +36,8 @@
 import org.junit.runner.notification.RunNotifier;
 
 public class DirectoryRunner extends Runner {
-	private static final String DEBUG_FOCUS_ON_FILE = null;
+	/** Fill in a file name (or multiple, space separated) to reduce the testset to just the named file(s). */
+	private static final String DEBUG_FOCUS_ON_FILE = "";
 	
 	public enum Compiler {
 		DELOMBOK {
@@ -79,7 +80,7 @@ public boolean accept(File file) {
 	private static final FileFilter JAVA_FILE_FILTER = new FileFilter() {
 		@Override public boolean accept(File file) {
 			return file.isFile() && file.getName().endsWith(".java") &&
-				(DEBUG_FOCUS_ON_FILE == null || file.getName().equals(DEBUG_FOCUS_ON_FILE));
+				(DEBUG_FOCUS_ON_FILE.isEmpty() || (" " + DEBUG_FOCUS_ON_FILE + " ").contains(" " + file.getName() + " "));
 		}
 	};
 	

File: src/launch/lombok/launch/ShadowClassLoader.java
Patch:
@@ -436,14 +436,14 @@ private boolean isPartOfShadowSuffix(String url, String name, String suffix) {
 		Enumeration<URL> sec = super.getResources(name);
 		while (sec.hasMoreElements()) {
 			URL item = sec.nextElement();
-			if (!partOfShadow(item.toString(), name)) vector.add(item);
+			if (isPartOfShadowSuffix(item.toString(), name, sclSuffix)) vector.add(item);
 		}
 		
 		if (altName != null) {
 			Enumeration<URL> tern = super.getResources(altName);
 			while (tern.hasMoreElements()) {
 				URL item = tern.nextElement();
-				if (!partOfShadow(item.toString(), altName)) vector.add(item);
+				if (isPartOfShadowSuffix(item.toString(), altName, sclSuffix)) vector.add(item);
 			}
 		}
 		

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -339,7 +339,8 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 			Name rawName = field.name;
 			List<JCAnnotation> copyableAnnotations = findCopyableAnnotations(fieldNode);
 			long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());
-			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, copyableAnnotations), fieldName, field.vartype, null);
+			JCExpression pType = cloneType(fieldNode.getTreeMaker(), field.vartype, source.get(), source.getContext());
+			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, copyableAnnotations), fieldName, pType, null);
 			params.append(param);
 			if (hasNonNullAnnotations(fieldNode)) {
 				JCStatement nullCheck = generateNullCheck(maker, param, source);

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -223,7 +223,7 @@ public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker tr
 		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
 		
 		// Remember the type; lazy will change it
-		JCExpression methodType = copyType(treeMaker, fieldNode);
+		JCExpression methodType = cloneType(treeMaker, copyType(treeMaker, fieldNode), source, field.getContext());
 		// Generate the methodName; lazy will change the field type
 		Name methodName = field.toName(toGetterName(field));
 		

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -233,7 +233,8 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(copyableAnnotations);
 		
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
-		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), paramName, fieldDecl.vartype, null);
+		JCExpression pType = cloneType(treeMaker, fieldDecl.vartype, source.get(), source.getContext());
+		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), paramName, pType, null);
 		
 		if (!hasNonNullAnnotations(field) && !hasNonNullAnnotations(field, onParam)) {
 			statements.append(treeMaker.Exec(assign));

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -302,6 +302,7 @@ public static int primeForNull() {
 		}));
 		COPY_TO_SETTER_ANNOTATIONS = Collections.unmodifiableList(Arrays.asList(new String[] {
 				"com.fasterxml.jackson.annotation.JsonProperty",
+				"com.fasterxml.jackson.annotation.JsonSetter",
 			}));
 	}
 	

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -342,7 +342,7 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, copyableAnnotations), fieldName, field.vartype, null);
 			params.append(param);
 			if (hasNonNullAnnotations(fieldNode)) {
-				JCStatement nullCheck = generateNullCheck(maker, fieldNode, param, source);
+				JCStatement nullCheck = generateNullCheck(maker, param, source);
 				if (nullCheck != null) nullChecks.append(nullCheck);
 			}
 			JCFieldAccess thisX = maker.Select(maker.Ident(fieldNode.toName("this")), rawName);

File: test/transform/resource/before/JacksonJsonProperty.java
Patch:
@@ -1,10 +1,13 @@
 import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonSetter;
+import com.fasterxml.jackson.annotation.Nulls;
 import lombok.Builder;
 import lombok.Setter;
 
 @Builder
 public class JacksonJsonProperty {
 	@JsonProperty("kebab-case-prop")
+	@JsonSetter(nulls = Nulls.SKIP)
 	@Setter
 	public String kebabCaseProp;
 }

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -302,6 +302,7 @@ public static int primeForNull() {
 		}));
 		COPY_TO_SETTER_ANNOTATIONS = Collections.unmodifiableList(Arrays.asList(new String[] {
 				"com.fasterxml.jackson.annotation.JsonProperty",
+				"com.fasterxml.jackson.annotation.JsonSetter",
 			}));
 	}
 	

File: test/transform/resource/before/JacksonJsonProperty.java
Patch:
@@ -1,10 +1,13 @@
 import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonSetter;
+import com.fasterxml.jackson.annotation.Nulls;
 import lombok.Builder;
 import lombok.Setter;
 
 @Builder
 public class JacksonJsonProperty {
 	@JsonProperty("kebab-case-prop")
+	@JsonSetter(nulls = Nulls.SKIP)
 	@Setter
 	public String kebabCaseProp;
 }

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -342,7 +342,7 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, copyableAnnotations), fieldName, field.vartype, null);
 			params.append(param);
 			if (hasNonNullAnnotations(fieldNode)) {
-				JCStatement nullCheck = generateNullCheck(maker, fieldNode, param, source);
+				JCStatement nullCheck = generateNullCheck(maker, param, source);
 				if (nullCheck != null) nullChecks.append(nullCheck);
 			}
 			JCFieldAccess thisX = maker.Select(maker.Ident(fieldNode.toName("this")), rawName);

File: test/transform/resource/after-ecj/BuilderWithPrefix.java
Patch:
@@ -13,7 +13,7 @@
       return new BuilderWithPrefix<T>(unprefixed);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-      return (((("BuilderWithPrefix.BuilderWithPrefixBuilder(unprefixed=" + this.unprefixed) + ")");
+      return (("BuilderWithPrefix.BuilderWithPrefixBuilder(unprefixed=" + this.unprefixed) + ")");
     }
   }
   private int unprefixed;

File: src/core/lombok/core/configuration/TypeName.java
Patch:
@@ -34,7 +34,7 @@ public static TypeName valueOf(String name) {
 		if (name == null || name.trim().isEmpty()) return null;
 		
 		String trimmedName = name.trim();
-		for (String identifier : trimmedName.split(".")) {
+		for (String identifier : trimmedName.split("\\.")) {
 			if (!JavaIdentifiers.isValidJavaIdentifier(identifier)) throw new IllegalArgumentException("Invalid type name " + trimmedName + " (part " + identifier + ")");
 		}
 		return new TypeName(trimmedName);

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -760,7 +760,7 @@ public static Annotation[] findCopyableAnnotations(EclipseNode node) {
 			TypeReference typeRef = annotation.type;
 			boolean match = false;
 			if (typeRef != null && typeRef.getTypeName() != null) {
-				for (TypeName cn : configuredCopyable) if (typeMatches(cn.toString(), node, typeRef)) {
+				for (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, typeRef)) {
 					result.add(annotation);
 					match = true;
 					break;

File: src/core/lombok/eclipse/handlers/HandleFieldNameConstants.java
Patch:
@@ -135,7 +135,7 @@ private void createInnerTypeFieldNameConstants(EclipseNode typeNode, EclipseNode
 		TypeDeclaration parent = (TypeDeclaration) typeNode.get();
 		EclipseNode fieldsType = findInnerClass(typeNode, innerTypeName.getName());
 		boolean genConstr = false, genClinit = false;
-		char[] name = innerTypeName.getName().toCharArray();
+		char[] name = innerTypeName.getCharArray();
 		TypeDeclaration generatedInnerType = null;
 		if (fieldsType == null) {
 			generatedInnerType = new TypeDeclaration(parent.compilationResult);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1450,7 +1450,7 @@ public static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {
 		java.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);
 		
 		if (!annoName.isEmpty()) {
-			for (TypeName cn : configuredCopyable) if (typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);
+			for (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);
 			for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);
 		}
 		
@@ -1459,7 +1459,7 @@ public static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {
 			if (child.getKind() == Kind.ANNOTATION) {
 				JCAnnotation annotation = (JCAnnotation) child.get();
 				boolean match = false;
-				for (TypeName cn : configuredCopyable) if (typeMatches(cn.toString(), node, annotation.annotationType)) {
+				for (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotation.annotationType)) {
 					result.append(annotation);
 					match = true;
 					break;

File: src/delombok/lombok/delombok/PrettyPrinter.java
Patch:
@@ -692,7 +692,10 @@ private void printEnumMember(JCVariableDecl tree) {
 	@Override public void visitTypeApply(JCTypeApply tree) {
 		print(tree.clazz);
 		print("<");
+		boolean temp = innermostArrayBracketsAreVarargs;
+		innermostArrayBracketsAreVarargs = false;
 		print(tree.arguments, ", ");
+		innermostArrayBracketsAreVarargs = temp;
 		print(">");
 	}
 	

File: src/core/lombok/core/configuration/TypeName.java
Patch:
@@ -34,7 +34,7 @@ public static TypeName valueOf(String name) {
 		if (name == null || name.trim().isEmpty()) return null;
 		
 		String trimmedName = name.trim();
-		for (String identifier : trimmedName.split(".")) {
+		for (String identifier : trimmedName.split("\\.")) {
 			if (!JavaIdentifiers.isValidJavaIdentifier(identifier)) throw new IllegalArgumentException("Invalid type name " + trimmedName + " (part " + identifier + ")");
 		}
 		return new TypeName(trimmedName);

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -760,7 +760,7 @@ public static Annotation[] findCopyableAnnotations(EclipseNode node) {
 			TypeReference typeRef = annotation.type;
 			boolean match = false;
 			if (typeRef != null && typeRef.getTypeName() != null) {
-				for (TypeName cn : configuredCopyable) if (typeMatches(cn.toString(), node, typeRef)) {
+				for (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, typeRef)) {
 					result.add(annotation);
 					match = true;
 					break;

File: src/core/lombok/eclipse/handlers/HandleFieldNameConstants.java
Patch:
@@ -135,7 +135,7 @@ private void createInnerTypeFieldNameConstants(EclipseNode typeNode, EclipseNode
 		TypeDeclaration parent = (TypeDeclaration) typeNode.get();
 		EclipseNode fieldsType = findInnerClass(typeNode, innerTypeName.getName());
 		boolean genConstr = false, genClinit = false;
-		char[] name = innerTypeName.getName().toCharArray();
+		char[] name = innerTypeName.getCharArray();
 		TypeDeclaration generatedInnerType = null;
 		if (fieldsType == null) {
 			generatedInnerType = new TypeDeclaration(parent.compilationResult);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1450,7 +1450,7 @@ public static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {
 		java.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);
 		
 		if (!annoName.isEmpty()) {
-			for (TypeName cn : configuredCopyable) if (typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);
+			for (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);
 			for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);
 		}
 		
@@ -1459,7 +1459,7 @@ public static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {
 			if (child.getKind() == Kind.ANNOTATION) {
 				JCAnnotation annotation = (JCAnnotation) child.get();
 				boolean match = false;
-				for (TypeName cn : configuredCopyable) if (typeMatches(cn.toString(), node, annotation.annotationType)) {
+				for (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotation.annotationType)) {
 					result.append(annotation);
 					match = true;
 					break;

File: src/core/lombok/core/Version.java
Patch:
@@ -30,9 +30,9 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "1.18.8";
-//	private static final String RELEASE_NAME = "Edgy Guinea Pig";
-	private static final String RELEASE_NAME = "Envious Ferret";
+	private static final String VERSION = "1.18.9";
+	private static final String RELEASE_NAME = "Edgy Guinea Pig";
+//	private static final String RELEASE_NAME = "Envious Ferret";
 	
 	// Named version history:
 	//   Angry Butterfly

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -114,6 +114,7 @@
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
@@ -965,7 +966,7 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a
 		// Finally, add however many nullTypeArgument[] arrays as that are missing, inverse the list, toArray it, and use that as PTR's typeArgument argument.
 		
 		List<TypeReference[]> params = new ArrayList<TypeReference[]>();
-		/* Calculate generics */ {
+		/* Calculate generics */ if(!(binding instanceof RawTypeBinding)) {
 			TypeBinding b = binding;
 			while (true) {
 				boolean isFinalStop = b.isLocalType() || !b.isMemberType() || b.enclosingType() == null;

File: test/transform/resource/after-ecj/ValLambda.java
Patch:
@@ -15,5 +15,8 @@ public void easyIntersectionLambda() {
   public void easyLubLambda() {
     final @lombok.val java.lang.Runnable foo = ((System.currentTimeMillis() > 0) ? (Runnable) () -> {
 } : System.out::println);
+    final @lombok.val java.util.function.Function foo2 = ((System.currentTimeMillis() < 0) ? (java.util.function.Function) (<no type> r) -> "" : (<no type> r) -> System.currentTimeMillis());
+    java.util.function.Function foo3 = ((System.currentTimeMillis() < 0) ? (java.util.function.Function) (<no type> r) -> "" : (<no type> r) -> System.currentTimeMillis());
+    final @lombok.val java.util.function.Function<java.lang.String, java.lang.String> foo4 = ((System.currentTimeMillis() < 0) ? (java.util.function.Function<String, String>) (<no type> r) -> "" : (<no type> r) -> String.valueOf(System.currentTimeMillis()));
   }
 }
\ No newline at end of file

File: test/transform/resource/before/ValLambda.java
Patch:
@@ -11,6 +11,9 @@ public void easyIntersectionLambda() {
 	
 	public void easyLubLambda() {
 		lombok.val foo = (System.currentTimeMillis() > 0) ? (Runnable)()-> {} : System.out::println;
+		lombok.val foo2 = (System.currentTimeMillis() < 0) ? (java.util.function.Function) r -> "" : r -> System.currentTimeMillis();
+		java.util.function.Function foo3 = (System.currentTimeMillis() < 0) ? (java.util.function.Function) r -> "" : r -> System.currentTimeMillis();
+		lombok.val foo4 = (System.currentTimeMillis() < 0) ? (java.util.function.Function<String, String>) r -> "" : r -> String.valueOf(System.currentTimeMillis());
 	}
 	
 //	public void castLubLambda() {

File: src/core/lombok/core/AgentLauncher.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.core;
 
 import java.lang.instrument.Instrumentation;
+import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -35,9 +36,10 @@ public static void runAgents(String agentArgs, Instrumentation instrumentation,
 		for (AgentInfo info : AGENTS) {
 			try {
 				Class<?> agentClass = Class.forName(info.className());
-				AgentLaunchable agent = (AgentLaunchable) agentClass.newInstance();
+				AgentLaunchable agent = (AgentLaunchable) agentClass.getConstructor().newInstance();
 				agent.runAgent(agentArgs, instrumentation, injected, launchingContext);
 			} catch (Throwable t) {
+				if (t instanceof InvocationTargetException) t = t.getCause();
 				info.problem(t, instrumentation);
 			}
 		}

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -112,7 +112,7 @@ static class JavacDescriptor extends ProcessorDescriptor {
 			
 			try {
 				ClassLoader classLoader = findAndPatchClassLoader(javacProcEnv);
-				processor = (Processor) Class.forName("lombok.javac.apt.LombokProcessor", false, classLoader).newInstance();
+				processor = (Processor) Class.forName("lombok.javac.apt.LombokProcessor", false, classLoader).getConstructor().newInstance();
 			} catch (Exception e) {
 				delayedWarnings.add("You found a bug in lombok; lombok.javac.apt.LombokProcessor is not available. Lombok will not run during this compilation: " + trace(e));
 				return false;

File: src/core/lombok/core/Version.java
Patch:
@@ -30,9 +30,9 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "1.18.7";
-	private static final String RELEASE_NAME = "Edgy Guinea Pig";
-//	private static final String RELEASE_NAME = "Envious Ferret";
+	private static final String VERSION = "1.18.8";
+//	private static final String RELEASE_NAME = "Edgy Guinea Pig";
+	private static final String RELEASE_NAME = "Envious Ferret";
 	
 	// Named version history:
 	//   Angry Butterfly

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2017 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -220,7 +220,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		if (isFieldDeprecated(fieldNode) || deprecate) {
 			deprecated = new Annotation[] { generateDeprecatedAnnotation(source) };
 		}
-		method.annotations = copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated);
+		method.annotations = mergeAnnotations(copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated), findCopyableToSetterAnnotations(fieldNode));
 		Argument param = new Argument(field.name, p, copyType(field.type, source), Modifier.FINAL);
 		param.sourceStart = pS; param.sourceEnd = pE;
 		method.arguments = new Argument[] { param };
@@ -238,7 +238,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		
 		Annotation[] copyableAnnotations = findCopyableAnnotations(fieldNode);
 		List<Statement> statements = new ArrayList<Statement>(5);
-		if (!hasNonNullAnnotations(fieldNode)) {
+		if (!hasNonNullAnnotations(fieldNode) && !hasNonNullAnnotations(fieldNode, onParam)) {
 			statements.add(assignment);
 		} else {
 			Statement nullCheck = generateNullCheck(field, sourceNode);

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -750,10 +750,11 @@ private void makeSimpleSetterMethodForBuilder(JavacNode builderType, boolean dep
 		
 		JavacTreeMaker maker = fieldNode.getTreeMaker();
 		
-		JCMethodDecl newMethod = HandleSetter.createSetter(toJavacModifier(access), deprecate, fieldNode, maker, setterName, nameOfSetFlag, chain, source, List.<JCAnnotation>nil(), annosOnParam);
+		List<JCAnnotation> methodAnns = JavacHandlerUtil.findCopyableToSetterAnnotations(originalFieldNode);
+		JCMethodDecl newMethod = HandleSetter.createSetter(toJavacModifier(access), deprecate, fieldNode, maker, setterName, nameOfSetFlag, chain, source, methodAnns, annosOnParam);
 		recursiveSetGeneratedBy(newMethod, source.get(), builderType.getContext());
 		copyJavadoc(originalFieldNode, newMethod, CopyJavadoc.SETTER);
-
+		
 		injectMethod(builderType, newMethod);
 	}
 	

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2017 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -234,7 +234,7 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), fieldDecl.name, fieldDecl.vartype, null);
 		
-		if (!hasNonNullAnnotations(field)) {
+		if (!hasNonNullAnnotations(field) && !hasNonNullAnnotations(field, onParam)) {
 			statements.append(treeMaker.Exec(assign));
 		} else {
 			JCStatement nullCheck = generateNullCheck(treeMaker, field, source);
@@ -261,7 +261,7 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
+		List<JCAnnotation> annsOnMethod = mergeAnnotations(copyAnnotations(onMethod), findCopyableToSetterAnnotations(field));
 		if (isFieldDeprecated(field) || deprecate) {
 			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}

File: src/delombok/lombok/delombok/ant/DelombokTask.java
Patch:
@@ -188,7 +188,7 @@ public void execute() throws BuildException {
 			Location loc = getLocation();
 			
 			try {
-				Object instance = shadowLoadClass("lombok.delombok.ant.DelombokTaskImpl").newInstance();
+				Object instance = shadowLoadClass("lombok.delombok.ant.DelombokTaskImpl").getConstructor().newInstance();
 				for (Field selfField : getClass().getDeclaredFields()) {
 					if (selfField.isSynthetic() || Modifier.isStatic(selfField.getModifiers())) continue;
 					Field otherField = instance.getClass().getDeclaredField(selfField.getName());
@@ -208,7 +208,7 @@ public void execute() throws BuildException {
 				Method m = instance.getClass().getMethod("execute", Location.class);
 				m.invoke(instance, loc);
 			} catch (Exception e) {
-				Throwable t = (e instanceof InvocationTargetException) ? ((InvocationTargetException) e).getCause() : e;
+				Throwable t = (e instanceof InvocationTargetException) ? e.getCause() : e;
 				if (t instanceof Error) throw (Error) t;
 				if (t instanceof RuntimeException) throw (RuntimeException) t;
 				throw new RuntimeException(t);

File: test/transform/resource/after-delombok/ValLambda.java
Patch:
@@ -12,7 +12,7 @@ public void easyIntersectionLambda() {
 	}
 	public void easyLubLambda() {
 		final java.lang.Runnable foo = (System.currentTimeMillis() > 0) ? (Runnable) () -> {
-		} : (Runnable) System.out::println;
+		} : System.out::println;
 	}
 //	public void castLubLambda() {
 //		Runnable foo = (Runnable) ((System.currentTimeMillis() > 0) ? () -> {} : System.out::println);

File: test/transform/resource/after-ecj/ValLambda.java
Patch:
@@ -14,6 +14,6 @@ public void easyIntersectionLambda() {
   }
   public void easyLubLambda() {
     final @lombok.val java.lang.Runnable foo = ((System.currentTimeMillis() > 0) ? (Runnable) () -> {
-} : (Runnable) System.out::println);
+} : System.out::println);
   }
 }
\ No newline at end of file

File: test/transform/resource/before/ValLambda.java
Patch:
@@ -10,7 +10,7 @@ public void easyIntersectionLambda() {
 	}
 	
 	public void easyLubLambda() {
-		lombok.val foo = (System.currentTimeMillis() > 0) ? (Runnable)()-> {} : (Runnable)System.out::println;
+		lombok.val foo = (System.currentTimeMillis() > 0) ? (Runnable)()-> {} : System.out::println;
 	}
 	
 //	public void castLubLambda() {

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -220,7 +220,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		if (isFieldDeprecated(fieldNode) || deprecate) {
 			deprecated = new Annotation[] { generateDeprecatedAnnotation(source) };
 		}
-		method.annotations = copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated);
+		method.annotations = mergeAnnotations(copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated), findCopyableToSetterAnnotations(fieldNode));
 		Argument param = new Argument(field.name, p, copyType(field.type, source), Modifier.FINAL);
 		param.sourceStart = pS; param.sourceEnd = pE;
 		method.arguments = new Argument[] { param };

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -750,10 +750,11 @@ private void makeSimpleSetterMethodForBuilder(JavacNode builderType, boolean dep
 		
 		JavacTreeMaker maker = fieldNode.getTreeMaker();
 		
-		JCMethodDecl newMethod = HandleSetter.createSetter(toJavacModifier(access), deprecate, fieldNode, maker, setterName, nameOfSetFlag, chain, source, List.<JCAnnotation>nil(), annosOnParam);
+		List<JCAnnotation> methodAnns = JavacHandlerUtil.findCopyableToSetterAnnotations(originalFieldNode);
+		JCMethodDecl newMethod = HandleSetter.createSetter(toJavacModifier(access), deprecate, fieldNode, maker, setterName, nameOfSetFlag, chain, source, methodAnns, annosOnParam);
 		recursiveSetGeneratedBy(newMethod, source.get(), builderType.getContext());
 		copyJavadoc(originalFieldNode, newMethod, CopyJavadoc.SETTER);
-
+		
 		injectMethod(builderType, newMethod);
 	}
 	

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -261,7 +261,7 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		List<JCExpression> throwsClauses = List.nil();
 		JCExpression annotationMethodDefaultValue = null;
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
+		List<JCAnnotation> annsOnMethod = mergeAnnotations(copyAnnotations(onMethod), findCopyableToSetterAnnotations(field));
 		if (isFieldDeprecated(field) || deprecate) {
 			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2017 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -238,7 +238,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		
 		Annotation[] copyableAnnotations = findCopyableAnnotations(fieldNode);
 		List<Statement> statements = new ArrayList<Statement>(5);
-		if (!hasNonNullAnnotations(fieldNode)) {
+		if (!hasNonNullAnnotations(fieldNode) && !hasNonNullAnnotations(fieldNode, onParam)) {
 			statements.add(assignment);
 		} else {
 			Statement nullCheck = generateNullCheck(field, sourceNode);

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2017 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -234,7 +234,7 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), fieldDecl.name, fieldDecl.vartype, null);
 		
-		if (!hasNonNullAnnotations(field)) {
+		if (!hasNonNullAnnotations(field) && !hasNonNullAnnotations(field, onParam)) {
 			statements.append(treeMaker.Exec(assign));
 		} else {
 			JCStatement nullCheck = generateNullCheck(treeMaker, field, source);

File: src/core/lombok/core/AgentLauncher.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.core;
 
 import java.lang.instrument.Instrumentation;
+import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -35,9 +36,10 @@ public static void runAgents(String agentArgs, Instrumentation instrumentation,
 		for (AgentInfo info : AGENTS) {
 			try {
 				Class<?> agentClass = Class.forName(info.className());
-				AgentLaunchable agent = (AgentLaunchable) agentClass.newInstance();
+				AgentLaunchable agent = (AgentLaunchable) agentClass.getConstructor().newInstance();
 				agent.runAgent(agentArgs, instrumentation, injected, launchingContext);
 			} catch (Throwable t) {
+				if (t instanceof InvocationTargetException) t = t.getCause();
 				info.problem(t, instrumentation);
 			}
 		}

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -112,7 +112,7 @@ static class JavacDescriptor extends ProcessorDescriptor {
 			
 			try {
 				ClassLoader classLoader = findAndPatchClassLoader(javacProcEnv);
-				processor = (Processor) Class.forName("lombok.javac.apt.LombokProcessor", false, classLoader).newInstance();
+				processor = (Processor) Class.forName("lombok.javac.apt.LombokProcessor", false, classLoader).getConstructor().newInstance();
 			} catch (Exception e) {
 				delayedWarnings.add("You found a bug in lombok; lombok.javac.apt.LombokProcessor is not available. Lombok will not run during this compilation: " + trace(e));
 				return false;

File: src/delombok/lombok/delombok/ant/DelombokTask.java
Patch:
@@ -188,7 +188,7 @@ public void execute() throws BuildException {
 			Location loc = getLocation();
 			
 			try {
-				Object instance = shadowLoadClass("lombok.delombok.ant.DelombokTaskImpl").newInstance();
+				Object instance = shadowLoadClass("lombok.delombok.ant.DelombokTaskImpl").getConstructor().newInstance();
 				for (Field selfField : getClass().getDeclaredFields()) {
 					if (selfField.isSynthetic() || Modifier.isStatic(selfField.getModifiers())) continue;
 					Field otherField = instance.getClass().getDeclaredField(selfField.getName());
@@ -208,7 +208,7 @@ public void execute() throws BuildException {
 				Method m = instance.getClass().getMethod("execute", Location.class);
 				m.invoke(instance, loc);
 			} catch (Exception e) {
-				Throwable t = (e instanceof InvocationTargetException) ? ((InvocationTargetException) e).getCause() : e;
+				Throwable t = (e instanceof InvocationTargetException) ? e.getCause() : e;
 				if (t instanceof Error) throw (Error) t;
 				if (t instanceof RuntimeException) throw (RuntimeException) t;
 				throw new RuntimeException(t);

File: src/core/lombok/Generated.java
Patch:
@@ -33,7 +33,8 @@
  * <p>
  * NB: As of v1.16.2 which introduces this annotation, lombok doesn't actually add this annotation; we're setting
  * it up so that lombok jars in widespread use start having this, which will make it easier to actually apply it
- * later on.
+ * later on. By adding {@code lombok.addLombokGeneratedAnnotation = true} to {@code lombok.config} you can already
+ * get this behavior.
  */
 @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE})
 @Retention(RetentionPolicy.CLASS)

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -82,7 +82,7 @@
 import lombok.javac.ResolutionResetNeeded;
 
 @ProviderFor(JavacAnnotationHandler.class)
-@HandlerPriority(65536) //2^16; to make sure that we also delegate generated methods.
+@HandlerPriority(HandleDelegate.HANDLE_DELEGATE_PRIORITY) //2^16; to make sure that we also delegate generated methods.
 @ResolutionResetNeeded
 public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
@@ -102,6 +102,7 @@ public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
 	private static final String LEGALITY_OF_DELEGATE = "@Delegate is legal only on instance fields or no-argument instance methods.";
 	private static final String RECURSION_NOT_ALLOWED = "@Delegate does not support recursion (delegating to a type that itself has @Delegate members). Member \"%s\" is @Delegate in type \"%s\"";
+	public static final int HANDLE_DELEGATE_PRIORITY = 65536;
 
 	
 	@Override public void handle(AnnotationValues<Delegate> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.javac.handlers;
 
 import static lombok.core.handlers.HandlerUtil.handleFlagUsage;
+import static lombok.javac.handlers.HandleDelegate.HANDLE_DELEGATE_PRIORITY;
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 import lombok.ConfigurationKeys;
 import lombok.val;
@@ -49,7 +50,7 @@
 import com.sun.tools.javac.util.List;
 
 @ProviderFor(JavacASTVisitor.class)
-@HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
+@HandlerPriority(HANDLE_DELEGATE_PRIORITY + 100) // run slightly after HandleDelegate; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
 @ResolutionResetNeeded
 public class HandleVal extends JavacASTAdapter {
 	

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilSingularizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Project Lombok Authors.
+ * Copyright (C) 2015-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,14 +32,12 @@
 import com.sun.tools.javac.util.ListBuffer;
 import com.sun.tools.javac.util.Name;
 
-import lombok.ConfigurationKeys;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
 
 abstract class JavacJavaUtilSingularizer extends JavacSingularizer {
-	
 	protected List<JCStatement> createJavaUtilSetMapInitialCapacitySwitchStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, String emptyCollectionMethod, String singletonCollectionMethod, String targetType, JCTree source, String builderVariable) {
 		List<JCExpression> jceBlank = List.nil();
 		ListBuffer<JCCase> cases = new ListBuffer<JCCase>();

File: src/installer/lombok/installer/OsUtils.java
Patch:
@@ -53,14 +53,14 @@ private static void loadWindowsDriveInfoLib() throws IOException {
 		dll1.deleteOnExit();
 		dll2.deleteOnExit();
 		try {
-			if (unpackDLL("WindowsDriveInfo-i386.dll", dll1)) {
+			if (unpackDLL("WindowsDriveInfo-i386.binary", dll1)) {
 				System.load(dll1.getAbsolutePath());
 				return;
 			}
 		} catch (Throwable ignore) {}
 		
 		try {
-			if (unpackDLL("WindowsDriveInfo-x86_64.dll", dll2)) {
+			if (unpackDLL("WindowsDriveInfo-x86_64.binary", dll2)) {
 				System.load(dll2.getAbsolutePath());
 			}
 		} catch (Throwable ignore) {}

File: test/transform/resource/after-delombok/BuilderSimple.java
Patch:
@@ -10,7 +10,7 @@ class BuilderSimple<T> {
 		this.also = also;
 	}
 	@java.lang.SuppressWarnings("all")
-	public static class BuilderSimpleBuilder<T> {
+	protected static class BuilderSimpleBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		private int yes;
 		@java.lang.SuppressWarnings("all")
@@ -39,7 +39,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static <T> BuilderSimpleBuilder<T> builder() {
+	protected static <T> BuilderSimpleBuilder<T> builder() {
 		return new BuilderSimpleBuilder<T>();
 	}
 }

File: test/transform/resource/after-ecj/BuilderSimple.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
-@lombok.Builder class BuilderSimple<T> {
-  public static @java.lang.SuppressWarnings("all") class BuilderSimpleBuilder<T> {
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED) class BuilderSimple<T> {
+  protected static @java.lang.SuppressWarnings("all") class BuilderSimpleBuilder<T> {
     private @java.lang.SuppressWarnings("all") int yes;
     private @java.lang.SuppressWarnings("all") List<T> also;
     @java.lang.SuppressWarnings("all") BuilderSimpleBuilder() {
@@ -30,7 +30,7 @@
     this.yes = yes;
     this.also = also;
   }
-  public static @java.lang.SuppressWarnings("all") <T>BuilderSimpleBuilder<T> builder() {
+  protected static @java.lang.SuppressWarnings("all") <T>BuilderSimpleBuilder<T> builder() {
     return new BuilderSimpleBuilder<T>();
   }
 }

File: test/transform/resource/before/BuilderSimple.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
 
-@lombok.Builder
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED)
 class BuilderSimple<T> {
 	private final int noshow = 0;
 	private final int yes;

File: test/transform/resource/before/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -1,10 +1,10 @@
-import java.util.List;
+import java.util.Map;
 
 public class SuperBuilderWithGenericsAndToBuilder {
 	@lombok.experimental.SuperBuilder(toBuilder = true)
 	public static class Parent<A> {
 		A field1;
-		@lombok.Singular List<String> items;
+		@lombok.Singular Map<Integer, String> items;
 	}
 	
 	@lombok.experimental.SuperBuilder(toBuilder = true)
@@ -13,6 +13,6 @@ public static class Child<A> extends Parent<A> {
 	}
 	
 	public static void test() {
-		Child<Integer> x = Child.<Integer>builder().field3(0.0).field1(5).item("").build().toBuilder().build();
+		Child<Integer> x = Child.<Integer>builder().field3(0.0).field1(5).item(5, "").build().toBuilder().build();
 	}
 }

File: src/core/lombok/Generated.java
Patch:
@@ -33,7 +33,8 @@
  * <p>
  * NB: As of v1.16.2 which introduces this annotation, lombok doesn't actually add this annotation; we're setting
  * it up so that lombok jars in widespread use start having this, which will make it easier to actually apply it
- * later on.
+ * later on. By adding {@code lombok.addLombokGeneratedAnnotation = true} to {@code lombok.config} you can already
+ * get this behavior.
  */
 @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE})
 @Retention(RetentionPolicy.CLASS)

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -82,7 +82,7 @@
 import lombok.javac.ResolutionResetNeeded;
 
 @ProviderFor(JavacAnnotationHandler.class)
-@HandlerPriority(65536) //2^16; to make sure that we also delegate generated methods.
+@HandlerPriority(HandleDelegate.HANDLE_DELEGATE_PRIORITY) //2^16; to make sure that we also delegate generated methods.
 @ResolutionResetNeeded
 public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
@@ -102,6 +102,7 @@ public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
 	private static final String LEGALITY_OF_DELEGATE = "@Delegate is legal only on instance fields or no-argument instance methods.";
 	private static final String RECURSION_NOT_ALLOWED = "@Delegate does not support recursion (delegating to a type that itself has @Delegate members). Member \"%s\" is @Delegate in type \"%s\"";
+	public static final int HANDLE_DELEGATE_PRIORITY = 65536;
 
 	
 	@Override public void handle(AnnotationValues<Delegate> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.javac.handlers;
 
 import static lombok.core.handlers.HandlerUtil.handleFlagUsage;
+import static lombok.javac.handlers.HandleDelegate.HANDLE_DELEGATE_PRIORITY;
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 import lombok.ConfigurationKeys;
 import lombok.val;
@@ -49,7 +50,7 @@
 import com.sun.tools.javac.util.List;
 
 @ProviderFor(JavacASTVisitor.class)
-@HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
+@HandlerPriority(HANDLE_DELEGATE_PRIORITY + 100) // run slightly after HandleDelegate; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
 @ResolutionResetNeeded
 public class HandleVal extends JavacASTAdapter {
 	

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilSingularizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Project Lombok Authors.
+ * Copyright (C) 2015-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,14 +32,12 @@
 import com.sun.tools.javac.util.ListBuffer;
 import com.sun.tools.javac.util.Name;
 
-import lombok.ConfigurationKeys;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
 
 abstract class JavacJavaUtilSingularizer extends JavacSingularizer {
-	
 	protected List<JCStatement> createJavaUtilSetMapInitialCapacitySwitchStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, String emptyCollectionMethod, String singletonCollectionMethod, String targetType, JCTree source, String builderVariable) {
 		List<JCExpression> jceBlank = List.nil();
 		ListBuffer<JCCase> cases = new ListBuffer<JCCase>();

File: src/installer/lombok/installer/OsUtils.java
Patch:
@@ -53,14 +53,14 @@ private static void loadWindowsDriveInfoLib() throws IOException {
 		dll1.deleteOnExit();
 		dll2.deleteOnExit();
 		try {
-			if (unpackDLL("WindowsDriveInfo-i386.dll", dll1)) {
+			if (unpackDLL("WindowsDriveInfo-i386.binary", dll1)) {
 				System.load(dll1.getAbsolutePath());
 				return;
 			}
 		} catch (Throwable ignore) {}
 		
 		try {
-			if (unpackDLL("WindowsDriveInfo-x86_64.dll", dll2)) {
+			if (unpackDLL("WindowsDriveInfo-x86_64.binary", dll2)) {
 				System.load(dll2.getAbsolutePath());
 			}
 		} catch (Throwable ignore) {}

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -91,7 +91,7 @@ public boolean accept(File file) {
 	public DirectoryRunner(Class<?> testClass) throws Exception {
 		description = Description.createSuiteDescription(testClass);
 		
-		this.params = (TestParams) testClass.newInstance();
+		this.params = (TestParams) testClass.getConstructor().newInstance();
 		
 		Throwable error = null;
 		try {

File: test/transform/resource/after-delombok/BuilderSimple.java
Patch:
@@ -10,7 +10,7 @@ class BuilderSimple<T> {
 		this.also = also;
 	}
 	@java.lang.SuppressWarnings("all")
-	public static class BuilderSimpleBuilder<T> {
+	protected static class BuilderSimpleBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		private int yes;
 		@java.lang.SuppressWarnings("all")
@@ -39,7 +39,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static <T> BuilderSimpleBuilder<T> builder() {
+	protected static <T> BuilderSimpleBuilder<T> builder() {
 		return new BuilderSimpleBuilder<T>();
 	}
 }

File: test/transform/resource/after-ecj/BuilderSimple.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
-@lombok.Builder class BuilderSimple<T> {
-  public static @java.lang.SuppressWarnings("all") class BuilderSimpleBuilder<T> {
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED) class BuilderSimple<T> {
+  protected static @java.lang.SuppressWarnings("all") class BuilderSimpleBuilder<T> {
     private @java.lang.SuppressWarnings("all") int yes;
     private @java.lang.SuppressWarnings("all") List<T> also;
     @java.lang.SuppressWarnings("all") BuilderSimpleBuilder() {
@@ -30,7 +30,7 @@
     this.yes = yes;
     this.also = also;
   }
-  public static @java.lang.SuppressWarnings("all") <T>BuilderSimpleBuilder<T> builder() {
+  protected static @java.lang.SuppressWarnings("all") <T>BuilderSimpleBuilder<T> builder() {
     return new BuilderSimpleBuilder<T>();
   }
 }

File: test/transform/resource/before/BuilderSimple.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
 
-@lombok.Builder
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED)
 class BuilderSimple<T> {
 	private final int noshow = 0;
 	private final int yes;

File: test/transform/resource/before/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -1,10 +1,10 @@
-import java.util.List;
+import java.util.Map;
 
 public class SuperBuilderWithGenericsAndToBuilder {
 	@lombok.experimental.SuperBuilder(toBuilder = true)
 	public static class Parent<A> {
 		A field1;
-		@lombok.Singular List<String> items;
+		@lombok.Singular Map<Integer, String> items;
 	}
 	
 	@lombok.experimental.SuperBuilder(toBuilder = true)
@@ -13,6 +13,6 @@ public static class Child<A> extends Parent<A> {
 	}
 	
 	public static void test() {
-		Child<Integer> x = Child.<Integer>builder().field3(0.0).field1(5).item("").build().toBuilder().build();
+		Child<Integer> x = Child.<Integer>builder().field3(0.0).field1(5).item(5, "").build().toBuilder().build();
 	}
 }

File: src/core/lombok/eclipse/handlers/EclipseSingularsRecipes.java
Patch:
@@ -395,5 +395,8 @@ protected static Reference getBuilderReference(String builderVariable) {
 				return new SingleNameReference(builderVariable.toCharArray(), 0);
 			}
 		}
+		
+		protected abstract char[][] getEmptyMakerReceiver(String targetFqn);
+		protected abstract char[] getEmptyMakerSelector(String targetFqn);
 	}
 }

File: src/core/lombok/javac/handlers/JavacSingularsRecipes.java
Patch:
@@ -437,5 +437,7 @@ protected JCExpression cloneParamType(int index, JavacTreeMaker maker, List<JCEx
 		protected abstract String getAddMethodName();
 		
 		protected abstract int getTypeArgumentsCount();
+		
+		protected abstract String getEmptyMaker(String target);
 	}
 }

File: test/transform/resource/before/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -1,10 +1,10 @@
-import java.util.List;
+import java.util.Map;
 
 public class SuperBuilderWithGenericsAndToBuilder {
 	@lombok.experimental.SuperBuilder(toBuilder = true)
 	public static class Parent<A> {
 		A field1;
-		@lombok.Singular List<String> items;
+		@lombok.Singular Map<Integer, String> items;
 	}
 	
 	@lombok.experimental.SuperBuilder(toBuilder = true)
@@ -13,6 +13,6 @@ public static class Child<A> extends Parent<A> {
 	}
 	
 	public static void test() {
-		Child<Integer> x = Child.<Integer>builder().field3(0.0).field1(5).item("").build().toBuilder().build();
+		Child<Integer> x = Child.<Integer>builder().field3(0.0).field1(5).item(5, "").build().toBuilder().build();
 	}
 }

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -889,7 +889,7 @@ private void generateSetterMethodsForBuilder(EclipseNode builderType, BuilderFie
 		if (bfd.singularData == null || bfd.singularData.getSingularizer() == null) {
 			generateSimpleSetterMethodForBuilder(builderType, deprecate, bfd.createdFields.get(0), bfd.nameOfSetFlag, returnTypeMaker.make(), returnStatementMaker.make(), sourceNode, bfd.annotations);
 		} else {
-			bfd.singularData.getSingularizer().generateMethods(bfd.singularData, deprecate, builderType, true, returnTypeMaker, returnStatementMaker);
+			bfd.singularData.getSingularizer().generateMethods(bfd.singularData, deprecate, builderType, true, returnTypeMaker, returnStatementMaker, AccessLevel.PUBLIC);
 		}
 	}
 

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -862,7 +862,7 @@ private void generateSetterMethodsForBuilder(final JavacNode builderType, Builde
 		if (fieldNode.singularData == null || fieldNode.singularData.getSingularizer() == null) {
 			generateSimpleSetterMethodForBuilder(builderType, deprecate, fieldNode.createdFields.get(0), fieldNode.nameOfSetFlag, source, true, returnTypeMaker.make(), returnStatementMaker.make(), fieldNode.annotations);
 		} else {
-			fieldNode.singularData.getSingularizer().generateMethods(fieldNode.singularData, deprecate, builderType, source.get(), true, returnTypeMaker, returnStatementMaker);
+			fieldNode.singularData.getSingularizer().generateMethods(fieldNode.singularData, deprecate, builderType, source.get(), true, returnTypeMaker, returnStatementMaker, AccessLevel.PUBLIC);
 		}
 	}
 	

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilSingularizer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Project Lombok Authors.
+ * Copyright (C) 2015-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,14 +32,12 @@
 import com.sun.tools.javac.util.ListBuffer;
 import com.sun.tools.javac.util.Name;
 
-import lombok.ConfigurationKeys;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
 import lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;
 import lombok.javac.handlers.JavacSingularsRecipes.SingularData;
 
 abstract class JavacJavaUtilSingularizer extends JavacSingularizer {
-	
 	protected List<JCStatement> createJavaUtilSetMapInitialCapacitySwitchStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, boolean mapMode, String emptyCollectionMethod, String singletonCollectionMethod, String targetType, JCTree source, String builderVariable) {
 		List<JCExpression> jceBlank = List.nil();
 		ListBuffer<JCCase> cases = new ListBuffer<JCCase>();

File: test/transform/resource/after-delombok/BuilderSimple.java
Patch:
@@ -10,7 +10,7 @@ class BuilderSimple<T> {
 		this.also = also;
 	}
 	@java.lang.SuppressWarnings("all")
-	public static class BuilderSimpleBuilder<T> {
+	protected static class BuilderSimpleBuilder<T> {
 		@java.lang.SuppressWarnings("all")
 		private int yes;
 		@java.lang.SuppressWarnings("all")
@@ -39,7 +39,7 @@ public java.lang.String toString() {
 		}
 	}
 	@java.lang.SuppressWarnings("all")
-	public static <T> BuilderSimpleBuilder<T> builder() {
+	protected static <T> BuilderSimpleBuilder<T> builder() {
 		return new BuilderSimpleBuilder<T>();
 	}
 }

File: test/transform/resource/after-ecj/BuilderSimple.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
-@lombok.Builder class BuilderSimple<T> {
-  public static @java.lang.SuppressWarnings("all") class BuilderSimpleBuilder<T> {
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED) class BuilderSimple<T> {
+  protected static @java.lang.SuppressWarnings("all") class BuilderSimpleBuilder<T> {
     private @java.lang.SuppressWarnings("all") int yes;
     private @java.lang.SuppressWarnings("all") List<T> also;
     @java.lang.SuppressWarnings("all") BuilderSimpleBuilder() {
@@ -30,7 +30,7 @@
     this.yes = yes;
     this.also = also;
   }
-  public static @java.lang.SuppressWarnings("all") <T>BuilderSimpleBuilder<T> builder() {
+  protected static @java.lang.SuppressWarnings("all") <T>BuilderSimpleBuilder<T> builder() {
     return new BuilderSimpleBuilder<T>();
   }
 }

File: test/transform/resource/before/BuilderSimple.java
Patch:
@@ -1,6 +1,6 @@
 import java.util.List;
 
-@lombok.Builder
+@lombok.Builder(access = lombok.AccessLevel.PROTECTED)
 class BuilderSimple<T> {
 	private final int noshow = 0;
 	private final int yes;

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -82,7 +82,7 @@
 import lombok.javac.ResolutionResetNeeded;
 
 @ProviderFor(JavacAnnotationHandler.class)
-@HandlerPriority(65536) //2^16; to make sure that we also delegate generated methods.
+@HandlerPriority(HandleDelegate.HANDLE_DELEGATE_PRIORITY) //2^16; to make sure that we also delegate generated methods.
 @ResolutionResetNeeded
 public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
@@ -102,6 +102,7 @@ public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
 	private static final String LEGALITY_OF_DELEGATE = "@Delegate is legal only on instance fields or no-argument instance methods.";
 	private static final String RECURSION_NOT_ALLOWED = "@Delegate does not support recursion (delegating to a type that itself has @Delegate members). Member \"%s\" is @Delegate in type \"%s\"";
+	public static final int HANDLE_DELEGATE_PRIORITY = 65536;
 
 	
 	@Override public void handle(AnnotationValues<Delegate> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.javac.handlers;
 
 import static lombok.core.handlers.HandlerUtil.handleFlagUsage;
+import static lombok.javac.handlers.HandleDelegate.HANDLE_DELEGATE_PRIORITY;
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 import lombok.ConfigurationKeys;
 import lombok.val;
@@ -49,7 +50,7 @@
 import com.sun.tools.javac.util.List;
 
 @ProviderFor(JavacASTVisitor.class)
-@HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
+@HandlerPriority(HANDLE_DELEGATE_PRIORITY + 100) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
 @ResolutionResetNeeded
 public class HandleVal extends JavacASTAdapter {
 	

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -91,7 +91,7 @@ public boolean accept(File file) {
 	public DirectoryRunner(Class<?> testClass) throws Exception {
 		description = Description.createSuiteDescription(testClass);
 		
-		this.params = (TestParams) testClass.newInstance();
+		this.params = (TestParams) testClass.getConstructor().newInstance();
 		
 		Throwable error = null;
 		try {

File: src/utils/lombok/javac/JavacTreeMaker.java
Patch:
@@ -442,6 +442,8 @@ public JCMethodDecl MethodDef(JCModifiers mods, Name name, JCExpression resType,
 	private static final MethodId<JCVariableDecl> VarDef = MethodId("VarDef");
 	public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {
 		JCVariableDecl varDef = invoke(VarDef, mods, name, vartype, init);
+		// We use 'position of the type is -1' as indicator in delombok that the original node was written using JDK10's 'var' feature, because javac desugars 'var' to the real type and doesn't leave any markers other than the
+		// node position to indicate that it did so. Unfortunately, that means vardecls we generate look like 'var' to delombok. Adjust the position to avoid this.
 		if (varDef.vartype != null && varDef.vartype.pos == -1) varDef.vartype.pos = 0;
 		return varDef;
 	}

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -91,7 +91,7 @@ public boolean accept(File file) {
 	public DirectoryRunner(Class<?> testClass) throws Exception {
 		description = Description.createSuiteDescription(testClass);
 		
-		this.params = (TestParams) testClass.newInstance();
+		this.params = (TestParams) testClass.getConstructor().newInstance();
 		
 		Throwable error = null;
 		try {

File: test/transform/resource/after-delombok/ValLambda.java
Patch:
@@ -5,9 +5,9 @@ public void easyLambda() {
 		};
 	}
 	public void easyIntersectionLambda() {
-		final java.lang.Object foo = (Runnable & java.io.Serializable) () -> {
+		final java.lang.Runnable foo = (Runnable & java.io.Serializable) () -> {
 		};
-		final java.lang.Object bar = (java.io.Serializable & Runnable) () -> {
+		final java.io.Serializable bar = (java.io.Serializable & Runnable) () -> {
 		};
 	}
 	public void easyLubLambda() {

File: test/transform/resource/after-ecj/ValLambda.java
Patch:
@@ -7,9 +7,9 @@ public void easyLambda() {
 };
   }
   public void easyIntersectionLambda() {
-    final @lombok.val java.lang.Object foo = (Runnable & java.io.Serializable) () -> {
+    final @lombok.val java.lang.Runnable foo = (Runnable & java.io.Serializable) () -> {
 };
-    final @lombok.val java.lang.Object bar = (java.io.Serializable & Runnable) () -> {
+    final @lombok.val java.io.Serializable bar = (java.io.Serializable & Runnable) () -> {
 };
   }
   public void easyLubLambda() {

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -170,7 +170,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 		List<char[]> typeArgsForToBuilder = null;
 		
 		if (builderMethodName == null) builderMethodName = "builder";
-		if (buildMethodName == null) builderMethodName = "build";
+		if (buildMethodName == null) buildMethodName = "build";
 		if (builderClassName == null) builderClassName = "";
 		
 		boolean generateBuilderMethod;

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -417,7 +417,7 @@ static class BuilderFieldData {
 		}
 		
 		{
-			MemberExistsResult methodExists = methodExists(builderMethodName, builderType, -1);
+			MemberExistsResult methodExists = methodExists(buildMethodName, builderType, -1);
 			if (methodExists == MemberExistsResult.EXISTS_BY_LOMBOK) methodExists = methodExists(buildMethodName, builderType, 0);
 			if (methodExists == MemberExistsResult.NOT_EXISTS) {
 				JCMethodDecl md = generateBuildMethod(tdParent, isStatic, buildMethodName, nameOfBuilderMethod, returnType, builderFields, builderType, thrownExceptions, ast, addCleaning);

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -753,6 +753,7 @@ public boolean delombok() throws IOException {
 		Object care = callAttributeMethodOnJavaCompiler(delegate, delegate.todo);
 		
 		callFlowMethodOnJavaCompiler(delegate, care);
+		
 		FormatPreferences fps = new FormatPreferences(formatPrefs);
 		for (JCCompilationUnit unit : roots) {
 			DelombokResult result = new DelombokResult(catcher.getComments(unit), unit, force || options.isChanged(unit), fps);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -265,7 +265,7 @@ public static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNo
 	 */
 	public static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {
 		if (node.getKind() != Kind.ANNOTATION) return false;
-		return typeMatches(type, node, ((JCAnnotation)node.get()).annotationType);
+		return typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);
 	}
 	
 	/**
@@ -301,7 +301,7 @@ public static boolean typeMatches(String type, JavacNode node, JCTree typeNode)
 		String typeName = typeNode == null ? null : typeNode.toString();
 		if (typeName == null || typeName.length() == 0) return false;
 		int lastIndexA = typeName.lastIndexOf('.') + 1;
-		int lastIndexB = type.lastIndexOf('.') + 1;
+		int lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;
 		int len = typeName.length() - lastIndexA;
 		if (len != type.length() - lastIndexB) return false;
 		for (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;

File: src/core/lombok/experimental/FieldNameConstants.java
Patch:
@@ -41,6 +41,8 @@
 	/**
 	 * Only include fields and methods explicitly marked with {@code @FieldNameConstants.Include}.
 	 * Normally, all (non-static) fields are included by default.
+	 * 
+	 * @return If {@code true}, don't include non-static fields automatically (default: {@code false}).
 	 */
 	boolean onlyExplicitlyIncluded() default false;
 	

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -372,7 +372,7 @@ public static void handleFlagUsage(LombokNode<?, ?, ?> node, ConfigurationKey<Fl
 		if (fut != null) {
 			String msg = "Use of " + featureName + " is flagged according to lombok configuration.";
 			if (fut == FlagUsageType.WARNING) node.addWarning(msg);
-			else node.addError(msg);
+			else if (fut == FlagUsageType.ERROR) node.addError(msg);
 		}
 	}
 	

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -372,7 +372,7 @@ public static void handleFlagUsage(LombokNode<?, ?, ?> node, ConfigurationKey<Fl
 		if (fut != null) {
 			String msg = "Use of " + featureName + " is flagged according to lombok configuration.";
 			if (fut == FlagUsageType.WARNING) node.addWarning(msg);
-			else node.addError(msg);
+			else if (fut == FlagUsageType.ERROR) node.addError(msg);
 		}
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/PatchVal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2018 The Project Lombok Authors.
+ * Copyright (C) 2010-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -265,8 +265,9 @@ public static boolean handleValForLocalDeclaration(LocalDeclaration local, Block
 			if (resolved != null) {
 				try {
 					replacement = makeType(resolved, local.type, false);
+					if (!decomponent) init.resolvedType = replacement.resolveType(scope);
 				} catch (Exception e) {
-					// Some type thing failed. It might be an IntersectionType
+					// Some type thing failed.
 				}
 			}
 		}

File: src/core/lombok/experimental/UtilityClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Project Lombok Authors.
+ * Copyright (C) 2015-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -33,6 +33,8 @@
  * <li>It is marked final.</li>
  * <li>If any constructors are declared in it, an error is generated. Otherwise, a private no-args constructor is generated; it throws a {@code UnsupportedOperationException}.</li>
  * <li>All methods, inner classes, and fields in the class are marked static.</li>
+ * <li><em>WARNING:</em> Do not use non-star static imports to import these members; javac won't be able to figure it out. Use either:
+ *    <code>import static ThisType.*;</code> or don't static-import.</li>
  * </ul>
  */
 @Target({ElementType.TYPE})

File: src/core/lombok/Builder.java
Patch:
@@ -33,7 +33,7 @@
  * <p>
  * If a member is annotated, it must be either a constructor or a method. If a class is annotated,
  * then a private constructor is generated with all fields as arguments
- * (as if {@code @AllArgsConstructor(AccessLevel.PRIVATE)} is present
+ * (as if {@code @AllArgsConstructor(access = AccessLevel.PRIVATE)} is present
  * on the class), and it is as if this constructor has been annotated with {@code @Builder} instead.
  * Note that this constructor is only generated if you haven't written any constructors and also haven't
  * added any explicit {@code @XArgsConstructor} annotations. In those cases, lombok will assume an all-args

File: src/core/lombok/Builder.java
Patch:
@@ -33,7 +33,7 @@
  * <p>
  * If a member is annotated, it must be either a constructor or a method. If a class is annotated,
  * then a private constructor is generated with all fields as arguments
- * (as if {@code @AllArgsConstructor(AccessLevel.PRIVATE)} is present
+ * (as if {@code @AllArgsConstructor(access = AccessLevel.PRIVATE)} is present
  * on the class), and it is as if this constructor has been annotated with {@code @Builder} instead.
  * Note that this constructor is only generated if you haven't written any constructors and also haven't
  * added any explicit {@code @XArgsConstructor} annotations. In those cases, lombok will assume an all-args

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2015 The Project Lombok Authors.
+ * Copyright (C) 2009-2019 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -392,8 +392,8 @@ private static void patchCatchReparse(ScriptManager sm) {
 	private static void patchIdentifierEndReparse(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.wrapReturnValue()
 				.target(new MethodTarget("org.eclipse.jdt.core.dom.ASTConverter", "retrieveIdentifierEndPosition"))
-				.wrapMethod(new Hook("lombok.launch.PatchFixesHider$PatchFixes", "fixRetrieveIdentifierEndPosition", "int", "int", "int"))
-				.transplant().request(StackRequest.RETURN_VALUE, StackRequest.PARAM2).build());
+				.wrapMethod(new Hook("lombok.launch.PatchFixesHider$PatchFixes", "fixRetrieveIdentifierEndPosition", "int", "int", "int", "int"))
+				.transplant().request(StackRequest.RETURN_VALUE, StackRequest.PARAM1, StackRequest.PARAM2).build());
 	}
 	
 	private static void patchRetrieveEllipsisStartPosition(ScriptManager sm) {

File: src/core/lombok/core/AST.java
Patch:
@@ -229,7 +229,7 @@ protected FieldAccess[] fieldsOf(Class<?> c) {
 		
 		List<FieldAccess> fieldList = new ArrayList<FieldAccess>();
 		getFields(c, fieldList);
-		fieldsOfASTClasses.putIfAbsent(c, fieldList.toArray(new FieldAccess[fieldList.size()]));
+		fieldsOfASTClasses.putIfAbsent(c, fieldList.toArray(new FieldAccess[0]));
 		return fieldsOfASTClasses.get(c);
 	}
 	

File: src/core/lombok/eclipse/handlers/EclipseSingularsRecipes.java
Patch:
@@ -341,7 +341,7 @@ protected TypeReference[] createTypeArgs(int count, boolean addExtends, EclipseN
 			}
 			
 			if (arguments.isEmpty()) return null;
-			return arguments.toArray(new TypeReference[arguments.size()]);
+			return arguments.toArray(new TypeReference[0]);
 		}
 		
 		private static final char[] SIZE_TEXT = new char[] {'s', 'i', 'z', 'e'};

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -663,7 +663,7 @@ public MethodDeclaration generateBuildMethod(EclipseNode tdParent, boolean isSta
 		if (staticName == null) {
 			AllocationExpression allocationStatement = new AllocationExpression();
 			allocationStatement.type = copyType(out.returnType);
-			allocationStatement.arguments = args.isEmpty() ? null : args.toArray(new Expression[args.size()]);
+			allocationStatement.arguments = args.isEmpty() ? null : args.toArray(new Expression[0]);
 			statements.add(new ReturnStatement(allocationStatement, 0, 0));
 		} else {
 			MessageSend invoke = new MessageSend();
@@ -674,14 +674,14 @@ public MethodDeclaration generateBuildMethod(EclipseNode tdParent, boolean isSta
 				invoke.receiver = new QualifiedThisReference(new SingleTypeReference(type.up().getName().toCharArray(), 0) , 0, 0);
 			
 			invoke.typeArguments = typeParameterNames(((TypeDeclaration) type.get()).typeParameters);
-			invoke.arguments = args.isEmpty() ? null : args.toArray(new Expression[args.size()]);
+			invoke.arguments = args.isEmpty() ? null : args.toArray(new Expression[0]);
 			if (returnType instanceof SingleTypeReference && Arrays.equals(TypeConstants.VOID, ((SingleTypeReference) returnType).token)) {
 				statements.add(invoke);
 			} else {
 				statements.add(new ReturnStatement(invoke, 0, 0));
 			}
 		}
-		out.statements = statements.isEmpty() ? null : statements.toArray(new Statement[statements.size()]);
+		out.statements = statements.isEmpty() ? null : statements.toArray(new Statement[0]);
 		out.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);
 		return out;
 	}

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -391,7 +391,7 @@ public MethodDeclaration createHashCode(EclipseNode type, Collection<Included<Ec
 			setGeneratedBy(returnStatement, source);
 			statements.add(returnStatement);
 		}
-		method.statements = statements.toArray(new Statement[statements.size()]);
+		method.statements = statements.toArray(new Statement[0]);
 		return method;
 	}
 
@@ -738,7 +738,7 @@ public MethodDeclaration createEquals(EclipseNode type, Collection<Included<Ecli
 			setGeneratedBy(returnStatement, source);
 			statements.add(returnStatement);
 		}
-		method.statements = statements.toArray(new Statement[statements.size()]);
+		method.statements = statements.toArray(new Statement[0]);
 		return method;
 	}
 	

File: src/core/lombok/eclipse/handlers/HandleHelper.java
Patch:
@@ -103,7 +103,7 @@ private void setStatementsOfAstNode(ASTNode node, Statement[] statements) {
 		}
 		
 		Collections.sort(knownMethodNames);
-		final String[] knownMethodNames_ = knownMethodNames.toArray(new String[knownMethodNames.size()]);
+		final String[] knownMethodNames_ = knownMethodNames.toArray(new String[0]);
 		
 		final char[] helperName = new char[annotatedType_.name.length + 1];
 		final boolean[] helperUsed = new boolean[1];

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -149,7 +149,7 @@ void generateSingularMethod(boolean deprecate, TypeReference returnType, Stateme
 		thisDotFieldDotAdd.selector = getAddMethodName().toCharArray();
 		statements.add(thisDotFieldDotAdd);
 		if (returnStatement != null) statements.add(returnStatement);
-		md.statements = statements.toArray(new Statement[statements.size()]);
+		md.statements = statements.toArray(new Statement[0]);
 		md.arguments = new Argument[suffixes.size()];
 		for (int i = 0; i < suffixes.size(); i++) {
 			TypeReference tr = cloneParamType(i, data.getTypeArgs(), builderType);
@@ -183,7 +183,7 @@ void generatePluralMethod(boolean deprecate, TypeReference returnType, Statement
 		statements.add(thisDotFieldDotAddAll);
 		if (returnStatement != null) statements.add(returnStatement);
 		
-		md.statements = statements.toArray(new Statement[statements.size()]);
+		md.statements = statements.toArray(new Statement[0]);
 		
 		TypeReference paramType;
 		paramType = new QualifiedTypeReference(fromQualifiedName(getAddAllTypeName()), NULL_POSS);

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSetSingularizer.java
Patch:
@@ -140,7 +140,7 @@ void generateSingularMethod(boolean deprecate, TypeReference returnType, Stateme
 		statements.add(thisDotFieldDotAdd);
 		if (returnStatement != null) statements.add(returnStatement);
 		
-		md.statements = statements.toArray(new Statement[statements.size()]);
+		md.statements = statements.toArray(new Statement[0]);
 		TypeReference paramType = cloneParamType(0, data.getTypeArgs(), builderType);
 		Annotation[] typeUseAnns = getTypeUseAnnotations(paramType);
 		removeTypeUseAnnotations(paramType);
@@ -172,7 +172,7 @@ void generatePluralMethod(boolean deprecate, TypeReference returnType, Statement
 		statements.add(thisDotFieldDotAddAll);
 		if (returnStatement != null) statements.add(returnStatement);
 		
-		md.statements = statements.toArray(new Statement[statements.size()]);
+		md.statements = statements.toArray(new Statement[0]);
 		
 		TypeReference paramType = new QualifiedTypeReference(TypeConstants.JAVA_UTIL_COLLECTION, NULL_POSS);
 		paramType = addTypeArgs(1, true, builderType, paramType, data.getTypeArgs());

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSingularizer.java
Patch:
@@ -115,7 +115,7 @@ public class EclipseJavaUtilListSingularizer extends EclipseJavaUtilListSetSingu
 		}
 		
 		SwitchStatement switchStat = new SwitchStatement();
-		switchStat.statements = switchContents.toArray(new Statement[switchContents.size()]);
+		switchStat.statements = switchContents.toArray(new Statement[0]);
 		switchStat.expression = getSize(builderType, data.getPluralName(), true, builderVariable);
 		
 		TypeReference localShadowerType = new QualifiedTypeReference(Eclipse.fromQualifiedName(data.getTargetFqn()), NULL_POSS);

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilMapSingularizer.java
Patch:
@@ -215,7 +215,7 @@ private void generateSingularMethod(boolean deprecate, TypeReference returnType,
 		}
 		if (returnStatement != null) statements.add(returnStatement);
 		
-		md.statements = statements.toArray(new Statement[statements.size()]);
+		md.statements = statements.toArray(new Statement[0]);
 		TypeReference keyParamType = cloneParamType(0, data.getTypeArgs(), builderType);
 		TypeReference valueParamType = cloneParamType(1, data.getTypeArgs(), builderType);
 		Annotation[] typeUseAnnsKey = getTypeUseAnnotations(keyParamType);
@@ -286,7 +286,7 @@ private void generatePluralMethod(boolean deprecate, TypeReference returnType, S
 		statements.add(forEach);
 		if (returnStatement != null) statements.add(returnStatement);
 		
-		md.statements = statements.toArray(new Statement[statements.size()]);
+		md.statements = statements.toArray(new Statement[0]);
 		
 		TypeReference paramType = new QualifiedTypeReference(JAVA_UTIL_MAP, NULL_POSS);
 		paramType = addTypeArgs(2, true, builderType, paramType, data.getTypeArgs());

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilSingularizer.java
Patch:
@@ -147,7 +147,7 @@ protected List<Statement> createJavaUtilSetMapInitialCapacitySwitchStatements(Si
 		}
 		
 		SwitchStatement switchStat = new SwitchStatement();
-		switchStat.statements = switchContents.toArray(new Statement[switchContents.size()]);
+		switchStat.statements = switchContents.toArray(new Statement[0]);
 		switchStat.expression = getSize(builderType, keyName, true, builderVariable);
 		
 		TypeReference localShadowerType = new QualifiedTypeReference(fromQualifiedName(data.getTargetFqn()), NULL_POSS);

File: src/core/lombok/javac/handlers/HandleHelper.java
Patch:
@@ -102,7 +102,7 @@ private void setStatementsOfJcNode(JCTree tree, List<JCStatement> statements) {
 		}
 		
 		Collections.sort(knownMethodNames);
-		final String[] knownMethodNames_ = knownMethodNames.toArray(new String[knownMethodNames.size()]);
+		final String[] knownMethodNames_ = knownMethodNames.toArray(new String[0]);
 		
 		final Name helperName = annotationNode.toName("$" + annotatedType_.name);
 		final boolean[] helperUsed = new boolean[1];

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -426,7 +426,7 @@ private static String[] readArgsFromFile(String file) throws IOException {
 			throw new IOException("Unclosed ' in @ file");
 		}
 		
-		return x.toArray(new String[x.size()]);
+		return x.toArray(new String[0]);
 	}
 	
 	public static class InvalidFormatOptionException extends Exception {

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethodCompletionProposal.java
Patch:
@@ -78,7 +78,7 @@ public static IJavaCompletionProposal[] getJavaCompletionProposals(IJavaCompleti
 				}
 			}
 		}
-		return proposals.toArray(new IJavaCompletionProposal[proposals.size()]);
+		return proposals.toArray(new IJavaCompletionProposal[0]);
 	}
 	
 	

File: src/eclipseAgent/lombok/launch/PatchFixesHider.java
Patch:
@@ -551,7 +551,7 @@ public static RewriteEvent[] listRewriteHandleGeneratedMethods(RewriteEvent pare
 			// Since Eclipse doesn't honor the "insert at specified location" for already existing members,
 			// we'll just add them last
 			newChildren.addAll(modifiedChildren);
-			return newChildren.toArray(new RewriteEvent[newChildren.size()]);
+			return newChildren.toArray(new RewriteEvent[0]);
 		}
 		
 		public static int getTokenEndOffsetFixed(TokenScanner scanner, int token, int startOffset, Object domNode) throws CoreException {
@@ -570,7 +570,7 @@ public static IMethod[] removeGeneratedMethods(IMethod[] methods) throws Excepti
 			for (IMethod m : methods) {
 				if (m.getNameRange().getLength() > 0 && !m.getNameRange().equals(m.getSourceRange())) result.add(m);
 			}
-			return result.size() == methods.length ? methods : result.toArray(new IMethod[result.size()]);
+			return result.size() == methods.length ? methods : result.toArray(new IMethod[0]);
 		}
 		
 		public static SearchMatch[] removeGenerated(SearchMatch[] returnValue) {
@@ -591,7 +591,7 @@ public static SearchMatch[] removeGenerated(SearchMatch[] returnValue) {
 				}
 				result.add(searchResult);
 			}
-			return result.toArray(new SearchMatch[result.size()]);
+			return result.toArray(new SearchMatch[0]);
 		}
 		
 		public static SearchResultGroup[] createFakeSearchResult(SearchResultGroup[] returnValue,

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1462,7 +1462,7 @@ public static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {
 	 * variable name as message.
 	 */
 	public static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {
-		return generateNullCheck(maker, variable, (JCVariableDecl)variable.get(), source);
+		return generateNullCheck(maker, variable, (JCVariableDecl) variable.get(), source);
 	}
 
 	/**

File: src/delombok/lombok/delombok/PrettyPrinter.java
Patch:
@@ -258,6 +258,7 @@ private boolean suppress(JCTree tree) {
 				JCMethodInvocation inv = (JCMethodInvocation) expr;
 				if (!inv.typeargs.isEmpty() || !inv.args.isEmpty()) return false;
 				if (!(inv.meth instanceof JCIdent)) return false;
+				if (tree.pos != expr.pos) return false; // Explicit super call
 				return ((JCIdent) inv.meth).name.toString().equals("super");
 			}
 		}

File: test/transform/resource/after-delombok/DataPlain.java
Patch:
@@ -152,6 +152,7 @@ public java.lang.String toString() {
 final class Data4 extends java.util.Timer {
 	int x;
 	Data4() {
+		super();
 	}
 	@java.lang.SuppressWarnings("all")
 	public int getX() {

File: test/transform/resource/after-delombok/SneakyThrowsPlain.java
Patch:
@@ -1,5 +1,6 @@
 class SneakyThrowsPlain {
 	SneakyThrowsPlain() {
+		super();
 		try {
 			System.out.println("constructor");
 		} catch (final java.lang.Throwable $ex) {

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -83,7 +83,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * NB: If you enable this option, findbugs must be on the source or classpath, or you'll get errors that the type {@code SuppressFBWarnings} cannot be found.
 	 */
-	public static final ConfigurationKey<Boolean> ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.extern.findbugs.addSuppressFBWarnings", "Generate @edu.umd.cs.findbugs.annotations.SuppressFBWArnings on all generated code (default: false).") {};
+	public static final ConfigurationKey<Boolean> ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.extern.findbugs.addSuppressFBWarnings", "Generate @edu.umd.cs.findbugs.annotations.SuppressFBWarnings on all generated code (default: false).") {};
 	
 	// ----- *ArgsConstructor -----
 	
@@ -138,7 +138,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * If {@code true} (default), @Data and @Value will also generate a private no-args constructor, if there isn't already one, setting all fields to their default values. 
 	 */
-	public static final ConfigurationKey<Boolean> NO_ARGS_CONSTRUCTOR_EXTRA_PRIVATE = new ConfigurationKey<Boolean>("lombok.noArgsConstructor.extraPrivate", "Generate a private no-ars constructor for @Data and @Value (default: true).") {};
+	public static final ConfigurationKey<Boolean> NO_ARGS_CONSTRUCTOR_EXTRA_PRIVATE = new ConfigurationKey<Boolean>("lombok.noArgsConstructor.extraPrivate", "Generate a private no-args constructor for @Data and @Value (default: true).") {};
 	
 	/**
 	 * lombok configuration: {@code lombok.requiredArgsConstructor.flagUsage} = {@code WARNING} | {@code ERROR}.

File: test/transform/resource/after-delombok/ConflictingStaticConstructorNames.java
Patch:
@@ -15,7 +15,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/DataPlain.java
Patch:
@@ -210,7 +210,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 	@java.lang.Override
@@ -233,7 +233,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/EqualsAndHashCode.java
Patch:
@@ -92,7 +92,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 }
@@ -114,7 +114,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = super.hashCode();
+		final int result = super.hashCode();
 		return result;
 	}
 }

File: test/transform/resource/after-delombok/EqualsAndHashCodeConfigKeys1.java
Patch:
@@ -15,7 +15,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 }

File: test/transform/resource/after-delombok/EqualsAndHashCodeConfigKeys2.java
Patch:
@@ -15,7 +15,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 }
@@ -36,7 +36,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 }

File: test/transform/resource/after-delombok/EqualsAndHashCodeExplicitInclude.java
Patch:
@@ -16,7 +16,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/EqualsAndHashCodeNestedShadow.java
Patch:
@@ -19,7 +19,7 @@ protected boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				int result = 1;
+				final int result = 1;
 				return result;
 			}
 		}
@@ -42,7 +42,7 @@ protected boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				int result = 1;
+				final int result = 1;
 				return result;
 			}
 		}

File: test/transform/resource/after-delombok/PrivateNoArgsConstructor.java
Patch:
@@ -224,7 +224,7 @@ protected boolean canEqual(final java.lang.Object other) {
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
 		public int hashCode() {
-			int result = 1;
+			final int result = 1;
 			return result;
 		}
 		@java.lang.Override

File: test/transform/resource/after-delombok/ValueCallSuper.java
Patch:
@@ -21,7 +21,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = super.hashCode();
+		final int result = super.hashCode();
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/ValueStaticField.java
Patch:
@@ -14,7 +14,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		int result = 1;
+		final int result = 1;
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-ecj/ConflictingStaticConstructorNames.java
Patch:
@@ -13,7 +13,7 @@
     return (other instanceof ConflictingStaticConstructorNames);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/DataPlain.java
Patch:
@@ -188,7 +188,7 @@
     return (other instanceof Data5);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
@@ -207,7 +207,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/EqualsAndHashCode.java
Patch:
@@ -105,7 +105,7 @@
     return (other instanceof EqualsAndHashCode3);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
 }
@@ -129,7 +129,7 @@
     return (other instanceof EqualsAndHashCode4);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = super.hashCode();
+    final int result = super.hashCode();
     return result;
   }
 }

File: test/transform/resource/after-ecj/EqualsAndHashCodeConfigKeys1.java
Patch:
@@ -16,7 +16,7 @@
     return (other instanceof EqualsAndHashCodeConfigKeys1Parent);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
 }

File: test/transform/resource/after-ecj/EqualsAndHashCodeConfigKeys2.java
Patch:
@@ -16,7 +16,7 @@
     return (other instanceof EqualsAndHashCodeConfigKeys2Object);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
 }
@@ -38,7 +38,7 @@
     return (other instanceof EqualsAndHashCodeConfigKeys2Parent);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
 }

File: test/transform/resource/after-ecj/EqualsAndHashCodeExplicitInclude.java
Patch:
@@ -17,7 +17,7 @@
     return (other instanceof EqualsAndHashCodeExplicitInclude);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/EqualsAndHashCodeNestedShadow.java
Patch:
@@ -20,7 +20,7 @@ public Foo() {
         return (other instanceof EqualsAndHashCodeNestedShadow.Bar.Foo);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        int result = 1;
+        final int result = 1;
         return result;
       }
     }
@@ -47,7 +47,7 @@ public Foo() {
         return (other instanceof EqualsAndHashCodeNestedShadow.Baz.Foo);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        int result = 1;
+        final int result = 1;
         return result;
       }
     }

File: test/transform/resource/after-ecj/PrivateNoArgsConstructor.java
Patch:
@@ -203,7 +203,7 @@ private Base() {
       return (other instanceof PrivateNoArgsConstructor.PrivateNoArgsConstructorNoFields);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-      int result = 1;
+      final int result = 1;
       return result;
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/ValueCallSuper.java
Patch:
@@ -20,7 +20,7 @@ class ValueParent {
     return (other instanceof ValueCallSuper);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = super.hashCode();
+    final int result = super.hashCode();
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/ValueStaticField.java
Patch:
@@ -12,7 +12,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    int result = 1;
+    final int result = 1;
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: src/core/lombok/core/LombokNode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2018 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -279,6 +279,7 @@ public boolean isStructurallySignificant() {
 	public abstract boolean isStatic();
 	public abstract boolean isTransient();
 	public abstract boolean isEnumMember();
+	public abstract boolean isEnumType();
 	
 	public abstract int countMethodParameters();
 	

File: test/transform/resource/after-delombok/DataOnEnum.java
Patch:
@@ -8,7 +8,7 @@ public String getSomeField() {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public java.lang.String toString() {
-		return "DataOnEnum(someField=" + this.getSomeField() + ")";
+		return "DataOnEnum." + this.name() + "(someField=" + this.getSomeField() + ")";
 	}
 	@java.lang.SuppressWarnings("all")
 	private DataOnEnum(final String someField) {

File: test/transform/resource/after-ecj/DataOnEnum.java
Patch:
@@ -7,7 +7,7 @@
     return this.someField;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-    return (("DataOnEnum(someField=" + this.getSomeField()) + ")");
+    return (((("DataOnEnum." + this.name()) + "(someField=") + this.getSomeField()) + ")");
   }
   private @java.lang.SuppressWarnings("all") DataOnEnum(final String someField) {
     super();

File: src/launch/lombok/launch/Main.java
Patch:
@@ -25,9 +25,8 @@
 import java.util.Arrays;
 
 class Main {
-	
 	private static ShadowClassLoader classLoader;
-
+	
 	static synchronized ClassLoader getShadowClassLoader() {
 		if (classLoader == null) {
 			classLoader = new ShadowClassLoader(Main.class.getClassLoader(), "lombok", null, Arrays.<String>asList(), Arrays.asList("lombok.patcher.Symbols"));

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -92,6 +92,7 @@ private void generateClearMethod(boolean deprecate, JavacTreeMaker maker, JCExpr
 		JCBlock body = maker.Block(0, statements);
 		Name methodName = builderType.toName(HandlerUtil.buildAccessorName("clear", data.getPluralName().toString()));
 		JCMethodDecl method = maker.MethodDef(mods, methodName, returnType, typeParams, params, thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	
@@ -134,6 +135,7 @@ void generateSingularMethod(boolean deprecate, JavacTreeMaker maker, JCExpressio
 		}
 		
 		JCMethodDecl method = maker.MethodDef(mods, methodName, returnType, typeParams, params.toList(), thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	
@@ -161,6 +163,7 @@ protected void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCE
 		paramType = addTypeArgs(getTypeArgumentsCount(), true, builderType, paramType, data.getTypeArgs(), source);
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(paramFlags), data.getPluralName(), paramType, null);
 		JCMethodDecl method = maker.MethodDef(mods, methodName, returnType, typeParams, List.of(param), thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSetSingularizer.java
Patch:
@@ -107,6 +107,7 @@ private void generateClearMethod(boolean deprecate, JavacTreeMaker maker, JCExpr
 		JCBlock body = maker.Block(0, statements);
 		Name methodName = builderType.toName(HandlerUtil.buildAccessorName("clear", data.getPluralName().toString()));
 		JCMethodDecl method = maker.MethodDef(mods, methodName, returnType, typeParams, params, thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	
@@ -130,6 +131,7 @@ void generateSingularMethod(boolean deprecate, JavacTreeMaker maker, JCExpressio
 		JCModifiers paramMods = typeUseAnns.isEmpty() ? maker.Modifiers(paramFlags) : maker.Modifiers(paramFlags, typeUseAnns);
 		JCVariableDecl param = maker.VarDef(paramMods, data.getSingularName(), paramType, null);
 		JCMethodDecl method = maker.MethodDef(mods, name, returnType, typeParams, List.of(param), thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	
@@ -151,6 +153,7 @@ void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCExpression
 		paramType = addTypeArgs(1, true, builderType, paramType, data.getTypeArgs(), source);
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(paramFlags), data.getPluralName(), paramType, null);
 		JCMethodDecl method = maker.MethodDef(mods, name, returnType, typeParams, List.of(param), thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 }

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilMapSingularizer.java
Patch:
@@ -136,6 +136,7 @@ private void generateClearMethod(boolean deprecate, JavacTreeMaker maker, JCExpr
 		JCBlock body = maker.Block(0, statements);
 		Name methodName = builderType.toName(HandlerUtil.buildAccessorName("clear", data.getPluralName().toString()));
 		JCMethodDecl method = maker.MethodDef(mods, methodName, returnType, typeParams, params, thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	
@@ -175,6 +176,7 @@ private void generateSingularMethod(boolean deprecate, JavacTreeMaker maker, JCE
 		JCVariableDecl paramKey = maker.VarDef(paramModsKey, keyName, paramTypeKey, null);
 		JCVariableDecl paramValue = maker.VarDef(paramModsValue, valueName, paramTypeValue, null);
 		JCMethodDecl method = maker.MethodDef(mods, name, returnType, typeParams, List.of(paramKey, paramValue), thrown, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 
@@ -207,6 +209,7 @@ private void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCExp
 		paramType = addTypeArgs(2, true, builderType, paramType, data.getTypeArgs(), source);
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(paramFlags), data.getPluralName(), paramType, null);
 		JCMethodDecl method = maker.MethodDef(mods, name, returnType, typeParams, List.of(param), jceBlank, body, null);
+		recursiveSetGeneratedBy(method, source, builderType.getContext());
 		injectMethod(builderType, method);
 	}
 	

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -86,7 +86,7 @@ public static <T> BuilderWithToBuilderBuilder<T> builder() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderWithToBuilderBuilder<T> toBuilder() {
-		final BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this));
+		final BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.<T>rrr(this));
 		if (this.bars != null) builder.bars(this.bars);
 		return builder;
 	}

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -74,7 +74,7 @@ public static <K>K rrr(BuilderWithToBuilder<K> x) {
     return new BuilderWithToBuilderBuilder<T>();
   }
   public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> toBuilder() {
-    final BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this));
+    final BuilderWithToBuilderBuilder<T> builder = new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.<T>rrr(this));
     if ((this.bars != null))
         builder.bars(this.bars);
     return builder;

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -508,7 +508,7 @@ private JCMethodDecl generateToBuilderMethod(String toBuilderMethodName, String
 				if (bfd.obtainVia.isStatic()) {
 					for (int i = 0; i < tgt.length; i++) {
 						JCExpression c = maker.Select(maker.Ident(type.toName(type.getName())), type.toName(bfd.obtainVia.method()));
-						tgt[i] = maker.Apply(List.<JCExpression>nil(), c, List.<JCExpression>of(maker.Ident(type.toName("this"))));
+						tgt[i] = maker.Apply(typeParameterNames(maker, typeParams), c, List.<JCExpression>of(maker.Ident(type.toName("this"))));
 					}
 				} else {
 					for (int i = 0; i < tgt.length; i++) {

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -169,13 +169,13 @@ protected void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCE
 		List<JCExpression> jceBlank = List.nil();
 		
 		JCExpression varType = chainDotsString(builderType, data.getTargetFqn());
-		int agrumentsCount = getTypeArgumentsCount();
-		varType = addTypeArgs(agrumentsCount, false, builderType, varType, data.getTypeArgs(), source);
+		int argumentsCount = getTypeArgumentsCount();
+		varType = addTypeArgs(argumentsCount, false, builderType, varType, data.getTypeArgs(), source);
 		
 		JCExpression empty; {
 			//ImmutableX.of()
 			JCExpression emptyMethod = chainDots(builderType, "com", "google", "common", "collect", getSimpleTargetTypeName(data), "of");
-			List<JCExpression> invokeTypeArgs = createTypeArgs(agrumentsCount, false, builderType, data.getTypeArgs(), source);
+			List<JCExpression> invokeTypeArgs = createTypeArgs(argumentsCount, false, builderType, data.getTypeArgs(), source);
 			empty = maker.Apply(invokeTypeArgs, emptyMethod, jceBlank);
 		}
 		

File: src/delombok/lombok/delombok/ant/DelombokTaskImpl.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2015 The Project Lombok Authors.
+ * Copyright (C) 2009-2018 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -40,6 +40,7 @@ public class DelombokTaskImpl {
 	private File fromDir, toDir;
 	private Path classpath;
 	private Path sourcepath;
+	private Path modulepath;
 	private boolean verbose;
 	private String encoding;
 	private Path path;
@@ -60,6 +61,7 @@ public void execute(Location location) throws BuildException {
 		
 		if (classpath != null) delombok.setClasspath(classpath.toString());
 		if (sourcepath != null) delombok.setSourcepath(sourcepath.toString());
+		if (modulepath != null) delombok.setModulepath(modulepath.toString());
 		
 		try {
 			delombok.setFormatPreferences(Delombok.formatOptionsToMap(formatOptions));

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -484,6 +484,7 @@ private static List<EclipseNode> fieldsNeedingExplicitDefaults(EclipseNode type,
 		for (EclipseNode node : type.down()) {
 			if (node.getKind() != Kind.FIELD) continue top;
 			FieldDeclaration fd = (FieldDeclaration) node.get();
+			if (fd.initialization != null) continue top;
 			if ((fd.modifiers & ClassFileConstants.AccFinal) == 0) continue top;
 			if ((fd.modifiers & ClassFileConstants.AccStatic) != 0) continue top;
 			for (EclipseNode ftp : fieldsToParam) if (node == ftp) continue top;

File: test/transform/resource/after-delombok/NoArgsConstructorForce.java
Patch:
@@ -3,6 +3,7 @@ public class NoArgsConstructorForce {
 	private final int[] i;
 	private final Object[] o;
 	private final java.util.List<?>[] fullQualifiedList;
+	private final String alreadyInitialized = "yes";
 	
 	@java.lang.SuppressWarnings("all")
 	public NoArgsConstructorForce() {

File: test/transform/resource/after-ecj/NoArgsConstructorForce.java
Patch:
@@ -3,6 +3,7 @@
   private final int[] i;
   private final Object[] o;
   private final java.util.List<?>[] fullQualifiedList;
+  private final String alreadyInitialized = "yes";
   public @java.lang.SuppressWarnings("all") NoArgsConstructorForce() {
     super();
     this.i = null;

File: test/transform/resource/before/NoArgsConstructorForce.java
Patch:
@@ -5,4 +5,5 @@ public class NoArgsConstructorForce {
 	private final int[] i;
 	private final Object[] o;
 	private final java.util.List<?>[] fullQualifiedList;
+	private final String alreadyInitialized = "yes";
 }
\ No newline at end of file

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -445,6 +445,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 			cleanDecl.declarationSourceEnd = -1;
 			cleanDecl.modifiers = ClassFileConstants.AccPrivate;
 			cleanDecl.type = TypeReference.baseTypeReference(TypeIds.T_boolean, 0);
+			cleanDecl.traverse(new SetGeneratedByVisitor(ast), (MethodScope) null);
 			injectFieldAndMarkGenerated(builderType, cleanDecl);
 		}
 		

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -94,6 +94,7 @@ protected char[][] makeGuavaTypeName(String simpleName, boolean addBuilder) {
 		buildField.modifiers = ClassFileConstants.AccPrivate;
 		buildField.declarationSourceEnd = -1;
 		buildField.type = type;
+		
 		data.setGeneratedByRecursive(buildField);
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
@@ -117,6 +118,7 @@ void generateClearMethod(boolean deprecate, TypeReference returnType, Statement
 		md.returnType = returnType;
 		md.annotations = deprecate ? new Annotation[] { generateDeprecatedAnnotation(data.getSource()) } : null;
 		
+		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}
 	

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilListSetSingularizer.java
Patch:
@@ -85,6 +85,7 @@ abstract class EclipseJavaUtilListSetSingularizer extends EclipseJavaUtilSingula
 		buildField.modifiers = ClassFileConstants.AccPrivate;
 		buildField.declarationSourceEnd = -1;
 		buildField.type = type;
+		
 		data.setGeneratedByRecursive(buildField);
 		return Collections.singletonList(injectFieldAndMarkGenerated(builderType, buildField));
 	}
@@ -117,6 +118,8 @@ private void generateClearMethod(boolean deprecate, TypeReference returnType, St
 		md.statements = returnStatement != null ? new Statement[] {clearStatement, returnStatement} : new Statement[] {clearStatement};
 		md.returnType = returnType;
 		md.annotations = deprecate ? new Annotation[] { generateDeprecatedAnnotation(data.getSource()) } : null;
+		
+		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}
 	
@@ -149,7 +152,6 @@ void generateSingularMethod(boolean deprecate, TypeReference returnType, Stateme
 		md.annotations = deprecate ? new Annotation[] { generateDeprecatedAnnotation(data.getSource()) } : null;
 		
 		data.setGeneratedByRecursive(md);
-		
 		HandleNonNull.INSTANCE.fix(injectMethod(builderType, md));
 	}
 	

File: src/core/lombok/eclipse/handlers/singulars/EclipseJavaUtilMapSingularizer.java
Patch:
@@ -127,6 +127,7 @@ public class EclipseJavaUtilMapSingularizer extends EclipseJavaUtilSingularizer
 			buildValueField.declarationSourceEnd = -1;
 			buildValueField.type = type;
 		}
+		
 		data.setGeneratedByRecursive(buildKeyField);
 		data.setGeneratedByRecursive(buildValueField);
 		EclipseNode keyFieldNode = injectFieldAndMarkGenerated(builderType, buildKeyField);
@@ -174,6 +175,7 @@ private void generateClearMethod(boolean deprecate, TypeReference returnType, St
 		md.returnType = returnType;
 		md.annotations = deprecate ? new Annotation[] { generateDeprecatedAnnotation(data.getSource()) } : null;
 		
+		data.setGeneratedByRecursive(md);
 		injectMethod(builderType, md);
 	}
 	

File: test/core/src/lombok/CompilerMessageMatcher.java
Patch:
@@ -67,7 +67,8 @@ public static CompilerMessageMatcher asCompilerMessageMatcher(CompilerMessage me
 	public boolean matches(CompilerMessage message) {
 		outer:
 		for (int i = 0; i < lineNumbers.size(); i++) {
-			if (message.getLine() != lineNumbers.get(i)) continue;
+			//Allow an off-by-1 in line numbers; when running tests that sometimes happens for as yet unknown reasons.
+			if (message.getLine() != lineNumbers.get(i) && message.getLine() -1 != lineNumbers.get(i)) continue;
 			for (String token : messages.get(i)) {
 				if (!message.getMessage().contains(token)) continue outer;
 			}

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNull.java
Patch:
@@ -58,6 +58,8 @@ public static BuilderSingularToBuilderWithNullBuilder builder() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderSingularToBuilderWithNullBuilder toBuilder() {
-		return new BuilderSingularToBuilderWithNullBuilder().elems(this.elems == null ? java.util.Collections.<String>emptyList() : this.elems);
+		final BuilderSingularToBuilderWithNullBuilder builder = new BuilderSingularToBuilderWithNullBuilder();
+		if (this.elems != null) builder.elems(this.elems);
+		return builder;
 	}
 }

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -559,7 +559,7 @@ private MethodDeclaration generateToBuilderMethod(String methodName, String buil
 				MessageSend emptyList = new MessageSend();
 				emptyList.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.UTIL, "Collections".toCharArray());
 				emptyList.selector = EMPTY_LIST;
-				emptyList.typeArguments = copyTypes(bfd.singularData.getTypeArgs().toArray(new TypeReference[0]));
+				emptyList.typeArguments = bfd.singularData.getSingularizer().createTypeArgs(bfd.singularData.getTypeArgs().size(), false, type, bfd.singularData.getTypeArgs());
 				ms.arguments = new Expression[] {new ConditionalExpression(ifNull, emptyList, tgt[1])};
 			}
 			ms.receiver = receiver;

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -506,7 +506,7 @@ private JCMethodDecl generateToBuilderMethod(String toBuilderMethodName, String
 				if (bfd.obtainVia.isStatic()) {
 					for (int i = 0; i < tgt.length; i++) {
 						JCExpression c = maker.Select(maker.Ident(type.toName(type.getName())), type.toName(bfd.obtainVia.method()));
-						tgt[i] = maker.Apply(List.<JCExpression>nil(), c, List.<JCExpression>of(maker.Ident(type.toName("this"))));
+						tgt[i] = maker.Apply(typeParameterNames(maker, typeParams), c, List.<JCExpression>of(maker.Ident(type.toName("this"))));
 					}
 				} else {
 					for (int i = 0; i < tgt.length; i++) {

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -86,7 +86,7 @@ public static <T> BuilderWithToBuilderBuilder<T> builder() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderWithToBuilderBuilder<T> toBuilder() {
-		return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(this.bars == null ? java.util.Collections.<T>emptyList() : this.bars);
+		return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.<T>rrr(this)).bars(this.bars == null ? java.util.Collections.<T>emptyList() : this.bars);
 	}
 }
 class ConstructorWithToBuilder<T> {

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -74,7 +74,7 @@ public static <K>K rrr(BuilderWithToBuilder<K> x) {
     return new BuilderWithToBuilderBuilder<T>();
   }
   public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> toBuilder() {
-    return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(((this.bars == null) ? java.util.Collections.<T>emptyList() : this.bars));
+    return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.<T>rrr(this)).bars(((this.bars == null) ? java.util.Collections.<T>emptyList() : this.bars));
   }
 }
 @lombok.experimental.Accessors(prefix = "m") class ConstructorWithToBuilder<T> {

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -521,7 +521,8 @@ private JCMethodDecl generateToBuilderMethod(String toBuilderMethodName, String
 				arg = tgt[0];
 			} else {
 				JCExpression eqNull = maker.Binary(CTC_EQUAL, tgt[0], maker.Literal(CTC_BOT, null));
-				List<JCExpression> tas = cloneTypes(maker, bfd.singularData.getTypeArgs(), ast, type.getContext());
+				// Use the singularizer to create the type args (will remove possible wildcards on the type).
+				List<JCExpression> tas = bfd.singularData.getSingularizer().createTypeArgs(bfd.singularData.getTypeArgs().size(), false, type, bfd.singularData.getTypeArgs(), type.get());
 				JCExpression emptyList = maker.Apply(tas, chainDots(type, "java", "util", "Collections", "emptyList"), List.<JCExpression>nil());
 				arg = maker.Conditional(eqNull, emptyList, tgt[1]);
 			}

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -169,13 +169,13 @@ protected void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCE
 		List<JCExpression> jceBlank = List.nil();
 		
 		JCExpression varType = chainDotsString(builderType, data.getTargetFqn());
-		int agrumentsCount = getTypeArgumentsCount();
-		varType = addTypeArgs(agrumentsCount, false, builderType, varType, data.getTypeArgs(), source);
+		int argumentsCount = getTypeArgumentsCount();
+		varType = addTypeArgs(argumentsCount, false, builderType, varType, data.getTypeArgs(), source);
 		
 		JCExpression empty; {
 			//ImmutableX.of()
 			JCExpression emptyMethod = chainDots(builderType, "com", "google", "common", "collect", getSimpleTargetTypeName(data), "of");
-			List<JCExpression> invokeTypeArgs = createTypeArgs(agrumentsCount, false, builderType, data.getTypeArgs(), source);
+			List<JCExpression> invokeTypeArgs = createTypeArgs(argumentsCount, false, builderType, data.getTypeArgs(), source);
 			empty = maker.Apply(invokeTypeArgs, emptyMethod, jceBlank);
 		}
 		

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -527,6 +527,7 @@ public boolean delombok() throws IOException {
 			}
 			String[] argv = argsList.toArray(new String[0]);
 			args.init("javac", argv);
+			options.put("diags.legacy", "TRUE");
 		}
 		
 		CommentCatcher catcher = CommentCatcher.create(context);

File: test/transform/resource/after-ecj/SuperBuilderBasicToBuilder.java
Patch:
@@ -39,13 +39,13 @@ public ParentBuilder() {
         this.obtainViaStaticMethod = obtainViaStaticMethod;
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B item(String item) {
+      public @java.lang.SuppressWarnings("all") B item(final String item) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.add(item);
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+      public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenericsAndToBuilder.java
Patch:
@@ -21,13 +21,13 @@ public ParentBuilder() {
         this.field1 = field1;
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B item(String item) {
+      public @java.lang.SuppressWarnings("all") B item(final String item) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.add(item);
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+      public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -659,7 +659,7 @@ private MethodDeclaration generateStaticFillValuesMethod(EclipseNode tdParent, S
 		TypeReference[] wildcards = new TypeReference[] {new Wildcard(Wildcard.UNBOUND), new Wildcard(Wildcard.UNBOUND)};
 		TypeReference builderType = new ParameterizedSingleTypeReference(builderClassName.toCharArray(), mergeToTypeReferences(typeParams, wildcards), 0, 0);
 		Argument builderArgument = new Argument(BUILDER_VARIABLE_NAME, 0, builderType, Modifier.FINAL);
-		TypeReference parentArgument = new ParameterizedSingleTypeReference(tdParent.getName().toCharArray(), mergeToTypeReferences(typeParams, new TypeReference[0]), 0, 0);
+		TypeReference parentArgument = createTypeReferenceWithTypeParameters(tdParent.getName(), typeParams);
 		out.arguments = new Argument[] {new Argument(INSTANCE_VARIABLE_NAME, 0, parentArgument, Modifier.FINAL), builderArgument};
 
 		// Add type params if there are any.

File: test/transform/resource/after-ecj/BuilderDefaultsWarnings.java
Patch:
@@ -16,13 +16,13 @@
       this.z = z;
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderDefaultsWarningsBuilder item(String item) {
+    public @java.lang.SuppressWarnings("all") BuilderDefaultsWarningsBuilder item(final String item) {
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.add(item);
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderDefaultsWarningsBuilder items(java.util.Collection<? extends String> items) {
+    public @java.lang.SuppressWarnings("all") BuilderDefaultsWarningsBuilder items(final java.util.Collection<? extends String> items) {
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.addAll(items);

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNull.java
Patch:
@@ -5,13 +5,13 @@
     @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullBuilder elem(String elem) {
+    public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullBuilder elem(final String elem) {
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.add(elem);
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullBuilder elems(java.util.Collection<? extends String> elems) {
+    public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullBuilder elems(final java.util.Collection<? extends String> elems) {
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderSingularWithPrefixes.java
Patch:
@@ -5,13 +5,13 @@
     @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesBuilder() {
       super();
     }
-    public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesBuilder elem(String elem) {
+    public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesBuilder elem(final String elem) {
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.add(elem);
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesBuilder elems(java.util.Collection<? extends String> elems) {
+    public @java.lang.SuppressWarnings("all") BuilderSingularWithPrefixesBuilder elems(final java.util.Collection<? extends String> elems) {
       if ((this.elems == null))
           this.elems = new java.util.ArrayList<String>();
       this.elems.addAll(elems);

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -21,13 +21,13 @@
       this.foo = foo;
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> bar(T bar) {
+    public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> bar(final T bar) {
       if ((this.bars == null))
           this.bars = new java.util.ArrayList<T>();
       this.bars.add(bar);
       return this;
     }
-    public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> bars(java.util.Collection<? extends T> bars) {
+    public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> bars(final java.util.Collection<? extends T> bars) {
       if ((this.bars == null))
           this.bars = new java.util.ArrayList<T>();
       this.bars.addAll(bars);

File: test/transform/resource/after-ecj/SuperBuilderBasic.java
Patch:
@@ -13,13 +13,13 @@ public ParentBuilder() {
         this.field1 = field1;
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B item(String item) {
+      public @java.lang.SuppressWarnings("all") B item(final String item) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.add(item);
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+      public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -13,13 +13,13 @@ public ParentBuilder() {
         this.field1 = field1;
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B item(String item) {
+      public @java.lang.SuppressWarnings("all") B item(final String item) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.add(item);
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+      public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics.java
Patch:
@@ -13,13 +13,13 @@ public ParentBuilder() {
         this.field1 = field1;
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B item(String item) {
+      public @java.lang.SuppressWarnings("all") B item(final String item) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.add(item);
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+      public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics2.java
Patch:
@@ -13,13 +13,13 @@ public ParentBuilder() {
         this.field1 = field1;
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B item(String item) {
+      public @java.lang.SuppressWarnings("all") B item(final String item) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.add(item);
         return self();
       }
-      public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+      public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
         if ((this.items == null))
             this.items = new java.util.ArrayList<String>();
         this.items.addAll(items);

File: test/transform/resource/after-ecj/SuperBuilderWithNonNull.java
Patch:
@@ -9,7 +9,7 @@ public ParentBuilder() {
       }
       protected abstract @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.SuppressWarnings("all") C build();
-      public @java.lang.SuppressWarnings("all") B nonNullParentField(final String nonNullParentField) {
+      public @java.lang.SuppressWarnings("all") B nonNullParentField(final @lombok.NonNull String nonNullParentField) {
         this.nonNullParentField = nonNullParentField;
         nonNullParentField$set = true;
         return self();
@@ -56,7 +56,7 @@ public ChildBuilder() {
       }
       protected abstract @java.lang.Override @java.lang.SuppressWarnings("all") B self();
       public abstract @java.lang.Override @java.lang.SuppressWarnings("all") C build();
-      public @java.lang.SuppressWarnings("all") B nonNullChildField(final String nonNullChildField) {
+      public @java.lang.SuppressWarnings("all") B nonNullChildField(final @lombok.NonNull String nonNullChildField) {
         this.nonNullChildField = nonNullChildField;
         return self();
       }

File: test/transform/resource/after-ecj/SuperBuilderWithPrefixes.java
Patch:
@@ -16,13 +16,13 @@ public SuperBuilderWithPrefixesBuilder() {
       this.otherField = otherField;
       return self();
     }
-    public @java.lang.SuppressWarnings("all") B item(String item) {
+    public @java.lang.SuppressWarnings("all") B item(final String item) {
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.add(item);
       return self();
     }
-    public @java.lang.SuppressWarnings("all") B items(java.util.Collection<? extends String> items) {
+    public @java.lang.SuppressWarnings("all") B items(final java.util.Collection<? extends String> items) {
       if ((this.items == null))
           this.items = new java.util.ArrayList<String>();
       this.items.addAll(items);

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -646,9 +646,9 @@ private MessageSend createSetterCallWithInstanceValue(BuilderFieldData bfd, fina
 				boolean obtainIsStatic = bfd.obtainVia.isStatic();
 				for (int i = 0; i < tgt.length; i++) {
 					MessageSend obtainExpr = new MessageSend();
-					obtainExpr.receiver = obtainIsStatic ? new SingleNameReference(type.getName().toCharArray(), 0) : new ThisReference(0, 0);
+					obtainExpr.receiver = obtainIsStatic ? new SingleNameReference(type.getName().toCharArray(), 0) : new SingleNameReference(instanceVariableName.toCharArray(), 0);
 					obtainExpr.selector = obtainName.toCharArray();
-					if (obtainIsStatic) obtainExpr.arguments = new Expression[] {new ThisReference(0, 0)};
+					if (obtainIsStatic) obtainExpr.arguments = new Expression[] {new SingleNameReference(instanceVariableName.toCharArray(), 0)};
 					tgt[i] = obtainExpr;
 				}
 			}

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -27,6 +27,7 @@
 import lombok.core.configuration.ConfigurationKey;
 import lombok.core.configuration.FlagUsageType;
 import lombok.core.configuration.NullCheckExceptionType;
+import lombok.core.configuration.TypeName;
 
 /**
  * A container class containing all lombok configuration keys that do not belong to a specific annotation.
@@ -565,10 +566,10 @@ private ConfigurationKeys() {}
 	public static final ConfigurationKey<Boolean> STOP_BUBBLING = new ConfigurationKey<Boolean>("config.stopBubbling", "Tell the configuration system it should stop looking for other configuration files (default: false).") {};
 
 	/**
-	 * lombok configuration: {@code lombok.copyableAnnotations} += &lt;String: fully-qualified annotation class name&gt;.
+	 * lombok configuration: {@code lombok.copyableAnnotations} += &lt;TypeName: fully-qualified annotation class name&gt;.
 	 *
 	 * Copy these annotations to getters, setters, withers, builder-setters, etc.
 	 */
-	public static final ConfigurationKey<List<String>> COPYABLE_ANNOTATIONS = new ConfigurationKey<List<String>>("lombok.copyableAnnotations", "Copy these annotations to getters, setters, withers, builder-setters, etc.") {};
+	public static final ConfigurationKey<List<TypeName>> COPYABLE_ANNOTATIONS = new ConfigurationKey<List<TypeName>>("lombok.copyableAnnotations", "Copy these annotations to getters, setters, withers, builder-setters, etc.") {};
 
 }

File: src/core/lombok/NonNull.java
Patch:
@@ -41,7 +41,7 @@
  * this annotation will <strong>be deleted</strong> from the lombok package. If the need to update an import statement scares
  * you, you should use your own annotation named {@code @NonNull} instead of this one.
  */
-@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})
+@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.TYPE_USE})
 @Retention(RetentionPolicy.CLASS)
 @Documented
 public @interface NonNull {

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -431,8 +431,7 @@ private void generateBuilderBasedConstructor(JavacNode typeNode, List<JCTypePara
 				statements.append(assign);
 			}
 			
-			List<JCAnnotation> nonNulls = findAnnotations(bfd.originalFieldNode, NON_NULL_PATTERN);
-			if (!nonNulls.isEmpty()) {
+			if (hasNonNullAnnotations(bfd.originalFieldNode)) {
 				JCStatement nullCheck = generateNullCheck(maker, bfd.originalFieldNode, source);
 				if (nullCheck != null) statements.append(nullCheck);
 			}

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -565,10 +565,10 @@ private ConfigurationKeys() {}
 	public static final ConfigurationKey<Boolean> STOP_BUBBLING = new ConfigurationKey<Boolean>("config.stopBubbling", "Tell the configuration system it should stop looking for other configuration files (default: false).") {};
 
 	/**
-	 * lombok configuration: {@code lombok.copyAnnotations} += &lt;String: fully-qualified annotation class name&gt;.
+	 * lombok configuration: {@code lombok.copyableAnnotations} += &lt;String: fully-qualified annotation class name&gt;.
 	 *
-	 * Copy these annotations to getters, setters, etc.
+	 * Copy these annotations to getters, setters, withers, builder-setters, etc.
 	 */
-	public static final ConfigurationKey<List<String>> COPY_ANNOTATIONS = new ConfigurationKey<List<String>>("lombok.copyAnnotations", "Copy these annotations to getters, setters, etc.") {};
+	public static final ConfigurationKey<List<String>> COPYABLE_ANNOTATIONS = new ConfigurationKey<List<String>>("lombok.copyableAnnotations", "Copy these annotations to getters, setters, withers, builder-setters, etc.") {};
 
 }

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -230,9 +230,9 @@ public static CharSequence removePrefix(CharSequence fieldName, List<String> pre
 	
 	public static final String DEFAULT_EXCEPTION_FOR_NON_NULL = "java.lang.NullPointerException";
 	
-	/** Returns the configuration value for ConfigurationKeys.COPY_ANNOTATIONS. */
-	public static List<String> copyAnnotationNames(AST<?, ?, ?> ast) {
-		return ast.readConfiguration(ConfigurationKeys.COPY_ANNOTATIONS);
+	/** Returns the configuration value for ConfigurationKeys.COPYABLE_ANNOTATIONS. */
+	public static List<String> getCopyableAnnotationNames(AST<?, ?, ?> ast) {
+		return ast.readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);
 	}
 
 	/**

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -405,7 +405,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 			Argument parameter = new Argument(fieldName, fieldPos, copyType(field.type, source), Modifier.FINAL);
 			Annotation[] nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 			Annotation[] nullables = findAnnotations(field, NULLABLE_PATTERN);
-			Annotation[] copyAnnotations = findExactAnnotations(field, copyAnnotationNames(fieldNode.getAst()));
+			Annotation[] copyAnnotations = findExactAnnotations(field, getCopyableAnnotationNames(fieldNode.getAst()));
 			if (nonNulls.length != 0) {
 				Statement nullCheck = generateNullCheck(parameter, sourceNode);
 				if (nullCheck != null) nullChecks.add(nullCheck);

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -274,7 +274,7 @@ public MethodDeclaration createGetter(TypeDeclaration parent, EclipseNode fieldN
 					onMethod.toArray(new Annotation[0]),
 					findAnnotations(field, NON_NULL_PATTERN),
 					findAnnotations(field, NULLABLE_PATTERN),
-					findExactAnnotations(field, copyAnnotationNames(fieldNode.getAst())),
+					findExactAnnotations(field, getCopyableAnnotationNames(fieldNode.getAst())),
 					findDelegatesAndMarkAsHandled(fieldNode),
 					deprecated);
 		}

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -238,7 +238,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		
 		Annotation[] nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 		Annotation[] nullables = findAnnotations(field, NULLABLE_PATTERN);
-		Annotation[] copyAnnotations = findExactAnnotations(field, copyAnnotationNames(fieldNode.getAst()));
+		Annotation[] copyableAnnotations = findExactAnnotations(field, getCopyableAnnotationNames(fieldNode.getAst()));
 		List<Statement> statements = new ArrayList<Statement>(5);
 		if (nonNulls.length == 0) {
 			statements.add(assignment);
@@ -256,7 +256,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 			statements.add(returnStatement);
 		}
 		method.statements = statements.toArray(new Statement[0]);
-		param.annotations = copyAnnotations(source, nonNulls, nullables, copyAnnotations, onParam.toArray(new Annotation[0]));
+		param.annotations = copyAnnotations(source, nonNulls, nullables, copyableAnnotations, onParam.toArray(new Annotation[0]));
 		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);
 		return method;

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -242,7 +242,7 @@ public MethodDeclaration createWither(TypeDeclaration parent, EclipseNode fieldN
 		
 		Annotation[] nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 		Annotation[] nullables = findAnnotations(field, NULLABLE_PATTERN);
-		Annotation[] copyAnnotations = findExactAnnotations(field, copyAnnotationNames(fieldNode.getAst()));
+		Annotation[] copyableAnnotations = findExactAnnotations(field, getCopyableAnnotationNames(fieldNode.getAst()));
 		
 		if (!makeAbstract) {
 			List<Expression> args = new ArrayList<Expression>();
@@ -286,7 +286,7 @@ public MethodDeclaration createWither(TypeDeclaration parent, EclipseNode fieldN
 			
 			method.statements = statements.toArray(new Statement[0]);
 		}
-		param.annotations = copyAnnotations(source, nonNulls, nullables, copyAnnotations, onParam.toArray(new Annotation[0]));
+		param.annotations = copyAnnotations(source, nonNulls, nullables, copyableAnnotations, onParam.toArray(new Annotation[0]));
 		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);
 		return method;

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -331,9 +331,9 @@ public static void addConstructorProperties(JCModifiers mods, JavacNode node, Li
 			Name rawName = field.name;
 			List<JCAnnotation> nonNulls = findAnnotations(fieldNode, NON_NULL_PATTERN);
 			List<JCAnnotation> nullables = findAnnotations(fieldNode, NULLABLE_PATTERN);
-			List<JCAnnotation> copyAnnotations = findExactAnnotations(fieldNode, copyAnnotationNames(fieldNode.getAst()));
+			List<JCAnnotation> copyableAnnotations = findExactAnnotations(fieldNode, getCopyableAnnotationNames(fieldNode.getAst()));
 			long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());
-			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, nonNulls.appendList(nullables).appendList(copyAnnotations)), fieldName, field.vartype, null);
+			JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, nonNulls.appendList(nullables).appendList(copyableAnnotations)), fieldName, field.vartype, null);
 			params.append(param);
 			if (!nonNulls.isEmpty()) {
 				JCStatement nullCheck = generateNullCheck(maker, fieldNode, param, source);

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -245,11 +245,11 @@ public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker tr
 		
 		List<JCAnnotation> nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 		List<JCAnnotation> nullables = findAnnotations(field, NULLABLE_PATTERN);
-		List<JCAnnotation> copyAnnotations = findExactAnnotations(field, copyAnnotationNames(field.getAst()));
+		List<JCAnnotation> copyableAnnotations = findExactAnnotations(field, getCopyableAnnotationNames(field.getAst()));
 		
 		List<JCAnnotation> delegates = findDelegatesAndRemoveFromField(field);
 		
-		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod).appendList(nonNulls).appendList(nullables).appendList(copyAnnotations);
+		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod).appendList(nonNulls).appendList(nullables).appendList(copyableAnnotations);
 		if (isFieldDeprecated(field)) {
 			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -228,10 +228,10 @@ public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNod
 		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
 		List<JCAnnotation> nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 		List<JCAnnotation> nullables = findAnnotations(field, NULLABLE_PATTERN);
-		List<JCAnnotation> copyAnnotations = findExactAnnotations(field, copyAnnotationNames(field.getAst()));
+		List<JCAnnotation> copyableAnnotations = findExactAnnotations(field, getCopyableAnnotationNames(field.getAst()));
 		
 		Name methodName = field.toName(setterName);
-		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(nonNulls).appendList(nullables).appendList(copyAnnotations);
+		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(nonNulls).appendList(nullables).appendList(copyableAnnotations);
 		
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
 		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(flags, annsOnParam), fieldDecl.name, fieldDecl.vartype, null);

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -224,15 +224,15 @@ public JCMethodDecl createWither(long access, JavacNode field, JavacTreeMaker ma
 		
 		List<JCAnnotation> nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 		List<JCAnnotation> nullables = findAnnotations(field, NULLABLE_PATTERN);
-		List<JCAnnotation> copyAnnotations = findExactAnnotations(field, copyAnnotationNames(field.getAst()));
+		List<JCAnnotation> copyableAnnotations = findExactAnnotations(field, getCopyableAnnotationNames(field.getAst()));
 		
 		Name methodName = field.toName(witherName);
 		
 		JCExpression returnType = cloneSelfType(field);
 		
 		JCBlock methodBody = null;
 		long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, field.getContext());
-		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(nonNulls).appendList(nullables).appendList(copyAnnotations);
+		List<JCAnnotation> annsOnParam = copyAnnotations(onParam).appendList(nonNulls).appendList(nullables).appendList(copyableAnnotations);
 		
 		JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, annsOnParam), fieldDecl.name, fieldDecl.vartype, null);
 		

File: test/transform/resource/before/GetterTypeAnnosCopy.java
Patch:
@@ -12,5 +12,5 @@
 
 class GetterTypeAnnos {
 	@Getter
-       	@TA List<@TA String> foo;
+	@TA List<@TA String> foo;
 }

File: test/transform/resource/before/GetterTypeAnnosNoCopy.java
Patch:
@@ -10,5 +10,5 @@
 
 class GetterTypeAnnos {
 	@Getter
-       	@TA List<@TA String> foo;
+	@TA List<@TA String> foo;
 }

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -541,6 +541,7 @@ private MethodDeclaration generateToBuilderMethod(String methodName, String buil
 				MessageSend emptyList = new MessageSend();
 				emptyList.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.UTIL, "Collections".toCharArray());
 				emptyList.selector = EMPTY_LIST;
+				emptyList.typeArguments = copyTypes(bfd.singularData.getTypeArgs().toArray(new TypeReference[0]));
 				ms.arguments = new Expression[] {new ConditionalExpression(ifNull, emptyList, tgt[1])};
 			}
 			ms.receiver = receiver;

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -74,7 +74,7 @@ public static <K>K rrr(BuilderWithToBuilder<K> x) {
     return new BuilderWithToBuilderBuilder<T>();
   }
   public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> toBuilder() {
-    return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(((this.bars == null) ? java.util.Collections.emptyList() : this.bars));
+    return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(((this.bars == null) ? java.util.Collections.<T>emptyList() : this.bars));
   }
 }
 @lombok.experimental.Accessors(prefix = "m") class ConstructorWithToBuilder<T> {

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -516,7 +516,8 @@ private JCMethodDecl generateToBuilderMethod(String toBuilderMethodName, String
 				arg = tgt[0];
 			} else {
 				JCExpression eqNull = maker.Binary(CTC_EQUAL, tgt[0], maker.Literal(CTC_BOT, null));
-				JCExpression emptyList = maker.Apply(List.<JCExpression>nil(), chainDots(type, "java", "util", "Collections", "emptyList"), List.<JCExpression>nil());
+				List<JCExpression> tas = cloneTypes(maker, bfd.singularData.getTypeArgs(), ast, type.getContext());
+				JCExpression emptyList = maker.Apply(tas, chainDots(type, "java", "util", "Collections", "emptyList"), List.<JCExpression>nil());
 				arg = maker.Conditional(eqNull, emptyList, tgt[1]);
 			}
 			

File: src/utils/lombok/eclipse/Eclipse.java
Patch:
@@ -186,11 +186,11 @@ public static Object calculateValue(Expression e) {
 			default: return null;
 			}
 		} else if (e instanceof ClassLiteralAccess) {
-			return new ClassLiteral(Eclipse.toQualifiedName(((ClassLiteralAccess)e).type.getTypeName()));
+			return new ClassLiteral(Eclipse.toQualifiedName(((ClassLiteralAccess) e).type.getTypeName()));
 		} else if (e instanceof SingleNameReference) {
 			return new FieldSelect(new String(((SingleNameReference)e).token));
 		} else if (e instanceof QualifiedNameReference) {
-			String qName = Eclipse.toQualifiedName(((QualifiedNameReference)e).tokens);
+			String qName = Eclipse.toQualifiedName(((QualifiedNameReference) e).tokens);
 			int idx = qName.lastIndexOf('.');
 			return new FieldSelect(idx == -1 ? qName : qName.substring(idx+1));
 		} else if (e instanceof UnaryExpression) {

File: test/transform/resource/after-delombok/BuilderSingularToBuilderWithNull.java
Patch:
@@ -58,6 +58,6 @@ public static BuilderSingularToBuilderWithNullBuilder builder() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderSingularToBuilderWithNullBuilder toBuilder() {
-		return new BuilderSingularToBuilderWithNullBuilder().elems(this.elems == null ? java.util.Collections.emptyList() : this.elems);
+		return new BuilderSingularToBuilderWithNullBuilder().elems(this.elems == null ? java.util.Collections.<String>emptyList() : this.elems);
 	}
 }

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -86,7 +86,7 @@ public static <T> BuilderWithToBuilderBuilder<T> builder() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderWithToBuilderBuilder<T> toBuilder() {
-		return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(this.bars == null ? java.util.Collections.emptyList() : this.bars);
+		return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(this.bars == null ? java.util.Collections.<T>emptyList() : this.bars);
 	}
 }
 class ConstructorWithToBuilder<T> {

File: test/transform/resource/after-ecj/BuilderSingularToBuilderWithNull.java
Patch:
@@ -52,6 +52,6 @@ public static void test() {
     return new BuilderSingularToBuilderWithNullBuilder();
   }
   public @java.lang.SuppressWarnings("all") BuilderSingularToBuilderWithNullBuilder toBuilder() {
-    return new BuilderSingularToBuilderWithNullBuilder().elems(((this.elems == null) ? java.util.Collections.emptyList() : this.elems));
+    return new BuilderSingularToBuilderWithNullBuilder().elems(((this.elems == null) ? java.util.Collections.<String>emptyList() : this.elems));
   }
 }

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -24,7 +24,6 @@
 import static lombok.core.handlers.HandlerUtil.*;
 import static lombok.eclipse.Eclipse.*;
 import static lombok.eclipse.EclipseAugments.*;
-import static lombok.eclipse.handlers.EclipseHandlerUtil.setGeneratedBy;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -48,7 +48,6 @@
 import org.eclipse.jdt.internal.compiler.ast.IfStatement;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
@@ -61,7 +60,6 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.eclipse.jdt.internal.compiler.ast.UnaryExpression;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;

File: src/core/lombok/javac/handlers/HandleSuperBuilder.java
Patch:
@@ -415,7 +415,7 @@ private void generateBuilderBasedConstructor(JavacNode typeNode, List<JCTypePara
 				bfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, bfd.originalFieldNode, bfd.type, statements, bfd.name, "b");
 				rhs = maker.Ident(bfd.singularData.getPluralName());
 			} else {
-				rhs = maker.Select(maker.Ident(builderVariableName), bfd.rawName);
+				rhs = maker.Select(maker.Ident(builderVariableName), bfd.name);
 			}
 			JCFieldAccess fieldInThis = maker.Select(maker.Ident(typeNode.toName("this")), bfd.rawName);
 			

File: test/transform/resource/after-delombok/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -48,7 +48,7 @@ private ParentBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ParentBuilderImpl self() {
+			protected ParentBuilderImpl<A> self() {
 				return this;
 			}
 			@java.lang.Override
@@ -111,7 +111,7 @@ private ChildBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ChildBuilderImpl self() {
+			protected ChildBuilderImpl<A> self() {
 				return this;
 			}
 			@java.lang.Override

File: test/transform/resource/after-delombok/SuperBuilderWithDefaults.java
Patch:
@@ -50,7 +50,7 @@ private ParentBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ParentBuilderImpl self() {
+			protected ParentBuilderImpl<N> self() {
 				return this;
 			}
 			@java.lang.Override

File: test/transform/resource/after-ecj/SuperBuilderWithCustomBuilderMethod.java
Patch:
@@ -38,7 +38,7 @@ public ParentBuilder() {
       private ParentBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl<A> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Parent<A> build() {
@@ -87,7 +87,7 @@ public ChildBuilder() {
       private ChildBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ChildBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ChildBuilderImpl<A> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Child<A> build() {

File: test/transform/resource/after-ecj/SuperBuilderWithDefaults.java
Patch:
@@ -29,7 +29,7 @@ public ParentBuilder() {
       private ParentBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl<N> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Parent<N> build() {

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics.java
Patch:
@@ -48,7 +48,7 @@ private ParentBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ParentBuilderImpl self() {
+			protected ParentBuilderImpl<A> self() {
 				return this;
 			}
 			@java.lang.Override
@@ -108,7 +108,7 @@ private ChildBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ChildBuilderImpl self() {
+			protected ChildBuilderImpl<A> self() {
 				return this;
 			}
 			@java.lang.Override

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics2.java
Patch:
@@ -48,7 +48,7 @@ private ParentBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ParentBuilderImpl self() {
+			protected ParentBuilderImpl<A> self() {
 				return this;
 			}
 			@java.lang.Override
@@ -108,7 +108,7 @@ private ChildBuilderImpl() {
 			}
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
-			protected ChildBuilderImpl self() {
+			protected ChildBuilderImpl<A> self() {
 				return this;
 			}
 			@java.lang.Override

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics.java
Patch:
@@ -38,7 +38,7 @@ public ParentBuilder() {
       private ParentBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl<A> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Parent<A> build() {
@@ -87,7 +87,7 @@ public ChildBuilder() {
       private ChildBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ChildBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ChildBuilderImpl<A> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Child<A> build() {

File: test/transform/resource/after-ecj/SuperBuilderWithGenerics2.java
Patch:
@@ -38,7 +38,7 @@ public ParentBuilder() {
       private ParentBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ParentBuilderImpl<A> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Parent<A> build() {
@@ -87,7 +87,7 @@ public ChildBuilder() {
       private ChildBuilderImpl() {
         super();
       }
-      protected @java.lang.Override @java.lang.SuppressWarnings("all") ChildBuilderImpl self() {
+      protected @java.lang.Override @java.lang.SuppressWarnings("all") ChildBuilderImpl<A> self() {
         return this;
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") Child<A> build() {

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -611,7 +611,7 @@ private JCMethodDecl generateBuildMethod(JavacNode tdParent, boolean isStatic, S
 		return maker.MethodDef(maker.Modifiers(Flags.PUBLIC), type.toName(buildName), returnType, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);
 	}
 	
-	public JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params) {
+	public static JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params) {
 		JavacTreeMaker maker = fieldNode.getTreeMaker();
 		JCVariableDecl field = (JCVariableDecl) fieldNode.get();
 		

File: src/core9/module-info.java
Patch:
@@ -23,6 +23,7 @@
 	requires java.compiler;
 	requires java.instrument;
 	requires jdk.unsupported;
+	requires static org.mapstruct.processor;
 	
 	exports lombok;
 	exports lombok.experimental;
@@ -36,4 +37,3 @@
 	provides javax.annotation.processing.Processor with lombok.launch.AnnotationProcessorHider.AnnotationProcessor;
 	provides org.mapstruct.ap.spi.AstModifyingAnnotationProcessor with lombok.launch.AnnotationProcessorHider.AstModificationNotifier;
 }
-

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -86,7 +86,7 @@ public static <T> BuilderWithToBuilderBuilder<T> builder() {
 	}
 	@java.lang.SuppressWarnings("all")
 	public BuilderWithToBuilderBuilder<T> toBuilder() {
-		return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(this.bars);
+		return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(this.bars == null ? java.util.Collections.emptyList() : this.bars);
 	}
 }
 class ConstructorWithToBuilder<T> {

File: test/transform/resource/after-ecj/BuilderWithToBuilder.java
Patch:
@@ -74,7 +74,7 @@ public static <K>K rrr(BuilderWithToBuilder<K> x) {
     return new BuilderWithToBuilderBuilder<T>();
   }
   public @java.lang.SuppressWarnings("all") BuilderWithToBuilderBuilder<T> toBuilder() {
-    return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(this.bars);
+    return new BuilderWithToBuilderBuilder<T>().one(this.mOne).two(this.mTwo).foo(BuilderWithToBuilder.rrr(this)).bars(((this.bars == null) ? java.util.Collections.emptyList() : this.bars));
   }
 }
 @lombok.experimental.Accessors(prefix = "m") class ConstructorWithToBuilder<T> {

File: src/core/lombok/core/configuration/StringConfigurationSource.java
Patch:
@@ -67,7 +67,6 @@ private void modifyList(ConfigurationKey<?> key, Object value, boolean add) {
 				list.add(new ListModification(value, add));
 			}
 		});
-		
 		return new StringConfigurationSource(values);
 	}
 	

File: src/core/lombok/javac/apt/LombokProcessor.java
Patch:
@@ -166,13 +166,13 @@ private void placePostCompileAndDontMakeForceRoundDummiesHook() {
 			if (!(originalFiler instanceof InterceptingJavaFileManager)) {
 				final Messager messager = processingEnv.getMessager();
 				DiagnosticsReceiver receiver = new MessagerDiagnosticsReceiver(messager);
-
+				
 				JavaFileManager newFilerManager = new InterceptingJavaFileManager(originalFiler, receiver);
 				ht.put(key, newFilerManager);
 				Field filerFileManagerField = JavacFiler.class.getDeclaredField("fileManager");
 				filerFileManagerField.setAccessible(true);
 				filerFileManagerField.set(javacFiler, newFilerManager);
-
+				
 				replaceFileManagerJdk9(context, newFilerManager);
 			}
 		} catch (Exception e) {
@@ -429,7 +429,7 @@ public JavacProcessingEnvironment getJavacProcessingEnvironment(Object procEnv)
 	}
 
 	/**
-	 * This class returns the given filer as a JavacFiler. In case the case that the filer is no
+	 * This class returns the given filer as a JavacFiler. In case the filer is no
 	 * JavacFiler (e.g. the Gradle IncrementalFiler), its "delegate" field is used to get the JavacFiler
 	 * (directly or through a delegate field again)
 	 */

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -122,7 +122,7 @@ public boolean transformCode(Collection<CompilerMessage> messages, StringWriter
 		
 		CompilationUnitDeclaration cud = compilationUnit_.get();
 		
-		if (cud == null) result.append("---- NO CompilationUnit provided by ecj ----");
+		if (cud == null) result.append("---- No CompilationUnit provided by ecj ----");
 		else result.append(cud.toString());
 		
 		return true;

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -146,6 +146,8 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 	}
 	
 	@Override public void handle(AnnotationValues<Builder> annotation, Annotation ast, EclipseNode annotationNode) {
+		handleFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, "@Builder");
+
 		long p = (long) ast.sourceStart << 32 | ast.sourceEnd;
 		
 		Builder builderInstance = annotation.getInstance();

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -595,7 +595,7 @@ private JCMethodDecl generateBuildMethod(JavacNode tdParent, boolean isStatic, S
 		return maker.MethodDef(maker.Modifiers(Flags.PUBLIC), type.toName(buildName), returnType, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);
 	}
 	
-	public JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params) {
+	public static JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params) {
 		JavacTreeMaker maker = fieldNode.getTreeMaker();
 		JCVariableDecl field = (JCVariableDecl) fieldNode.get();
 		

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -44,7 +44,7 @@
 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 
 /**
- * Handles the {@code lombok.FieldDefaults} annotation for eclipse.
+ * Handles the {@code lombok.FieldDefaults} annotation for javac.
  */
 @ProviderFor(JavacASTVisitor.class)
 @HandlerPriority(-2048) //-2^11; to ensure @Value picks up on messing with the fields' 'final' state, run earlier.

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -99,6 +99,8 @@ private static class BuilderFieldData {
 	}
 	
 	@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		handleFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, "@Builder");
+		
 		Builder builderInstance = annotation.getInstance();
 		
 		// These exist just to support the 'old' lombok.experimental.Builder, which had these properties. lombok.Builder no longer has them.

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixesShadowLoaded.java
Patch:
@@ -32,6 +32,7 @@
 public class PatchFixesShadowLoaded {
 	public static String addLombokNotesToEclipseAboutDialog(String origReturnValue, String key) {
 		if ("aboutText".equals(key)) {
+			if (origReturnValue.contains(" is installed. https://projectlombok.org")) return origReturnValue;
 			return origReturnValue + "\n\nLombok " + Version.getFullVersion() + " is installed. https://projectlombok.org/";
 		}
 		return origReturnValue;

File: test/transform/resource/before/ConstructorsWithBuilderDefaults.java
Patch:
@@ -3,6 +3,7 @@
 import lombok.Value;
 import lombok.Builder;
 
-@NoArgsConstructor @AllArgsConstructor @Builder @Value class ConstructorsWithBuilderDefaults {
+@NoArgsConstructor(force = true) @AllArgsConstructor @Builder @Value class ConstructorsWithBuilderDefaults {
 	@Builder.Default int x = 5;
+	int y;
 }

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -155,11 +155,13 @@ private static class BuilderFieldData {
 				
 				if (bfd.singularData != null && isDefault != null) {
 					isDefault.addError("@Builder.Default and @Singular cannot be mixed.");
+					findAnnotation(Builder.Default.class, fieldNode, true);
 					isDefault = null;
 				}
 				
 				if (fd.init == null && isDefault != null) {
 					isDefault.addWarning("@Builder.Default requires an initializing expression (' = something;').");
+					findAnnotation(Builder.Default.class, fieldNode, true);
 					isDefault = null;
 				}
 				

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -144,7 +144,7 @@ private static class BuilderFieldData {
 			boolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation("lombok.experimental.Value", parent));
 			for (JavacNode fieldNode : HandleConstructor.findAllFields(tdParent, true)) {
 				JCVariableDecl fd = (JCVariableDecl) fieldNode.get();
-				JavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, true);
+				JavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, false);
 				boolean isFinal = (fd.mods.flags & Flags.FINAL) != 0 || (valuePresent && !hasAnnotation(NonFinal.class, fieldNode));
 				BuilderFieldData bfd = new BuilderFieldData();
 				bfd.rawName = fd.name;

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -212,7 +212,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate,
 		return createSetter(parent, deprecate, fieldNode, name, booleanFieldToSet, returnType, returnThis, modifier, sourceNode, onMethod, onParam);
 	}
 	
-	static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate, EclipseNode fieldNode, String name, char[] booleanFieldToSet, TypeReference returnType, ReturnStatement returnStatement, int modifier, EclipseNode sourceNode, List<Annotation> onMethod, List<Annotation> onParam) {
+	static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate, EclipseNode fieldNode, String name, char[] booleanFieldToSet, TypeReference returnType, Statement returnStatement, int modifier, EclipseNode sourceNode, List<Annotation> onMethod, List<Annotation> onParam) {
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		ASTNode source = sourceNode.get();
 		int pS = source.sourceStart, pE = source.sourceEnd;

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -214,7 +214,7 @@ public void generateExtraNoArgsConstructor(EclipseNode typeNode, EclipseNode sou
 		if (!isDirectDescendantOfObject(typeNode)) return;
 		
 		Boolean v = typeNode.getAst().readConfiguration(ConfigurationKeys.NO_ARGS_CONSTRUCTOR_EXTRA_PRIVATE);
-		if (v != null && !v) return;
+		if (v == null || !v) return;
 
 		List<EclipseNode> fields = findFinalFields(typeNode);
 		generate(typeNode, AccessLevel.PRIVATE, fields, true, null, SkipIfConstructorExists.NO, Collections.<Annotation>emptyList(), sourceNode, true);

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -200,7 +200,7 @@ public void generateExtraNoArgsConstructor(JavacNode typeNode, JavacNode source)
 		if (!isDirectDescendantOfObject(typeNode)) return;
 		
 		Boolean v = typeNode.getAst().readConfiguration(ConfigurationKeys.NO_ARGS_CONSTRUCTOR_EXTRA_PRIVATE);
-		if (v != null && !v) return;
+		if (v == null || !v) return;
 
 		List<JavacNode> fields = findFinalFields(typeNode);
 		generate(typeNode, AccessLevel.PRIVATE, List.<JCAnnotation>nil(), fields, true, null, SkipIfConstructorExists.NO, source, true);

File: test/transform/resource/before/DataConfiguration.java
Patch:
@@ -1,6 +1,7 @@
 //CONF: lombok.anyConstructor.suppressConstructorProperties = true
 //CONF: lombok.toString.doNotUseGetters = true
 //CONF: lombok.equalsAndHashCode.doNotUseGetters = true
+//CONF: lombok.noArgsConstructor.extraPrivate = true
 @lombok.Data
 class DataConfiguration {
 	final int x;

File: test/transform/resource/before/PrivateNoArgsConstructor.java
Patch:
@@ -1,3 +1,4 @@
+// CONF: lombok.noArgsConstructor.extraPrivate = true
 // CONF: lombok.equalsAndHashCode.callSuper = call
 public class PrivateNoArgsConstructor {
 	private static class Base {

File: src/core/lombok/experimental/FieldNameConstants.java
Patch:
@@ -35,4 +35,6 @@
 @Retention(RetentionPolicy.SOURCE)
 public @interface FieldNameConstants {
 	lombok.AccessLevel level() default AccessLevel.PUBLIC;
+	String prefix() default " CONFIG DEFAULT ";
+	String suffix() default " CONFIG DEFAULT ";
 }

File: test/transform/resource/after-delombok/FieldNameConstantsBasic.java
Patch:
@@ -1,6 +1,6 @@
 public class FieldNameConstantsBasic {
-	protected static final java.lang.String I_AM_A_DVD_PLAYER = "iAmADvdPlayer";
-	public static final java.lang.String BUT_PRINT_ME_PLEASE = "butPrintMePlease";
+	protected static final java.lang.String FIELD_I_AM_A_DVD_PLAYER = "iAmADvdPlayer";
+	public static final java.lang.String FIELD_BUT_PRINT_ME_PLEASE = "butPrintMePlease";
 	String iAmADvdPlayer;
 	int $skipMe;
 	static double skipMeToo;

File: test/transform/resource/after-delombok/FieldNameConstantsWeird.java
Patch:
@@ -1,4 +1,6 @@
 public class FieldNameConstantsWeird {
+	public static final java.lang.String FIELD_AZ = "A";
 	String iAmADvdPlayer;
 	String X;
+	String A;
 }

File: test/transform/resource/after-ecj/FieldNameConstantsBasic.java
Patch:
@@ -1,8 +1,8 @@
 import lombok.experimental.FieldNameConstants;
 import lombok.AccessLevel;
 public @FieldNameConstants class FieldNameConstantsBasic {
-  public static final java.lang.String BUT_PRINT_ME_PLEASE = "butPrintMePlease";
-  protected static final java.lang.String I_AM_A_DVD_PLAYER = "iAmADvdPlayer";
+  public static final java.lang.String FIELD_BUT_PRINT_ME_PLEASE = "butPrintMePlease";
+  protected static final java.lang.String FIELD_I_AM_A_DVD_PLAYER = "iAmADvdPlayer";
   @FieldNameConstants(level = AccessLevel.PROTECTED) String iAmADvdPlayer;
   int $skipMe;
   static double skipMeToo;

File: test/transform/resource/before/FieldNameConstantsWeird.java
Patch:
@@ -5,5 +5,8 @@
 public class FieldNameConstantsWeird {
 	@FieldNameConstants(level = AccessLevel.NONE)
 	String iAmADvdPlayer;
+	@FieldNameConstants(prefix = "")
 	String X;
+	@FieldNameConstants(suffix = "Z")
+	String A;
 }

File: src/core/lombok/extern/apachecommons/CommonsLog.java
Patch:
@@ -56,6 +56,7 @@
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/java/Log.java
Patch:
@@ -55,6 +55,7 @@
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/jbosslog/JBossLog.java
Patch:
@@ -53,8 +53,9 @@
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
+ * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
- * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  *  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/log4j/Log4j.java
Patch:
@@ -56,6 +56,7 @@
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/log4j/Log4j2.java
Patch:
@@ -56,6 +56,7 @@
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/slf4j/Slf4j.java
Patch:
@@ -55,6 +55,7 @@
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/slf4j/XSlf4j.java
Patch:
@@ -55,6 +55,7 @@
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ * @see lombok.extern.flogger.Flogger &#64;Flogger
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core9/module-info.java
Patch:
@@ -31,6 +31,7 @@
 	exports lombok.extern.jbosslog;
 	exports lombok.extern.log4j;
 	exports lombok.extern.slf4j;
+	exports lombok.extern.flogger;
 	
 	provides javax.annotation.processing.Processor with lombok.launch.AnnotationProcessorHider.AnnotationProcessor;
 	provides org.mapstruct.ap.spi.AstModifyingAnnotationProcessor with lombok.launch.AnnotationProcessorHider.AstModificationNotifier;

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -146,6 +146,7 @@ private FileSystem createFileSystem(File file) {
 		classpath.add("lib/test/org.jboss.logging-jboss-logging.jar");
 		classpath.add("lib/test/com.google.guava-guava.jar");
 		classpath.add("lib/test/com.google.code.findbugs-findbugs.jar");
+		classpath.add("lib/test/com.google.flogger-flogger.jar");
 		return new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, "UTF-8");
 	}
 }

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -147,7 +147,6 @@ private static class CmdArgs {
 		private boolean nocopy;
 		
 		@Description("Output only changed files (implies -n)")
-		@Shorthand("c")
 		private boolean onlyChanged;
 		
 		private boolean help;

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -434,7 +434,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 		
 		if (constructorExists(builderType) == MemberExistsResult.NOT_EXISTS) {
 			ConstructorDeclaration cd = HandleConstructor.createConstructor(
-				AccessLevel.PACKAGE, builderType, Collections.<EclipseNode>emptyList(), false, true,
+				AccessLevel.PACKAGE, builderType, Collections.<EclipseNode>emptyList(), false,
 				annotationNode, Collections.<Annotation>emptyList());
 			if (cd != null) injectMethod(builderType, cd);
 		}

File: src/core/lombok/eclipse/handlers/EclipseSingularsRecipes.java
Patch:
@@ -229,7 +229,7 @@ public List<char[]> listMethodsToBeGenerated(SingularData data, EclipseNode buil
 		 * control over the return type and value, use
 		 * {@link #generateMethods(SingularData, boolean, EclipseNode, boolean, Supplier, Supplier)}.
 		 */
-		public void generateMethods(SingularData data, boolean deprecate, EclipseNode builderType, boolean fluent, boolean chain) {
+		public void generateMethods(SingularData data, boolean deprecate, final EclipseNode builderType, boolean fluent, final boolean chain) {
 			// TODO: Make these lambdas when switching to a source level >= 1.8.
 			Supplier<TypeReference> returnType = new Supplier<TypeReference>() {
 				@Override public TypeReference get() {

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -434,7 +434,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 		
 		if (constructorExists(builderType) == MemberExistsResult.NOT_EXISTS) {
 			ConstructorDeclaration cd = HandleConstructor.createConstructor(
-				AccessLevel.PACKAGE, builderType, Collections.<EclipseNode>emptyList(), false,
+				AccessLevel.PACKAGE, builderType, Collections.<EclipseNode>emptyList(), false, true,
 				annotationNode, Collections.<Annotation>emptyList());
 			if (cd != null) injectMethod(builderType, cd);
 		}
@@ -569,7 +569,7 @@ public MethodDeclaration generateBuildMethod(EclipseNode tdParent, boolean isSta
 		
 		for (BuilderFieldData bfd : builderFields) {
 			if (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {
-				bfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, type, statements, bfd.name);
+				bfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, type, statements, bfd.name, "this");
 			}
 		}
 		
@@ -640,7 +640,7 @@ private TypeReference[] typeParameterNames(TypeParameter[] typeParameters) {
 		return trs;
 	}
 	
-	public MethodDeclaration generateDefaultProvider(char[] methodName, TypeParameter[] typeParameters, EclipseNode fieldNode, ASTNode source) {
+	public static MethodDeclaration generateDefaultProvider(char[] methodName, TypeParameter[] typeParameters, EclipseNode fieldNode, ASTNode source) {
 		int pS = source.sourceStart, pE = source.sourceEnd;
 		
 		MethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) fieldNode.top().get()).compilationResult);

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -79,5 +79,6 @@ public class HandleData extends EclipseAnnotationHandler<Data> {
 		handleConstructor.generateRequiredArgsConstructor(
 				typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), SkipIfConstructorExists.YES,
 				Collections.<Annotation>emptyList(), annotationNode);
+		handleConstructor.generateExtraNoArgsConstructor(typeNode, annotationNode);
 	}
 }

File: src/core/lombok/eclipse/handlers/HandleValue.java
Patch:
@@ -91,5 +91,6 @@ public void handle(AnnotationValues<Value> annotation, Annotation ast, EclipseNo
 		handleToString.generateToStringForType(typeNode, annotationNode);
 		handleConstructor.generateAllArgsConstructor(typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), SkipIfConstructorExists.YES,
 				Collections.<Annotation>emptyList(), annotationNode);
+		handleConstructor.generateExtraNoArgsConstructor(typeNode, annotationNode);
 	}
 }

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2014 The Project Lombok Authors.
+ * Copyright (C) 2009-2018 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -61,7 +61,9 @@ public class HandleData extends JavacAnnotationHandler<Data> {
 		
 		String staticConstructorName = annotation.getInstance().staticConstructor();
 		
+		// TODO move this to the end OR move it to the top in eclipse.
 		handleConstructor.generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, SkipIfConstructorExists.YES, annotationNode);
+		handleConstructor.generateExtraNoArgsConstructor(typeNode, annotationNode);
 		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCAnnotation>nil());
 		handleSetter.generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCAnnotation>nil(), List.<JCAnnotation>nil());
 		handleEqualsAndHashCode.generateEqualsAndHashCodeForType(typeNode, annotationNode);

File: src/core/lombok/javac/handlers/HandleValue.java
Patch:
@@ -77,6 +77,7 @@ public class HandleValue extends JavacAnnotationHandler<Value> {
 		}
 		handleFieldDefaults.generateFieldDefaultsForType(typeNode, annotationNode, AccessLevel.PRIVATE, true, true);
 		handleConstructor.generateAllArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, SkipIfConstructorExists.YES, annotationNode);
+		handleConstructor.generateExtraNoArgsConstructor(typeNode, annotationNode);
 		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCAnnotation>nil());
 		handleEqualsAndHashCode.generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		handleToString.generateToStringForType(typeNode, annotationNode);

File: src/core/lombok/eclipse/handlers/HandleSuperBuilder.java
Patch:
@@ -225,7 +225,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec
 		// You can use it to check whether to inherit or not.
 
 		returnType = namePlusTypeParamsToTypeReference(td.name, td.typeParameters, p);
-		typeParams = td.typeParameters;
+		typeParams = td.typeParameters != null ? td.typeParameters : new TypeParameter[0];
 
 		// <C, B> are the generics for our builder.
 		String classGenericName = "C";

File: test/transform/resource/after-delombok/SuperBuilderBasic.java
Patch:
@@ -1,6 +1,7 @@
 import java.util.List;
 
 public class SuperBuilderBasic {
+	@lombok.experimental.SuperBuilder
 	public static class Parent {
 		int field1;
 		List<String> items;
@@ -97,7 +98,7 @@ public Parent build() {
 		}
 	}
 
-
+	@lombok.experimental.SuperBuilder
 	public static class Child extends Parent {
 		double field3;
 
@@ -130,7 +131,7 @@ public B field3(final double field3) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public java.lang.String toString() {
-				return "SuperBuilderBasic.Child.ChildBuilder(field3=" + this.field3 + ")";
+				return "SuperBuilderBasic.Child.ChildBuilder(super=" + super.toString() + ", field3=" + this.field3 + ")";
 			}
 		}
 

File: test/transform/resource/after-delombok/SuperBuilderWithGenerics.java
Patch:
@@ -1,6 +1,7 @@
 import java.util.List;
 
 public class SuperBuilderWithGenerics {
+	@lombok.experimental.SuperBuilder
 	public static class Parent<A> {
 		A field1;
 		List<String> items;
@@ -97,7 +98,7 @@ public Parent<A> build() {
 		}
 	}
 
-
+	@lombok.experimental.SuperBuilder
 	public static class Child<A> extends Parent<A> {
 		double field3;
 
@@ -130,7 +131,7 @@ public B field3(final double field3) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public java.lang.String toString() {
-				return "SuperBuilderWithGenerics.Child.ChildBuilder(field3=" + this.field3 + ")";
+				return "SuperBuilderWithGenerics.Child.ChildBuilder(super=" + super.toString() + ", field3=" + this.field3 + ")";
 			}
 		}
 

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -72,8 +72,8 @@ public class HandleData extends EclipseAnnotationHandler<Data> {
 		//for whatever reason, though you can find callers of that one by focusing on the class name itself
 		//and hitting 'find callers'.
 		
-		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
-		handleSetter.generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
+		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, Collections.<Annotation>emptyList());
+		handleSetter.generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, Collections.<Annotation>emptyList(), Collections.<Annotation>emptyList());
 		handleEqualsAndHashCode.generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		handleToString.generateToStringForType(typeNode, annotationNode);
 		handleConstructor.generateRequiredArgsConstructor(

File: src/core/lombok/eclipse/handlers/HandleValue.java
Patch:
@@ -86,7 +86,7 @@ public void handle(AnnotationValues<Value> annotation, Annotation ast, EclipseNo
 		//for whatever reason, though you can find callers of that one by focusing on the class name itself
 		//and hitting 'find callers'.
 		
-		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
+		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, Collections.<Annotation>emptyList());
 		handleEqualsAndHashCode.generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		handleToString.generateToStringForType(typeNode, annotationNode);
 		handleConstructor.generateAllArgsConstructor(typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), SkipIfConstructorExists.YES,

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -34,6 +34,7 @@
 import org.mangosdk.spi.ProviderFor;
 
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
+import com.sun.tools.javac.util.List;
 
 /**
  * Handles the {@code lombok.Data} annotation for javac.
@@ -61,8 +62,8 @@ public class HandleData extends JavacAnnotationHandler<Data> {
 		String staticConstructorName = annotation.getInstance().staticConstructor();
 		
 		handleConstructor.generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, SkipIfConstructorExists.YES, annotationNode);
-		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
-		handleSetter.generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
+		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCAnnotation>nil());
+		handleSetter.generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCAnnotation>nil(), List.<JCAnnotation>nil());
 		handleEqualsAndHashCode.generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		handleToString.generateToStringForType(typeNode, annotationNode);
 	}

File: src/core/lombok/javac/handlers/HandleValue.java
Patch:
@@ -40,6 +40,7 @@
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCModifiers;
+import com.sun.tools.javac.util.List;
 
 /**
  * Handles the {@code lombok.Value} annotation for javac.
@@ -76,7 +77,7 @@ public class HandleValue extends JavacAnnotationHandler<Value> {
 		}
 		handleFieldDefaults.generateFieldDefaultsForType(typeNode, annotationNode, AccessLevel.PRIVATE, true, true);
 		handleConstructor.generateAllArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, SkipIfConstructorExists.YES, annotationNode);
-		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
+		handleGetter.generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCAnnotation>nil());
 		handleEqualsAndHashCode.generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		handleToString.generateToStringForType(typeNode, annotationNode);
 	}

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -479,14 +479,16 @@ public TypeReference createTypeReference(EclipseNode type, long p, ASTNode sourc
 		
 		list.add(type.getName());
 		if (addWildcards) genericsCount.add(arraySizeOf(((TypeDeclaration) type.get()).typeParameters));
-		boolean staticContext = (((TypeDeclaration) type.get()).modifiers & Modifier.STATIC) != 0;
+		boolean staticContext = (((TypeDeclaration) type.get()).modifiers & ClassFileConstants.AccStatic) != 0;
 		EclipseNode tNode = type.up();
+		if (!staticContext && tNode.getKind() == Kind.TYPE && (((TypeDeclaration) tNode.get()).modifiers & ClassFileConstants.AccInterface) != 0) staticContext = true;
 		
 		while (tNode != null && tNode.getKind() == Kind.TYPE) {
 			list.add(tNode.getName());
 			if (addWildcards) genericsCount.add(staticContext ? 0 : arraySizeOf(((TypeDeclaration) tNode.get()).typeParameters));
 			if (!staticContext) staticContext = (((TypeDeclaration) tNode.get()).modifiers & Modifier.STATIC) != 0;
 			tNode = tNode.up();
+			if (!staticContext && tNode.getKind() == Kind.TYPE && (((TypeDeclaration) tNode.get()).modifiers & ClassFileConstants.AccInterface) != 0) staticContext = true;
 		}
 		Collections.reverse(list);
 		if (addWildcards) Collections.reverse(genericsCount);

File: test/transform/resource/before/BuilderWithRecursiveGenerics.java
Patch:
@@ -5,7 +5,7 @@
 
 public class BuilderWithRecursiveGenerics {
 	interface Inter<T, U extends Inter<T, U>> {}
-
+	
 	@Builder @Value public static class Test<Foo, Bar extends Set<Foo>, Quz extends Inter<Bar, Quz>> {
 		Foo foo;
 		Bar bar;

File: src/installer/lombok/installer/eclipse/EclipseProductLocationProvider.java
Patch:
@@ -51,7 +51,7 @@ public class EclipseProductLocationProvider implements IdeLocationProvider {
 	 * Create a new EclipseLocation by pointing at either the directory contains the Eclipse executable, or the executable itself,
 	 * or an eclipse.ini file.
 	 * 
-	 * @throws NotAnIdeLocationException
+	 * @throws CorruptedIdeLocationException
 	 *             If this isn't an Eclipse executable or a directory with an
 	 *             Eclipse executable.
 	 */

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -746,7 +746,7 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a
 	 * Provides AnnotationValues with the data it needs to do its thing.
 	 */
 	public static <A extends java.lang.annotation.Annotation> AnnotationValues<A>
-			createAnnotation(Class<A> type, final EclipseNode annotationNode) {
+		createAnnotation(Class<A> type, final EclipseNode annotationNode) {
 		
 		final Annotation annotation = (Annotation) annotationNode.get();
 		Map<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();
@@ -763,7 +763,7 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a
 			String mName = (n == null || n.length == 0) ? "value" : new String(pair.name);
 			final Expression rhs = pair.value;
 			if (rhs instanceof ArrayInitializer) {
-				expressions = ((ArrayInitializer)rhs).expressions;
+				expressions = ((ArrayInitializer) rhs).expressions;
 			} else if (rhs != null) {
 				expressions = new Expression[] { rhs };
 			}

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -396,7 +396,7 @@ void printMessage(Diagnostic.Kind kind, String message, JavacNode node, Diagnost
 			oldSource = log.useSource(newSource);
 			if (pos == null) pos = astObject.pos();
 		}
-		if (pos != null && attemptToRemoveErrorsInRange) {
+		if (pos != null && node != null && attemptToRemoveErrorsInRange) {
 			removeFromDeferredDiagnostics(pos.getStartPosition(), node.getEndPosition(pos));
 		}
 		try {

File: src/core/lombok/javac/apt/EmptyLombokFileObject.java
Patch:
@@ -57,7 +57,7 @@ public EmptyLombokFileObject(String name, Kind kind) {
 	}
 	
 	@Override public URI toUri() {
-		return URI.create("file:///" + name);
+		return URI.create("file:///" + (name.startsWith("/") ? name.substring(1) : name));
 	}
 	
 	@Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {

File: src/core/lombok/javac/apt/EmptyLombokFileObject.java
Patch:
@@ -57,7 +57,7 @@ public EmptyLombokFileObject(String name, Kind kind) {
 	}
 	
 	@Override public URI toUri() {
-		return URI.create("file://" + name);
+		return URI.create("file:///" + name);
 	}
 	
 	@Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {

File: src/core/lombok/javac/apt/EmptyLombokFileObject.java
Patch:
@@ -57,7 +57,7 @@ public EmptyLombokFileObject(String name, Kind kind) {
 	}
 	
 	@Override public URI toUri() {
-		return URI.create("file://" + name);
+		return URI.create("file:///" + (name.startsWith("/") ? name.substring(1) : name));
 	}
 	
 	@Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -79,7 +79,7 @@ public static Class<?> loadDelombok(List<String> args) throws Exception {
 				}
 			}
 			
-			System.err.printf("Can't find tools.jar. Rerun delombok as: java -cp lombok.jar%1$s%2$s lombok.core.Main delombok %3$s\n",
+			System.err.printf("Can't find tools.jar. Rerun delombok as: java -cp lombok.jar%1$s%2$s lombok.launch.Main delombok %3$s\n",
 					File.pathSeparator, examplePath, sb.toString());
 			return null;
 		}

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1097,7 +1097,7 @@ public static boolean filterField(FieldDeclaration declaration) {
 	public static boolean filterField(FieldDeclaration declaration, boolean skipStatic) {
 		// Skip the fake fields that represent enum constants.
 		if (declaration.initialization instanceof AllocationExpression &&
-				((AllocationExpression)declaration.initialization).enumConstant != null) return false;
+				((AllocationExpression) declaration.initialization).enumConstant != null) return false;
 		
 		if (declaration.type == null) return false;
 		

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -243,7 +243,7 @@ private static void compareContent(String name, String expectedFile, String actu
 		
 		int size = Math.min(expectedLines.length, actualLines.length);
 		if (size == 0 && expectedLines.length + actualLines.length > 0) {
-			Assert.fail("Missing / empty expected file.");
+			Assert.fail("Missing / empty expected file: " + name);
 		}
 		
 		for (int i = 0; i < size; i++) {

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithGenericsOnInners.java
Patch:
@@ -1,3 +1,4 @@
+//version 7:
 public class EqualsAndHashCodeWithGenericsOnInners<A> {
 	class Inner<B> {
 		int x;

File: test/transform/resource/after-delombok/InnerClass.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class A {
 	class B {
 		String s;
@@ -48,4 +49,4 @@ public java.lang.String toString() {
 			return "C.D(a=" + this.getA() + ")";
 		}
 	}
-}
\ No newline at end of file
+}

File: src/core/lombok/javac/apt/EmptyLombokFileObject.java
Patch:
@@ -57,7 +57,7 @@ public EmptyLombokFileObject(String name, Kind kind) {
 	}
 	
 	@Override public URI toUri() {
-		return URI.create(name);
+		return URI.create("file://" + name);
 	}
 	
 	@Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {

File: src/website/lombok/website/FetchCurrentVersion.java
Patch:
@@ -23,7 +23,7 @@ public static String fetchVersionFromSite(boolean fetchFull) throws IOException
 			BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
 			for (String line = br.readLine(); line != null; line = br.readLine()) {
 				Matcher m = VERSION_PATTERN.matcher(line);
-				if (m.matches() && m.group(1).equals("currentVersionFull") == fetchFull) return m.group(2);
+				if (m.matches() && m.group(1).equals("currentVersionFull") == fetchFull) return m.group(2).replace("&quot;", "\"");
 			}
 			throw new IOException("Expected a span with id 'currentVersion'");
 		} finally {

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -267,7 +267,7 @@ public void generateConstructor(
 		}
 	}
 	
-	private static final char[][] JAVA_BEANS_CONSTRUCTORPROPERTIES = new char[][] { "java".toCharArray(), "beans".toCharArray(), "ConstructorProperties".toCharArray() };
+	public static final char[][] JAVA_BEANS_CONSTRUCTORPROPERTIES = new char[][] { "java".toCharArray(), "beans".toCharArray(), "ConstructorProperties".toCharArray() };
 	public static Annotation[] createConstructorProperties(ASTNode source, Collection<EclipseNode> fields) {
 		if (fields.isEmpty()) return null;
 		

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -200,7 +200,7 @@ void generatePluralMethod(boolean deprecate, TypeReference returnType, Statement
 		injectMethod(builderType, md);
 	}
 	
-	@Override public void appendBuildCode(SingularData data, EclipseNode builderType, List<Statement> statements, char[] targetVariableName) {
+	@Override public void appendBuildCode(SingularData data, EclipseNode builderType, List<Statement> statements, char[] targetVariableName, String builderVariable) {
 		TypeReference varType = new QualifiedTypeReference(fromQualifiedName(data.getTargetFqn()), NULL_POSS);
 		String simpleTypeName = getSimpleTargetTypeName(data);
 		int agrumentsCount = getTypeArgumentsCount();
@@ -219,14 +219,14 @@ void generatePluralMethod(boolean deprecate, TypeReference returnType, Statement
 			invokeBuild = new MessageSend();
 			invokeBuild.selector = new char[] {'b', 'u', 'i', 'l', 'd'};
 			FieldReference thisDotField = new FieldReference(data.getPluralName(), 0L);
-			thisDotField.receiver = new ThisReference(0, 0);
+			thisDotField.receiver = getBuilderReference(builderVariable);
 			invokeBuild.receiver = thisDotField;
 		}
 		
 		Expression isNull; {
 			//this.pluralName == null
 			FieldReference thisDotField = new FieldReference(data.getPluralName(), 0L);
-			thisDotField.receiver = new ThisReference(0, 0);
+			thisDotField.receiver = getBuilderReference(builderVariable);
 			isNull = new EqualExpression(thisDotField, new NullLiteral(0, 0), OperatorIds.EQUAL_EQUAL);
 		}
 		

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -168,7 +168,7 @@ protected void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCE
 		injectMethod(builderType, method);
 	}
 	
-	@Override public void appendBuildCode(SingularData data, JavacNode builderType, JCTree source, ListBuffer<JCStatement> statements, Name targetVariableName) {
+	@Override public void appendBuildCode(SingularData data, JavacNode builderType, JCTree source, ListBuffer<JCStatement> statements, Name targetVariableName, String builderVariable) {
 		JavacTreeMaker maker = builderType.getTreeMaker();
 		List<JCExpression> jceBlank = List.nil();
 		
@@ -185,12 +185,12 @@ protected void generatePluralMethod(boolean deprecate, JavacTreeMaker maker, JCE
 		
 		JCExpression invokeBuild; {
 			//this.pluralName.build();
-			invokeBuild = maker.Apply(jceBlank, chainDots(builderType, "this", data.getPluralName().toString(), "build"), jceBlank);
+			invokeBuild = maker.Apply(jceBlank, chainDots(builderType, builderVariable, data.getPluralName().toString(), "build"), jceBlank);
 		}
 		
 		JCExpression isNull; {
 			//this.pluralName == null
-			isNull = maker.Binary(CTC_EQUAL, maker.Select(maker.Ident(builderType.toName("this")), data.getPluralName()), maker.Literal(CTC_BOT, null));
+			isNull = maker.Binary(CTC_EQUAL, maker.Select(maker.Ident(builderType.toName(builderVariable)), data.getPluralName()), maker.Literal(CTC_BOT, null));
 		}
 		
 		JCExpression init = maker.Conditional(isNull, empty, invokeBuild); // this.pluralName == null ? ImmutableX.of() : this.pluralName.build()

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -42,7 +42,7 @@ private ConfigurationKeys() {}
 	 * lombok configuration: {@code lombok.addGeneratedAnnotation} = {@code true} | {@code false}.
 	 * 
 	 * If {@code true}, lombok generates {@code @javax.annotation.Generated("lombok")} on all fields, methods, and types that are generated, unless {@code lombok.addJavaxGeneratedAnnotation} is set.
-	 * <br />
+	 * <br>
 	 * <em>BREAKING CHANGE</em>: Starting with lombok v2.0.0, defaults to {@code false} instead of {@code true}, as this annotation is broken in JDK9.
 	 * 
 	 * @see ConfigurationKeys#ADD_JAVAX_GENERATED_ANNOTATIONS
@@ -56,7 +56,7 @@ private ConfigurationKeys() {}
 	 * lombok configuration: {@code lombok.addJavaxGeneratedAnnotation} = {@code true} | {@code false}.
 	 * 
 	 * If {@code true}, lombok generates {@code @javax.annotation.Generated("lombok")} on all fields, methods, and types that are generated.
-	 * <br />
+	 * <br>
 	 * <em>BREAKING CHANGE</em>: Starting with lombok v2.0.0, defaults to {@code false} instead of {@code true}, as this annotation is broken in JDK9.
 	 */
 	public static final ConfigurationKey<Boolean> ADD_JAVAX_GENERATED_ANNOTATIONS = new ConfigurationKey<Boolean>("lombok.addJavaxGeneratedAnnotation", "Generate @javax.annotation.Generated on all generated code (default: follow lombok.addGeneratedAnnotation).") {};
@@ -94,7 +94,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * NB: GWT projects, and probably android projects, should explicitly set this key to {@code true} for the entire project.
 	 * 
-	 * <br />
+	 * <br>
 	 * <em>BREAKING CHANGE</em>: Starting with lombok v2.0.0, defaults to {@code false} instead of {@code true}, as {@code @ConstructorProperties} requires extra modules in JDK9.
 	 * 
 	 * @see ConfigurationKeys#ANY_CONSTRUCTOR_ADD_CONSTRUCTOR_PROPERTIES

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -897,7 +897,7 @@ private static GetterMethod findGetter(EclipseNode field) {
 		
 		// Check if the class has a @Getter annotation.
 		
-		if (!hasGetterAnnotation && new HandleGetter().fieldQualifiesForGetterGeneration(field)) {
+		if (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {
 			//Check if the class has @Getter or @Data annotation.
 			
 			EclipseNode containingType = field.up();

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -89,6 +89,8 @@
 @ProviderFor(EclipseAnnotationHandler.class)
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleBuilder extends EclipseAnnotationHandler<Builder> {
+	private HandleConstructor handleConstructor = new HandleConstructor();
+	
 	private static final char[] CLEAN_FIELD_NAME = "$lombokUnclean".toCharArray();
 	private static final char[] CLEAN_METHOD_NAME = "$lombokClean".toCharArray();
 	
@@ -225,7 +227,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 				allFields.add(fieldNode);
 			}
 			
-			new HandleConstructor().generateConstructor(tdParent, AccessLevel.PACKAGE, allFields, false, null, SkipIfConstructorExists.I_AM_BUILDER,
+			handleConstructor.generateConstructor(tdParent, AccessLevel.PACKAGE, allFields, false, null, SkipIfConstructorExists.I_AM_BUILDER,
 				Collections.<Annotation>emptyList(), annotationNode);
 			
 			returnType = namePlusTypeParamsToTypeReference(td.name, td.typeParameters, p);

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -43,7 +43,6 @@
  */
 @ProviderFor(EclipseAnnotationHandler.class)
 public class HandleData extends EclipseAnnotationHandler<Data> {
-	
 	private HandleGetter handleGetter = new HandleGetter();
 	private HandleSetter handleSetter = new HandleSetter();
 	private HandleEqualsAndHashCode handleEqualsAndHashCode = new HandleEqualsAndHashCode();

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -105,7 +105,7 @@ public boolean generateGetterForType(EclipseNode typeNode, EclipseNode pos, Acce
 		return true;
 	}
 	
-	public boolean fieldQualifiesForGetterGeneration(EclipseNode field) {
+	public static boolean fieldQualifiesForGetterGeneration(EclipseNode field) {
 		if (field.getKind() != Kind.FIELD) return false;
 		FieldDeclaration fieldDecl = (FieldDeclaration) field.get();
 		return filterField(fieldDecl);

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -74,6 +74,8 @@
 @ProviderFor(JavacAnnotationHandler.class)
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleBuilder extends JavacAnnotationHandler<Builder> {
+	private HandleConstructor handleConstructor = new HandleConstructor();
+	
 	private static final boolean toBoolean(Object expr, boolean defaultValue) {
 		if (expr == null) return defaultValue;
 		if (expr instanceof JCLiteral) return ((Integer) ((JCLiteral) expr).value) != 0;
@@ -176,7 +178,7 @@ private static class BuilderFieldData {
 				allFields.append(fieldNode);
 			}
 			
-			new HandleConstructor().generateConstructor(tdParent, AccessLevel.PACKAGE, List.<JCAnnotation>nil(), allFields.toList(), false, null, SkipIfConstructorExists.I_AM_BUILDER, annotationNode);
+			handleConstructor.generateConstructor(tdParent, AccessLevel.PACKAGE, List.<JCAnnotation>nil(), allFields.toList(), false, null, SkipIfConstructorExists.I_AM_BUILDER, annotationNode);
 			
 			returnType = namePlusTypeParamsToTypeReference(tdParent.getTreeMaker(), td.name, td.typarams);
 			typeParams = td.typarams;

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -95,7 +95,7 @@ public void generateGetterForType(JavacNode typeNode, JavacNode errorNode, Acces
 		}
 	}
 	
-	public boolean fieldQualifiesForGetterGeneration(JavacNode field) {
+	public static boolean fieldQualifiesForGetterGeneration(JavacNode field) {
 		if (field.getKind() != Kind.FIELD) return false;
 		JCVariableDecl fieldDecl = (JCVariableDecl) field.get();
 		//Skip fields that start with $

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -818,7 +818,7 @@ private static GetterMethod findGetter(JavacNode field) {
 		
 		// Check if the class has a @Getter annotation.
 		
-		if (!hasGetterAnnotation && new HandleGetter().fieldQualifiesForGetterGeneration(field)) {
+		if (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {
 			//Check if the class has @Getter or @Data annotation.
 			
 			JavacNode containingType = field.up();

File: src/core/lombok/javac/apt/EmptyLombokFileObject.java
Patch:
@@ -57,7 +57,7 @@ public EmptyLombokFileObject(String name, Kind kind) {
 	}
 	
 	@Override public URI toUri() {
-		return URI.create(name);
+		return URI.create("file://" + name);
 	}
 	
 	@Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {

File: src/core/lombok/javac/apt/LombokFileObjects.java
Patch:
@@ -106,7 +106,8 @@ private LombokFileObjects() {}
 		"com.google.devtools.build.buildjar.javac.BlazeJavacMain$ClassloaderMaskingFileManager",
 		"com.google.devtools.build.java.turbine.javac.JavacTurbineCompiler$ClassloaderMaskingFileManager",
 		"org.netbeans.modules.java.source.parsing.ProxyFileManager",
-		"com.sun.tools.javac.api.ClientCodeWrapper$WrappedStandardJavaFileManager"
+		"com.sun.tools.javac.api.ClientCodeWrapper$WrappedStandardJavaFileManager",
+		"com.sun.tools.javac.main.DelegatingJavaFileManager$DelegatingSJFM" // IntelliJ + JDK10
 	);
 	
 	static Compiler getCompiler(JavaFileManager jfm) {

File: src/core/lombok/eclipse/handlers/HandleBuilderDefault.java
Patch:
@@ -39,7 +39,7 @@ public class HandleBuilderDefault extends EclipseAnnotationHandler<Builder.Defau
 		EclipseNode annotatedField = annotationNode.up();
 		if (annotatedField.getKind() != Kind.FIELD) return;
 		EclipseNode classWithAnnotatedField = annotatedField.up();
-		if (!hasAnnotation(Builder.class, classWithAnnotatedField)) {
+		if (!hasAnnotation(Builder.class, classWithAnnotatedField) && !hasAnnotation("lombok.experimental.Builder", classWithAnnotatedField)) {
 			annotationNode.addWarning("@Builder.Default requires @Builder on the class for it to mean anything.");
 		}
 	}

File: src/delombok/lombok/delombok/DocCommentIntegrator.java
Patch:
@@ -74,7 +74,7 @@ public List<CommentInfo> integrate(List<CommentInfo> comments, JCCompilationUnit
 		return out;
 	}
 	
-	private static final Pattern CONTENT_STRIPPER = Pattern.compile("^(?:\\s*\\*)?[ \\t]*(.*?)$", Pattern.MULTILINE);
+	private static final Pattern CONTENT_STRIPPER = Pattern.compile("^(?:\\s*\\*)?(.*?)$", Pattern.MULTILINE);
 	@SuppressWarnings("unchecked") private boolean attach(JCCompilationUnit top, final JCTree node, CommentInfo cmt) {
 		String docCommentContent = cmt.content;
 		if (docCommentContent.startsWith("/**")) docCommentContent = docCommentContent.substring(3);

File: test/transform/resource/after-delombok/JavadocGenerally.java
Patch:
@@ -9,6 +9,9 @@
 class JavadocGenerally {
 	/**
 	 * Doc on field
+	 * <pre>
+	 * 	// code
+	 * </pre>
 	 */
 	private int someField;
 	/**

File: test/transform/resource/before/JavadocGenerally.java
Patch:
@@ -11,6 +11,9 @@
 class JavadocGenerally {
 	/**
 	 * Doc on field
+	 * <pre>
+	 * 	// code
+	 * </pre>
 	 */
 	private int someField;
 

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -185,8 +185,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {
 			TypeDeclaration td = (TypeDeclaration) tdParent.get();
 			
 			List<EclipseNode> allFields = new ArrayList<EclipseNode>();
-			@SuppressWarnings("deprecation")
-			boolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation(lombok.experimental.Value.class, parent));
+			boolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation("lombok.experimental.Value", parent));
 			for (EclipseNode fieldNode : HandleConstructor.findAllFields(tdParent, true)) {
 				FieldDeclaration fd = (FieldDeclaration) fieldNode.get();
 				EclipseNode isDefault = findAnnotation(Builder.Default.class, fieldNode);

File: src/core/lombok/javac/handlers/HandleBuilderDefault.java
Patch:
@@ -16,12 +16,11 @@
 @ProviderFor(JavacAnnotationHandler.class)
 @HandlerPriority(-1025) //HandleBuilder's level, minus one.
 public class HandleBuilderDefault extends JavacAnnotationHandler<Builder.Default> {
-	@SuppressWarnings("deprecation")
 	@Override public void handle(AnnotationValues<Builder.Default> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		JavacNode annotatedField = annotationNode.up();
 		if (annotatedField.getKind() != Kind.FIELD) return;
 		JavacNode classWithAnnotatedField = annotatedField.up();
-		if (!hasAnnotation(Builder.class, classWithAnnotatedField) && !hasAnnotation(lombok.experimental.Builder.class, classWithAnnotatedField)) {
+		if (!hasAnnotation(Builder.class, classWithAnnotatedField) && !hasAnnotation("lombok.experimental.Builder", classWithAnnotatedField)) {
 			annotationNode.addWarning("@Builder.Default requires @Builder on the class for it to mean anything.");
 			deleteAnnotationIfNeccessary(annotationNode, Builder.Default.class);
 		}

File: src/core/lombok/core/LombokInternalAliasing.java
Patch:
@@ -51,6 +51,7 @@ public static String processAliases(String in) {
 		Map<String, String> m2 = new HashMap<String, String>();
 		m2.put("lombok.experimental.Value", "lombok.Value");
 		m2.put("lombok.experimental.Builder", "lombok.Builder");
+		m2.put("lombok.experimental.var", "lombok.var");
 		m2.put("lombok.Delegate", "lombok.experimental.Delegate");
 		ALIASES = Collections.unmodifiableMap(m2);
 	}

File: src/eclipseAgent/lombok/eclipse/agent/PatchVal.java
Patch:
@@ -212,7 +212,7 @@ public static boolean handleValForLocalDeclaration(LocalDeclaration local, Block
 	}
 	
 	private static boolean isVar(LocalDeclaration local, BlockScope scope) {
-		return is(local.type, scope, "lombok.experimental.var");
+		return is(local.type, scope, "lombok.experimental.var") || is(local.type, scope, "lombok.var");
 	}
 	
 	private static boolean isVal(LocalDeclaration local, BlockScope scope) {

File: src/eclipseAgent/lombok/eclipse/agent/PatchValEclipse.java
Patch:
@@ -103,7 +103,7 @@ public static void copyInitializationOfLocalDeclaration(Parser parser) {
 	}
 	
 	private static boolean couldBeVar(TypeReference type) {
-		return PatchVal.couldBe("lombok.experimental.var", type);
+		return PatchVal.couldBe("lombok.experimental.var", type) || PatchVal.couldBe("lombok.var", type);
 	}
 	
 	public static void addFinalAndValAnnotationToSingleVariableDeclaration(Object converter, SingleVariableDeclaration out, LocalDeclaration in) {

File: test/transform/resource/after-ecj/VarComplex.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.experimental.var;
+import lombok.var;
 public class VarComplex {
   private String field = "";
   private static final int CONSTANT = 20;

File: test/transform/resource/after-ecj/VarInFor.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.experimental.var;
+import lombok.var;
 public class VarInFor {
   public VarInFor() {
     super();

File: test/transform/resource/after-ecj/VarInForOld.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.experimental.var;
+import lombok.var;
 public class VarInForOld {
   public VarInForOld() {
     super();

File: test/transform/resource/after-ecj/VarNullInit.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.experimental.var;
+import lombok.var;
 public class VarNullInit {
   public VarNullInit() {
     super();

File: test/transform/resource/before/VarComplex.java
Patch:
@@ -1,5 +1,4 @@
-//CONF: lombok.var.flagUsage = ALLOW
-import lombok.experimental.var;
+import lombok.var;
 
 public class VarComplex {
 	private String field = "";

File: test/transform/resource/before/VarInFor.java
Patch:
@@ -1,5 +1,4 @@
-//CONF: lombok.var.flagUsage = ALLOW
-import lombok.experimental.var;
+import lombok.var;
 
 public class VarInFor {
 	public void enhancedFor() {

File: test/transform/resource/before/VarInForOld.java
Patch:
@@ -1,5 +1,4 @@
-//CONF: lombok.var.flagUsage = ALLOW
-import lombok.experimental.var;
+import lombok.var;
 
 public class VarInForOld {
 	public void oldFor() {

File: test/transform/resource/before/VarModifier.java
Patch:
@@ -1,4 +1,3 @@
-//CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
 public class VarModifier {

File: test/transform/resource/before/VarNullInit.java
Patch:
@@ -1,5 +1,4 @@
-//CONF: lombok.var.flagUsage = ALLOW
-import lombok.experimental.var;
+import lombok.var;
 
 public class VarNullInit {
 	void method() {

File: test/transform/resource/before/VarWarning.java
Patch:
@@ -1,6 +1,5 @@
 //CONF: lombok.var.flagUsage = WARNING
-//skip compare contents
-import lombok.experimental.var;
+import lombok.var;
 
 public class VarWarning {
 	public void isOkay() {

File: src/core9/module-info.java
Patch:
@@ -12,7 +12,6 @@
 	exports lombok.extern.slf4j;
 	
 	provides javax.annotation.processing.Processor with lombok.launch.AnnotationProcessorHider.AnnotationProcessor;
-//	provides javax.annotation.processing.Processor with lombok.launch.AnnotationProcessorHider.ClaimingProcessor;
 	provides org.mapstruct.ap.spi.AstModifyingAnnotationProcessor with lombok.launch.AnnotationProcessorHider.AstModificationNotifier;
 }
 

File: src/core/lombok/Cleanup.java
Patch:
@@ -61,10 +61,10 @@
  *                 outStream.write(b, 0, r);
  *             }
  *         } finally {
- *             if (out != null) out.close();
+ *             if (outStream != null) outStream.close();
  *         }
  *     } finally {
- *         if (in != null) in.close();
+ *         if (inStream != null) inStream.close();
  *     }
  * }
  * </pre>

File: src/core/lombok/core/Version.java
Patch:
@@ -30,7 +30,7 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "1.16.19-issue-879";
+	private static final String VERSION = "1.16.19";
 	private static final String RELEASE_NAME = "Edgy Guinea Pig";
 //	private static final String RELEASE_NAME = "Dancing Elephant";
 	

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -216,8 +216,8 @@ private static void patchSyntaxAndOccurrencesHighlighting(ScriptManager sm) {
 	
 	private static void patchDisableLombokForCodeFormatterAndCleanup(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.setSymbolDuringMethodCall()
-				.target(new MethodTarget("org.eclipse.jdt.internal.formatter.DefaultCodeFormatter", "formatCompilationUnit"))
-				//.target(new MethodTarget("org.eclipse.jdt.internal.formatter.DefaultCodeFormatter", "parseSourceCode"))
+				//.target(new MethodTarget("org.eclipse.jdt.internal.formatter.DefaultCodeFormatter", "formatCompilationUnit"))
+				.target(new MethodTarget("org.eclipse.jdt.internal.formatter.DefaultCodeFormatter", "parseSourceCode"))
 				.callToWrap(new Hook("org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil", "parseCompilationUnit", "org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration", "char[]", "java.util.Map", "boolean"))
 				.symbol("lombok.disable")
 				.build());

File: test/transform/resource/after-delombok/BuilderWithExistingBuilderClass.java
Patch:
@@ -24,7 +24,7 @@ public BuilderWithExistingBuilderClassBuilder<Z> arg3(final String arg3) {
 			return this;
 		}
 		@java.lang.SuppressWarnings("all")
-		public BuilderWithExistingBuilderClass build() {
+		public BuilderWithExistingBuilderClass<String, Z> build() {
 			return BuilderWithExistingBuilderClass.<Z>staticMethod(arg1, arg2, arg3);
 		}
 		@java.lang.Override

File: test/transform/resource/after-delombok/BuilderWithToBuilder.java
Patch:
@@ -165,7 +165,7 @@ public StaticWithToBuilderBuilder<Z> bar(final Z bar) {
 			return this;
 		}
 		@java.lang.SuppressWarnings("all")
-		public StaticWithToBuilder build() {
+		public StaticWithToBuilder<Z, String> build() {
 			return StaticWithToBuilder.<Z>test(mOne, bar);
 		}
 		@java.lang.Override

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -24,7 +24,6 @@
 import java.io.File;
 import java.io.StringWriter;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -131,14 +130,14 @@ public boolean transformCode(Collection<CompilerMessage> messages, StringWriter
 	
 	private FileSystem createFileSystem(File file) {
 		List<String> classpath = new ArrayList<String>();
-		classpath.addAll(Arrays.asList(System.getProperty("sun.boot.class.path").split(File.pathSeparator)));
 		for (Iterator<String> i = classpath.iterator(); i.hasNext();) {
 			if (FileSystem.getClasspath(i.next(), "UTF-8", null) == null) {
 				i.remove();
 			}
 		}
 		if (new File("bin").exists()) classpath.add("bin");
 		classpath.add("dist/lombok.jar");
+		classpath.add("lib/oracleJDK8Environment/rt.jar");
 		classpath.add("lib/test/commons-logging-commons-logging.jar");
 		classpath.add("lib/test/org.slf4j-slf4j-api.jar");
 		classpath.add("lib/test/org.slf4j-slf4j-ext.jar");

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -561,7 +561,7 @@ private Jdk9Plus(Log log, Messager messager, Field errorCount, Field warningCoun
 		
 		@Override void error1(DiagnosticPosition pos, String message) {
 			try {
-				logMethod.invoke(multiple, pos, "proc.messager", message);
+				logMethod.invoke(log, multiple, pos, "proc.messager", new Object[] { message });
 			} catch (Throwable t) {}
 		}
 	}

File: src/delombok/lombok/delombok/DocCommentIntegrator.java
Patch:
@@ -29,6 +29,7 @@
 
 import lombok.javac.CommentInfo;
 import lombok.javac.Javac;
+import lombok.javac.PackageName;
 import lombok.javac.handlers.JavacHandlerUtil;
 
 import com.sun.tools.javac.parser.Tokens.Comment;
@@ -120,7 +121,8 @@ static void attach(final JCTree node, String docCommentContent, Object map_) {
 	}
 	
 	private JCTree findJavadocableNodeOnOrAfter(JCCompilationUnit unit, int endPos) {
-		if (unit.pid != null && endPos <= unit.pid.pos) return null;
+		JCTree pid = PackageName.getPackageNode(unit);
+		if (pid != null && endPos <= pid.pos) return null;
 		Iterator<JCTree> it = unit.defs.iterator();
 		
 		while (it.hasNext()) {

File: src/utils/lombok/javac/CommentCatcher.java
Patch:
@@ -95,8 +95,10 @@ private static void setInCompiler(JavaCompiler compiler, Context context) {
 				parserFactory = Class.forName("lombok.javac.java6.CommentCollectingParserFactory");
 			} else if (javaCompilerVersion == 7) {
 				parserFactory = Class.forName("lombok.javac.java7.CommentCollectingParserFactory");
-			} else {
+			} else if (javaCompilerVersion == 8) {
 				parserFactory = Class.forName("lombok.javac.java8.CommentCollectingParserFactory");
+			} else {
+				parserFactory = Class.forName("lombok.javac.java9.CommentCollectingParserFactory");
 			}
 			parserFactory.getMethod("setInCompiler", JavaCompiler.class, Context.class).invoke(null, compiler, context);
 		} catch (InvocationTargetException e) {

File: test/transform/resource/after-delombok/GeneratedJavaxOnLombokOn.java
Patch:
@@ -1,3 +1,4 @@
+//version :8
 class GeneratedJavaxOnLombokOn {
 	int x;
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/GeneratedOffJavaxOn.java
Patch:
@@ -1,3 +1,4 @@
+//version :8
 class GeneratedOffJavaxOn {
 	int x;
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/before/GeneratedJavaxOnLombokOn.java
Patch:
@@ -1,5 +1,6 @@
 //CONF: lombok.addJavaxGeneratedAnnotation = true
 //CONF: lombok.addLombokGeneratedAnnotation = true
+//version :8
 class GeneratedJavaxOnLombokOn {
 	@lombok.Getter
 	int x;

File: test/transform/resource/before/GeneratedOffJavaxOn.java
Patch:
@@ -1,5 +1,6 @@
 //CONF: lombok.addGeneratedAnnotation = false
 //CONF: lombok.addJavaxGeneratedAnnotation = true
+//version :8
 class GeneratedOffJavaxOn {
 	@lombok.Getter
 	int x;

File: test/transform/resource/after-delombok/BuilderSingularMaps.java
Patch:
@@ -6,7 +6,6 @@ class BuilderSingularMaps<K, V> {
 	@SuppressWarnings("all")
 	private Map rawMap;
 	private Map<String, V> stringMap;
-	@java.beans.ConstructorProperties({"women", "men", "rawMap", "stringMap"})
 	@SuppressWarnings("all")
 	BuilderSingularMaps(Map<K, V> women, SortedMap<K, ? extends Number> men, Map rawMap, Map<String, V> stringMap) {
 		this.women = women;

File: test/transform/resource/after-delombok/ClassNamedAfterGetter.java
Patch:
@@ -1,7 +1,6 @@
 class GetFoo {
 	private int foo;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getFoo() {
 		return this.foo;
 	}

File: test/transform/resource/after-delombok/CommentsInterspersed.java
Patch:
@@ -12,7 +12,6 @@ public class CommentsInterspersed {
 		javascript;
 	}-*/
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public String getTest() {
 		return this.test;
 	}

File: test/transform/resource/after-delombok/ConstructorsConfiguration.java
Patch:
@@ -1,7 +1,6 @@
 class ConstructorsConfiguration {
 	int x;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public ConstructorsConfiguration(final int x) {
 		this.x = x;
 	}

File: test/transform/resource/after-delombok/DelegateOnGetter.java
Patch:
@@ -5,7 +5,6 @@ private interface Bar {
 		int getInt();
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public Bar getBar() {
 		java.lang.Object value = this.bar.get();
 		if (value == null) {
@@ -27,12 +26,10 @@ public int getInt() {
 		return (Bar) (value == this.bar ? null : value);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setList(final java.util.ArrayList<java.lang.String> list) {
 		this.getBar().setList(list);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getInt() {
 		return this.getBar().getInt();
 	}

File: test/transform/resource/after-delombok/DelegateOnGetterNone.java
Patch:
@@ -5,12 +5,10 @@ private interface Bar {
 		int getInt();
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setList(final java.util.ArrayList<java.lang.String> list) {
 		this.bar.setList(list);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getInt() {
 		return this.bar.getInt();
 	}

File: test/transform/resource/after-delombok/DelegateOnMethods.java
Patch:
@@ -7,7 +7,6 @@ public static interface Bar {
 	
 	@java.lang.SuppressWarnings("all")
 	
-	@javax.annotation.Generated("lombok")
 	
 	public void bar(final java.util.ArrayList<java.lang.String> list) {
 		this.getBar().bar(list);

File: test/transform/resource/after-delombok/DelegateTypesAndExcludes.java
Patch:
@@ -25,15 +25,13 @@ private static interface Bar {
 
 	@java.lang.SuppressWarnings("all")
 
-	@javax.annotation.Generated("lombok")
 
 	public void bar(final java.util.ArrayList<java.lang.String> list) {
 		this.bar.bar(list);
 	}
 
 	@java.lang.SuppressWarnings("all")
 
-	@javax.annotation.Generated("lombok")
 
 	public void foo() {
 		this.foo.foo();

File: test/transform/resource/after-delombok/DelegateWithDeprecated.java
Patch:
@@ -11,18 +11,15 @@ private interface Bar {
 	}
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void deprecatedAnnotation() {
 		this.bar.deprecatedAnnotation();
 	}
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void deprecatedComment() {
 		this.bar.deprecatedComment();
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void notDeprecated() {
 		this.bar.notDeprecated();
 	}

File: test/transform/resource/after-delombok/EncodingUsAscii.java
Patch:
@@ -3,7 +3,6 @@ class EncodingUsAscii {
 	String foo\u0e51\u0e51 = "\016\t\b ";
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public java.lang.String toString() {
 		return "EncodingUsAscii(foo\u0e51\u0e51=" + this.foo\u0e51\u0e51 + ")";
 	}

File: test/transform/resource/after-delombok/EncodingUtf8.java
Patch:
@@ -2,7 +2,6 @@ class EncodingUtf8 {
 	String foo๑๑ = "\016\t\b ";
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public java.lang.String toString() {
 		return "EncodingUtf8(foo๑๑=" + this.foo๑๑ + ")";
 	}

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithExistingMethods.java
Patch:
@@ -17,7 +17,6 @@ private boolean canEqual(Object other) {
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof EqualsAndHashCodeWithExistingMethods3)) return false;
@@ -29,7 +28,6 @@ public boolean equals(final java.lang.Object o) {
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int hashCode() {
 		final int PRIME = 59;
 		int result = super.hashCode();

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithOnParam.java
Patch:
@@ -9,7 +9,6 @@ class EqualsAndHashCodeWithOnParam {
 	String b;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public boolean equals(@Nullable final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof EqualsAndHashCodeWithOnParam)) return false;
@@ -27,13 +26,11 @@ public boolean equals(@Nullable final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	protected boolean canEqual(@Nullable final java.lang.Object other) {
 		return other instanceof EqualsAndHashCodeWithOnParam;
 	}
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int hashCode() {
 		final int PRIME = 59;
 		int result = 1;

File: test/transform/resource/after-delombok/FieldDefaultsViaConfigAndRequiredArgsConstructor.java
Patch:
@@ -1,8 +1,6 @@
 class FieldDefaultsViaConfigAndRequiredArgsConstructor {
 	final int x;
-	@java.beans.ConstructorProperties({"x"})
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public FieldDefaultsViaConfigAndRequiredArgsConstructor(final int x) {
 		this.x = x;
 	}

File: test/transform/resource/after-delombok/GenerateSuppressFBWarnings.java
Patch:
@@ -3,7 +3,6 @@ class GenerateSuppressFBWarnings {
 	int y;
 	@java.lang.SuppressWarnings("all")
 	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = "generated code")
-	@javax.annotation.Generated("lombok")
 	public int getY() {
 		return this.y;
 	}

File: test/transform/resource/after-delombok/GetterDeprecated.java
Patch:
@@ -7,7 +7,6 @@ class GetterDeprecated {
 	int javadoc;
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getAnnotation() {
 		return this.annotation;
 	}
@@ -16,7 +15,6 @@ public int getAnnotation() {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getJavadoc() {
 		return this.javadoc;
 	}

File: test/transform/resource/after-delombok/GetterLazy.java
Patch:
@@ -3,7 +3,6 @@ static class ValueType {
 	}
 	private final java.util.concurrent.atomic.AtomicReference<java.lang.Object> fieldName = new java.util.concurrent.atomic.AtomicReference<java.lang.Object>();
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public ValueType getFieldName() {
 		java.lang.Object value = this.fieldName.get();
 		if (value == null) {

File: test/transform/resource/after-delombok/GetterLazyInvalid.java
Patch:
@@ -13,7 +13,6 @@ class GetterLazyInvalidNone {
 class GetterLazyInvalidClass {
 	private final String fieldName = "";
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public String getFieldName() {
 		return this.fieldName;
 	}

File: test/transform/resource/after-delombok/GetterLazyTransient.java
Patch:
@@ -3,7 +3,6 @@ class GetterLazyTransient {
 	private final transient int transientField = 2;
 	private final transient int nonLazyTransientField = 3;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getNonTransientField() {
 		java.lang.Object value = this.nonTransientField.get();
 		if (value == null) {
@@ -19,7 +18,6 @@ public int getNonTransientField() {
 		return (java.lang.Integer) value;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getNonLazyTransientField() {
 		return this.nonLazyTransientField;
 	}

File: test/transform/resource/after-delombok/GetterNone.java
Patch:
@@ -2,7 +2,6 @@ class GetterNone {
 	int i;
 	int foo;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getI() {
 		return this.i;
 	}

File: test/transform/resource/after-delombok/GetterOnMethod.java
Patch:
@@ -6,21 +6,18 @@ class GetterOnMethod {
 	}
 	@Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getI() {
 		return this.i;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getJ() {
 		return this.j;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getK() {
 		return this.k;
 	}

File: test/transform/resource/after-delombok/GetterOnMethodErrors.java
Patch:
@@ -3,7 +3,6 @@ class PlaceFillerToMakeSurePositionIsRelevant {
 class GetterOnMethodErrors {
 	private int test;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getTest() {
 		return this.test;
 	}

File: test/transform/resource/after-delombok/GetterOnStatic.java
Patch:
@@ -2,12 +2,10 @@ class Getter {
 	static boolean foo;
 	static int bar;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public static boolean isFoo() {
 		return Getter.foo;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public static int getBar() {
 		return Getter.bar;
 	}

File: test/transform/resource/after-delombok/GetterPlain.java
Patch:
@@ -2,12 +2,10 @@ class GetterPlain {
 	int i;
 	int foo;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getI() {
 		return this.i;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getFoo() {
 		return this.foo;
 	}

File: test/transform/resource/after-delombok/GetterWithDollar.java
Patch:
@@ -1,7 +1,6 @@
 class GetterWithDollar1 {
 	int $i;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int get$i() {
 		return this.$i;
 	}
@@ -10,12 +9,10 @@ class GetterWithDollar2 {
 	int $i;
 	int i;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int get$i() {
 		return this.$i;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getI() {
 		return this.i;
 	}

File: test/transform/resource/after-delombok/LoggerCommons.java
Patch:
@@ -1,15 +1,12 @@
 class LoggerCommons {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommons.class);
 }
 class LoggerCommonsWithImport {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommonsWithImport.class);
 }
 class LoggerCommonsWithDifferentName {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog("DifferentName");
 }

File: test/transform/resource/after-delombok/LoggerConfig.java
Patch:
@@ -1,5 +1,4 @@
 class LoggerWithConfig {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private final org.slf4j.Logger myLogger = org.slf4j.LoggerFactory.getLogger(LoggerWithConfig.class);
 }

File: test/transform/resource/after-delombok/LoggerJul.java
Patch:
@@ -1,15 +1,12 @@
 class LoggerJul {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJul.class.getName());
 }
 class LoggerJulWithImport {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJulWithImport.class.getName());
 }
 class LoggerJulWithDifferentName {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("DifferentName");
 }

File: test/transform/resource/after-delombok/LoggerLog4j.java
Patch:
@@ -1,15 +1,12 @@
 class LoggerLog4j {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4j.class);
 }
 class LoggerLog4jWithImport {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4jWithImport.class);
 }
 class LoggerLog4jWithDifferentName {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger("DifferentName");
 }

File: test/transform/resource/after-delombok/LoggerLog4j2.java
Patch:
@@ -1,15 +1,12 @@
 class LoggerLog4j2 {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LoggerLog4j2.class);
 }
 class LoggerLog4j2WithImport {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LoggerLog4j2WithImport.class);
 }
 class LoggerLog4j2WithDifferentName {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger("DifferentName");
 }

File: test/transform/resource/after-delombok/LoggerSlf4jTypes.java
Patch:
@@ -5,19 +5,16 @@ interface LoggerSlf4jTypesInterface {
 enum LoggerSlf4jTypesEnum {
 	;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnum.class);
 }
 enum LoggerSlf4jTypesEnumWithElement {
 	FOO;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnumWithElement.class);
 }
 interface LoggerSlf4jTypesInterfaceOuter {
 	class Inner {
 		@java.lang.SuppressWarnings("all")
-		@javax.annotation.Generated("lombok")
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }

File: test/transform/resource/after-delombok/LoggerSlf4jWithPackage.java
Patch:
@@ -1,13 +1,11 @@
 package before;
 class LoggerSlf4jWithPackage {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jWithPackage.class);
 }
 class LoggerSlf4jWithPackageOuter {
 	static class Inner {
 		@java.lang.SuppressWarnings("all")
-		@javax.annotation.Generated("lombok")
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }

File: test/transform/resource/after-delombok/LoggerXSlf4j.java
Patch:
@@ -1,15 +1,12 @@
 class LoggerXSlf4j {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4j.class);
 }
 class LoggerXSlf4jWithImport {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4jWithImport.class);
 }
 class LoggerXSlf4jWithDifferentName {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger("DifferentName");
 }

File: test/transform/resource/after-delombok/MixGetterVal.java
Patch:
@@ -9,7 +9,6 @@ public void test() {
 		m(a);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/NoArgsConstructorForce.java
Patch:
@@ -5,7 +5,6 @@ public class NoArgsConstructorForce {
 	private final java.util.List<?>[] fullQualifiedList;
 	
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public NoArgsConstructorForce() {
 		this.i = null;
 		this.o = null;

File: test/transform/resource/after-delombok/NonNullWithAlternateException.java
Patch:
@@ -8,7 +8,6 @@ public void testMethod(@lombok.NonNull String arg) {
 		System.out.println(arg);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setTest(@lombok.NonNull final String test) {
 		if (test == null) {
 			throw new java.lang.IllegalArgumentException("test is null");

File: test/transform/resource/after-delombok/SetterAlreadyExists.java
Patch:
@@ -23,7 +23,6 @@ class Setter5 {
 	void setFoo() {
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setFoo(final String foo) {
 		this.foo = foo;
 	}
@@ -33,7 +32,6 @@ class Setter6 {
 	void setFoo(String foo, int x) {
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setFoo(final String foo) {
 		this.foo = foo;
 	}

File: test/transform/resource/after-delombok/SetterDeprecated.java
Patch:
@@ -7,7 +7,6 @@ class SetterDeprecated {
 	int javadoc;
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setAnnotation(final int annotation) {
 		this.annotation = annotation;
 	}
@@ -16,7 +15,6 @@ public void setAnnotation(final int annotation) {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setJavadoc(final int javadoc) {
 		this.javadoc = javadoc;
 	}

File: test/transform/resource/after-delombok/SetterOnMethodOnParam.java
Patch:
@@ -6,21 +6,18 @@ class SetterOnMethodOnParam {
 	}
 	@Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setI(final int i) {
 		this.i = i;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setJ(@Test final int j) {
 		this.j = j;
 	}
 	@java.lang.Deprecated
 	@Test
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setK(@Test final int k) {
 		this.k = k;
 	}

File: test/transform/resource/after-delombok/SetterOnStatic.java
Patch:
@@ -2,12 +2,10 @@ class Setter {
 	static boolean foo;
 	static int bar;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public static void setFoo(final boolean foo) {
 		Setter.foo = foo;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public static void setBar(final int bar) {
 		Setter.bar = bar;
 	}

File: test/transform/resource/after-delombok/SetterPlain.java
Patch:
@@ -2,12 +2,10 @@ class SetterPlain {
 	int i;
 	int foo;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setI(final int i) {
 		this.i = i;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setFoo(final int foo) {
 		this.foo = foo;
 	}

File: test/transform/resource/after-delombok/SetterWithDollar.java
Patch:
@@ -3,7 +3,6 @@ class SetterWithDollar1 {
 	
 	@java.lang.SuppressWarnings("all")
 	
-	@javax.annotation.Generated("lombok")
 	
 	public void set$i(final int $i) {
 		this.$i = $i;
@@ -15,13 +14,11 @@ class SetterWithDollar2 {
 	
 	@java.lang.SuppressWarnings("all")
 	
-	@javax.annotation.Generated("lombok")
 	
 	public void set$i(final int $i) {
 		this.$i = $i;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public void setI(final int i) {
 		this.i = i;
 	}

File: test/transform/resource/after-delombok/SimpleTypeResolution.java
Patch:
@@ -5,7 +5,6 @@ class SimpleTypeResolutionFail {
 class SimpleTypeResolutionSuccess {
 	private int x;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/SynchronizedPlain.java
Patch:
@@ -1,6 +1,5 @@
 class SynchronizedPlain1 {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private final java.lang.Object $lock = new java.lang.Object[0];
 	void test() {
 		synchronized (this.$lock) {
@@ -15,7 +14,6 @@ void test2() {
 }
 class SynchronizedPlain2 {
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	private static final java.lang.Object $LOCK = new java.lang.Object[0];
 	static void test() {
 		synchronized (SynchronizedPlain2.$LOCK) {

File: test/transform/resource/after-delombok/ToStringPlain.java
Patch:
@@ -3,7 +3,6 @@ class ToString1 {
 	String name;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public java.lang.String toString() {
 		return "ToString1(x=" + this.x + ", name=" + this.name + ")";
 	}
@@ -13,7 +12,6 @@ class ToString2 {
 	String name;
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public java.lang.String toString() {
 		return "ToString2(x=" + this.x + ", name=" + this.name + ")";
 	}

File: test/transform/resource/after-delombok/TrickyTypeResolution.java
Patch:
@@ -14,7 +14,6 @@ class TrickyDoNothing2 {
 class TrickySuccess {
 	int x;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public int getX() {
 		return this.x;
 	}

File: test/transform/resource/after-delombok/WitherAlreadyExists.java
Patch:
@@ -33,7 +33,6 @@ void withFoo() {
 	Wither5(String foo) {
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public Wither5 withFoo(final String foo) {
 		return this.foo == foo ? this : new Wither5(foo);
 	}
@@ -45,7 +44,6 @@ void withFoo(String foo, int x) {
 	Wither6(String foo) {
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public Wither6 withFoo(final String foo) {
 		return this.foo == foo ? this : new Wither6(foo);
 	}

File: test/transform/resource/after-delombok/WitherDeprecated.java
Patch:
@@ -9,7 +9,6 @@ class WitherDeprecated {
 	}
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherDeprecated withAnnotation(final int annotation) {
 		return this.annotation == annotation ? this : new WitherDeprecated(annotation, this.javadoc);
 	}
@@ -18,7 +17,6 @@ public WitherDeprecated withAnnotation(final int annotation) {
 	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherDeprecated withJavadoc(final int javadoc) {
 		return this.javadoc == javadoc ? this : new WitherDeprecated(this.annotation, javadoc);
 	}

File: test/transform/resource/after-delombok/WitherPlain.java
Patch:
@@ -6,12 +6,10 @@ class WitherPlain {
 		this.foo = foo;
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherPlain withI(final int i) {
 		return this.i == i ? this : new WitherPlain(i, this.foo);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherPlain withFoo(final int foo) {
 		return this.foo == foo ? this : new WitherPlain(this.i, foo);
 	}

File: test/transform/resource/after-delombok/WitherWithAbstract.java
Patch:
@@ -1,6 +1,5 @@
 abstract class WitherWithAbstract {
 	String foo;
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public abstract WitherWithAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-delombok/WitherWithGenerics.java
Patch:
@@ -6,17 +6,14 @@ class WitherWithGenerics<T, J extends T, L extends java.lang.Number> {
 	public WitherWithGenerics(J test, java.util.List<L> test2, java.util.List<? extends L> test3) {
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherWithGenerics<T, J, L> withTest(final J test) {
 		return this.test == test ? this : new WitherWithGenerics<T, J, L>(test, this.test2, this.test3);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherWithGenerics<T, J, L> withTest2(final java.util.List<L> test2) {
 		return this.test2 == test2 ? this : new WitherWithGenerics<T, J, L>(this.test, test2, this.test3);
 	}
 	@java.lang.SuppressWarnings("all")
-	@javax.annotation.Generated("lombok")
 	public WitherWithGenerics<T, J, L> withTest3(final java.util.List<? extends L> test3) {
 		return this.test3 == test3 ? this : new WitherWithGenerics<T, J, L>(this.test, this.test2, test3);
 	}

File: test/transform/resource/after-ecj/ClassNamedAfterGetter.java
Patch:
@@ -3,7 +3,7 @@ class GetFoo {
   GetFoo() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getFoo() {
+  public @java.lang.SuppressWarnings("all") int getFoo() {
     return this.foo;
   }
 }

File: test/transform/resource/after-ecj/CommentsInterspersed.java
Patch:
@@ -6,7 +6,7 @@ public CommentsInterspersed() {
     super();
   }
   public native void gwtTest();
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") String getTest() {
+  public @java.lang.SuppressWarnings("all") String getTest() {
     return this.test;
   }
 }

File: test/transform/resource/after-ecj/ConstructorsConfiguration.java
Patch:
@@ -1,6 +1,6 @@
 @lombok.AllArgsConstructor class ConstructorsConfiguration {
   int x;
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") ConstructorsConfiguration(final int x) {
+  public @java.lang.SuppressWarnings("all") ConstructorsConfiguration(final int x) {
     super();
     this.x = x;
   }

File: test/transform/resource/after-ecj/ConstructorsWithAccessors.java
Patch:
@@ -3,7 +3,7 @@
   int pUpper;
   int _huh;
   int __huh2;
-  public @java.beans.ConstructorProperties({"plower", "upper", "huh", "_huh2"}) @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") ConstructorsWithAccessors(final int plower, final int upper, final int huh, final int _huh2) {
+  public @java.lang.SuppressWarnings("all") ConstructorsWithAccessors(final int plower, final int upper, final int huh, final int _huh2) {
     super();
     this.plower = plower;
     this.pUpper = upper;
@@ -16,7 +16,7 @@
   @lombok.NonNull Integer pUpper;
   @lombok.NonNull Integer _huh;
   final @lombok.NonNull Integer __huh2;
-  public @java.beans.ConstructorProperties({"plower", "upper", "huh", "_huh2"}) @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") ConstructorsWithAccessorsNonNull(final @lombok.NonNull Integer plower, final @lombok.NonNull Integer upper, final @lombok.NonNull Integer huh, final @lombok.NonNull Integer _huh2) {
+  public @java.lang.SuppressWarnings("all") ConstructorsWithAccessorsNonNull(final @lombok.NonNull Integer plower, final @lombok.NonNull Integer upper, final @lombok.NonNull Integer huh, final @lombok.NonNull Integer _huh2) {
     super();
     if ((plower == null))
         {

File: test/transform/resource/after-ecj/DataOnEnum.java
Patch:
@@ -3,13 +3,13 @@
   private final String someField;
   <clinit>() {
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") String getSomeField() {
+  public @java.lang.SuppressWarnings("all") String getSomeField() {
     return this.someField;
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") java.lang.String toString() {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
     return (("DataOnEnum(someField=" + this.getSomeField()) + ")");
   }
-  private @java.beans.ConstructorProperties({"someField"}) @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") DataOnEnum(final String someField) {
+  private @java.lang.SuppressWarnings("all") DataOnEnum(final String someField) {
     super();
     this.someField = someField;
   }

File: test/transform/resource/after-ecj/DelegateOnGetter.java
Patch:
@@ -9,7 +9,7 @@ private interface Bar {
   DelegateOnGetter() {
     super();
   }
-  public @Delegate @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") Bar getBar() {
+  public @Delegate @java.lang.SuppressWarnings("all") Bar getBar() {
     java.lang.Object value = this.bar.get();
     if ((value == null))
         {
@@ -35,10 +35,10 @@ public int getInt() {
         }
     return (Bar) ((value == this.bar) ? null : value);
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getInt() {
+  public @java.lang.SuppressWarnings("all") int getInt() {
     return this.getBar().getInt();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setList(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") void setList(final java.util.ArrayList<java.lang.String> list) {
     this.getBar().setList(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnGetterNone.java
Patch:
@@ -10,10 +10,10 @@ private interface Bar {
   DelegateOnGetterNone() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getInt() {
+  public @java.lang.SuppressWarnings("all") int getInt() {
     return this.bar.getInt();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setList(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") void setList(final java.util.ArrayList<java.lang.String> list) {
     this.bar.setList(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateOnMethods.java
Patch:
@@ -7,7 +7,7 @@ public static interface Bar {
     super();
   }
   public abstract @Delegate Bar getBar();
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void bar(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") void bar(final java.util.ArrayList<java.lang.String> list) {
     this.getBar().bar(list);
   }
 }

File: test/transform/resource/after-ecj/DelegateTypesAndExcludes.java
Patch:
@@ -27,10 +27,10 @@ private static interface Bar {
   DelegatePlain() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void bar(final java.util.ArrayList<java.lang.String> list) {
+  public @java.lang.SuppressWarnings("all") void bar(final java.util.ArrayList<java.lang.String> list) {
     this.bar.bar(list);
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void foo() {
+  public @java.lang.SuppressWarnings("all") void foo() {
     this.foo.foo();
   }
 }

File: test/transform/resource/after-ecj/DelegateWithDeprecated.java
Patch:
@@ -9,13 +9,13 @@ private interface Bar {
   DelegateWithDeprecated() {
     super();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void deprecatedAnnotation() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void deprecatedAnnotation() {
     this.bar.deprecatedAnnotation();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void deprecatedComment() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void deprecatedComment() {
     this.bar.deprecatedComment();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void notDeprecated() {
+  public @java.lang.SuppressWarnings("all") void notDeprecated() {
     this.bar.notDeprecated();
   }
 }

File: test/transform/resource/after-ecj/EqualsAndHashCodeWithExistingMethods.java
Patch:
@@ -24,7 +24,7 @@ public boolean equals(Object other) {
   private boolean canEqual(Object other) {
     return true;
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") boolean equals(final java.lang.Object o) {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") boolean equals(final java.lang.Object o) {
     if ((o == this))
         return true;
     if ((! (o instanceof EqualsAndHashCodeWithExistingMethods3)))
@@ -38,7 +38,7 @@ private boolean canEqual(Object other) {
         return false;
     return true;
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
     final int PRIME = 59;
     int result = super.hashCode();
     result = ((result * PRIME) + this.x);

File: test/transform/resource/after-ecj/EqualsAndHashCodeWithOnParam.java
Patch:
@@ -10,7 +10,7 @@
   EqualsAndHashCodeWithOnParam() {
     super();
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") boolean equals(final @Nullable java.lang.Object o) {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") boolean equals(final @Nullable java.lang.Object o) {
     if ((o == this))
         return true;
     if ((! (o instanceof EqualsAndHashCodeWithOnParam)))
@@ -34,10 +34,10 @@
         return false;
     return true;
   }
-  protected @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") boolean canEqual(final @Nullable java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final @Nullable java.lang.Object other) {
     return (other instanceof EqualsAndHashCodeWithOnParam);
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
     final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.x);

File: test/transform/resource/after-ecj/FieldDefaultsViaConfigAndRequiredArgsConstructor.java
Patch:
@@ -1,6 +1,6 @@
 @lombok.RequiredArgsConstructor class FieldDefaultsViaConfigAndRequiredArgsConstructor {
   final int x;
-  public @java.beans.ConstructorProperties({"x"}) @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") FieldDefaultsViaConfigAndRequiredArgsConstructor(final int x) {
+  public @java.lang.SuppressWarnings("all") FieldDefaultsViaConfigAndRequiredArgsConstructor(final int x) {
     super();
     this.x = x;
   }

File: test/transform/resource/after-ecj/GenerateSuppressFBWarnings.java
Patch:
@@ -3,7 +3,7 @@ class GenerateSuppressFBWarnings {
   GenerateSuppressFBWarnings() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = "generated code") @javax.annotation.Generated("lombok") int getY() {
+  public @java.lang.SuppressWarnings("all") @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = "generated code") int getY() {
     return this.y;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/GetterDeprecated.java
Patch:
@@ -5,10 +5,10 @@ class GetterDeprecated {
   GetterDeprecated() {
     super();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getAnnotation() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") int getAnnotation() {
     return this.annotation;
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getJavadoc() {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") int getJavadoc() {
     return this.javadoc;
   }
 }

File: test/transform/resource/after-ecj/GetterEnum.java
Patch:
@@ -7,13 +7,13 @@
   private final @Getter String name;
   <clinit>() {
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getId() {
+  public @java.lang.SuppressWarnings("all") int getId() {
     return this.id;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") String getName() {
+  public @java.lang.SuppressWarnings("all") String getName() {
     return this.name;
   }
-  private @java.beans.ConstructorProperties({"id", "name"}) @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") GetterEnum(final int id, final String name) {
+  private @java.lang.SuppressWarnings("all") GetterEnum(final int id, final String name) {
     super();
     this.id = id;
     this.name = name;

File: test/transform/resource/after-ecj/GetterLazy.java
Patch:
@@ -8,7 +8,7 @@ static class ValueType {
   GetterLazy() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") ValueType getFieldName() {
+  public @java.lang.SuppressWarnings("all") ValueType getFieldName() {
     java.lang.Object value = this.fieldName.get();
     if ((value == null))
         {

File: test/transform/resource/after-ecj/GetterLazyInvalid.java
Patch:
@@ -27,7 +27,7 @@ class GetterLazyInvalidNone {
   GetterLazyInvalidClass() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") String getFieldName() {
+  public @java.lang.SuppressWarnings("all") String getFieldName() {
     return this.fieldName;
   }
 }

File: test/transform/resource/after-ecj/GetterLazyTransient.java
Patch:
@@ -5,7 +5,7 @@ class GetterLazyTransient {
   GetterLazyTransient() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getNonTransientField() {
+  public @java.lang.SuppressWarnings("all") int getNonTransientField() {
     java.lang.Object value = this.nonTransientField.get();
     if ((value == null))
         {
@@ -22,7 +22,7 @@ class GetterLazyTransient {
         }
     return (java.lang.Integer) value;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getNonLazyTransientField() {
+  public @java.lang.SuppressWarnings("all") int getNonLazyTransientField() {
     return this.nonLazyTransientField;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/GetterNone.java
Patch:
@@ -6,7 +6,7 @@
   GetterNone() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getI() {
+  public @java.lang.SuppressWarnings("all") int getI() {
     return this.i;
   }
 }

File: test/transform/resource/after-ecj/GetterOnMethod.java
Patch:
@@ -7,13 +7,13 @@ class GetterOnMethod {
   GetterOnMethod() {
     super();
   }
-  public @Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getI() {
+  public @Deprecated @java.lang.SuppressWarnings("all") int getI() {
     return this.i;
   }
-  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getJ() {
+  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") int getJ() {
     return this.j;
   }
-  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getK() {
+  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") int getK() {
     return this.k;
   }
 }

File: test/transform/resource/after-ecj/GetterOnMethodErrors.java
Patch:
@@ -8,7 +8,7 @@ class PlaceFillerToMakeSurePositionIsRelevant {
   GetterOnMethodErrors() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getTest() {
+  public @java.lang.SuppressWarnings("all") int getTest() {
     return this.test;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/GetterOnStatic.java
Patch:
@@ -6,10 +6,10 @@ class Getter {
   Getter() {
     super();
   }
-  public static @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") boolean isFoo() {
+  public static @java.lang.SuppressWarnings("all") boolean isFoo() {
     return Getter.foo;
   }
-  public static @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getBar() {
+  public static @java.lang.SuppressWarnings("all") int getBar() {
     return Getter.bar;
   }
 }

File: test/transform/resource/after-ecj/GetterPlain.java
Patch:
@@ -5,10 +5,10 @@ class GetterPlain {
   GetterPlain() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getI() {
+  public @java.lang.SuppressWarnings("all") int getI() {
     return this.i;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getFoo() {
+  public @java.lang.SuppressWarnings("all") int getFoo() {
     return this.foo;
   }
 }

File: test/transform/resource/after-ecj/GetterWithDollar.java
Patch:
@@ -3,7 +3,7 @@ class GetterWithDollar1 {
   GetterWithDollar1() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int get$i() {
+  public @java.lang.SuppressWarnings("all") int get$i() {
     return this.$i;
   }
 }
@@ -13,10 +13,10 @@ class GetterWithDollar2 {
   GetterWithDollar2() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int get$i() {
+  public @java.lang.SuppressWarnings("all") int get$i() {
     return this.$i;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getI() {
+  public @java.lang.SuppressWarnings("all") int getI() {
     return this.i;
   }
 }

File: test/transform/resource/after-ecj/MixGetterVal.java
Patch:
@@ -13,7 +13,7 @@ public void test() {
     final @val int a = getX();
     m(a);
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getX() {
+  public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/NoArgsConstructorForce.java
Patch:
@@ -3,7 +3,7 @@
   private final int[] i;
   private final Object[] o;
   private final java.util.List<?>[] fullQualifiedList;
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") NoArgsConstructorForce() {
+  public @java.lang.SuppressWarnings("all") NoArgsConstructorForce() {
     super();
     this.i = null;
     this.o = null;

File: test/transform/resource/after-ecj/NonNullWithAlternateException.java
Patch:
@@ -10,7 +10,7 @@ public void testMethod(@lombok.NonNull String arg) {
         }
     System.out.println(arg);
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setTest(final @lombok.NonNull String test) {
+  public @java.lang.SuppressWarnings("all") void setTest(final @lombok.NonNull String test) {
     if ((test == null))
         {
           throw new java.lang.IllegalArgumentException("test is null");

File: test/transform/resource/after-ecj/SetterAlreadyExists.java
Patch:
@@ -37,7 +37,7 @@ class Setter5 {
   }
   void setFoo() {
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setFoo(final String foo) {
+  public @java.lang.SuppressWarnings("all") void setFoo(final String foo) {
     this.foo = foo;
   }
 }
@@ -48,7 +48,7 @@ class Setter6 {
   }
   void setFoo(String foo, int x) {
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setFoo(final String foo) {
+  public @java.lang.SuppressWarnings("all") void setFoo(final String foo) {
     this.foo = foo;
   }
 }

File: test/transform/resource/after-ecj/SetterDeprecated.java
Patch:
@@ -5,10 +5,10 @@ class SetterDeprecated {
   SetterDeprecated() {
     super();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setAnnotation(final int annotation) {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void setAnnotation(final int annotation) {
     this.annotation = annotation;
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setJavadoc(final int javadoc) {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void setJavadoc(final int javadoc) {
     this.javadoc = javadoc;
   }
 }

File: test/transform/resource/after-ecj/SetterOnMethodOnParam.java
Patch:
@@ -7,13 +7,13 @@ class SetterOnMethodOnParam {
   SetterOnMethodOnParam() {
     super();
   }
-  public @Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setI(final int i) {
+  public @Deprecated @java.lang.SuppressWarnings("all") void setI(final int i) {
     this.i = i;
   }
-  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setJ(final @Test int j) {
+  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") void setJ(final @Test int j) {
     this.j = j;
   }
-  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setK(final @Test int k) {
+  public @java.lang.Deprecated @Test @java.lang.SuppressWarnings("all") void setK(final @Test int k) {
     this.k = k;
   }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/SetterOnParamAndOnMethod.java
Patch:
@@ -1,6 +1,6 @@
 class SetterOnParamAndOnMethod {
   @lombok.Setter() int i;
-  public @Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setI(final @SuppressWarnings("all") int i) {
+  public @Deprecated @java.lang.SuppressWarnings("all") void setI(final @SuppressWarnings("all") int i) {
     this.i = i;
   }
   SetterOnParamAndOnMethod() {

File: test/transform/resource/after-ecj/SetterOnStatic.java
Patch:
@@ -6,10 +6,10 @@ class Setter {
   Setter() {
     super();
   }
-  public static @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setFoo(final boolean foo) {
+  public static @java.lang.SuppressWarnings("all") void setFoo(final boolean foo) {
     Setter.foo = foo;
   }
-  public static @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setBar(final int bar) {
+  public static @java.lang.SuppressWarnings("all") void setBar(final int bar) {
     Setter.bar = bar;
   }
 }

File: test/transform/resource/after-ecj/SetterPlain.java
Patch:
@@ -5,10 +5,10 @@ class SetterPlain {
   SetterPlain() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setI(final int i) {
+  public @java.lang.SuppressWarnings("all") void setI(final int i) {
     this.i = i;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setFoo(final int foo) {
+  public @java.lang.SuppressWarnings("all") void setFoo(final int foo) {
     this.foo = foo;
   }
 }

File: test/transform/resource/after-ecj/SetterWithDollar.java
Patch:
@@ -3,7 +3,7 @@ class SetterWithDollar1 {
   SetterWithDollar1() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void set$i(final int $i) {
+  public @java.lang.SuppressWarnings("all") void set$i(final int $i) {
     this.$i = $i;
   }
 }
@@ -13,10 +13,10 @@ class SetterWithDollar2 {
   SetterWithDollar2() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void set$i(final int $i) {
+  public @java.lang.SuppressWarnings("all") void set$i(final int $i) {
     this.$i = $i;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") void setI(final int i) {
+  public @java.lang.SuppressWarnings("all") void setI(final int i) {
     this.i = i;
   }
 }

File: test/transform/resource/after-ecj/SimpleTypeResolution.java
Patch:
@@ -7,7 +7,7 @@ class SimpleTypeResolutionSuccess {
   private @lombok.Getter int x;
   SimpleTypeResolutionSuccess() {
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getX() {
+  public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;
   }
 }

File: test/transform/resource/after-ecj/ToStringPlain.java
Patch:
@@ -5,7 +5,7 @@
   ToString1() {
     super();
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") java.lang.String toString() {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
     return (((("ToString1(x=" + this.x) + ", name=") + this.name) + ")");
   }
 }
@@ -15,7 +15,7 @@
   ToString2() {
     super();
   }
-  public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") java.lang.String toString() {
+  public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
     return (((("ToString2(x=" + this.x) + ", name=") + this.name) + ")");
   }
 }

File: test/transform/resource/after-ecj/TrickyTypeResolution.java
Patch:
@@ -20,7 +20,7 @@ class TrickySuccess {
   TrickySuccess() {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int getX() {
+  public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;
   }
 }

File: test/transform/resource/after-ecj/WitherAlreadyExists.java
Patch:
@@ -37,7 +37,7 @@ void withFoo() {
   Wither5(String foo) {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") Wither5 withFoo(final String foo) {
+  public @java.lang.SuppressWarnings("all") Wither5 withFoo(final String foo) {
     return ((this.foo == foo) ? this : new Wither5(foo));
   }
 }
@@ -48,7 +48,7 @@ void withFoo(String foo, int x) {
   Wither6(String foo) {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") Wither6 withFoo(final String foo) {
+  public @java.lang.SuppressWarnings("all") Wither6 withFoo(final String foo) {
     return ((this.foo == foo) ? this : new Wither6(foo));
   }
 }

File: test/transform/resource/after-ecj/WitherAndAllArgsConstructor.java
Patch:
@@ -4,13 +4,13 @@
   final int x = 10;
   int y = 20;
   final int z;
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherAndAllArgsConstructor<T, J, L> withTest(final J test) {
+  public @java.lang.SuppressWarnings("all") WitherAndAllArgsConstructor<T, J, L> withTest(final J test) {
     return ((this.test == test) ? this : new WitherAndAllArgsConstructor<T, J, L>(test, this.test2, this.y, this.z));
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherAndAllArgsConstructor<T, J, L> withTest2(final java.util.List<L> test2) {
+  public @java.lang.SuppressWarnings("all") WitherAndAllArgsConstructor<T, J, L> withTest2(final java.util.List<L> test2) {
     return ((this.test2 == test2) ? this : new WitherAndAllArgsConstructor<T, J, L>(this.test, test2, this.y, this.z));
   }
-  public @java.beans.ConstructorProperties({"test", "test2", "y", "z"}) @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherAndAllArgsConstructor(final J test, final java.util.List<L> test2, final int y, final int z) {
+  public @java.lang.SuppressWarnings("all") WitherAndAllArgsConstructor(final J test, final java.util.List<L> test2, final int y, final int z) {
     super();
     this.test = test;
     this.test2 = test2;

File: test/transform/resource/after-ecj/WitherDeprecated.java
Patch:
@@ -5,10 +5,10 @@ class WitherDeprecated {
   WitherDeprecated(int annotation, int javadoc) {
     super();
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherDeprecated withAnnotation(final int annotation) {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") WitherDeprecated withAnnotation(final int annotation) {
     return ((this.annotation == annotation) ? this : new WitherDeprecated(annotation, this.javadoc));
   }
-  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherDeprecated withJavadoc(final int javadoc) {
+  public @java.lang.Deprecated @java.lang.SuppressWarnings("all") WitherDeprecated withJavadoc(final int javadoc) {
     return ((this.javadoc == javadoc) ? this : new WitherDeprecated(this.annotation, javadoc));
   }
 }

File: test/transform/resource/after-ecj/WitherPlain.java
Patch:
@@ -7,10 +7,10 @@ class WitherPlain {
     this.i = i;
     this.foo = foo;
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherPlain withI(final int i) {
+  public @java.lang.SuppressWarnings("all") WitherPlain withI(final int i) {
     return ((this.i == i) ? this : new WitherPlain(i, this.foo));
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherPlain withFoo(final int foo) {
+  public @java.lang.SuppressWarnings("all") WitherPlain withFoo(final int foo) {
     return ((this.foo == foo) ? this : new WitherPlain(this.i, foo));
   }
 }

File: test/transform/resource/after-ecj/WitherWithAbstract.java
Patch:
@@ -3,5 +3,5 @@ abstract class WitherWithAbstract {
   WitherWithAbstract() {
     super();
   }
-  public abstract @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherWithAbstract withFoo(final String foo);
+  public abstract @java.lang.SuppressWarnings("all") WitherWithAbstract withFoo(final String foo);
 }

File: test/transform/resource/after-ecj/WitherWithGenerics.java
Patch:
@@ -6,13 +6,13 @@ class WitherWithGenerics<T, J extends T, L extends java.lang.Number> {
   public WitherWithGenerics(J test, java.util.List<L> test2, java.util.List<? extends L> test3) {
     super();
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherWithGenerics<T, J, L> withTest(final J test) {
+  public @java.lang.SuppressWarnings("all") WitherWithGenerics<T, J, L> withTest(final J test) {
     return ((this.test == test) ? this : new WitherWithGenerics<T, J, L>(test, this.test2, this.test3));
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherWithGenerics<T, J, L> withTest2(final java.util.List<L> test2) {
+  public @java.lang.SuppressWarnings("all") WitherWithGenerics<T, J, L> withTest2(final java.util.List<L> test2) {
     return ((this.test2 == test2) ? this : new WitherWithGenerics<T, J, L>(this.test, test2, this.test3));
   }
-  public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") WitherWithGenerics<T, J, L> withTest3(final java.util.List<? extends L> test3) {
+  public @java.lang.SuppressWarnings("all") WitherWithGenerics<T, J, L> withTest3(final java.util.List<? extends L> test3) {
     return ((this.test3 == test3) ? this : new WitherWithGenerics<T, J, L>(this.test, this.test2, test3));
   }
 }

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -113,7 +113,7 @@ public static void handleFlagUsage(LombokNode<?, ?, ?> node, ConfigurationKey<Fl
 	public static boolean shouldAddGenerated(LombokNode<?, ?, ?> node) {
 		Boolean add = node.getAst().readConfiguration(ConfigurationKeys.ADD_JAVAX_GENERATED_ANNOTATIONS);
 		if (add != null) return add;
-		return !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_GENERATED_ANNOTATIONS));
+		return Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_GENERATED_ANNOTATIONS));
 	}
 	
 	public static void handleExperimentalFlagUsage(LombokNode<?, ?, ?> node, ConfigurationKey<FlagUsageType> key, String featureName) {

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -261,6 +261,7 @@ public static Type Types_upperBound(Types types, Type type) {
 	}
 	
 	public static Type ifTypeIsIterableToComponent(Type type, JavacAST ast) {
+		if (type == null) return null;
 		Types types = Types.instance(ast.getContext());
 		Symtab syms = Symtab.instance(ast.getContext());
 		Type boundType = ReflectiveAccess.Types_upperBound(types, type);

File: src/utils/lombok/javac/JavacTreeMaker.java
Patch:
@@ -226,6 +226,7 @@ public static TypeTag typeTag(JCTree o) {
 		}
 		
 		public static TypeTag typeTag(Type t) {
+			if (t == null) return Javac.CTC_VOID;
 			try {
 				return new TypeTag(getFieldCached(FIELD_CACHE, t, "tag"));
 			} catch (NoSuchFieldException e) {

File: src/core/lombok/javac/Javac9BasedLombokOptions.java
Patch:
@@ -39,6 +39,7 @@ private Javac9BasedLombokOptions(Context context) {
 	}
 	
 	@Override public void putJavacOption(String optionName, String value) {
+		if (optionName.equals("CLASSPATH")) optionName = "CLASS_PATH";
 		if (optionName.equals("SOURCEPATH")) optionName = "SOURCE_PATH";
 		if (optionName.equals("BOOTCLASSPATH")) optionName = "BOOT_CLASS_PATH";
 		String optionText = Option.valueOf(optionName).primaryName;

File: src/delombok/lombok/delombok/LombokOptionsFactory.java
Patch:
@@ -50,7 +50,7 @@ enum LombokOptionCompilerVersion {
 			}
 		};
 		
-		abstract LombokOptions createAndRegisterOptions(Context context); 
+		abstract LombokOptions createAndRegisterOptions(Context context);
 	}
 	
 	public static LombokOptions getDelombokOptions(Context context) {

File: src/stubsstubs/com/sun/tools/javac/main/Option.java
Patch:
@@ -0,0 +1,3 @@
+package com.sun.tools.javac.main;
+
+public class Option {}
\ No newline at end of file

File: src/stubsstubs/com/sun/tools/javac/main/OptionName.java
Patch:
@@ -0,0 +1,3 @@
+package com.sun.tools.javac.main;
+
+public class OptionName {}
\ No newline at end of file

File: src/stubsstubs/com/sun/tools/javac/util/Context.java
Patch:
@@ -1,3 +1,5 @@
 package com.sun.tools.javac.util;
 
-public class Context {}
\ No newline at end of file
+public class Context {
+	public static class Key<T> {}
+}
\ No newline at end of file

File: src/core/lombok/ToString.java
Patch:
@@ -64,7 +64,7 @@
 	 * Include the result of the superclass's implementation of {@code toString} in the output.
 	 * <strong>default: false</strong>
 	 * 
-	 * @return Whether to call the superclass's {@code toString} implementation as part of the generated equals algorithm.
+	 * @return Whether to call the superclass's {@code toString} implementation as part of the generated toString algorithm.
 	 */
 	boolean callSuper() default false;
 	

File: src/core/lombok/ToString.java
Patch:
@@ -64,7 +64,7 @@
 	 * Include the result of the superclass's implementation of {@code toString} in the output.
 	 * <strong>default: false</strong>
 	 * 
-	 * @return Whether to call the superclass's {@code equals} implementation as part of the generated equals algorithm.
+	 * @return Whether to call the superclass's {@code toString} implementation as part of the generated equals algorithm.
 	 */
 	boolean callSuper() default false;
 	

File: test/transform/resource/after-delombok/DataPlain.java
Patch:
@@ -217,8 +217,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@javax.annotation.Generated("lombok")
 	public int hashCode() {
 		final int PRIME = 59;
-		int result = 1;
-		result = result * PRIME + super.hashCode();
+		int result = super.hashCode();
 		result = result * PRIME + this.getX();
 		return result;
 	}

File: test/transform/resource/after-delombok/EqualsAndHashCode.java
Patch:
@@ -125,9 +125,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
 	public int hashCode() {
-		final int PRIME = 59;
-		int result = 1;
-		result = result * PRIME + super.hashCode();
+		int result = super.hashCode();
 		return result;
 	}
 }

File: test/transform/resource/after-delombok/EqualsAndHashCodeConfigKeys2.java
Patch:
@@ -70,8 +70,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@javax.annotation.Generated("lombok")
 	public int hashCode() {
 		final int PRIME = 59;
-		int result = 1;
-		result = result * PRIME + super.hashCode();
+		int result = super.hashCode();
 		result = result * PRIME + this.x;
 		return result;
 	}

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithExistingMethods.java
Patch:
@@ -32,8 +32,7 @@ public boolean equals(final java.lang.Object o) {
 	@javax.annotation.Generated("lombok")
 	public int hashCode() {
 		final int PRIME = 59;
-		int result = 1;
-		result = result * PRIME + super.hashCode();
+		int result = super.hashCode();
 		result = result * PRIME + this.x;
 		return result;
 	}

File: test/transform/resource/after-delombok/ValueCallSuper.java
Patch:
@@ -25,9 +25,7 @@ protected boolean canEqual(final java.lang.Object other) {
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
 	public int hashCode() {
-		final int PRIME = 59;
-		int result = 1;
-		result = result * PRIME + super.hashCode();
+		int result = super.hashCode();
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-ecj/DataPlain.java
Patch:
@@ -168,8 +168,7 @@
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
     final int PRIME = 59;
-    int result = 1;
-    result = ((result * PRIME) + super.hashCode());
+    int result = super.hashCode();
     result = ((result * PRIME) + this.getX());
     return result;
   }

File: test/transform/resource/after-ecj/EqualsAndHashCode.java
Patch:
@@ -129,9 +129,7 @@
     return (other instanceof EqualsAndHashCode4);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
-    final int PRIME = 59;
-    int result = 1;
-    result = ((result * PRIME) + super.hashCode());
+    int result = super.hashCode();
     return result;
   }
 }

File: test/transform/resource/after-ecj/EqualsAndHashCodeConfigKeys2.java
Patch:
@@ -66,8 +66,7 @@
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
     final int PRIME = 59;
-    int result = 1;
-    result = ((result * PRIME) + super.hashCode());
+    int result = super.hashCode();
     result = ((result * PRIME) + this.x);
     return result;
   }

File: test/transform/resource/after-ecj/EqualsAndHashCodeWithExistingMethods.java
Patch:
@@ -40,8 +40,7 @@ private boolean canEqual(Object other) {
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
     final int PRIME = 59;
-    int result = 1;
-    result = ((result * PRIME) + super.hashCode());
+    int result = super.hashCode();
     result = ((result * PRIME) + this.x);
     return result;
   }

File: test/transform/resource/after-ecj/ValueCallSuper.java
Patch:
@@ -20,9 +20,7 @@ class ValueParent {
     return (other instanceof ValueCallSuper);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") int hashCode() {
-    final int PRIME = 59;
-    int result = 1;
-    result = ((result * PRIME) + super.hashCode());
+    int result = super.hashCode();
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") java.lang.String toString() {

File: src/core/lombok/javac/apt/LombokFileObjects.java
Patch:
@@ -154,7 +154,7 @@ static class BaseFileManagerWrapper extends BaseFileManager {
 		JavaFileManager manager;
 
 		public BaseFileManagerWrapper(JavaFileManager manager) {
-			super(StandardCharsets.UTF_8);
+			super(null); // use default encoding
 			this.manager = manager;
 		}
 		

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -137,7 +137,7 @@ private FileSystem createFileSystem(File file) {
 				i.remove();
 			}
 		}
-		classpath.add("bin");
+		if (new File("bin").exists()) classpath.add("bin");
 		classpath.add("dist/lombok.jar");
 		classpath.add("lib/test/commons-logging-commons-logging.jar");
 		classpath.add("lib/test/org.slf4j-slf4j-api.jar");

File: test/transform/resource/after-ecj/EqualsAndHashCodeOfAndExclude.java
Patch:
@@ -43,4 +43,4 @@
     result = ((result * PRIME) + this.x);
     return result;
   }
-}
\ No newline at end of file
+}

File: test/transform/resource/before/EqualsAndHashCodeOfAndExclude.java
Patch:
@@ -8,4 +8,4 @@ final class EqualsAndHashCodeOf {
 final class EqualsAndHashCodeExclude {
 	int x;
 	int y;
-}
\ No newline at end of file
+}

File: src/core/lombok/Builder.java
Patch:
@@ -48,7 +48,7 @@
  * as the relevant class, unless a method has been annotated, in which case it'll be equal to the
  * return type of that method.
  * <p>
- * Complete documentation is found at <a href="https://projectlombok.org/features/experimental/Builder">the project lombok features page for &#64;Builder</a>.
+ * Complete documentation is found at <a href="https://projectlombok.org/features/Builder">the project lombok features page for &#64;Builder</a>.
  * <br>
  * <p>
  * Before:

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -350,7 +350,7 @@ public static ConstructorDeclaration createConstructor(
 				Annotation[] nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 				Annotation[] nullables = findAnnotations(field, NULLABLE_PATTERN);
 				if (nonNulls.length != 0) {
-					Statement nullCheck = generateNullCheck(field, sourceNode);
+					Statement nullCheck = generateNullCheck(parameter, sourceNode);
 					if (nullCheck != null) nullChecks.add(nullCheck);
 				}
 				parameter.annotations = copyAnnotations(source, nonNulls, nullables);

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -289,7 +289,7 @@ public static JCMethodDecl createConstructor(AccessLevel level, List<JCAnnotatio
 				JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, nonNulls.appendList(nullables)), fieldName, field.vartype, null);
 				params.append(param);
 				if (!nonNulls.isEmpty()) {
-					JCStatement nullCheck = generateNullCheck(maker, fieldNode, source);
+					JCStatement nullCheck = generateNullCheck(maker, fieldNode, param, source);
 					if (nullCheck != null) nullChecks.append(nullCheck);
 				}
 			}

File: src/core/lombok/Builder.java
Patch:
@@ -48,7 +48,7 @@
  * as the relevant class, unless a method has been annotated, in which case it'll be equal to the
  * return type of that method.
  * <p>
- * Complete documentation is found at <a href="https://projectlombok.org/features/experimental/Builder">the project lombok features page for &#64;Builder</a>.
+ * Complete documentation is found at <a href="https://projectlombok.org/features/Builder">the project lombok features page for &#64;Builder</a>.
  * <br>
  * <p>
  * Before:

File: test/transform/resource/before/EqualsAndHashCodeConfigKeys2.java
Patch:
@@ -1,5 +1,7 @@
 //CONF: lombok.equalsAndHashCode.callSuper = call
-
+@lombok.EqualsAndHashCode
+class EqualsAndHashCodeConfigKeys2Object extends Object {
+}
 @lombok.EqualsAndHashCode
 class EqualsAndHashCodeConfigKeys2Parent {
 }

File: src/core/lombok/javac/apt/LombokFileObjects.java
Patch:
@@ -100,7 +100,8 @@ static Compiler getCompiler(JavaFileManager jfm) {
 		if (jfmClassName.equals("com.sun.tools.javac.util.DefaultFileManager")) return Compiler.JAVAC6;
 		if (jfmClassName.equals("com.sun.tools.javac.util.JavacFileManager")) return Compiler.JAVAC6;
 		if (jfmClassName.equals("com.sun.tools.javac.file.JavacFileManager") ||
-				jfmClassName.equals("com.google.errorprone.MaskedClassLoader$MaskedFileManager")) {
+				jfmClassName.equals("com.google.errorprone.MaskedClassLoader$MaskedFileManager") ||
+				jfmClassName.equals("com.google.devtools.build.buildjar.javac.BlazeJavacMain$ClassloaderMaskingFileManager")) {
 			try {
 				Class<?> superType = Class.forName("com.sun.tools.javac.file.BaseFileManager");
 				if (superType.isInstance(jfm)) {

File: src/core/lombok/javac/apt/LombokFileObjects.java
Patch:
@@ -147,7 +147,7 @@ public Java9Compiler(JavaFileManager jfm) {
 		@Override public JavaFileObject wrap(LombokFileObject fileObject) {
 			URI uri = fileObject.toUri();
 			if (uri.getScheme() == null) {
-				uri = URI.create("file://" + uri);
+				uri = URI.create("file:///" + uri);
 			}
 			Path path;
 			try {

File: src/core/lombok/javac/apt/LombokFileObjects.java
Patch:
@@ -98,7 +98,8 @@ static Compiler getCompiler(JavaFileManager jfm) {
 		String jfmClassName = jfm != null ? jfm.getClass().getName() : "null";
 		if (jfmClassName.equals("com.sun.tools.javac.util.DefaultFileManager")) return Compiler.JAVAC6;
 		if (jfmClassName.equals("com.sun.tools.javac.util.JavacFileManager")) return Compiler.JAVAC6;
-		if (jfmClassName.equals("com.sun.tools.javac.file.JavacFileManager")) {
+		if (jfmClassName.equals("com.sun.tools.javac.file.JavacFileManager") ||
+				jfmClassName.equals("com.google.errorprone.MaskedClassLoader$MaskedFileManager")) {
 			try {
 				Class<?> superType = Class.forName("com.sun.tools.javac.file.BaseFileManager");
 				if (superType.isInstance(jfm)) {

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -167,6 +167,7 @@ public static MarkerAnnotation generateDeprecatedAnnotation(ASTNode source) {
 	}
 	
 	public static boolean isFieldDeprecated(EclipseNode fieldNode) {
+		if (!(fieldNode.get() instanceof FieldDeclaration)) return false;
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		if ((field.modifiers & ClassFileConstants.AccDeprecated) != 0) {
 			return true;

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -193,11 +193,11 @@ public void createSetterForField(
 			}
 		}
 		
-		MethodDeclaration method = createSetter((TypeDeclaration) fieldNode.up().get(), fieldNode, setterName, null, shouldReturnThis, modifier, sourceNode, onMethod, onParam);
+		MethodDeclaration method = createSetter((TypeDeclaration) fieldNode.up().get(), false, fieldNode, setterName, null, shouldReturnThis, modifier, sourceNode, onMethod, onParam);
 		injectMethod(fieldNode.up(), method);
 	}
 	
-	static MethodDeclaration createSetter(TypeDeclaration parent, EclipseNode fieldNode, String name, char[] booleanFieldToSet, boolean shouldReturnThis, int modifier, EclipseNode sourceNode, List<Annotation> onMethod, List<Annotation> onParam) {
+	static MethodDeclaration createSetter(TypeDeclaration parent, boolean deprecate, EclipseNode fieldNode, String name, char[] booleanFieldToSet, boolean shouldReturnThis, int modifier, EclipseNode sourceNode, List<Annotation> onMethod, List<Annotation> onParam) {
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		ASTNode source = sourceNode.get();
 		int pS = source.sourceStart, pE = source.sourceEnd;
@@ -214,7 +214,7 @@ static MethodDeclaration createSetter(TypeDeclaration parent, EclipseNode fieldN
 			shouldReturnThis = false;
 		}
 		Annotation[] deprecated = null;
-		if (isFieldDeprecated(fieldNode)) {
+		if (isFieldDeprecated(fieldNode) || deprecate) {
 			deprecated = new Annotation[] { generateDeprecatedAnnotation(source) };
 		}
 		method.annotations = copyAnnotations(source, onMethod.toArray(new Annotation[0]), deprecated);

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -206,10 +206,10 @@ public void createSetterForField(AccessLevel level, JavacNode fieldNode, JavacNo
 	public static JCMethodDecl createSetter(long access, JavacNode field, JavacTreeMaker treeMaker, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam) {
 		String setterName = toSetterName(field);
 		boolean returnThis = shouldReturnThis(field);
-		return createSetter(access, field, treeMaker, setterName, null, returnThis, source, onMethod, onParam);
+		return createSetter(access, false, field, treeMaker, setterName, null, returnThis, source, onMethod, onParam);
 	}
 	
-	public static JCMethodDecl createSetter(long access, JavacNode field, JavacTreeMaker treeMaker, String setterName, Name booleanFieldToSet, boolean shouldReturnThis, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam) {
+	public static JCMethodDecl createSetter(long access, boolean deprecate, JavacNode field, JavacTreeMaker treeMaker, String setterName, Name booleanFieldToSet, boolean shouldReturnThis, JavacNode source, List<JCAnnotation> onMethod, List<JCAnnotation> onParam) {
 		if (setterName == null) return null;
 		
 		JCVariableDecl fieldDecl = (JCVariableDecl) field.get();
@@ -263,7 +263,7 @@ public static JCMethodDecl createSetter(long access, JavacNode field, JavacTreeM
 		JCExpression annotationMethodDefaultValue = null;
 		
 		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
-		if (isFieldDeprecated(field)) {
+		if (isFieldDeprecated(field) || deprecate) {
 			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}
 		

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -243,6 +243,7 @@ public static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode
 	 * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}
 	 */
 	public static boolean isFieldDeprecated(JavacNode field) {
+		if (!(field.get() instanceof JCVariableDecl)) return false;
 		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
 		if ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {
 			return true;

File: src/core/lombok/javac/handlers/singulars/JavacJavaUtilSingularizer.java
Patch:
@@ -165,6 +165,9 @@ protected List<JCStatement> createJavaUtilSimpleCreationAndFillStatements(JavacT
 				JCExpression pluralnameDotPut = maker.Select(maker.Ident(data.getPluralName()), builderType.toName("put"));
 				JCExpression arg1 = maker.Apply(jceBlank, chainDots(builderType, "this", data.getPluralName() + "$key", "get"), List.<JCExpression>of(maker.Ident(ivar)));
 				JCExpression arg2 = maker.Apply(jceBlank, chainDots(builderType, "this", data.getPluralName() + "$value", "get"), List.<JCExpression>of(maker.Ident(ivar)));
+				// [jdk9] We add an unneccessary (V) cast here. Not doing so gives an error in javac (build 9-ea+156-jigsaw-nightly-h6072-20170212):
+				//   error: method put in interface Map<K#2,V#2> cannot be applied to given types;
+				arg2 = maker.TypeCast(createTypeArgs(2, false, builderType, data.getTypeArgs(), source).get(1), arg2);
 				JCStatement putStatement = maker.Exec(maker.Apply(jceBlank, pluralnameDotPut, List.of(arg1, arg2)));
 				JCStatement forInit = maker.VarDef(maker.Modifiers(0), ivar, maker.TypeIdent(CTC_INT), maker.Literal(CTC_INT, 0));
 				JCExpression checkExpr = maker.Binary(CTC_LESS_THAN, maker.Ident(ivar), getSize(maker, builderType, keyVarName, nullGuard, true));

File: src/core/lombok/Builder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 The Project Lombok Authors.
+ * Copyright (C) 2013-2017 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -108,11 +108,11 @@
 @Retention(SOURCE)
 public @interface Builder {
 	/**
-	 * Marks a given field as being a 'constant' (initialized by the initializing expression during construction and not eligible to be modified as part of {@code @Builder}.
+	 * The field annotated with {@code @Default} must have an initializing expression; that expression is taken as the default to be used if not explicitly set during building.
 	 */
 	@Target(FIELD)
 	@Retention(SOURCE)
-	public @interface Constant {}
+	public @interface Default {}
 
 	/** Name of the method that creates a new builder instance. Default: {@code builder}. */
 	String builderMethodName() default "builder";

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -347,7 +347,7 @@ public static ConstructorDeclaration createConstructor(
 				Annotation[] nonNulls = findAnnotations(field, NON_NULL_PATTERN);
 				Annotation[] nullables = findAnnotations(field, NULLABLE_PATTERN);
 				if (nonNulls.length != 0) {
-					Statement nullCheck = generateNullCheck(field, sourceNode);
+					Statement nullCheck = generateNullCheck(parameter, sourceNode);
 					if (nullCheck != null) nullChecks.add(nullCheck);
 				}
 				parameter.annotations = copyAnnotations(source, nonNulls, nullables);

File: test/transform/resource/after-delombok/ConstructorsWithAccessors.java
Patch:
@@ -23,12 +23,11 @@ class NonNullConstructorsWithAccessors {
 	@lombok.NonNull
 	Integer _huh;
 	@lombok.NonNull
-	Integer __huh2;
+	final Integer __huh2;
 
 	@java.beans.ConstructorProperties({"plower", "upper", "huh", "_huh2"})
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
-	@lombok.Generated
 	public NonNullConstructorsWithAccessors(@lombok.NonNull final Integer plower, @lombok.NonNull final Integer upper, @lombok.NonNull final Integer huh, @lombok.NonNull final Integer _huh2) {
 		if (plower == null) {
 			throw new java.lang.NullPointerException("plower");

File: test/transform/resource/before/ConstructorsWithAccessors.java
Patch:
@@ -9,6 +9,6 @@
 	@lombok.NonNull Integer plower;
 	@lombok.NonNull Integer pUpper;
 	@lombok.NonNull Integer _huh;
-	@lombok.NonNull Integer __huh2;
+	@lombok.NonNull final Integer __huh2;
 }
 

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -93,7 +93,7 @@ public static class HandleNoArgsConstructor extends EclipseAnnotationHandler<NoA
 			boolean force = ann.force();
 			
 			List<EclipseNode> fields = force ? findFinalFields(typeNode) : Collections.<EclipseNode>emptyList();
-			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@NoArgsConstructor(onConstructor=", annotationNode);
+			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@NoArgsConstructor(onConstructor", annotationNode);
 			
 			new HandleConstructor().generateConstructor(typeNode, level, fields, force, staticName, SkipIfConstructorExists.NO, null, onConstructor, annotationNode);
 		}
@@ -117,7 +117,7 @@ public static class HandleRequiredArgsConstructor extends EclipseAnnotationHandl
 				suppressConstructorProperties = suppress;
 			}
 			
-			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@RequiredArgsConstructor(onConstructor=", annotationNode);
+			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@RequiredArgsConstructor(onConstructor", annotationNode);
 			
 			new HandleConstructor().generateConstructor(
 				typeNode, level, findRequiredFields(typeNode), false, staticName, SkipIfConstructorExists.NO,
@@ -179,7 +179,7 @@ public static class HandleAllArgsConstructor extends EclipseAnnotationHandler<Al
 				suppressConstructorProperties = suppress;
 			}
 			
-			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@AllArgsConstructor(onConstructor=", annotationNode);
+			List<Annotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@AllArgsConstructor(onConstructor", annotationNode);
 			
 			new HandleConstructor().generateConstructor(
 				typeNode, level, findAllFields(typeNode), false, staticName, SkipIfConstructorExists.NO,

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -129,7 +129,7 @@ public void generateEqualsAndHashCodeForType(EclipseNode typeNode, EclipseNode e
 		List<String> includes = Arrays.asList(ann.of());
 		EclipseNode typeNode = annotationNode.up();
 		
-		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@EqualsAndHashCode(onParam=", annotationNode);
+		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@EqualsAndHashCode(onParam", annotationNode);
 		checkForBogusFieldNames(typeNode, annotation);
 		
 		Boolean callSuper = ann.callSuper();

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -148,7 +148,7 @@ public void handle(AnnotationValues<Getter> annotation, Annotation ast, EclipseN
 		
 		if (node == null) return;
 		
-		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Getter(onMethod=", annotationNode);
+		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Getter(onMethod", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -125,8 +125,8 @@ public void handle(AnnotationValues<Setter> annotation, Annotation ast, EclipseN
 		AccessLevel level = annotation.getInstance().value();
 		if (level == AccessLevel.NONE || node == null) return;
 		
-		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Setter(onMethod=", annotationNode);
-		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Setter(onParam=", annotationNode);
+		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Setter(onMethod", annotationNode);
+		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Setter(onParam", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -127,8 +127,8 @@ public void generateWitherForField(EclipseNode fieldNode, EclipseNode sourceNode
 		AccessLevel level = annotation.getInstance().value();
 		if (level == AccessLevel.NONE || node == null) return;
 		
-		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Wither(onMethod=", annotationNode);
-		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Wither(onParam=", annotationNode);
+		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Wither(onMethod", annotationNode);
+		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Wither(onParam", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -71,7 +71,7 @@ public static class HandleNoArgsConstructor extends JavacAnnotationHandler<NoArg
 			deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 			JavacNode typeNode = annotationNode.up();
 			if (!checkLegality(typeNode, annotationNode, NoArgsConstructor.class.getSimpleName())) return;
-			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@NoArgsConstructor(onConstructor=", annotationNode);
+			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@NoArgsConstructor(onConstructor", annotationNode);
 			NoArgsConstructor ann = annotation.getInstance();
 			AccessLevel level = ann.access();
 			if (level == AccessLevel.NONE) return;
@@ -91,7 +91,7 @@ public static class HandleRequiredArgsConstructor extends JavacAnnotationHandler
 			deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 			JavacNode typeNode = annotationNode.up();
 			if (!checkLegality(typeNode, annotationNode, RequiredArgsConstructor.class.getSimpleName())) return;
-			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@RequiredArgsConstructor(onConstructor=", annotationNode);
+			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@RequiredArgsConstructor(onConstructor", annotationNode);
 			RequiredArgsConstructor ann = annotation.getInstance();
 			AccessLevel level = ann.access();
 			if (level == AccessLevel.NONE) return;
@@ -141,7 +141,7 @@ public static class HandleAllArgsConstructor extends JavacAnnotationHandler<AllA
 			deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 			JavacNode typeNode = annotationNode.up();
 			if (!checkLegality(typeNode, annotationNode, AllArgsConstructor.class.getSimpleName())) return;
-			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@AllArgsConstructor(onConstructor=", annotationNode);
+			List<JCAnnotation> onConstructor = unboxAndRemoveAnnotationParameter(ast, "onConstructor", "@AllArgsConstructor(onConstructor", annotationNode);
 			AllArgsConstructor ann = annotation.getInstance();
 			AccessLevel level = ann.access();
 			if (level == AccessLevel.NONE) return;

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -95,7 +95,7 @@ public void checkForBogusFieldNames(JavacNode type, AnnotationValues<EqualsAndHa
 		List<String> excludes = List.from(ann.exclude());
 		List<String> includes = List.from(ann.of());
 		JavacNode typeNode = annotationNode.up();
-		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@EqualsAndHashCode(onParam=", annotationNode);
+		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@EqualsAndHashCode(onParam", annotationNode);
 		checkForBogusFieldNames(typeNode, annotation);
 		
 		Boolean callSuper = ann.callSuper();

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -147,7 +147,7 @@ public void generateGetterForField(JavacNode fieldNode, DiagnosticPosition pos,
 		
 		if (node == null) return;
 		
-		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Getter(onMethod=", annotationNode);
+		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Getter(onMethod", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -129,8 +129,8 @@ public void generateSetterForField(JavacNode fieldNode, JavacNode sourceNode, Ac
 		
 		if (level == AccessLevel.NONE || node == null) return;
 		
-		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Setter(onMethod=", annotationNode);
-		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Setter(onParam=", annotationNode);
+		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Setter(onMethod", annotationNode);
+		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Setter(onParam", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -131,8 +131,8 @@ public void generateWitherForField(JavacNode fieldNode, DiagnosticPosition pos,
 		
 		if (level == AccessLevel.NONE || node == null) return;
 		
-		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Wither(onMethod=", annotationNode);
-		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Wither(onParam=", annotationNode);
+		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Wither(onMethod", annotationNode);
+		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Wither(onParam", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: test/transform/resource/before/GetterOnMethodErrors2.java
Patch:
@@ -1,3 +1,4 @@
+//version 8:
 class GetterOnMethodErrors2 {
 	@lombok.Getter(onMethod=@_A_(@Deprecated)) private int bad1;
 	@lombok.Getter(onMethod=@__(5)) private int bad2;

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -55,7 +55,7 @@ public AbstractRunTests() {
 		this.dumpActualFilesHere = findPlaceToDumpActualFiles();
 	}
 	
-	public final FileTester createTester(final DirectoryRunner.TestParams params, final File file) throws IOException {
+	public final FileTester createTester(final DirectoryRunner.TestParams params, final File file, int version) throws IOException {
 		ConfigurationKeysLoader.LoaderLoader.loadAllConfigurationKeys();
 		AssertionError directiveFailure = null;
 		LombokTestSource sourceDirectives = null;
@@ -64,6 +64,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 			if (sourceDirectives.isIgnore()) return null;
 			if (!sourceDirectives.versionWithinLimit(params.getVersion())) return null;
 			if (!sourceDirectives.versionWithinLimit(getClasspathVersion())) return null;
+			if (!sourceDirectives.versionWithinLimit(version)) return null;
 		} catch (AssertionError ae) {
 			directiveFailure = ae;
 		}
@@ -73,6 +74,7 @@ public final FileTester createTester(final DirectoryRunner.TestParams params, fi
 		
 		if (expected.isIgnore()) return null;
 		if (!expected.versionWithinLimit(params.getVersion())) return null;
+		if (!expected.versionWithinLimit(version)) return null;
 		
 		final LombokTestSource sourceDirectives_ = sourceDirectives;
 		final AssertionError directiveFailure_ = directiveFailure;

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -155,12 +155,11 @@ private void reportInitializationFailure(RunNotifier notifier, Description descr
 	
 	private FileTester createTester(String fileName) throws IOException {
 		File file = new File(params.getBeforeDirectory(), fileName);
-		
 		switch (params.getCompiler()) {
 		case DELOMBOK:
-			return new RunTestsViaDelombok().createTester(params, file);
+			return new RunTestsViaDelombok().createTester(params, file, params.getVersion());
 		case ECJ:
-			return new RunTestsViaEcj().createTester(params, file);
+			return new RunTestsViaEcj().createTester(params, file, params.getVersion());
 		default:
 		case JAVAC:
 			throw new UnsupportedOperationException();

File: test/transform/resource/after-delombok/GenerateSuppressFBWarnings.java
Patch:
@@ -1,3 +1,4 @@
+//VERSION 7:
 class GenerateSuppressFBWarnings {
 	int y;
 	@java.lang.SuppressWarnings("all")

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -907,7 +907,7 @@ static class ClassSymbolMembersField {
 			} catch (Exception ex) {}
 			membersField = f;
 			removeMethod = r;
-			enterMethod = r;
+			enterMethod = e;
 		}
 		
 		static void remove(ClassSymbol from, Symbol toRemove) {

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -270,8 +270,7 @@ private static class BuilderFieldData {
 					}
 					
 					if (pos == -1 || tpOnType.size() <= pos) {
-						annotationNode.addError("**" + returnType.getClass().toString());
-//						annotationNode.addError("@Builder(toBuilder=true) requires that each type parameter on the static method is part of the typeargs of the return value. Type parameter " + tp.name + " is not part of the return type.");
+						annotationNode.addError("@Builder(toBuilder=true) requires that each type parameter on the static method is part of the typeargs of the return value. Type parameter " + tp.name + " is not part of the return type.");
 						return;
 					}
 					typeArgsForToBuilder.add(tpOnType.get(pos).name);

File: src/core/lombok/eclipse/handlers/HandleUtilityClass.java
Patch:
@@ -49,6 +49,7 @@
 
 import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.core.AST.Kind;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
@@ -57,6 +58,7 @@
 /**
  * Handles the {@code lombok.experimental.UtilityClass} annotation for eclipse.
  */
+@HandlerPriority(-4096) //-2^12; to ensure @FieldDefaults picks up on the 'static' we set here.
 @ProviderFor(EclipseAnnotationHandler.class)
 public class HandleUtilityClass extends EclipseAnnotationHandler<UtilityClass> {
 	@Override public void handle(AnnotationValues<UtilityClass> annotation, Annotation ast, EclipseNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleUtilityClass.java
Patch:
@@ -44,6 +44,7 @@
 import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.experimental.UtilityClass;
 import lombok.javac.Javac;
 import lombok.javac.JavacAnnotationHandler;
@@ -53,6 +54,7 @@
 /**
  * Handles the {@code @UtilityClass} annotation for javac.
  */
+@HandlerPriority(-4096) //-2^12; to ensure @FieldDefaults picks up on the 'static' we set here.
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleUtilityClass extends JavacAnnotationHandler<UtilityClass> {
 	@Override public void handle(AnnotationValues<UtilityClass> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -97,7 +97,7 @@ public void setName(@lombok.NonNull final String name) {
 				public boolean equals(final java.lang.Object o) {
 					if (o == this) return true;
 					if (!(o instanceof Local.InnerLocal)) return false;
-					final InnerLocal other = (InnerLocal) o;
+					final Local.InnerLocal other = (Local.InnerLocal) o;
 					if (!other.canEqual((java.lang.Object) this)) return false;
 					final java.lang.Object this$name = this.getName();
 					final java.lang.Object other$name = other.getName();

File: test/transform/resource/after-ecj/DataOnLocalClass.java
Patch:
@@ -73,7 +73,7 @@ class DataOnLocalClass2 {
               return true;
           if ((! (o instanceof Local.InnerLocal)))
               return false;
-          final InnerLocal other = (InnerLocal) o;
+          final Local.InnerLocal other = (Local.InnerLocal) o;
           if ((! other.canEqual((java.lang.Object) this)))
               return false;
           final java.lang.Object this$name = this.getName();

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -291,7 +291,7 @@ public static JCMethodDecl createConstructor(AccessLevel level, List<JCAnnotatio
 				JCVariableDecl param = maker.VarDef(maker.Modifiers(flags, nonNulls.appendList(nullables)), fieldName, field.vartype, null);
 				params.append(param);
 				if (!nonNulls.isEmpty()) {
-					JCStatement nullCheck = generateNullCheck(maker, fieldNode, source);
+					JCStatement nullCheck = generateNullCheck(maker, fieldNode, param, source);
 					if (nullCheck != null) nullChecks.append(nullCheck);
 				}
 			}

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -230,6 +230,7 @@ public void generateMethods(JavacNode typeNode, JavacNode source, List<String> e
 		}
 		
 		JCMethodDecl equalsMethod = createEquals(typeNode, nodesForEquality.toList(), callSuper, fieldAccess, needsCanEqual, source.get(), onParam);
+		
 		injectMethod(typeNode, equalsMethod);
 		
 		if (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -934,7 +934,7 @@ public static void injectMethod(JavacNode typeNode, JCMethodDecl method, List<Ty
 			int idx = 0;
 			for (JCTree def : type.defs) {
 				if (def instanceof JCMethodDecl) {
-					if ((((JCMethodDecl)def).mods.flags & Flags.GENERATEDCONSTR) != 0) {
+					if ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {
 						JavacNode tossMe = typeNode.getNodeFor(def);
 						if (tossMe != null) tossMe.up().removeChild(tossMe);
 						type.defs = addAllButOne(type.defs, idx);

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1200,7 +1200,7 @@ public static MemberExistsResult constructorExists(EclipseNode node) {
 		
 		if (node != null && node.get() instanceof TypeDeclaration) {
 			TypeDeclaration typeDecl = (TypeDeclaration)node.get();
-			if (typeDecl.methods != null) top: for (AbstractMethodDeclaration def : typeDecl.methods) {
+			if (typeDecl.methods != null) for (AbstractMethodDeclaration def : typeDecl.methods) {
 				if (def instanceof ConstructorDeclaration) {
 					if ((def.bits & ASTNode.IsDefaultConstructor) != 0) continue;
 					

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -481,7 +481,7 @@ private JCMethodDecl generateCleanMethod(java.util.List<BuilderFieldData> builde
 		
 		statements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(type.toName("this")), type.toName("$lombokUnclean")), maker.Literal(CTC_BOOLEAN, false))));
 		JCBlock body = maker.Block(0, statements.toList());
-		return maker.MethodDef(maker.Modifiers(Flags.PUBLIC), type.toName("$lombokClean"), maker.Type(Javac.createVoidType(maker, CTC_VOID)), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);
+		return maker.MethodDef(maker.Modifiers(Flags.PUBLIC), type.toName("$lombokClean"), maker.Type(Javac.createVoidType(type.getSymbolTable(), CTC_VOID)), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);
 		/*
 		 * 		if (shouldReturnThis) {
 			methodType = cloneSelfType(field);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -641,7 +641,7 @@ public static MemberExistsResult constructorExists(JavacNode node) {
 		node = upToTypeNode(node);
 		
 		if (node != null && node.get() instanceof JCClassDecl) {
-			top: for (JCTree def : ((JCClassDecl)node.get()).defs) {
+			for (JCTree def : ((JCClassDecl)node.get()).defs) {
 				if (def instanceof JCMethodDecl) {
 					JCMethodDecl md = (JCMethodDecl) def;
 					if (md.name.contentEquals("<init>")) {

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2016 The Project Lombok Authors.
+ * Copyright (C) 2009-2017 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2016 The Project Lombok Authors.
+ * Copyright (C) 2009-2017 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -46,6 +46,7 @@
 import org.mangosdk.spi.ProviderFor;
 
 import com.sun.tools.javac.code.Flags;
+import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCBinary;
@@ -219,7 +220,7 @@ public void createGetterForField(AccessLevel level,
 		
 		long access = toJavacModifier(level) | (fieldDecl.mods.flags & Flags.STATIC);
 		
-		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source.get(), lazy, onMethod));
+		injectMethod(fieldNode.up(), createGetter(access, fieldNode, fieldNode.getTreeMaker(), source.get(), lazy, onMethod), List.<Type>nil(), getMirrorForFieldType(fieldNode));
 	}
 	
 	public JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker treeMaker, JCTree source, boolean lazy, List<JCAnnotation> onMethod) {

File: src/core/lombok/core/configuration/ConfigurationApp.java
Patch:
@@ -198,7 +198,7 @@ public int display(Collection<ConfigurationKey<?>> keys, boolean verbose, Collec
 			if (paths.size() == 1) {
 				if (!(argsPaths.size() == 1)) out.printf("Configuration for '%s'.%n%n", paths.iterator().next());
 			} else {
-				out.printf("Configuration for: %s%n", paths.iterator().next());
+				out.printf("Configuration for:%n");
 				for (String path : paths) out.printf("- %s%n", path);
 				out.println();
 			}

File: src/core/lombok/experimental/FieldDefaults.java
Patch:
@@ -33,9 +33,9 @@
  * <p>
  * Complete documentation is found at <a href="https://projectlombok.org/features/experimental/FieldDefaults.html">the project lombok features page for &#64;FieldDefaults</a>.
  * <p>
- * If {@code makeFinal} is {@code true}, then each field that is not annotated with {@code @NonFinal} will have the {@code final} modifier added.
+ * If {@code makeFinal} is {@code true}, then each (instance) field that is not annotated with {@code @NonFinal} will have the {@code final} modifier added.
  * <p>
- * If {@code level} is set, then each field that is package private (i.e. no access modifier) and does not have the {@code @PackagePrivate} annotation will
+ * If {@code level} is set, then each (instance) field that is package private (i.e. no access modifier) and does not have the {@code @PackagePrivate} annotation will
  * have the appropriate access level modifier added.
  */
 @Target(ElementType.TYPE)

File: src/core/lombok/experimental/NonFinal.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Used to indicate the explicit intention for the annotated entity to <em>not</em> be {@code final}.
- * Currently used by {@code FieldDefaults} to avoid having it make a field final.
+ * Currently used by {@code FieldDefaults} and {@code Value} to avoid having it make a field final.
  */
 @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.ANNOTATION_TYPE, ElementType.TYPE, ElementType.METHOD})
 @Retention(RetentionPolicy.SOURCE)

File: src/core/lombok/experimental/PackagePrivate.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Used to indicate the explicit intention for the annotated entity to have the <em>package private</em> access level.
- * Currently used by {@code FieldDefaults} to avoid having it make a field one of {@code public}, {@code protected}, or {@code private}.
+ * Currently used by {@code FieldDefaults} and {@code Value} to avoid having it make a field one of {@code public}, {@code protected}, or {@code private}.
  */
 @Target({ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE})
 @Retention(RetentionPolicy.SOURCE)

File: test/transform/resource/after-delombok/FieldDefaults.java
Patch:
@@ -1,11 +1,13 @@
 class FieldDefaults1 {
+	static int STATIC = 3;
 	final int x;
 	int y;
 	FieldDefaults1(int x) {
 		this.x = x;
 	}
 }
 class FieldDefaults2 {
+	static int STATIC = 3;
 	int x;
 	private int y;
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/ValueStaticField.java
Patch:
@@ -1,6 +1,6 @@
 final class ValueStaticField {
-	private static int x;
-	private static final String PASSWORD = "Ken sent me";
+	static int x;
+	static String PASSWORD = "Ken sent me";
 	@java.lang.SuppressWarnings("all")
 	@javax.annotation.Generated("lombok")
 	public ValueStaticField() {

File: test/transform/resource/after-ecj/ValueStaticField.java
Patch:
@@ -1,7 +1,7 @@
 import lombok.Value;
 final @Value class ValueStaticField {
-  private static int x;
-  private static final String PASSWORD = "Ken sent me";
+  static int x;
+  static String PASSWORD = "Ken sent me";
   <clinit>() {
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") boolean equals(final java.lang.Object o) {

File: test/transform/resource/before/FieldDefaults.java
Patch:
@@ -1,5 +1,6 @@
 @lombok.experimental.FieldDefaults(makeFinal = true)
 class FieldDefaults1 {
+	static int STATIC = 3;
 	int x;
 	@lombok.experimental.NonFinal int y;
 	
@@ -10,6 +11,7 @@ class FieldDefaults1 {
 
 @lombok.experimental.FieldDefaults(level = lombok.AccessLevel.PRIVATE)
 class FieldDefaults2 {
+	static int STATIC = 3;
 	@lombok.experimental.PackagePrivate int x;
 	int y;
 }
\ No newline at end of file

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -652,7 +652,7 @@ private void makeSimpleSetterMethodForBuilder(EclipseNode builderType, EclipseNo
 		for (int i = 0; i < len; i++) {
 			if (!(existing[i] instanceof MethodDeclaration)) continue;
 			char[] existingName = existing[i].selector;
-			if (Arrays.equals(name, existingName)) return;
+			if (Arrays.equals(name, existingName) && !isTolerate(fieldNode, existing[i])) return;
 		}
 		
 		String setterName = fluent ? fieldNode.getName() : HandlerUtil.buildAccessorName("set", fieldNode.getName());

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -608,8 +608,9 @@ private void makeSimpleSetterMethodForBuilder(JavacNode builderType, JavacNode f
 		
 		for (JavacNode child : builderType.down()) {
 			if (child.getKind() != Kind.METHOD) continue;
-			Name existingName = ((JCMethodDecl) child.get()).name;
-			if (existingName.equals(fieldName)) return;
+			JCMethodDecl methodDecl = (JCMethodDecl) child.get();
+			Name existingName = methodDecl.name;
+			if (existingName.equals(fieldName) && !isTolerate(fieldNode, methodDecl)) return;
 		}
 		
 		String setterName = fluent ? fieldNode.getName() : HandlerUtil.buildAccessorName("set", fieldNode.getName());

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -48,6 +48,7 @@
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
+import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Assignment;
 import org.eclipse.jdt.internal.compiler.ast.CharLiteral;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
@@ -381,6 +382,8 @@ public static ConstructorDeclaration createConstructor(
 	}
 	
 	private static Expression getDefaultExpr(TypeReference type, int s, int e) {
+		boolean array = type instanceof ArrayTypeReference;
+		if (array) return new NullLiteral(s, e);
 		char[] lastToken = type.getLastToken();
 		if (Arrays.equals(TypeConstants.BOOLEAN, lastToken)) return new FalseLiteral(s, e);
 		if (Arrays.equals(TypeConstants.CHAR, lastToken)) return new CharLiteral(new char[] {'\'', '\\', '0', '\''}, s, e);

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -652,7 +652,7 @@ private void makeSimpleSetterMethodForBuilder(EclipseNode builderType, EclipseNo
 		for (int i = 0; i < len; i++) {
 			if (!(existing[i] instanceof MethodDeclaration)) continue;
 			char[] existingName = existing[i].selector;
-			if (Arrays.equals(name, existingName)) return;
+			if (Arrays.equals(name, existingName) && !isTolerate(fieldNode, existing[i])) return;
 		}
 		
 		String setterName = fluent ? fieldNode.getName() : HandlerUtil.buildAccessorName("set", fieldNode.getName());

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -608,8 +608,9 @@ private void makeSimpleSetterMethodForBuilder(JavacNode builderType, JavacNode f
 		
 		for (JavacNode child : builderType.down()) {
 			if (child.getKind() != Kind.METHOD) continue;
-			Name existingName = ((JCMethodDecl) child.get()).name;
-			if (existingName.equals(fieldName)) return;
+			JCMethodDecl methodDecl = (JCMethodDecl) child.get();
+			Name existingName = methodDecl.name;
+			if (existingName.equals(fieldName) && !isTolerate(fieldNode, methodDecl)) return;
 		}
 		
 		String setterName = fluent ? fieldNode.getName() : HandlerUtil.buildAccessorName("set", fieldNode.getName());

File: test/transform/resource/after-delombok/VarNullInit.java
Patch:
@@ -1,4 +1,5 @@
-class VarNullInit {
+
+public class VarNullInit {
 	void method() {
 		java.lang.Object x = null;
 	}

File: test/transform/resource/after-ecj/VarNullInit.java
Patch:
@@ -1,7 +1,6 @@
 import lombok.experimental.var;
-
-class VarNullInit {
-  VarNullInit() {
+public class VarNullInit {
+  public VarNullInit() {
     super();
   }
   void method() {

File: test/transform/resource/before/VarNullInit.java
Patch:
@@ -1,7 +1,7 @@
 //CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
-class VarNullInit {
+public class VarNullInit {
 	void method() {
 		var x = null;
 	}

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -48,6 +48,7 @@
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
+import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Assignment;
 import org.eclipse.jdt.internal.compiler.ast.CharLiteral;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
@@ -381,6 +382,8 @@ public static ConstructorDeclaration createConstructor(
 	}
 	
 	private static Expression getDefaultExpr(TypeReference type, int s, int e) {
+		boolean array = type instanceof ArrayTypeReference;
+		if (array) return new NullLiteral(s, e);
 		char[] lastToken = type.getLastToken();
 		if (Arrays.equals(TypeConstants.BOOLEAN, lastToken)) return new FalseLiteral(s, e);
 		if (Arrays.equals(TypeConstants.CHAR, lastToken)) return new CharLiteral(new char[] {'\'', '\\', '0', '\''}, s, e);

File: src/core/lombok/core/configuration/FlagUsageType.java
Patch:
@@ -23,5 +23,5 @@
 
 /** Used for lombok configuration to flag usages of certain lombok feature. */
 public enum FlagUsageType {
-	WARNING, ERROR;
+	WARNING, ERROR, ALLOW;
 }

File: test/transform/resource/after-ecj/VarNullInit.java
Patch:
@@ -1,10 +1,10 @@
 import lombok.experimental.var;
 
 class VarNullInit {
-  ValNullInit() {
+  VarNullInit() {
     super();
   }
   void method() {
-    final @var java.lang.Object x = null;
+    @var java.lang.Object x = null;
   }
 }
\ No newline at end of file

File: test/transform/resource/before/VarComplex.java
Patch:
@@ -1,3 +1,4 @@
+//CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
 public class VarComplex {

File: test/transform/resource/before/VarInFor.java
Patch:
@@ -1,3 +1,4 @@
+//CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
 public class VarInFor {

File: test/transform/resource/before/VarInForOld.java
Patch:
@@ -1,3 +1,4 @@
+//CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
 public class VarInForOld {

File: test/transform/resource/before/VarModifier.java
Patch:
@@ -1,3 +1,4 @@
+//CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
 public class VarModifier {

File: test/transform/resource/before/VarNullInit.java
Patch:
@@ -1,3 +1,4 @@
+//CONF: lombok.var.flagUsage = ALLOW
 import lombok.experimental.var;
 
 class VarNullInit {

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -701,8 +701,7 @@ public DelegateRecursion(char[] type, char[] member) {
 	private static void addAllMethodBindings0(List<BindingTuple> list, TypeBinding binding, Set<String> banList, char[] fieldName, ASTNode responsible) throws DelegateRecursion {
 		if (binding instanceof SourceTypeBinding) {
 			ClassScope scope = ((SourceTypeBinding) binding).scope;
-			if (scope == null) return;
-			scope.environment().globalOptions.storeAnnotations = true;
+			if (scope != null) scope.environment().globalOptions.storeAnnotations = true;
 		}
 		if (binding == null) return;
 		

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -103,7 +103,6 @@ private ClassLoader findAndPatchClassLoader(ProcessingEnvironment procEnv) throw
 					URL selfUrl = new File(ClassRootFinder.findClassRootOfClass(AnnotationProcessor.class)).toURI().toURL();
 					m.invoke(environmentClassLoader, selfUrl);
 				}
-				return environmentClassLoader;
 			}
 			
 			ClassLoader ourClassLoader = JavacDescriptor.class.getClassLoader();

File: src/core/lombok/Value.java
Patch:
@@ -49,7 +49,7 @@
 	 * We suggest the name: "of", like so:
 	 * 
 	 * <pre>
-	 *     public @Data(staticConstructor = "of") class Point { final int x, y; }
+	 *     public @Value(staticConstructor = "of") class Point { final int x, y; }
 	 * </pre>
 	 * 
 	 * Default: No static constructor, instead the normal constructor is public.

File: src/core/lombok/extern/apachecommons/CommonsLog.java
Patch:
@@ -55,6 +55,7 @@
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
+ * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/java/Log.java
Patch:
@@ -54,6 +54,7 @@
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
+ * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/log4j/Log4j.java
Patch:
@@ -55,6 +55,7 @@
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
+ * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/log4j/Log4j2.java
Patch:
@@ -55,6 +55,7 @@
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
+ * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/slf4j/Slf4j.java
Patch:
@@ -54,7 +54,8 @@
  * @see lombok.extern.log4j.Log4j &#64;Log4j
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
- *  */
+ * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
+ */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)
 public @interface Slf4j {

File: src/core/lombok/extern/slf4j/XSlf4j.java
Patch:
@@ -54,6 +54,7 @@
  * @see lombok.extern.log4j.Log4j &#64;Log4j
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
+ * @see lombok.extern.jbosslog.JBossLog &#64;JBossLog
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -144,7 +144,7 @@ private FileSystem createFileSystem(File file) {
 		classpath.add("lib/test/org.slf4j-slf4j-ext.jar");
 		classpath.add("lib/test/log4j-log4j.jar");
 		classpath.add("lib/test/org.apache.logging.log4j-log4j-api.jar");
-		classpath.add("lib/test/jboss-logging.jar");
+		classpath.add("lib/test/org.jboss.logging-jboss-logging.jar");
 		classpath.add("lib/test/com.google.guava-guava.jar");
 		classpath.add("lib/test/com.google.code.findbugs-findbugs.jar");
 		return new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, "UTF-8");

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -144,6 +144,7 @@ private FileSystem createFileSystem(File file) {
 		classpath.add("lib/test/org.slf4j-slf4j-ext.jar");
 		classpath.add("lib/test/log4j-log4j.jar");
 		classpath.add("lib/test/org.apache.logging.log4j-log4j-api.jar");
+		classpath.add("lib/test/jboss-logging.jar");
 		classpath.add("lib/test/com.google.guava-guava.jar");
 		classpath.add("lib/test/com.google.code.findbugs-findbugs.jar");
 		return new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, "UTF-8");

File: src/core/lombok/Value.java
Patch:
@@ -49,7 +49,7 @@
 	 * We suggest the name: "of", like so:
 	 * 
 	 * <pre>
-	 *     public @Data(staticConstructor = "of") class Point { final int x, y; }
+	 *     public @Value(staticConstructor = "of") class Point { final int x, y; }
 	 * </pre>
 	 * 
 	 * Default: No static constructor, instead the normal constructor is public.

File: src/core/lombok/Value.java
Patch:
@@ -31,7 +31,7 @@
  * <p>
  * Equivalent to {@code @Getter @FieldDefaults(makeFinal=true, level=AccessLevel.PRIVATE) @AllArgsConstructor @ToString @EqualsAndHashCode}.
  * <p>
- * Complete documentation is found at <a href="https://projectlombok.org/features/experimental/Value.html">the project lombok features page for &#64;Value</a>.
+ * Complete documentation is found at <a href="https://projectlombok.org/features/Value.html">the project lombok features page for &#64;Value</a>.
  * 
  * @see lombok.Getter
  * @see lombok.experimental.FieldDefaults

File: src/core/lombok/Builder.java
Patch:
@@ -139,6 +139,8 @@
 	 * <p>
 	 * The default behaviour is to obtain a value by referencing the name of the parameter as a field on 'this'.
 	 */
+	@Target({FIELD, PARAMETER})
+	@Retention(SOURCE)
 	public @interface ObtainVia {
 		/** Tells lombok to obtain a value with the expression {@code this.value}. */
 		String field() default "";

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -75,9 +75,9 @@ static class JavacDescriptor extends ProcessorDescriptor {
 			
 			try {
 				ClassLoader classLoader = findAndPatchClassLoader(procEnv);
-				processor = (Processor)Class.forName("lombok.javac.apt.Processor", false, classLoader).newInstance();
+				processor = (Processor) Class.forName("lombok.javac.apt.LombokProcessor", false, classLoader).newInstance();
 			} catch (Exception e) {
-				delayedWarnings.add("You found a bug in lombok; lombok.javac.apt.Processor is not available. Lombok will not run during this compilation: " + trace(e));
+				delayedWarnings.add("You found a bug in lombok; lombok.javac.apt.LombokProcessor is not available. Lombok will not run during this compilation: " + trace(e));
 				return false;
 			} catch (NoClassDefFoundError e) {
 				delayedWarnings.add("Can't load javac processor due to (most likely) a class loader problem: " + trace(e));
@@ -86,7 +86,7 @@ static class JavacDescriptor extends ProcessorDescriptor {
 			try {
 				processor.init(procEnv);
 			} catch (Exception e) {
-				delayedWarnings.add("lombok.javac.apt.Processor could not be initialized. Lombok will not run during this compilation: " + trace(e));
+				delayedWarnings.add("lombok.javac.apt.LombokProcessor could not be initialized. Lombok will not run during this compilation: " + trace(e));
 				return false;
 			} catch (NoClassDefFoundError e) {
 				delayedWarnings.add("Can't initialize javac processor due to (most likely) a class loader problem: " + trace(e));

File: src/core/lombok/javac/apt/LombokProcessor.java
Patch:
@@ -66,7 +66,7 @@
  * running javac; that's the only requirement.
  */
 @SupportedAnnotationTypes("*")
-public class Processor extends AbstractProcessor {
+public class LombokProcessor extends AbstractProcessor {
 
 	private JavacProcessingEnvironment processingEnv;
 	private JavacTransformer transformer;

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -482,7 +482,7 @@ public boolean delombok() throws IOException {
 		List<JCCompilationUnit> roots = new ArrayList<JCCompilationUnit>();
 		Map<JCCompilationUnit, File> baseMap = new IdentityHashMap<JCCompilationUnit, File>();
 		
-		compiler.initProcessAnnotations(Collections.singleton(new lombok.javac.apt.Processor()));
+		compiler.initProcessAnnotations(Collections.singleton(new lombok.javac.apt.LombokProcessor()));
 		
 		for (File fileToParse : filesToParse) {
 			@SuppressWarnings("deprecation") JCCompilationUnit unit = compiler.parse(fileToParse.getAbsolutePath());

File: test/transform/resource/before/WitherWithAbstract.java
Patch:
@@ -0,0 +1,3 @@
+abstract class WitherWithAbstract {
+	@lombok.experimental.Wither String foo;
+}
\ No newline at end of file

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -711,7 +711,7 @@ private SingularData getSingularData(EclipseNode node, ASTNode source) {
 					node.addError("The singular must be specified explicitly (e.g. @Singular(\"task\")) because auto singularization is disabled.");
 					explicitSingular = new String(pluralName);
 				} else {
-					explicitSingular = autoSingularize(node.getName());
+					explicitSingular = autoSingularize(new String(pluralName));
 					if (explicitSingular == null) {
 						node.addError("Can't singularize this name; please specify the singular explicitly (i.e. @Singular(\"sheep\"))");
 						explicitSingular = new String(pluralName);

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -666,7 +666,7 @@ private SingularData getSingularData(JavacNode node) {
 					node.addError("The singular must be specified explicitly (e.g. @Singular(\"task\")) because auto singularization is disabled.");
 					explicitSingular = pluralName.toString();
 				} else {
-					explicitSingular = autoSingularize(node.getName());
+					explicitSingular = autoSingularize(pluralName.toString());
 					if (explicitSingular == null) {
 						node.addError("Can't singularize this name; please specify the singular explicitly (i.e. @Singular(\"sheep\"))");
 						explicitSingular = pluralName.toString();

File: src/delombok/lombok/delombok/PrettyPrinter.java
Patch:
@@ -1395,7 +1395,7 @@ private <T> T readObject(JCTree tree, String fieldName, T defaultValue) {
 		}
 	}
 	
-	@Override public void visitTypeBoundKind(TypeBoundKind tree) {
+	public void visitTypeBoundKind(TypeBoundKind tree) {
 		print(String.valueOf(tree.kind));
 	}
 	

File: src/delombok/lombok/delombok/PrettyPrinter.java
Patch:
@@ -1438,10 +1438,11 @@ private void printLambda0(JCTree tree) {
 		List<JCVariableDecl> params = readObject(tree, "params", List.<JCVariableDecl>nil());
 		boolean explicit = true;
 		int paramLength = params.size();
-		if (paramLength != 1) print("(");
 		try {
 			explicit = readObject(tree, "paramKind", new Object()).toString().equals("EXPLICIT");
 		} catch (Exception e) {}
+		boolean useParens = paramLength != 1 || explicit;
+		if (useParens) print("(");
 		if (explicit) {
 			boolean first = true;
 			for (JCVariableDecl vd : params) {
@@ -1457,7 +1458,7 @@ private void printLambda0(JCTree tree) {
 				sep = ", ";
 			}
 		}
-		if (paramLength != 1) print(")");
+		if (useParens) print(")");
 		print(" -> ");
 		JCTree body = readObject(tree, "body", (JCTree) null);
 		if (body instanceof JCBlock) {

File: test/transform/resource/after-delombok/BuilderSingularRedirectToGuava.java
Patch:
@@ -50,9 +50,9 @@ public BuilderSingularRedirectToGuavaBuilder clearDangerMice() {
 		}
 		@java.lang.SuppressWarnings("all")
 		@javax.annotation.Generated("lombok")
-		public BuilderSingularRedirectToGuavaBuilder thing(final Integer thing$key, final Number thing$value) {
+		public BuilderSingularRedirectToGuavaBuilder thing(final Integer key, final Number value) {
 			if (this.things == null) this.things = com.google.common.collect.ImmutableSortedMap.naturalOrder();
-			this.things.put(thing$key, thing$value);
+			this.things.put(key, value);
 			return this;
 		}
 		@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-ecj/BuilderSingularRedirectToGuava.java
Patch:
@@ -26,10 +26,10 @@
       this.dangerMice = null;
       return this;
     }
-    public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") BuilderSingularRedirectToGuavaBuilder thing(Integer thing$key, Number thing$value) {
+    public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") BuilderSingularRedirectToGuavaBuilder thing(Integer key, Number value) {
       if ((this.things == null))
           this.things = com.google.common.collect.ImmutableSortedMap.naturalOrder();
-      this.things.put(thing$key, thing$value);
+      this.things.put(key, value);
       return this;
     }
     public @java.lang.SuppressWarnings("all") @javax.annotation.Generated("lombok") BuilderSingularRedirectToGuavaBuilder things(java.util.Map<? extends Integer, ? extends Number> things) {

File: src/delombok/lombok/delombok/PrettyPrinter.java
Patch:
@@ -372,6 +372,8 @@ private void printComment(CommentInfo comment) {
 			break;
 		}
 		
+		if (onNewLine && !aligned && comment.start != StartConnection.START_OF_LINE) needsAlign = true;
+		
 		print(comment.content);
 		
 		switch (comment.end) {

File: test/transform/resource/before/ValLambda.java
Patch:
@@ -14,7 +14,7 @@ public void easyLubLambda() {
 	}
 	
 //	public void castLubLambda() {
-//		Runnable foo = (Runnable)((System.currentTimeMillis() > 0) ? ()-> {} : System.out::println);
-//		lombok.val foo = (Runnable)((System.currentTimeMillis() > 0) ? ()-> {} : System.out::println);
+//		Runnable foo = (Runnable) ((System.currentTimeMillis() > 0) ? () -> {} : System.out::println);
+//		lombok.val foo = (Runnable) ((System.currentTimeMillis() > 0) ? () -> {} : System.out::println);
 //	}
 }

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -141,6 +141,7 @@ public class HandleNonNull extends JavacAnnotationHandler<NonNull> {
 		List<JCStatement> newList = tail.prepend(nullCheck);
 		for (JCStatement stat : head) newList = newList.prepend(stat);
 		declaration.body.stats = newList;
+		annotationNode.getAst().setChanged();
 	}
 	
 	public boolean isNullCheck(JCStatement stat) {

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -160,8 +160,8 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 		
 		if (fd == null && (type.modifiers & (ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation)) != 0) return;
 		
-		boolean defaultToPrivate = Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_PRIVATE_EVERYWHERE));
-		boolean defaultToFinal = Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
+		boolean defaultToPrivate = levelIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_PRIVATE_EVERYWHERE));
+		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -140,8 +140,8 @@ public void setFieldDefaultsForField(JavacNode fieldNode, AccessLevel level, boo
 		
 		if (fd == null && (type.mods.flags & (Flags.INTERFACE | Flags.ANNOTATION)) != 0) return;
 		
-		boolean defaultToPrivate = Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_PRIVATE_EVERYWHERE));
-		boolean defaultToFinal = Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
+		boolean defaultToPrivate = levelIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_PRIVATE_EVERYWHERE));
+		boolean defaultToFinal = makeFinalIsExplicit ? false : Boolean.TRUE.equals(typeNode.getAst().readConfiguration(ConfigurationKeys.FIELD_DEFAULTS_FINAL_EVERYWHERE));
 		
 		if (!defaultToPrivate && !defaultToFinal && fieldDefaults == null) return;
 		AccessLevel fdAccessLevel = (fieldDefaults != null && levelIsExplicit) ? fd.level() : defaultToPrivate ? AccessLevel.PRIVATE : null;

File: test/transform/resource/after-delombok/NonNullOnParameterOfDefaultMethod.java
Patch:
@@ -1,3 +1,4 @@
+// version 8:
 interface NonNullOnParameterOfDefaultMethod {
 	void test(@lombok.NonNull String arg);
 	default void test2(@lombok.NonNull String arg) {

File: test/transform/resource/before/NonNullOnParameterOfDefaultMethod.java
Patch:
@@ -1,3 +1,4 @@
+// version 8:
 interface NonNullOnParameterOfDefaultMethod {
 	void test(@lombok.NonNull String arg);
 	default void test2(@lombok.NonNull String arg) {

File: src/core/lombok/eclipse/handlers/HandleNonNull.java
Patch:
@@ -91,7 +91,7 @@ public class HandleNonNull extends EclipseAnnotationHandler<NonNull> {
 		if (isGenerated(declaration)) return;
 		
 		if (declaration.isAbstract()) {
-			annotationNode.addWarning("@NonNull is meaningless on a parameter of an abstract method.");
+			// This used to be a warning, but as @NonNull also has a documentary purpose, better to not warn about this. Since 1.16.7
 			return;
 		}
 		

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -85,7 +85,7 @@ public class HandleNonNull extends JavacAnnotationHandler<NonNull> {
 		}
 		
 		if (declaration.body == null) {
-			annotationNode.addWarning("@NonNull is meaningless on a parameter of an abstract method.");
+			// This used to be a warning, but as @NonNull also has a documentary purpose, better to not warn about this. Since 1.16.7
 			return;
 		}
 		

File: src/core/lombok/eclipse/EclipseASTVisitor.java
Patch:
@@ -40,7 +40,7 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 
 /**
- * Implement so you can ask any JavacAST.Node to traverse depth-first through all children,
+ * Implement so you can ask any EclipseAST.Node to traverse depth-first through all children,
  * calling the appropriate visit and endVisit methods.
  */
 public interface EclipseASTVisitor {

File: src/core/lombok/ConfigurationKeys.java
Patch:
@@ -418,7 +418,7 @@ private ConfigurationKeys() {}
 	 * 
 	 * If set, <em>any</em> usage of {@code @UtilityClass} results in a warning / error.
 	 */
-	public static final ConfigurationKey<FlagUsageType> UTLITY_CLASS_FLAG_USAGE = new ConfigurationKey<FlagUsageType>("lombok.utilityClass.flagUsage", "Emit a warning or error if @UtilityClass is used.") {};
+	public static final ConfigurationKey<FlagUsageType> UTILITY_CLASS_FLAG_USAGE = new ConfigurationKey<FlagUsageType>("lombok.utilityClass.flagUsage", "Emit a warning or error if @UtilityClass is used.") {};
 	
 	// ----- Configuration System -----
 	

File: src/core/lombok/eclipse/handlers/HandleUtilityClass.java
Patch:
@@ -60,7 +60,7 @@
 @ProviderFor(EclipseAnnotationHandler.class)
 public class HandleUtilityClass extends EclipseAnnotationHandler<UtilityClass> {
 	@Override public void handle(AnnotationValues<UtilityClass> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, ConfigurationKeys.UTLITY_CLASS_FLAG_USAGE, "@UtilityClass");
+		handleFlagUsage(annotationNode, ConfigurationKeys.UTILITY_CLASS_FLAG_USAGE, "@UtilityClass");
 		
 		EclipseNode typeNode = annotationNode.up();
 		if (!checkLegality(typeNode, annotationNode)) return;

File: src/core/lombok/javac/handlers/HandleUtilityClass.java
Patch:
@@ -52,7 +52,7 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleUtilityClass extends JavacAnnotationHandler<UtilityClass> {
 	@Override public void handle(AnnotationValues<UtilityClass> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.UTLITY_CLASS_FLAG_USAGE, "@UtilityClass");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.UTILITY_CLASS_FLAG_USAGE, "@UtilityClass");
 		
 		deleteAnnotationIfNeccessary(annotationNode, UtilityClass.class);
 		

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -450,7 +450,7 @@ public static boolean hasAnnotation(Class<? extends java.lang.annotation.Annotat
 	 */
 	public static boolean annotationTypeMatches(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {
 		if (node.getKind() != Kind.ANNOTATION) return false;
-		return typeMatches(type, node, ((Annotation)node.get()).type);
+		return typeMatches(type, node, ((Annotation) node.get()).type);
 	}
 	
 	public static TypeReference cloneSelfType(EclipseNode context) {

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -74,9 +74,10 @@ public class EclipsePatcher implements AgentLauncher.AgentLaunchable {
 	private static void registerPatchScripts(Instrumentation instrumentation, boolean reloadExistingClasses, boolean ecjOnly, Class<?> launchingContext) {
 		ScriptManager sm = new ScriptManager();
 		sm.registerTransformer(instrumentation);
+		final boolean forceBaseResourceNames = !"".equals(System.getProperty("shadow.override.lombok", ""));
 		sm.setTransplantMapper(new TransplantMapper() {
 			public String mapResourceName(int classFileFormatVersion, String resourceName) {
-				if (classFileFormatVersion < 50) return resourceName;
+				if (classFileFormatVersion < 50 || forceBaseResourceNames) return resourceName;
 				return "Class50/" + resourceName;
 			}
 		});

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethodCompletionProposal.java
Patch:
@@ -60,8 +60,6 @@
 import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;
 
 public class PatchExtensionMethodCompletionProposal {
-
-	
 	public static IJavaCompletionProposal[] getJavaCompletionProposals(IJavaCompletionProposal[] javaCompletionProposals,
 			CompletionProposalCollector completionProposalCollector) {
 		
@@ -178,7 +176,7 @@ private static boolean canExtendCodeAssist(List<IJavaCompletionProposal> proposa
 		return !proposals.isEmpty() && Reflection.isComplete();
 	}
 	
-	private static int getReplacementOffset(IJavaCompletionProposal proposal) {
+	private static int getReplacementOffset(Object proposal) {
 		try {
 			return Reflection.replacementOffsetField.getInt(proposal);
 		} catch (Exception ignore) {

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethodCompletionProposalPortal.java
Patch:
@@ -52,7 +52,7 @@ public static IJavaCompletionProposal[] getJavaCompletionProposals(Object[] java
 			}
 			//ignore, we don't have access to the correct ECJ classes, so lombok can't possibly
 			//do anything useful here.
-			return (IJavaCompletionProposal[])javaCompletionProposals;
+			return (IJavaCompletionProposal[]) javaCompletionProposals;
 		}
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -75,8 +75,9 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea
 		ScriptManager sm = new ScriptManager();
 		sm.registerTransformer(instrumentation);
 		sm.setTransplantMapper(new TransplantMapper() {
-			public String getPrefixFor(int classFileFormatVersion) {
-				return classFileFormatVersion > 49 ? "Class50/" : "";
+			public String mapResourceName(int classFileFormatVersion, String resourceName) {
+				if (classFileFormatVersion < 50) return resourceName;
+				return "Class50/" + resourceName;
 			}
 		});
 		

File: src/launch/lombok/launch/Main.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Project Lombok Authors.
+ * Copyright (C) 2014-2015 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -22,10 +22,11 @@
 package lombok.launch;
 
 import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
 
 class Main {
 	static ClassLoader createShadowClassLoader() {
-		return new ShadowClassLoader(Main.class.getClassLoader(), "lombok");
+		return new ShadowClassLoader(Main.class.getClassLoader(), "lombok", null, Arrays.<String>asList(), Arrays.asList("lombok.patcher.Symbols"));
 	}
 	
 	public static void main(String[] args) throws Throwable {

File: src/eclipseAgent/lombok/eclipse/agent/EclipseLoaderPatcher.java
Patch:
@@ -44,7 +44,7 @@ public static void patchEquinoxLoaders(ScriptManager sm, Class<?> launchingConte
 				.transplant()
 				.request(StackRequest.THIS, StackRequest.PARAM1, StackRequest.PARAM2).build());
 		
-		sm.addScript(ScriptBuilder.addField().setPublic()
+		sm.addScript(ScriptBuilder.addField().setPublic().setVolatile()
 				.fieldType("Ljava/lang/ClassLoader;")
 				.fieldName("lombok$shadowLoader")
 				.targetClass("org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader")

File: test/transform/resource/before/BuilderSingularNoAuto.java
Patch:
@@ -4,7 +4,7 @@
 import lombok.Singular;
 
 @lombok.Builder
-class BuilderSingularNoAutosingularize {
+class BuilderSingularNoAuto {
 	@Singular private List<String> things;
 	@Singular("widget") private List<String> widgets;
 	@Singular private List<String> items;

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -1625,7 +1625,6 @@ public void visitTree(JCTree tree) {
 	
 	private void visitLambda0(JCTree tree) {
 		try {
-			print("(");
 			@SuppressWarnings("unchecked")
 			List<JCVariableDecl> params = (List<JCVariableDecl>) readTreeList(tree, "params");
 			boolean explicit = true;

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.List;
 
 import lombok.core.AgentLauncher;
-
 import lombok.patcher.Hook;
 import lombok.patcher.MethodTarget;
 import lombok.patcher.ScriptManager;

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -33,6 +33,7 @@
 import javax.lang.model.type.TypeKind;
 
 import lombok.Lombok;
+import lombok.core.debug.AssertionLogger;
 
 import com.sun.tools.javac.code.BoundKind;
 import com.sun.tools.javac.code.Symbol.TypeSymbol;
@@ -191,6 +192,7 @@ private void memberEnterAndAttribute(JCTree copy, Env<AttrContext> env, Context
 			copy.accept(memberEnter);
 		} catch (Exception ignore) {
 			// intentionally ignored; usually even if this step fails, val will work (but not for val in method local inner classes and anonymous inner classes).
+			AssertionLogger.assertLog("member enter failed.", ignore);
 		} finally {
 			setEnvOfMemberEnter(memberEnter, oldEnv);
 		}

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -127,8 +127,8 @@ public void generateWitherForField(EclipseNode fieldNode, EclipseNode sourceNode
 		AccessLevel level = annotation.getInstance().value();
 		if (level == AccessLevel.NONE || node == null) return;
 		
-		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Setter(onMethod=", annotationNode);
-		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Setter(onParam=", annotationNode);
+		List<Annotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Wither(onMethod=", annotationNode);
+		List<Annotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Wither(onParam=", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -129,8 +129,8 @@ public void generateWitherForField(JavacNode fieldNode, DiagnosticPosition pos,
 		
 		if (level == AccessLevel.NONE || node == null) return;
 		
-		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Setter(onMethod=", annotationNode);
-		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Setter(onParam=", annotationNode);
+		List<JCAnnotation> onMethod = unboxAndRemoveAnnotationParameter(ast, "onMethod", "@Wither(onMethod=", annotationNode);
+		List<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, "onParam", "@Wither(onParam=", annotationNode);
 		
 		switch (node.getKind()) {
 		case FIELD:

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -143,6 +143,7 @@ private FileSystem createFileSystem(File file) {
 		classpath.add("lib/test/log4j-log4j.jar");
 		classpath.add("lib/test/org.apache.logging.log4j-log4j-api.jar");
 		classpath.add("lib/test/com.google.guava-guava.jar");
+		classpath.add("lib/test/com.google.code.findbugs-findbugs.jar");
 		return new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, "UTF-8");
 	}
 }

File: test/core/src/lombok/LombokTestSource.java
Patch:
@@ -183,6 +183,8 @@ private LombokTestSource(File file, String content, List<CompilerMessageMatcher>
 				continue;
 			}
 			
+			if (lc.startsWith("issue ")) continue;
+			
 			Assert.fail("Directive line \"" + directive + "\" in '" + file.getAbsolutePath() + "' invalid: unrecognized directive.");
 			throw new RuntimeException();
 		}

File: test/transform/resource/before/ValAnonymousSubclassWithGenerics.java
Patch:
@@ -1,4 +1,4 @@
-// ignore
+// issue 205: val inside anonymous inner classes is a bit tricky in javac, this test ensures we don't break it.
 import java.util.*;
 import lombok.val;
 

File: test/transform/resource/before/ValWithLocalClasses.java
Patch:
@@ -1,3 +1,4 @@
+//issue 694: In javac, resolving the RHS (which is what val does) can cause an entire class to be resolved, breaking all usage of val inside that class. This tests that we handle that better.
 class ValWithLocalClasses1 {
 	{
 		lombok.val f2 = new ValWithLocalClasses2() {};

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2014 The Project Lombok Authors.
+ * Copyright (C) 2011-2015 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 The Project Lombok Authors.
+ * Copyright (C) 2010-2015 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2015 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/utils/lombok/javac/TreeMirrorMaker.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 The Project Lombok Authors.
+ * Copyright (C) 2010-2015 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -241,7 +241,7 @@ private static JCExpression typeToJCTree(Type type, JavacAST ast, boolean allowC
 		Type type0 = type;
 		while (type0 instanceof ArrayType) {
 			dims++;
-			type0 = ((ArrayType)type0).elemtype;
+			type0 = ((ArrayType) type0).elemtype;
 		}
 		
 		JCExpression result = typeToJCTree0(type0, ast, allowCompound, allowVoid);

File: src/utils/lombok/javac/Javac.java
Patch:
@@ -162,6 +162,9 @@ public static Object calculateGuess(JCExpression expr) {
 	public static final TypeTag CTC_VOID = typeTag("VOID");
 	public static final TypeTag CTC_NONE = typeTag("NONE");
 	public static final TypeTag CTC_BOT = typeTag("BOT");
+	public static final TypeTag CTC_ERROR = typeTag("ERROR");
+	public static final TypeTag CTC_UNKNOWN = typeTag("UNKNOWN");
+	public static final TypeTag CTC_UNDETVAR = typeTag("UNDETVAR");
 	public static final TypeTag CTC_CLASS = typeTag("CLASS");
 	
 	public static final TreeTag CTC_NOT_EQUAL = treeTag("NE");

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -270,14 +270,12 @@ public MethodDeclaration createGetter(TypeDeclaration parent, EclipseNode fieldN
 				deprecated = new Annotation[] { generateDeprecatedAnnotation(source) };
 			}
 			
-			Annotation[] copiedAnnotations = copyAnnotations(source,
+			method.annotations = copyAnnotations(source,
 					onMethod.toArray(new Annotation[0]),
 					findAnnotations(field, NON_NULL_PATTERN),
 					findAnnotations(field, NULLABLE_PATTERN),
 					findDelegatesAndMarkAsHandled(fieldNode),
 					deprecated);
-			
-			if (copiedAnnotations.length != 0) method.annotations = copiedAnnotations;
 		}
 		
 		method.traverse(new SetGeneratedByVisitor(source), parent.scope);

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethod.java
Patch:
@@ -227,8 +227,11 @@ public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend meth
 					if (argument.resolvedType != null) argumentTypes.add(argument.resolvedType);
 					// TODO: Instead of just skipping nulls entirely, there is probably a 'unresolved type' placeholder. THAT is what we ought to be adding here!
 				}
+				Expression[] originalArgs = methodCall.arguments;
+				methodCall.arguments = arguments.toArray(new Expression[0]);
 				MethodBinding fixedBinding = scope.getMethod(extensionMethod.declaringClass, methodCall.selector, argumentTypes.toArray(new TypeBinding[0]), methodCall);
 				if (fixedBinding instanceof ProblemMethodBinding) {
+					methodCall.arguments = originalArgs;
 					if (fixedBinding.declaringClass != null) {
 						scope.problemReporter().invalidMethod(methodCall, fixedBinding);
 					}
@@ -247,7 +250,6 @@ public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend meth
 							arg.implicitConversion = TypeIds.UNBOXING | (id + (id << 4)); // magic see TypeIds
 						}
 					}
-					methodCall.arguments = arguments.toArray(new Expression[0]);
 					
 					methodCall.receiver = createNameRef(extensionMethod.declaringClass, methodCall);
 					methodCall.actualReceiverType = extensionMethod.declaringClass;

File: src/eclipseAgent/lombok/eclipse/agent/PatchVal.java
Patch:
@@ -128,7 +128,9 @@ public static boolean handleValForLocalDeclaration(LocalDeclaration local, Block
 		
 		if (!isVal(local.type, scope)) return false;
 		
-		if (new Throwable().getStackTrace()[2].getClassName().contains("ForStatement")) return false;
+		StackTraceElement[] st = new Throwable().getStackTrace();
+		if (st.length > 2 && st[2].getClassName().contains("ForStatement")) return false;
+		if (st.length > 8 && st[8].getClassName().contains("ForStatement")) return false;
 		
 		Expression init = local.initialization;
 		if (init == null && Reflection.initCopyField != null) {

File: src/core/lombok/eclipse/handlers/singulars/EclipseGuavaSingularizer.java
Patch:
@@ -205,6 +205,7 @@ void generatePluralMethod(TypeReference returnType, Statement returnStatement, S
 			emptyInvoke = new MessageSend();
 			emptyInvoke.selector = new char[] {'o', 'f'};
 			emptyInvoke.receiver = new QualifiedNameReference(makeGuavaTypeName(getSimpleTargetTypeName(data), false), NULL_POSS, 0, 0);
+			emptyInvoke.typeArguments = createTypeArgs(mapMode ? 2 : 1, false, builderType, data.getTypeArgs());
 		}
 		
 		MessageSend invokeBuild; {

File: src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java
Patch:
@@ -159,7 +159,8 @@ protected void generatePluralMethod(JavacTreeMaker maker, JCExpression returnTyp
 		JCExpression empty; {
 			//ImmutableX.of()
 			JCExpression emptyMethod = chainDots(builderType, "com", "google", "common", "collect", getSimpleTargetTypeName(data), "of");
-			empty = maker.Apply(jceBlank, emptyMethod, jceBlank);
+			List<JCExpression> invokeTypeArgs = createTypeArgs(mapMode ? 2 : 1, false, builderType, data.getTypeArgs(), source);
+			empty = maker.Apply(invokeTypeArgs, emptyMethod, jceBlank);
 		}
 		
 		JCExpression invokeBuild; {

File: test/transform/resource/after-delombok/BuilderSingularGuavaMaps.java
Patch:
@@ -58,9 +58,9 @@ public BuilderSingularGuavaMapsBuilder<K, V> rawMap(final java.util.Map<?, ?> ra
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularGuavaMaps<K, V> build() {
-			com.google.common.collect.ImmutableMap<K, V> battleaxes = this.battleaxes == null ? com.google.common.collect.ImmutableMap.of() : this.battleaxes.build();
-			com.google.common.collect.ImmutableSortedMap<Integer, V> vertices = this.vertices == null ? com.google.common.collect.ImmutableSortedMap.of() : this.vertices.build();
-			com.google.common.collect.ImmutableBiMap<java.lang.Object, java.lang.Object> rawMap = this.rawMap == null ? com.google.common.collect.ImmutableBiMap.of() : this.rawMap.build();
+			com.google.common.collect.ImmutableMap<K, V> battleaxes = this.battleaxes == null ? com.google.common.collect.ImmutableMap.<K, V>of() : this.battleaxes.build();
+			com.google.common.collect.ImmutableSortedMap<Integer, V> vertices = this.vertices == null ? com.google.common.collect.ImmutableSortedMap.<Integer, V>of() : this.vertices.build();
+			com.google.common.collect.ImmutableBiMap<java.lang.Object, java.lang.Object> rawMap = this.rawMap == null ? com.google.common.collect.ImmutableBiMap.<java.lang.Object, java.lang.Object>of() : this.rawMap.build();
 			return new BuilderSingularGuavaMaps<K, V>(battleaxes, vertices, rawMap);
 		}
 		@java.lang.Override

File: test/transform/resource/after-delombok/BuilderSingularRedirectToGuava.java
Patch:
@@ -57,9 +57,9 @@ public BuilderSingularRedirectToGuavaBuilder doohickeys(final java.lang.Iterable
 		}
 		@java.lang.SuppressWarnings("all")
 		public BuilderSingularRedirectToGuava build() {
-			java.util.Set<String> dangerMice = this.dangerMice == null ? com.google.common.collect.ImmutableSet.of() : this.dangerMice.build();
-			java.util.NavigableMap<Integer, Number> things = this.things == null ? com.google.common.collect.ImmutableSortedMap.of() : this.things.build();
-			java.util.Collection<Class<?>> doohickeys = this.doohickeys == null ? com.google.common.collect.ImmutableList.of() : this.doohickeys.build();
+			java.util.Set<String> dangerMice = this.dangerMice == null ? com.google.common.collect.ImmutableSet.<String>of() : this.dangerMice.build();
+			java.util.NavigableMap<Integer, Number> things = this.things == null ? com.google.common.collect.ImmutableSortedMap.<Integer, Number>of() : this.things.build();
+			java.util.Collection<Class<?>> doohickeys = this.doohickeys == null ? com.google.common.collect.ImmutableList.<Class<?>>of() : this.doohickeys.build();
 			return new BuilderSingularRedirectToGuava(dangerMice, things, doohickeys);
 		}
 		@java.lang.Override

File: test/transform/resource/after-ecj/BuilderSingularGuavaMaps.java
Patch:
@@ -47,9 +47,9 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularGuavaMaps<K, V> build() {
-      com.google.common.collect.ImmutableMap<K, V> battleaxes = ((this.battleaxes == null) ? com.google.common.collect.ImmutableMap.of() : this.battleaxes.build());
-      com.google.common.collect.ImmutableSortedMap<Integer, V> vertices = ((this.vertices == null) ? com.google.common.collect.ImmutableSortedMap.of() : this.vertices.build());
-      com.google.common.collect.ImmutableBiMap<java.lang.Object, java.lang.Object> rawMap = ((this.rawMap == null) ? com.google.common.collect.ImmutableBiMap.of() : this.rawMap.build());
+      com.google.common.collect.ImmutableMap<K, V> battleaxes = ((this.battleaxes == null) ? com.google.common.collect.ImmutableMap.<K, V>of() : this.battleaxes.build());
+      com.google.common.collect.ImmutableSortedMap<Integer, V> vertices = ((this.vertices == null) ? com.google.common.collect.ImmutableSortedMap.<Integer, V>of() : this.vertices.build());
+      com.google.common.collect.ImmutableBiMap<java.lang.Object, java.lang.Object> rawMap = ((this.rawMap == null) ? com.google.common.collect.ImmutableBiMap.<java.lang.Object, java.lang.Object>of() : this.rawMap.build());
       return new BuilderSingularGuavaMaps<K, V>(battleaxes, vertices, rawMap);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/BuilderSingularRedirectToGuava.java
Patch:
@@ -47,9 +47,9 @@
       return this;
     }
     public @java.lang.SuppressWarnings("all") BuilderSingularRedirectToGuava build() {
-      java.util.Set<String> dangerMice = ((this.dangerMice == null) ? com.google.common.collect.ImmutableSet.of() : this.dangerMice.build());
-      java.util.NavigableMap<Integer, Number> things = ((this.things == null) ? com.google.common.collect.ImmutableSortedMap.of() : this.things.build());
-      java.util.Collection<Class<?>> doohickeys = ((this.doohickeys == null) ? com.google.common.collect.ImmutableList.of() : this.doohickeys.build());
+      java.util.Set<String> dangerMice = ((this.dangerMice == null) ? com.google.common.collect.ImmutableSet.<String>of() : this.dangerMice.build());
+      java.util.NavigableMap<Integer, Number> things = ((this.things == null) ? com.google.common.collect.ImmutableSortedMap.<Integer, Number>of() : this.things.build());
+      java.util.Collection<Class<?>> doohickeys = ((this.doohickeys == null) ? com.google.common.collect.ImmutableList.<Class<?>>of() : this.doohickeys.build());
       return new BuilderSingularRedirectToGuava(dangerMice, things, doohickeys);
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: src/core/lombok/Singular.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 The Project Lombok Authors.
+ * Copyright (C) 2015 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -112,8 +112,6 @@ public void transformCode(Collection<CompilerMessage> messages, StringWriter res
 			}
 		};
 		
-		// TODO: Create a configuration based on confLines and set this up so that this compile run will use them.
-		
 		ecjCompiler.compile(new ICompilationUnit[] {sourceUnit});
 		
 		CompilationResult compilationResult = compilationResult_.get();
@@ -137,6 +135,7 @@ private FileSystem createFileSystem(File file) {
 				i.remove();
 			}
 		}
+		classpath.add("bin");
 		classpath.add("dist/lombok.jar");
 		classpath.add("lib/test/commons-logging-commons-logging.jar");
 		classpath.add("lib/test/org.slf4j-slf4j-api.jar");

File: src/core/lombok/core/Main.java
Patch:
@@ -143,7 +143,7 @@ public void printHelp(String message, PrintStream out) {
 			out.println("------------------------------");
 		}
 		out.println("projectlombok.org " + Version.getFullVersion());
-		out.println("Copyright (C) 2009-2012 The Project Lombok Authors.");
+		out.println("Copyright (C) 2009-2015 The Project Lombok Authors.");
 		out.println("Run 'lombok license' to see the lombok license agreement.");
 		out.println();
 		out.println("Run lombok without any parameters to start the graphical installer.");

File: src/delombok/lombok/delombok/UnicodeEscapeWriter.java
Patch:
@@ -63,6 +63,6 @@ public final void write(char[] cbuf, int off, int len) throws IOException {
 	}
 	
 	protected void writeUnicodeEscape(char c) throws IOException {
-		writer.write("\\u" + Integer.toHexString(c));
+		writer.write(String.format("\\u%04x", (int) c));
 	}
 }
\ No newline at end of file

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -75,7 +75,7 @@ public boolean compareFile(DirectoryRunner.TestParams params, File file) throws
 			}
 		});
 		
-		transformCode(messages, writer, file);
+		transformCode(messages, writer, file, sourceDirectives.getSpecifiedEncoding());
 		
 		compare(file.getName(), expected, writer.toString(), messages, params.printErrors(), sourceDirectives.isSkipCompareContent() || expected.isSkipCompareContent());
 		return true;
@@ -97,7 +97,7 @@ private static int getClasspathVersion() {
 		return 8;
 	}
 	
-	protected abstract void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file) throws Throwable;
+	protected abstract void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding) throws Throwable;
 	
 	protected String readFile(File file) throws IOException {
 		BufferedReader reader;

File: test/core/src/lombok/RunTestsViaDelombok.java
Patch:
@@ -34,10 +34,10 @@ public class RunTestsViaDelombok extends AbstractRunTests {
 	private Delombok delombok = new Delombok();
 	
 	@Override
-	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, final File file) throws Throwable {
+	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, final File file, String encoding) throws Throwable {
 		delombok.setVerbose(false);
 		delombok.setForceProcess(true);
-		delombok.setCharset("UTF-8");
+		delombok.setCharset(encoding == null ? "UTF-8" : encoding);
 		
 		delombok.setDiagnosticsListener(new CapturingDiagnosticListener(file, messages));
 		

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -93,7 +93,7 @@ public boolean ignoreAllErrors() {
 	}
 	
 	@Override
-	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file) throws Throwable {
+	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding) throws Throwable {
 		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
 		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
 		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {
@@ -103,7 +103,7 @@ public void transformCode(Collection<CompilerMessage> messages, StringWriter res
 		};
 		
 		String source = readFile(file);
-		final CompilationUnit sourceUnit = new CompilationUnit(source.toCharArray(), file.getName(), "UTF-8");
+		final CompilationUnit sourceUnit = new CompilationUnit(source.toCharArray(), file.getName(), encoding == null ? "UTF-8" : encoding);
 		
 		Compiler ecjCompiler = new Compiler(createFileSystem(file), ecjErrorHandlingPolicy(), ecjCompilerOptions(), bitbucketRequestor, new DefaultProblemFactory(Locale.ENGLISH)) {
 			@Override protected synchronized void addCompilationUnit(ICompilationUnit inUnit, CompilationUnitDeclaration parsedUnit) {

File: test/transform/resource/after-ecj/EncodingUsAscii.java
Patch:
@@ -0,0 +1 @@
+//ignore: This test serves to check what happens with 'weird' characters when you use delombok. It's just not relevant for ecj.

File: src/delombok/lombok/delombok/UnicodeEscapeWriter.java
Patch:
@@ -63,6 +63,6 @@ public final void write(char[] cbuf, int off, int len) throws IOException {
 	}
 	
 	protected void writeUnicodeEscape(char c) throws IOException {
-		writer.write("\\u" + Integer.toHexString(c));
+		writer.write(String.format("\\u%04x", (int) c));
 	}
 }
\ No newline at end of file

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -75,7 +75,7 @@ public boolean compareFile(DirectoryRunner.TestParams params, File file) throws
 			}
 		});
 		
-		transformCode(messages, writer, file);
+		transformCode(messages, writer, file, sourceDirectives.getSpecifiedEncoding());
 		
 		compare(file.getName(), expected, writer.toString(), messages, params.printErrors(), sourceDirectives.isSkipCompareContent() || expected.isSkipCompareContent());
 		return true;
@@ -97,7 +97,7 @@ private static int getClasspathVersion() {
 		return 8;
 	}
 	
-	protected abstract void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file) throws Throwable;
+	protected abstract void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding) throws Throwable;
 	
 	protected String readFile(File file) throws IOException {
 		BufferedReader reader;

File: test/core/src/lombok/RunTestsViaDelombok.java
Patch:
@@ -34,10 +34,10 @@ public class RunTestsViaDelombok extends AbstractRunTests {
 	private Delombok delombok = new Delombok();
 	
 	@Override
-	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, final File file) throws Throwable {
+	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, final File file, String encoding) throws Throwable {
 		delombok.setVerbose(false);
 		delombok.setForceProcess(true);
-		delombok.setCharset("UTF-8");
+		delombok.setCharset(encoding == null ? "UTF-8" : encoding);
 		
 		delombok.setDiagnosticsListener(new CapturingDiagnosticListener(file, messages));
 		

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -93,7 +93,7 @@ public boolean ignoreAllErrors() {
 	}
 	
 	@Override
-	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file) throws Throwable {
+	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding) throws Throwable {
 		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
 		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
 		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {
@@ -103,7 +103,7 @@ public void transformCode(Collection<CompilerMessage> messages, StringWriter res
 		};
 		
 		String source = readFile(file);
-		final CompilationUnit sourceUnit = new CompilationUnit(source.toCharArray(), file.getName(), "UTF-8");
+		final CompilationUnit sourceUnit = new CompilationUnit(source.toCharArray(), file.getName(), encoding == null ? "UTF-8" : encoding);
 		
 		Compiler ecjCompiler = new Compiler(createFileSystem(file), ecjErrorHandlingPolicy(), ecjCompilerOptions(), bitbucketRequestor, new DefaultProblemFactory(Locale.ENGLISH)) {
 			@Override protected synchronized void addCompilationUnit(ICompilationUnit inUnit, CompilationUnitDeclaration parsedUnit) {

File: test/transform/resource/after-ecj/EncodingUsAscii.java
Patch:
@@ -0,0 +1 @@
+//ignore: This test serves to check what happens with 'weird' characters when you use delombok. It's just not relevant for ecj.

File: src/core/lombok/eclipse/handlers/HandlePrintAST.java
Patch:
@@ -59,7 +59,7 @@ public void handle(AnnotationValues<PrintAST> annotation, Annotation ast, Eclips
 				try {
 					stream.close();
 				} catch (Exception e) {
-					Lombok.sneakyThrow(e);
+					throw Lombok.sneakyThrow(e);
 				}
 			}
 		}

File: src/core/lombok/javac/handlers/HandlePrintAST.java
Patch:
@@ -59,7 +59,7 @@ public class HandlePrintAST extends JavacAnnotationHandler<PrintAST> {
 				try {
 					stream.close();
 				} catch (Exception e) {
-					Lombok.sneakyThrow(e);
+					throw Lombok.sneakyThrow(e);
 				}
 			}
 		}

File: src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethod.java
Patch:
@@ -224,7 +224,8 @@ public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend meth
 				if (methodCall.arguments != null) arguments.addAll(Arrays.asList(methodCall.arguments));
 				List<TypeBinding> argumentTypes = new ArrayList<TypeBinding>();
 				for (Expression argument : arguments) {
-					argumentTypes.add(argument.resolvedType);
+					if (argument.resolvedType != null) argumentTypes.add(argument.resolvedType);
+					// TODO: Instead of just skipping nulls entirely, there is probably a 'unresolved type' placeholder. THAT is what we ought to be adding here!
 				}
 				MethodBinding fixedBinding = scope.getMethod(extensionMethod.declaringClass, methodCall.selector, argumentTypes.toArray(new TypeBinding[0]), methodCall);
 				if (fixedBinding instanceof ProblemMethodBinding) {

File: src/eclipseAgent/lombok/eclipse/agent/EclipseLoaderPatcher.java
Patch:
@@ -22,10 +22,10 @@ public static boolean overrideLoadDecide(ClassLoader original, String name, bool
 	
 	public static Class<?> overrideLoadResult(ClassLoader original, String name, boolean resolve) throws ClassNotFoundException {
 		try {
-			Field shadowLoaderField = original.getClass().getDeclaredField("lombok$shadowLoader");
+			Field shadowLoaderField = original.getClass().getField("lombok$shadowLoader");
 			ClassLoader shadowLoader = (ClassLoader) shadowLoaderField.get(original);
 			if (shadowLoader == null) {
-				String jarLoc = (String) original.getClass().getDeclaredField("lombok$location").get(null);
+				String jarLoc = (String) original.getClass().getField("lombok$location").get(null);
 				JarFile jf = new JarFile(jarLoc);
 				InputStream in = null;
 				try {

File: src/core/lombok/core/configuration/ConfigurationDataType.java
Patch:
@@ -186,7 +186,7 @@ private ConfigurationDataType(boolean isList, ConfigurationValueParser parser) {
 		this.parser = parser;
 	}
 	
-	boolean isList() {
+	public boolean isList() {
 		return isList;
 	}
 	

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -143,7 +143,7 @@ public static void error(CompilationUnitDeclaration cud, String message, String
 		if (bundleName == null) bundleName = DEFAULT_BUNDLE;
 		try {
 			new EclipseWorkspaceLogger().error(message, bundleName, error);
-		} catch (NoClassDefFoundError e) {  //standalone ecj does not jave Platform, ILog, IStatus, and friends.
+		} catch (NoClassDefFoundError e) {  //standalone ecj does not java Platform, ILog, IStatus, and friends.
 			new TerminalLogger().error(message, bundleName, error);
 		}
 		if (cud != null) EclipseAST.addProblemToCompilationResult(cud.getFileName(), cud.compilationResult, false, message + " - See error log.", 0, 0);

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -21,6 +21,8 @@
  */
 package lombok.core;
 
+import static lombok.core.Augments.ClassLoader_lombokAlreadyAddedTo;
+
 import java.io.File;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -61,8 +63,6 @@ static abstract class ProcessorDescriptor {
 	private final List<ProcessorDescriptor> active = new ArrayList<ProcessorDescriptor>();
 	private final List<String> delayedWarnings = new ArrayList<String>();
 	
-	private static final BooleanFieldAugment<ClassLoader> lombokAlreadyAddedTo = BooleanFieldAugment.augment(ClassLoader.class, "lombok$alreadyAddedTo");
-			
 	static class JavacDescriptor extends ProcessorDescriptor {
 		private Processor processor;
 		
@@ -98,7 +98,7 @@ static class JavacDescriptor extends ProcessorDescriptor {
 		private ClassLoader findAndPatchClassLoader(ProcessingEnvironment procEnv) throws Exception {
 			ClassLoader environmentClassLoader = procEnv.getClass().getClassLoader();
 			if (environmentClassLoader != null && environmentClassLoader.getClass().getCanonicalName().equals("org.codehaus.plexus.compiler.javac.IsolatedClassLoader")) {
-				if (!lombokAlreadyAddedTo.set(environmentClassLoader)) {
+				if (!ClassLoader_lombokAlreadyAddedTo.getAndSet(environmentClassLoader, true)) {
 					Method m = environmentClassLoader.getClass().getDeclaredMethod("addURL", URL.class);
 					URL selfUrl = new File(ClassRootFinder.findClassRootOfClass(AnnotationProcessor.class)).toURI().toURL();
 					m.invoke(environmentClassLoader, selfUrl);

File: src/core/lombok/core/Version.java
Patch:
@@ -71,7 +71,7 @@ public static String getFullVersion() {
 		String version = String.format("v%s \"%s\"", VERSION, RELEASE_NAME);
 		if (!isEdgeRelease()) return version;
 		
-		InputStream in = Version.class.getResourceAsStream("release-timestamp.txt");
+		InputStream in = Version.class.getResourceAsStream("/release-timestamp.txt");
 		if (in == null) return version;
 		try {
 			byte[] data = new byte[65536];
@@ -97,7 +97,7 @@ public static boolean isEdgeRelease() {
 		int lastIdx = VERSION.lastIndexOf('.');
 		if (lastIdx == -1) return false;
 		try {
-			return Integer.parseInt(VERSION.substring(lastIdx + 1)) % 1 == 1;
+			return Integer.parseInt(VERSION.substring(lastIdx + 1)) % 2 == 1;
 		} catch (Exception e) {
 			return false;
 		}

File: src/core/lombok/core/handlers/HandlerUtil.java
Patch:
@@ -285,7 +285,6 @@ private static String toAccessorName(AST<?, ?, ?> ast, AnnotationValues<Accessor
 		
 		if (Boolean.TRUE.equals(ast.readConfiguration(ConfigurationKeys.GETTER_CONSEQUENT_BOOLEAN))) isBoolean = false;
 		boolean explicitPrefix = accessors != null && accessors.isExplicit("prefix");
-//		System.out.printf("accessors: %s actual expr: %s val: %s\n", accessors, accessors != null ? accessors.getActualExpression("prefix") : "(null)", accessors == null ? "(null)" : Arrays.toString(accessors.getInstance().prefix()));
 		boolean explicitFluent = accessors != null && accessors.isExplicit("fluent");
 		
 		Accessors ac = (explicitPrefix || explicitFluent) ? accessors.getInstance() : null;

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1425,7 +1425,7 @@ public static Statement generateNullCheck(AbstractVariableDeclaration variable,
 		if (isPrimitive(variable.type)) return null;
 		AllocationExpression exception = new AllocationExpression();
 		setGeneratedBy(exception, source);
-		int partCount = 0;
+		int partCount = 1;
 		String exceptionTypeStr = exceptionType.getExceptionType();
 		for (int i = 0; i < exceptionTypeStr.length(); i++) if (exceptionTypeStr.charAt(i) == '.') partCount++;
 		long[] ps = new long[partCount];

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -677,6 +677,7 @@ private static void patchExtensionMethod(ScriptManager sm, boolean ecj) {
 			.request(StackRequest.PARAM1)
 			.wrapMethod(new Hook(PATCH_EXTENSIONMETHOD, "resolveType", TYPE_BINDING_SIG, TYPE_BINDING_SIG, MESSAGE_SEND_SIG, BLOCK_SCOPE_SIG))
 			.build());
+		
 		sm.addScript(replaceMethodCall()
 			.target(new MethodTarget(MESSAGE_SEND_SIG, "resolveType", TYPE_BINDING_SIG, BLOCK_SCOPE_SIG))
 			.methodToReplace(new Hook(PROBLEM_REPORTER_SIG, "errorNoMethodFor", "void", MESSAGE_SEND_SIG, TYPE_BINDING_SIG, TYPE_BINDINGS_SIG))

File: test/transform/resource/after-delombok/NonNullWithAlternateException.java
Patch:
@@ -3,14 +3,14 @@ public class NonNullWithAlternateException {
 	private String test;
 	public void testMethod(@lombok.NonNull String arg) {
 		if (arg == null) {
-			throw new java.lang.IllegalArgumentException("arg");
+			throw new java.lang.IllegalArgumentException("arg is null");
 		}
 		System.out.println(arg);
 	}
 	@java.lang.SuppressWarnings("all")
 	public void setTest(@lombok.NonNull final String test) {
 		if (test == null) {
-			throw new java.lang.IllegalArgumentException("test");
+			throw new java.lang.IllegalArgumentException("test is null");
 		}
 		this.test = test;
 	}

File: test/transform/resource/after-ecj/NonNullWithAlternateException.java
Patch:
@@ -6,14 +6,14 @@ public NonNullWithAlternateException() {
   public void testMethod(@lombok.NonNull String arg) {
     if ((arg == null))
         {
-          throw new java.lang.IllegalArgumentException("arg");
+          throw new java.lang.IllegalArgumentException("arg is null");
         }
     System.out.println(arg);
   }
   public @java.lang.SuppressWarnings("all") void setTest(final @lombok.NonNull String test) {
     if ((test == null))
         {
-          throw new java.lang.IllegalArgumentException("test");
+          throw new java.lang.IllegalArgumentException("test is null");
         }
     this.test = test;
   }

File: test/transform/resource/before/NonNullWithAlternateException.java
Patch:
@@ -1,4 +1,4 @@
-//CONF: lombok.nonNull.exceptionType = java.lang.IllegalArgumentException
+//CONF: lombok.nonNull.exceptionType = IllegalArgumentException
 
 public class NonNullWithAlternateException {
 	@lombok.NonNull @lombok.Setter private String test;

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -85,6 +85,7 @@ public boolean proceedOnErrors() {
 				return false;
 			}
 			
+			@SuppressWarnings("unused") // Added to the interface in later ecj version
 			public boolean ignoreAllErrors() {
 				return false;
 			}

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -215,8 +215,9 @@ private static void compareMessages(String name, LombokImmutableList<CompilerMes
 			}
 			
 			while (expectedIterator.hasNext()) {
-				if (expectedIterator.next().isOptional()) continue;
-				fail(String.format("[%s] Expected message '%s' but ran out of actual messages", name, expectedIterator.next()));
+				CompilerMessageMatcher next = expectedIterator.next();
+				if (next.isOptional()) continue;
+				fail(String.format("[%s] Expected message '%s' but ran out of actual messages", name, next));
 			}
 			if (acHasNext) fail(String.format("[%s] Unexpected message: %s", name, actualIterator.next()));
 			break;

File: test/transform/resource/after-ecj/DelegateOnGetterNone.java
Patch:
@@ -1,5 +1,5 @@
 import lombok.AccessLevel;
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 import lombok.Getter;
 @Getter class DelegateOnGetterNone {
   private interface Bar {

File: test/transform/resource/after-ecj/DelegateOnMethods.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 abstract class DelegateOnMethods {
   public static interface Bar {
     void bar(java.util.ArrayList<java.lang.String> list);

File: test/transform/resource/after-ecj/DelegateTypesAndExcludes.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 class DelegatePlain {
   private static class FooImpl implements Foo {
     private FooImpl() {

File: test/transform/resource/after-ecj/DelegateWithDeprecated.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 class DelegateWithDeprecated {
   private interface Bar {
     @Deprecated void deprecatedAnnotation();

File: test/transform/resource/before/DelegateOnGetterNone.java
Patch:
@@ -1,5 +1,5 @@
 import lombok.AccessLevel;
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 import lombok.Getter;
 
 @Getter

File: test/transform/resource/before/DelegateOnMethods.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 
 abstract class DelegateOnMethods {
 

File: test/transform/resource/before/DelegateOnStatic.java
Patch:
@@ -1,5 +1,5 @@
 //skip compare content
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 import lombok.Getter;
 
 class DelegateOnStatic {

File: test/transform/resource/before/DelegateRecursion.java
Patch:
@@ -1,4 +1,5 @@
-import lombok.Delegate;
+//skip compare content: This test is to see if the 'delegate recursion is not supported' error pops up.
+import lombok.experimental.Delegate;
 class DelegateRecursionOuterMost {
 	@Delegate
 	private final DelegateRecursionCenter center = new DelegateRecursionCenter();
@@ -12,4 +13,4 @@ class DelegateRecursionCenter {
 class DelegateRecursionInnerMost {
 	public void innerMostMethod() {
 	}
-}
\ No newline at end of file
+}

File: test/transform/resource/before/DelegateTypesAndExcludes.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 class DelegatePlain {
 	@Delegate(types = Bar.class)
 	private final BarImpl bar = new BarImpl();

File: test/transform/resource/before/DelegateWithDeprecated.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Delegate;
+import lombok.experimental.Delegate;
 
 class DelegateWithDeprecated {
 	@Delegate private Bar bar;

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -91,7 +91,7 @@ public class HandleVal extends JavacASTAdapter {
 			local.mods.annotations = local.mods.annotations == null ? List.of(valAnnotation) : local.mods.annotations.append(valAnnotation);
 		}
 		
-		local.vartype = JavacResolution.createJavaLangObject(localNode.getAst());
+		local.vartype = localNode.getAst().getTreeMaker().Ident(localNode.getAst().toName("___Lombok_VAL_Attrib__"));
 		
 		Type type;
 		try {

File: test/transform/resource/before/LoggerSlf4jOnNonType.java
Patch:
@@ -1,3 +1,4 @@
+// skip-compare-content
 class LoggerSlf4jOnNonType {
 	@lombok.extern.slf4j.Slf4j
 	void foo() {

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -52,7 +52,7 @@
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
-import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
@@ -289,7 +289,7 @@ public MethodDeclaration generateBuildMethod(String name, char[] staticName, Typ
 				invoke.typeArguments = trs;
 			}
 			invoke.arguments = assigns.isEmpty() ? null : assigns.toArray(new Expression[assigns.size()]);
-			if (returnType instanceof SingleTypeReference && Arrays.equals(TypeBinding.VOID.simpleName, ((SingleTypeReference) returnType).token)) {
+			if (returnType instanceof SingleTypeReference && Arrays.equals(TypeConstants.VOID, ((SingleTypeReference) returnType).token)) {
 				statement = invoke;
 			} else {
 				statement = new ReturnStatement(invoke, (int)(p >> 32), (int)p);

File: test/transform/resource/before/EqualsAndHashCodeWithOnParam.java
Patch:
@@ -1,7 +1,7 @@
 @interface Nullable {
 }
 
-@lombok.EqualsAndHashCode(onParam=@_{@Nullable})
+@lombok.EqualsAndHashCode(onParam=@__({@Nullable}))
 class EqualsAndHashCodeWithOnParam {
 	int x;
 	boolean[] y;

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -116,7 +116,7 @@ public void generateEqualsAndHashCodeForType(EclipseNode typeNode, EclipseNode e
 			return;
 		}
 		
-		generateMethods(typeNode, errorNode, null, null, null, false, FieldAccess.GETTER, null);
+		generateMethods(typeNode, errorNode, null, null, null, false, FieldAccess.GETTER, new ArrayList<Annotation>());
 	}
 	
 	@Override public void handle(AnnotationValues<EqualsAndHashCode> annotation, Annotation ast, EclipseNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -118,7 +118,7 @@ public void generateEqualsAndHashCodeForType(JavacNode typeNode, JavacNode sourc
 			return;
 		}
 		
-		generateMethods(typeNode, source, null, null, null, false, FieldAccess.GETTER, null);
+		generateMethods(typeNode, source, null, null, null, false, FieldAccess.GETTER, List.<JCAnnotation>nil());
 	}
 	
 	public void generateMethods(JavacNode typeNode, JavacNode source, List<String> excludes, List<String> includes,

File: test/transform/resource/after-delombok/Accessors.java
Patch:
@@ -78,7 +78,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof AccessorsPrefix3;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/ConflictingStaticConstructorNames.java
Patch:
@@ -9,7 +9,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof ConflictingStaticConstructorNames;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/DataExtended.java
Patch:
@@ -22,7 +22,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof DataExtended;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/DataIgnore.java
Patch:
@@ -21,7 +21,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof DataIgnore;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -33,7 +33,7 @@ public boolean equals(final java.lang.Object o) {
 				return true;
 			}
 			@java.lang.SuppressWarnings("all")
-			public boolean canEqual(final java.lang.Object other) {
+			protected boolean canEqual(final java.lang.Object other) {
 				return other instanceof Local;
 			}
 			@java.lang.Override
@@ -93,7 +93,7 @@ public boolean equals(final java.lang.Object o) {
 					return true;
 				}
 				@java.lang.SuppressWarnings("all")
-				public boolean canEqual(final java.lang.Object other) {
+				protected boolean canEqual(final java.lang.Object other) {
 					return other instanceof Local.InnerLocal;
 				}
 				@java.lang.Override
@@ -130,7 +130,7 @@ public boolean equals(final java.lang.Object o) {
 				return true;
 			}
 			@java.lang.SuppressWarnings("all")
-			public boolean canEqual(final java.lang.Object other) {
+			protected boolean canEqual(final java.lang.Object other) {
 				return other instanceof Local;
 			}
 			@java.lang.Override

File: test/transform/resource/after-delombok/DataWithGetter.java
Patch:
@@ -30,7 +30,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof DataWithGetter;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/DataWithGetterNone.java
Patch:
@@ -30,7 +30,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof DataWithGetterNone;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/EqualsAndHashCode.java
Patch:
@@ -23,7 +23,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof EqualsAndHashCode;
 	}
 	@java.lang.Override
@@ -86,7 +86,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof EqualsAndHashCode3;
 	}
 	@java.lang.Override
@@ -108,7 +108,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof EqualsAndHashCode4;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/GetterLazyBoolean.java
Patch:
@@ -15,7 +15,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof GetterLazyBoolean;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/GetterLazyEahcToString.java
Patch:
@@ -20,7 +20,7 @@ public boolean equals(final java.lang.Object o) {
 	}
 	
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof GetterLazyEahcToString;
 	}
 	

File: test/transform/resource/after-delombok/GetterSetterJavadoc.java
Patch:
@@ -35,7 +35,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof GetterSetterJavadoc1;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/ValuePlain.java
Patch:
@@ -74,7 +74,7 @@ public boolean equals(final java.lang.Object o) {
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")
-	public boolean canEqual(final java.lang.Object other) {
+	protected boolean canEqual(final java.lang.Object other) {
 		return other instanceof Value2;
 	}
 	@java.lang.Override

File: test/transform/resource/after-ecj/Accessors.java
Patch:
@@ -86,7 +86,7 @@ private String getName() {
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof AccessorsPrefix3);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/ConflictingStaticConstructorNames.java
Patch:
@@ -9,7 +9,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof ConflictingStaticConstructorNames);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -18,7 +18,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof DataExtended);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/DataIgnore.java
Patch:
@@ -16,7 +16,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof DataIgnore);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/DataOnLocalClass.java
Patch:
@@ -32,7 +32,7 @@ public static void main(String[] args) {
             return false;
         return true;
       }
-      public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+      protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
@@ -82,7 +82,7 @@ class DataOnLocalClass2 {
               return false;
           return true;
         }
-        public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+        protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
           return (other instanceof Local.InnerLocal);
         }
         public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
@@ -120,7 +120,7 @@ class DataOnLocalClass2 {
             return false;
         return true;
       }
-      public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+      protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -26,7 +26,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof DataWithGetter);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/DataWithGetterNone.java
Patch:
@@ -26,7 +26,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof DataWithGetterNone);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/EqualsAndHashCode.java
Patch:
@@ -31,7 +31,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof EqualsAndHashCode);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
@@ -101,7 +101,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof EqualsAndHashCode3);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
@@ -125,7 +125,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof EqualsAndHashCode4);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -53,7 +53,7 @@ private static boolean calculateBoolean() {
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof GetterLazyBoolean);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -42,7 +42,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof GetterLazyEahcToString);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/GetterSetterJavadoc.java
Patch:
@@ -18,7 +18,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof GetterSetterJavadoc1);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/after-ecj/ValuePlain.java
Patch:
@@ -64,7 +64,7 @@
         return false;
     return true;
   }
-  public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
+  protected @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {
     return (other instanceof Value2);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {

File: test/transform/resource/before/EqualsAndHashCodeWithExistingMethods.java
Patch:
@@ -20,7 +20,7 @@ public boolean equals(Object other) {
 final class EqualsAndHashCodeWithExistingMethods3 extends EqualsAndHashCodeWithExistingMethods {
 	int x;
 	
-	public boolean canEqual(Object other) {
+	private boolean canEqual(Object other) {
 		return true;
 	}
 }
\ No newline at end of file

File: test/transform/resource/before/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -18,7 +18,7 @@ public int hashCode() {
 class EqualsAndHashCodeWithSomeExistingMethods2 {
 	int x;
 	
-	public boolean canEqual(Object other) {
+	protected boolean canEqual(Object other) {
 		return false;
 	}
 }

File: src/core/lombok/core/debug/DebugSnapshotStore.java
Patch:
@@ -35,8 +35,9 @@
 
 public class DebugSnapshotStore {
 	public static final DebugSnapshotStore INSTANCE = new DebugSnapshotStore();
-	public static boolean GLOBAL_DSS_DISABLE_SWITCH = true;
+	public static final boolean GLOBAL_DSS_DISABLE_SWITCH = true;
 	
+	// All access should synchronize on the map
 	private final Map<CompilationUnitDeclaration, List<DebugSnapshot>> map =
 			new WeakHashMap<CompilationUnitDeclaration, List<DebugSnapshot>>();
 	

File: experimental/src/lombok/javac/disableCheckedExceptions/DisableCheckedExceptionsAgent.java
Patch:
@@ -34,6 +34,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic.Kind;
 
+import lombok.patcher.ClassRootFinder;
 import lombok.patcher.Hook;
 import lombok.patcher.MethodTarget;
 import lombok.patcher.ScriptManager;
@@ -56,7 +57,7 @@ public class DisableCheckedExceptionsAgent extends AbstractProcessor {
 			procEnv.getMessager().printMessage(Kind.WARNING, "You aren't using a compiler based around javac v1.6, so disableCheckedExceptions will not work.\n" +
 					"Your processor class is: " + className);
 		} else {
-			new LiveInjector().inject(LiveInjector.findPathJar(DisableCheckedExceptionsAgent.class));
+			new LiveInjector().inject(ClassRootFinder.findClassRootOfClass(DisableCheckedExceptionsAgent.class));
 		}
 	}
 	

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -43,7 +43,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic.Kind;
 
-import lombok.patcher.inject.LiveInjector;
+import lombok.patcher.ClassRootFinder;
 
 @SupportedAnnotationTypes("*")
 public class AnnotationProcessor extends AbstractProcessor {
@@ -102,7 +102,7 @@ private ClassLoader findAndPatchClassLoader(ProcessingEnvironment procEnv) throw
 			if (environmentClassLoader != null && environmentClassLoader.getClass().getCanonicalName().equals("org.codehaus.plexus.compiler.javac.IsolatedClassLoader")) {
 				if (lombokAlreadyAddedTo.put(environmentClassLoader, true) == null) {
 					Method m = environmentClassLoader.getClass().getDeclaredMethod("addURL", URL.class);
-					URL selfUrl = new File(LiveInjector.findPathJar(AnnotationProcessor.class)).toURI().toURL();
+					URL selfUrl = new File(ClassRootFinder.findClassRootOfClass(AnnotationProcessor.class)).toURI().toURL();
 					m.invoke(environmentClassLoader, selfUrl);
 				}
 				return environmentClassLoader;

File: src/core/lombok/core/PublicApiCreatorApp.java
Patch:
@@ -35,8 +35,7 @@
 import java.util.zip.ZipEntry;
 
 import lombok.Lombok;
-import lombok.installer.IdeFinder;
-import lombok.patcher.inject.LiveInjector;
+import lombok.patcher.ClassRootFinder;
 
 import org.mangosdk.spi.ProviderFor;
 
@@ -80,7 +79,7 @@ public class PublicApiCreatorApp extends LombokApp {
 	 * a jar that wasn't accessed via the file-system, or if its started via e.g. unpacking the jar.
 	 */
 	private static File findOurJar() {
-		return new File(LiveInjector.findPathJar(IdeFinder.class));
+		return new File(ClassRootFinder.findClassRootOfClass(PublicApiCreatorApp.class));
 	}
 	
 	private int writeApiJar(File outFile) throws Exception {

File: src/core/lombok/core/Version.java
Patch:
@@ -28,7 +28,7 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "1.12.3";
+	private static final String VERSION = "1.12.5";
 	private static final String RELEASE_NAME = "Edgy Guinea Pig";
 //	private static final String RELEASE_NAME = "Angry Butterfly";
 	

File: src/core/lombok/core/package-info.java
Patch:
@@ -26,5 +26,8 @@
  * an implementation of SPI service loader (to avoid being dependent on a v1.6 JVM),
  * lombok's version, and annotations and support classes for your normal java code
  * that's primarily useful for developing and debugging lombok.
+ * 
+ * <strong>NB: This package is not public API in the sense that contents of this package,
+ *    even public classes / methods / etc, may change in point releases.</strong>
  */
 package lombok.core;

File: src/core/lombok/eclipse/handlers/HandleCleanup.java
Patch:
@@ -229,7 +229,7 @@ public void handle(AnnotationValues<Cleanup> annotation, Annotation ast, Eclipse
 		ancestor.rebuild();
 	}
 	
-	private MessageSend preventNullAnalysis(Annotation ast, Expression expr) {
+	public MessageSend preventNullAnalysis(Annotation ast, Expression expr) {
 		MessageSend singletonList = new MessageSend();
 		setGeneratedBy(singletonList, ast);
 		
@@ -258,7 +258,7 @@ private MessageSend preventNullAnalysis(Annotation ast, Expression expr) {
 		return preventNullAnalysis;
 	}
 	
-	private void doAssignmentCheck(EclipseNode node, Statement[] tryBlock, char[] varName) {
+	public void doAssignmentCheck(EclipseNode node, Statement[] tryBlock, char[] varName) {
 		for (Statement statement : tryBlock) doAssignmentCheck0(node, statement, varName);
 	}
 	

File: src/core/lombok/eclipse/handlers/HandleNonNull.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 The Project Lombok Authors.
+ * Copyright (C) 2013-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -146,11 +146,11 @@ public class HandleNonNull extends EclipseAnnotationHandler<NonNull> {
 		annotationNode.up().up().rebuild();
 	}
 	
-	private boolean isNullCheck(Statement stat) {
+	public boolean isNullCheck(Statement stat) {
 		return returnVarNameIfNullCheck(stat) != null;
 	}
 	
-	private char[] returnVarNameIfNullCheck(Statement stat) {
+	public char[] returnVarNameIfNullCheck(Statement stat) {
 		if (!(stat instanceof IfStatement)) return null;
 		
 		/* Check that the if's statement is a throw statement, possibly in a block. */ {

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -144,13 +144,13 @@ public void handle(AnnotationValues<Setter> annotation, Annotation ast, EclipseN
 		}
 	}
 	
-	private void createSetterForFields(AccessLevel level, Collection<EclipseNode> fieldNodes, EclipseNode errorNode, ASTNode source, boolean whineIfExists, List<Annotation> onMethod, List<Annotation> onParam) {
+	public void createSetterForFields(AccessLevel level, Collection<EclipseNode> fieldNodes, EclipseNode errorNode, ASTNode source, boolean whineIfExists, List<Annotation> onMethod, List<Annotation> onParam) {
 		for (EclipseNode fieldNode : fieldNodes) {
 			createSetterForField(level, fieldNode, errorNode, source, whineIfExists, onMethod, onParam);
 		}
 	}
 	
-	private void createSetterForField(
+	public void createSetterForField(
 			AccessLevel level, EclipseNode fieldNode, EclipseNode errorNode,
 			ASTNode source, boolean whineIfExists, List<Annotation> onMethod,
 			List<Annotation> onParam) {

File: src/core/lombok/eclipse/handlers/HandleSneakyThrows.java
Patch:
@@ -149,7 +149,7 @@ private static class DeclaredException {
 //		return true;
 //	}
 	
-	private void handleMethod(EclipseNode annotation, AbstractMethodDeclaration method, List<DeclaredException> exceptions) {
+	public void handleMethod(EclipseNode annotation, AbstractMethodDeclaration method, List<DeclaredException> exceptions) {
 		if (method.isAbstract()) {
 			annotation.addError("@SneakyThrows can only be used on concrete methods.");
 			return;
@@ -181,7 +181,7 @@ private void handleMethod(EclipseNode annotation, AbstractMethodDeclaration meth
 		annotation.up().rebuild();
 	}
 	
-	private Statement buildTryCatchBlock(Statement[] contents, DeclaredException exception, ASTNode source, AbstractMethodDeclaration method) {
+	public Statement buildTryCatchBlock(Statement[] contents, DeclaredException exception, ASTNode source, AbstractMethodDeclaration method) {
 		int methodStart = method.bodyStart;
 		int methodEnd = method.bodyEnd;
 		long methodPosEnd = ((long) methodEnd) << 32 | (methodEnd & 0xFFFFFFFFL);

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -69,7 +69,7 @@ public class HandleSynchronized extends EclipseAnnotationHandler<Synchronized> {
 		createLockField(annotation, annotationNode, method.isStatic(), false);
 	}
 	
-	private char[] createLockField(AnnotationValues<Synchronized> annotation, EclipseNode annotationNode, boolean isStatic, boolean reportErrors) {
+	public char[] createLockField(AnnotationValues<Synchronized> annotation, EclipseNode annotationNode, boolean isStatic, boolean reportErrors) {
 		char[] lockName = annotation.getInstance().value().toCharArray();
 		Annotation source = (Annotation) annotationNode.get();
 		boolean autoMake = false;

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -146,13 +146,13 @@ public void generateWitherForField(EclipseNode fieldNode, ASTNode pos, AccessLev
 		}
 	}
 	
-	private void createWitherForFields(AccessLevel level, Collection<EclipseNode> fieldNodes, EclipseNode errorNode, ASTNode source, boolean whineIfExists, List<Annotation> onMethod, List<Annotation> onParam) {
+	public void createWitherForFields(AccessLevel level, Collection<EclipseNode> fieldNodes, EclipseNode errorNode, ASTNode source, boolean whineIfExists, List<Annotation> onMethod, List<Annotation> onParam) {
 		for (EclipseNode fieldNode : fieldNodes) {
 			createWitherForField(level, fieldNode, errorNode, source, whineIfExists, onMethod, onParam);
 		}
 	}
 	
-	private void createWitherForField(
+	public void createWitherForField(
 			AccessLevel level, EclipseNode fieldNode, EclipseNode errorNode,
 			ASTNode source, boolean whineIfExists, List<Annotation> onMethod,
 			List<Annotation> onParam) {
@@ -210,7 +210,7 @@ private void createWitherForField(
 		injectMethod(fieldNode.up(), method);
 	}
 	
-	private MethodDeclaration createWither(TypeDeclaration parent, EclipseNode fieldNode, String name, int modifier, ASTNode source, List<Annotation> onMethod, List<Annotation> onParam) {
+	public MethodDeclaration createWither(TypeDeclaration parent, EclipseNode fieldNode, String name, int modifier, ASTNode source, List<Annotation> onMethod, List<Annotation> onParam) {
 		if (name == null) return null;
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		int pS = source.sourceStart, pE = source.sourceEnd;

File: src/core/lombok/javac/apt/package-info.java
Patch:
@@ -22,5 +22,8 @@
 
 /**
  * Contains the mechanism that instruments javac as an annotation processor.
+ * 
+ * <strong>NB: This package is not public API in the sense that contents of this package,
+ *    even public classes / methods / etc, may change in point releases.</strong>
  */
 package lombok.javac.apt;

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -145,7 +145,7 @@ public class HandleCleanup extends JavacAnnotationHandler<Cleanup> {
 		ancestor.rebuild();
 	}
 	
-	private JCExpression preventNullAnalysis(JavacTreeMaker maker, JavacNode node, JCExpression expression) {
+	public JCExpression preventNullAnalysis(JavacTreeMaker maker, JavacNode node, JCExpression expression) {
 		if (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().danceAroundIdeChecks()) {
 			JCMethodInvocation singletonList = maker.Apply(List.<JCExpression>nil(), chainDotsString(node, "java.util.Collections.singletonList"), List.of(expression));
 			JCMethodInvocation cleanedExpr = maker.Apply(List.<JCExpression>nil(), maker.Select(singletonList, node.toName("get")) , List.<JCExpression>of(maker.Literal(CTC_INT, 0)));
@@ -155,11 +155,11 @@ private JCExpression preventNullAnalysis(JavacTreeMaker maker, JavacNode node, J
 		}
 	}
 	
-	private void doAssignmentCheck(JavacNode node, List<JCStatement> statements, Name name) {
+	public void doAssignmentCheck(JavacNode node, List<JCStatement> statements, Name name) {
 		for (JCStatement statement : statements) doAssignmentCheck0(node, statement, name);
 	}
 	
-	private void doAssignmentCheck0(JavacNode node, JCTree statement, Name name) {
+	public void doAssignmentCheck0(JavacNode node, JCTree statement, Name name) {
 		if (statement instanceof JCAssign) doAssignmentCheck0(node, ((JCAssign)statement).rhs, name);
 		if (statement instanceof JCExpressionStatement) doAssignmentCheck0(node,
 				((JCExpressionStatement)statement).expr, name);

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 The Project Lombok Authors.
+ * Copyright (C) 2013-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -145,7 +145,7 @@ public class HandleNonNull extends JavacAnnotationHandler<NonNull> {
 		declaration.body.stats = newList;
 	}
 	
-	private boolean isNullCheck(JCStatement stat) {
+	public boolean isNullCheck(JCStatement stat) {
 		return returnVarNameIfNullCheck(stat) != null;
 	}
 	
@@ -154,7 +154,7 @@ private boolean isNullCheck(JCStatement stat) {
 	 * where the block braces are optional. If it is of this form, returns "x".
 	 * If it is not of this form, returns null.
 	 */
-	private String returnVarNameIfNullCheck(JCStatement stat) {
+	public String returnVarNameIfNullCheck(JCStatement stat) {
 		if (!(stat instanceof JCIf)) return null;
 		
 		/* Check that the if's statement is a throw statement, possibly in a block. */ {

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -59,7 +59,7 @@
  */
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleToString extends JavacAnnotationHandler<ToString> {
-	private void checkForBogusFieldNames(JavacNode type, AnnotationValues<ToString> annotation) {
+	public void checkForBogusFieldNames(JavacNode type, AnnotationValues<ToString> annotation) {
 		if (annotation.isExplicit("exclude")) {
 			for (int i : createListOfNonExistentFields(List.from(annotation.getInstance().exclude()), type, true, false)) {
 				annotation.setWarning("exclude", "This field does not exist, or would have been excluded anyway.", i);
@@ -253,7 +253,7 @@ static JCMethodDecl createToString(JavacNode typeNode, Collection<JavacNode> fie
 				List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source, typeNode.getContext());
 	}
 	
-	private static String getTypeName(JavacNode typeNode) {
+	public static String getTypeName(JavacNode typeNode) {
 		String typeName = ((JCClassDecl) typeNode.get()).name.toString();
 		JavacNode upType = typeNode.up();
 		while (upType.getKind() == Kind.TYPE) {

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -467,6 +467,7 @@ private static <T> com.sun.tools.javac.util.List<T> toJavacList(List<T> list) {
 	
 	public boolean delombok() throws IOException {
 		LombokOptions options = LombokOptionsFactory.getDelombokOptions(context);
+		options.deleteLombokAnnotations();
 		options.putJavacOption("ENCODING", charset.name());
 		if (classpath != null) options.putJavacOption("CLASSPATH", classpath);
 		if (sourcepath != null) options.putJavacOption("SOURCEPATH", sourcepath);

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -591,7 +591,7 @@ public void printEnumBody(List<JCTree> stats) throws IOException {
         for (List<JCTree> l = stats; l.nonEmpty(); l = l.tail) {
         	x++;
             if (!isEnumerator(l.head)) {
-                align();
+                if (!suppressAlignmentForEmptyLines(l.head)) align();
                 printStat(l.head);
                 println();
             }

File: src/installer/lombok/installer/IdeLocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -26,7 +26,7 @@
 import java.net.URL;
 
 import lombok.installer.eclipse.EclipseFinder;
-import lombok.patcher.inject.LiveInjector;
+import lombok.patcher.ClassRootFinder;
 
 /**
  * Represents a location that contains an IDE.
@@ -46,7 +46,7 @@ public abstract class IdeLocation {
 	 * a jar that wasn't accessed via the file-system, or if its started via e.g. unpacking the jar.
 	 */
 	public static File findOurJar() {
-		return new File(LiveInjector.findPathJar(IdeFinder.class));
+		return new File(ClassRootFinder.findClassRootOfClass(IdeFinder.class));
 	}
 	
 	@Override public String toString() {

File: src/installer/lombok/installer/Installer.java
Patch:
@@ -39,7 +39,7 @@
 import lombok.core.SpiLoadUtil;
 import lombok.core.Version;
 import lombok.installer.IdeFinder.OS;
-import lombok.patcher.inject.LiveInjector;
+import lombok.patcher.ClassRootFinder;
 
 import org.mangosdk.spi.ProviderFor;
 
@@ -101,7 +101,7 @@ static void autoDiscover(List<IdeLocation> locations, List<CorruptedIdeLocationE
 	}
 	
 	public static boolean isSelf(String jar) {
-		String self = LiveInjector.findPathJar(Installer.class);
+		String self = ClassRootFinder.findClassRootOfClass(Installer.class);
 		if (self == null) return false;
 		File a = new File(jar).getAbsoluteFile();
 		File b = new File(self).getAbsoluteFile();

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -70,6 +70,7 @@ protected CompilerOptions ecjCompilerOptions() {
 		warnings.put(CompilerOptions.OPTION_ReportUnusedLabel, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedImport, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, "ignore");
+		warnings.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_7);
 		options.set(warnings);
 		return options;
 	}

File: test/transform/resource/after-delombok/Accessors.java
Patch:
@@ -84,7 +84,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		final java.lang.Object $fName = this.getName();
 		result = result * PRIME + ($fName == null ? 0 : $fName.hashCode());

File: test/transform/resource/after-delombok/DataExtended.java
Patch:
@@ -28,7 +28,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		return result;

File: test/transform/resource/after-delombok/DataIgnore.java
Patch:
@@ -27,7 +27,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		return result;

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -39,7 +39,7 @@ public boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				final int PRIME = 31;
+				final int PRIME = 59;
 				int result = 1;
 				result = result * PRIME + this.getX();
 				final java.lang.Object $name = this.getName();
@@ -99,7 +99,7 @@ public boolean canEqual(final java.lang.Object other) {
 				@java.lang.Override
 				@java.lang.SuppressWarnings("all")
 				public int hashCode() {
-					final int PRIME = 31;
+					final int PRIME = 59;
 					int result = 1;
 					final java.lang.Object $name = this.getName();
 					result = result * PRIME + ($name == null ? 0 : $name.hashCode());
@@ -136,7 +136,7 @@ public boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				final int PRIME = 31;
+				final int PRIME = 59;
 				int result = 1;
 				result = result * PRIME + this.getX();
 				return result;

File: test/transform/resource/after-delombok/DataWithGetter.java
Patch:
@@ -36,7 +36,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		result = result * PRIME + this.getY();

File: test/transform/resource/after-delombok/DataWithGetterNone.java
Patch:
@@ -36,7 +36,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.x;
 		result = result * PRIME + this.y;

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -69,7 +69,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.x;
 		return result;

File: test/transform/resource/after-delombok/GetterLazyBoolean.java
Patch:
@@ -21,9 +21,9 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
-		result = result * PRIME + (this.isBooleanValue() ? 1231 : 1237);
+		result = result * PRIME + (this.isBooleanValue() ? 79 : 97);
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/GetterLazyEahcToString.java
Patch:
@@ -27,7 +27,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		final java.lang.Object $value = this.getValue();
 		result = result * PRIME + ($value == null ? 0 : $value.hashCode());

File: test/transform/resource/after-delombok/GetterSetterJavadoc.java
Patch:
@@ -41,7 +41,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getFieldName();
 		return result;

File: test/transform/resource/after-delombok/ValuePlain.java
Patch:
@@ -30,7 +30,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		final java.lang.Object $name = this.getName();
@@ -80,7 +80,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		final java.lang.Object $name = this.getName();
@@ -123,7 +123,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		result = result * PRIME + this.getY();

File: test/transform/resource/after-ecj/Accessors.java
Patch:
@@ -90,7 +90,7 @@ private String getName() {
     return (other instanceof AccessorsPrefix3);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     final java.lang.Object $fName = this.getName();
     result = ((result * PRIME) + (($fName == null) ? 0 : $fName.hashCode()));

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -22,7 +22,7 @@
     return (other instanceof DataExtended);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     return result;

File: test/transform/resource/after-ecj/DataIgnore.java
Patch:
@@ -20,7 +20,7 @@
     return (other instanceof DataIgnore);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     return result;

File: test/transform/resource/after-ecj/DataOnLocalClass.java
Patch:
@@ -36,7 +36,7 @@ public static void main(String[] args) {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        final int PRIME = 31;
+        final int PRIME = 59;
         int result = 1;
         result = ((result * PRIME) + this.getX());
         final java.lang.Object $name = this.getName();
@@ -86,7 +86,7 @@ class DataOnLocalClass2 {
           return (other instanceof Local.InnerLocal);
         }
         public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-          final int PRIME = 31;
+          final int PRIME = 59;
           int result = 1;
           final java.lang.Object $name = this.getName();
           result = ((result * PRIME) + (($name == null) ? 0 : $name.hashCode()));
@@ -124,7 +124,7 @@ class DataOnLocalClass2 {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        final int PRIME = 31;
+        final int PRIME = 59;
         int result = 1;
         result = ((result * PRIME) + this.getX());
         return result;

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -30,7 +30,7 @@
     return (other instanceof DataWithGetter);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     result = ((result * PRIME) + this.getY());

File: test/transform/resource/after-ecj/DataWithGetterNone.java
Patch:
@@ -30,7 +30,7 @@
     return (other instanceof DataWithGetterNone);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.x);
     result = ((result * PRIME) + this.y);

File: test/transform/resource/after-ecj/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -57,7 +57,7 @@ public boolean equals(Object other) {
     return (other instanceof EqualsAndHashCodeWithNoExistingMethods);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.x);
     return result;

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -57,9 +57,9 @@ private static boolean calculateBoolean() {
     return (other instanceof GetterLazyBoolean);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
-    result = ((result * PRIME) + (this.isBooleanValue() ? 1231 : 1237));
+    result = ((result * PRIME) + (this.isBooleanValue() ? 79 : 97));
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -46,7 +46,7 @@
     return (other instanceof GetterLazyEahcToString);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     final java.lang.Object $value = this.getValue();
     result = ((result * PRIME) + (($value == null) ? 0 : $value.hashCode()));

File: test/transform/resource/after-ecj/GetterSetterJavadoc.java
Patch:
@@ -22,7 +22,7 @@
     return (other instanceof GetterSetterJavadoc1);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getFieldName());
     return result;

File: test/transform/resource/after-ecj/NonNullWithSneakyThrows.java
Patch:
@@ -11,7 +11,8 @@ class NonNullWithSneakyThrows {
             }
         System.out.println(in);
       }
-    catch (final java.lang.Throwable $ex)       {
+    catch (final java.lang.Throwable $ex)
+      {
         throw lombok.Lombok.sneakyThrow($ex);
       }
   }

File: test/transform/resource/after-ecj/ValComplex.java
Patch:
@@ -16,7 +16,7 @@ public void testComplex() {
         final @val int field = 20;
         final @val int inner = 10;
         switch (field) {
-        case 5 : ;
+        case 5 :
             final @val char[] shouldBeCharArray2 = shouldBeCharArray;
             final @val int innerInner = inner;
         }

File: test/transform/resource/after-ecj/ValLessSimple.java
Patch:
@@ -32,7 +32,8 @@ private void testValInCatchBlock() {
       {
         final @val int x = (1 / 0);
       }
-    catch (ArithmeticException e)       {
+    catch (ArithmeticException e)
+      {
         final @val int y = 0;
       }
   }

File: test/transform/resource/after-ecj/ValuePlain.java
Patch:
@@ -23,7 +23,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     final java.lang.Object $name = this.getName();
@@ -68,7 +68,7 @@
     return (other instanceof Value2);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     final java.lang.Object $name = this.getName();
@@ -106,7 +106,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     result = ((result * PRIME) + this.getY());

File: test/transform/resource/before/EqualsAndHashCode.java
Patch:
@@ -13,6 +13,7 @@ final class EqualsAndHashCode2 {
 	long y;
 	float f;
 	double d;
+	boolean b;
 }
 
 @lombok.EqualsAndHashCode(callSuper=false)

File: experimental/src/lombok/javac/disableCheckedExceptions/DisableCheckedExceptionsAgent.java
Patch:
@@ -34,7 +34,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic.Kind;
 
-import lombok.patcher.HomeFinder;
+import lombok.patcher.ClassRootFinder;
 import lombok.patcher.Hook;
 import lombok.patcher.MethodTarget;
 import lombok.patcher.ScriptManager;
@@ -57,7 +57,7 @@ public class DisableCheckedExceptionsAgent extends AbstractProcessor {
 			procEnv.getMessager().printMessage(Kind.WARNING, "You aren't using a compiler based around javac v1.6, so disableCheckedExceptions will not work.\n" +
 					"Your processor class is: " + className);
 		} else {
-			new LiveInjector().inject(HomeFinder.findHomeOfClass(DisableCheckedExceptionsAgent.class));
+			new LiveInjector().inject(ClassRootFinder.findClassRootOfClass(DisableCheckedExceptionsAgent.class));
 		}
 	}
 	

File: src/core/lombok/core/AnnotationProcessor.java
Patch:
@@ -43,7 +43,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic.Kind;
 
-import lombok.patcher.HomeFinder;
+import lombok.patcher.ClassRootFinder;
 
 @SupportedAnnotationTypes("*")
 public class AnnotationProcessor extends AbstractProcessor {
@@ -102,7 +102,7 @@ private ClassLoader findAndPatchClassLoader(ProcessingEnvironment procEnv) throw
 			if (environmentClassLoader != null && environmentClassLoader.getClass().getCanonicalName().equals("org.codehaus.plexus.compiler.javac.IsolatedClassLoader")) {
 				if (lombokAlreadyAddedTo.put(environmentClassLoader, true) == null) {
 					Method m = environmentClassLoader.getClass().getDeclaredMethod("addURL", URL.class);
-					URL selfUrl = new File(HomeFinder.findHomeOfClass(AnnotationProcessor.class)).toURI().toURL();
+					URL selfUrl = new File(ClassRootFinder.findClassRootOfClass(AnnotationProcessor.class)).toURI().toURL();
 					m.invoke(environmentClassLoader, selfUrl);
 				}
 				return environmentClassLoader;

File: src/core/lombok/core/PublicApiCreatorApp.java
Patch:
@@ -35,7 +35,7 @@
 import java.util.zip.ZipEntry;
 
 import lombok.Lombok;
-import lombok.patcher.HomeFinder;
+import lombok.patcher.ClassRootFinder;
 
 import org.mangosdk.spi.ProviderFor;
 
@@ -79,7 +79,7 @@ public class PublicApiCreatorApp extends LombokApp {
 	 * a jar that wasn't accessed via the file-system, or if its started via e.g. unpacking the jar.
 	 */
 	private static File findOurJar() {
-		return new File(HomeFinder.findHomeOfClass(PublicApiCreatorApp.class));
+		return new File(ClassRootFinder.findClassRootOfClass(PublicApiCreatorApp.class));
 	}
 	
 	private int writeApiJar(File outFile) throws Exception {

File: src/installer/lombok/installer/IdeLocation.java
Patch:
@@ -26,7 +26,7 @@
 import java.net.URL;
 
 import lombok.installer.eclipse.EclipseFinder;
-import lombok.patcher.HomeFinder;
+import lombok.patcher.ClassRootFinder;
 
 /**
  * Represents a location that contains an IDE.
@@ -46,7 +46,7 @@ public abstract class IdeLocation {
 	 * a jar that wasn't accessed via the file-system, or if its started via e.g. unpacking the jar.
 	 */
 	public static File findOurJar() {
-		return new File(HomeFinder.findHomeOfClass(IdeFinder.class));
+		return new File(ClassRootFinder.findClassRootOfClass(IdeFinder.class));
 	}
 	
 	@Override public String toString() {

File: src/installer/lombok/installer/Installer.java
Patch:
@@ -39,7 +39,7 @@
 import lombok.core.SpiLoadUtil;
 import lombok.core.Version;
 import lombok.installer.IdeFinder.OS;
-import lombok.patcher.HomeFinder;
+import lombok.patcher.ClassRootFinder;
 
 import org.mangosdk.spi.ProviderFor;
 
@@ -101,7 +101,7 @@ static void autoDiscover(List<IdeLocation> locations, List<CorruptedIdeLocationE
 	}
 	
 	public static boolean isSelf(String jar) {
-		String self = HomeFinder.findHomeOfClass(Installer.class);
+		String self = ClassRootFinder.findClassRootOfClass(Installer.class);
 		if (self == null) return false;
 		File a = new File(jar).getAbsoluteFile();
 		File b = new File(self).getAbsoluteFile();

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -197,7 +197,7 @@ void warning(String message, String bundleName, Throwable error) {
 		private void msg(int msgType, String message, String bundleName, Throwable error) {
 			Bundle bundle = Platform.getBundle(bundleName);
 			if (bundle == null) {
-				System.err.printf("Can't find bundle %s while trying to report error:\n%s\n", bundleName, message);
+				System.err.printf("Can't find bundle %s while trying to report error:\n%s\n%s\n", bundleName, message, error);
 				return;
 			}
 			

File: src/core/lombok/extern/slf4j/Slf4j.java
Patch:
@@ -52,7 +52,8 @@
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
  * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
- */
+ * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
+ *  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)
 public @interface Slf4j {

File: test/transform/resource/after-delombok/Accessors.java
Patch:
@@ -84,7 +84,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		final java.lang.Object $fName = this.getName();
 		result = result * PRIME + ($fName == null ? 0 : $fName.hashCode());

File: test/transform/resource/after-delombok/DataExtended.java
Patch:
@@ -28,7 +28,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		return result;

File: test/transform/resource/after-delombok/DataIgnore.java
Patch:
@@ -27,7 +27,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		return result;

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -39,7 +39,7 @@ public boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				final int PRIME = 277;
+				final int PRIME = 59;
 				int result = 1;
 				result = result * PRIME + this.getX();
 				final java.lang.Object $name = this.getName();
@@ -99,7 +99,7 @@ public boolean canEqual(final java.lang.Object other) {
 				@java.lang.Override
 				@java.lang.SuppressWarnings("all")
 				public int hashCode() {
-					final int PRIME = 277;
+					final int PRIME = 59;
 					int result = 1;
 					final java.lang.Object $name = this.getName();
 					result = result * PRIME + ($name == null ? 0 : $name.hashCode());
@@ -136,7 +136,7 @@ public boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				final int PRIME = 277;
+				final int PRIME = 59;
 				int result = 1;
 				result = result * PRIME + this.getX();
 				return result;

File: test/transform/resource/after-delombok/DataWithGetter.java
Patch:
@@ -36,7 +36,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		result = result * PRIME + this.getY();

File: test/transform/resource/after-delombok/DataWithGetterNone.java
Patch:
@@ -36,7 +36,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.x;
 		result = result * PRIME + this.y;

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -69,7 +69,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.x;
 		return result;

File: test/transform/resource/after-delombok/GetterLazyBoolean.java
Patch:
@@ -21,9 +21,9 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
-		result = result * PRIME + (this.isBooleanValue() ? 2609 : 2591);
+		result = result * PRIME + (this.isBooleanValue() ? 79 : 97);
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/GetterLazyEahcToString.java
Patch:
@@ -27,7 +27,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		final java.lang.Object $value = this.getValue();
 		result = result * PRIME + ($value == null ? 0 : $value.hashCode());

File: test/transform/resource/after-delombok/GetterSetterJavadoc.java
Patch:
@@ -41,7 +41,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getFieldName();
 		return result;

File: test/transform/resource/after-delombok/ValuePlain.java
Patch:
@@ -30,7 +30,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		final java.lang.Object $name = this.getName();
@@ -80,7 +80,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		final java.lang.Object $name = this.getName();
@@ -123,7 +123,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 277;
+		final int PRIME = 59;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		result = result * PRIME + this.getY();

File: test/transform/resource/after-ecj/Accessors.java
Patch:
@@ -90,7 +90,7 @@ private String getName() {
     return (other instanceof AccessorsPrefix3);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     final java.lang.Object $fName = this.getName();
     result = ((result * PRIME) + (($fName == null) ? 0 : $fName.hashCode()));

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -22,7 +22,7 @@
     return (other instanceof DataExtended);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     return result;

File: test/transform/resource/after-ecj/DataIgnore.java
Patch:
@@ -20,7 +20,7 @@
     return (other instanceof DataIgnore);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     return result;

File: test/transform/resource/after-ecj/DataOnLocalClass.java
Patch:
@@ -36,7 +36,7 @@ public static void main(String[] args) {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        final int PRIME = 277;
+        final int PRIME = 59;
         int result = 1;
         result = ((result * PRIME) + this.getX());
         final java.lang.Object $name = this.getName();
@@ -86,7 +86,7 @@ class DataOnLocalClass2 {
           return (other instanceof Local.InnerLocal);
         }
         public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-          final int PRIME = 277;
+          final int PRIME = 59;
           int result = 1;
           final java.lang.Object $name = this.getName();
           result = ((result * PRIME) + (($name == null) ? 0 : $name.hashCode()));
@@ -124,7 +124,7 @@ class DataOnLocalClass2 {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        final int PRIME = 277;
+        final int PRIME = 59;
         int result = 1;
         result = ((result * PRIME) + this.getX());
         return result;

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -30,7 +30,7 @@
     return (other instanceof DataWithGetter);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     result = ((result * PRIME) + this.getY());

File: test/transform/resource/after-ecj/DataWithGetterNone.java
Patch:
@@ -30,7 +30,7 @@
     return (other instanceof DataWithGetterNone);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.x);
     result = ((result * PRIME) + this.y);

File: test/transform/resource/after-ecj/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -57,7 +57,7 @@ public boolean equals(Object other) {
     return (other instanceof EqualsAndHashCodeWithNoExistingMethods);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.x);
     return result;

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -57,9 +57,9 @@ private static boolean calculateBoolean() {
     return (other instanceof GetterLazyBoolean);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
-    result = ((result * PRIME) + (this.isBooleanValue() ? 2609 : 2591));
+    result = ((result * PRIME) + (this.isBooleanValue() ? 79 : 97));
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -46,7 +46,7 @@
     return (other instanceof GetterLazyEahcToString);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     final java.lang.Object $value = this.getValue();
     result = ((result * PRIME) + (($value == null) ? 0 : $value.hashCode()));

File: test/transform/resource/after-ecj/GetterSetterJavadoc.java
Patch:
@@ -22,7 +22,7 @@
     return (other instanceof GetterSetterJavadoc1);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getFieldName());
     return result;

File: test/transform/resource/after-ecj/ValuePlain.java
Patch:
@@ -23,7 +23,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     final java.lang.Object $name = this.getName();
@@ -68,7 +68,7 @@
     return (other instanceof Value2);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     final java.lang.Object $name = this.getName();
@@ -106,7 +106,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 277;
+    final int PRIME = 59;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     result = ((result * PRIME) + this.getY());

File: test/transform/resource/before/EqualsAndHashCode.java
Patch:
@@ -13,6 +13,7 @@ final class EqualsAndHashCode2 {
 	long y;
 	float f;
 	double d;
+	boolean b;
 }
 
 @lombok.EqualsAndHashCode(callSuper=false)

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -591,7 +591,7 @@ public void printEnumBody(List<JCTree> stats) throws IOException {
         for (List<JCTree> l = stats; l.nonEmpty(); l = l.tail) {
         	x++;
             if (!isEnumerator(l.head)) {
-                align();
+                if (!suppressAlignmentForEmptyLines(l.head)) align();
                 printStat(l.head);
                 println();
             }

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -33,7 +33,6 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
 
-import lombok.core.LombokImmutableList;
 import lombok.eclipse.Eclipse;
 import lombok.javac.CapturingDiagnosticListener.CompilerMessage;
 
@@ -88,7 +87,7 @@ protected IErrorHandlingPolicy ecjErrorHandlingPolicy() {
 	}
 	
 	@Override
-	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, LombokImmutableList<String> confLines) throws Throwable {
+	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file) throws Throwable {
 		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
 		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
 		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 The Project Lombok Authors.
+ * Copyright (C) 2013-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -56,6 +56,7 @@
 import org.mangosdk.spi.ProviderFor;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -71,7 +72,7 @@
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleBuilder extends EclipseAnnotationHandler<Builder> {
 	@Override public void handle(AnnotationValues<Builder> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Builder.FLAG_USAGE, "@Builder");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, "@Builder");
 		
 		long p = (long) ast.sourceStart << 32 | ast.sourceEnd;
 		

File: src/core/lombok/eclipse/handlers/HandleCleanup.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2011 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,6 +27,7 @@
 import java.util.Arrays;
 
 import lombok.Cleanup;
+import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
 import lombok.core.AST.Kind;
 import lombok.eclipse.EclipseAnnotationHandler;
@@ -59,7 +60,7 @@
 @ProviderFor(EclipseAnnotationHandler.class)
 public class HandleCleanup extends EclipseAnnotationHandler<Cleanup> {
 	public void handle(AnnotationValues<Cleanup> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Cleanup.FLAG_USAGE, "@Cleanup");
+		handleFlagUsage(annotationNode, ConfigurationKeys.CLEANUP_FLAG_USAGE, "@Cleanup");
 		
 		String cleanupName = annotation.getInstance().value();
 		if (cleanupName.length() == 0) {

File: src/core/lombok/eclipse/handlers/HandleExtensionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -30,6 +30,7 @@
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.mangosdk.spi.ProviderFor;
 
+import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
 import lombok.eclipse.EclipseAnnotationHandler;
@@ -41,7 +42,7 @@
 @HandlerPriority(66560) // 2^16 + 2^10; we must run AFTER HandleVal which is at 2^16
 public class HandleExtensionMethod extends EclipseAnnotationHandler<ExtensionMethod> {
 	@Override public void handle(AnnotationValues<ExtensionMethod> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, ExtensionMethod.FLAG_USAGE, "@ExtensionMethod");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.EXTENSION_METHOD_FLAG_USAGE, "@ExtensionMethod");
 		
 		TypeDeclaration typeDecl = null;
 		EclipseNode owner = annotationNode.up();

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -24,6 +24,7 @@
 import static lombok.core.handlers.HandlerUtil.*;
 import static lombok.eclipse.handlers.EclipseHandlerUtil.*;
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -103,7 +104,7 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 	}
 	
 	public void handle(AnnotationValues<FieldDefaults> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, FieldDefaults.FLAG_USAGE, "@FieldDefaults");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.FIELD_DEFAULTS_FLAG_USAGE, "@FieldDefaults");
 		
 		EclipseNode node = annotationNode.up();
 		FieldDefaults instance = annotation.getInstance();

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -33,6 +33,7 @@
 import java.util.Map;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.Delegate;
 import lombok.Getter;
 import lombok.core.AST.Kind;
@@ -133,7 +134,7 @@ public void generateGetterForField(EclipseNode fieldNode, ASTNode pos, AccessLev
 	}
 	
 	public void handle(AnnotationValues<Getter> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Getter.FLAG_USAGE, "@Getter");
+		handleFlagUsage(annotationNode, ConfigurationKeys.GETTER_FLAG_USAGE, "@Getter");
 		
 		EclipseNode node = annotationNode.up();
 		Getter annotationInstance = annotation.getInstance();

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,6 +32,7 @@
 import java.util.List;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.Setter;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -119,7 +120,7 @@ public void generateSetterForField(EclipseNode fieldNode, ASTNode pos, AccessLev
 	}
 	
 	public void handle(AnnotationValues<Setter> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Setter.FLAG_USAGE, "@Setter");
+		handleFlagUsage(annotationNode, ConfigurationKeys.SETTER_FLAG_USAGE, "@Setter");
 		
 		EclipseNode node = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();

File: src/core/lombok/eclipse/handlers/HandleSneakyThrows.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -29,6 +29,7 @@
 import java.util.Arrays;
 import java.util.List;
 
+import lombok.ConfigurationKeys;
 import lombok.SneakyThrows;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -76,7 +77,7 @@ private static class DeclaredException {
 	}
 	
 	@Override public void handle(AnnotationValues<SneakyThrows> annotation, Annotation source, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, SneakyThrows.FLAG_USAGE, "@SneakyThrows");
+		handleFlagUsage(annotationNode, ConfigurationKeys.SNEAKY_THROWS_FLAG_USAGE, "@SneakyThrows");
 		
 		List<String> exceptionNames = annotation.getRawExpressions("value");
 		List<DeclaredException> exceptions = new ArrayList<DeclaredException>();

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -26,6 +26,7 @@
 
 import java.lang.reflect.Modifier;
 
+import lombok.ConfigurationKeys;
 import lombok.Synchronized;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -106,7 +107,7 @@ private char[] createLockField(AnnotationValues<Synchronized> annotation, Eclips
 	}
 	
 	@Override public void handle(AnnotationValues<Synchronized> annotation, Annotation source, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Synchronized.FLAG_USAGE, "@Synchronized");
+		handleFlagUsage(annotationNode, ConfigurationKeys.SYNCHRONIZED_FLAG_USAGE, "@Synchronized");
 		
 		int p1 = source.sourceStart -1;
 		int p2 = source.sourceStart -2;

File: src/core/lombok/eclipse/handlers/HandleToString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -33,6 +33,7 @@
 import java.util.Set;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.ToString;
 import lombok.core.AnnotationValues;
 import lombok.core.AST.Kind;
@@ -95,7 +96,7 @@ public void generateToStringForType(EclipseNode typeNode, EclipseNode errorNode)
 	}
 	
 	public void handle(AnnotationValues<ToString> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, ToString.FLAG_USAGE, "@ToString");
+		handleFlagUsage(annotationNode, ConfigurationKeys.TO_STRING_FLAG_USAGE, "@ToString");
 		
 		ToString ann = annotation.getInstance();
 		List<String> excludes = Arrays.asList(ann.exclude());

File: src/core/lombok/eclipse/handlers/HandleVal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2013 The Project Lombok Authors.
+ * Copyright (C) 2010-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -22,6 +22,7 @@
 package lombok.eclipse.handlers;
 
 import static lombok.core.handlers.HandlerUtil.*;
+import lombok.ConfigurationKeys;
 import lombok.val;
 import lombok.core.HandlerPriority;
 import lombok.eclipse.DeferUntilPostDiet;
@@ -44,7 +45,7 @@
 public class HandleVal extends EclipseASTAdapter {
 	@Override public void visitLocal(EclipseNode localNode, LocalDeclaration local) {
 		if (!EclipseHandlerUtil.typeMatches(val.class, localNode, local.type)) return;
-		handleFlagUsage(localNode, val.FLAG_USAGE, "val");
+		handleFlagUsage(localNode, ConfigurationKeys.VAL_FLAG_USAGE, "val");
 		
 		boolean variableOfForEach = false;
 		

File: src/core/lombok/eclipse/handlers/HandleValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,6 +27,7 @@
 import java.util.Collections;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
 import lombok.eclipse.EclipseAnnotationHandler;
@@ -47,7 +48,7 @@
 @HandlerPriority(-512) //-2^9; to ensure @EqualsAndHashCode and such pick up on this handler making the class final and messing with the fields' access levels, run earlier.
 public class HandleValue extends EclipseAnnotationHandler<Value> {
 	public void handle(AnnotationValues<Value> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Value.FLAG_USAGE, "@Value");
+		handleFlagUsage(annotationNode, ConfigurationKeys.VALUE_FLAG_USAGE, "@Value");
 		
 		Value ann = annotation.getInstance();
 		EclipseNode typeNode = annotationNode.up();

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,6 +32,7 @@
 import java.util.List;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.core.TransformationsUtil;
@@ -121,7 +122,7 @@ public void generateWitherForField(EclipseNode fieldNode, ASTNode pos, AccessLev
 	}
 	
 	@Override public void handle(AnnotationValues<Wither> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, Wither.FLAG_USAGE, "@Wither");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.WITHER_FLAG_USAGE, "@Wither");
 		
 		EclipseNode node = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 The Project Lombok Authors.
+ * Copyright (C) 2013-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -46,6 +46,7 @@
 import com.sun.tools.javac.util.Name;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -65,7 +66,7 @@
 @HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.
 public class HandleBuilder extends JavacAnnotationHandler<Builder> {
 	@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Builder.FLAG_USAGE, "@Builder");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, "@Builder");
 		
 		Builder builderInstance = annotation.getInstance();
 		String builderMethodName = builderInstance.builderMethodName();

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -25,6 +25,7 @@
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 import static lombok.javac.Javac.*;
 import lombok.Cleanup;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.delombok.LombokOptionsFactory;
@@ -62,7 +63,7 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleCleanup extends JavacAnnotationHandler<Cleanup> {
 	@Override public void handle(AnnotationValues<Cleanup> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Cleanup.FLAG_USAGE, "@Cleanup");
+		handleFlagUsage(annotationNode, ConfigurationKeys.CLEANUP_FLAG_USAGE, "@Cleanup");
 		
 		if (inNetbeansEditor(annotationNode)) return;
 		

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -24,6 +24,7 @@
 import static lombok.core.handlers.HandlerUtil.*;
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.Data;
 import lombok.core.AnnotationValues;
 import lombok.javac.JavacAnnotationHandler;
@@ -40,7 +41,7 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleData extends JavacAnnotationHandler<Data> {
 	@Override public void handle(AnnotationValues<Data> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Data.FLAG_USAGE, "@Data");
+		handleFlagUsage(annotationNode, ConfigurationKeys.DATA_FLAG_USAGE, "@Data");
 		
 		deleteAnnotationIfNeccessary(annotationNode, Data.class);
 		JavacNode typeNode = annotationNode.up();

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2013 The Project Lombok Authors.
+ * Copyright (C) 2010-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -41,6 +41,7 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
+import lombok.ConfigurationKeys;
 import lombok.Delegate;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -95,7 +96,7 @@ public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 			"finalize()"));
 	
 	@Override public void handle(AnnotationValues<Delegate> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Delegate.FLAG_USAGE, "@Delegate");
+		handleFlagUsage(annotationNode, ConfigurationKeys.DELEGATE_FLAG_USAGE, "@Delegate");
 		
 		deleteAnnotationIfNeccessary(annotationNode, Delegate.class);
 		

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -29,6 +29,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 
+import lombok.ConfigurationKeys;
 import lombok.EqualsAndHashCode;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -85,7 +86,7 @@ private void checkForBogusFieldNames(JavacNode type, AnnotationValues<EqualsAndH
 	}
 	
 	@Override public void handle(AnnotationValues<EqualsAndHashCode> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, EqualsAndHashCode.FLAG_USAGE, "@EqualsAndHashCode");
+		handleFlagUsage(annotationNode, ConfigurationKeys.EQUALS_AND_HASH_CODE_FLAG_USAGE, "@EqualsAndHashCode");
 		
 		deleteAnnotationIfNeccessary(annotationNode, EqualsAndHashCode.class);
 		EqualsAndHashCode ann = annotation.getInstance();

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -31,6 +31,7 @@
 
 import javax.lang.model.element.ElementKind;
 
+import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
 import lombok.experimental.ExtensionMethod;
@@ -65,7 +66,7 @@
 public class HandleExtensionMethod extends JavacAnnotationHandler<ExtensionMethod> {
 	@Override
 	public void handle(final AnnotationValues<ExtensionMethod> annotation, final JCAnnotation source, final JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, ExtensionMethod.FLAG_USAGE, "@ExtensionMethod");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.EXTENSION_METHOD_FLAG_USAGE, "@ExtensionMethod");
 		
 		deleteAnnotationIfNeccessary(annotationNode, ExtensionMethod.class);
 		JavacNode typeNode = annotationNode.up();

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -24,6 +24,7 @@
 import static lombok.core.handlers.HandlerUtil.*;
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -97,7 +98,7 @@ public void setFieldDefaultsForField(JavacNode fieldNode, DiagnosticPosition pos
 	}
 	
 	@Override public void handle(AnnotationValues<FieldDefaults> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, FieldDefaults.FLAG_USAGE, "@FieldDefaults");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.FIELD_DEFAULTS_FLAG_USAGE, "@FieldDefaults");
 		
 		deleteAnnotationIfNeccessary(annotationNode, FieldDefaults.class);
 		deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -32,6 +32,7 @@
 import java.util.Map;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.Delegate;
 import lombok.Getter;
 import lombok.core.AST.Kind;
@@ -128,7 +129,7 @@ public void generateGetterForField(JavacNode fieldNode, DiagnosticPosition pos,
 	}
 	
 	@Override public void handle(AnnotationValues<Getter> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Getter.FLAG_USAGE, "@Getter");
+		handleFlagUsage(annotationNode, ConfigurationKeys.GETTER_FLAG_USAGE, "@Getter");
 		
 		Collection<JavacNode> fields = annotationNode.upFromAnnotationToFields();
 		deleteAnnotationIfNeccessary(annotationNode, Getter.class);

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,6 +28,7 @@
 import java.util.Collection;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.Setter;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -119,7 +120,7 @@ public void generateSetterForField(JavacNode fieldNode, DiagnosticPosition pos,
 	}
 	
 	@Override public void handle(AnnotationValues<Setter> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Setter.FLAG_USAGE, "@Setter");
+		handleFlagUsage(annotationNode, ConfigurationKeys.SETTER_FLAG_USAGE, "@Setter");
 		
 		Collection<JavacNode> fields = annotationNode.upFromAnnotationToFields();
 		deleteAnnotationIfNeccessary(annotationNode, Setter.class);

File: src/core/lombok/javac/handlers/HandleSneakyThrows.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,6 +28,7 @@
 import java.util.Collection;
 import java.util.Collections;
 
+import lombok.ConfigurationKeys;
 import lombok.SneakyThrows;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -55,7 +56,7 @@
 @HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSneakyThrows extends JavacAnnotationHandler<SneakyThrows> {
 	@Override public void handle(AnnotationValues<SneakyThrows> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, SneakyThrows.FLAG_USAGE, "@SneakyThrows");
+		handleFlagUsage(annotationNode, ConfigurationKeys.SNEAKY_THROWS_FLAG_USAGE, "@SneakyThrows");
 		
 		deleteAnnotationIfNeccessary(annotationNode, SneakyThrows.class);
 		Collection<String> exceptionNames = annotation.getRawExpressions("value");

File: src/core/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -24,6 +24,7 @@
 import static lombok.core.handlers.HandlerUtil.*;
 import static lombok.javac.Javac.*;
 import static lombok.javac.handlers.JavacHandlerUtil.*;
+import lombok.ConfigurationKeys;
 import lombok.Synchronized;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -55,7 +56,7 @@ public class HandleSynchronized extends JavacAnnotationHandler<Synchronized> {
 	private static final String STATIC_LOCK_NAME = "$LOCK";
 	
 	@Override public void handle(AnnotationValues<Synchronized> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Synchronized.FLAG_USAGE, "@Synchronized");
+		handleFlagUsage(annotationNode, ConfigurationKeys.SYNCHRONIZED_FLAG_USAGE, "@Synchronized");
 		
 		if (inNetbeansEditor(annotationNode)) return;
 		

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,6 +27,7 @@
 
 import java.util.Collection;
 
+import lombok.ConfigurationKeys;
 import lombok.ToString;
 import lombok.core.AnnotationValues;
 import lombok.core.AST.Kind;
@@ -72,7 +73,7 @@ private void checkForBogusFieldNames(JavacNode type, AnnotationValues<ToString>
 	}
 	
 	@Override public void handle(AnnotationValues<ToString> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, ToString.FLAG_USAGE, "@ToString");
+		handleFlagUsage(annotationNode, ConfigurationKeys.TO_STRING_FLAG_USAGE, "@ToString");
 		
 		deleteAnnotationIfNeccessary(annotationNode, ToString.class);
 		

File: src/core/lombok/javac/handlers/HandleValue.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,6 +27,7 @@
 import java.lang.annotation.Annotation;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
 import lombok.experimental.NonFinal;
@@ -52,7 +53,7 @@ public class HandleValue extends JavacAnnotationHandler<Value> {
 		@SuppressWarnings("deprecation")
 		Class<? extends Annotation> oldExperimentalValue = lombok.experimental.Value.class;
 		
-		handleFlagUsage(annotationNode, Value.FLAG_USAGE, "@Value");
+		handleFlagUsage(annotationNode, ConfigurationKeys.VALUE_FLAG_USAGE, "@Value");
 		
 		deleteAnnotationIfNeccessary(annotationNode, Value.class, oldExperimentalValue);
 		JavacNode typeNode = annotationNode.up();

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2013 The Project Lombok Authors.
+ * Copyright (C) 2012-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,6 +28,7 @@
 import java.util.Collection;
 
 import lombok.AccessLevel;
+import lombok.ConfigurationKeys;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
 import lombok.core.TransformationsUtil;
@@ -120,7 +121,7 @@ public void generateWitherForField(JavacNode fieldNode, DiagnosticPosition pos,
 	}
 	
 	@Override public void handle(AnnotationValues<Wither> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, Wither.FLAG_USAGE, "@Wither");
+		handleExperimentalFlagUsage(annotationNode, ConfigurationKeys.WITHER_FLAG_USAGE, "@Wither");
 		
 		Collection<JavacNode> fields = annotationNode.upFromAnnotationToFields();
 		deleteAnnotationIfNeccessary(annotationNode, Wither.class);

File: src/core/lombok/eclipse/handlers/HandleNonNull.java
Patch:
@@ -27,6 +27,7 @@
 
 import java.util.Arrays;
 
+import lombok.ConfigurationKeys;
 import lombok.NonNull;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
@@ -58,7 +59,7 @@
 @HandlerPriority(value = 512) // 2^9; onParameter=@__(@NonNull) has to run first.
 public class HandleNonNull extends EclipseAnnotationHandler<NonNull> {
 	@Override public void handle(AnnotationValues<NonNull> annotation, Annotation ast, EclipseNode annotationNode) {
-		handleFlagUsage(annotationNode, NonNull.FLAG_USAGE, "@NonNull");
+		handleFlagUsage(annotationNode, ConfigurationKeys.NON_NULL_FLAG_USAGE, "@NonNull");
 		
 		if (annotationNode.up().getKind() == Kind.FIELD) {
 			// This is meaningless unless the field is used to generate a method (@Setter, @RequiredArgsConstructor, etc),

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -43,6 +43,7 @@
 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 import com.sun.tools.javac.util.List;
 
+import lombok.ConfigurationKeys;
 import lombok.NonNull;
 import lombok.core.AnnotationValues;
 import lombok.core.HandlerPriority;
@@ -56,7 +57,7 @@
 @HandlerPriority(value = 512) // 2^9; onParameter=@__(@NonNull) has to run first.
 public class HandleNonNull extends JavacAnnotationHandler<NonNull> {
 	@Override public void handle(AnnotationValues<NonNull> annotation, JCAnnotation ast, JavacNode annotationNode) {
-		handleFlagUsage(annotationNode, NonNull.FLAG_USAGE, "@NonNull");
+		handleFlagUsage(annotationNode, ConfigurationKeys.NON_NULL_FLAG_USAGE, "@NonNull");
 		
 		if (annotationNode.up().getKind() == Kind.FIELD) {
 			// This is meaningless unless the field is used to generate a method (@Setter, @RequiredArgsConstructor, etc),

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -395,7 +395,7 @@ void printMessage(Diagnostic.Kind kind, String message, JavacNode node, Diagnost
 		}
 	}
 
-	private void removeFromDeferredDiagnostics(int startPos, int endPos) {
+	public void removeFromDeferredDiagnostics(int startPos, int endPos) {
 		JCCompilationUnit self = (JCCompilationUnit) top().get();
 		new CompilerMessageSuppressor(getContext()).removeAllBetween(self.sourcefile, startPos, endPos);
 	}

File: src/core/lombok/core/configuration/BubblingConfigurationResolver.java
Patch:
@@ -44,7 +44,7 @@ public <T> T resolve(ConfigurationKey<T> key) {
 		boolean isList = key.getType().isList();
 		List<ListModification> listModifications = null;
 		for (ConfigurationSource source : sources) {
-			Result<T> result = source.resolve(key);
+			Result result = source.resolve(key);
 			if (result == null) continue;
 			if (isList) {
 				if (listModifications == null) {
@@ -57,9 +57,9 @@ public <T> T resolve(ConfigurationKey<T> key) {
 				if (isList) {
 					break;
 				}
-				return result.getValue();
+				return (T) result.getValue();
 			}
-			Result<Boolean> stop = source.resolve(STOP_BUBBLING);
+			Result stop = source.resolve(STOP_BUBBLING);
 			if (stop != null && Boolean.TRUE.equals(stop.getValue())) break;
 		}
 		if (!isList) {

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -225,7 +225,7 @@ private JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker t
 		
 		List<JCStatement> statements;
 		JCTree toClearOfMarkers = null;
-		if (lazy) {
+		if (lazy && !inNetbeansEditor(field)) {
 			toClearOfMarkers = fieldNode.init;
 			statements = createLazyGetterBody(treeMaker, field, source);
 		} else {

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2013 The Project Lombok Authors.
+ * Copyright (C) 2009-2014 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -225,7 +225,7 @@ private JCMethodDecl createGetter(long access, JavacNode field, JavacTreeMaker t
 		
 		List<JCStatement> statements;
 		JCTree toClearOfMarkers = null;
-		if (lazy) {
+		if (lazy && !inNetbeansEditor(field)) {
 			toClearOfMarkers = fieldNode.init;
 			statements = createLazyGetterBody(treeMaker, field, source);
 		} else {

File: test/transform/resource/after-delombok/GetterLazyBoolean.java
Patch:
@@ -23,7 +23,7 @@ public boolean canEqual(final java.lang.Object other) {
 	public int hashCode() {
 		final int PRIME = 277;
 		int result = 1;
-		result = result * PRIME + (this.isBooleanValue() ? 2591 : 2609);
+		result = result * PRIME + (this.isBooleanValue() ? 2609 : 2591);
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -59,7 +59,7 @@ private static boolean calculateBoolean() {
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
     final int PRIME = 277;
     int result = 1;
-    result = ((result * PRIME) + (this.isBooleanValue() ? 2591 : 2609));
+    result = ((result * PRIME) + (this.isBooleanValue() ? 2609 : 2591));
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -467,6 +467,7 @@ private static <T> com.sun.tools.javac.util.List<T> toJavacList(List<T> list) {
 	
 	public boolean delombok() throws IOException {
 		LombokOptions options = LombokOptionsFactory.getDelombokOptions(context);
+		options.deleteLombokAnnotations();
 		options.putJavacOption("ENCODING", charset.name());
 		if (classpath != null) options.putJavacOption("CLASSPATH", classpath);
 		if (sourcepath != null) options.putJavacOption("SOURCEPATH", sourcepath);

File: test/transform/resource/after-delombok/Accessors.java
Patch:
@@ -84,7 +84,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		final java.lang.Object $fName = this.getName();
 		result = result * PRIME + ($fName == null ? 0 : $fName.hashCode());

File: test/transform/resource/after-delombok/DataExtended.java
Patch:
@@ -28,7 +28,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		return result;

File: test/transform/resource/after-delombok/DataIgnore.java
Patch:
@@ -27,7 +27,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		return result;

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -39,7 +39,7 @@ public boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				final int PRIME = 31;
+				final int PRIME = 277;
 				int result = 1;
 				result = result * PRIME + this.getX();
 				final java.lang.Object $name = this.getName();
@@ -99,7 +99,7 @@ public boolean canEqual(final java.lang.Object other) {
 				@java.lang.Override
 				@java.lang.SuppressWarnings("all")
 				public int hashCode() {
-					final int PRIME = 31;
+					final int PRIME = 277;
 					int result = 1;
 					final java.lang.Object $name = this.getName();
 					result = result * PRIME + ($name == null ? 0 : $name.hashCode());
@@ -136,7 +136,7 @@ public boolean canEqual(final java.lang.Object other) {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public int hashCode() {
-				final int PRIME = 31;
+				final int PRIME = 277;
 				int result = 1;
 				result = result * PRIME + this.getX();
 				return result;

File: test/transform/resource/after-delombok/DataWithGetter.java
Patch:
@@ -36,7 +36,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		result = result * PRIME + this.getY();

File: test/transform/resource/after-delombok/DataWithGetterNone.java
Patch:
@@ -36,7 +36,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.x;
 		result = result * PRIME + this.y;

File: test/transform/resource/after-delombok/EqualsAndHashCode.java
Patch:
@@ -29,7 +29,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.x;
 		result = result * PRIME + java.util.Arrays.hashCode(this.y);
@@ -61,7 +61,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.x;
 		final long $y = this.y;
@@ -111,7 +111,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + super.hashCode();
 		return result;

File: test/transform/resource/after-delombok/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -69,7 +69,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.x;
 		return result;

File: test/transform/resource/after-delombok/GetterLazyBoolean.java
Patch:
@@ -21,9 +21,9 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
-		result = result * PRIME + (this.isBooleanValue() ? 1231 : 1237);
+		result = result * PRIME + (this.isBooleanValue() ? 2591 : 2609);
 		return result;
 	}
 	@java.lang.Override

File: test/transform/resource/after-delombok/GetterLazyEahcToString.java
Patch:
@@ -27,7 +27,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		final java.lang.Object $value = this.getValue();
 		result = result * PRIME + ($value == null ? 0 : $value.hashCode());

File: test/transform/resource/after-delombok/GetterSetterJavadoc.java
Patch:
@@ -41,7 +41,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getFieldName();
 		return result;

File: test/transform/resource/after-delombok/ValuePlain.java
Patch:
@@ -30,7 +30,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		final java.lang.Object $name = this.getName();
@@ -80,7 +80,7 @@ public boolean canEqual(final java.lang.Object other) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		final java.lang.Object $name = this.getName();
@@ -123,7 +123,7 @@ public boolean equals(final java.lang.Object o) {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public int hashCode() {
-		final int PRIME = 31;
+		final int PRIME = 277;
 		int result = 1;
 		result = result * PRIME + this.getX();
 		result = result * PRIME + this.getY();

File: test/transform/resource/after-ecj/Accessors.java
Patch:
@@ -90,7 +90,7 @@ private String getName() {
     return (other instanceof AccessorsPrefix3);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     final java.lang.Object $fName = this.getName();
     result = ((result * PRIME) + (($fName == null) ? 0 : $fName.hashCode()));

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -22,7 +22,7 @@
     return (other instanceof DataExtended);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     return result;

File: test/transform/resource/after-ecj/DataIgnore.java
Patch:
@@ -20,7 +20,7 @@
     return (other instanceof DataIgnore);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     return result;

File: test/transform/resource/after-ecj/DataOnLocalClass.java
Patch:
@@ -36,7 +36,7 @@ public static void main(String[] args) {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        final int PRIME = 31;
+        final int PRIME = 277;
         int result = 1;
         result = ((result * PRIME) + this.getX());
         final java.lang.Object $name = this.getName();
@@ -86,7 +86,7 @@ class DataOnLocalClass2 {
           return (other instanceof Local.InnerLocal);
         }
         public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-          final int PRIME = 31;
+          final int PRIME = 277;
           int result = 1;
           final java.lang.Object $name = this.getName();
           result = ((result * PRIME) + (($name == null) ? 0 : $name.hashCode()));
@@ -124,7 +124,7 @@ class DataOnLocalClass2 {
         return (other instanceof Local);
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-        final int PRIME = 31;
+        final int PRIME = 277;
         int result = 1;
         result = ((result * PRIME) + this.getX());
         return result;

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -30,7 +30,7 @@
     return (other instanceof DataWithGetter);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     result = ((result * PRIME) + this.getY());

File: test/transform/resource/after-ecj/DataWithGetterNone.java
Patch:
@@ -30,7 +30,7 @@
     return (other instanceof DataWithGetterNone);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.x);
     result = ((result * PRIME) + this.y);

File: test/transform/resource/after-ecj/EqualsAndHashCode.java
Patch:
@@ -35,7 +35,7 @@
     return (other instanceof EqualsAndHashCode);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.x);
     result = ((result * PRIME) + java.util.Arrays.hashCode(this.y));
@@ -72,7 +72,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.x);
     final long $y = this.y;
@@ -125,7 +125,7 @@
     return (other instanceof EqualsAndHashCode4);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + super.hashCode());
     return result;

File: test/transform/resource/after-ecj/EqualsAndHashCodeWithSomeExistingMethods.java
Patch:
@@ -57,7 +57,7 @@ public boolean equals(Object other) {
     return (other instanceof EqualsAndHashCodeWithNoExistingMethods);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.x);
     return result;

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -57,9 +57,9 @@ private static boolean calculateBoolean() {
     return (other instanceof GetterLazyBoolean);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
-    result = ((result * PRIME) + (this.isBooleanValue() ? 1231 : 1237));
+    result = ((result * PRIME) + (this.isBooleanValue() ? 2591 : 2609));
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -46,7 +46,7 @@
     return (other instanceof GetterLazyEahcToString);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     final java.lang.Object $value = this.getValue();
     result = ((result * PRIME) + (($value == null) ? 0 : $value.hashCode()));

File: test/transform/resource/after-ecj/GetterSetterJavadoc.java
Patch:
@@ -22,7 +22,7 @@
     return (other instanceof GetterSetterJavadoc1);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getFieldName());
     return result;

File: test/transform/resource/after-ecj/ValuePlain.java
Patch:
@@ -23,7 +23,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     final java.lang.Object $name = this.getName();
@@ -68,7 +68,7 @@
     return (other instanceof Value2);
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     final java.lang.Object $name = this.getName();
@@ -106,7 +106,7 @@
     return true;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
-    final int PRIME = 31;
+    final int PRIME = 277;
     int result = 1;
     result = ((result * PRIME) + this.getX());
     result = ((result * PRIME) + this.getY());

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -149,7 +149,7 @@ public static <T extends JCTree> T setGeneratedBy(T node, JCTree source, Context
 			if (source == null) generatedNodes.remove(node);
 			else generatedNodes.put(node, new WeakReference<JCTree>(source));
 		}
-		if (source != null && !inNetbeansEditor(context)) node.pos = source.pos;
+		if (source != null && (!inNetbeansEditor(context) || (node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0))) node.pos = source.pos;
 		return node;
 	}
 	

File: src/core/lombok/eclipse/handlers/HandleLog.java
Patch:
@@ -73,6 +73,8 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue
 			
 			FieldDeclaration fieldDeclaration = createField(framework, source, loggingType);
 			fieldDeclaration.traverse(new SetGeneratedByVisitor(source), typeDecl.staticInitializerScope);
+			// TODO temporary workaround for issue 217. http://code.google.com/p/projectlombok/issues/detail?id=217
+			// injectFieldSuppressWarnings(owner, fieldDeclaration);
 			injectField(owner, fieldDeclaration);
 			owner.rebuild();
 			break;

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -93,7 +93,7 @@ private static boolean createField(LoggingFramework framework, JavacNode typeNod
 				maker.Modifiers(Flags.PRIVATE | Flags.FINAL | Flags.STATIC),
 				typeNode.toName("log"), loggerType, factoryMethodCall), source, typeNode.getContext());
 		
-		injectField(typeNode, fieldDecl);
+		injectFieldSuppressWarnings(typeNode, fieldDecl);
 		return true;
 	}
 	

File: test/transform/resource/after-delombok/InjectField.java
Patch:
@@ -4,6 +4,7 @@ enum InjectField1 {
 	A,
 	B;
 
+	@java.lang.SuppressWarnings("all")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(InjectField1.class.getName());
 	@java.lang.SuppressWarnings("all")
 	private final java.lang.Object $lock = new java.lang.Object[0];
@@ -34,6 +35,7 @@ static void generateStaticLockField() {
 }
 
 class InjectField2 {
+	@java.lang.SuppressWarnings("all")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(InjectField2.class.getName());
 	@java.lang.SuppressWarnings("all")
 	private final java.lang.Object $lock = new java.lang.Object[0];
@@ -52,6 +54,7 @@ void generateLockField() {
 }
 
 class InjectField3 {
+	@java.lang.SuppressWarnings("all")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(InjectField3.class.getName());
 	static {
 		log.log(Level.FINE, "static initializer");

File: test/transform/resource/after-delombok/LoggerCommons.java
Patch:
@@ -1,6 +1,8 @@
 class LoggerCommons {
+	@java.lang.SuppressWarnings("all")
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommons.class);
 }
 class LoggerCommonsWithImport {
+	@java.lang.SuppressWarnings("all")
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommonsWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerJul.java
Patch:
@@ -1,6 +1,8 @@
 class LoggerJul {
+	@java.lang.SuppressWarnings("all")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJul.class.getName());
 }
 class LoggerJulWithImport {
+	@java.lang.SuppressWarnings("all")
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJulWithImport.class.getName());
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerLog4j.java
Patch:
@@ -1,6 +1,8 @@
 class LoggerLog4j {
+	@java.lang.SuppressWarnings("all")
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4j.class);
 }
 class LoggerLog4jWithImport {
+	@java.lang.SuppressWarnings("all")
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4jWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerLog4j2.java
Patch:
@@ -1,6 +1,8 @@
 class LoggerLog4j2 {
+	@java.lang.SuppressWarnings("all")
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LoggerLog4j2.class);
 }
 class LoggerLog4j2WithImport {
+	@java.lang.SuppressWarnings("all")
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LoggerLog4j2WithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerSlf4j.java
Patch:
@@ -1,11 +1,14 @@
 class LoggerSlf4j {
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4j.class);
 }
 class LoggerSlf4jWithImport {
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jWithImport.class);
 }
 class LoggerSlf4jOuter {
 	static class Inner {
+		@java.lang.SuppressWarnings("all")
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerSlf4jTypes.java
Patch:
@@ -4,14 +4,17 @@ interface LoggerSlf4jTypesInterface {
 }
 enum LoggerSlf4jTypesEnum {
 ;
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnum.class);
 }
 enum LoggerSlf4jTypesEnumWithElement {
 	FOO;
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnumWithElement.class);
 }
 interface LoggerSlf4jTypesInterfaceOuter {
 	class Inner {
+		@java.lang.SuppressWarnings("all")
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerSlf4jWithPackage.java
Patch:
@@ -1,9 +1,11 @@
 package before;
 class LoggerSlf4jWithPackage {
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jWithPackage.class);
 }
 class LoggerSlf4jWithPackageOuter {
 	static class Inner {
+		@java.lang.SuppressWarnings("all")
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);
 	}
 }

File: test/transform/resource/after-delombok/LoggerXSlf4j.java
Patch:
@@ -1,6 +1,8 @@
 class LoggerXSlf4j {
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4j.class);
 }
 class LoggerXSlf4jWithImport {
+	@java.lang.SuppressWarnings("all")
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4jWithImport.class);
 }
\ No newline at end of file

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -29,6 +29,7 @@
 import lombok.core.AnnotationValues;
 import lombok.core.TransformationsUtil;
 import lombok.core.AST.Kind;
+import lombok.delombok.LombokOptionsFactory;
 import lombok.experimental.Builder;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
@@ -249,7 +250,7 @@ static JCMethodDecl createConstructor(AccessLevel level, List<JCAnnotation> onCo
 		}
 		
 		JCModifiers mods = maker.Modifiers(toJavacModifier(level), List.<JCAnnotation>nil());
-		if (!suppressConstructorProperties && level != AccessLevel.PRIVATE && !isLocalType(typeNode)) {
+		if (!suppressConstructorProperties && level != AccessLevel.PRIVATE && !isLocalType(typeNode) && LombokOptionsFactory.getDelombokOptions(typeNode.getContext()).getFormatPreferences().generateConstructorProperties()) {
 			addConstructorProperties(mods, typeNode, fields);
 		}
 		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor));

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -271,7 +271,7 @@ private JCMethodDecl createDelegateMethod(MethodSig sig, JavacNode annotation, N
 		com.sun.tools.javac.util.List<JCAnnotation> annotations;
 		if (sig.isDeprecated) {
 			annotations = com.sun.tools.javac.util.List.of(maker.Annotation(
-					chainDots(annotation, "java", "lang", "Deprecated"),
+					genJavaLangTypeRef(annotation, "Deprecated"),
 					com.sun.tools.javac.util.List.<JCExpression>nil()));
 		} else {
 			annotations = com.sun.tools.javac.util.List.nil();

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -246,7 +246,7 @@ static JCMethodDecl createSetter(long access, JavacNode field, JavacTreeMaker tr
 		
 		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
 		if (isFieldDeprecated(field)) {
-			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(chainDots(field, "java", "lang", "Deprecated"), List.<JCExpression>nil()));
+			annsOnMethod = annsOnMethod.prepend(treeMaker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}
 		
 		JCMethodDecl decl = recursiveSetGeneratedBy(treeMaker.MethodDef(treeMaker.Modifiers(access, annsOnMethod), methodName, methodType,

File: src/core/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -88,9 +88,9 @@ public class HandleSynchronized extends JavacAnnotationHandler<Synchronized> {
 				annotationNode.addError("The field " + lockName + " does not exist.");
 				return;
 			}
-			JCExpression objectType = chainDots(methodNode, ast.pos, "java", "lang", "Object");
+			JCExpression objectType = genJavaLangTypeRef(methodNode, ast.pos, "Object");
 			//We use 'new Object[0];' because unlike 'new Object();', empty arrays *ARE* serializable!
-			JCNewArray newObjectArray = maker.NewArray(chainDots(methodNode, ast.pos, "java", "lang", "Object"),
+			JCNewArray newObjectArray = maker.NewArray(genJavaLangTypeRef(methodNode, ast.pos, "Object"),
 					List.<JCExpression>of(maker.Literal(CTC_INT, 0)), null);
 			JCVariableDecl fieldDecl = recursiveSetGeneratedBy(maker.VarDef(
 					maker.Modifiers(Flags.PRIVATE | Flags.FINAL | (isStatic ? Flags.STATIC : 0)),

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -169,9 +169,9 @@ public void generateToString(JavacNode typeNode, JavacNode source, List<String>
 	static JCMethodDecl createToString(JavacNode typeNode, Collection<JavacNode> fields, boolean includeFieldNames, boolean callSuper, FieldAccess fieldAccess, JCTree source) {
 		JavacTreeMaker maker = typeNode.getTreeMaker();
 		
-		JCAnnotation overrideAnnotation = maker.Annotation(chainDots(typeNode, "java", "lang", "Override"), List.<JCExpression>nil());
+		JCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, "Override"), List.<JCExpression>nil());
 		JCModifiers mods = maker.Modifiers(Flags.PUBLIC, List.of(overrideAnnotation));
-		JCExpression returnType = chainDots(typeNode, "java", "lang", "String");
+		JCExpression returnType = genJavaLangTypeRef(typeNode, "String");
 		
 		boolean first = true;
 		

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -262,7 +262,7 @@ private JCMethodDecl createWither(long access, JavacNode field, JavacTreeMaker m
 		List<JCAnnotation> annsOnMethod = copyAnnotations(onMethod);
 		
 		if (isFieldDeprecated(field)) {
-			annsOnMethod = annsOnMethod.prepend(maker.Annotation(chainDots(field, "java", "lang", "Deprecated"), List.<JCExpression>nil()));
+			annsOnMethod = annsOnMethod.prepend(maker.Annotation(genJavaLangTypeRef(field, "Deprecated"), List.<JCExpression>nil()));
 		}
 		JCMethodDecl decl = recursiveSetGeneratedBy(maker.MethodDef(maker.Modifiers(access, annsOnMethod), methodName, returnType,
 				methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source, field.getContext());

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -288,7 +288,7 @@ private java.util.List<JavacNode> addFieldsToBuilder(JavacNode builderType, java
 			}
 			JavacTreeMaker maker = builderType.getTreeMaker();
 			JCModifiers mods = maker.Modifiers(Flags.PRIVATE);
-			JCVariableDecl newField = maker.VarDef(mods, name, cloneType(maker, typesOfParameters.get(i), source), null);
+			JCVariableDecl newField = maker.VarDef(mods, name, cloneType(maker, typesOfParameters.get(i), source, builderType.getContext()), null);
 			out.add(injectField(builderType, newField));
 		}
 		

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -254,7 +254,7 @@ static JCMethodDecl createConstructor(AccessLevel level, List<JCAnnotation> onCo
 		if (onConstructor != null) mods.annotations = mods.annotations.appendList(copyAnnotations(onConstructor));
 		
 		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("<init>"),
-				null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(), maker.Block(0L, nullChecks.appendList(assigns).toList()), null), source);
+				null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(), maker.Block(0L, nullChecks.appendList(assigns).toList()), null), source, typeNode.getContext());
 	}
 	
 	private static boolean isLocalType(JavacNode type) {
@@ -294,7 +294,7 @@ private JCMethodDecl createStaticConstructor(String name, AccessLevel level, Jav
 		for (JavacNode fieldNode : fields) {
 			JCVariableDecl field = (JCVariableDecl) fieldNode.get();
 			Name fieldName = removePrefixFromField(fieldNode);
-			JCExpression pType = cloneType(maker, field.vartype, source);
+			JCExpression pType = cloneType(maker, field.vartype, source, typeNode.getContext());
 			List<JCAnnotation> nonNulls = findAnnotations(fieldNode, TransformationsUtil.NON_NULL_PATTERN);
 			List<JCAnnotation> nullables = findAnnotations(fieldNode, TransformationsUtil.NULLABLE_PATTERN);
 			JCVariableDecl param = maker.VarDef(maker.Modifiers(Flags.FINAL | Flags.PARAMETER, nonNulls.appendList(nullables)), fieldName, pType, null);
@@ -304,6 +304,6 @@ private JCMethodDecl createStaticConstructor(String name, AccessLevel level, Jav
 		JCReturn returnStatement = maker.Return(maker.NewClass(null, List.<JCExpression>nil(), constructorType, args.toList(), null));
 		JCBlock body = maker.Block(0, List.<JCStatement>of(returnStatement));
 		
-		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(name), returnType, typeParams.toList(), params.toList(), List.<JCExpression>nil(), body, null), source);
+		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(name), returnType, typeParams.toList(), params.toList(), List.<JCExpression>nil(), body, null), source, typeNode.getContext());
 	}
 }

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -316,7 +316,7 @@ private JCMethodDecl createDelegateMethod(MethodSig sig, JavacNode annotation, N
 		JCStatement body = useReturn ? maker.Return(delegateCall) : maker.Exec(delegateCall);
 		JCBlock bodyBlock = maker.Block(0, com.sun.tools.javac.util.List.of(body));
 		
-		return recursiveSetGeneratedBy(maker.MethodDef(mods, sig.name, returnType, toList(typeParams), toList(params), toList(thrown), bodyBlock, null), annotation.get());
+		return recursiveSetGeneratedBy(maker.MethodDef(mods, sig.name, returnType, toList(typeParams), toList(params), toList(thrown), bodyBlock, null), annotation.get(), annotation.getContext());
 	}
 	
 	private static <T> com.sun.tools.javac.util.List<T> toList(ListBuffer<T> collection) {

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -317,7 +317,7 @@ private JCMethodDecl createHashCode(JavacNode typeNode, List<JavacNode> fields,
 		
 		JCBlock body = maker.Block(0, statements.toList());
 		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("hashCode"), returnType,
-				List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source);
+				List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source, typeNode.getContext());
 	}
 
 	private JCExpressionStatement createResultCalculation(JavacNode typeNode, JCExpression expr) {
@@ -486,7 +486,7 @@ private JCMethodDecl createEquals(JavacNode typeNode, List<JavacNode> fields, bo
 		}
 		
 		JCBlock body = maker.Block(0, statements.toList());
-		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("equals"), returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source);
+		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("equals"), returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source, typeNode.getContext());
 	}
 
 	private JCMethodDecl createCanEqual(JavacNode typeNode, JCTree source) {
@@ -506,7 +506,7 @@ private JCMethodDecl createCanEqual(JavacNode typeNode, JCTree source) {
 		JCBlock body = maker.Block(0, List.<JCStatement>of(
 				maker.Return(maker.TypeTest(maker.Ident(otherName), createTypeReference(typeNode)))));
 		
-		return recursiveSetGeneratedBy(maker.MethodDef(mods, canEqualName, returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source);
+		return recursiveSetGeneratedBy(maker.MethodDef(mods, canEqualName, returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source, typeNode.getContext());
 	}
 	
 	private JCStatement generateCompareFloatOrDouble(JCExpression thisDotField, JCExpression otherDotField,

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -91,7 +91,7 @@ private static boolean createField(LoggingFramework framework, JavacNode typeNod
 		
 		JCVariableDecl fieldDecl = recursiveSetGeneratedBy(maker.VarDef(
 				maker.Modifiers(Flags.PRIVATE | Flags.FINAL | Flags.STATIC),
-				typeNode.toName("log"), loggerType, factoryMethodCall), source);
+				typeNode.toName("log"), loggerType, factoryMethodCall), source, typeNode.getContext());
 		
 		injectField(typeNode, fieldDecl);
 		return true;

File: src/core/lombok/javac/handlers/HandleNonNull.java
Patch:
@@ -91,7 +91,7 @@ public class HandleNonNull extends JavacAnnotationHandler<NonNull> {
 		// and if they exist, create a new method in the class: 'private static <T> T lombok$nullCheck(T expr, String msg) {if (expr == null) throw NPE; return expr;}' and
 		// wrap all references to it in the super/this to a call to this method.
 		
-		JCStatement nullCheck = recursiveSetGeneratedBy(generateNullCheck(annotationNode.getTreeMaker(), annotationNode.up()), ast);
+		JCStatement nullCheck = recursiveSetGeneratedBy(generateNullCheck(annotationNode.getTreeMaker(), annotationNode.up()), ast, annotationNode.getContext());
 		
 		if (nullCheck == null) {
 			// @NonNull applied to a primitive. Kinda pointless. Let's generate a warning.

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -249,7 +249,7 @@ static JCMethodDecl createSetter(long access, JavacNode field, JavacTreeMaker tr
 		}
 		
 		JCMethodDecl decl = recursiveSetGeneratedBy(treeMaker.MethodDef(treeMaker.Modifiers(access, annsOnMethod), methodName, methodType,
-				methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source);
+				methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source, field.getContext());
 		copyJavadoc(field, decl, CopyJavadoc.SETTER);
 		return decl;
 	}

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -240,7 +240,7 @@ static JCMethodDecl createToString(JavacNode typeNode, Collection<JavacNode> fie
 		JCBlock body = maker.Block(0, List.of(returnStatement));
 		
 		return recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName("toString"), returnType,
-				List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source);
+				List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source, typeNode.getContext());
 	}
 	
 	private static String getTypeName(JavacNode typeNode) {

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -84,7 +84,7 @@ public class HandleVal extends JavacASTAdapter {
 		local.mods.flags |= Flags.FINAL;
 		
 		if (!localNode.shouldDeleteLombokAnnotations()) {
-			JCAnnotation valAnnotation = recursiveSetGeneratedBy(localNode.getTreeMaker().Annotation(local.vartype, List.<JCExpression>nil()), source);
+			JCAnnotation valAnnotation = recursiveSetGeneratedBy(localNode.getTreeMaker().Annotation(local.vartype, List.<JCExpression>nil()), source, localNode.getContext());
 			local.mods.annotations = local.mods.annotations == null ? List.of(valAnnotation) : local.mods.annotations.append(valAnnotation);
 		}
 		
@@ -138,7 +138,7 @@ public class HandleVal extends JavacASTAdapter {
 			local.vartype = JavacResolution.createJavaLangObject(localNode.getAst());
 			throw e;
 		} finally {
-			recursiveSetGeneratedBy(local.vartype, source);
+			recursiveSetGeneratedBy(local.vartype, source, localNode.getContext());
 		}
 	}
 }

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -264,7 +264,7 @@ private JCMethodDecl createWither(long access, JavacNode field, JavacTreeMaker m
 			annsOnMethod = annsOnMethod.prepend(maker.Annotation(chainDots(field, "java", "lang", "Deprecated"), List.<JCExpression>nil()));
 		}
 		JCMethodDecl decl = recursiveSetGeneratedBy(maker.MethodDef(maker.Modifiers(access, annsOnMethod), methodName, returnType,
-				methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source);
+				methodGenericParams, parameters, throwsClauses, methodBody, annotationMethodDefaultValue), source, field.getContext());
 		copyJavadoc(field, decl, CopyJavadoc.WITHER);
 		return decl;
 	}

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -275,7 +275,6 @@ private static void patchPostCompileHookEclipse(ScriptManager sm) {
 				.methodToWrap(new Hook("org.eclipse.jdt.internal.compiler.ClassFile", "getBytes", "byte[]"))
 				.wrapMethod(new Hook("lombok.eclipse.agent.PatchFixes", "runPostCompiler", "byte[]", "byte[]", "java.lang.String"))
 				.requestExtra(StackRequest.PARAM3)
-				.transplant()
 				.build());
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -329,7 +329,7 @@ public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Ex
 		return newSimpleNames;
 	}
 	
-	public static byte[] runPostCompiler(byte[] bytes,  String fileName) {
+	public static byte[] runPostCompiler(byte[] bytes, String fileName) {
 		byte[] transformed = PostCompiler.applyTransformations(bytes, fileName, DiagnosticsReceiver.CONSOLE);
 		return transformed == null ? bytes : transformed;
 	}

File: src/core/lombok/core/Version.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2011 The Project Lombok Authors.
+ * Copyright (C) 2009-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/eclipse/handlers/HandleSneakyThrows.java
Patch:
@@ -30,6 +30,7 @@
 
 import lombok.SneakyThrows;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.eclipse.DeferUntilPostDiet;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
@@ -60,6 +61,7 @@
  */
 @ProviderFor(EclipseAnnotationHandler.class)
 @DeferUntilPostDiet
+@HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSneakyThrows extends EclipseAnnotationHandler<SneakyThrows> {
 	
 	private static class DeclaredException {

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -27,6 +27,7 @@
 
 import lombok.Synchronized;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.core.AST.Kind;
 import lombok.eclipse.DeferUntilPostDiet;
 import lombok.eclipse.EclipseAnnotationHandler;
@@ -52,6 +53,7 @@
  */
 @ProviderFor(EclipseAnnotationHandler.class)
 @DeferUntilPostDiet
+@HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSynchronized extends EclipseAnnotationHandler<Synchronized> {
 	private static final char[] INSTANCE_LOCK_NAME = "$lock".toCharArray();
 	private static final char[] STATIC_LOCK_NAME = "$LOCK".toCharArray();

File: src/core/lombok/javac/handlers/HandleSneakyThrows.java
Patch:
@@ -29,6 +29,7 @@
 
 import lombok.SneakyThrows;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
@@ -49,6 +50,7 @@
  * Handles the {@code lombok.SneakyThrows} annotation for javac.
  */
 @ProviderFor(JavacAnnotationHandler.class)
+@HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSneakyThrows extends JavacAnnotationHandler<SneakyThrows> {
 	@Override public void handle(AnnotationValues<SneakyThrows> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		deleteAnnotationIfNeccessary(annotationNode, SneakyThrows.class);

File: src/core/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -26,6 +26,7 @@
 import lombok.Synchronized;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacTreeMaker;
@@ -46,6 +47,7 @@
  * Handles the {@code lombok.Synchronized} annotation for javac.
  */
 @ProviderFor(JavacAnnotationHandler.class)
+@HandlerPriority(value = 1024) // 2^10; @NonNull must have run first, so that we wrap around the statements generated by it.
 public class HandleSynchronized extends JavacAnnotationHandler<Synchronized> {
 	private static final String INSTANCE_LOCK_NAME = "$lock";
 	private static final String STATIC_LOCK_NAME = "$LOCK";

File: test/transform/resource/after-ecj/InjectField.java
Patch:
@@ -4,9 +4,9 @@
 @Log enum InjectField1 {
   A(),
   B(),
+  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(InjectField1.class.getName());
   private final java.lang.Object $lock = new java.lang.Object[0];
   private static final java.lang.Object $LOCK = new java.lang.Object[0];
-  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(InjectField1.class.getName());
   private static final String LOG_MESSAGE = "static initializer";
   private String fieldA;
   static {
@@ -32,8 +32,8 @@
   }
 }
 @Log class InjectField2 {
-  private final java.lang.Object $lock = new java.lang.Object[0];
   private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(InjectField2.class.getName());
+  private final java.lang.Object $lock = new java.lang.Object[0];
   private static final String LOG_MESSAGE = "static initializer";
   static {
     log.log(Level.FINE, LOG_MESSAGE);

File: src/utils/lombok/javac/java6/CommentCollectingScanner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 The Project Lombok Authors.
+ * Copyright (C) 2011-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,7 +28,6 @@
 import lombok.javac.CommentInfo.StartConnection;
 
 import com.sun.tools.javac.parser.Scanner;
-import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 

File: src/utils/lombok/javac/java7/CommentCollectingScanner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 The Project Lombok Authors.
+ * Copyright (C) 2011-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -28,7 +28,6 @@
 import lombok.javac.CommentInfo.StartConnection;
 
 import com.sun.tools.javac.parser.Scanner;
-import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -409,7 +409,7 @@ private void removeFromDeferredDiagnostics(int startPos, int endPos) {
 			// Possibly integrate these 2 code paths.
 			if (JAVAC7_DEFERRED_DIAGNOSTICS != null) {
 				ListBuffer<?> deferredDiagnostics = (ListBuffer<?>) JAVAC7_DEFERRED_DIAGNOSTICS.get(log);
-				ListBuffer<Object> newDeferredDiagnostics = ListBuffer.lb();
+				ListBuffer<Object> newDeferredDiagnostics = new ListBuffer<Object>();
 				for (Object diag : deferredDiagnostics) {
 					if (!(diag instanceof JCDiagnostic)) {
 						newDeferredDiagnostics.add(diag);

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -534,7 +534,7 @@ private static JCExpression typeToJCTree0(Type type, JavacAST ast, boolean allow
 	
 	private static JCExpression genericsToJCTreeNodes(List<Type> generics, JavacAST ast, JCExpression rawTypeNode) throws TypeNotConvertibleException {
 		if (generics != null && !generics.isEmpty()) {
-			ListBuffer<JCExpression> args = ListBuffer.lb();
+			ListBuffer<JCExpression> args = new ListBuffer<JCExpression>();
 			for (Type t : generics) args.append(typeToJCTree(t, ast, true, false));
 			return ast.getTreeMaker().TypeApply(rawTypeNode, args.toList());
 		}

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -96,8 +96,8 @@ public class HandleCleanup extends JavacAnnotationHandler<Cleanup> {
 		}
 		
 		boolean seenDeclaration = false;
-		ListBuffer<JCStatement> newStatements = ListBuffer.lb();
-		ListBuffer<JCStatement> tryBlock = ListBuffer.lb();
+		ListBuffer<JCStatement> newStatements = new ListBuffer<JCStatement>();
+		ListBuffer<JCStatement> tryBlock = new ListBuffer<JCStatement>();
 		for (JCStatement statement : statements) {
 			if (!seenDeclaration) {
 				if (statement == decl) seenDeclaration = true;

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -204,7 +204,7 @@ static JCMethodDecl createSetter(long access, JavacNode field, JavacTreeMaker tr
 		JCExpression fieldRef = createFieldAccessor(treeMaker, field, FieldAccess.ALWAYS_FIELD);
 		JCAssign assign = treeMaker.Assign(fieldRef, treeMaker.Ident(fieldDecl.name));
 		
-		ListBuffer<JCStatement> statements = ListBuffer.lb();
+		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
 		List<JCAnnotation> nonNulls = findAnnotations(field, TransformationsUtil.NON_NULL_PATTERN);
 		List<JCAnnotation> nullables = findAnnotations(field, TransformationsUtil.NULLABLE_PATTERN);
 		

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -129,7 +129,7 @@ public void generateToString(JavacNode typeNode, JavacNode source, List<String>
 			return;
 		}
 		
-		ListBuffer<JavacNode> nodesForToString = ListBuffer.lb();
+		ListBuffer<JavacNode> nodesForToString = new ListBuffer<JavacNode>();
 		if (includes != null) {
 			for (JavacNode child : typeNode.down()) {
 				if (child.getKind() != Kind.FIELD) continue;

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -207,7 +207,7 @@ private JCMethodDecl createWither(long access, JavacNode field, JavacTreeMaker m
 		
 		JCVariableDecl fieldDecl = (JCVariableDecl) field.get();
 		
-		ListBuffer<JCStatement> statements = ListBuffer.lb();
+		ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();
 		List<JCAnnotation> nonNulls = findAnnotations(field, TransformationsUtil.NON_NULL_PATTERN);
 		List<JCAnnotation> nullables = findAnnotations(field, TransformationsUtil.NULLABLE_PATTERN);
 		
@@ -219,7 +219,7 @@ private JCMethodDecl createWither(long access, JavacNode field, JavacTreeMaker m
 		JCExpression selfType = cloneSelfType(field);
 		if (selfType == null) return null;
 		
-		ListBuffer<JCExpression> args = ListBuffer.lb();
+		ListBuffer<JCExpression> args = new ListBuffer<JCExpression>();
 		for (JavacNode child : field.up().down()) {
 			if (child.getKind() != Kind.FIELD) continue;
 			JCVariableDecl childDecl = (JCVariableDecl) child.get();

File: src/utils/lombok/javac/java6/CommentCollectingScanner.java
Patch:
@@ -28,11 +28,12 @@
 import lombok.javac.CommentInfo.StartConnection;
 
 import com.sun.tools.javac.parser.Scanner;
+import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 
 public class CommentCollectingScanner extends Scanner {
-	private final ListBuffer<CommentInfo> comments = ListBuffer.lb();
+	private final ListBuffer<CommentInfo> comments = new ListBuffer<CommentInfo>();
 	private int endComment = 0;
 	
 	public CommentCollectingScanner(CommentCollectingScannerFactory factory, CharBuffer charBuffer) {

File: src/utils/lombok/javac/java7/CommentCollectingScanner.java
Patch:
@@ -28,11 +28,12 @@
 import lombok.javac.CommentInfo.StartConnection;
 
 import com.sun.tools.javac.parser.Scanner;
+import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 
 public class CommentCollectingScanner extends Scanner {
-	private final ListBuffer<CommentInfo> comments = ListBuffer.lb();
+	private final ListBuffer<CommentInfo> comments = new ListBuffer<CommentInfo>();
 	private int endComment = 0;
 	
 	public CommentCollectingScanner(CommentCollectingScannerFactory factory, CharBuffer charBuffer) {

File: src/utils/lombok/javac/java8/CommentCollectingTokenizer.java
Patch:
@@ -12,12 +12,13 @@
 import com.sun.tools.javac.parser.Tokens.Token;
 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 import com.sun.tools.javac.parser.UnicodeReader;
+import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 
 class CommentCollectingTokenizer extends JavaTokenizer {
 	private int prevEndPosition = 0;
-	private final ListBuffer<CommentInfo> comments = ListBuffer.lb();
+	private final ListBuffer<CommentInfo> comments = new ListBuffer<CommentInfo>();
 	private int endComment = 0;
 
 	CommentCollectingTokenizer(ScannerFactory fac, char[] buf, int inputLength) {

File: src/core/lombok/javac/apt/Processor.java
Patch:
@@ -210,6 +210,7 @@ private void stopJavacProcessingEnvironmentFromClosingOurClassloader() {
 			Field f = JavacProcessingEnvironment.class.getDeclaredField("processorClassLoader");
 			f.setAccessible(true);
 			ClassLoader unwrapped = (ClassLoader) f.get(processingEnv);
+			if (unwrapped == null) return;
 			ClassLoader wrapped = new WrappingClassLoader(unwrapped);
 			f.set(processingEnv, wrapped);
 		} catch (NoSuchFieldException e) {

File: src/core/lombok/core/debug/DebugSnapshotStore.java
Patch:
@@ -82,7 +82,7 @@ public String print(CompilationUnitDeclaration owner, String message, Object...
 		}
 		
 		try {
-			File logFile = new File(System.getProperty("user.home", "."), String.format("lombok164-%d.err", System.currentTimeMillis()));
+			File logFile = new File(System.getProperty("user.home", "."), String.format("lombokdss-%d.err", System.currentTimeMillis()));
 			OutputStream stream = new FileOutputStream(logFile);
 			try {
 				stream.write(out.toString().getBytes("UTF-8"));

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -84,7 +84,7 @@ public static Class<?> loadDelombok(List<String> args) throws Exception {
 			return null;
 		}
 		
-		@SuppressWarnings("resource") final JarFile toolsJarFile = new JarFile(toolsJar);
+		@SuppressWarnings({"resource", "all"}) final JarFile toolsJarFile = new JarFile(toolsJar);
 		
 		ClassLoader loader = new ClassLoader() {
 			private Class<?> loadStreamAsClass(String name, boolean resolve, InputStream in) throws ClassNotFoundException {

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -112,7 +112,7 @@ public void transformCode(Collection<CompilerMessage> messages, StringWriter res
 		CategorizedProblem[] problems = compilationResult.getAllProblems();
 		
 		if (problems != null) for (CategorizedProblem p : problems) {
-			messages.add(new CompilerMessage(p.getSourceLineNumber(), p.getSourceStart(), p.getSourceStart(), p.isError(), p.getMessage()));
+			messages.add(new CompilerMessage(p.getSourceLineNumber(), p.getSourceStart(), p.isError(), p.getMessage()));
 		}
 		
 		CompilationUnitDeclaration cud = compilationUnit_.get();

File: src/core/lombok/eclipse/handlers/HandleBuilder.java
Patch:
@@ -113,7 +113,7 @@ public class HandleBuilder extends EclipseAnnotationHandler<Builder> {
 				// non-final fields final, but @Value's handler hasn't done this yet, so we have to do this math ourselves.
 				// Value will only skip making a field final if it has an explicit @NonFinal annotation, so we check for that.
 				if (fd.initialization != null && valuePresent && !hasAnnotation(NonFinal.class, fieldNode)) continue;
-				namesOfParameters.add(fd.name);
+				namesOfParameters.add(removePrefixFromField(fieldNode));
 				typesOfParameters.add(fd.type);
 				fields.add(fieldNode);
 			}

File: src/core/lombok/javac/handlers/HandleAccessors.java
Patch:
@@ -28,11 +28,13 @@
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.experimental.Accessors;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 
 @ProviderFor(JavacAnnotationHandler.class)
+@HandlerPriority(65536)
 public class HandleAccessors extends JavacAnnotationHandler<Accessors> {
 	@Override public void handle(AnnotationValues<Accessors> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		// Accessors itself is handled by HandleGetter/Setter; this is just to ensure that the annotation is removed

File: src/core/lombok/javac/handlers/HandleBuilder.java
Patch:
@@ -106,7 +106,7 @@ public class HandleBuilder extends JavacAnnotationHandler<Builder> {
 				// non-final fields final, but @Value's handler hasn't done this yet, so we have to do this math ourselves.
 				// Value will only skip making a field final if it has an explicit @NonFinal annotation, so we check for that.
 				if (fd.init != null && valuePresent && !hasAnnotation(NonFinal.class, fieldNode)) continue;
-				namesOfParameters.add(fd.name);
+				namesOfParameters.add(removePrefixFromField(fieldNode));
 				typesOfParameters.add(fd.vartype);
 				allFields.append(fieldNode);
 			}

File: src/core/lombok/core/Version.java
Patch:
@@ -29,7 +29,7 @@ public class Version {
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
 	private static final String VERSION = "0.12.1";
-	private static final String RELEASE_NAME = "Angry Butterfy";
+	private static final String RELEASE_NAME = "Angry Butterfly";
 	
 	private Version() {
 		//Prevent instantiation

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -221,7 +221,7 @@ public void generateMethods(EclipseNode typeNode, EclipseNode errorNode, List<St
 				// The user code couldn't possibly (barring really weird subclassing shenanigans) be in a shippable state anyway; the implementations of these 3 methods are
 				// all inter-related and should be written by the same entity.
 				String msg = String.format("Not generating %s: One of equals, hashCode, and canEqual exists. " +
-						"You should either write all of these are none of these (in the latter case, lombok generates them).",
+						"You should either write all of these or none of these (in the latter case, lombok generates them).",
 						equalsExists == MemberExistsResult.NOT_EXISTS && hashCodeExists == MemberExistsResult.NOT_EXISTS ? "equals and hashCode" :
 						equalsExists == MemberExistsResult.NOT_EXISTS ? "equals" : "hashCode");
 				errorNode.addWarning(msg);

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -195,7 +195,7 @@ public void generateMethods(JavacNode typeNode, JavacNode source, List<String> e
 				// The user code couldn't possibly (barring really weird subclassing shenanigans) be in a shippable state anyway; the implementations of these 3 methods are
 				// all inter-related and should be written by the same entity.
 				String msg = String.format("Not generating %s: One of equals, hashCode, and canEqual exists. " +
-						"You should either write all of these are none of these (in the latter case, lombok generates them).",
+						"You should either write all of these or none of these (in the latter case, lombok generates them).",
 						equalsExists == MemberExistsResult.NOT_EXISTS && hashCodeExists == MemberExistsResult.NOT_EXISTS ? "equals and hashCode" :
 						equalsExists == MemberExistsResult.NOT_EXISTS ? "equals" : "hashCode");
 				source.addWarning(msg);

File: src/core/lombok/core/Version.java
Patch:
@@ -29,7 +29,7 @@ public class Version {
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
 	private static final String VERSION = "0.12.1";
-	private static final String RELEASE_NAME = "Angry Butterfy";
+	private static final String RELEASE_NAME = "Angry Butterfly";
 	
 	private Version() {
 		//Prevent instantiation

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -221,7 +221,7 @@ public void generateMethods(EclipseNode typeNode, EclipseNode errorNode, List<St
 				// The user code couldn't possibly (barring really weird subclassing shenanigans) be in a shippable state anyway; the implementations of these 3 methods are
 				// all inter-related and should be written by the same entity.
 				String msg = String.format("Not generating %s: One of equals, hashCode, and canEqual exists. " +
-						"You should either write all of these are none of these (in the latter case, lombok generates them).",
+						"You should either write all of these or none of these (in the latter case, lombok generates them).",
 						equalsExists == MemberExistsResult.NOT_EXISTS && hashCodeExists == MemberExistsResult.NOT_EXISTS ? "equals and hashCode" :
 						equalsExists == MemberExistsResult.NOT_EXISTS ? "equals" : "hashCode");
 				errorNode.addWarning(msg);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -97,6 +97,7 @@ private static class MarkingScanner extends TreeScanner {
 		}
 		
 		@Override public void scan(JCTree tree) {
+			if (tree == null) return;
 			setGeneratedBy(tree, source);
 			super.scan(tree);
 		}
@@ -134,10 +135,12 @@ public static <T extends JCTree> T recursiveSetGeneratedBy(T node, JCTree source
 	}
 	
 	public static <T extends JCTree> T setGeneratedBy(T node, JCTree source) {
+		if (node == null) return null;
 		synchronized (generatedNodes) {
 			if (source == null) generatedNodes.remove(node);
 			else generatedNodes.put(node, new WeakReference<JCTree>(source));
 		}
+		if (source != null) node.pos = source.pos;
 		return node;
 	}
 	

File: src/core/lombok/Data.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2012 The Project Lombok Authors.
+ * Copyright (C) 2009-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -39,7 +39,7 @@
  * @see RequiredArgsConstructor
  * @see ToString
  * @see EqualsAndHashCode
- * @see lombok.experimental.Value
+ * @see lombok.Value
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.SOURCE)

File: src/core/lombok/core/PostCompiler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -33,6 +33,7 @@ public final class PostCompiler {
 	private static List<PostCompilerTransformation> transformations;
 	
 	public static byte[] applyTransformations(byte[] original, String fileName, DiagnosticsReceiver diagnostics) {
+		if (System.getProperty("lombok.disablePostCompiler", null) != null) return original;
 		init(diagnostics);
 		byte[] previous = original;
 		for (PostCompilerTransformation transformation : transformations) {
@@ -59,6 +60,7 @@ private static synchronized void init(DiagnosticsReceiver diagnostics) {
 	}
 
 	public static OutputStream wrapOutputStream(final OutputStream originalStream, final String fileName, final DiagnosticsReceiver diagnostics) throws IOException {
+		if (System.getProperty("lombok.disablePostCompiler", null) != null) return originalStream;
 		return new ByteArrayOutputStream() {
 			@Override public void close() throws IOException {
 				// no need to call super

File: src/core/lombok/core/Version.java
Patch:
@@ -28,8 +28,8 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "0.11.7";
-	private static final String RELEASE_NAME = "Dashing Kakapo";
+	private static final String VERSION = "0.12.1";
+	private static final String RELEASE_NAME = "Angry Butterfy";
 	
 	private Version() {
 		//Prevent instantiation

File: src/core/lombok/eclipse/EclipseAnnotationHandler.java
Patch:
@@ -29,7 +29,7 @@
  * 
  * You MUST replace 'T' with a specific annotation type, such as:
  * 
- * {@code public class HandleGetter implements EclipseAnnotationHandler<Getter>}
+ * {@code public class HandleGetter extends EclipseAnnotationHandler<Getter>}
  * 
  * Because this generics parameter is inspected to figure out which class you're interested in.
  * 

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -144,7 +144,7 @@ public static void transform(Parser parser, CompilationUnitDeclaration ast) {
 			try {
 				String message = "Lombok can't parse this source: " + t.toString();
 				
-				EclipseAST.addProblemToCompilationResult(ast, false, message, 0, 0);
+				EclipseAST.addProblemToCompilationResult(ast.getFileName(), ast.compilationResult, false, message, 0, 0);
 				t.printStackTrace();
 			} catch (Throwable t2) {
 				try {

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -28,6 +28,7 @@
 import lombok.core.AnnotationValues;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.eclipse.handlers.HandleConstructor.SkipIfConstructorExists;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -64,6 +65,6 @@ public void handle(AnnotationValues<Data> annotation, Annotation ast, EclipseNod
 		new HandleSetter().generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
 		new HandleEqualsAndHashCode().generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		new HandleToString().generateToStringForType(typeNode, annotationNode);
-		new HandleConstructor().generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), true, Collections.<Annotation>emptyList(), ast);
+		new HandleConstructor().generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), SkipIfConstructorExists.YES, Collections.<Annotation>emptyList(), ast);
 	}
 }

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -159,7 +159,7 @@ private void createSetterForField(
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		TypeReference fieldType = copyType(field.type, source);
-		boolean isBoolean = nameEquals(fieldType.getTypeName(), "boolean") && fieldType.dimensions() == 0;
+		boolean isBoolean = isBoolean(fieldType);
 		String setterName = toSetterName(fieldNode, isBoolean);
 		boolean shouldReturnThis = shouldReturnThis(fieldNode);
 		
@@ -192,7 +192,7 @@ private void createSetterForField(
 		injectMethod(fieldNode.up(), method);
 	}
 	
-	private MethodDeclaration createSetter(TypeDeclaration parent, EclipseNode fieldNode, String name, boolean shouldReturnThis, int modifier, ASTNode source, List<Annotation> onMethod, List<Annotation> onParam) {
+	static MethodDeclaration createSetter(TypeDeclaration parent, EclipseNode fieldNode, String name, boolean shouldReturnThis, int modifier, ASTNode source, List<Annotation> onMethod, List<Annotation> onParam) {
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		int pS = source.sourceStart, pE = source.sourceEnd;
 		long p = (long)pS << 32 | pE;

File: src/core/lombok/eclipse/handlers/HandleValue.java
Patch:
@@ -30,8 +30,9 @@
 import lombok.core.HandlerPriority;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
+import lombok.eclipse.handlers.HandleConstructor.SkipIfConstructorExists;
 import lombok.experimental.NonFinal;
-import lombok.experimental.Value;
+import lombok.Value;
 
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -78,6 +79,6 @@ public void handle(AnnotationValues<Value> annotation, Annotation ast, EclipseNo
 		new HandleGetter().generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
 		new HandleEqualsAndHashCode().generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		new HandleToString().generateToStringForType(typeNode, annotationNode);
-		new HandleConstructor().generateAllArgsConstructor(typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), true, Collections.<Annotation>emptyList(), ast);
+		new HandleConstructor().generateAllArgsConstructor(typeNode, AccessLevel.PUBLIC, ann.staticConstructor(), SkipIfConstructorExists.YES, Collections.<Annotation>emptyList(), ast);
 	}
 }

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -160,7 +160,7 @@ private void createWitherForField(
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		TypeReference fieldType = copyType(field.type, source);
-		boolean isBoolean = nameEquals(fieldType.getTypeName(), "boolean") && fieldType.dimensions() == 0;
+		boolean isBoolean = isBoolean(fieldType);
 		String witherName = toWitherName(fieldNode, isBoolean);
 		
 		if (witherName == null) {

File: src/core/lombok/experimental/Value.java
Patch:
@@ -39,9 +39,11 @@
  * @see lombok.ToString
  * @see lombok.EqualsAndHashCode
  * @see lombok.Data
+ * @deprecated {@link lombok.Value} has been promoted to the main package, so use that one instead.
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.SOURCE)
+@Deprecated
 public @interface Value {
 	/**
 	 * If you specify a static constructor name, then the generated constructor will be private, and

File: src/core/lombok/extern/apachecommons/CommonsLog.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -52,6 +52,7 @@
  * @see org.apache.commons.logging.LogFactory#getLog(java.lang.Class) org.apache.commons.logging.LogFactory.getLog(Class target)
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  */

File: src/core/lombok/extern/java/Log.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,6 +51,7 @@
  * @see java.util.logging.Logger#getLogger(java.lang.String) java.util.logging.Logger.getLogger(String name)
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  */

File: src/core/lombok/extern/log4j/Log4j.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -50,6 +50,7 @@
  * 
  * @see org.apache.log4j.Logger org.apache.log4j.Logger
  * @see org.apache.log4j.Logger#getLogger(java.lang.Class) org.apache.log4j.Logger.getLogger(Class target)
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j

File: src/core/lombok/extern/slf4j/Slf4j.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,6 +51,7 @@
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/slf4j/XSlf4j.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 The Project Lombok Authors.
+ * Copyright (C) 2012-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,6 +51,7 @@
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  */
 @Retention(RetentionPolicy.SOURCE)

File: src/core/lombok/javac/FindTypeVarScanner.java
Patch:
@@ -88,7 +88,7 @@ private Void subVisit(TypeMirror mirror) {
 	@Override public Void visitTypeVariable(TypeVariable t, Void p) {
 		Name name = null;
 		try {
-			name = ((Type)t).tsym.name;
+			name = ((Type) t).tsym.name;
 		} catch (NullPointerException e) {}
 		if (name != null) typeVariables.add(name.toString());
 		subVisit(t.getLowerBound());

File: src/core/lombok/javac/Javac6BasedLombokOptions.java
Patch:
@@ -26,7 +26,6 @@
 import com.sun.tools.javac.util.Options;
 
 public class Javac6BasedLombokOptions extends LombokOptions {
-	
 	public static Javac6BasedLombokOptions replaceWithDelombokOptions(Context context) {
 		Options options = Options.instance(context);
 		context.put(optionsKey, (Options)null);
@@ -38,7 +37,7 @@ public static Javac6BasedLombokOptions replaceWithDelombokOptions(Context contex
 	private Javac6BasedLombokOptions(Context context) {
 		super(context);
 	}
-
+	
 	@Override public void putJavacOption(String optionName, String value) {
 		put(OptionName.valueOf(optionName), value);
 	}

File: src/core/lombok/javac/JavacAnnotationHandler.java
Patch:
@@ -33,7 +33,7 @@
  * 
  * You MUST replace 'T' with a specific annotation type, such as:
  * 
- * {@code public class HandleGetter implements JavacAnnotationHandler<Getter>}
+ * {@code public class HandleGetter extends JavacAnnotationHandler<Getter>}
  * 
  * Because this generics parameter is inspected to figure out which class you're interested in.
  * 

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -433,8 +433,8 @@ private static JCExpression typeToJCTree0(Type type, JavacAST ast, boolean allow
 		if (symbol.name.length() == 0) {
 			// Anonymous inner class
 			if (type instanceof ClassType) {
-				List<Type> ifaces = ((ClassType)type).interfaces_field;
-				Type supertype = ((ClassType)type).supertype_field;
+				List<Type> ifaces = ((ClassType) type).interfaces_field;
+				Type supertype = ((ClassType) type).supertype_field;
 				if (ifaces != null && ifaces.length() == 1) {
 					return typeToJCTree(ifaces.get(0), ast, allowCompound, allowVoid);
 				}

File: src/core/lombok/javac/LombokOptions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -49,6 +49,6 @@ public static boolean shouldDeleteLombokAnnotations(Context context) {
 	protected LombokOptions(Context context) {
 		super(context);
 	}
-
+	
 	public abstract void putJavacOption(String optionName, String value);
 }

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.mangosdk.spi.ProviderFor;
 
-import com.sun.tools.javac.code.TypeTags;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCAssign;

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -27,6 +27,7 @@
 import lombok.core.AnnotationValues;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
+import lombok.javac.handlers.HandleConstructor.SkipIfConstructorExists;
 
 import org.mangosdk.spi.ProviderFor;
 
@@ -50,7 +51,7 @@ public class HandleData extends JavacAnnotationHandler<Data> {
 		String staticConstructorName = annotation.getInstance().staticConstructor();
 		
 		// TODO move this to the end OR move it to the top in eclipse.
-		new HandleConstructor().generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, true, annotationNode);
+		new HandleConstructor().generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, SkipIfConstructorExists.YES, annotationNode);
 		new HandleGetter().generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
 		new HandleSetter().generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
 		new HandleEqualsAndHashCode().generateEqualsAndHashCodeForType(typeNode, annotationNode);

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -267,7 +267,7 @@ private static void patchDomAstReparseIssues(ScriptManager sm) {
 				.build());
 		
 	}
-
+	
 	private static void patchPostCompileHookEclipse(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.wrapMethodCall()
 				.target(new MethodTarget("org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder", "writeClassFileContents"))

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -329,7 +329,7 @@ public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Ex
 		return newSimpleNames;
 	}
 	
-	public static byte[] runPostCompiler(byte[] bytes, String fileName) {
+	public static byte[] runPostCompiler(byte[] bytes,  String fileName) {
 		byte[] transformed = PostCompiler.applyTransformations(bytes, fileName, DiagnosticsReceiver.CONSOLE);
 		return transformed == null ? bytes : transformed;
 	}

File: src/installer/lombok/installer/eclipse/STSFinder.java
Patch:
@@ -57,7 +57,7 @@ public class STSFinder extends EclipseFinder {
 	}
 	
 	@Override protected List<String> getSourceDirsOnWindows() {
-		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
+		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files (x86)", "\\Program Files\\springsource", "\\Program Files (x86)\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
 	}
 	
 	@Override protected List<String> getSourceDirsOnMac() {

File: src/utils/lombok/javac/CommentInfo.java
Patch:
@@ -66,7 +66,7 @@ public CommentInfo(int prevEndPos, int pos, int endPos, String content, StartCon
 	}
 	
 	public boolean isJavadoc() {
-		return content.startsWith("/**");
+		return content.startsWith("/**") && content.length() > 4;
 	}
 	
 	@Override

File: src/utils/lombok/javac/java6/CommentCollectingParserFactory.java
Patch:
@@ -25,7 +25,7 @@ protected CommentCollectingParserFactory(Context context, Map<JCCompilationUnit,
 	}
 	
 	@Override public Parser newParser(Lexer S, boolean keepDocComments, boolean genEndPos) {
-		Object x = new CommentCollectingParser(this, S, keepDocComments, commentsMap);
+		Object x = new CommentCollectingParser(this, S, true, commentsMap);
 		return (Parser) x;
 		// CCP is based on a stub which extends nothing, but at runtime the stub is replaced with either
 		//javac6's EndPosParser which extends Parser, or javac7's EndPosParser which implements Parser.

File: src/utils/lombok/javac/java6/CommentCollectingScanner.java
Patch:
@@ -27,12 +27,10 @@
 import lombok.javac.CommentInfo.EndConnection;
 import lombok.javac.CommentInfo.StartConnection;
 
-import com.sun.tools.javac.parser.Scanner;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.ListBuffer;
 
-
-public class CommentCollectingScanner extends Scanner {
+public class CommentCollectingScanner extends DocCommentScanner {
 	private final ListBuffer<CommentInfo> comments = ListBuffer.lb();
 	private int endComment = 0;
 	
@@ -56,6 +54,7 @@ protected void processComment(CommentStyle style) {
 
 		CommentInfo comment = new CommentInfo(prevEndPos, pos, endPos, content, start, end);
 		comments.append(comment);
+		super.processComment(style);
 	}
 	
 	private EndConnection determineEndConnection(int pos) {

File: src/utils/lombok/javac/java7/CommentCollectingParserFactory.java
Patch:
@@ -30,8 +30,8 @@ protected CommentCollectingParserFactory(Context context, Map<JCCompilationUnit,
 	
 	public Parser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap) {
 		ScannerFactory scannerFactory = ScannerFactory.instance(context);
-		Lexer lexer = scannerFactory.newScanner(input, keepDocComments);
-		Object x = new CommentCollectingParser(this, lexer, keepDocComments, keepLineMap, commentsMap);
+		Lexer lexer = scannerFactory.newScanner(input, true);
+		Object x = new CommentCollectingParser(this, lexer, true, keepLineMap, commentsMap);
 		return (Parser) x;
 		// CCP is based on a stub which extends nothing, but at runtime the stub is replaced with either
 		//javac6's EndPosParser which extends Parser, or javac7's EndPosParser which implements Parser.

File: test/transform/resource/after-delombok/DelegateWithDeprecated.java
Patch:
@@ -3,7 +3,9 @@ class DelegateWithDeprecated {
 	private interface Bar {
 		@Deprecated
 		void deprecatedAnnotation();
-		/** @deprecated */
+		/**
+		 * @deprecated
+		 */
 		void deprecatedComment();
 		void notDeprecated();
 	}

File: test/transform/resource/after-delombok/GetterDeprecated.java
Patch:
@@ -10,6 +10,9 @@ class GetterDeprecated {
 	public int getAnnotation() {
 		return this.annotation;
 	}
+	/**
+	 * @deprecated
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public int getJavadoc() {

File: test/transform/resource/after-delombok/LoggerCommons.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerCommons {
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommons.class);
 }
-
 class LoggerCommonsWithImport {
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommonsWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerJul.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerJul {
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJul.class.getName());
 }
-
 class LoggerJulWithImport {
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJulWithImport.class.getName());
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerLog4j.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerLog4j {
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4j.class);
 }
-
 class LoggerLog4jWithImport {
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4jWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerSlf4j.java
Patch:
@@ -1,11 +1,9 @@
 class LoggerSlf4j {
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4j.class);
 }
-
 class LoggerSlf4jWithImport {
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jWithImport.class);
 }
-
 class LoggerSlf4jOuter {
 	static class Inner {
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);

File: test/transform/resource/after-delombok/LoggerXSlf4j.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerXSlf4j {
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4j.class);
 }
-
 class LoggerXSlf4jWithImport {
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4jWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/SetterDeprecated.java
Patch:
@@ -10,6 +10,9 @@ class SetterDeprecated {
 	public void setAnnotation(final int annotation) {
 		this.annotation = annotation;
 	}
+	/**
+	 * @deprecated
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public void setJavadoc(final int javadoc) {

File: test/transform/resource/after-delombok/SetterOnClass.java
Patch:
@@ -53,7 +53,9 @@ public void setCouldBeNull(final String couldBeNull) {
 	}
 	@java.lang.SuppressWarnings("all")
 	public void setNonNull(@lombok.NonNull final String nonNull) {
-		if (nonNull == null) throw new java.lang.NullPointerException("nonNull");
+		if (nonNull == null) {
+			throw new java.lang.NullPointerException("nonNull");
+		}
 		this.nonNull = nonNull;
 	}
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/WitherDeprecated.java
Patch:
@@ -12,6 +12,9 @@ class WitherDeprecated {
 	public WitherDeprecated withAnnotation(final int annotation) {
 		return this.annotation == annotation ? this : new WitherDeprecated(annotation, this.javadoc);
 	}
+	/**
+	 * @deprecated
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public WitherDeprecated withJavadoc(final int javadoc) {

File: test/transform/resource/after-delombok/WitherOnClass.java
Patch:
@@ -35,7 +35,9 @@ public WitherOnClass3 withCouldBeNull(final String couldBeNull) {
 	}
 	@java.lang.SuppressWarnings("all")
 	public WitherOnClass3 withNonNull(@lombok.NonNull final String nonNull) {
-		if (nonNull == null) throw new java.lang.NullPointerException("nonNull");
+		if (nonNull == null) {
+			throw new java.lang.NullPointerException("nonNull");
+		}
 		return this.nonNull == nonNull ? this : new WitherOnClass3(this.couldBeNull, nonNull);
 	}
 }

File: test/transform/resource/after-ecj/SetterOnClass.java
Patch:
@@ -63,7 +63,9 @@
   }
   public @java.lang.SuppressWarnings("all") void setNonNull(final @lombok.NonNull String nonNull) {
     if ((nonNull == null))
-        throw new java.lang.NullPointerException("nonNull");
+        {
+          throw new java.lang.NullPointerException("nonNull");
+        }
     this.nonNull = nonNull;
   }
 }

File: test/transform/resource/after-ecj/ValuePlain.java
Patch:
@@ -1,5 +1,5 @@
-import lombok.experimental.Value;
-final @lombok.experimental.Value class Value1 {
+import lombok.Value;
+final @lombok.Value class Value1 {
   private final int x;
   private final String name;
   public @java.lang.SuppressWarnings("all") int getX() {

File: test/transform/resource/after-ecj/WitherOnClass.java
Patch:
@@ -33,7 +33,9 @@
   }
   public @java.lang.SuppressWarnings("all") WitherOnClass3 withNonNull(final @lombok.NonNull String nonNull) {
     if ((nonNull == null))
-        throw new java.lang.NullPointerException("nonNull");
+        {
+          throw new java.lang.NullPointerException("nonNull");
+        }
     return ((this.nonNull == nonNull) ? this : new WitherOnClass3(this.couldBeNull, nonNull));
   }
 }

File: test/transform/resource/before/DelegateWithDeprecated.java
Patch:
@@ -6,7 +6,9 @@ class DelegateWithDeprecated {
 	private interface Bar {
 		@Deprecated
 		void deprecatedAnnotation();
-		/** @deprecated */
+		/**
+		 * @deprecated
+		 */
 		void deprecatedComment();
 		void notDeprecated();
 	}

File: test/transform/resource/before/ValuePlain.java
Patch:
@@ -1,5 +1,5 @@
-import lombok.experimental.Value;
-@lombok.experimental.Value class Value1 {
+import lombok.Value;
+@lombok.Value class Value1 {
 	final int x;
 	String name;
 }

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -187,7 +187,7 @@ private void createGetterForField(AccessLevel level,
 		}
 		
 		TypeReference fieldType = copyType(field.type, source);
-		boolean isBoolean = nameEquals(fieldType.getTypeName(), "boolean") && fieldType.dimensions() == 0;
+		boolean isBoolean = isBoolean(fieldType);
 		String getterName = toGetterName(fieldNode, isBoolean);
 		
 		if (getterName == null) {

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -159,7 +159,7 @@ private void createSetterForField(
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		TypeReference fieldType = copyType(field.type, source);
-		boolean isBoolean = nameEquals(fieldType.getTypeName(), "boolean") && fieldType.dimensions() == 0;
+		boolean isBoolean = isBoolean(fieldType);
 		String setterName = toSetterName(fieldNode, isBoolean);
 		boolean shouldReturnThis = shouldReturnThis(fieldNode);
 		

File: src/core/lombok/eclipse/handlers/HandleWither.java
Patch:
@@ -160,7 +160,7 @@ private void createWitherForField(
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
 		TypeReference fieldType = copyType(field.type, source);
-		boolean isBoolean = nameEquals(fieldType.getTypeName(), "boolean") && fieldType.dimensions() == 0;
+		boolean isBoolean = isBoolean(fieldType);
 		String witherName = toWitherName(fieldNode, isBoolean);
 		
 		if (witherName == null) {

File: test/transform/resource/after-delombok/BuilderSimple.java
Patch:
@@ -5,7 +5,7 @@ class BuilderSimple<T> {
 	private List<T> also;
 	private int $butNotMe;
 	@java.lang.SuppressWarnings("all")
-	private BuilderSimple(final int yes, final List<T> also) {
+	BuilderSimple(final int yes, final List<T> also) {
 		this.yes = yes;
 		this.also = also;
 	}

File: test/transform/resource/after-ecj/BuilderSimple.java
Patch:
@@ -25,7 +25,7 @@
   private final int yes;
   private List<T> also;
   private int $butNotMe;
-  private @java.lang.SuppressWarnings("all") BuilderSimple(final int yes, final List<T> also) {
+  @java.lang.SuppressWarnings("all") BuilderSimple(final int yes, final List<T> also) {
     super();
     this.yes = yes;
     this.also = also;

File: test/transform/resource/after-delombok/WitherDeprecated.java
Patch:
@@ -12,6 +12,9 @@ class WitherDeprecated {
 	public WitherDeprecated withAnnotation(final int annotation) {
 		return this.annotation == annotation ? this : new WitherDeprecated(annotation, this.javadoc);
 	}
+	/**
+	 * @deprecated
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public WitherDeprecated withJavadoc(final int javadoc) {

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -1165,7 +1165,7 @@ private static JCExpression cloneType0(TreeMaker maker, JCTree in) {
 		return (JCExpression) in;
 	}
 	
-	private static final Pattern SECTION_FINDER = Pattern.compile("^\\s*\\**\\s*[-*][-*]+\\s*(GETTER|SETTER)\\s*[-*][-*]+\\s*\\**\\s*$", Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);
+	private static final Pattern SECTION_FINDER = Pattern.compile("^\\s*\\**\\s*[-*][-*]+\\s*([GS]ETTER)\\s*[-*][-*]+\\s*\\**\\s*$", Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);
 	
 	private static String stripLinesWithTagFromJavadoc(String javadoc, String regexpFragment) {
 		Pattern p = Pattern.compile("^\\s*\\**\\s*" + regexpFragment + "\\s*\\**\\s*$", Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);
@@ -1201,7 +1201,7 @@ private static String[] splitJavadocOnSectionIfPresent(String javadoc, String se
 	public static enum CopyJavadoc {
 		VERBATIM, GETTER {
 			@Override public String[] split(String javadoc) {
-				// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new one and we strip that from the original.
+				// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc and we strip that from the original.
 				String[] out = splitJavadocOnSectionIfPresent(javadoc, "GETTER");
 				if (out != null) return out;
 				// failing that, create a copy, but strip @return from the original and @param from the copy.

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -54,6 +54,7 @@ protected CompilerOptions ecjCompilerOptions() {
 		options.complianceLevel = Eclipse.getLatestEcjCompilerVersionConstant();
 		options.sourceLevel = Eclipse.getLatestEcjCompilerVersionConstant();
 		options.targetJDK = Eclipse.getLatestEcjCompilerVersionConstant();
+		options.docCommentSupport = false;
 		options.parseLiteralExpressionsAsConstants = true;
 		options.inlineJsrBytecode = true;
 		options.reportUnusedDeclaredThrownExceptionExemptExceptionAndThrowable = false;
@@ -64,7 +65,6 @@ protected CompilerOptions ecjCompilerOptions() {
 		options.reportUnusedParameterWhenOverridingConcrete = false;
 		options.reportDeadCodeInTrivialIfStatement = false;
 		options.generateClassFiles = false;
-		options.docCommentSupport = false;
 		Map<String, String> warnings = new HashMap<String, String>();
 		warnings.put(CompilerOptions.OPTION_ReportUnusedLocal, "ignore");
 		warnings.put(CompilerOptions.OPTION_ReportUnusedLabel, "ignore");

File: test/transform/resource/after-delombok/DelegateWithDeprecated.java
Patch:
@@ -3,7 +3,9 @@ class DelegateWithDeprecated {
 	private interface Bar {
 		@Deprecated
 		void deprecatedAnnotation();
-		/** @deprecated */
+		/**
+		 * @deprecated
+		 */
 		void deprecatedComment();
 		void notDeprecated();
 	}

File: test/transform/resource/after-delombok/GetterDeprecated.java
Patch:
@@ -10,6 +10,9 @@ class GetterDeprecated {
 	public int getAnnotation() {
 		return this.annotation;
 	}
+	/**
+	 * @deprecated
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public int getJavadoc() {

File: test/transform/resource/after-delombok/SetterDeprecated.java
Patch:
@@ -10,6 +10,9 @@ class SetterDeprecated {
 	public void setAnnotation(final int annotation) {
 		this.annotation = annotation;
 	}
+	/**
+	 * @deprecated
+	 */
 	@java.lang.Deprecated
 	@java.lang.SuppressWarnings("all")
 	public void setJavadoc(final int javadoc) {

File: test/transform/resource/before/DelegateWithDeprecated.java
Patch:
@@ -6,7 +6,9 @@ class DelegateWithDeprecated {
 	private interface Bar {
 		@Deprecated
 		void deprecatedAnnotation();
-		/** @deprecated */
+		/**
+		 * @deprecated
+		 */
 		void deprecatedComment();
 		void notDeprecated();
 	}

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -84,7 +84,6 @@ public static Class<?> loadDelombok(List<String> args) throws Exception {
 			return null;
 		}
 		
-		@SuppressWarnings("resource")
 		final JarFile toolsJarFile = new JarFile(toolsJar);
 		
 		ClassLoader loader = new ClassLoader() {

File: test/transform/resource/after-delombok/SetterOnClass.java
Patch:
@@ -53,7 +53,9 @@ public void setCouldBeNull(final String couldBeNull) {
 	}
 	@java.lang.SuppressWarnings("all")
 	public void setNonNull(@lombok.NonNull final String nonNull) {
-		if (nonNull == null) throw new java.lang.NullPointerException("nonNull");
+		if (nonNull == null) {
+			throw new java.lang.NullPointerException("nonNull");
+		}
 		this.nonNull = nonNull;
 	}
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/WitherOnClass.java
Patch:
@@ -35,7 +35,9 @@ public WitherOnClass3 withCouldBeNull(final String couldBeNull) {
 	}
 	@java.lang.SuppressWarnings("all")
 	public WitherOnClass3 withNonNull(@lombok.NonNull final String nonNull) {
-		if (nonNull == null) throw new java.lang.NullPointerException("nonNull");
+		if (nonNull == null) {
+			throw new java.lang.NullPointerException("nonNull");
+		}
 		return this.nonNull == nonNull ? this : new WitherOnClass3(this.couldBeNull, nonNull);
 	}
 }

File: test/transform/resource/after-ecj/SetterOnClass.java
Patch:
@@ -63,7 +63,9 @@
   }
   public @java.lang.SuppressWarnings("all") void setNonNull(final @lombok.NonNull String nonNull) {
     if ((nonNull == null))
-        throw new java.lang.NullPointerException("nonNull");
+        {
+          throw new java.lang.NullPointerException("nonNull");
+        }
     this.nonNull = nonNull;
   }
 }

File: test/transform/resource/after-ecj/WitherOnClass.java
Patch:
@@ -33,7 +33,9 @@
   }
   public @java.lang.SuppressWarnings("all") WitherOnClass3 withNonNull(final @lombok.NonNull String nonNull) {
     if ((nonNull == null))
-        throw new java.lang.NullPointerException("nonNull");
+        {
+          throw new java.lang.NullPointerException("nonNull");
+        }
     return ((this.nonNull == nonNull) ? this : new WitherOnClass3(this.couldBeNull, nonNull));
   }
 }

File: src/core/lombok/bytecode/PreventNullAnalysisRemover.java
Patch:
@@ -44,7 +44,7 @@ public class PreventNullAnalysisRemover implements PostCompilerTransformation {
 		byte[] fixedByteCode = fixJSRInlining(original);
 		
 		ClassReader reader = new ClassReader(fixedByteCode);
-		ClassWriter writer = new FixedClassWriter(reader, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);
+		ClassWriter writer = new FixedClassWriter(reader, 0);
 		
 		final AtomicBoolean changesMade = new AtomicBoolean();
 		

File: src/core/lombok/core/PostCompiler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -33,6 +33,7 @@ public final class PostCompiler {
 	private static List<PostCompilerTransformation> transformations;
 	
 	public static byte[] applyTransformations(byte[] original, String fileName, DiagnosticsReceiver diagnostics) {
+		if (System.getProperty("lombok.disablePostCompiler", null) != null) return original;
 		init(diagnostics);
 		byte[] previous = original;
 		for (PostCompilerTransformation transformation : transformations) {
@@ -59,6 +60,7 @@ private static synchronized void init(DiagnosticsReceiver diagnostics) {
 	}
 
 	public static OutputStream wrapOutputStream(final OutputStream originalStream, final String fileName, final DiagnosticsReceiver diagnostics) throws IOException {
+		if (System.getProperty("lombok.disablePostCompiler", null) != null) return originalStream;
 		return new ByteArrayOutputStream() {
 			@Override public void close() throws IOException {
 				// no need to call super

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -144,7 +144,7 @@ public static void transform(Parser parser, CompilationUnitDeclaration ast) {
 			try {
 				String message = "Lombok can't parse this source: " + t.toString();
 				
-				EclipseAST.addProblemToCompilationResult(ast, false, message, 0, 0);
+				EclipseAST.addProblemToCompilationResult(ast.getFileName(), ast.compilationResult, false, message, 0, 0);
 				t.printStackTrace();
 			} catch (Throwable t2) {
 				try {

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -142,7 +142,7 @@ public static void error(CompilationUnitDeclaration cud, String message, String
 		} catch (NoClassDefFoundError e) {  //standalone ecj does not jave Platform, ILog, IStatus, and friends.
 			new TerminalLogger().error(message, bundleName, error);
 		}
-		if (cud != null) EclipseAST.addProblemToCompilationResult(cud, false, message + " - See error log.", 0, 0);
+		if (cud != null) EclipseAST.addProblemToCompilationResult(cud.getFileName(), cud.compilationResult, false, message + " - See error log.", 0, 0);
 	}
 	
 	/**

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -267,7 +267,7 @@ private static void patchDomAstReparseIssues(ScriptManager sm) {
 				.build());
 		
 	}
-
+	
 	private static void patchPostCompileHookEclipse(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.wrapMethodCall()
 				.target(new MethodTarget("org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder", "writeClassFileContents"))

File: src/core/lombok/bytecode/PreventNullAnalysisRemover.java
Patch:
@@ -61,6 +61,7 @@ class PreventNullAnalysisVisitor extends MethodVisitor {
 				if (hit && !"(Ljava/lang/Object;)Ljava/lang/Object;".equals(desc)) hit = false;
 				if (hit) {
 					changesMade.set(true);
+					if (System.getProperty("lombok.debugAsmOnly", null) != null) super.visitMethodInsn(opcode, owner, name, desc); // DEBUG for issue 470!
 				} else {
 					super.visitMethodInsn(opcode, owner, name, desc);
 				}

File: src/core/lombok/bytecode/PreventNullAnalysisRemover.java
Patch:
@@ -48,8 +48,8 @@ public class PreventNullAnalysisRemover implements PostCompilerTransformation {
 		
 		final AtomicBoolean changesMade = new AtomicBoolean();
 		
-		class PreventNullanalysisVisitor extends MethodVisitor {
-			PreventNullanalysisVisitor(MethodVisitor mv) {
+		class PreventNullAnalysisVisitor extends MethodVisitor {
+			PreventNullAnalysisVisitor(MethodVisitor mv) {
 				super(Opcodes.ASM4, mv);
 			}
 			
@@ -69,7 +69,7 @@ class PreventNullanalysisVisitor extends MethodVisitor {
 		
 		reader.accept(new ClassVisitor(Opcodes.ASM4, writer) {
 			@Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
-				return new PreventNullanalysisVisitor(super.visitMethod(access, name, desc, signature, exceptions));
+				return new PreventNullAnalysisVisitor(super.visitMethod(access, name, desc, signature, exceptions));
 			}
 		}, 0);
 		return changesMade.get() ? writer.toByteArray() : null;

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -1281,9 +1281,9 @@ private String assignOpName(JCExpression tree) {
     private int isOwnPrec(JCExpression tree) {
     	try {
 	    	if (JavaCompiler.version().startsWith("1.8")) {
-				return (Integer)TreeInfo.class.getMethod("opPrec", Class.forName("com.sun.tools.javac.code.TypeTag")).invoke(tree, getTag(tree));
+				return (Integer)TreeInfo.class.getMethod("opPrec", Class.forName("com.sun.tools.javac.code.TypeTag")).invoke(null, getTag(tree));
 			} else {
-				return (Integer)TreeInfo.class.getMethod("opPrec", Integer.TYPE).invoke(tree, getTag(tree));
+				return (Integer)TreeInfo.class.getMethod("opPrec", Integer.TYPE).invoke(null, getTag(tree));
 			}
 		} catch (NoSuchMethodException e) {
 			throw new RuntimeException(e);

File: src/core/lombok/eclipse/EclipseAnnotationHandler.java
Patch:
@@ -29,7 +29,7 @@
  * 
  * You MUST replace 'T' with a specific annotation type, such as:
  * 
- * {@code public class HandleGetter implements EclipseAnnotationHandler<Getter>}
+ * {@code public class HandleGetter extends EclipseAnnotationHandler<Getter>}
  * 
  * Because this generics parameter is inspected to figure out which class you're interested in.
  * 

File: src/core/lombok/extern/apachecommons/CommonsLog.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -52,6 +52,7 @@
  * @see org.apache.commons.logging.LogFactory#getLog(java.lang.Class) org.apache.commons.logging.LogFactory.getLog(Class target)
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  */

File: src/core/lombok/extern/java/Log.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,6 +51,7 @@
  * @see java.util.logging.Logger#getLogger(java.lang.String) java.util.logging.Logger.getLogger(String name)
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  * @see lombok.extern.slf4j.XSlf4j &#64;XSlf4j
  */

File: src/core/lombok/extern/log4j/Log4j.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -50,6 +50,7 @@
  * 
  * @see org.apache.log4j.Logger org.apache.log4j.Logger
  * @see org.apache.log4j.Logger#getLogger(java.lang.Class) org.apache.log4j.Logger.getLogger(Class target)
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j

File: src/core/lombok/extern/slf4j/Slf4j.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 The Project Lombok Authors.
+ * Copyright (C) 2010-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,6 +51,7 @@
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)

File: src/core/lombok/extern/slf4j/XSlf4j.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 The Project Lombok Authors.
+ * Copyright (C) 2012-2013 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -51,6 +51,7 @@
  * @see lombok.extern.apachecommons.CommonsLog &#64;CommonsLog
  * @see lombok.extern.java.Log &#64;Log
  * @see lombok.extern.log4j.Log4j &#64;Log4j
+ * @see lombok.extern.log4j.Log4j2 &#64;Log4j2
  * @see lombok.extern.slf4j.Slf4j &#64;Slf4j
  */
 @Retention(RetentionPolicy.SOURCE)

File: src/core/lombok/javac/JavacAnnotationHandler.java
Patch:
@@ -33,7 +33,7 @@
  * 
  * You MUST replace 'T' with a specific annotation type, such as:
  * 
- * {@code public class HandleGetter implements JavacAnnotationHandler<Getter>}
+ * {@code public class HandleGetter extends JavacAnnotationHandler<Getter>}
  * 
  * Because this generics parameter is inspected to figure out which class you're interested in.
  * 

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -305,6 +305,7 @@ public static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? ex
 			return;
 		}
 		
+		parentNode.getAst().setChanged();
 		deleteImportFromCompilationUnit(annotation, annotationType.getName());
 	}
 	

File: src/installer/lombok/installer/eclipse/STSFinder.java
Patch:
@@ -57,7 +57,7 @@ public class STSFinder extends EclipseFinder {
 	}
 	
 	@Override protected List<String> getSourceDirsOnWindows() {
-		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
+		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files (x86)", "\\Program Files\\springsource", "\\Program Files (x86)\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
 	}
 	
 	@Override protected List<String> getSourceDirsOnMac() {

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -72,7 +72,7 @@ public boolean compareFile(DirectoryRunner.TestParams params, File file) throws
 		StringReader r = new StringReader(expectedFile);
 		BufferedReader br = new BufferedReader(r);
 		String firstLine = br.readLine();
-		if (firstLine != null && firstLine.startsWith("//ignore")) return false;
+		if (firstLine != null && (firstLine.startsWith("//ignore") || params.shouldIgnoreBasedOnVersion(firstLine))) return false;
 		
 		compare(
 				file.getName(),

File: test/transform/resource/after-delombok/LoggerCommons.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerCommons {
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommons.class);
 }
-
 class LoggerCommonsWithImport {
 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LoggerCommonsWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerJul.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerJul {
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJul.class.getName());
 }
-
 class LoggerJulWithImport {
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJulWithImport.class.getName());
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerLog4j.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerLog4j {
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4j.class);
 }
-
 class LoggerLog4jWithImport {
 	private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LoggerLog4jWithImport.class);
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerSlf4j.java
Patch:
@@ -1,11 +1,9 @@
 class LoggerSlf4j {
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4j.class);
 }
-
 class LoggerSlf4jWithImport {
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jWithImport.class);
 }
-
 class LoggerSlf4jOuter {
 	static class Inner {
 		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Inner.class);

File: test/transform/resource/after-delombok/LoggerXSlf4j.java
Patch:
@@ -1,7 +1,6 @@
 class LoggerXSlf4j {
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4j.class);
 }
-
 class LoggerXSlf4jWithImport {
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LoggerXSlf4jWithImport.class);
 }
\ No newline at end of file

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -26,6 +26,7 @@
 import lombok.Cleanup;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.javac.Javac;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 
@@ -120,7 +121,7 @@ public class HandleCleanup extends JavacAnnotationHandler<Cleanup> {
 				maker.Apply(List.<JCExpression>nil(), cleanupMethod, List.<JCExpression>nil())));
 		
 		JCMethodInvocation preventNullAnalysis = preventNullAnalysis(maker, annotationNode, maker.Ident(decl.name));
-		JCBinary isNull = maker.Binary(CTC_NOT_EQUAL, preventNullAnalysis, maker.Literal(CTC_BOT, null));
+		JCBinary isNull = Javac.makeBinary(maker, CTC_NOT_EQUAL, preventNullAnalysis, Javac.makeLiteral(maker, CTC_BOT, null));
 		
 		JCIf ifNotNullCleanup = maker.If(isNull, maker.Block(0, cleanupCall), null);
 		
@@ -141,7 +142,7 @@ public class HandleCleanup extends JavacAnnotationHandler<Cleanup> {
 	
 	private JCMethodInvocation preventNullAnalysis(TreeMaker maker, JavacNode node, JCExpression expression) {
 		JCMethodInvocation singletonList = maker.Apply(List.<JCExpression>nil(), chainDotsString(node, "java.util.Collections.singletonList"), List.of(expression));
-		JCMethodInvocation cleanedExpr = maker.Apply(List.<JCExpression>nil(), maker.Select(singletonList, node.toName("get")) , List.<JCExpression>of(maker.Literal(TypeTags.INT, 0)));
+		JCMethodInvocation cleanedExpr = maker.Apply(List.<JCExpression>nil(), maker.Select(singletonList, node.toName("get")) , List.<JCExpression>of(Javac.makeLiteral(maker, CTC_INT, 0)));
 		return cleanedExpr;
 	}
 	

File: src/core/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -26,6 +26,7 @@
 import lombok.Synchronized;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.javac.Javac;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.handlers.JavacHandlerUtil.MemberExistsResult;
@@ -87,7 +88,7 @@ public class HandleSynchronized extends JavacAnnotationHandler<Synchronized> {
 			JCExpression objectType = chainDots(methodNode, ast.pos, "java", "lang", "Object");
 			//We use 'new Object[0];' because unlike 'new Object();', empty arrays *ARE* serializable!
 			JCNewArray newObjectArray = maker.NewArray(chainDots(methodNode, ast.pos, "java", "lang", "Object"),
-					List.<JCExpression>of(maker.Literal(CTC_INT, 0)), null);
+					List.<JCExpression>of(Javac.makeLiteral(maker, CTC_INT, 0)), null);
 			JCVariableDecl fieldDecl = recursiveSetGeneratedBy(maker.VarDef(
 					maker.Modifiers(Flags.PRIVATE | Flags.FINAL | (isStatic ? Flags.STATIC : 0)),
 					methodNode.toName(lockName), objectType, newObjectArray), ast);

File: src/core/lombok/javac/handlers/HandleWither.java
Patch:
@@ -31,6 +31,7 @@
 import lombok.core.AnnotationValues;
 import lombok.core.TransformationsUtil;
 import lombok.experimental.Wither;
+import lombok.javac.Javac;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.handlers.JavacHandlerUtil.FieldAccess;
@@ -239,7 +240,7 @@ private JCMethodDecl createWither(long access, JavacNode field, TreeMaker treeMa
 		}
 		
 		JCNewClass newClass = maker.NewClass(null, List.<JCExpression>nil(), selfType, args.toList(), null);
-		JCExpression identityCheck = maker.Binary(CTC_EQUAL, createFieldAccessor(maker, field, FieldAccess.ALWAYS_FIELD), maker.Ident(fieldDecl.name));
+		JCExpression identityCheck = Javac.makeBinary(maker, CTC_EQUAL, createFieldAccessor(maker, field, FieldAccess.ALWAYS_FIELD), maker.Ident(fieldDecl.name));
 		JCConditional conditional = maker.Conditional(identityCheck, maker.Ident(field.toName("this")), newClass);
 		JCReturn returnStatement = maker.Return(conditional);
 		

File: src/core/lombok/eclipse/EclipseAnnotationHandler.java
Patch:
@@ -29,7 +29,7 @@
  * 
  * You MUST replace 'T' with a specific annotation type, such as:
  * 
- * {@code public class HandleGetter implements EclipseAnnotationHandler<Getter>}
+ * {@code public class HandleGetter extends EclipseAnnotationHandler<Getter>}
  * 
  * Because this generics parameter is inspected to figure out which class you're interested in.
  * 

File: src/core/lombok/javac/JavacAnnotationHandler.java
Patch:
@@ -33,7 +33,7 @@
  * 
  * You MUST replace 'T' with a specific annotation type, such as:
  * 
- * {@code public class HandleGetter implements JavacAnnotationHandler<Getter>}
+ * {@code public class HandleGetter extends JavacAnnotationHandler<Getter>}
  * 
  * Because this generics parameter is inspected to figure out which class you're interested in.
  * 

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -305,6 +305,7 @@ public static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? ex
 			return;
 		}
 		
+		parentNode.getAst().setChanged();
 		deleteImportFromCompilationUnit(annotation, annotationType.getName());
 	}
 	

File: src/installer/lombok/installer/eclipse/STSFinder.java
Patch:
@@ -57,7 +57,7 @@ public class STSFinder extends EclipseFinder {
 	}
 	
 	@Override protected List<String> getSourceDirsOnWindows() {
-		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
+		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files (x86)", "\\Program Files\\springsource", "\\Program Files (x86)\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
 	}
 	
 	@Override protected List<String> getSourceDirsOnMac() {

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -1245,7 +1245,7 @@ public void visitUnary(JCUnary tree) {
             int ownprec = TreeInfo.opPrec(getTag(tree));
             String opname = operatorName(getTag(tree));
             open(prec, ownprec);
-            if (getTag(tree) <= JCTree.PREDEC) {
+            if (getTag(tree) <= Javac.getCtcInt(JCTree.class, "PREDEC")) {
                 print(opname);
                 printExpr(tree.arg, ownprec);
             } else {

File: src/stubs/com/sun/tools/javac/parser/EndPosParser.java
Patch:
@@ -1,3 +1,6 @@
+/*
+ * These are stub versions of various bits of javac-internal API (for various different versions of javac). Lombok is compiled against these.
+ */
 package com.sun.tools.javac.parser;
 
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;

File: src/stubs/com/sun/tools/javac/parser/Lexer.java
Patch:
@@ -1,3 +1,6 @@
+/*
+ * These are stub versions of various bits of javac-internal API (for various different versions of javac). Lombok is compiled against these.
+ */
 package com.sun.tools.javac.parser;
 
 public interface Lexer {

File: src/stubs/com/sun/tools/javac/parser/ParserFactory.java
Patch:
@@ -1,3 +1,6 @@
+/*
+ * These are stub versions of various bits of javac-internal API (for various different versions of javac). Lombok is compiled against these.
+ */
 package com.sun.tools.javac.parser;
 
 import com.sun.tools.javac.util.Context;

File: test/transform/src/lombok/transform/TestLombokFilesIdempotent.java
Patch:
@@ -28,7 +28,7 @@
 import org.junit.runner.RunWith;
 
 @RunWith(DirectoryRunner.class)
-public class TestLombokFilesIdempotent implements DirectoryRunner.TestParams {
+public class TestLombokFilesIdempotent extends DirectoryRunner.TestParams {
 	@Override
 	public File getBeforeDirectory() {
 		return getAfterDirectory();

File: test/transform/src/lombok/transform/TestWithDelombok.java
Patch:
@@ -28,7 +28,7 @@
 import org.junit.runner.RunWith;
 
 @RunWith(DirectoryRunner.class)
-public class TestWithDelombok implements DirectoryRunner.TestParams {
+public class TestWithDelombok extends DirectoryRunner.TestParams {
 	@Override
 	public DirectoryRunner.Compiler getCompiler() {
 		return DirectoryRunner.Compiler.DELOMBOK;

File: test/transform/src/lombok/transform/TestWithEcj.java
Patch:
@@ -32,7 +32,7 @@
 // When running inside eclipse's junit tester, you don't actually need to run 'ant dist' after updating code, though.
 
 @RunWith(DirectoryRunner.class)
-public class TestWithEcj implements DirectoryRunner.TestParams {
+public class TestWithEcj extends DirectoryRunner.TestParams {
 	@Override
 	public DirectoryRunner.Compiler getCompiler() {
 		return DirectoryRunner.Compiler.ECJ;

File: src/core/lombok/Getter.java
Patch:
@@ -55,7 +55,7 @@
 @Retention(RetentionPolicy.SOURCE)
 public @interface Getter {
 	/**
-	 * If you want your setter to be non-public, you can specify an alternate access level here.
+	 * If you want your getter to be non-public, you can specify an alternate access level here.
 	 */
 	lombok.AccessLevel value() default lombok.AccessLevel.PUBLIC;
 	

File: src/core/lombok/experimental/Value.java
Patch:
@@ -41,7 +41,7 @@
  * In other words, {@code @Value} is a shorthand for:<br />
  * {@code final @Getter @Wither @FieldDefaults(makeFinal=true,level=AccessLevel.PRIVATE) @EqualsAndHashCode @ToString @AllArgsConstructor}.
  * <p>
- * If any method to be generated already exists (in name and parameter c ount - the return type or parameter types are not relevant), then
+ * If any method to be generated already exists (in name and parameter count - the return type or parameter types are not relevant), then
  * that method will not be generated by the Value annotation.
  * <p>
  * The generated constructor will have 1 parameter for each field. The generated toString will print all fields,

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -103,8 +103,7 @@ public void run(RunNotifier notifier) {
 				if (!runTest(entry.getKey())) {
 					notifier.fireTestIgnored(testDescription);
 				}
-			}
-			catch (Throwable t) {
+			} catch (Throwable t) {
 				notifier.fireTestFailure(new Failure(testDescription, t));
 			}
 			notifier.fireTestFinished(testDescription);

File: test/core/src/lombok/RunTestsViaEcj.java
Patch:
@@ -25,6 +25,7 @@
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -84,7 +85,7 @@ protected IErrorHandlingPolicy ecjErrorHandlingPolicy() {
 	}
 	
 	@Override
-	public void transformCode(final StringBuilder messages, StringWriter result, File file) throws Throwable {
+	public void transformCode(Collection<CompilerMessage> messages, StringWriter result, File file) throws Throwable {
 		final AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();
 		final AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();
 		ICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {
@@ -109,7 +110,7 @@ public void transformCode(final StringBuilder messages, StringWriter result, Fil
 		CategorizedProblem[] problems = compilationResult.getAllProblems();
 		
 		if (problems != null) for (CategorizedProblem p : problems) {
-			messages.append(String.format("%d %s %s\n", p.getSourceLineNumber(), p.isError() ? "error" : p.isWarning() ? "warning" : "unknown", p.getMessage()));
+			messages.add(new CompilerMessage(p.getSourceLineNumber(), p.getSourceStart(), p.isError(), p.getMessage()));
 		}
 		
 		CompilationUnitDeclaration cud = compilationUnit_.get();

File: test/core/src/lombok/RunTestsViaDelombok.java
Patch:
@@ -55,6 +55,8 @@ public void transformCode(final StringBuilder messages, StringWriter result, fin
 		
 		delombok.addFile(file.getAbsoluteFile().getParentFile(), file.getName());
 		delombok.setSourcepath(file.getAbsoluteFile().getParent());
+		String bcp = System.getProperty("delombok.bootclasspath");
+		if (bcp != null) delombok.setBootclasspath(bcp);
 		delombok.setWriter(result);
 		Locale originalLocale = Locale.getDefault();
 		try {

File: src/core/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -158,8 +158,7 @@ private static void loadAnnotationHandlers(HandlerLibrary lib) {
 		try {
 			for (EclipseAnnotationHandler<?> handler : SpiLoadUtil.findServices(EclipseAnnotationHandler.class, EclipseAnnotationHandler.class.getClassLoader())) {
 				try {
-					Class<? extends Annotation> annotationClass =
-						SpiLoadUtil.findAnnotationClass(handler.getClass(), EclipseAnnotationHandler.class);
+					Class<? extends Annotation> annotationClass = handler.getAnnotationHandledByThisHandler();
 					AnnotationHandlerContainer<?> container = new AnnotationHandlerContainer(handler, annotationClass);
 					String annotationClassName = container.annotationClass.getName().replace("$", ".");
 					if (lib.annotationHandlers.put(annotationClassName, container) != null) {

File: src/core/lombok/javac/HandlerLibrary.java
Patch:
@@ -165,8 +165,7 @@ public static HandlerLibrary load(Messager messager) {
 	private static void loadAnnotationHandlers(HandlerLibrary lib) throws IOException {
 		//No, that seemingly superfluous reference to JavacAnnotationHandler's classloader is not in fact superfluous!
 		for (JavacAnnotationHandler handler : SpiLoadUtil.findServices(JavacAnnotationHandler.class, JavacAnnotationHandler.class.getClassLoader())) {
-			Class<? extends Annotation> annotationClass =
-				SpiLoadUtil.findAnnotationClass(handler.getClass(), JavacAnnotationHandler.class);
+			Class<? extends Annotation> annotationClass = handler.getAnnotationHandledByThisHandler();
 			AnnotationHandlerContainer<?> container = new AnnotationHandlerContainer(handler, annotationClass);
 			String annotationClassName = container.annotationClass.getName().replace("$", ".");
 			if (lib.annotationHandlers.put(annotationClassName, container) != null) {

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -89,6 +89,8 @@ public void setFieldDefaultsForField(EclipseNode fieldNode, ASTNode pos, AccessL
 				field.modifiers |= ClassFileConstants.AccFinal;
 			}
 		}
+		
+		fieldNode.rebuild();
 	}
 	
 	public void handle(AnnotationValues<FieldDefaults> annotation, Annotation ast, EclipseNode annotationNode) {

File: src/core/lombok/javac/handlers/HandleExtensionMethod.java
Patch:
@@ -99,7 +99,7 @@ private List<Extension> getExtensions(final JavacNode typeNode, final List<Objec
 			if (providerType == null) continue;
 			if ((providerType.tsym.flags() & (INTERFACE | ANNOTATION)) != 0) continue;
 			
-			extensions.add(getExtension(typeNode, (ClassType) providerType));	
+			extensions.add(getExtension(typeNode, (ClassType) providerType));
 		}
 		return extensions;
 	}

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -91,6 +91,8 @@ public void setFieldDefaultsForField(JavacNode fieldNode, DiagnosticPosition pos
 				field.mods.flags |= Flags.FINAL;
 			}
 		}
+		
+		fieldNode.rebuild();
 	}
 	
 	@Override public void handle(AnnotationValues<FieldDefaults> annotation, JCAnnotation ast, JavacNode annotationNode) {

File: test/transform/resource/after-delombok/FieldDefaultsNoop.java
Patch:
@@ -0,0 +1,2 @@
+class FieldDefaultsNoop {
+}
\ No newline at end of file

File: test/transform/resource/before/FieldDefaultsNoop.java
Patch:
@@ -0,0 +1,3 @@
+@lombok.experimental.FieldDefaults
+class FieldDefaultsNoop {
+}
\ No newline at end of file

File: src/core/lombok/javac/apt/LombokFileObjects.java
Patch:
@@ -63,7 +63,7 @@ enum Compiler {
 			@Override public Method getDecoderMethod() {
 				synchronized (decoderIsSet) {
 					if (decoderIsSet.get()) return decoderMethod;
-					decoderMethod = getDecoderMethod("com.sun.tools.javac.util.BaseFileObject");
+					decoderMethod = getDecoderMethod("com.sun.tools.javac.file.BaseFileObject");
 					decoderIsSet.set(true);
 					return decoderMethod;
 				}
@@ -92,6 +92,7 @@ private LombokFileObjects() {}
 	static Compiler getCompiler(JavaFileManager jfm) {
 		String jfmClassName = jfm != null ? jfm.getClass().getName() : "null";
 		if (jfmClassName.equals("com.sun.tools.javac.util.DefaultFileManager")) return Compiler.JAVAC6;
+		if (jfmClassName.equals("com.sun.tools.javac.util.JavacFileManager")) return Compiler.JAVAC6;
 		if (jfmClassName.equals("com.sun.tools.javac.file.JavacFileManager")) return Compiler.JAVAC7;
 		try {
 			if (Class.forName("com.sun.tools.javac.file.BaseFileObject") == null) throw new NullPointerException();

File: src/core/lombok/eclipse/handlers/HandleFieldDefaults.java
Patch:
@@ -25,6 +25,7 @@
 import lombok.AccessLevel;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseNode;
 import lombok.experimental.FieldDefaults;
@@ -42,6 +43,7 @@
  * Handles the {@code lombok.FieldDefaults} annotation for eclipse.
  */
 @ProviderFor(EclipseAnnotationHandler.class)
+@HandlerPriority(-512) //-2^9; to ensure @Setter and such pick up on messing with the fields' 'final' state, run earlier.
 public class HandleFieldDefaults extends EclipseAnnotationHandler<FieldDefaults> {
 	public boolean generateFieldDefaultsForType(EclipseNode typeNode, EclipseNode pos, AccessLevel level, boolean makeFinal, boolean checkForTypeLevelFieldDefaults) {
 		if (checkForTypeLevelFieldDefaults) {

File: src/core/lombok/eclipse/handlers/HandlePrintAST.java
Patch:
@@ -30,6 +30,7 @@
 
 import lombok.Lombok;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.core.PrintAST;
 import lombok.eclipse.DeferUntilPostDiet;
 import lombok.eclipse.EclipseASTVisitor;
@@ -41,6 +42,7 @@
  */
 @ProviderFor(EclipseAnnotationHandler.class)
 @DeferUntilPostDiet
+@HandlerPriority(536870912) // 2^29; this handler is customarily run at the very end.
 public class HandlePrintAST extends EclipseAnnotationHandler<PrintAST> {
 	public void handle(AnnotationValues<PrintAST> annotation, Annotation ast, EclipseNode annotationNode) {
 		PrintStream stream = System.out;

File: src/core/lombok/eclipse/handlers/HandleVal.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.eclipse.handlers;
 
 import lombok.val;
+import lombok.core.HandlerPriority;
 import lombok.eclipse.DeferUntilPostDiet;
 import lombok.eclipse.EclipseASTAdapter;
 import lombok.eclipse.EclipseASTVisitor;
@@ -38,6 +39,7 @@
  */
 @ProviderFor(EclipseASTVisitor.class)
 @DeferUntilPostDiet
+@HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
 public class HandleVal extends EclipseASTAdapter {
 	@Override public void visitLocal(EclipseNode localNode, LocalDeclaration local) {
 		if (!EclipseHandlerUtil.typeMatches(val.class, localNode, local.type)) return;

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -43,11 +43,11 @@
 import lombok.Delegate;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.javac.FindTypeVarScanner;
 import lombok.javac.JavacAnnotationHandler;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacResolution;
-import lombok.javac.ResolutionBased;
 import lombok.javac.JavacResolution.TypeNotConvertibleException;
 
 import org.mangosdk.spi.ProviderFor;
@@ -75,7 +75,7 @@
 import com.sun.tools.javac.util.Name;
 
 @ProviderFor(JavacAnnotationHandler.class)
-@ResolutionBased
+@HandlerPriority(65536) //2^16; to make sure that we also delegate generated methods.
 public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	private static final List<String> METHODS_IN_OBJECT = Collections.unmodifiableList(Arrays.asList(
 			"hashCode()",

File: src/core/lombok/javac/handlers/HandleFieldDefaults.java
Patch:
@@ -25,6 +25,7 @@
 import lombok.AccessLevel;
 import lombok.core.AST.Kind;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.experimental.FieldDefaults;
 import lombok.experimental.NonFinal;
 import lombok.experimental.PackagePrivate;
@@ -43,6 +44,7 @@
  * Handles the {@code lombok.FieldDefaults} annotation for eclipse.
  */
 @ProviderFor(JavacAnnotationHandler.class)
+@HandlerPriority(-512) //-2^9; to ensure @Setter and such pick up on messing with the fields' 'final' state, run earlier.
 public class HandleFieldDefaults extends JavacAnnotationHandler<FieldDefaults> {
 	public boolean generateFieldDefaultsForType(JavacNode typeNode, JavacNode errorNode, AccessLevel level, boolean makeFinal, boolean checkForTypeLevelFieldDefaults) {
 		if (checkForTypeLevelFieldDefaults) {

File: src/core/lombok/javac/handlers/HandleLog.java
Patch:
@@ -44,7 +44,6 @@
 import com.sun.tools.javac.util.Name;
 
 public class HandleLog {
-	
 	private HandleLog() {
 		throw new UnsupportedOperationException();
 	}

File: src/core/lombok/javac/handlers/HandlePrintAST.java
Patch:
@@ -31,6 +31,7 @@
 
 import lombok.Lombok;
 import lombok.core.AnnotationValues;
+import lombok.core.HandlerPriority;
 import lombok.core.PrintAST;
 import lombok.javac.JavacASTVisitor;
 import lombok.javac.JavacAnnotationHandler;
@@ -40,6 +41,7 @@
  * Handles the {@code lombok.core.PrintAST} annotation for javac.
  */
 @ProviderFor(JavacAnnotationHandler.class)
+@HandlerPriority(536870912) // 2^29; this handler is customarily run at the very end.
 public class HandlePrintAST extends JavacAnnotationHandler<PrintAST> {
 	@Override public void handle(AnnotationValues<PrintAST> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		PrintStream stream = System.out;

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -24,11 +24,11 @@
 import static lombok.javac.handlers.JavacHandlerUtil.*;
 
 import lombok.val;
+import lombok.core.HandlerPriority;
 import lombok.javac.JavacASTAdapter;
 import lombok.javac.JavacASTVisitor;
 import lombok.javac.JavacNode;
 import lombok.javac.JavacResolution;
-import lombok.javac.ResolutionBased;
 
 import org.mangosdk.spi.ProviderFor;
 
@@ -44,7 +44,7 @@
 import com.sun.tools.javac.util.List;
 
 @ProviderFor(JavacASTVisitor.class)
-@ResolutionBased
+@HandlerPriority(65536) // 2^16; resolution needs to work, so if the RHS expression is i.e. a call to a generated getter, we have to run after that getter has been generated.
 public class HandleVal extends JavacASTAdapter {
 	@Override public void visitLocal(JavacNode localNode, JCVariableDecl local) {
 		if (local.vartype == null || (!local.vartype.toString().equals("val") && !local.vartype.toString().equals("lombok.val"))) return;

File: src/utils/lombok/eclipse/Eclipse.java
Patch:
@@ -122,7 +122,7 @@ public static Annotation[] findAnnotations(FieldDeclaration field, Pattern nameP
 		if (field.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;
 		for (Annotation annotation : field.annotations) {
 			TypeReference typeRef = annotation.type;
-			if (typeRef != null && typeRef.getTypeName()!= null) {
+			if (typeRef != null && typeRef.getTypeName() != null) {
 				char[][] typeName = typeRef.getTypeName();
 				String suspect = new String(typeName[typeName.length - 1]);
 				if (namePattern.matcher(suspect).matches()) {

File: src/core/lombok/Data.java
Patch:
@@ -30,7 +30,7 @@
  * Generates getters for all fields, a useful toString method, and hashCode and equals implementations that check
  * all non-transient fields. Will also generate setters for all non-final fields, as well as a constructor.
  * <p>
- * If any method to be generated already exists (in name - the return type or parameters are not relevant), then
+ * If any method to be generated already exists (in name and parameter count - the return type or parameter types are not relevant), then
  * that method will not be generated by the Data annotation.
  * <p>
  * The generated constructor will have 1 parameter for each final field. The generated toString will print all fields,

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -250,6 +250,7 @@ public static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<
 	 * Only does this if the DeleteLombokAnnotations class is in the context.
 	 */
 	public static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {
+		if (inNetbeansEditor(annotation)) return;
 		if (!annotation.shouldDeleteLombokAnnotations()) return;
 		JavacNode parentNode = annotation.directUp();
 		switch (parentNode.getKind()) {
@@ -280,6 +281,7 @@ public static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? ex
 	}
 	
 	public static void deleteImportFromCompilationUnit(JavacNode node, String name) {
+		if (inNetbeansEditor(node)) return;
 		if (!node.shouldDeleteLombokAnnotations()) return;
 		ListBuffer<JCTree> newDefs = ListBuffer.lb();
 		

File: test/transform/resource/after-ecj/ClassNamedAfterGetter.java
Patch:
@@ -1,9 +1,9 @@
 class GetFoo {
   private @lombok.Getter int foo;
-  public @java.lang.SuppressWarnings("all") int getFoo() {
-    return this.foo;
-  }
   GetFoo() {
     super();
   }
+  public @java.lang.SuppressWarnings("all") int getFoo() {
+    return this.foo;
+  }
 }

File: test/transform/resource/after-ecj/CommentsInterspersed.java
Patch:
@@ -2,11 +2,11 @@
 public class CommentsInterspersed {
   private int x;
   private @Getter String test = "foo";
-  public @java.lang.SuppressWarnings("all") String getTest() {
-    return this.test;
-  }
   public CommentsInterspersed() {
     super();
   }
   public native void gwtTest();
+  public @java.lang.SuppressWarnings("all") String getTest() {
+    return this.test;
+  }
 }

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -1,8 +1,5 @@
 @lombok.Data @lombok.ToString(doNotUseGetters = true) class DataExtended {
   int x;
-  public @java.lang.SuppressWarnings("all") DataExtended() {
-    super();
-  }
   public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;
   }
@@ -30,6 +27,9 @@
     result = ((result * PRIME) + this.getX());
     return result;
   }
+  public @java.lang.SuppressWarnings("all") DataExtended() {
+    super();
+  }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
     return (("DataExtended(x=" + this.x) + ")");
   }

File: test/transform/resource/after-ecj/GetterAccessLevel.java
Patch:
@@ -10,6 +10,9 @@ class GetterAccessLevel {
   @lombok.Getter(lombok.AccessLevel.PROTECTED) String protectedString;
   @lombok.Getter(lombok.AccessLevel.PUBLIC) String publicString;
   @lombok.Getter(value = lombok.AccessLevel.PUBLIC) String value;
+  GetterAccessLevel() {
+    super();
+  }
   private @java.lang.SuppressWarnings("all") boolean isPrivate() {
     return this.isPrivate;
   }
@@ -37,7 +40,4 @@ class GetterAccessLevel {
   public @java.lang.SuppressWarnings("all") String getValue() {
     return this.value;
   }
-  GetterAccessLevel() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/GetterDeprecated.java
Patch:
@@ -2,13 +2,13 @@
 class GetterDeprecated {
   @Deprecated @Getter int annotation;
   @Getter int javadoc;
+  GetterDeprecated() {
+    super();
+  }
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") int getAnnotation() {
     return this.annotation;
   }
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") int getJavadoc() {
     return this.javadoc;
   }
-  GetterDeprecated() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/GetterLazy.java
Patch:
@@ -5,6 +5,9 @@ static class ValueType {
     }
   }
   private final @lombok.Getter(lazy = true) java.util.concurrent.atomic.AtomicReference<java.util.concurrent.atomic.AtomicReference<ValueType>> fieldName = new java.util.concurrent.atomic.AtomicReference<java.util.concurrent.atomic.AtomicReference<ValueType>>();
+  GetterLazy() {
+    super();
+  }
   public @java.lang.SuppressWarnings("all") ValueType getFieldName() {
     java.util.concurrent.atomic.AtomicReference<ValueType> value = this.fieldName.get();
     if ((value == null))
@@ -22,7 +25,4 @@ static class ValueType {
         }
     return value.get();
   }
-  GetterLazy() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/GetterOnStatic.java
Patch:
@@ -3,13 +3,13 @@ class Getter {
   static @lombok.Getter int bar;
   <clinit>() {
   }
+  Getter() {
+    super();
+  }
   public static @java.lang.SuppressWarnings("all") boolean isFoo() {
     return Getter.foo;
   }
   public static @java.lang.SuppressWarnings("all") int getBar() {
     return Getter.bar;
   }
-  Getter() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/SetterAccessLevel.java
Patch:
@@ -5,6 +5,9 @@ class SetterAccessLevel {
   @lombok.Setter(lombok.AccessLevel.PROTECTED) boolean isProtected;
   @lombok.Setter(lombok.AccessLevel.PUBLIC) boolean isPublic;
   @lombok.Setter(value = lombok.AccessLevel.PUBLIC) boolean value;
+  SetterAccessLevel() {
+    super();
+  }
   private @java.lang.SuppressWarnings("all") void setPrivate(final boolean isPrivate) {
     this.isPrivate = isPrivate;
   }
@@ -20,7 +23,4 @@ class SetterAccessLevel {
   public @java.lang.SuppressWarnings("all") void setValue(final boolean value) {
     this.value = value;
   }
-  SetterAccessLevel() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/SetterDeprecated.java
Patch:
@@ -2,13 +2,13 @@
 class SetterDeprecated {
   @Deprecated @Setter int annotation;
   @Setter int javadoc;
+  SetterDeprecated() {
+    super();
+  }
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void setAnnotation(final int annotation) {
     this.annotation = annotation;
   }
   public @java.lang.Deprecated @java.lang.SuppressWarnings("all") void setJavadoc(final int javadoc) {
     this.javadoc = javadoc;
   }
-  SetterDeprecated() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/SetterOnStatic.java
Patch:
@@ -3,13 +3,13 @@ class Setter {
   static @lombok.Setter int bar;
   <clinit>() {
   }
+  Setter() {
+    super();
+  }
   public static @java.lang.SuppressWarnings("all") void setFoo(final boolean foo) {
     Setter.foo = foo;
   }
   public static @java.lang.SuppressWarnings("all") void setBar(final int bar) {
     Setter.bar = bar;
   }
-  Setter() {
-    super();
-  }
 }

File: test/transform/resource/after-ecj/SimpleTypeResolution.java
Patch:
@@ -5,9 +5,9 @@ class SimpleTypeResolutionFail {
 }
 class SimpleTypeResolutionSuccess {
   private @lombok.Getter int x;
+  SimpleTypeResolutionSuccess() {
+  }
   public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;
   }
-  SimpleTypeResolutionSuccess() {
-  }
 }

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -381,6 +381,7 @@ public boolean delombok() throws IOException {
 		}
 		
 		JavaCompiler delegate = compiler.processAnnotations(compiler.enterTrees(toJavacList(roots)));
+		delegate.flow(delegate.attribute(delegate.todo));
 		for (JCCompilationUnit unit : roots) {
 			DelombokResult result = new DelombokResult(catcher.getComments(unit), unit, force || options.isChanged(unit));
 			if (verbose) feedback.printf("File: %s [%s]\n", unit.sourcefile.getName(), result.isChanged() ? "delomboked" : "unchanged");

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -838,7 +838,7 @@ private static GetterMethod findGetter(EclipseNode field) {
 		return null;
 	}
 	
-	enum FieldAccess {
+	public enum FieldAccess {
 		GETTER, PREFER_FIELD, ALWAYS_FIELD;
 	}
 	

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -119,7 +119,7 @@ public void generateEqualsAndHashCodeForType(JavacNode typeNode, JavacNode sourc
 		generateMethods(typeNode, source, null, null, null, false, FieldAccess.GETTER);
 	}
 	
-	private void generateMethods(JavacNode typeNode, JavacNode source, List<String> excludes, List<String> includes,
+	public void generateMethods(JavacNode typeNode, JavacNode source, List<String> excludes, List<String> includes,
 			Boolean callSuper, boolean whineIfExists, FieldAccess fieldAccess) {
 		boolean notAClass = true;
 		if (typeNode.get() instanceof JCClassDecl) {

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -111,7 +111,7 @@ public void generateToStringForType(JavacNode typeNode, JavacNode errorNode) {
 		generateToString(typeNode, errorNode, null, null, includeFieldNames, null, false, FieldAccess.GETTER);
 	}
 	
-	private void generateToString(JavacNode typeNode, JavacNode source, List<String> excludes, List<String> includes,
+	public void generateToString(JavacNode typeNode, JavacNode source, List<String> excludes, List<String> includes,
 			boolean includeFieldNames, Boolean callSuper, boolean whineIfExists, FieldAccess fieldAccess) {
 		boolean notAClass = true;
 		if (typeNode.get() instanceof JCClassDecl) {

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -566,7 +566,7 @@ private static GetterMethod findGetter(JavacNode field) {
 		return null;
 	}
 	
-	enum FieldAccess {
+	public enum FieldAccess {
 		GETTER, PREFER_FIELD, ALWAYS_FIELD;
 	}
 	

File: src/installer/lombok/installer/eclipse/EclipseLocation.java
Patch:
@@ -175,8 +175,8 @@ public void uninstall() throws UninstallException {
 						}
 						
 						newContents.append(line).append(OS_NEWLINE);
-						br.close();
 					}
+					br.close();
 				} finally {
 					fis.close();
 				}

File: src/core/lombok/Getter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2010 The Project Lombok Authors.
+ * Copyright (C) 2009-2012 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -45,8 +45,8 @@
  * Note that fields of type {@code boolean} (but not {@code java.lang.Boolean}) will result in an
  * {@code isFoo} name instead of {@code getFoo}.
  * <p>
- * If any method named {@code getFoo}/{@code isFoo} exists, regardless of return type or parameters, no method is generated,
- * and instead a compiler warning is emitted.
+ * If any method named {@code getFoo}/{@code isFoo} (case insensitive) exists, regardless of return type or parameters,
+ * no method is generated, and instead a compiler warning is emitted.
  * <p>
  * This annotation can also be applied to a class, in which case it'll be as if all non-static fields that don't already have
  * a {@code @Getter} annotation have the annotation.

File: src/core/lombok/Setter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2010 The Project Lombok Authors.
+ * Copyright (C) 2009-2012 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -42,8 +42,8 @@
  *     }
  * </pre>
  * 
- * If any method named {@code setFoo} exists, regardless of return type or parameters, no method is generated,
- * and instead a compiler warning is emitted.
+ * If any method named {@code setFoo} (case insensitive) exists, regardless of return type or parameters,
+ * no method is generated, and instead a compiler warning is emitted.
  * <p>
  * This annotation can also be applied to a class, in which case it'll be as if all non-static fields that don't already have
  * a {@code Setter} annotation have the annotation.

File: src/installer/lombok/installer/eclipse/EclipseLocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2010 The Project Lombok Authors.
+ * Copyright (C) 2009-2012 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -228,6 +228,8 @@ private ConstructorDeclaration createConstructor(AccessLevel level,
 		constructor.selector = ((TypeDeclaration)type.get()).name;
 		constructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);
 		setGeneratedBy(constructor.constructorCall, source);
+		constructor.constructorCall.sourceStart = source.sourceStart;
+		constructor.constructorCall.sourceEnd = source.sourceEnd;
 		constructor.thrownExceptions = null;
 		constructor.typeParameters = null;
 		constructor.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -268,6 +268,9 @@ private MethodDeclaration generateGetter(TypeDeclaration parent, EclipseNode fie
 		method.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;
 		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;
 		method.statements = statements;
+		
+		EclipseHandlerUtil.registerCreatedLazyGetter((FieldDeclaration) fieldNode.get(), method.selector, returnType);
+		
 		return method;
 	}
 

File: test/transform/resource/after-ecj/GetterLazyBoolean.java
Patch:
@@ -1,4 +1,4 @@
-class GetterLazyBoolean {
+@lombok.EqualsAndHashCode(of = "booleanValue") @lombok.ToString(of = "booleanValue") class GetterLazyBoolean {
   private final @lombok.Getter(lazy = true) java.util.concurrent.atomic.AtomicReference<java.util.concurrent.atomic.AtomicReference<java.lang.Boolean>> booleanValue = new java.util.concurrent.atomic.AtomicReference<java.util.concurrent.atomic.AtomicReference<java.lang.Boolean>>();
   private final @lombok.Getter(lazy = true) java.util.concurrent.atomic.AtomicReference<java.util.concurrent.atomic.AtomicReference<java.lang.Boolean>> otherBooleanValue = new java.util.concurrent.atomic.AtomicReference<java.util.concurrent.atomic.AtomicReference<java.lang.Boolean>>();
   public @java.lang.SuppressWarnings("all") boolean isBooleanValue() {
@@ -43,7 +43,7 @@ class GetterLazyBoolean {
     final @java.lang.SuppressWarnings("all") GetterLazyBoolean other = (GetterLazyBoolean) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
-    if (this.isBooleanValue() != other.isBooleanValue())
+    if ((this.isBooleanValue() != other.isBooleanValue()))
         return false;
     return true;
   }
@@ -53,7 +53,7 @@ class GetterLazyBoolean {
   public @java.lang.Override @java.lang.SuppressWarnings("all") int hashCode() {
     final int PRIME = 31;
     int result = 1;
-    result = result * PRIME + (this.isBooleanValue() ? 1231 : 1237);
+    result = ((result * PRIME) + (this.isBooleanValue() ? 1231 : 1237));
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -221,8 +221,10 @@ private void createGetterForField(AccessLevel level,
 	private JCMethodDecl createGetter(long access, JavacNode field, TreeMaker treeMaker, boolean lazy, JCTree source) {
 		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
 		
-		// Remember the type; lazy will change it;
+		// Remember the type; lazy will change it
 		JCExpression methodType = copyType(treeMaker, fieldNode);
+		// Generate the methodName; lazy will change the field type
+		Name methodName = field.toName(toGetterName(field));
 		
 		List<JCStatement> statements;
 		JCTree toClearOfMarkers = null;
@@ -234,7 +236,6 @@ private JCMethodDecl createGetter(long access, JavacNode field, TreeMaker treeMa
 		}
 		
 		JCBlock methodBody = treeMaker.Block(0, statements);
-		Name methodName = field.toName(toGetterName(field));
 		
 		List<JCTypeParameter> methodGenericParams = List.nil();
 		List<JCVariableDecl> parameters = List.nil();

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -434,7 +434,7 @@ private JCMethodDecl createEquals(JavacNode typeNode, List<JavacNode> fields, bo
 					statements.append(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, maker, typeNode, false));
 					break;
 				case DOUBLE:
-					/* if (Double(this.fieldName, other.fieldName) != 0) return false; */
+					/* if (Double.compare(this.fieldName, other.fieldName) != 0) return false; */
 					statements.append(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, maker, typeNode, true));
 					break;
 				default:

File: test/transform/resource/after-ecj/EqualsAndHashCode.java
Patch:
@@ -25,7 +25,7 @@
     final java.lang.Object this$b = this.b;
     final java.lang.Object other$b = other.b;
     if (((this$b == null) ? (other$b != null) : (! this$b.equals(other$b))))
-    	return false;
+        return false;
     return true;
   }
   public @java.lang.SuppressWarnings("all") boolean canEqual(final java.lang.Object other) {

File: src/core/lombok/core/Version.java
Patch:
@@ -28,7 +28,7 @@ public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.
 	// Official builds always end in an even number. (Since 0.10.2).
-	private static final String VERSION = "0.11.0";
+	private static final String VERSION = "0.11.1";
 	private static final String RELEASE_NAME = "Burning Emu";
 	
 	private Version() {

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1421,12 +1421,12 @@ public static IntLiteral makeIntLiteral(char[] token, ASTNode source) {
 		Method intLiteralFactoryMethod_ = null;
 		try { 
 			intLiteralConstructor_ = IntLiteral.class.getConstructor(parameterTypes);
-		} catch (Exception ignore) {
+		} catch (Throwable ignore) {
 			// probably eclipse 3.7++
 		}
 		try { 
 			intLiteralFactoryMethod_ = IntLiteral.class.getMethod("buildIntLiteral", parameterTypes);
-		} catch (Exception ignore) {
+		} catch (Throwable ignore) {
 			// probably eclipse versions before 3.7
 		}
 		intLiteralConstructor = intLiteralConstructor_;

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -105,7 +105,7 @@ private static final class LogDisabler {
 				d.setAccessible(true);
 				e.setAccessible(true);
 				f.setAccessible(true);
-			} catch (Exception x) {
+			} catch (Throwable x) {
 				z = true;
 			}
 			
@@ -114,7 +114,7 @@ private static final class LogDisabler {
 				h = Log.class.getDeclaredField("deferredDiagnostics");
 				g.setAccessible(true);
 				h.setAccessible(true);
-			} catch (Exception x) {
+			} catch (Throwable x) {
 			}
 			
 			errWriterField = a;

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -659,7 +659,7 @@ private static final class Reflection {
 			try {
 				m = ClassScope.class.getDeclaredMethod("buildFieldsAndMethods");
 				m.setAccessible(true);
-			} catch (Exception e) {
+			} catch (Throwable t) {
 				// That's problematic, but as long as no local classes are used we don't actually need it.
 				// Better fail on local classes than crash altogether.
 			}

File: src/eclipseAgent/lombok/eclipse/agent/PatchValEclipse.java
Patch:
@@ -227,7 +227,7 @@ public static MarkerAnnotation createValAnnotation(AST ast, Annotation original,
 		try {
 			f = Name.class.getDeclaredField("index");
 			f.setAccessible(true);
-		} catch (Exception e) {
+		} catch (Throwable t) {
 			// Leave it null, in which case we don't set index. That'll result in error log messages but its better than crashing here.
 		}
 		
@@ -274,7 +274,7 @@ public static final class Reflection {
 				Class<?> z = Class.forName("org.eclipse.jdt.core.dom.ASTConverter");
 				h = z.getDeclaredMethod("recordNodes", org.eclipse.jdt.core.dom.ASTNode.class, org.eclipse.jdt.internal.compiler.ast.ASTNode.class);
 				h.setAccessible(true);
-			} catch (Exception e) {
+			} catch (Throwable t) {
 				// Most likely we're in ecj or some other plugin usage of the eclipse compiler. No need for this.
 			}
 			

File: src/eclipseAgent/lombok/eclipse/agent/PatchValEclipsePortal.java
Patch:
@@ -118,10 +118,10 @@ private static final class Reflection {
 						Object.class,
 						Class.forName(SINGLEVARIABLEDECLARATION_SIG),
 						Class.forName(LOCALDECLARATION_SIG));
-			} catch (Exception e) {
+			} catch (Throwable t) {
 				// That's problematic, but as long as no local classes are used we don't actually need it.
 				// Better fail on local classes than crash altogether.
-				problem_ = e;
+				problem_ = t;
 			}
 			copyInitializationOfForEachIterable = m;
 			copyInitializationOfLocalDeclaration = n;

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -331,7 +331,7 @@ private static void patchRefactorScripts(ScriptManager sm) {
 				.target(new MethodTarget("org.eclipse.jdt.internal.corext.refactoring.rename.TempOccurrenceAnalyzer", "visit", "boolean", "org.eclipse.jdt.core.dom.SimpleName"))
 				.target(new MethodTarget("org.eclipse.jdt.internal.corext.refactoring.rename.RenameAnalyzeUtil$ProblemNodeFinder$NameNodeVisitor", "visit", "boolean", "org.eclipse.jdt.core.dom.SimpleName"))
 				.decisionMethod(new Hook("lombok.eclipse.agent.PatchFixes", "isGenerated", "boolean", "org.eclipse.jdt.core.dom.ASTNode"))
-				.valueMethod(new Hook("lombok.eclipse.agent.PatchFixes", "isGenerated", "boolean", "org.eclipse.jdt.core.dom.ASTNode"))
+				.valueMethod(new Hook("lombok.eclipse.agent.PatchFixes", "returnTrue", "boolean", "java.lang.Object"))
 				.request(StackRequest.PARAM1)
 				.transplant().build());
 	}

File: src/core/lombok/core/TransformationsUtil.java
Patch:
@@ -93,7 +93,7 @@ private static CharSequence removePrefix(CharSequence fieldName, String[] prefix
 	 * Strategy:
 	 * <ul>
 	 * <li>Reduce the field's name to its base name by stripping off any prefix (from {@code Accessors}). If the field name does not fit
-	 * the prefix list, this method immediately returns {@null}.</li>
+	 * the prefix list, this method immediately returns {@code null}.</li>
 	 * <li>If {@code Accessors} has {@code fluent=true}, then return the basename.</li>
 	 * <li>Pick a prefix. 'get' normally, but 'is' if {@code isBoolean} is true.</li>
 	 * <li>Only if {@code isBoolean} is true: Check if the field starts with {@code is} followed by a non-lowercase character. If so, return the field name verbatim.</li> 
@@ -130,7 +130,7 @@ public static String toGetterName(AnnotationValues<Accessors> accessors, CharSeq
 	 * Strategy:
 	 * <ul>
 	 * <li>Reduce the field's name to its base name by stripping off any prefix (from {@code Accessors}). If the field name does not fit
-	 * the prefix list, this method immediately returns {@null}.</li>
+	 * the prefix list, this method immediately returns {@code null}.</li>
 	 * <li>If {@code Accessors} has {@code fluent=true}, then return the basename.</li>
 	 * <li>Only if {@code isBoolean} is true: Check if the field starts with {@code is} followed by a non-lowercase character.
 	 * If so, replace {@code is} with {@code set} and return that.</li> 

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1055,7 +1055,7 @@ public static MemberExistsResult fieldExists(String fieldName, EclipseNode node)
 	}
 	
 	/**
-	 * Wrapper for {@link #methodExists(String, EclipseNode, boolean)} with {@code caseSensitive} = {@code true}.
+	 * Wrapper for {@link #methodExists(String, EclipseNode, boolean, int)} with {@code caseSensitive} = {@code true}.
 	 */
 	public static MemberExistsResult methodExists(String methodName, EclipseNode node, int params) {
 		return methodExists(methodName, node, true, params);

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -759,6 +759,7 @@ public void visitMethodDef(JCMethodDecl tree) {
             printDocComment(tree);
             printExpr(tree.mods);
             printTypeParameters(tree.typarams);
+            if (tree.typarams != null && tree.typarams.length() > 0) print(" ");
             if (tree.name == tree.name.table.fromChars("<init>".toCharArray(), 0, 6)) {
                 print(enclClassName != null ? enclClassName : tree.name);
             } else {

File: test/transform/resource/after-delombok/ValWeirdTypes.java
Patch:
@@ -23,7 +23,7 @@ public void run() {
 			}
 		};
 	}
-	public <T extends Number>void testTypeParams(List<T> param) {
+	public <T extends Number> void testTypeParams(List<T> param) {
 		final T t = param.get(0);
 		final Z z = fieldList.get(0);
 		final java.util.List<T> k = param;

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -990,7 +990,7 @@ public static AnnotationValues<Accessors> getAccessorsForField(EclipseNode field
 					return createAnnotation(Accessors.class, node);
 				}
 			}
-			current = field.up();
+			current = current.up();
 		}
 		
 		return AnnotationValues.of(Accessors.class, field);

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -184,7 +184,9 @@ private MethodDeclaration generateSetter(TypeDeclaration parent, EclipseNode fie
 		method.returnType = TypeReference.baseTypeReference(TypeIds.T_void, 0);
 		method.returnType.sourceStart = pS; method.returnType.sourceEnd = pE;
 		setGeneratedBy(method.returnType, source);
-		method.annotations = null;
+		if (isFieldDeprecated(fieldNode)) {
+			method.annotations = new Annotation[] { generateDeprecatedAnnotation(source) };
+		}
 		Argument param = new Argument(field.name, p, copyType(field.type, source), Modifier.FINAL);
 		param.sourceStart = pS; param.sourceEnd = pE;
 		setGeneratedBy(param, source);

File: src/core/lombok/core/TypeResolver.java
Patch:
@@ -48,6 +48,7 @@ private static Collection<String> makeImportList(String packageString, Collectio
 		Set<String> imports = new HashSet<String>();
 		if (packageString != null) imports.add(packageString + ".*");
 		imports.addAll(importStrings == null ? Collections.<String>emptySet() : importStrings);
+		imports.add("java.lang.*");
 		return imports;
 	}
 	

File: test/core/src/lombok/RunTestsViaDelombok.java
Patch:
@@ -57,8 +57,8 @@ public void transformCode(final StringBuilder messages, StringWriter result, fin
 		delombok.setSourcepath(file.getAbsoluteFile().getParent());
 		delombok.setWriter(result);
 		Locale originalLocale = Locale.getDefault();
-		Locale.setDefault(Locale.ENGLISH);
 		try {
+			Locale.setDefault(Locale.ENGLISH);
 			delombok.delombok();
 		} finally {
 			Locale.setDefault(originalLocale);

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.javac.handlers;
 
 import static lombok.javac.handlers.JavacHandlerUtil.*;
+import static com.sun.tools.javac.code.Flags.*;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -335,7 +336,7 @@ private void addMethodBindings(List<MethodSig> signatures, ClassType ct, JavacTy
 			ExecutableType methodType = (ExecutableType) types.asMemberOf(ct, member);
 			String sig = printSig(methodType, member.name, types);
 			if (!banList.add(sig)) continue; //If add returns false, it was already in there
-			boolean isDeprecated = exElem.getAnnotation(Deprecated.class) != null;
+			boolean isDeprecated = (member.flags() & DEPRECATED) != 0;
 			signatures.add(new MethodSig(member.name, methodType, isDeprecated, exElem));
 		}
 		

File: src/eclipseAgent/lombok/eclipse/agent/PatchVal.java
Patch:
@@ -120,6 +120,8 @@ public static boolean handleValForLocalDeclaration(LocalDeclaration local, Block
 		
 		if (!isVal(local.type, scope)) return false;
 		
+		if (new Throwable().getStackTrace()[2].getClassName().contains("ForStatement")) return false;
+		
 		Expression init = local.initialization;
 		if (init == null && Reflection.initCopyField != null) {
 			try {

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -277,7 +277,7 @@ private JCMethodDecl createDelegateMethod(MethodSig sig, JavacNode annotation, N
 		}
 		
 		JCModifiers mods = maker.Modifiers(Flags.PUBLIC, annotations);
-		JCExpression returnType = JavacResolution.typeToJCTree((Type) sig.type.getReturnType(), maker, annotation.getAst(), true);
+		JCExpression returnType = JavacResolution.typeToJCTree((Type) sig.type.getReturnType(), annotation.getAst(), true);
 		boolean useReturn = sig.type.getReturnType().getKind() != TypeKind.VOID;
 		ListBuffer<JCVariableDecl> params = sig.type.getParameterTypes().isEmpty() ? null : new ListBuffer<JCVariableDecl>();
 		ListBuffer<JCExpression> args = sig.type.getParameterTypes().isEmpty() ? null : new ListBuffer<JCExpression>();
@@ -293,15 +293,15 @@ private JCMethodDecl createDelegateMethod(MethodSig sig, JavacNode annotation, N
 		}
 		
 		for (TypeMirror ex : sig.type.getThrownTypes()) {
-			thrown.append(JavacResolution.typeToJCTree((Type) ex, maker, annotation.getAst(), true));
+			thrown.append(JavacResolution.typeToJCTree((Type) ex, annotation.getAst(), true));
 		}
 		
 		int idx = 0;
 		for (TypeMirror param : sig.type.getParameterTypes()) {
 			JCModifiers paramMods = maker.Modifiers(Flags.FINAL);
 			String[] paramNames = sig.getParameterNames();
 			Name name = annotation.toName(paramNames[idx++]);
-			params.append(maker.VarDef(paramMods, name, JavacResolution.typeToJCTree((Type) param, maker, annotation.getAst(), true), null));
+			params.append(maker.VarDef(paramMods, name, JavacResolution.typeToJCTree((Type) param, annotation.getAst(), true), null));
 			args.append(maker.Ident(name));
 		}
 		

File: test/core/src/lombok/AbstractRunTests.java
Patch:
@@ -103,8 +103,7 @@ private void compare(String name, String expectedFile, String actualFile, String
 		}
 		try {
 			compareContent(name, expectedMessages, actualMessages);
-		}
-		catch (Throwable e) {
+		} catch (Throwable e) {
 			if (printErrors) {
 				System.out.println("***** " + name + " *****");
 				System.out.println(e.getMessage());

File: src/core/lombok/core/Main.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2010 The Project Lombok Authors.
+ * Copyright (C) 2009-2012 The Project Lombok Authors.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -142,12 +142,13 @@ public void printHelp(String message, PrintStream out) {
 			out.println("------------------------------");
 		}
 		out.println("projectlombok.org v" + Version.getVersion());
-		out.println("Copyright (C) 2009-2010 The Project Lombok Authors.");
+		out.println("Copyright (C) 2009-2012 The Project Lombok Authors.");
 		out.println("Run 'lombok license' to see the lombok license agreement.");
 		out.println();
 		out.println("Run lombok without any parameters to start the graphical installer.");
 		out.println("Other available commands:");
 		for (LombokApp app : apps) {
+			if (app.isDebugTool()) continue;
 			String[] desc = app.getAppDescription().split("\n");
 			for (int i = 0; i < desc.length; i++) {
 				out.printf("  %15s    %s\n", i == 0 ? app.getAppName() : "", desc[i]);

File: src/core/lombok/core/runtimeDependencies/CreateLombokRuntimeApp.java
Patch:
@@ -49,7 +49,7 @@
 import com.zwitserloot.cmdreader.Shorthand;
 
 @ProviderFor(LombokApp.class)
-public class CreateLombokRuntimeApp implements LombokApp {
+public class CreateLombokRuntimeApp extends LombokApp {
 	private List<RuntimeDependencyInfo> infoObjects;
 	
 	@Override public String getAppName() {
@@ -64,7 +64,7 @@ public class CreateLombokRuntimeApp implements LombokApp {
 	}
 	
 	@Override public List<String> getAppAliases() {
-		return Arrays.asList("createRuntime", "runtime");
+		return Arrays.asList("runtime");
 	}
 	
 	private static class CmdArgs {

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -40,7 +40,7 @@
 import org.mangosdk.spi.ProviderFor;
 
 @ProviderFor(LombokApp.class)
-public class DelombokApp implements LombokApp {
+public class DelombokApp extends LombokApp {
 	@Override public int runApp(List<String> args) throws Exception {
 		try {
 			Class.forName("com.sun.tools.javac.main.JavaCompiler");
@@ -245,7 +245,7 @@ private static File checkToolsJar(File d) {
 	}
 	
 	@Override public List<String> getAppAliases() {
-		return Arrays.asList("unlombok", "delombok");
+		return Arrays.asList("unlombok");
 	}
 	
 	@Override public String getAppDescription() {

File: src/utils/lombok/eclipse/Eclipse.java
Patch:
@@ -43,6 +43,7 @@
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 
 public class Eclipse {
+	private static final Annotation[] EMPTY_ANNOTATIONS_ARRAY = new Annotation[0];
 	/**
 	 * Eclipse's Parser class is instrumented to not attempt to fill in the body of any method or initializer
 	 * or field initialization if this flag is set. Set it on the flag field of
@@ -120,7 +121,7 @@ public static boolean hasClinit(TypeDeclaration parent) {
 	 */
 	public static Annotation[] findAnnotations(FieldDeclaration field, Pattern namePattern) {
 		List<Annotation> result = new ArrayList<Annotation>();
-		if (field.annotations == null) return new Annotation[0];
+		if (field.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;
 		for (Annotation annotation : field.annotations) {
 			TypeReference typeRef = annotation.type;
 			if (typeRef != null && typeRef.getTypeName()!= null) {
@@ -131,7 +132,7 @@ public static Annotation[] findAnnotations(FieldDeclaration field, Pattern nameP
 				}
 			}
 		}	
-		return result.toArray(new Annotation[0]);
+		return result.toArray(EMPTY_ANNOTATIONS_ARRAY);
 	}
 	
 	/**

File: test/transform/resource/after-ecj/DelegateOnGetter.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -281,6 +281,7 @@ private static void fillMethodBindingsForMethods(CompilationUnitDeclaration cud,
 				List<BindingTuple> methodsToDelegateForThisAnn = new ArrayList<BindingTuple>();
 				
 				if (rawTypes.isEmpty()) {
+					if (method.returnType == null) continue;
 					addAllMethodBindings(methodsToDelegateForThisAnn, method.returnType.resolveType(decl.initializerScope), banList, method.selector, ann);
 				} else {
 					for (ClassLiteralAccess cla : rawTypes) {

File: test/bytecode/resource/Foo.java
Patch:
@@ -1,6 +1,7 @@
 public class Foo implements java.util.RandomAccess {
 	private static final long LONG = 123L;
-	private static final String ONE = "Eén";
+	private static final long LONG_OVERFLOW = 0x1FFFFFFFFL;
+	private static final String ONE = "E\u00e9n";
 	private static final int INT = 123;
 	private static final double DOUBLE = 1.23;
 	private static final double DOUBLE_NAN = Double.NaN;

File: test/bytecode/src/lombok/bytecode/TestClassFileMetaData.java
Patch:
@@ -169,6 +169,7 @@ public void testContainsInteger() {
 	@Test
 	public void testContainsLong() {
 		assertTrue(foo.containsLong(123));
+		assertTrue(foo.containsLong(0x1FFFFFFFFL));
 		
 		assertFalse(foo.containsLong(1));
 		assertFalse(buux.containsLong(1));

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -222,14 +222,17 @@ public void generateMethods(EclipseNode typeNode, EclipseNode errorNode, List<St
 		}
 		
 		MethodDeclaration equalsMethod = createEquals(typeNode, nodesForEquality, callSuper, errorNode.get(), fieldAccess, needsCanEqual);
+		equalsMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
 		injectMethod(typeNode, equalsMethod);
 		
 		if (needsCanEqual) {
 			MethodDeclaration canEqualMethod = createCanEqual(typeNode, errorNode.get());
+			canEqualMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
 			injectMethod(typeNode, canEqualMethod);
 		}
 		
 		MethodDeclaration hashCodeMethod = createHashCode(typeNode, nodesForEquality, callSuper, errorNode.get(), fieldAccess);
+		hashCodeMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
 		injectMethod(typeNode, hashCodeMethod);
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -233,8 +233,8 @@ public static int fixRetrieveEllipsisStartPosition(int original, int end) {
 	}
 	
 	public static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {
-		return original;
-		// return original == -1 ? end : original;  // Need to fix: see issue 325.
+//		return original;
+		 return original == -1 ? end : original;  // Need to fix: see issue 325.
 	}
 	
 	public static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24

File: src/core/lombok/Delegate.java
Patch:
@@ -40,7 +40,7 @@
  * that exist in {@link Object}, the {@code canEqual(Object)} method, and any methods that appear in types
  * that are listed in the {@code excludes} property.
  */
-@Target(ElementType.FIELD)
+@Target({ElementType.FIELD, ElementType.METHOD})
 @Retention(RetentionPolicy.SOURCE)
 public @interface Delegate {
 	/**

File: test/transform/resource/after-ecj/DelegateOnMethods.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -222,14 +222,17 @@ public void generateMethods(EclipseNode typeNode, EclipseNode errorNode, List<St
 		}
 		
 		MethodDeclaration equalsMethod = createEquals(typeNode, nodesForEquality, callSuper, errorNode.get(), fieldAccess, needsCanEqual);
+		equalsMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
 		injectMethod(typeNode, equalsMethod);
 		
 		if (needsCanEqual) {
 			MethodDeclaration canEqualMethod = createCanEqual(typeNode, errorNode.get());
+			canEqualMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
 			injectMethod(typeNode, canEqualMethod);
 		}
 		
 		MethodDeclaration hashCodeMethod = createHashCode(typeNode, nodesForEquality, callSuper, errorNode.get(), fieldAccess);
+		hashCodeMethod.traverse(new SetGeneratedByVisitor(errorNode.get()), ((TypeDeclaration)typeNode.get()).scope);
 		injectMethod(typeNode, hashCodeMethod);
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -237,8 +237,8 @@ public static int fixRetrieveEllipsisStartPosition(int original, int end) {
 	}
 	
 	public static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {
-		return original;
-		// return original == -1 ? end : original;  // Need to fix: see issue 325.
+//		return original;
+		 return original == -1 ? end : original;  // Need to fix: see issue 325.
 	}
 	
 	public static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -237,7 +237,8 @@ public static int fixRetrieveEllipsisStartPosition(int original, int end) {
 	}
 	
 	public static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {
-		return original == -1 ? end : original;
+		return original;
+		// return original == -1 ? end : original;  // Need to fix: see issue 325.
 	}
 	
 	public static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -261,7 +261,7 @@ public static void setIsGeneratedFlag(org.eclipse.jdt.core.dom.ASTNode domNode,
 		}
 	}
 	
-	public static void setIsGeneratedFlagForSimpleName(SimpleName name, Object internalNode) throws Exception {
+	public static void setIsGeneratedFlagForName(org.eclipse.jdt.core.dom.Name name, Object internalNode) throws Exception {
 		if (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {
 			if (internalNode.getClass().getField("$generatedBy").get(internalNode) != null) {
 				name.getClass().getField("$isGenerated").set(name, true);
@@ -307,9 +307,9 @@ public static int getTokenEndOffsetFixed(TokenScanner scanner, int token, int st
 	public static IMethod[] removeGeneratedMethods(IMethod[] methods) throws Exception {
 		List<IMethod> result = new ArrayList<IMethod>();
 		for (IMethod m : methods) {
-			if (m.getNameRange().getLength() > 0) result.add(m);
+			if (m.getNameRange().getLength() > 0 && !m.getNameRange().equals(m.getSourceRange())) result.add(m);
 		}
-		return result.size() == methods.length ? methods : result.toArray(new IMethod[0]);
+		return result.size() == methods.length ? methods : result.toArray(new IMethod[result.size()]);
 	}
 	
 	public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Exception {

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -212,7 +212,7 @@ public static void setIsGeneratedFlag(org.eclipse.jdt.core.dom.ASTNode domNode,
 		}
 	}
 	
-	public static void setIsGeneratedFlagForSimpleName(SimpleName name, Object internalNode) throws Exception {
+	public static void setIsGeneratedFlagForName(org.eclipse.jdt.core.dom.Name name, Object internalNode) throws Exception {
 		if (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {
 			if (internalNode.getClass().getField("$generatedBy").get(internalNode) != null) {
 				name.getClass().getField("$isGenerated").set(name, true);

File: src/core/lombok/eclipse/handlers/SetGeneratedByVisitor.java
Patch:
@@ -261,7 +261,7 @@ private long recalcSourcePosition(long sourcePosition) {
 //		start = newSourceStart;
 //		end = newSourceStart;
 //		return ((start<<32)+end); 
-		return ((long)newSourceStart << 32) | (newSourceStart & INT_TO_LONG_MASK);
+		return ((long)newSourceStart << 32) | (newSourceEnd & INT_TO_LONG_MASK);
 	}
 	
 	@Override public boolean visit(AllocationExpression node, BlockScope scope) {

File: src/core/lombok/eclipse/handlers/HandleLog.java
Patch:
@@ -71,7 +71,9 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue
 			
 			ClassLiteralAccess loggingType = selfType(owner, source);
 			
-			injectField(owner, createField(framework, source, loggingType));
+			FieldDeclaration fieldDeclaration = createField(framework, source, loggingType);
+			fieldDeclaration.traverse(new SetGeneratedByVisitor(source), typeDecl.staticInitializerScope);
+			injectField(owner, fieldDeclaration);
 			owner.rebuild();
 			break;
 		default:

File: src/core/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -173,11 +173,11 @@ public void handleAnnotation(CompilationUnitDeclaration ast, EclipseNode annotat
 		String pkgName = annotationNode.getPackageDeclaration();
 		Collection<String> imports = annotationNode.getImportStatements();
 		
-		TypeResolver resolver = new TypeResolver(typeLibrary, pkgName, imports);
+		TypeResolver resolver = new TypeResolver(pkgName, imports);
 		TypeReference rawType = annotation.type;
 		if (rawType == null) return;
 		
-		for (String fqn : resolver.findTypeMatches(annotationNode, toQualifiedName(annotation.type.getTypeName()))) {
+		for (String fqn : resolver.findTypeMatches(annotationNode, typeLibrary, toQualifiedName(annotation.type.getTypeName()))) {
 			boolean isPrintAST = fqn.equals(PrintAST.class.getName());
 			if (isPrintAST == skipPrintAst) continue;
 			AnnotationHandlerContainer<?> container = annotationHandlers.get(fqn);

File: src/core/lombok/javac/HandlerLibrary.java
Patch:
@@ -171,9 +171,9 @@ private boolean checkAndSetHandled(JCTree node) {
 	 * @param annotation 'node.get()' - convenience parameter.
 	 */
 	public void handleAnnotation(JCCompilationUnit unit, JavacNode node, JCAnnotation annotation) {
-		TypeResolver resolver = new TypeResolver(typeLibrary, node.getPackageDeclaration(), node.getImportStatements());
+		TypeResolver resolver = new TypeResolver(node.getPackageDeclaration(), node.getImportStatements());
 		String rawType = annotation.annotationType.toString();
-		for (String fqn : resolver.findTypeMatches(node, rawType)) {
+		for (String fqn : resolver.findTypeMatches(node, typeLibrary, rawType)) {
 			boolean isPrintAST = fqn.equals(PrintAST.class.getName());
 			if (isPrintAST && phase != 2) continue;
 			if (!isPrintAST && phase == 2) continue;

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -108,6 +108,7 @@ private static boolean hasDelegateMarkedFields(TypeDeclaration decl) {
 			for (Annotation ann : field.annotations) {
 				if (ann.type == null) continue;
 				TypeBinding tb = ann.type.resolveType(decl.initializerScope);
+				if (tb == null) continue;
 				if (!charArrayEquals("lombok", tb.qualifiedPackageName())) continue;
 				if (!charArrayEquals("Delegate", tb.qualifiedSourceName())) continue;
 				return true;

File: test/transform/resource/after-ecj/TrickyTypeResolution.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/TrickyTypeResolution2.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/TrickyTypeResolution.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/TrickyTypeResolution2.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/core/TypeResolver.java
Patch:
@@ -73,7 +73,7 @@ public Collection<String> findTypeMatches(LombokNode<?, ?, ?> context, TypeLibra
 		// because if you want to know if 'Foo' could refer to 'bar.Foo' when 'baz.Foo' is explicitly imported, the answer is no.
 		if (nameConflictInImportList(typeRef, potentialMatches)) return Collections.emptyList();
 		
-		// Check if any of our potentials is even imported in the first place. If not: no matches.
+		// Check if any of our potentials are even imported in the first place. If not: no matches.
 		// Note that (ourPackage.*) is added to the imports.
 		potentialMatches = eliminateImpossibleMatches(potentialMatches, library);
 		if (potentialMatches.isEmpty()) return Collections.emptyList();
@@ -84,7 +84,7 @@ public Collection<String> findTypeMatches(LombokNode<?, ?, ?> context, TypeLibra
 		LombokNode<?, ?, ?> n = context;
 		
 		mainLoop:
-		while (n != null && n.getKind() != Kind.COMPILATION_UNIT) {
+		while (n != null) {
 			if (n.getKind() == Kind.TYPE && typeRef.equals(n.getName())) {
 				// Our own class or one of our outer classes is named 'typeRef' so that's what 'typeRef' is referring to, not one of our type library classes.
 				return Collections.emptyList();
@@ -106,7 +106,7 @@ public Collection<String> findTypeMatches(LombokNode<?, ?, ?> context, TypeLibra
 				continue mainLoop;
 			}
 			
-			if (n.getKind() == Kind.TYPE) {
+			if (n.getKind() == Kind.TYPE || n.getKind() == Kind.COMPILATION_UNIT) {
 				for (LombokNode<?, ?, ?> child : n.down()) {
 					// Inner class that's visible to us has 'typeRef' as name, so that's the one being referred to, not one of our type library classes.
 					if (child.getKind() == Kind.TYPE && typeRef.equals(child.getName())) return Collections.emptyList();

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -108,6 +108,7 @@ private static boolean hasDelegateMarkedFields(TypeDeclaration decl) {
 			for (Annotation ann : field.annotations) {
 				if (ann.type == null) continue;
 				TypeBinding tb = ann.type.resolveType(decl.initializerScope);
+				if (tb == null) continue;
 				if (!charArrayEquals("lombok", tb.qualifiedPackageName())) continue;
 				if (!charArrayEquals("Delegate", tb.qualifiedSourceName())) continue;
 				return true;

File: test/transform/resource/after-ecj/TrickyTypeResolution.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/TrickyTypeResolution2.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/TrickyTypeResolution.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/TrickyTypeResolution2.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -478,7 +478,8 @@ private MethodDeclaration createEquals(EclipseNode type, Collection<EclipseNode>
 			setGeneratedBy(oRef, source);
 			
 			TypeReference typeReference = createTypeReference(type, p);
-			
+			setGeneratedBy(typeReference, source);
+
 			InstanceOfExpression instanceOf = new InstanceOfExpression(oRef, typeReference);
 			instanceOf.sourceStart = pS; instanceOf.sourceEnd = pE;
 			setGeneratedBy(instanceOf, source);
@@ -705,7 +706,6 @@ private MethodDeclaration createCanEqual(EclipseNode type, ASTNode source) {
 		setGeneratedBy(otherRef, source);
 		
 		TypeReference typeReference = createTypeReference(type, p);
-		
 		setGeneratedBy(typeReference, source);
 		
 		InstanceOfExpression instanceOf = new InstanceOfExpression(otherRef, typeReference);

File: src/core/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -173,11 +173,11 @@ public void handleAnnotation(CompilationUnitDeclaration ast, EclipseNode annotat
 		String pkgName = annotationNode.getPackageDeclaration();
 		Collection<String> imports = annotationNode.getImportStatements();
 		
-		TypeResolver resolver = new TypeResolver(typeLibrary, pkgName, imports);
+		TypeResolver resolver = new TypeResolver(pkgName, imports);
 		TypeReference rawType = annotation.type;
 		if (rawType == null) return;
 		
-		for (String fqn : resolver.findTypeMatches(annotationNode, toQualifiedName(annotation.type.getTypeName()))) {
+		for (String fqn : resolver.findTypeMatches(annotationNode, typeLibrary, toQualifiedName(annotation.type.getTypeName()))) {
 			boolean isPrintAST = fqn.equals(PrintAST.class.getName());
 			if (isPrintAST == skipPrintAst) continue;
 			AnnotationHandlerContainer<?> container = annotationHandlers.get(fqn);

File: src/core/lombok/javac/HandlerLibrary.java
Patch:
@@ -171,9 +171,9 @@ private boolean checkAndSetHandled(JCTree node) {
 	 * @param annotation 'node.get()' - convenience parameter.
 	 */
 	public void handleAnnotation(JCCompilationUnit unit, JavacNode node, JCAnnotation annotation) {
-		TypeResolver resolver = new TypeResolver(typeLibrary, node.getPackageDeclaration(), node.getImportStatements());
+		TypeResolver resolver = new TypeResolver(node.getPackageDeclaration(), node.getImportStatements());
 		String rawType = annotation.annotationType.toString();
-		for (String fqn : resolver.findTypeMatches(node, rawType)) {
+		for (String fqn : resolver.findTypeMatches(node, typeLibrary, rawType)) {
 			boolean isPrintAST = fqn.equals(PrintAST.class.getName());
 			if (isPrintAST && phase != 2) continue;
 			if (!isPrintAST && phase == 2) continue;

File: src/core/lombok/eclipse/handlers/HandleLog.java
Patch:
@@ -71,7 +71,9 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue
 			
 			ClassLiteralAccess loggingType = selfType(owner, source);
 			
-			injectField(owner, createField(framework, source, loggingType));
+			FieldDeclaration fieldDeclaration = createField(framework, source, loggingType);
+			fieldDeclaration.traverse(new SetGeneratedByVisitor(source), typeDecl.staticInitializerScope);
+			injectField(owner, fieldDeclaration);
 			owner.rebuild();
 			break;
 		default:

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -478,7 +478,8 @@ private MethodDeclaration createEquals(EclipseNode type, Collection<EclipseNode>
 			setGeneratedBy(oRef, source);
 			
 			TypeReference typeReference = createTypeReference(type, p);
-			
+			setGeneratedBy(typeReference, source);
+
 			InstanceOfExpression instanceOf = new InstanceOfExpression(oRef, typeReference);
 			instanceOf.sourceStart = pS; instanceOf.sourceEnd = pE;
 			setGeneratedBy(instanceOf, source);
@@ -705,7 +706,6 @@ private MethodDeclaration createCanEqual(EclipseNode type, ASTNode source) {
 		setGeneratedBy(otherRef, source);
 		
 		TypeReference typeReference = createTypeReference(type, p);
-		
 		setGeneratedBy(typeReference, source);
 		
 		InstanceOfExpression instanceOf = new InstanceOfExpression(otherRef, typeReference);

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -94,12 +94,12 @@ public static int fixRetrieveIdentifierEndPosition(int original, int end) {
 	public static int fixRetrieveEllipsisStartPosition(int original, int end) {
 		return original == -1 ? end : original;
 	}
-
+	
 	public static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {
 		return original == -1 ? end : original;
 	}
 	
-	public static final int ALREADY_PROCESSED_FLAG = 0x800000;	//Bit 24
+	public static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24
 	
 	public static boolean checkBit24(Object node) throws Exception {
 		int bits = (Integer)(node.getClass().getField("bits").get(node));

File: src/eclipseAgent/lombok/eclipse/agent/PatchVal.java
Patch:
@@ -70,7 +70,7 @@ public static boolean matches(String key, char[] array) {
 		return true;
 	}
 	
-	private static boolean couldBeVal(TypeReference ref) {
+	public static boolean couldBeVal(TypeReference ref) {
 		if (ref instanceof SingleTypeReference) {
 			char[] token = ((SingleTypeReference)ref).token;
 			return matches("val", token);

File: test/transform/resource/after-ecj/ValWithLabel.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValWithLabel.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -249,6 +249,7 @@ private ConstructorDeclaration createConstructor(AccessLevel level,
 			SingleNameReference assignmentNameRef = new SingleNameReference(field.name, p);
 			setGeneratedBy(assignmentNameRef, source);
 			Assignment assignment = new Assignment(thisX, assignmentNameRef, (int)p);
+			assignment.sourceStart = (int)(p >> 32); assignment.sourceEnd = assignment.statementEnd = (int)(p >> 32);
 			setGeneratedBy(assignment, source);
 			assigns.add(assignment);
 			long fieldPos = (((long)field.sourceStart) << 32) | field.sourceEnd;

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -391,7 +391,7 @@ private MethodDeclaration createHashCode(EclipseNode type, Collection<EclipseNod
 				resultRef = new SingleNameReference(RESULT, p);
 				setGeneratedBy(resultRef, source);
 				Assignment assignment = new Assignment(resultRef, addItem, pE);
-				assignment.sourceStart = pS; assignment.sourceEnd = pE;
+				assignment.sourceStart = pS; assignment.sourceEnd = assignment.statementEnd = pE;
 				setGeneratedBy(assignment, source);
 				statements.add(assignment);
 			}

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -198,7 +198,7 @@ private MethodDeclaration generateSetter(TypeDeclaration parent, EclipseNode fie
 		NameReference fieldNameRef = new SingleNameReference(field.name, p);
 		setGeneratedBy(fieldNameRef, source);
 		Assignment assignment = new Assignment(fieldRef, fieldNameRef, (int)p);
-		assignment.sourceStart = pS; assignment.sourceEnd = pE;
+		assignment.sourceStart = pS; assignment.sourceEnd = assignment.statementEnd = pE;
 		setGeneratedBy(assignment, source);
 		method.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;
 		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;

File: test/transform/resource/after-ecj/LoggerSlf4jTypes.java
Patch:
@@ -11,8 +11,8 @@
   }
 }
 @lombok.extern.slf4j.Slf4j enum LoggerSlf4jTypesEnumWithElement {
-  FOO(),
   private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnumWithElement.class);
+  FOO(),
   <clinit>() {
   }
   LoggerSlf4jTypesEnumWithElement() {

File: test/transform/resource/after-eclipse/LoggerSlf4jTypes.java
Patch:
@@ -11,8 +11,8 @@
   }
 }
 @lombok.extern.slf4j.Slf4j enum LoggerSlf4jTypesEnumWithElement {
-  FOO(),
   private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LoggerSlf4jTypesEnumWithElement.class);
+  FOO(),
   <clinit>() {
   }
   LoggerSlf4jTypesEnumWithElement() {

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1014,8 +1014,8 @@ public static void injectField(EclipseNode type, FieldDeclaration field) {
 			parent.fields[0] = field;
 		} else {
 			FieldDeclaration[] newArray = new FieldDeclaration[parent.fields.length + 1];
-			System.arraycopy(parent.fields, 0, newArray, 0, parent.fields.length);
-			newArray[parent.fields.length] = field;
+			System.arraycopy(parent.fields, 0, newArray, 1, parent.fields.length);
+			newArray[0] = field;
 			parent.fields = newArray;
 		}
 		

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -77,15 +77,15 @@ public void setName(@lombok.NonNull final String name) {
 				@java.lang.SuppressWarnings("all")
 				public boolean equals(final java.lang.Object o) {
 					if (o == this) return true;
-					if (!(o instanceof InnerLocal)) return false;
+					if (!(o instanceof Local.InnerLocal)) return false;
 					final InnerLocal other = (InnerLocal)o;
 					if (!other.canEqual((java.lang.Object)this)) return false;
 					if (this.getName() == null ? other.getName() != null : !this.getName().equals((java.lang.Object)other.getName())) return false;
 					return true;
 				}
 				@java.lang.SuppressWarnings("all")
 				public boolean canEqual(final java.lang.Object other) {
-					return other instanceof InnerLocal;
+					return other instanceof Local.InnerLocal;
 				}
 				@java.lang.Override
 				@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -14,7 +14,7 @@
         return true;
     if ((! (o instanceof DataExtended)))
         return false;
-    final DataExtended other = (DataExtended) o;
+    final @java.lang.SuppressWarnings("all") DataExtended other = (DataExtended) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))

File: test/transform/resource/after-ecj/DataIgnore.java
Patch:
@@ -13,7 +13,7 @@
         return true;
     if ((! (o instanceof DataIgnore)))
         return false;
-    final DataIgnore other = (DataIgnore) o;
+    final @java.lang.SuppressWarnings("all") DataIgnore other = (DataIgnore) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -17,7 +17,7 @@
         return true;
     if ((! (o instanceof DataWithGetter)))
         return false;
-    final DataWithGetter other = (DataWithGetter) o;
+    final @java.lang.SuppressWarnings("all") DataWithGetter other = (DataWithGetter) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))

File: test/transform/resource/after-ecj/DataWithGetterNone.java
Patch:
@@ -17,7 +17,7 @@
         return true;
     if ((! (o instanceof DataWithGetterNone)))
         return false;
-    final DataWithGetterNone other = (DataWithGetterNone) o;
+    final @java.lang.SuppressWarnings("all") DataWithGetterNone other = (DataWithGetterNone) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.x != other.x))

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -25,7 +25,7 @@
         return true;
     if ((! (o instanceof GetterLazyEahcToString)))
         return false;
-    final GetterLazyEahcToString other = (GetterLazyEahcToString) o;
+    final @java.lang.SuppressWarnings("all") GetterLazyEahcToString other = (GetterLazyEahcToString) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if (((this.getValue() == null) ? (other.getValue() != null) : (! this.getValue().equals((java.lang.Object) other.getValue()))))

File: test/transform/resource/after-ecj/SynchronizedPlain.java
Patch:
@@ -1,6 +1,6 @@
 import lombok.Synchronized;
 class SynchronizedPlain1 {
-  private final @java.lang.SuppressWarnings("all") java.lang.Object $lock = new java.lang.Object[0];
+  private final java.lang.Object $lock = new java.lang.Object[0];
   SynchronizedPlain1() {
     super();
   }
@@ -18,7 +18,7 @@ class SynchronizedPlain1 {
   }
 }
 class SynchronizedPlain2 {
-  private static final @java.lang.SuppressWarnings("all") java.lang.Object $LOCK = new java.lang.Object[0];
+  private static final java.lang.Object $LOCK = new java.lang.Object[0];
   <clinit>() {
   }
   SynchronizedPlain2() {

File: test/transform/resource/after-eclipse/DataExtended.java
Patch:
@@ -14,7 +14,7 @@
         return true;
     if ((! (o instanceof DataExtended)))
         return false;
-    final DataExtended other = (DataExtended) o;
+    final @java.lang.SuppressWarnings("all") DataExtended other = (DataExtended) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))

File: test/transform/resource/after-eclipse/DataIgnore.java
Patch:
@@ -13,7 +13,7 @@
         return true;
     if ((! (o instanceof DataIgnore)))
         return false;
-    final DataIgnore other = (DataIgnore) o;
+    final @java.lang.SuppressWarnings("all") DataIgnore other = (DataIgnore) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))

File: test/transform/resource/after-eclipse/DataWithGetter.java
Patch:
@@ -17,7 +17,7 @@
         return true;
     if ((! (o instanceof DataWithGetter)))
         return false;
-    final DataWithGetter other = (DataWithGetter) o;
+    final @java.lang.SuppressWarnings("all") DataWithGetter other = (DataWithGetter) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))

File: test/transform/resource/after-eclipse/DataWithGetterNone.java
Patch:
@@ -17,7 +17,7 @@
         return true;
     if ((! (o instanceof DataWithGetterNone)))
         return false;
-    final DataWithGetterNone other = (DataWithGetterNone) o;
+    final @java.lang.SuppressWarnings("all") DataWithGetterNone other = (DataWithGetterNone) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.x != other.x))

File: test/transform/resource/after-eclipse/GetterLazyEahcToString.java
Patch:
@@ -25,7 +25,7 @@
         return true;
     if ((! (o instanceof GetterLazyEahcToString)))
         return false;
-    final GetterLazyEahcToString other = (GetterLazyEahcToString) o;
+    final @java.lang.SuppressWarnings("all") GetterLazyEahcToString other = (GetterLazyEahcToString) o;
     if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if (((this.getValue() == null) ? (other.getValue() != null) : (! this.getValue().equals((java.lang.Object) other.getValue()))))

File: test/transform/resource/after-eclipse/SynchronizedPlain.java
Patch:
@@ -1,6 +1,6 @@
 import lombok.Synchronized;
 class SynchronizedPlain1 {
-  private final @java.lang.SuppressWarnings("all") java.lang.Object $lock = new java.lang.Object[0];
+  private final java.lang.Object $lock = new java.lang.Object[0];
   SynchronizedPlain1() {
     super();
   }
@@ -18,7 +18,7 @@ class SynchronizedPlain1 {
   }
 }
 class SynchronizedPlain2 {
-  private static final @java.lang.SuppressWarnings("all") java.lang.Object $LOCK = new java.lang.Object[0];
+  private static final java.lang.Object $LOCK = new java.lang.Object[0];
   <clinit>() {
   }
   SynchronizedPlain2() {

File: src/core/lombok/core/Version.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
-	private static final String VERSION = "0.10.2-HEAD";
+	private static final String VERSION = "0.10.2";
 	private static final String RELEASE_NAME = "Burning Emu";
 	
 	private Version() {

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -358,8 +358,9 @@ public boolean delombok() throws IOException {
 		options.put("compilePolicy", "attr");
 		
 		
+		registerCommentsCollectingScannerFactory(context);
 		JavaCompiler compiler = new JavaCompiler(context);
-
+		
 		Map<JCCompilationUnit, com.sun.tools.javac.util.List<Comment>> commentsMap = new IdentityHashMap<JCCompilationUnit, com.sun.tools.javac.util.List<Comment>>();
 		setInCompiler(compiler, context, commentsMap);
 		
@@ -369,7 +370,6 @@ public boolean delombok() throws IOException {
 		List<JCCompilationUnit> roots = new ArrayList<JCCompilationUnit>();
 		Map<JCCompilationUnit, File> baseMap = new IdentityHashMap<JCCompilationUnit, File>();
 		
-		registerCommentsCollectingScannerFactory(context);
 		
 		compiler.initProcessAnnotations(Collections.singleton(new lombok.javac.apt.Processor()));
 		

File: src/stubs/com/sun/tools/javac/parser/Scanner.java
Patch:
@@ -7,7 +7,7 @@
 
 import com.sun.tools.javac.util.Context;
 
-public class Scanner {
+public class Scanner implements Lexer {
 	protected Scanner(Factory fac, CharBuffer buffer) {
 	}
 	

File: src/utils/lombok/javac/java6/CommentCollectingParser.java
Patch:
@@ -6,19 +6,19 @@
 
 import com.sun.tools.javac.parser.EndPosParser;
 import com.sun.tools.javac.parser.Lexer;
+import com.sun.tools.javac.parser.Parser;
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 import com.sun.tools.javac.util.List;
 
 class CommentCollectingParser extends EndPosParser {
 	
 	private final Map<JCCompilationUnit, List<Comment>> commentsMap;
 	private final Lexer lexer;
-
-	protected CommentCollectingParser(Factory fac, Lexer S, boolean keepDocComments, Map<JCCompilationUnit, List<Comment>> commentsMap) {
+	
+	protected CommentCollectingParser(Parser.Factory fac, Lexer S, boolean keepDocComments, Map<JCCompilationUnit, List<Comment>> commentsMap) {
 		super(fac, S, keepDocComments);
 		lexer = S;
 		this.commentsMap = commentsMap;
-		
 	}
 	
 	@Override public JCCompilationUnit compilationUnit() {

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -1211,6 +1211,9 @@ public static CastExpression makeCastExpression(Expression ref, TypeReference ca
 			throw Lombok.sneakyThrow(e);
 		}
 		
+		result.sourceStart = source.sourceStart;
+		result.sourceEnd = source.sourceEnd;
+		
 		setGeneratedBy(result, source);
 		return result;
 	}

File: src/core/lombok/NonNull.java
Patch:
@@ -28,12 +28,12 @@
 import java.lang.annotation.Target;
 
 /**
- * Lombok is smart enough to translate any annotation named {@code @NonNull} or {@code @NotNull} in any casing and
+ * Lombok is smart enough to translate any annotation named {@code @NonNull} in any casing and
  * with any package name to the return type of generated getters and the parameter of generated setters and constructors,
  * as well as generate the appropriate null checks in the setter and constructor.
  * 
  * You can use this annotation for the purpose, though you can also use JSR305's annotation, findbugs's, pmd's, or IDEA's, or just
- * about anyone elses. As long as it is named {@code @NonNull} or {@code @NotNull}.
+ * about anyone elses. As long as it is named {@code @NonNull}.
  * 
  * WARNING: If the java community ever does decide on supporting a single {@code @NonNull} annotation (for example via JSR305), then
  * this annotation will <strong>be deleted</strong> from the lombok package. If the need to update an import statement scares

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -36,6 +36,7 @@
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.model.JavacTypes;
 import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.JCTree.JCCatch;
 import com.sun.tools.javac.tree.TreeMaker;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCBlock;
@@ -275,9 +276,10 @@ private JavacNode drill(JCTree statement) {
 	/** For javac, both JCExpression and JCStatement are considered as valid children types. */
 	@Override
 	protected Collection<Class<? extends JCTree>> getStatementTypes() {
-		Collection<Class<? extends JCTree>> collection = new ArrayList<Class<? extends JCTree>>(2);
+		Collection<Class<? extends JCTree>> collection = new ArrayList<Class<? extends JCTree>>(3);
 		collection.add(JCStatement.class);
 		collection.add(JCExpression.class);
+		collection.add(JCCatch.class);
 		return collection;
 	}
 	

File: src/core/lombok/core/Version.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
-	private static final String VERSION = "0.10.1-EDGE";
+	private static final String VERSION = "0.10.1";
 	private static final String RELEASE_NAME = "Burning Emu";
 	
 	private Version() {

File: src/core/lombok/eclipse/handlers/HandleConstructor.java
Patch:
@@ -131,7 +131,7 @@ public static class HandleAllArgsConstructor extends EclipseAnnotationHandler<Al
 				if (!EclipseHandlerUtil.filterField(fieldDecl)) continue;
 				
 				// Skip initialized final fields.
-				if (((fieldDecl.modifiers & ClassFileConstants.AccFinal) != 0) && fieldDecl.initialization != null) return;
+				if (((fieldDecl.modifiers & ClassFileConstants.AccFinal) != 0) && fieldDecl.initialization != null) continue;
 				
 				fields.add(child);
 			}

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -580,6 +580,7 @@ public void printEnumBody(List<JCTree> stats) throws IOException {
     }
 
     public void printEnumMember(JCVariableDecl tree) throws IOException {
+        printAnnotations(tree.mods.annotations);
         print(tree.name);
         if (tree.init instanceof JCNewClass) {
             JCNewClass constructor = (JCNewClass) tree.init;

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.WeakHashMap;
 
 import lombok.core.AST.Kind;
 import lombok.eclipse.Eclipse;
@@ -177,7 +178,7 @@ private static String containsDuplicates(List<BindingTuple> tuples) {
 		return null;
 	}
 	
-	private static Map<ASTNode, Object> alreadyApplied = new IdentityHashMap<ASTNode, Object>();
+	private static Map<ASTNode, Object> alreadyApplied = new WeakHashMap<ASTNode, Object>();
 	private static final Object MARKER = new Object();
 	
 	private static void fillMethodBindings(CompilationUnitDeclaration cud, ClassScope scope, List<BindingTuple> methodsToDelegate) {

File: src/core/lombok/core/handlers/TransformationsUtil.java
Patch:
@@ -72,7 +72,7 @@ public static String toGetterName(CharSequence fieldName, boolean isBoolean) {
 	public static final Pattern PRIMITIVE_TYPE_NAME_PATTERN = Pattern.compile(
 			"^(boolean|byte|short|int|long|float|double|char)$");
 	
-	public static final Pattern NON_NULL_PATTERN = Pattern.compile("^nonnull$", Pattern.CASE_INSENSITIVE);
+	public static final Pattern NON_NULL_PATTERN = Pattern.compile("^(?:notnull|nonnull)$", Pattern.CASE_INSENSITIVE);
 	public static final Pattern NULLABLE_PATTERN = Pattern.compile("^(?:nullable|checkfornull)$", Pattern.CASE_INSENSITIVE);
 	
 	/**

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -72,7 +72,7 @@ public class HandleVal extends JavacASTAdapter {
 			return;
 		}
 		
-		JavacHandlerUtil.deleteImportFromCompilationUnit(localNode, "lombok.val");
+		if (localNode.shouldDeleteLombokAnnotations()) JavacHandlerUtil.deleteImportFromCompilationUnit(localNode, "lombok.val");
 		
 		local.mods.flags |= Flags.FINAL;
 		
@@ -115,7 +115,7 @@ public class HandleVal extends JavacASTAdapter {
 				if (replacement != null) {
 					local.vartype = replacement;
 				} else {
-					local.vartype = JavacResolution.createJavaLangObject(localNode.getTreeMaker(), localNode.getAst());;
+					local.vartype = JavacResolution.createJavaLangObject(localNode.getTreeMaker(), localNode.getAst());
 				}
 				localNode.getAst().setChanged();
 			} catch (JavacResolution.TypeNotConvertibleException e) {

File: src/core/lombok/javac/Javac.java
Patch:
@@ -187,7 +187,7 @@ private static Object calculateGuess(JCExpression expr) {
 	 * @param ctcLocation location of the compile time constant
 	 * @param identifier the name of the field of the compile time constant.
 	 */
-	public static int getCTCint(Class<?> ctcLocation, String identifier) {
+	public static int getCtcInt(Class<?> ctcLocation, String identifier) {
 		try {
 			return (Integer)ctcLocation.getField(identifier).get(null);
 		} catch (NoSuchFieldException e) {

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -118,7 +118,7 @@ public class HandleCleanup extends JavacAnnotationHandler<Cleanup> {
 				maker.Apply(List.<JCExpression>nil(), cleanupMethod, List.<JCExpression>nil())));
 		
 		JCMethodInvocation preventNullAnalysis = preventNullAnalysis(maker, annotationNode, maker.Ident(decl.name));
-		JCBinary isNull = maker.Binary(Javac.getCTCint(JCTree.class, "NE"), preventNullAnalysis, maker.Literal(Javac.getCTCint(TypeTags.class, "BOT"), null));
+		JCBinary isNull = maker.Binary(Javac.getCtcInt(JCTree.class, "NE"), preventNullAnalysis, maker.Literal(Javac.getCtcInt(TypeTags.class, "BOT"), null));
 		
 		JCIf ifNotNullCleanup = maker.If(isNull, maker.Block(0, cleanupCall), null);
 		

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -211,7 +211,7 @@ private JCMethodDecl createSetter(long access, JavacNode field, TreeMaker treeMa
 		List<JCAnnotation> annsOnParam = nonNulls.appendList(nullables);
 		JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(Flags.FINAL, annsOnParam), fieldDecl.name, fieldDecl.vartype, null);
 		//WARNING: Do not use field.getSymbolTable().voidType - that field has gone through non-backwards compatible API changes within javac1.6.
-		JCExpression methodType = treeMaker.Type(new JCNoType(Javac.getCTCint(TypeTags.class, "VOID")));
+		JCExpression methodType = treeMaker.Type(new JCNoType(Javac.getCtcInt(TypeTags.class, "VOID")));
 		
 		List<JCTypeParameter> methodGenericParams = List.nil();
 		List<JCVariableDecl> parameters = List.of(param);
@@ -229,8 +229,8 @@ public JCNoType(int tag) {
 		
 		@Override
 		public TypeKind getKind() {
-			if (tag == Javac.getCTCint(TypeTags.class, "VOID")) return TypeKind.VOID;
-			if (tag == Javac.getCTCint(TypeTags.class, "NONE")) return TypeKind.NONE;
+			if (tag == Javac.getCtcInt(TypeTags.class, "VOID")) return TypeKind.VOID;
+			if (tag == Javac.getCtcInt(TypeTags.class, "NONE")) return TypeKind.NONE;
 			throw new AssertionError("Unexpected tag: " + tag);
 		}
 		

File: src/core/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -86,7 +86,7 @@ public class HandleSynchronized extends JavacAnnotationHandler<Synchronized> {
 			JCExpression objectType = chainDots(maker, methodNode, "java", "lang", "Object");
 			//We use 'new Object[0];' because unlike 'new Object();', empty arrays *ARE* serializable!
 			JCNewArray newObjectArray = maker.NewArray(chainDots(maker, methodNode, "java", "lang", "Object"),
-					List.<JCExpression>of(maker.Literal(Javac.getCTCint(TypeTags.class, "INT"), 0)), null);
+					List.<JCExpression>of(maker.Literal(Javac.getCtcInt(TypeTags.class, "INT"), 0)), null);
 			JCVariableDecl fieldDecl = Javac.recursiveSetGeneratedBy(maker.VarDef(
 					maker.Modifiers(Flags.PRIVATE | Flags.FINAL | (isStatic ? Flags.STATIC : 0)),
 					methodNode.toName(lockName), objectType, newObjectArray), ast);

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -566,7 +566,7 @@ public static JCStatement generateNullCheck(TreeMaker treeMaker, JavacNode varia
 		JCExpression npe = chainDots(treeMaker, variable, "java", "lang", "NullPointerException");
 		JCTree exception = treeMaker.NewClass(null, List.<JCExpression>nil(), npe, List.<JCExpression>of(treeMaker.Literal(fieldName.toString())), null);
 		JCStatement throwStatement = treeMaker.Throw(exception);
-		return treeMaker.If(treeMaker.Binary(Javac.getCTCint(JCTree.class, "EQ"), treeMaker.Ident(fieldName), treeMaker.Literal(Javac.getCTCint(TypeTags.class, "BOT"), null)), throwStatement, null);
+		return treeMaker.If(treeMaker.Binary(Javac.getCtcInt(JCTree.class, "EQ"), treeMaker.Ident(fieldName), treeMaker.Literal(Javac.getCtcInt(TypeTags.class, "BOT"), null)), throwStatement, null);
 	}
 	
 	/**

File: src/core/lombok/javac/apt/Javac6BaseFileObjectWrapper.java
Patch:
@@ -33,6 +33,8 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.NestingKind;
 
+// Weird SuppressWarnings, but javac doesn't understand 'all' and eclipse doesn't understand that this file contains deprecation references.
+@SuppressWarnings({"all", "deprecation"})
 class Javac6BaseFileObjectWrapper extends com.sun.tools.javac.util.BaseFileObject {
 	private final LombokFileObject delegate;
 	
@@ -48,7 +50,6 @@ public Javac6BaseFileObjectWrapper(LombokFileObject delegate) {
 		return delegate.toUri();
 	}
 	
-	@SuppressWarnings("all")
 	@Override public String getName() {
 		return delegate.getName();
 	}

File: src/delombok/lombok/delombok/DelombokApp.java
Patch:
@@ -87,7 +87,7 @@ public static Class<?> loadDelombok(List<String> args) throws Exception {
 		final JarFile toolsJarFile = new JarFile(toolsJar);
 		
 		ClassLoader loader = new ClassLoader() {
-			private Class<?>loadStreamAsClass(String name, boolean resolve, InputStream in) throws ClassNotFoundException {
+			private Class<?> loadStreamAsClass(String name, boolean resolve, InputStream in) throws ClassNotFoundException {
 				try {
 					try {
 						byte[] b = new byte[65536];

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -663,9 +663,9 @@ public void visitClassDef(JCClassDecl tree) {
                 else
                     print("class " + tree.name);
                 printTypeParameters(tree.typarams);
-                if (tree.extending != null) {
+                if (tree.getExtendsClause() != null) {
                     print(" extends ");
-                    printExpr(tree.extending);
+                    printExpr(tree.getExtendsClause());
                 }
                 if (tree.implementing.nonEmpty()) {
                     print(" implements ");

File: src/delombok/lombok/delombok/java7/CommentCollectingScanner.java
Patch:
@@ -32,7 +32,7 @@
 
 public class CommentCollectingScanner extends Scanner {
 	private final Comments comments;
-	private int endComment = 0;	
+	private int endComment = 0;
 	
 	public CommentCollectingScanner(CommentCollectingScannerFactory factory, CharBuffer charBuffer, Comments comments) {
 		super(factory, charBuffer);

File: test/transform/resource/before/SetterOnParamAndOnMethod.java
Patch:
@@ -1,3 +0,0 @@
-class SetterOnParamAndOnMethod {
-	@lombok.Setter(onMethod=@Deprecated,onParam=@SuppressWarnings("all")) int i;
-}

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -428,7 +428,8 @@ private static String getExtension(File dir) {
 	}
 	
 	private Writer createFileWriter(File outBase, File inBase, URI file) throws IOException {
-		URI relative = inBase.toURI().relativize(file);
+		URI base = inBase.toURI();
+		URI relative = base.relativize(base.resolve(file));
 		File outFile;
 		if (relative.isAbsolute()) {
 			outFile = new File(outBase, new File(relative).getName());

File: src/core/lombok/eclipse/handlers/HandleCleanup.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.eclipse.handlers;
 
 import static lombok.eclipse.handlers.EclipseHandlerUtil.createNameReference;
+import static lombok.eclipse.handlers.EclipseHandlerUtil.makeIntLiteral;
 
 import java.util.Arrays;
 
@@ -42,7 +43,6 @@
 import org.eclipse.jdt.internal.compiler.ast.EqualExpression;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.IfStatement;
-import org.eclipse.jdt.internal.compiler.ast.IntLiteral;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
@@ -228,7 +228,7 @@ private MessageSend preventNullAnalysis(Annotation ast, Expression expr) {
 		preventNullAnalysis.receiver = singletonList;
 		preventNullAnalysis.selector = "get".toCharArray();
 		
-		preventNullAnalysis.arguments = new Expression[] { new IntLiteral(new char[] { '0' }, pS, pE) };
+		preventNullAnalysis.arguments = new Expression[] { makeIntLiteral("0".toCharArray(), ast) };
 		preventNullAnalysis.nameSourcePosition = p;
 		preventNullAnalysis.sourceStart = pS;
 		preventNullAnalysis.sourceEnd = singletonList.statementEnd = pE;

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -39,7 +39,6 @@
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldReference;
-import org.eclipse.jdt.internal.compiler.ast.IntLiteral;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
@@ -93,8 +92,7 @@ private char[] createLockField(AnnotationValues<Synchronized> annotation, Eclips
 			//We use 'new Object[0];' because unlike 'new Object();', empty arrays *ARE* serializable!
 			ArrayAllocationExpression arrayAlloc = new ArrayAllocationExpression();
 			Eclipse.setGeneratedBy(arrayAlloc, source);
-			arrayAlloc.dimensions = new Expression[] { new IntLiteral(new char[] { '0' }, 0, 0) };
-			Eclipse.setGeneratedBy(arrayAlloc.dimensions[0], source);
+			arrayAlloc.dimensions = new Expression[] { makeIntLiteral("0".toCharArray(), source) };
 			arrayAlloc.type = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, new long[] { 0, 0, 0 });
 			Eclipse.setGeneratedBy(arrayAlloc.type, source);
 			fieldDecl.type = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, new long[] { 0, 0, 0 });

File: src/core/lombok/eclipse/EclipseNode.java
Patch:
@@ -111,7 +111,7 @@ public void traverse(EclipseASTVisitor visitor) {
 				visitor.visitAnnotationOnLocal((LocalDeclaration)parent.get(), this, (Annotation)get());
 				break;
 			default:
-				throw new AssertionError("Annotion not expected as child of a " + up().getKind());
+				throw new AssertionError("Annotation not expected as child of a " + up().getKind());
 			}
 			break;
 		case STATEMENT:

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -81,6 +81,7 @@ public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	
 	private static final List<String> METHODS_IN_OBJECT = Collections.unmodifiableList(Arrays.asList(
 			"hashCode()",
+			"canEqual(java.lang.Object)",  //Not in j.l.Object, but it goes with hashCode and equals so if we ignore those two, we should ignore this one.
 			"equals(java.lang.Object)",
 			"wait()",
 			"wait(long)",

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -136,7 +136,7 @@ private void generateMethods(JavacNode typeNode, JavacNode source, List<String>
 			}
 		}
 		
-		JCTree extending = ((JCClassDecl)typeNode.get()).extending;
+		JCTree extending = ((JCClassDecl)typeNode.get()).getExtendsClause();
 		if (extending != null) {
 			String p = extending.toString();
 			isDirectDescendantOfObject = p.equals("Object") || p.equals("java.lang.Object");

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -100,7 +100,9 @@ private char[] createLockField(AnnotationValues<Synchronized> annotation, Eclips
 			fieldDecl.type = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, new long[] { 0, 0, 0 });
 			Eclipse.setGeneratedBy(fieldDecl.type, source);
 			fieldDecl.initialization = arrayAlloc;
-			injectFieldSuppressWarnings(annotationNode.up().up(), fieldDecl);
+			// TODO temporary workaround for issue 217. http://code.google.com/p/projectlombok/issues/detail?id=217
+			// injectFieldSuppressWarnings(annotationNode.up().up(), fieldDecl);
+			injectField(annotationNode.up().up(), fieldDecl);
 		}
 		
 		return lockName;

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -175,7 +175,7 @@ public static void main(String[] rawArgs) {
 		
 		try {
 			for (String in : args.input) {
-				File f = new File(in);
+				File f = new File(in).getAbsoluteFile();
 				if (f.isFile()) {
 					delombok.addFile(f.getParentFile(), f.getName());
 				} else if (f.isDirectory()) {
@@ -332,7 +332,7 @@ private void copy(boolean copy, File base, String fileName) throws IOException {
 			in.close();
 		}
 	}
-
+	
 	public void addFile(File base, String fileName) throws IOException {
 		if (output != null && canonical(base).equals(canonical(output))) throw new IOException(
 				"DELOMBOK: Output file and input file refer to the same filesystem location. Specify a separate path for output.");

File: test/core/src/lombok/RunTestsViaDelombok.java
Patch:
@@ -53,8 +53,8 @@ public void transformCode(final StringBuilder messages, StringWriter result, fin
 			}
 		});
 		
-		delombok.addFile(file.getParentFile(), file.getName());
-		delombok.setSourcepath(file.getParentFile().getAbsolutePath());
+		delombok.addFile(file.getAbsoluteFile().getParentFile(), file.getName());
+		delombok.setSourcepath(file.getAbsoluteFile().getParent());
 		delombok.setWriter(result);
 		delombok.delombok();
 	}

File: src/core/lombok/core/debug/DebugSnapshot.java
Patch:
@@ -43,7 +43,7 @@ private String ownerName() {
 	public String shortToString() {
 		StringBuilder out = new StringBuilder();
 		out.append(String.format("WHEN: %14d THREAD: %s AST: %s", when, threadName, ownerName()));
-		if (message != null) out.append(String.format(message, params));
+		if (message != null) out.append(" ").append(String.format(message, params));
 		return out.toString();
 	}
 	

File: src/core/lombok/javac/apt/InterceptingJavaFileManager.java
Patch:
@@ -43,12 +43,12 @@ final class InterceptingJavaFileManager extends ForwardingJavaFileManager<JavaFi
 	@Override public JavaFileObject getJavaFileForOutput(Location location, String className, final Kind kind, FileObject sibling) throws IOException {
 		if (className.startsWith("lombok.dummy.ForceNewRound")) {
 			final String name = className.replace(".", "/") + kind.extension;
-			return LombokFileObjects.createEmpty(fileManager, name, kind);
+			return LombokFileObjects.createEmpty(name, kind);
 		}
 		JavaFileObject fileObject = fileManager.getJavaFileForOutput(location, className, kind, sibling);
 		if (kind != Kind.CLASS) {
 			return fileObject;
 		}
-		return LombokFileObjects.createIntercepting(fileManager, fileObject, className, diagnostics);
+		return LombokFileObjects.createIntercepting(fileObject, className, diagnostics);
 	}
 }
\ No newline at end of file

File: src/core/lombok/javac/apt/Javac7BaseFileObjectWrapper.java
Patch:
@@ -36,8 +36,8 @@
 class Javac7BaseFileObjectWrapper extends com.sun.tools.javac.file.BaseFileObject {
 	private final LombokFileObject delegate;
 	
-	public Javac7BaseFileObjectWrapper(com.sun.tools.javac.file.JavacFileManager jfm, LombokFileObject delegate) {
-		super(jfm);
+	public Javac7BaseFileObjectWrapper(LombokFileObject delegate) {
+		super(null);
 		this.delegate = delegate;
 	}
 	

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -292,7 +292,7 @@ public static boolean nameEquals(char[][] typeName, String string) {
 	
 	/** Serves as return value for the methods that check for the existence of fields and methods. */
 	public enum MemberExistsResult {
-		NOT_EXISTS, EXISTS_BY_USER, EXISTS_BY_LOMBOK;
+		NOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;
 	}
 	
 	/**

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -185,7 +185,7 @@ public static String toSetterName(JCVariableDecl field) {
 	
 	/** Serves as return value for the methods that check for the existence of fields and methods. */
 	public enum MemberExistsResult {
-		NOT_EXISTS, EXISTS_BY_USER, EXISTS_BY_LOMBOK;
+		NOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;
 	}
 	
 	/**

File: test/pretty/resource/after/Enum.java
Patch:
@@ -3,6 +3,7 @@ enum Ranks {
 	HEARTS,
 	DIAMONDS,
 	SPADES;
+	;
 }
 enum Complex {
 	RED("ff0000"),

File: test/pretty/resource/before/Enum.java
Patch:
@@ -1,5 +1,5 @@
 enum Ranks {
-	CLUBS, HEARTS, DIAMONDS, SPADES
+	CLUBS, HEARTS, DIAMONDS, SPADES;;
 }
 
 enum Complex {

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -82,7 +82,7 @@ private char[] createLockField(AnnotationValues<Synchronized> annotation, Eclips
 		if (fieldExists(new String(lockName), annotationNode) == MemberExistsResult.NOT_EXISTS) {
 			if (!autoMake) {
 				if (reportErrors) annotationNode.addError(String.format("The field %s does not exist.", new String(lockName)));
-				return lockName;
+				return null;
 			}
 			FieldDeclaration fieldDecl = new FieldDeclaration(lockName, 0, -1);
 			Eclipse.setGeneratedBy(fieldDecl, source);
@@ -123,6 +123,7 @@ private char[] createLockField(AnnotationValues<Synchronized> annotation, Eclips
 		}
 		
 		char[] lockName = createLockField(annotation, annotationNode, method.isStatic(), true);
+		if (lockName == null) return;
 		if (method.statements == null) return;
 		
 		Block block = new Block(0);

File: src/core/lombok/Synchronized.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2009-2011 Reinier Zwitserloot and Roel Spilker.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/eclipse/handlers/HandlePrintAST.java
Patch:
@@ -39,7 +39,7 @@
  * Handles the {@code lombok.core.PrintAST} annotation for eclipse.
  */
 @ProviderFor(EclipseAnnotationHandler.class)
-public class HandlePrintAST implements EclipseAnnotationHandler<PrintAST> {
+public class HandlePrintAST extends EclipseAnnotationHandler<PrintAST> {
 	@Override public boolean deferUntilPostDiet() {
 		return true;
 	}

File: src/core/lombok/eclipse/handlers/HandleSneakyThrows.java
Patch:
@@ -54,7 +54,7 @@
  * Handles the {@code lombok.HandleSneakyThrows} annotation for eclipse.
  */
 @ProviderFor(EclipseAnnotationHandler.class)
-public class HandleSneakyThrows implements EclipseAnnotationHandler<SneakyThrows> {
+public class HandleSneakyThrows extends EclipseAnnotationHandler<SneakyThrows> {
 	private static class DeclaredException {
 		final String exceptionName;
 		final ASTNode node;

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -53,7 +53,7 @@
  * Handles the {@code lombok.Synchronized} annotation for eclipse.
  */
 @ProviderFor(EclipseAnnotationHandler.class)
-public class HandleSynchronized implements EclipseAnnotationHandler<Synchronized> {
+public class HandleSynchronized extends EclipseAnnotationHandler<Synchronized> {
 	private static final char[] INSTANCE_LOCK_NAME = "$lock".toCharArray();
 	private static final char[] STATIC_LOCK_NAME = "$LOCK".toCharArray();
 	

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -74,7 +74,7 @@
 import com.sun.tools.javac.util.Name;
 
 @ProviderFor(JavacAnnotationHandler.class)
-public class HandleDelegate implements JavacAnnotationHandler<Delegate> {
+public class HandleDelegate extends JavacAnnotationHandler<Delegate> {
 	@Override public boolean isResolutionBased() {
 		return true;
 	}

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -101,7 +101,7 @@ public static EclipseAST getAST(CompilationUnitDeclaration ast, boolean forceReb
 			} catch (Exception ignore) {
 			}
 		} else {
-			existing.reparse(forceRebuild);
+			existing.rebuild(forceRebuild);
 		}
 		
 		return existing;

File: src/core/lombok/eclipse/handlers/HandlePrintAST.java
Patch:
@@ -41,12 +41,10 @@
 @ProviderFor(EclipseAnnotationHandler.class)
 public class HandlePrintAST implements EclipseAnnotationHandler<PrintAST> {
 	@Override public boolean deferUntilPostDiet() {
-		return false;
+		return true;
 	}
 	
 	public void handle(AnnotationValues<PrintAST> annotation, Annotation ast, EclipseNode annotationNode) {
-		if (!annotationNode.isCompleteParse()) return;
-		
 		PrintStream stream = System.out;
 		String fileName = annotation.getInstance().outfile();
 		if (fileName.length() > 0) try {

File: src/core/lombok/bytecode/SneakyThrowsRemover.java
Patch:
@@ -147,7 +147,7 @@ class SneakyThrowsRemoverVisitor extends MethodAdapter {
 				return super.visitParameterAnnotation(parameter, desc, visible);
 			}
 			
-			@Override public void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels) {
+			@Override public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
 				justAddedAthrow = false;
 				super.visitTableSwitchInsn(min, max, dflt, labels);
 			}

File: src/core/lombok/eclipse/EclipseNode.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009-2010 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2009-2011 Reinier Zwitserloot and Roel Spilker.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -50,6 +50,8 @@ public class EclipseNode extends lombok.core.LombokNode<EclipseAST, EclipseNode,
 	 * Visits this node and all child nodes depth-first, calling the provided visitor's visit methods.
 	 */
 	public void traverse(EclipseASTVisitor visitor) {
+		if (!this.isCompleteParse() && visitor.deferUntilPostDiet()) return;
+		
 		switch (getKind()) {
 		case COMPILATION_UNIT:
 			visitor.visitCompilationUnit(this, (CompilationUnitDeclaration)get());

File: src/core/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -82,7 +82,7 @@ public class HandleSynchronized implements EclipseAnnotationHandler<Synchronized
 		
 		if (fieldExists(new String(lockName), methodNode) == MemberExistsResult.NOT_EXISTS) {
 			if (!autoMake) {
-				annotationNode.addError("The field " + new String(lockName) + " does not exist.");
+				annotationNode.addError(String.format("The field %s does not exist.", new String(lockName)));
 				return;
 			}
 			FieldDeclaration fieldDecl = new FieldDeclaration(lockName, 0, -1);
@@ -91,7 +91,7 @@ public class HandleSynchronized implements EclipseAnnotationHandler<Synchronized
 			
 			fieldDecl.modifiers = (method.isStatic() ? Modifier.STATIC : 0) | Modifier.FINAL | Modifier.PRIVATE;
 			
-			//We use 'new Object[0];' because quite unlike 'new Object();', empty arrays *ARE* serializable!
+			//We use 'new Object[0];' because unlike 'new Object();', empty arrays *ARE* serializable!
 			ArrayAllocationExpression arrayAlloc = new ArrayAllocationExpression();
 			Eclipse.setGeneratedBy(arrayAlloc, source);
 			arrayAlloc.dimensions = new Expression[] { new IntLiteral(new char[] { '0' }, 0, 0) };

File: test/core/src/lombok/DirectoryRunner.java
Patch:
@@ -37,7 +37,7 @@
 
 public class DirectoryRunner extends Runner {
 	public enum Compiler {
-		DELOMBOK, JAVAC, ECJ;
+		DELOMBOK, JAVAC, ECJ, ECLIPSE;
 	}
 	
 	public interface TestParams {
@@ -119,6 +119,8 @@ private boolean runTest(String fileName) throws Throwable {
 		switch (params.getCompiler()) {
 		case DELOMBOK:
 			return new RunTestsViaDelombok().compareFile(params, file);
+		case ECLIPSE:
+			return new RunTestsViaEclipse().compareFile(params, file);
 		case ECJ:
 			return new RunTestsViaEcj().compareFile(params, file);
 		default:

File: test/transform/resource/after-eclipse/LoggerSlf4jWithPackage.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValComplex.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValErrors.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValInFor.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValLessSimple.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValSimple.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-eclipse/ValWeirdTypes.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/javac/handlers/HandleDelegate.java
Patch:
@@ -21,6 +21,8 @@
  */
 package lombok.javac.handlers;
 
+import static lombok.javac.handlers.JavacHandlerUtil.markAnnotationAsProcessed;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -90,6 +92,7 @@ public class HandleDelegate implements JavacAnnotationHandler<Delegate> {
 			"finalize()"));
 	
 	@Override public boolean handle(AnnotationValues<Delegate> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, Delegate.class);
 		if (annotationNode.up().getKind() != Kind.FIELD) {
 			// As the annotation is legal on fields only, javac itself will take care of printing an error message for this.
 			return false;

File: test/transform/resource/after-ecj/DelegateTypesAndExcludes.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -53,7 +53,7 @@ public class TransformEclipseAST {
 	private static final Field astCacheField;
 	private static final HandlerLibrary handlers;
 	
-	private static boolean disableLombok = false;
+	public static boolean disableLombok = false;
 	
 	static {
 		Field f = null;

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -102,6 +102,8 @@ private static String nameOfScope(ClassScope scope) {
 	}
 	
 	public static boolean handleDelegateForType(ClassScope scope) {
+		if (TransformEclipseAST.disableLombok) return false;
+		
 		List<ClassScopeEntry> stack = visited.get();
 		StringBuilder corrupted = null;
 		for (ClassScopeEntry entry : stack) {

File: src/installer/lombok/installer/eclipse/EclipseFinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2009-2011 Reinier Zwitserloot, Roel Spilker and Robbert Jan Grootjans.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/installer/lombok/installer/eclipse/EclipseLocationProvider.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2009-2011 Reinier Zwitserloot, Roel Spilker and Robbert Jan Grootjans.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -336,18 +336,18 @@ private static void addPatchesForValEclipse(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.wrapReturnValue()
 				.target(new MethodTarget(PARSER_SIG, "consumeExitVariableWithInitialization", "void"))
 				.request(StackRequest.THIS)
-				.wrapMethod(new Hook("lombok.eclipse.agent.PatchVal", "copyInitializationOfLocalDeclaration", "void", PARSER_SIG))
+				.wrapMethod(new Hook("lombok.eclipse.agent.PatchValEclipse", "copyInitializationOfLocalDeclaration", "void", PARSER_SIG))
 				.build());
 		
 		sm.addScript(ScriptBuilder.wrapReturnValue()
 				.target(new MethodTarget(PARSER_SIG, "consumeEnhancedForStatementHeader", "void"))
 				.request(StackRequest.THIS)
-				.wrapMethod(new Hook("lombok.eclipse.agent.PatchVal", "copyInitializationOfForEachIterable", "void", PARSER_SIG))
+				.wrapMethod(new Hook("lombok.eclipse.agent.PatchValEclipse", "copyInitializationOfForEachIterable", "void", PARSER_SIG))
 				.build());
 		
 		sm.addScript(ScriptBuilder.wrapReturnValue()
 				.target(new MethodTarget(ASTCONVERTER_SIG, "setModifiers", "void", VARIABLEDECLARATIONSTATEMENT_SIG, LOCALDECLARATION_SIG))
-				.wrapMethod(new Hook("lombok.eclipse.agent.PatchVal", "addFinalAndValAnnotationToVariableDeclarationStatement",
+				.wrapMethod(new Hook("lombok.eclipse.agent.PatchValEclipse", "addFinalAndValAnnotationToVariableDeclarationStatement",
 						"void", "java.lang.Object", VARIABLEDECLARATIONSTATEMENT_SIG, LOCALDECLARATION_SIG))
 				.transplant().request(StackRequest.THIS, StackRequest.PARAM1, StackRequest.PARAM2).build());
 	}

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -35,7 +35,6 @@
 import org.eclipse.jdt.core.IAnnotatable;
 import org.eclipse.jdt.core.IAnnotation;
 import org.eclipse.jdt.core.IMethod;
-import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.dom.SimpleName;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 
@@ -144,7 +143,7 @@ public static Annotation[] convertAnnotations(Annotation[] out, IAnnotatable ann
 		
 		try {
 			in = annotatable.getAnnotations();
-		} catch (JavaModelException e) {
+		} catch (Exception e) {
 			return out;
 		}
 		

File: src/core/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -103,7 +103,7 @@ private static void loadAnnotationHandlers(HandlerLibrary lib) {
 						SpiLoadUtil.findAnnotationClass(handler.getClass(), EclipseAnnotationHandler.class);
 					AnnotationHandlerContainer<?> container = new AnnotationHandlerContainer(handler, annotationClass);
 					if (lib.annotationHandlers.put(container.annotationClass.getName(), container) != null) {
-						Eclipse.error(null, "Duplicate handlers for annotation type: " + container.annotationClass.getName());
+						Eclipse.error(null, "Duplicate handlers for annotation type: " + container.annotationClass.getName(), null);
 					}
 					lib.typeLibrary.addType(container.annotationClass.getName());
 				} catch (Throwable t) {

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -74,7 +74,6 @@
 import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
-import org.eclipse.jdt.internal.compiler.lookup.MemberTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -475,7 +474,7 @@ private static void addAllMethodBindings(List<BindingPair> list, TypeBinding bin
 			inner = binding;
 		}
 		
-		if (inner instanceof MemberTypeBinding) {
+		if (inner instanceof SourceTypeBinding) {
 			ClassScope cs = ((SourceTypeBinding)inner).scope;
 			if (cs != null) {
 				try {
@@ -527,6 +526,7 @@ private static final class BindingPair {
 	
 	private static final List<String> METHODS_IN_OBJECT = Collections.unmodifiableList(Arrays.asList(
 			"hashCode()",
+			"canEqual(java.lang.Object)",  //Not in j.l.Object, but it goes with hashCode and equals so if we ignore those two, we should ignore this one.
 			"equals(java.lang.Object)",
 			"wait()",
 			"wait(long)",

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -427,9 +427,6 @@ argName, pos(source),
 			if (isVarargs) {
 				method.arguments[method.arguments.length - 1].type.bits |= ASTNode.IsVarArgs;
 			}
-			for (int i = 0; i < method.arguments.length; i++) {
-				System.out.printf("Positions of marg type: %d %d\n", method.arguments[i].sourceStart(), method.arguments[i].sourceEnd());
-			}
 		}
 		
 		Statement body;

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -208,6 +208,9 @@ private static void addConstructorProperties(JCModifiers mods, JavacNode node, L
 	private JCMethodDecl createConstructor(AccessLevel level, JavacNode typeNode, List<JavacNode> fields, boolean suppressConstructorProperties) {
 		TreeMaker maker = typeNode.getTreeMaker();
 		
+		boolean isEnum = (((JCClassDecl) typeNode.get()).mods.flags & Flags.ENUM) != 0;
+		if (isEnum) level = AccessLevel.PRIVATE;
+		
 		ListBuffer<JCStatement> nullChecks = ListBuffer.lb();
 		ListBuffer<JCStatement> assigns = ListBuffer.lb();
 		ListBuffer<JCVariableDecl> params = ListBuffer.lb();

File: test/transform/resource/after-delombok/DataExtended.java
Patch:
@@ -17,7 +17,7 @@ public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof DataExtended)) return false;
 		final DataExtended other = (DataExtended)o;
-		if (!other.canEqual(this)) return false;
+		if (!other.canEqual((java.lang.Object)this)) return false;
 		if (this.getX() != other.getX()) return false;
 		return true;
 	}

File: test/transform/resource/after-delombok/DataIgnore.java
Patch:
@@ -16,7 +16,7 @@ public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof DataIgnore)) return false;
 		final DataIgnore other = (DataIgnore)o;
-		if (!other.canEqual(this)) return false;
+		if (!other.canEqual((java.lang.Object)this)) return false;
 		if (this.getX() != other.getX()) return false;
 		return true;
 	}

File: test/transform/resource/after-delombok/DataWithGetter.java
Patch:
@@ -21,10 +21,10 @@ public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof DataWithGetter)) return false;
 		final DataWithGetter other = (DataWithGetter)o;
-		if (!other.canEqual(this)) return false;
+		if (!other.canEqual((java.lang.Object)this)) return false;
 		if (this.getX() != other.getX()) return false;
 		if (this.getY() != other.getY()) return false;
-		if (this.getZ() == null ? other.getZ() != null : !this.getZ().equals(other.getZ())) return false;
+		if (this.getZ() == null ? other.getZ() != null : !this.getZ().equals((java.lang.Object)other.getZ())) return false;
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/DataWithGetterNone.java
Patch:
@@ -21,10 +21,10 @@ public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof DataWithGetterNone)) return false;
 		final DataWithGetterNone other = (DataWithGetterNone)o;
-		if (!other.canEqual(this)) return false;
+		if (!other.canEqual((java.lang.Object)this)) return false;
 		if (this.x != other.x) return false;
 		if (this.y != other.y) return false;
-		if (this.z == null ? other.z != null : !this.z.equals(other.z)) return false;
+		if (this.z == null ? other.z != null : !this.z.equals((java.lang.Object)other.z)) return false;
 		return true;
 	}
 	@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/GetterLazyEahcToString.java
Patch:
@@ -9,9 +9,9 @@ public boolean equals(final java.lang.Object o) {
 		if (o == this) return true;
 		if (!(o instanceof GetterLazyEahcToString)) return false;
 		final GetterLazyEahcToString other = (GetterLazyEahcToString)o;
-		if (!other.canEqual(this)) return false;
-		if (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue())) return false;
-		if (this.value2 == null ? other.value2 != null : !this.value2.equals(other.value2)) return false;
+		if (!other.canEqual((java.lang.Object)this)) return false;
+		if (this.getValue() == null ? other.getValue() != null : !this.getValue().equals((java.lang.Object)other.getValue())) return false;
+		if (this.value2 == null ? other.value2 != null : !this.value2.equals((java.lang.Object)other.value2)) return false;
 		return true;
 	}
 	

File: test/transform/resource/after-ecj/DataExtended.java
Patch:
@@ -15,7 +15,7 @@
     if ((! (o instanceof DataExtended)))
         return false;
     final DataExtended other = (DataExtended) o;
-    if ((! other.canEqual(this)))
+    if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))
         return false;

File: test/transform/resource/after-ecj/DataIgnore.java
Patch:
@@ -14,7 +14,7 @@
     if ((! (o instanceof DataIgnore)))
         return false;
     final DataIgnore other = (DataIgnore) o;
-    if ((! other.canEqual(this)))
+    if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))
         return false;

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -18,13 +18,13 @@
     if ((! (o instanceof DataWithGetter)))
         return false;
     final DataWithGetter other = (DataWithGetter) o;
-    if ((! other.canEqual(this)))
+    if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.getX() != other.getX()))
         return false;
     if ((this.getY() != other.getY()))
         return false;
-    if (((this.getZ() == null) ? (other.getZ() != null) : (! this.getZ().equals(other.getZ()))))
+    if (((this.getZ() == null) ? (other.getZ() != null) : (! this.getZ().equals((java.lang.Object) other.getZ()))))
         return false;
     return true;
   }

File: test/transform/resource/after-ecj/DataWithGetterNone.java
Patch:
@@ -18,13 +18,13 @@
     if ((! (o instanceof DataWithGetterNone)))
         return false;
     final DataWithGetterNone other = (DataWithGetterNone) o;
-    if ((! other.canEqual(this)))
+    if ((! other.canEqual((java.lang.Object) this)))
         return false;
     if ((this.x != other.x))
         return false;
     if ((this.y != other.y))
         return false;
-    if (((this.z == null) ? (other.z != null) : (! this.z.equals(other.z))))
+    if (((this.z == null) ? (other.z != null) : (! this.z.equals((java.lang.Object) other.z))))
         return false;
     return true;
   }

File: test/transform/resource/after-ecj/GetterLazyEahcToString.java
Patch:
@@ -26,11 +26,11 @@
     if ((! (o instanceof GetterLazyEahcToString)))
         return false;
     final GetterLazyEahcToString other = (GetterLazyEahcToString) o;
-    if ((! other.canEqual(this)))
+    if ((! other.canEqual((java.lang.Object) this)))
         return false;
-    if (((this.getValue() == null) ? (other.getValue() != null) : (! this.getValue().equals(other.getValue()))))
+    if (((this.getValue() == null) ? (other.getValue() != null) : (! this.getValue().equals((java.lang.Object) other.getValue()))))
         return false;
-    if (((this.value2 == null) ? (other.value2 != null) : (! this.value2.equals(other.value2))))
+    if (((this.value2 == null) ? (other.value2 != null) : (! this.value2.equals((java.lang.Object) other.value2))))
         return false;
     return true;
   }

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -366,6 +366,7 @@ public boolean delombok() throws IOException {
 		
 		for (File fileToParse : filesToParse) {
 			Comments comments = new Comments();
+			context.put(Comments.class, (Comments) null);
 			context.put(Comments.class, comments);
 			
 			@SuppressWarnings("deprecation")

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -298,6 +298,8 @@ public static boolean filterField(FieldDeclaration declaration) {
 		if (declaration.initialization instanceof AllocationExpression &&
 				((AllocationExpression)declaration.initialization).enumConstant != null) return false;
 		
+		if (declaration.type == null) return false;
+		
 		// Skip fields that start with $
 		if (declaration.name.length > 0 && declaration.name[0] == '$') return false;
 		

File: src/core/lombok/eclipse/EclipseAST.java
Patch:
@@ -196,12 +196,12 @@ private static String toFileName(CompilationUnitDeclaration ast) {
 	 * with filled in method bodies and such. Also propagates problems and errors, which in diet parse
 	 * mode can't be reliably added to the problems/warnings view.
 	 */
-	public void reparse() {
+	public void reparse(boolean forceRebuild) {
 		propagateProblems();
-		if (completeParse) return;
+		if (completeParse && !forceRebuild) return;
 		boolean changed = isChanged();
 		boolean newCompleteParse = isComplete(compilationUnitDeclaration);
-		if (!newCompleteParse) return;
+		if (!newCompleteParse && !forceRebuild) return;
 		
 		top().rebuild();
 		

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -84,7 +84,7 @@ public static void transform_swapped(CompilationUnitDeclaration ast, Parser pars
 		transform(parser, ast);
 	}
 	
-	public static EclipseAST getAST(CompilationUnitDeclaration ast) {
+	public static EclipseAST getAST(CompilationUnitDeclaration ast, boolean forceRebuild) {
 		EclipseAST existing = null;
 		if (astCacheField != null) {
 			try {
@@ -101,7 +101,7 @@ public static EclipseAST getAST(CompilationUnitDeclaration ast) {
 			} catch (Exception ignore) {
 			}
 		} else {
-			existing.reparse();
+			existing.reparse(forceRebuild);
 		}
 		
 		return existing;
@@ -126,7 +126,7 @@ public static void transform(Parser parser, CompilationUnitDeclaration ast) {
 		// Do NOT abort if (ast.bits & ASTNode.HasAllMethodBodies) != 0 - that doesn't work.
 		
 		try {
-			EclipseAST existing = getAST(ast);
+			EclipseAST existing = getAST(ast, false);
 			new TransformEclipseAST(existing).go();
 		} catch (Throwable t) {
 			try {

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -113,7 +113,7 @@ public static boolean handleDelegateForType(ClassScope scope) {
 				
 				if (cud == null) {
 					cud = scope.compilationUnitScope().referenceContext;
-					eclipseAst = TransformEclipseAST.getAST(cud);
+					eclipseAst = TransformEclipseAST.getAST(cud, true);
 				}
 				
 				List<ClassLiteralAccess> rawTypes = new ArrayList<ClassLiteralAccess>();

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -85,10 +85,10 @@ public boolean generateGetterForType(JavacNode typeNode, JavacNode errorNode, Ac
 		JCClassDecl typeDecl = null;
 		if (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();
 		long modifiers = typeDecl == null ? 0 : typeDecl.mods.flags;
-		boolean notAClass = (modifiers & (Flags.INTERFACE | Flags.ANNOTATION | Flags.ENUM)) != 0;
+		boolean notAClass = (modifiers & (Flags.INTERFACE | Flags.ANNOTATION)) != 0;
 		
 		if (typeDecl == null || notAClass) {
-			errorNode.addError("@Getter is only supported on a class or a field.");
+			errorNode.addError("@Getter is only supported on a class, an enum, or a field.");
 			return false;
 		}
 		

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -117,7 +117,7 @@ private boolean generateToString(JavacNode typeNode, JavacNode errorNode, List<S
 		boolean notAClass = true;
 		if (typeNode.get() instanceof JCClassDecl) {
 			long flags = ((JCClassDecl)typeNode.get()).mods.flags;
-			notAClass = (flags & (Flags.INTERFACE | Flags.ANNOTATION | Flags.ENUM)) != 0;
+			notAClass = (flags & (Flags.INTERFACE | Flags.ANNOTATION)) != 0;
 		}
 		
 		if (callSuper == null) {
@@ -127,7 +127,7 @@ private boolean generateToString(JavacNode typeNode, JavacNode errorNode, List<S
 		}
 		
 		if (notAClass) {
-			errorNode.addError("@ToString is only supported on a class.");
+			errorNode.addError("@ToString is only supported on a class or enum.");
 			return false;
 		}
 		

File: src/core/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -123,6 +123,8 @@ public static void transform(Parser parser, CompilationUnitDeclaration ast) {
 		
 		if (Symbols.hasSymbol("lombok.disable")) return;
 		
+		// Do NOT abort if (ast.bits & ASTNode.HasAllMethodBodies) != 0 - that doesn't work.
+		
 		try {
 			EclipseAST existing = getAST(ast);
 			new TransformEclipseAST(existing).go();

File: src/core/lombok/val.java
Patch:
@@ -25,5 +25,7 @@
  * Use {@code val} as the type of any local variable declaration (even in a for-each statement), and the type will be inferred from the initializing expression.
  * For example: {@code val x = 10.0;} will infer {@code double}, and {@code val y = new ArrayList<String>();} will infer {@code ArrayList<String>}. The local variable
  * will also be made final.
+ * 
+ * Note that this is an interface because {@code val x = 10;} will be desugared to <code>&#64;val int x = 10;</code>
  */
-public class val {}
+public @interface val {}

File: src/core/lombok/core/LombokNode.java
Patch:
@@ -289,9 +289,9 @@ public void rebuild() {
 		ast.replaceNewWithExistingOld(oldNodes, newNode);
 	}
 	
-	@SuppressWarnings("unchecked")
+	@SuppressWarnings({"unchecked", "rawtypes"})
 	private void gatherAndRemoveChildren(Map<N, L> map) {
-		for (L child : children) child.gatherAndRemoveChildren(map);
+		for (LombokNode child : children) child.gatherAndRemoveChildren(map);
 		ast.identityDetector.remove(get());
 		map.put(get(), (L) this);
 		children.clear();

File: src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java
Patch:
@@ -26,7 +26,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -72,7 +71,6 @@
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 
 public class PatchDelegate {
 	static void addPatches(ScriptManager sm, boolean ecj) {

File: src/core/lombok/javac/HandlerLibrary.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2009-2010 Reinier Zwitserloot and Roel Spilker.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -172,6 +172,7 @@ public boolean handleAnnotation(JCCompilationUnit unit, JavacNode node, JCAnnota
 			try {
 				if (container.isResolutionBased() && phase == 1) handled |= container.handle(node);
 				if (!container.isResolutionBased() && phase == 0) handled |= container.handle(node);
+				if (container.annotationClass == PrintAST.class && phase == 2) handled |= container.handle(node);
 			} catch (AnnotationValueDecodeFail fail) {
 				fail.owner.setError(fail.getMessage(), fail.idx);
 			} catch (Throwable t) {

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -71,14 +71,14 @@ public class HandleVal extends JavacASTAdapter {
 				if (rhsOfEnhancedForLoop == null) {
 					if (local.init.type == null) {
 						JavacResolution resolver = new JavacResolution(localNode.getContext());
-						type = ((JCExpression) resolver.resolve(localNode).get(local.init)).type;
+						type = ((JCExpression) resolver.resolveMethodMember(localNode).get(local.init)).type;
 					} else {
 						type = local.init.type;
 					}
 				} else {
 					if (rhsOfEnhancedForLoop.type == null) {
 						JavacResolution resolver = new JavacResolution(localNode.getContext());
-						type = ((JCExpression) resolver.resolve(localNode.directUp()).get(rhsOfEnhancedForLoop)).type;
+						type = ((JCExpression) resolver.resolveMethodMember(localNode.directUp()).get(rhsOfEnhancedForLoop)).type;
 					} else {
 						type = rhsOfEnhancedForLoop.type;
 					}

File: src/core/lombok/core/Version.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
-	private static final String VERSION = "0.10.0-BETA1";
+	private static final String VERSION = "0.10.0-BETA2";
 	private static final String RELEASE_NAME = "Burning Emu";
 	
 	private Version() {

File: test/core/src/lombok/RunTestsViaDelombok.java
Patch:
@@ -45,7 +45,9 @@ public void transformCode(final StringBuilder messages, StringWriter result, fin
 		delombok.setDiagnosticsListener(new DiagnosticListener<JavaFileObject>() {
 			@Override public void report(Diagnostic<? extends JavaFileObject> d) {
 				String msg = d.getMessage(Locale.ENGLISH);
-				Matcher m = Pattern.compile("^" + Pattern.quote(file.getAbsolutePath()) + "\\s*:\\s*\\d+\\s*:\\s*(?:warning:\\s*)?(.*)$").matcher(msg);
+				Matcher m = Pattern.compile(
+						"^" + Pattern.quote(file.getAbsolutePath()) +
+						"\\s*:\\s*\\d+\\s*:\\s*(?:warning:\\s*)?(.*)$", Pattern.DOTALL).matcher(msg);
 				if (m.matches()) msg = m.group(1);
 				messages.append(String.format("%d:%d %s %s\n", d.getLineNumber(), d.getColumnNumber(), d.getKind(), msg));
 			}

File: src/core/lombok/eclipse/handlers/HandleVal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009-2010 Reinier Zwitserloot, Roel Spilker and Robbert Jan Grootjans.
+ * Copyright © 2010 Reinier Zwitserloot, Roel Spilker and Robbert Jan Grootjans.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -325,6 +325,8 @@ private static JCExpression typeToJCTree0(Type type, TreeMaker maker, JavacAST a
 		// NB: There's such a thing as maker.Type(type), but this doesn't work very well; it screws up anonymous classes, captures, and adds an extra prefix dot for some reason too.
 		//  -- so we write our own take on that here.
 		
+		if (type.tag == TypeTags.BOT) return createJavaLangObject(maker, ast);
+		
 		if (type.isPrimitive()) return primitiveToJCTree(type.getKind(), maker);
 		if (type.isErroneous()) throw new TypeNotConvertibleException("Type cannot be resolved");
 		

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2010 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2010 Reinier Zwitserloot, Roel Spilker and Robbert Jan Grootjans.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal

File: test/pretty/resource/after/Annotation.java
Patch:
@@ -6,7 +6,7 @@ public String toString() {
 	}
 	public void method(@SuppressWarnings("unused") int x) {
 	}
-	public void method2(@SuppressWarnings(value = {"unused"}) int y) {
+	public void method2(@SuppressWarnings({"unused"}) int y) {
 	}
 	public void method3(@SuppressWarnings({"unused", "unchecked"}) int z) {
 	}

File: test/pretty/resource/before/Annotation.java
Patch:
@@ -1,4 +1,3 @@
-//ignore
 @SuppressWarnings("all")
 class Annotation {
 	@Override

File: test/transform/resource/after-ecj/ValComplex.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/ValErrors.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/ValInFor.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/ValLessSimple.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/ValSimple.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: test/transform/resource/after-ecj/ValWeirdTypes.java
Patch:
@@ -0,0 +1 @@
+//ignore
\ No newline at end of file

File: src/core/lombok/javac/JavacResolution.java
Patch:
@@ -325,6 +325,8 @@ private static JCExpression typeToJCTree0(Type type, TreeMaker maker, JavacAST a
 		// NB: There's such a thing as maker.Type(type), but this doesn't work very well; it screws up anonymous classes, captures, and adds an extra prefix dot for some reason too.
 		//  -- so we write our own take on that here.
 		
+		if (type.tag == TypeTags.BOT) return createJavaLangObject(maker, ast);
+		
 		if (type.isPrimitive()) return primitiveToJCTree(type.getKind(), maker);
 		if (type.isErroneous()) throw new TypeNotConvertibleException("Type cannot be resolved");
 		

File: src/core/lombok/javac/handlers/HandleVal.java
Patch:
@@ -31,10 +31,8 @@
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.tree.JCTree;
-import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCEnhancedForLoop;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
-import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCNewArray;
 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -384,7 +384,8 @@ public boolean delombok() throws IOException {
 		
 		for (JCCompilationUnit unit : roots) {
 			// Run one single massive transform instead of a lot of singleton calls, as this causes a heck of a lot of refilling of the enter cache.
-			boolean changed = new JavacTransformer(messager).transform(context, Collections.singletonList(unit));
+			// XXX This isn't enough - we need to call transform again after resetting everything.
+			boolean changed = new JavacTransformer(messager).transform(false, context, Collections.singletonList(unit));
 			DelombokResult result = new DelombokResult(commentsMap.get(unit).comments, unit, force || changed);
 			if (verbose) feedback.printf("File: %s [%s]\n", unit.sourcefile.getName(), result.isChanged() ? "delomboked" : "unchanged");
 			Writer rawWriter;

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -505,7 +505,7 @@ private MethodDeclaration createEquals(EclipseNode type, Collection<EclipseNode>
 		char[] otherName = "other".toCharArray();
 		
 		/* MyType<?> other = (MyType<?>) o; */ {
-			if (!fields.isEmpty()) {
+			if (!fields.isEmpty() || needsCanEqual) {
 				LocalDeclaration other = new LocalDeclaration(otherName, pS, pE);
 				other.modifiers |= ClassFileConstants.AccFinal;
 				Eclipse.setGeneratedBy(other, source);

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -505,7 +505,7 @@ private MethodDeclaration createEquals(EclipseNode type, Collection<EclipseNode>
 		char[] otherName = "other".toCharArray();
 		
 		/* MyType<?> other = (MyType<?>) o; */ {
-			if (!fields.isEmpty()) {
+			if (!fields.isEmpty() || needsCanEqual) {
 				LocalDeclaration other = new LocalDeclaration(otherName, pS, pE);
 				other.modifiers |= ClassFileConstants.AccFinal;
 				Eclipse.setGeneratedBy(other, source);

File: src/core/lombok/eclipse/Eclipse.java
Patch:
@@ -410,6 +410,7 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a
 		} else {
 			String[] pkg = new String(binding.qualifiedPackageName()).split("\\.");
 			String[] name = new String(binding.qualifiedSourceName()).split("\\.");
+			if (pkg.length == 1 && pkg[0].isEmpty()) pkg = new String[0];
 			parts = new char[pkg.length + name.length][];
 			int ptr;
 			for (ptr = 0; ptr < pkg.length; ptr++) parts[ptr] = pkg[ptr].toCharArray();

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -282,7 +282,8 @@ private static void patchHandleVal(ScriptManager sm, boolean ecj) {
 		sm.addScript(ScriptBuilder.replaceMethodCall()
 				.target(new MethodTarget(LOCALDECLARATION_SIG, "resolve", "void", BLOCKSCOPE_SIG))
 				.methodToReplace(new Hook(EXPRESSION_SIG, "resolveType", TYPEBINDING_SIG, BLOCKSCOPE_SIG))
-				.replacementMethod(new Hook("lombok.eclipse.agent.PatchFixes", "skipResolveInitializerIfAlreadyCalled", TYPEBINDING_SIG, EXPRESSION_SIG, BLOCKSCOPE_SIG))
+				.requestExtra(StackRequest.THIS)
+				.replacementMethod(new Hook("lombok.eclipse.agent.PatchFixes", "skipResolveInitializerIfAlreadyCalled2", TYPEBINDING_SIG, EXPRESSION_SIG, BLOCKSCOPE_SIG, LOCALDECLARATION_SIG))
 				.build());
 		
 		sm.addScript(ScriptBuilder.exitEarly()

File: src/core/lombok/core/AST.java
Patch:
@@ -65,7 +65,7 @@ protected AST(String fileName, String packageDeclaration, Collection<String> imp
 		this.imports = Collections.unmodifiableCollection(new ArrayList<String>(imports));
 	}
 	
-	protected void setChanged() {
+	public void setChanged() {
 		this.changed = true;
 	}
 	

File: test/transform/resource/after-ecj/ClassNamedAfterGetter.java
Patch:
@@ -1,9 +1,9 @@
 class GetFoo {
   private @lombok.Getter int foo;
-  GetFoo() {
-    super();
-  }
   public @java.lang.SuppressWarnings("all") int getFoo() {
     return this.foo;
   }
+  GetFoo() {
+    super();
+  }
 }

File: test/transform/resource/after-ecj/CommentsInterspersed.java
Patch:
@@ -2,11 +2,11 @@
 public class CommentsInterspersed {
   private int x;
   private @Getter String test = "foo";
+  public @java.lang.SuppressWarnings("all") String getTest() {
+    return this.test;
+  }
   public CommentsInterspersed() {
     super();
   }
   public native void gwtTest();
-  public @java.lang.SuppressWarnings("all") String getTest() {
-    return this.test;
-  }
 }

File: test/transform/resource/after-ecj/GetterAccessLevel.java
Patch:
@@ -10,9 +10,6 @@ class GetterAccessLevel {
   @lombok.Getter(lombok.AccessLevel.PROTECTED) String protectedString;
   @lombok.Getter(lombok.AccessLevel.PUBLIC) String publicString;
   @lombok.Getter(value = lombok.AccessLevel.PUBLIC) String value;
-  GetterAccessLevel() {
-    super();
-  }
   private @java.lang.SuppressWarnings("all") boolean isPrivate() {
     return this.isPrivate;
   }
@@ -40,4 +37,7 @@ class GetterAccessLevel {
   public @java.lang.SuppressWarnings("all") String getValue() {
     return this.value;
   }
+  GetterAccessLevel() {
+    super();
+  }
 }

File: test/transform/resource/after-ecj/GetterBoolean.java
Patch:
@@ -2,9 +2,6 @@ class Getter {
   @lombok.Getter boolean foo;
   @lombok.Getter boolean isBar;
   @lombok.Getter boolean hasBaz;
-  Getter() {
-    super();
-  }
   public @java.lang.SuppressWarnings("all") boolean isFoo() {
     return this.foo;
   }
@@ -14,6 +11,9 @@ class Getter {
   public @java.lang.SuppressWarnings("all") boolean hasBaz() {
     return this.hasBaz;
   }
+  Getter() {
+    super();
+  }
 }
 class MoreGetter {
   @lombok.Getter boolean foo;

File: test/transform/resource/after-ecj/GetterOnStatic.java
Patch:
@@ -3,13 +3,13 @@ class Getter {
   static @lombok.Getter int bar;
   <clinit>() {
   }
-  Getter() {
-    super();
-  }
   public static @java.lang.SuppressWarnings("all") boolean isFoo() {
     return Getter.foo;
   }
   public static @java.lang.SuppressWarnings("all") int getBar() {
     return Getter.bar;
   }
+  Getter() {
+    super();
+  }
 }

File: test/transform/resource/after-ecj/GetterPlain.java
Patch:
@@ -2,13 +2,13 @@
 class GetterPlain {
   @lombok.Getter int i;
   @Getter int foo;
-  GetterPlain() {
-    super();
-  }
   public @java.lang.SuppressWarnings("all") int getI() {
     return this.i;
   }
   public @java.lang.SuppressWarnings("all") int getFoo() {
     return this.foo;
   }
+  GetterPlain() {
+    super();
+  }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/NonNullPlain.java
Patch:
@@ -1,9 +1,6 @@
 class NonNullPlain {
   @lombok.Setter @lombok.NonNull @lombok.Getter int i;
   @lombok.Getter @lombok.Setter @lombok.NonNull String s;
-  NonNullPlain() {
-    super();
-  }
   public @java.lang.SuppressWarnings("all") void setI(final @lombok.NonNull int i) {
     this.i = i;
   }
@@ -18,4 +15,7 @@ class NonNullPlain {
         throw new java.lang.NullPointerException("s");
     this.s = s;
   }
+  NonNullPlain() {
+    super();
+  }
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/SetterAccessLevel.java
Patch:
@@ -5,9 +5,6 @@ class SetterAccessLevel {
   @lombok.Setter(lombok.AccessLevel.PROTECTED) boolean isProtected;
   @lombok.Setter(lombok.AccessLevel.PUBLIC) boolean isPublic;
   @lombok.Setter(value = lombok.AccessLevel.PUBLIC) boolean value;
-  SetterAccessLevel() {
-    super();
-  }
   private @java.lang.SuppressWarnings("all") void setIsPrivate(final boolean isPrivate) {
     this.isPrivate = isPrivate;
   }
@@ -23,4 +20,7 @@ class SetterAccessLevel {
   public @java.lang.SuppressWarnings("all") void setValue(final boolean value) {
     this.value = value;
   }
+  SetterAccessLevel() {
+    super();
+  }
 }

File: test/transform/resource/after-ecj/SetterOnStatic.java
Patch:
@@ -3,13 +3,13 @@ class Setter {
   static @lombok.Setter int bar;
   <clinit>() {
   }
-  Setter() {
-    super();
-  }
   public static @java.lang.SuppressWarnings("all") void setFoo(final boolean foo) {
     Setter.foo = foo;
   }
   public static @java.lang.SuppressWarnings("all") void setBar(final int bar) {
     Setter.bar = bar;
   }
+  Setter() {
+    super();
+  }
 }

File: test/transform/resource/after-ecj/SetterPlain.java
Patch:
@@ -2,13 +2,13 @@
 class SetterPlain {
   @lombok.Setter int i;
   @Setter int foo;
-  SetterPlain() {
-    super();
-  }
   public @java.lang.SuppressWarnings("all") void setI(final int i) {
     this.i = i;
   }
   public @java.lang.SuppressWarnings("all") void setFoo(final int foo) {
     this.foo = foo;
   }
+  SetterPlain() {
+    super();
+  }
 }
\ No newline at end of file

File: test/transform/resource/after-delombok/LoggerJul.java
Patch:
@@ -1,9 +1,9 @@
 class LoggerJul {
-	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("LoggerJul");
+	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJul.class.getName());
 }
 class LoggerJulString {
-	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("String");
+	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(String.class.getName());
 }
 class LoggerJulJavaLangString {
-	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("java.lang.String");
+	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(java.lang.String.class.getName());
 }
\ No newline at end of file

File: test/transform/resource/after-ecj/LoggerJul.java
Patch:
@@ -1,21 +1,21 @@
 @lombok.jul.Log class LoggerJul {
-  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("LoggerJul");
+  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggerJul.class.getName());
   <clinit>() {
   }
   LoggerJul() {
     super();
   }
 }
 @lombok.jul.Log(String.class) class LoggerJulString {
-  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("String");
+  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(String.class.getName());
   <clinit>() {
   }
   LoggerJulString() {
     super();
   }
 }
 @lombok.jul.Log(java.lang.String.class) class LoggerJulJavaLangString {
-  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger("java.lang.String");
+  private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(java.lang.String.class.getName());
   <clinit>() {
   }
   LoggerJulJavaLangString() {

File: src/delombok/lombok/delombok/PrettyCommentsPrinter.java
Patch:
@@ -337,7 +337,7 @@ public void println() throws IOException {
      * Traversal methods
      *************************************************************************/
 
-    /** Exception to propogate IOException through visitXXX methods */
+    /** Exception to propagate IOException through visitXXX methods */
     private static class UncheckedIOException extends Error {
         static final long serialVersionUID = -4032692679158424751L;
         UncheckedIOException(IOException e) {

File: test/transform/resource/after-delombok/ValInFor.java
Patch:
@@ -15,6 +15,5 @@ public class ValInFor {
 			System.out.println(shouldBeString.toLowerCase());
 			val shouldBeString2 = shouldBeString;
 		}
-	}
-*/
+	}*/
 }
\ No newline at end of file

File: src/core/lombok/javac/apt/Processor.java
Patch:
@@ -157,6 +157,8 @@ private void stopJavacProcessingEnvironmentFromClosingOurClassloader() {
 			ClassLoader unwrapped = (ClassLoader) f.get(processingEnv);
 			ClassLoader wrapped = new WrappingClassLoader(unwrapped);
 			f.set(processingEnv, wrapped);
+		} catch (NoSuchFieldException e) {
+			// Some versions of javac have this (and call close on it), some don't. I guess this one doesn't have it.
 		} catch (Throwable t) {
 			throw Lombok.sneakyThrow(t);
 		}

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -33,6 +33,8 @@
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
+import com.sun.tools.javac.tree.JCTree.JCExpression;
+import com.sun.tools.javac.util.List;
 
 /**
  * Handles the {@code lombok.Data} annotation for javac.
@@ -57,7 +59,7 @@ public class HandleData implements JavacAnnotationHandler<Data> {
 		// TODO move this to the end OR move it to the top in eclipse.
 		new HandleConstructor().generateRequiredArgsConstructor(typeNode, AccessLevel.PUBLIC, staticConstructorName, true);
 		new HandleGetter().generateGetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
-		new HandleSetter().generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true);
+		new HandleSetter().generateSetterForType(typeNode, annotationNode, AccessLevel.PUBLIC, true, List.<JCExpression>nil(), List.<JCExpression>nil());
 		new HandleEqualsAndHashCode().generateEqualsAndHashCodeForType(typeNode, annotationNode);
 		new HandleToString().generateToStringForType(typeNode, annotationNode);
 		

File: src/core/lombok/bytecode/SneakyThrowsRemover.java
Patch:
@@ -71,7 +71,7 @@ protected byte[] fixJSRInlining(byte[] byteCode) {
 		return writer.toByteArray();
 	}
 	
-	@Override public byte[] applyTransformations(byte[] original, String className, DiagnosticsReceiver diagnostics) {
+	@Override public byte[] applyTransformations(byte[] original, String fileName, DiagnosticsReceiver diagnostics) {
 		if (!new ClassFileMetaData(original).usesMethod("lombok/Lombok", "sneakyThrow")) return null;
 		
 		byte[] fixedByteCode = fixJSRInlining(original);
@@ -89,6 +89,7 @@ class SneakyThrowsRemoverVisitor extends MethodAdapter {
 			}
 			
 			@Override public void visitMethodInsn(int opcode, String owner, String name, String desc) {
+				justAddedAthrow = false;
 				boolean hit = true;
 				if (hit && opcode != Opcodes.INVOKESTATIC) hit = false;
 				if (hit && !"sneakyThrow".equals(name)) hit = false;

File: src/core/lombok/Lombok.java
Patch:
@@ -39,7 +39,7 @@ public class Lombok {
 	 * about the concept of a 'checked exception'. All this method does is hide the act of throwing a checked exception
 	 * from the java compiler.
 	 * <p>
-	 * Note that this method has a return type of {@code RuntimeException} it is advised you always call this
+	 * Note that this method has a return type of {@code RuntimeException}; it is advised you always call this
 	 * method as argument to the {@code throw} statement to avoid compiler errors regarding no return
 	 * statement and similar problems. This method won't of course return an actual {@code RuntimeException} -
 	 * it never returns, it always throws the provided exception.

File: src/core/lombok/core/PostCompilerTransformation.java
Patch:
@@ -22,5 +22,5 @@
 package lombok.core;
 
 public interface PostCompilerTransformation {
-	byte[] applyTransformations(byte[] original, String className, DiagnosticsReceiver diagnostics);
+	byte[] applyTransformations(byte[] original, String fileName, DiagnosticsReceiver diagnostics);
 }

File: src/core/lombok/core/handlers/TransformationsUtil.java
Patch:
@@ -129,7 +129,7 @@ public static List<String> toAllGetterNames(CharSequence fieldName, boolean isBo
 				//could also be 'foo'.
 				baseNames.add(fieldName.toString().substring(knownBooleanPrefix.length()));
 				//prefix with 'is' but instead just use the field name as is. The isLowerCase check is so we don't turn
-				//hashCodeGenerated, which so happens to start with 'has', into hasHCodeGenerated instead of isHashCodeGenerated.
+				//hashCodeGenerated, which so happens to start with 'has', into hashCodeGenerated instead of isHashCodeGenerated.
 			}
 		}
 		

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -114,8 +114,8 @@ public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Ex
 		return newSimpleNames;
 	}
 	
-	public static byte[] runPostCompiler(byte[] bytes, String className) {
-		byte[] transformed = PostCompiler.applyTransformations(bytes, className, DiagnosticsReceiver.CONSOLE);
+	public static byte[] runPostCompiler(byte[] bytes, String fileName) {
+		byte[] transformed = PostCompiler.applyTransformations(bytes, fileName, DiagnosticsReceiver.CONSOLE);
 		return transformed == null ? bytes : transformed;
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -93,7 +93,8 @@ private static void patchPostCompileHookEcj(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.wrapMethodCall()
 				.target(new MethodTarget("org.eclipse.jdt.internal.compiler.util.Util", "writeToDisk"))
 				.methodToWrap(new Hook("java.io.BufferedOutputStream", "<init>", "void", "java.io.OutputStream", "int"))
-				.wrapMethod(new Hook("lombok.eclipse.agent.PatchFixes", "runPostCompiler", "java.io.BufferedOutputStream", "java.io.BufferedOutputStream"))
+				.wrapMethod(new Hook("lombok.eclipse.agent.PatchFixes", "runPostCompiler", "java.io.BufferedOutputStream", "java.io.BufferedOutputStream", "java.lang.String", "java.lang.String"))
+				.requestExtra(StackRequest.PARAM2, StackRequest.PARAM3)
 				.build());
 	}
 	

File: src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -123,7 +123,8 @@ public static OutputStream runPostCompiler(OutputStream out) throws IOException
 		return PostCompiler.wrapOutputStream(out, "TEST", DiagnosticsReceiver.CONSOLE);
 	}
 	
-	public static BufferedOutputStream runPostCompiler(BufferedOutputStream out) throws IOException {
-		return new BufferedOutputStream(PostCompiler.wrapOutputStream(out, "TEST", DiagnosticsReceiver.CONSOLE));
+	public static BufferedOutputStream runPostCompiler(BufferedOutputStream out, String path, String name) throws IOException {
+		String fileName = path + "/" + name;
+		return new BufferedOutputStream(PostCompiler.wrapOutputStream(out, fileName, DiagnosticsReceiver.CONSOLE));
 	}
 }

File: src/core/lombok/core/DiagnosticsReceiver.java
Patch:
@@ -23,13 +23,12 @@
 
 public interface DiagnosticsReceiver {
 	DiagnosticsReceiver CONSOLE = new DiagnosticsReceiver() {
-		
 		@Override public void addError(String message) {
-			System.err.println(message);
+			System.err.println("Error: " + message);
 		}
 		
 		@Override public void addWarning(String message) {
-			System.out.println(message);
+			System.out.println("Warning: " + message);
 		}
 	};
 	

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -175,7 +175,6 @@ private static void addConstructorProperties(JCModifiers mods, JavacNode node, L
 	
 	private JCMethodDecl createConstructor(AccessLevel level, JavacNode typeNode, List<JavacNode> fields, boolean suppressConstructorProperties) {
 		TreeMaker maker = typeNode.getTreeMaker();
-		JCClassDecl type = (JCClassDecl) typeNode.get();
 		
 		List<JCStatement> nullChecks = List.nil();
 		List<JCStatement> assigns = List.nil();
@@ -203,7 +202,7 @@ private JCMethodDecl createConstructor(AccessLevel level, JavacNode typeNode, Li
 		}
 		
 		return maker.MethodDef(mods, typeNode.toName("<init>"),
-				null, type.typarams, params, List.<JCExpression>nil(), maker.Block(0L, nullChecks.appendList(assigns)), null);
+				null, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), maker.Block(0L, nullChecks.appendList(assigns)), null);
 	}
 	
 	private boolean isLocalType(JavacNode type) {

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -42,7 +42,6 @@
 import com.sun.tools.javac.tree.JCTree.JCBlock;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
 import com.sun.tools.javac.tree.JCTree.JCTypeParameter;
@@ -186,8 +185,8 @@ private boolean createGetterForField(AccessLevel level,
 	
 	private JCMethodDecl createGetter(long access, JavacNode field, TreeMaker treeMaker) {
 		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
-		JCFieldAccess thisX = treeMaker.Select(treeMaker.Ident(field.toName("this")), fieldNode.name);
-		JCStatement returnStatement = treeMaker.Return(thisX);
+		JCExpression fieldRef = createFieldAccessor(treeMaker, field, true);
+		JCStatement returnStatement = treeMaker.Return(fieldRef);
 		
 		JCBlock methodBody = treeMaker.Block(0, List.of(returnStatement));
 		Name methodName = field.toName(toGetterName(fieldNode));

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -49,7 +49,6 @@
 import com.sun.tools.javac.tree.JCTree.JCBlock;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
 import com.sun.tools.javac.tree.JCTree.JCTypeParameter;
@@ -189,8 +188,8 @@ private boolean createSetterForField(AccessLevel level,
 	private JCMethodDecl createSetter(long access, JavacNode field, TreeMaker treeMaker) {
 		JCVariableDecl fieldDecl = (JCVariableDecl) field.get();
 		
-		JCFieldAccess thisX = treeMaker.Select(treeMaker.Ident(field.toName("this")), fieldDecl.name);
-		JCAssign assign = treeMaker.Assign(thisX, treeMaker.Ident(fieldDecl.name));
+		JCExpression fieldRef = createFieldAccessor(treeMaker, field, true);
+		JCAssign assign = treeMaker.Assign(fieldRef, treeMaker.Ident(fieldDecl.name));
 		
 		List<JCStatement> statements;
 		List<JCAnnotation> nonNulls = findAnnotations(field, TransformationsUtil.NON_NULL_PATTERN);

File: test/transform/resource/after-delombok/DataOnLocalClass.java
Patch:
@@ -90,7 +90,7 @@ public int hashCode() {
 				@java.lang.Override
 				@java.lang.SuppressWarnings("all")
 				public java.lang.String toString() {
-					return "InnerLocal(name=" + this.getName() + ")";
+					return "Local.InnerLocal(name=" + this.getName() + ")";
 				}
 			}
 			@java.lang.SuppressWarnings("all")

File: test/transform/resource/after-delombok/ToStringInner.java
Patch:
@@ -6,15 +6,15 @@ class ToStringInner {
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
 		public java.lang.String toString() {
-			return "ToStringInner(y=" + this.y + ")";
+			return "ToStringOuter.ToStringInner(y=" + this.y + ")";
 		}
 	}
 	static class ToStringStaticInner {
 		final int y;
 		@java.lang.Override
 		@java.lang.SuppressWarnings("all")
 		public java.lang.String toString() {
-			return "ToStringStaticInner(y=" + this.y + ")";
+			return "ToStringOuter.ToStringStaticInner(y=" + this.y + ")";
 		}
 	}
 	class ToStringMiddle {
@@ -23,7 +23,7 @@ class ToStringMoreInner {
 			@java.lang.Override
 			@java.lang.SuppressWarnings("all")
 			public java.lang.String toString() {
-				return "ToStringMoreInner(name=" + this.name + ")";
+				return "ToStringOuter.ToStringMiddle.ToStringMoreInner(name=" + this.name + ")";
 			}
 		}
 	}

File: test/transform/resource/after-ecj/DataOnLocalClass.java
Patch:
@@ -85,7 +85,7 @@ class DataOnLocalClass2 {
           return result;
         }
         public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-          return (("InnerLocal(name=" + this.getName()) + ")");
+          return (("Local.InnerLocal(name=" + this.getName()) + ")");
         }
       }
       final int x;

File: test/transform/resource/after-ecj/ToStringInner.java
Patch:
@@ -6,7 +6,7 @@
       super();
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-      return (("ToStringInner(y=" + this.y) + ")");
+      return (("ToStringOuter.ToStringInner(y=" + this.y) + ")");
     }
   }
   static @ToString class ToStringStaticInner {
@@ -15,7 +15,7 @@
       super();
     }
     public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-      return (("ToStringStaticInner(y=" + this.y) + ")");
+      return (("ToStringOuter.ToStringStaticInner(y=" + this.y) + ")");
     }
   }
   class ToStringMiddle {
@@ -25,7 +25,7 @@ class ToStringMiddle {
         super();
       }
       public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-        return (("ToStringMoreInner(name=" + this.name) + ")");
+        return (("ToStringOuter.ToStringMiddle.ToStringMoreInner(name=" + this.name) + ")");
       }
     }
     ToStringMiddle() {

File: src/core/lombok/eclipse/EclipseNode.java
Patch:
@@ -165,7 +165,7 @@ public void addWarning(String message, int sourceStart, int sourceEnd) {
 	}
 	
 	/** {@inheritDoc} */
-	@Override protected boolean calculateIsStructurallySignificant() {
+	@Override protected boolean calculateIsStructurallySignificant(ASTNode parent) {
 		if (node instanceof TypeDeclaration) return true;
 		if (node instanceof AbstractMethodDeclaration) return true;
 		if (node instanceof FieldDeclaration) return true;

File: src/installer/lombok/installer/InstallerGUI.java
Patch:
@@ -313,20 +313,20 @@ private Component buildIdeArea() {
 				String file = null;
 				
 				if (IdeFinder.getOS() == OS.MAC_OS_X) {
-					System.setProperty("apple.awt.fileDialogForDirectories", "true");
 					FileDialog chooser = new FileDialog(appWindow);
 					chooser.setMode(FileDialog.LOAD);
 					
 					chooser.setFilenameFilter(new FilenameFilter() {
 						@Override public boolean accept(File dir, String fileName) {
 							for (Pattern exeName : exeNames) if (exeName.matcher(fileName).matches()) return true;
-							if (new File(dir, fileName).isDirectory()) return true;
 							return false;
 						}
 					});
 					
 					chooser.setVisible(true);
-					file = new File(chooser.getDirectory(), chooser.getFile()).getAbsolutePath();
+					if (chooser.getDirectory() != null && chooser.getFile() != null) {
+						file = new File(chooser.getDirectory(), chooser.getFile()).getAbsolutePath();
+					}
 				} else {
 					JFileChooser chooser = new JFileChooser();
 					

File: src/installer/lombok/installer/UninstallException.java
Patch:
@@ -26,9 +26,11 @@
  */
 public class UninstallException extends Exception {
 	private boolean warning;
+	
 	public UninstallException(String message, Throwable cause) {
 		super(message, cause);
 	}
+	
 	public UninstallException(boolean warning, String message, Throwable cause) {
 		super(message, cause);
 		this.warning = warning;

File: src/installer/lombok/installer/IdeLocation.java
Patch:
@@ -54,7 +54,7 @@ public static File findOurJar() {
 	
 	/**
 	 * Returns a full path to the provided file.
-	 * Returns the canonical path, unless that is not available, in which cae it returns the absolute path.
+	 * Returns the canonical path, unless that is not available, in which case it returns the absolute path.
 	 */
 	public static String canonical(File p) {
 		try {

File: test/transform/resource/after-delombok/DataWithGetter.java
Patch:
@@ -40,7 +40,7 @@ public int hashCode() {
 	@java.lang.Override
 	@java.lang.SuppressWarnings("all")
 	public java.lang.String toString() {
-		return "DataWithGetterNone(x=" + this.getX() + ", y=" + this.getY() + ", z=" + this.getZ() + ")";
+		return "DataWithGetter(x=" + this.getX() + ", y=" + this.getY() + ", z=" + this.getZ() + ")";
 	}
 	@java.lang.SuppressWarnings("all")
 	public int getX() {

File: test/transform/resource/after-ecj/DataWithGetter.java
Patch:
@@ -37,7 +37,7 @@
     return result;
   }
   public @java.lang.Override @java.lang.SuppressWarnings("all") java.lang.String toString() {
-    return (((((("DataWithGetterNone(x=" + this.getX()) + ", y=") + this.getY()) + ", z=") + this.getZ()) + ")");
+    return (((((("DataWithGetter(x=" + this.getX()) + ", y=") + this.getY()) + ", z=") + this.getZ()) + ")");
   }
   public @java.lang.SuppressWarnings("all") int getX() {
     return this.x;

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -527,6 +527,7 @@ private MethodDeclaration createEquals(EclipseNode type, Collection<EclipseNode>
 		/* MyType<?> other = (MyType<?>) o; */ {
 			if (!fields.isEmpty()) {
 				LocalDeclaration other = new LocalDeclaration(otherN, pS, pE);
+				other.modifiers |= ClassFileConstants.AccFinal;
 				Eclipse.setGeneratedBy(other, source);
 				char[] typeName = typeDecl.name;
 				Expression targetType;

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -412,7 +412,7 @@ private JCMethodDecl createEquals(JavacNode typeNode, List<JavacNode> fields, bo
 			} else /* objects */ {
 				/* if (this.fieldName == null ? other.fieldName != null : !this.fieldName.equals(other.fieldName)) return false; */
 				JCExpression thisEqualsNull = maker.Binary(JCTree.EQ, thisFieldAccessor, maker.Literal(TypeTags.BOT, null));
-				JCExpression otherNotEqualsNull = maker.Binary(JCTree.NE, thisFieldAccessor, maker.Literal(TypeTags.BOT, null));
+				JCExpression otherNotEqualsNull = maker.Binary(JCTree.NE, otherFieldAccessor, maker.Literal(TypeTags.BOT, null));
 				JCExpression thisEqualsThat = maker.Apply(List.<JCExpression>nil(),
 						maker.Select(createFieldAccessor(maker, fieldNode, useFieldsDirectly), typeNode.toName("equals")),
 						List.of(createFieldAccessor(maker, fieldNode, useFieldsDirectly, maker.Ident(otherName))));

File: src/core/lombok/javac/handlers/HandleSneakyThrows.java
Patch:
@@ -102,7 +102,7 @@ private JCStatement buildTryCatchBlock(JavacNode node, List<JCStatement> content
 		
 		JCExpression varType = chainDots(maker, node, exception.split("\\."));
 		
-		JCVariableDecl catchParam = maker.VarDef(maker.Modifiers(0), node.toName("$ex"), varType, null);
+		JCVariableDecl catchParam = maker.VarDef(maker.Modifiers(Flags.FINAL), node.toName("$ex"), varType, null);
 		JCExpression lombokLombokSneakyThrowNameRef = chainDots(maker, node, "lombok", "Lombok", "sneakyThrow");
 		JCBlock catchBody = maker.Block(0, List.<JCStatement>of(maker.Throw(maker.Apply(
 				List.<JCExpression>nil(), lombokLombokSneakyThrowNameRef,

File: test/transform/resource/after-delombok/SneakyThrowsPlain.java
Patch:
@@ -2,15 +2,15 @@ class SneakyThrowsPlain {
 	public void test() {
 		try {
 			System.out.println("test1");
-		} catch (java.lang.Throwable $ex) {
+		} catch (final java.lang.Throwable $ex) {
 			throw lombok.Lombok.sneakyThrow($ex);
 		}
 	}
 	
 	public void test2() {
 		try {
 			System.out.println("test2");
-		} catch (java.lang.Throwable $ex) {
+		} catch (final java.lang.Throwable $ex) {
 			throw lombok.Lombok.sneakyThrow($ex);
 		}
 	}

File: test/transform/resource/after-delombok/SneakyThrowsSingle.java
Patch:
@@ -3,23 +3,23 @@ class SneakyThrowsSingle {
 	public void test() {
 		try {
 			System.out.println("test1");
-		} catch (Throwable $ex) {
+		} catch (final Throwable $ex) {
 			throw lombok.Lombok.sneakyThrow($ex);
 		}
 	}
 	public void test2() {
 		try {
 			System.out.println("test2");
 			throw new IOException();
-		} catch (IOException $ex) {
+		} catch (final IOException $ex) {
 			throw lombok.Lombok.sneakyThrow($ex);
 		}
 	}
 	public void test3() {
 		try {
 			System.out.println("test3");
 			throw new IOException();
-		} catch (IOException $ex) {
+		} catch (final IOException $ex) {
 			throw lombok.Lombok.sneakyThrow($ex);
 		}
 	}

File: test/transform/resource/before/GetterWithDollar.java
Patch:
@@ -1,4 +1,3 @@
-//ignore
 class GetterWithDollar1 {
 	@lombok.Getter int $i;
 }

File: test/transform/resource/before/NonNullPlain.java
Patch:
@@ -1,5 +1,4 @@
 class NonNullPlain {
-	@lombok.Getter
 	@lombok.Setter
 	@lombok.NonNull
 	@lombok.Getter int i;

File: test/transform/resource/before/SetterWithDollar.java
Patch:
@@ -1,4 +1,3 @@
-//ignore
 class SetterWithDollar1 {
 	@lombok.Setter int $i;
 }

File: test/transform/resource/before/SneakyThrowsMultiple.java
Patch:
@@ -3,13 +3,13 @@
 import java.util.Random;
 
 class SneakyThrowsMultiple {
-	@lombok.SneakyThrows(IOException.class,Throwable.class) 
+	@lombok.SneakyThrows({IOException.class,Throwable.class})
 	public void test() {
 		System.out.println("test1");
 		throw new IOException();
 	}
 	
-	@lombok.SneakyThrows(AWTException.class,IOException.class)
+	@lombok.SneakyThrows({AWTException.class,IOException.class})
 	public void test2() {
 		System.out.println("test2");
 		if (new Random().nextBoolean()) {

File: test/transform/resource/before/SynchronizedName.java
Patch:
@@ -1,4 +1,3 @@
-//ignore
 class SynchronizedName {
 	private Object read = new Object();
 	private static Object READ = new Object();

File: src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -353,7 +353,7 @@ private MethodDeclaration createHashCode(EclipseNode type, Collection<EclipseNod
 					MessageSend hashCodeCall = new MessageSend();
 					hashCodeCall.sourceStart = pS; hashCodeCall.sourceEnd = pE;
 					Eclipse.setGeneratedBy(hashCodeCall, source);
-					hashCodeCall.receiver = fieldAccessor;
+					hashCodeCall.receiver = createFieldAccessor(field, useFieldsDirectly, source);
 					hashCodeCall.selector = "hashCode".toCharArray();
 					NullLiteral nullLiteral = new NullLiteral(pS, pE);
 					Eclipse.setGeneratedBy(nullLiteral, source);

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -281,7 +281,7 @@ private JCMethodDecl createHashCode(JavacNode typeNode, List<JavacNode> fields,
 						maker.Apply(List.<JCExpression>nil(), hcMethod, List.of(fieldAccessor)));
 			} else /* objects */ {
 				/* this.fieldName == null ? 0 : this.fieldName.hashCode() */
-				JCExpression hcCall = maker.Apply(List.<JCExpression>nil(), maker.Select(fieldAccessor, typeNode.toName("hashCode")),
+				JCExpression hcCall = maker.Apply(List.<JCExpression>nil(), maker.Select(createFieldAccessor(maker, fieldNode, useFieldsDirectly), typeNode.toName("hashCode")),
 						List.<JCExpression>nil());
 				JCExpression thisEqualsNull = maker.Binary(JCTree.EQ, fieldAccessor, maker.Literal(TypeTags.BOT, null));
 				intoResult = intoResult.append(

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -63,10 +63,12 @@ public static boolean isPrimitive(JCExpression ref) {
 	}
 	
 	/**
-	 * Removes the annotation from javac's AST, then removes it from lombok's AST,
+	 * Removes the annotation from javac's AST (it remains in lombok's AST),
 	 * then removes any import statement that imports this exact annotation (not star imports).
+	 * Only does this if the DeleteLombokAnnotations class is in the context.
 	 */
 	public static void markAnnotationAsProcessed(JavacNode annotation, Class<? extends Annotation> annotationType) {
+		if (!annotation.shouldDeleteLombokAnnotations()) return;
 		JavacNode parentNode = annotation.directUp();
 		switch (parentNode.getKind()) {
 		case FIELD:

File: src/core/lombok/eclipse/EclipseAST.java
Patch:
@@ -73,7 +73,9 @@ private static Collection<String> imports(CompilationUnitDeclaration cud) {
 		if (cud.imports == null) return imports;
 		for (ImportReference imp : cud.imports) {
 			if (imp == null) continue;
-			imports.add(Eclipse.toQualifiedName(imp.getImportName()));
+			String qualifiedName = Eclipse.toQualifiedName(imp.getImportName());
+			if ((imp.bits & ASTNode.OnDemand) != 0) qualifiedName += ".*";
+			imports.add(qualifiedName);
 		}
 		return imports;
 	}

File: src/core/lombok/javac/handlers/HandleConstructor.java
Patch:
@@ -58,6 +58,7 @@ public class HandleConstructor {
 	public static class HandleNoArgsConstructor implements JavacAnnotationHandler<NoArgsConstructor> {
 		@Override public boolean handle(AnnotationValues<NoArgsConstructor> annotation, JCAnnotation ast, JavacNode annotationNode) {
 			markAnnotationAsProcessed(annotationNode, NoArgsConstructor.class);
+			deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 			JavacNode typeNode = annotationNode.up();
 			NoArgsConstructor ann = annotation.getInstance();
 			AccessLevel level = ann.access();
@@ -73,6 +74,7 @@ public static class HandleNoArgsConstructor implements JavacAnnotationHandler<No
 	public static class HandleRequiredArgsConstructor implements JavacAnnotationHandler<RequiredArgsConstructor> {
 		@Override public boolean handle(AnnotationValues<RequiredArgsConstructor> annotation, JCAnnotation ast, JavacNode annotationNode) {
 			markAnnotationAsProcessed(annotationNode, RequiredArgsConstructor.class);
+			deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 			JavacNode typeNode = annotationNode.up();
 			RequiredArgsConstructor ann = annotation.getInstance();
 			AccessLevel level = ann.access();
@@ -102,6 +104,7 @@ public static class HandleRequiredArgsConstructor implements JavacAnnotationHand
 	public static class HandleAllArgsConstructor implements JavacAnnotationHandler<AllArgsConstructor> {
 		@Override public boolean handle(AnnotationValues<AllArgsConstructor> annotation, JCAnnotation ast, JavacNode annotationNode) {
 			markAnnotationAsProcessed(annotationNode, AllArgsConstructor.class);
+			deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 			JavacNode typeNode = annotationNode.up();
 			AllArgsConstructor ann = annotation.getInstance();
 			AccessLevel level = ann.access();

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -95,6 +95,7 @@ public void generateGetterForField(JavacNode fieldNode, DiagnosticPosition pos,
 	
 	@Override public boolean handle(AnnotationValues<Getter> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		markAnnotationAsProcessed(annotationNode, Getter.class);
+		deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 		JavacNode node = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
 		if (level == AccessLevel.NONE) return true;

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -104,6 +104,7 @@ public void generateSetterForField(JavacNode fieldNode, DiagnosticPosition pos,
 	
 	@Override public boolean handle(AnnotationValues<Setter> annotation, JCAnnotation ast, JavacNode annotationNode) {
 		markAnnotationAsProcessed(annotationNode, Setter.class);
+		deleteImportFromCompilationUnit(annotationNode, "lombok.AccessLevel");
 		JavacNode node = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
 		

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -83,7 +83,7 @@ public boolean handle(AnnotationValues<Data> annotation, Annotation ast, Eclipse
 		//for whatever reason, though you can find callers of that one by focusing on the class name itself
 		//and hitting 'find callers'.
 		
-		new HandleConstructor().generateConstructor(AccessLevel.PUBLIC, typeNode, nodesForConstructor, ann.staticConstructor(), true, ast);
+		new HandleConstructor().generateConstructor(AccessLevel.PUBLIC, typeNode, nodesForConstructor, ann.staticConstructor(), true, false, ast);
 		
 		for (Map.Entry<EclipseNode, Boolean> field : gettersAndSetters.entrySet()) {
 			new HandleGetter().generateGetterForField(field.getKey(), annotationNode.get(), AccessLevel.PUBLIC, true);

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -78,7 +78,7 @@ public class HandleData implements JavacAnnotationHandler<Data> {
 		
 		String staticConstructorName = annotation.getInstance().staticConstructor();
 		
-		new HandleConstructor().generateConstructor(AccessLevel.PUBLIC, typeNode, nodesForConstructor, staticConstructorName, true);
+		new HandleConstructor().generateConstructor(AccessLevel.PUBLIC, typeNode, nodesForConstructor, staticConstructorName, true, false);
 		
 		for (Map.Entry<JavacNode, Boolean> field : gettersAndSetters.entrySet()) {
 			new HandleGetter().generateGetterForField(field.getKey(), annotationNode.get(), AccessLevel.PUBLIC, true);

File: src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -88,6 +88,7 @@ public static int toEclipseModifier(AccessLevel value) {
 			return ClassFileConstants.AccPublic;
 		case PROTECTED:
 			return ClassFileConstants.AccProtected;
+		case NONE:
 		case PRIVATE:
 			return ClassFileConstants.AccPrivate;
 		}

File: src/core/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -257,6 +257,7 @@ public static int toJavacModifier(AccessLevel accessLevel) {
 		default:
 		case PUBLIC:
 			return Flags.PUBLIC;
+		case NONE:
 		case PRIVATE:
 			return Flags.PRIVATE;
 		case PROTECTED:

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -39,6 +39,7 @@
 import com.sun.tools.javac.tree.JCTree.JCBlock;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
 import com.sun.tools.javac.tree.JCTree.JCTypeParameter;
@@ -159,7 +160,8 @@ private boolean createGetterForField(AccessLevel level,
 	
 	private JCMethodDecl createGetter(long access, JavacNode field, TreeMaker treeMaker) {
 		JCVariableDecl fieldNode = (JCVariableDecl) field.get();
-		JCStatement returnStatement = treeMaker.Return(treeMaker.Ident(fieldNode.getName()));
+		JCFieldAccess thisX = treeMaker.Select(treeMaker.Ident(field.toName("this")), fieldNode.name);
+		JCStatement returnStatement = treeMaker.Return(thisX);
 		
 		JCBlock methodBody = treeMaker.Block(0, List.of(returnStatement));
 		Name methodName = field.toName(toGetterName(fieldNode));

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -176,8 +176,8 @@ private JavacNode buildType(JCClassDecl type) {
 		if (setAndGetAsHandled(type)) return null;
 		List<JavacNode> childNodes = new ArrayList<JavacNode>();
 		
+		for (JCAnnotation annotation : type.mods.annotations) addIfNotNull(childNodes, buildAnnotation(annotation));
 		for (JCTree def : type.defs) {
-			for (JCAnnotation annotation : type.mods.annotations) addIfNotNull(childNodes, buildAnnotation(annotation));
 			/* A def can be:
 			 *   JCClassDecl for inner types
 			 *   JCMethodDecl for constructors and methods

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2009 Reinier Zwitserloot and Roel Spilker.
+ * Copyright © 2009-2010 Reinier Zwitserloot and Roel Spilker.
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -127,8 +127,8 @@ public boolean handle(AnnotationValues<Data> annotation, Annotation ast, Eclipse
 		}
 		
 		for (Map.Entry<EclipseNode, Boolean> field : gettersAndSetters.entrySet()) {
-			new HandleGetter().generateGetterForField(field.getKey(), annotationNode.get());
-			if (field.getValue()) new HandleSetter().generateSetterForField(field.getKey(), annotationNode.get());
+			new HandleGetter().generateGetterForField(field.getKey(), annotationNode.get(), AccessLevel.PUBLIC, true);
+			if (field.getValue()) new HandleSetter().generateSetterForField(field.getKey(), annotationNode.get(), AccessLevel.PUBLIC, true);
 		}
 		
 		new HandleEqualsAndHashCode().generateEqualsAndHashCodeForType(typeNode, annotationNode);

File: src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -72,8 +72,8 @@ private static void patchHideGeneratedNodes(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.wrapReturnValue()
 				.target(new MethodTarget("org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder", "findByNode"))
 				.target(new MethodTarget("org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder", "findByBinding"))
-				.wrapMethod(new Hook("lombok.eclipse.agent.PatchFixes", "removeGeneratedSimpleNames", "org.eclipse.jdt.core.dom.SimpleName",
-						"org.eclipse.jdt.core.dom.SimpleName"))
+				.wrapMethod(new Hook("lombok.eclipse.agent.PatchFixes", "removeGeneratedSimpleNames", "org.eclipse.jdt.core.dom.SimpleName[]",
+						"org.eclipse.jdt.core.dom.SimpleName[]"))
 				.request(StackRequest.RETURN_VALUE).build());
 		
 		patchRefactorScripts(sm);

File: src/core/lombok/core/handlers/TransformationsUtil.java
Patch:
@@ -84,7 +84,7 @@ public static String toGetterName(CharSequence fieldName, boolean isBoolean) {
 			"^(boolean|byte|short|int|long|float|double|char)$");
 	
 	public static final Pattern NON_NULL_PATTERN = Pattern.compile("^nonnull$", Pattern.CASE_INSENSITIVE);
-	public static final Pattern NULLABLE_PATTERN = Pattern.compile("^nullable$", Pattern.CASE_INSENSITIVE);
+	public static final Pattern NULLABLE_PATTERN = Pattern.compile("^(?:nullable|checkfornull)$", Pattern.CASE_INSENSITIVE);
 	
 	/**
 	 * Generates a getter name from a given field name.

File: test/delombok/resource/before/ClassNamedAfterGetter.java
Patch:
@@ -0,0 +1,3 @@
+class GetFoo {
+	@lombok.Getter private int foo;
+}

File: src/core/lombok/core/AnnotationValues.java
Patch:
@@ -425,7 +425,9 @@ private String toFQ(String typeName) {
 		}
 		
 		/* 3. Walk through star imports and, if they start with "java.", use Class.forName based resolution. */ {
-			for (String im : ast.getImportStatements()) {
+			List<String> imports = new ArrayList<String>(ast.getImportStatements());
+			imports.add("java.lang.*");
+			for (String im : imports) {
 				if (!im.endsWith(".*") || !im.startsWith("java.")) continue;
 				try {
 					Class<?> c = Class.forName(im.substring(0, im.length()-1) + typeName);

File: src/core/lombok/javac/JavacAST.java
Patch:
@@ -42,6 +42,7 @@
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
+import com.sun.tools.javac.tree.JCTree.JCIdent;
 import com.sun.tools.javac.tree.JCTree.JCImport;
 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCStatement;
@@ -87,7 +88,7 @@ private static String sourceName(JCCompilationUnit cu) {
 	}
 	
 	private static String packageDeclaration(JCCompilationUnit cu) {
-		return cu.pid instanceof JCFieldAccess ? cu.pid.toString() : null;
+		return (cu.pid instanceof JCFieldAccess || cu.pid instanceof JCIdent) ? cu.pid.toString() : null;
 	}
 	
 	private static Collection<String> imports(JCCompilationUnit cu) {

File: src/installer/lombok/installer/Installer.java
Patch:
@@ -240,7 +240,6 @@ public static int cliInstaller(boolean uninstall, List<String> rawArgs) {
 					IdeLocation loc = tryAllProviders(rawPath);
 					if (loc != null) locations.add(loc);
 					else problems.add(new CorruptedIdeLocationException("Can't find any IDE at: " + rawPath, null, null));
-					locations.add(tryAllProviders(rawPath));
 				} catch (CorruptedIdeLocationException e) {
 					problems.add(e);
 				}

File: src/installer/lombok/installer/eclipse/STSFinder.java
Patch:
@@ -57,8 +57,7 @@ public class STSFinder extends EclipseFinder {
 	}
 	
 	@Override protected List<String> getSourceDirsOnWindows() {
-//		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
-		return Arrays.asList();
+		return Arrays.asList("\\", "\\springsource", "\\Program Files", "\\Program Files\\springsource", System.getProperty("user.home", "."), System.getProperty("user.home", ".") + "\\springsource");
 	}
 	
 	@Override protected List<String> getSourceDirsOnMac() {

File: src/delombok/lombok/delombok/ant/DelombokTask.java
Patch:
@@ -85,9 +85,9 @@ public void execute() throws BuildException {
 					File baseDir = fileResource.getBaseDir();
 					if (baseDir == null) {
 						File file = fileResource.getFile();
-						delombok.process(file.getParentFile(), file.getName());
+						delombok.process(false, file.getParentFile(), file.getName());
 					} else {
-						delombok.process(baseDir, fileResource.getName());
+						delombok.process(false, baseDir, fileResource.getName());
 					}
 				}
 			}

File: src/netbeansAgent/lombok/netbeans/agent/NetbeansPatcher.java
Patch:
@@ -58,7 +58,7 @@ private static void patchNetbeansClassLoader(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.exitEarly()
 				.transplant().request(StackRequest.PARAM1, StackRequest.PARAM2)
 				.target(new MethodTarget("org.netbeans.StandardModule$OneModuleClassLoader", "<init>"))
-				.decisionMethod(new Hook("lombok/netbeans/agent/PatchFixes", "addSelfToClassLoader", "(Lorg/netbeans/Module;Ljava/util/List;)Z"))
+				.decisionMethod(new Hook("lombok/netbeans/agent/PatchFixes", "addSelfToClassLoader", "(Lorg/netbeans/Module;Ljava/util/List;)V"))
 				.build());
 		sm.addScript(ScriptBuilder.exitEarly()
 				.transplant()

File: src/core/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -119,7 +119,7 @@ public boolean handle(AnnotationValues<Data> annotation, Annotation ast, Eclipse
 		}
 		
 		if (ann.staticConstructor().length() > 0) {
-			if (methodExists("of", typeNode) == MemberExistsResult.NOT_EXISTS) {
+			if (methodExists("of", typeNode, false) == MemberExistsResult.NOT_EXISTS) {
 				MethodDeclaration staticConstructor = createStaticConstructor(
 						ann.staticConstructor(), typeNode, nodesForConstructor, ast);
 				injectMethod(typeNode, staticConstructor);

File: src/core/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -99,7 +99,7 @@ private boolean createGetterForField(AccessLevel level,
 		int modifier = toEclipseModifier(level) | (field.modifiers & ClassFileConstants.AccStatic);
 		
 		for (String altName : TransformationsUtil.toAllGetterNames(fieldName, isBoolean)) {
-			switch (methodExists(altName, fieldNode)) {
+			switch (methodExists(altName, fieldNode, false)) {
 			case EXISTS_BY_LOMBOK:
 				return true;
 			case EXISTS_BY_USER:

File: src/core/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -103,7 +103,7 @@ private boolean createSetterForField(AccessLevel level,
 		
 		int modifier = toEclipseModifier(level) | (field.modifiers & ClassFileConstants.AccStatic);
 		
-		switch (methodExists(setterName, fieldNode)) {
+		switch (methodExists(setterName, fieldNode, false)) {
 		case EXISTS_BY_LOMBOK:
 			return true;
 		case EXISTS_BY_USER:

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -101,7 +101,7 @@ public class HandleData implements JavacAnnotationHandler<Data> {
 			injectMethod(typeNode, constructor);
 		}
 		
-		if (!staticConstructorName.isEmpty() && methodExists("of", typeNode) == MemberExistsResult.NOT_EXISTS) {
+		if (!staticConstructorName.isEmpty() && methodExists("of", typeNode, false) == MemberExistsResult.NOT_EXISTS) {
 			JCMethodDecl staticConstructor = createStaticConstructor(staticConstructorName, typeNode, nodesForConstructor);
 			injectMethod(typeNode, staticConstructor);
 		}

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -100,7 +100,7 @@ private boolean createGetterForField(AccessLevel level,
 		String methodName = toGetterName(fieldDecl);
 		
 		for (String altName : toAllGetterNames(fieldDecl)) {
-			switch (methodExists(altName, fieldNode)) {
+			switch (methodExists(altName, fieldNode, false)) {
 			case EXISTS_BY_LOMBOK:
 				return true;
 			case EXISTS_BY_USER:

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -101,7 +101,7 @@ private boolean createSetterForField(AccessLevel level,
 		JCVariableDecl fieldDecl = (JCVariableDecl)fieldNode.get();
 		String methodName = toSetterName(fieldDecl);
 		
-		switch (methodExists(methodName, fieldNode)) {
+		switch (methodExists(methodName, fieldNode, false)) {
 		case EXISTS_BY_LOMBOK:
 			return true;
 		case EXISTS_BY_USER:

File: src/installer/lombok/installer/netbeans/NetbeansFinder.java
Patch:
@@ -101,7 +101,7 @@ private void findNetbeansOnWindows(List<IdeLocation> locations, List<CorruptedId
 	
 	/** Checks if the provided directory contains 'netbeans.exe', and if so, returns the directory, otherwise null. */
 	private String findNetbeansOnWindows1(File dir) {
-		if (new File(dir, "netbeans.exe").isFile()) return dir.getAbsolutePath();
+		if (new File(dir, "bin/netbeans.exe").isFile()) return dir.getAbsolutePath();
 		return null;
 	}
 	
@@ -165,7 +165,7 @@ private static void findNetbeansInSubDir(String dir, List<String> guesses) {
 		if (!d.isDirectory()) return;
 		for (File f : d.listFiles()) {
 			if (f.isDirectory() && f.getName().toLowerCase().contains("netbeans")) {
-				File possible = new File(f, "bin/netbeans.exe");
+				File possible = new File(f, "bin/netbeans");
 				if (possible.exists()) guesses.add(possible.getAbsolutePath());
 			}
 		}

File: src/installer/lombok/installer/netbeans/NetbeansLocation.java
Patch:
@@ -84,7 +84,7 @@ public boolean hasLombok() {
 	
 	private final String ID_CHARS = "(?:\\\\.|[^\"\\\\])*";
 	private final Pattern JAVA_AGENT_LINE_MATCHER = Pattern.compile(
-			"^\\s*netbeans_default_options\\s*=\\s*\"\\s*" + ID_CHARS + "(?<=[ \"])(-J-javaagent:\\\\\"" + ID_CHARS + "lombok" + ID_CHARS + "\\.jar\\\\\")(?=[ \"])" + ID_CHARS +"\\s*\"\\s*(?:#.*)?$", Pattern.CASE_INSENSITIVE);
+			"^\\s*netbeans_default_options\\s*=\\s*\"\\s*" + ID_CHARS + "(?<=[ \"])(-J-javaagent:\\\\\".*lombok.*\\.jar\\\\\")(?=[ \"])" + ID_CHARS +"\\s*\"\\s*(?:#.*)?$", Pattern.CASE_INSENSITIVE);
 	
 	private final Pattern OPTIONS_LINE_MATCHER = Pattern.compile(
 			"^\\s*netbeans_default_options\\s*=\\s*\"\\s*" + ID_CHARS + "\\s*(\")\\s*(?:#.*)?$", Pattern.CASE_INSENSITIVE);
@@ -240,7 +240,7 @@ public String install() throws InstallException {
 					m = OPTIONS_LINE_MATCHER.matcher(line);
 					if (m.matches()) {
 						newContents.append(line.substring(0, m.start(1)));
-						newContents.append(" ").append("-J-javaagent:\\\"" + canonical(lombokJar) +"\\\"");
+						newContents.append(" ").append("-J-javaagent:\\\"" + canonical(lombokJar) +"\\\"\"");
 						newContents.append(line.substring(m.end(1))).append(OS_NEWLINE);
 						continue;
 					}

File: src/core/lombok/javac/HandlerLibrary.java
Patch:
@@ -165,7 +165,6 @@ public boolean handleAnnotation(JCCompilationUnit unit, JavacNode node, JCAnnota
 			if (container == null) continue;
 			
 			try {
-				System.out.println("Calling handle on: "+ container.handler.getClass().getName());
 				handled |= container.handle(node);
 			} catch (AnnotationValueDecodeFail fail) {
 				fail.owner.setError(fail.getMessage(), fail.idx);

File: test/lombok/resource/after/SynchronizedPlain.java
Patch:
@@ -1,5 +1,4 @@
 class SynchronizedPlain1 {
-	private final Object $lock = new Object[0];
 	void test() {
 		synchronized ($lock) {
 			System.out.println("one");
@@ -10,9 +9,9 @@ void test2() {
 			System.out.println("two");
 		}
 	}
+	private final java.lang.Object $lock = new java.lang.Object[0];
 }
 class SynchronizedPlain2 {
-	private static final Object $LOCK = new Object[0];
 	static void test() {
 		synchronized ($LOCK) {
 			System.out.println("three");
@@ -23,4 +22,5 @@ static void test2() {
 			System.out.println("four");
 		}
 	}
+	private static final java.lang.Object $LOCK = new java.lang.Object[0];
 }
\ No newline at end of file

File: src/core/lombok/core/handlers/SneakyThrowsDependencyInfo.java
Patch:
@@ -32,7 +32,7 @@
 public class SneakyThrowsDependencyInfo implements RuntimeDependencyInfo {
 	@Override public List<String> getRuntimeDependencies() {
 		return Arrays.asList(
-				"/lombok/Lombok.class"
+				"lombok/Lombok.class"
 		);
 	}
 	

File: src/core/lombok/core/runtimeDependencies/RuntimeDependencyInfo.java
Patch:
@@ -34,7 +34,7 @@ public interface RuntimeDependencyInfo {
 	public List<String> getRuntimeDependentsDescriptions();
 	
 	/**
-	 * @return A list of files (findable via {@code yourClass.getResourceAsStream(NAME)}) to include in
+	 * @return A list of files (findable via {@code yourClass.getResourceAsStream("/" + NAME)}) to include in
 	 *     {@code lombok-runtime.jar}.
 	 */
 	public List<String> getRuntimeDependencies();

File: test/core/src/lombok/TestViaDelombok.java
Patch:
@@ -64,7 +64,7 @@ private static void compare(String name, String expectedFile, String actualFile)
 			String expected = expectedLines[i];
 			String actual = actualLines[i];
 			if (!expected.equals(actual)) {
-				fail(String.format("Difference in line %s(%d):\n`%s`\n`%s`\n", name, i, expected, actual));
+				fail(String.format("Difference in line %s(%d):\nExpected `%s`\nGot `%s`\n", name, i, expected, actual));
 			}
 		}
 		if (expectedLines.length > actualLines.length) {

File: src/delombok/lombok/delombok/Delombok.java
Patch:
@@ -78,7 +78,7 @@ private static class CmdArgs {
 		
 		@Shorthand("d")
 		@Description("Directory to save delomboked files to")
-		@Mandatory(onlyIfNot="print")
+		@Mandatory(onlyIfNot={"print", "help"})
 		@Parameterized
 		private String target;
 		
@@ -103,9 +103,9 @@ public static void main(String[] rawArgs) {
 		}
 		
 		if (args.help || args.input.isEmpty()) {
-			if (args.input.isEmpty()) System.err.println("ERROR: no files or directories to delombok specified.");
+			if (!args.help) System.err.println("ERROR: no files or directories to delombok specified.");
 			System.err.println(reader.generateCommandLineHelp("delombok"));
-			System.exit(args.input.isEmpty() ? 1 : 0);
+			System.exit(args.help ? 0 : 1);
 			return;
 		}
 		

File: src/core/lombok/javac/handlers/HandleCleanup.java
Patch:
@@ -21,6 +21,7 @@
  */
 package lombok.javac.handlers;
 
+import static lombok.javac.handlers.JavacHandlerUtil.markAnnotationAsProcessed;
 import lombok.Cleanup;
 import lombok.core.AnnotationValues;
 import lombok.core.AST.Kind;
@@ -53,6 +54,7 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleCleanup implements JavacAnnotationHandler<Cleanup> {
 	@Override public boolean handle(AnnotationValues<Cleanup> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, Cleanup.class);
 		String cleanupName = annotation.getInstance().value();
 		if (cleanupName.length() == 0) {
 			annotationNode.addError("cleanupName cannot be the empty string.");

File: src/core/lombok/javac/handlers/HandleData.java
Patch:
@@ -59,6 +59,7 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleData implements JavacAnnotationHandler<Data> {
 	@Override public boolean handle(AnnotationValues<Data> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, Data.class);
 		JavacNode typeNode = annotationNode.up();
 		JCClassDecl typeDecl = null;
 		if (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl)typeNode.get();

File: src/core/lombok/javac/handlers/HandleEqualsAndHashCode.java
Patch:
@@ -72,6 +72,7 @@ private void checkForBogusFieldNames(JavacNode type, AnnotationValues<EqualsAndH
 	}
 	
 	@Override public boolean handle(AnnotationValues<EqualsAndHashCode> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, EqualsAndHashCode.class);
 		EqualsAndHashCode ann = annotation.getInstance();
 		List<String> excludes = List.from(ann.exclude());
 		List<String> includes = List.from(ann.of());

File: src/core/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -80,8 +80,10 @@ public void generateGetterForField(JavacNode fieldNode, DiagnosticPosition pos)
 	}
 	
 	@Override public boolean handle(AnnotationValues<Getter> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, Getter.class);
 		JavacNode fieldNode = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
+		
 		if (level == AccessLevel.NONE) return true;
 		
 		return createGetterForField(level, fieldNode, annotationNode, true);

File: src/core/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -82,8 +82,10 @@ public void generateSetterForField(JavacNode fieldNode, DiagnosticPosition pos)
 	}
 	
 	@Override public boolean handle(AnnotationValues<Setter> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, Setter.class);
 		JavacNode fieldNode = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
+		
 		if (level == AccessLevel.NONE) return true;
 		
 		return createSetterForField(level, fieldNode, annotationNode, true);

File: src/core/lombok/javac/handlers/HandleSneakyThrows.java
Patch:
@@ -22,6 +22,7 @@
 package lombok.javac.handlers;
 
 import static lombok.javac.handlers.JavacHandlerUtil.chainDots;
+import static lombok.javac.handlers.JavacHandlerUtil.markAnnotationAsProcessed;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -49,6 +50,7 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleSneakyThrows implements JavacAnnotationHandler<SneakyThrows> {
 	@Override public boolean handle(AnnotationValues<SneakyThrows> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, SneakyThrows.class);
 		Collection<String> exceptionNames = annotation.getRawExpressions("value");
 		
 		List<JCExpression> memberValuePairs = ast.getArguments();

File: src/core/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -51,17 +51,20 @@ public class HandleSynchronized implements JavacAnnotationHandler<Synchronized>
 	private static final String STATIC_LOCK_NAME = "$LOCK";
 	
 	@Override public boolean handle(AnnotationValues<Synchronized> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, Synchronized.class);
 		JavacNode methodNode = annotationNode.up();
 		
 		if (methodNode == null || methodNode.getKind() != Kind.METHOD || !(methodNode.get() instanceof JCMethodDecl)) {
 			annotationNode.addError("@Synchronized is legal only on methods.");
+			
 			return true;
 		}
 		
 		JCMethodDecl method = (JCMethodDecl)methodNode.get();
 		
 		if ((method.mods.flags & Flags.ABSTRACT) != 0) {
 			annotationNode.addError("@Synchronized is legal only on concrete methods.");
+			
 			return true;
 		}
 		boolean isStatic = (method.mods.flags & Flags.STATIC) != 0;

File: src/core/lombok/javac/handlers/HandleToString.java
Patch:
@@ -68,6 +68,8 @@ private void checkForBogusFieldNames(JavacNode type, AnnotationValues<ToString>
 	}
 	
 	@Override public boolean handle(AnnotationValues<ToString> annotation, JCAnnotation ast, JavacNode annotationNode) {
+		markAnnotationAsProcessed(annotationNode, ToString.class);
+		
 		ToString ann = annotation.getInstance();
 		List<String> excludes = List.from(ann.exclude());
 		List<String> includes = List.from(ann.of());

File: test/lombok/resource/before/CommentsInterspersed.java
Patch:
@@ -1,4 +1,4 @@
-import lombok.Getter;
+import  /* cmt */   lombok./* cmt2 */Getter   /* cmt3 */   ;
 
 public /*bla */ class CommentsInterspersed {
 	/** javadoc for field */

File: src_eclipseagent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -55,7 +55,7 @@ public static void premain(@SuppressWarnings("unused") String agentArgs, Instrum
 	private static void registerPatchScripts(Instrumentation instrumentation, boolean reloadExistingClasses) {
 		ScriptManager sm = new ScriptManager();
 		sm.registerTransformer(instrumentation);
-		EquinoxClassLoader.getInstance().addPrefix("lombok.");
+		EquinoxClassLoader.addPrefix("lombok.");
 		EquinoxClassLoader.registerScripts(sm);
 		
 		patchLombokizeAST(sm);

File: src/lombok/eclipse/handlers/EclipseHandlerUtil.java
Patch:
@@ -348,7 +348,7 @@ public static Statement generateNullCheck(AbstractVariableDeclaration variable,
 	 * Create an annotation of the given name, and is marked as being generated by the given source.
 	 */
 	public static MarkerAnnotation makeMarkerAnnotation(char[][] name, ASTNode source) {
-		long pos = source.sourceStart << 32 | source.sourceEnd;
+		long pos = (long)source.sourceStart << 32 | source.sourceEnd;
 		TypeReference typeRef = new QualifiedTypeReference(name, new long[] {pos, pos, pos});
 		Eclipse.setGeneratedBy(typeRef, source);
 		MarkerAnnotation ann = new MarkerAnnotation(typeRef, (int)(pos >> 32));

File: src/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -142,7 +142,7 @@ private MethodDeclaration generateGetter(TypeDeclaration parent, FieldDeclaratio
 		method.thrownExceptions = null;
 		method.typeParameters = null;
 		method.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;
-		Expression fieldExpression = new SingleNameReference(field.name, (field.declarationSourceStart << 32) | field.declarationSourceEnd);
+		Expression fieldExpression = new SingleNameReference(field.name, ((long)field.declarationSourceStart << 32) | field.declarationSourceEnd);
 		Eclipse.setGeneratedBy(fieldExpression, source);
 		Statement returnStatement = new ReturnStatement(fieldExpression, field.sourceStart, field.sourceEnd);
 		Eclipse.setGeneratedBy(returnStatement, source);

File: src/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -76,7 +76,7 @@ public class HandleSynchronized implements JavacAnnotationHandler<Synchronized>
 		
 		if (fieldExists(lockName, methodNode) == MemberExistsResult.NOT_EXISTS) {
 			if (!autoMake) {
-				annotationNode.addError("The field " + new String(lockName) + " does not exist.");
+				annotationNode.addError("The field " + lockName + " does not exist.");
 				return true;
 			}
 			JCExpression objectType = chainDots(maker, methodNode, "java", "lang", "Object");

File: src/lombok/javac/handlers/JavacHandlerUtil.java
Patch:
@@ -59,7 +59,7 @@ public static boolean isPrimitive(JCExpression ref) {
 	
 	/**
 	 * Translates the given field into all possible getter names.
-	 * Convenient wrapper around {@link TransformationsUtil#toAllGetterNames(String, boolean)}.
+	 * Convenient wrapper around {@link TransformationsUtil#toAllGetterNames(CharSequence, boolean)}.
 	 */
 	public static java.util.List<String> toAllGetterNames(JCVariableDecl field) {
 		CharSequence fieldName = field.name;
@@ -72,7 +72,7 @@ public static java.util.List<String> toAllGetterNames(JCVariableDecl field) {
 	/**
 	 * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).
 	 * 
-	 * Convenient wrapper around {@link TransformationsUtil#toGetterName(String, boolean)}.
+	 * Convenient wrapper around {@link TransformationsUtil#toGetterName(CharSequence, boolean)}.
 	 */
 	public static String toGetterName(JCVariableDecl field) {
 		CharSequence fieldName = field.name;
@@ -85,7 +85,7 @@ public static String toGetterName(JCVariableDecl field) {
 	/**
 	 * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).
 	 * 
-	 * Convenient wrapper around {@link TransformationsUtil.toSetterName(String)}.
+	 * Convenient wrapper around {@link TransformationsUtil#toSetterName(CharSequence)}.
 	 */
 	public static String toSetterName(JCVariableDecl field) {
 		CharSequence fieldName = field.name;

File: src/lombok/javac/handlers/HandleData.java
Patch:
@@ -137,7 +137,7 @@ private JCMethodDecl createStaticConstructor(String name, JavacNode typeNode, Li
 		TreeMaker maker = typeNode.getTreeMaker();
 		JCClassDecl type = (JCClassDecl) typeNode.get();
 		
-		JCModifiers mods = maker.Modifiers(Flags.STATIC);
+		JCModifiers mods = maker.Modifiers(Flags.STATIC | Flags.PUBLIC);
 		
 		JCExpression returnType, constructorType;
 		

File: src/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -87,6 +87,8 @@ public boolean handle(AnnotationValues<Data> annotation, Annotation ast, Eclipse
 		for (EclipseNode child : typeNode.down()) {
 			if (child.getKind() != Kind.FIELD) continue;
 			FieldDeclaration fieldDecl = (FieldDeclaration) child.get();
+			//Skip fields that start with $
+			if (fieldDecl.name.length > 0 && fieldDecl.name[0] == '$') continue;
 			//Skip static fields.
 			if ((fieldDecl.modifiers & ClassFileConstants.AccStatic) != 0) continue;
 			boolean isFinal = (fieldDecl.modifiers & ClassFileConstants.AccFinal) != 0;

File: src/lombok/javac/handlers/HandleData.java
Patch:
@@ -70,15 +70,15 @@ public class HandleData implements JavacAnnotationHandler<Data> {
 			return false;
 		}
 		
-		List<JavacNode> nodesForEquality = List.nil();
 		List<JavacNode> nodesForConstructor = List.nil();
 		for (JavacNode child : typeNode.down()) {
 			if (child.getKind() != Kind.FIELD) continue;
 			JCVariableDecl fieldDecl = (JCVariableDecl) child.get();
+			//Skip fields that start with $
+			if (fieldDecl.name.toString().startsWith("$")) continue;
 			long fieldFlags = fieldDecl.mods.flags;
 			//Skip static fields.
 			if ((fieldFlags & Flags.STATIC) != 0) continue;
-			if ((fieldFlags & Flags.TRANSIENT) == 0) nodesForEquality = nodesForEquality.append(child);
 			boolean isFinal = (fieldFlags & Flags.FINAL) != 0;
 			boolean isNonNull = !findAnnotations(child, TransformationsUtil.NON_NULL_PATTERN).isEmpty();
 			if ((isFinal || isNonNull) && fieldDecl.init == null) nodesForConstructor = nodesForConstructor.append(child);

File: src/lombok/eclipse/Eclipse.java
Patch:
@@ -176,7 +176,7 @@ public static TypeParameter[] copyTypeParams(TypeParameter[] params, ASTNode sou
 	
 	/**
 	 * Convenience method that creates a new array and copies each TypeReference in the source array via
-	 * {@link #copyType(TypeReference)}.
+	 * {@link #copyType(TypeReference, ASTNode)}.
 	 */
 	public static TypeReference[] copyTypes(TypeReference[] refs, ASTNode source) {
 		if (refs == null) return null;

File: src/lombok/javac/JavacNode.java
Patch:
@@ -43,7 +43,9 @@
  * Javac specific version of the LombokNode class.
  */
 public class JavacNode extends lombok.core.LombokNode<JavacAST, JavacNode, JCTree> {
-	/** {@inheritDoc} */
+	/**
+	 * Passes through to the parent constructor.
+	 */
 	public JavacNode(JavacAST ast, JCTree node, List<JavacNode> children, Kind kind) {
 		super(ast, node, children, kind);
 	}

File: experimental/src/lombok/javac/disableCheckedExceptions/DisableCheckedExceptionsAgent.java
Patch:
@@ -52,7 +52,7 @@ public class DisableCheckedExceptionsAgent extends AbstractProcessor {
 			this.processingEnv = null;
 		}
 		
-		new LiveInjector().injectSelf();
+		new LiveInjector().inject(LiveInjector.findPathJar(DisableCheckedExceptionsAgent.class));
 	}
 	
 	/** Does nothing - we just wanted the init method so we can inject an agent. */
@@ -81,10 +81,9 @@ private static void patchExceptions(ScriptManager sm) {
 		sm.addScript(ScriptBuilder.exitEarly()
 				.target(new MethodTarget("com.sun.tools.javac.comp.Check", "isUnchecked",
 						"boolean", "com.sun.tools.javac.code.Symbol$ClassSymbol"))
-				.transplant()
 				.decisionMethod(new Hook("lombok/javac/disableCheckedExceptions/DisableCheckedExceptionsAgent", "retTrue", "()Z"))
 				.valueMethod(new Hook("lombok/javac/disableCheckedExceptions/DisableCheckedExceptionsAgent", "retTrue", "()Z"))
-				.build());
+				.insert().build());
 	}
 	
 	public static boolean retTrue() {

File: src/lombok/Lombok.java
Patch:
@@ -48,7 +48,7 @@ public class Lombok {
 	 * @return A dummy RuntimeException; this method never returns normally, it <em>always</em> throws an exception!
 	 */
 	public static RuntimeException sneakyThrow(Throwable t) {
-		if ( t == null ) throw new NullPointerException("t");
+		if (t == null) throw new NullPointerException("t");
 		Lombok.<RuntimeException>sneakyThrow0(t);
 		return null;
 	}

File: src/lombok/core/TypeLibrary.java
Patch:
@@ -47,13 +47,13 @@ public class TypeLibrary {
 	 */
 	public void addType(String fullyQualifiedTypeName) {
 		int idx = fullyQualifiedTypeName.lastIndexOf('.');
-		if ( idx == -1 ) throw new IllegalArgumentException(
+		if (idx == -1) throw new IllegalArgumentException(
 				"Only fully qualified types are allowed (and stuff in the default package is not palatable to us either!)");
 		
 		final String simpleName = fullyQualifiedTypeName.substring(idx +1);
 		final String packageName = fullyQualifiedTypeName.substring(0, idx);
 		
-		if ( simpleToQualifiedMap.put(fullyQualifiedTypeName, Collections.singleton(fullyQualifiedTypeName)) != null ) return;
+		if (simpleToQualifiedMap.put(fullyQualifiedTypeName, Collections.singleton(fullyQualifiedTypeName)) != null) return;
 		
 		addToMap(simpleName, fullyQualifiedTypeName);
 		addToMap(packageName + ".*", fullyQualifiedTypeName);

File: src/lombok/eclipse/EclipseAnnotationHandler.java
Patch:
@@ -50,5 +50,5 @@ public interface EclipseAnnotationHandler<T extends java.lang.annotation.Annotat
 	 * @return <code>true</code> if you don't want to be called again about this annotation during this
 	 * compile session (you've handled it), or <code>false</code> to indicate you aren't done yet.
 	 */
-	boolean handle(AnnotationValues<T> annotation, org.eclipse.jdt.internal.compiler.ast.Annotation ast, EclipseAST.Node annotationNode);
+	boolean handle(AnnotationValues<T> annotation, org.eclipse.jdt.internal.compiler.ast.Annotation ast, EclipseNode annotationNode);
 }

File: src/lombok/installer/AppleNativeLook.java
Patch:
@@ -36,7 +36,7 @@ public static void go() throws Exception {
 		Object app = appClass.getMethod("getApplication").invoke(null);
 		appClass.getMethod("removeAboutMenuItem").invoke(app);
 		appClass.getMethod("removePreferencesMenuItem").invoke(app);
-
+		
 		BufferedImage image = ImageIO.read(AppleNativeLook.class.getResource("lombokIcon.png"));
 		appClass.getMethod("setDockIconImage", Image.class).invoke(app, image);
 	}

File: src/lombok/javac/JavacAnnotationHandler.java
Patch:
@@ -54,5 +54,5 @@ public interface JavacAnnotationHandler<T extends Annotation> {
 	 * @return <code>true</code> if you don't want to be called again about this annotation during this
 	 * compile session (you've handled it), or <code>false</code> to indicate you aren't done yet.
 	 */
-	boolean handle(AnnotationValues<T> annotation, JCAnnotation ast, JavacAST.Node annotationNode);
+	boolean handle(AnnotationValues<T> annotation, JCAnnotation ast, JavacNode annotationNode);
 }

File: src_eclipseagent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -54,13 +54,13 @@ public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Ex
 		
 		int count = 0;
 		for (int i = 0; i < in.length; i++) {
-			if ( in[i] == null || !((Boolean)f.get(in[i])).booleanValue() ) count++;
+			if (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) count++;
 		}
 		if (count == in.length) return in;
 		SimpleName[] newSimpleNames = new SimpleName[count];
 		count = 0;
 		for (int i = 0; i < in.length; i++) {
-			if ( in[i] == null || !((Boolean)f.get(in[i])).booleanValue() ) newSimpleNames[count++] = in[i];
+			if (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) newSimpleNames[count++] = in[i];
 		}
 		return newSimpleNames;
 	}

File: src_eclipseagent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -125,7 +125,9 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea
 						
 						List<String> fullDesc = MethodTarget.decomposeFullDesc(descriptor);
 						if ("V".equals(fullDesc.get(0))) return false;
-						return fullDesc.size() == 2;
+						if (fullDesc.size() < 2) return false;
+						if (!fullDesc.get(1).startsWith("Lorg/eclipse/jdt/internal/compiler/ast/")) return false;
+						return true;
 					}
 					
 					@Override public Collection<String> getAffectedClasses() {

File: src_eclipseagent/lombok/eclipse/agent/PatchFixes.java
Patch:
@@ -23,7 +23,6 @@ public static void setIsGeneratedFlag(org.eclipse.jdt.core.dom.ASTNode domNode,
 	}
 	
 	public static void setIsGeneratedFlagForSimpleName(SimpleName name, Object internalNode) throws Exception {
-		System.out.println("Setting isGenerated on SimpleName");
 		if (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {
 			if (internalNode.getClass().getField("$generatedBy").get(internalNode) != null) {
 				name.getClass().getField("$isGenerated").set(name, true);
@@ -32,14 +31,12 @@ public static void setIsGeneratedFlagForSimpleName(SimpleName name, Object inter
 	}
 	
 	public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Exception {
-		System.out.print("Removing is generated...");
 		Field f = SimpleName.class.getField("$isGenerated");
 		
 		int count = 0;
 		for (int i = 0; i < in.length; i++) {
 			if ( in[i] == null || !((Boolean)f.get(in[i])).booleanValue() ) count++;
 		}
-		System.out.println("" + (in.length - count));
 		if (count == in.length) return in;
 		SimpleName[] newSimpleNames = new SimpleName[count];
 		count = 0;

File: src_eclipseagent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -71,7 +71,7 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea
 				.setPublic().setTransient().build());
 		
 		sm.addScript(ScriptBuilder.addField()
-				.targetClass("org.eclipse.jdt.internal.compiler.CompilationUnitDeclaration")
+				.targetClass("org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration")
 				.fieldName("$lombokAST").fieldType("Ljava/lang/Object;")
 				.setPublic().setTransient().build());
 		

File: src/lombok/javac/HandlerLibrary.java
Patch:
@@ -140,7 +140,7 @@ public void javacWarning(String message, Throwable t) {
 	
 	/** Generates an error in the Messager that was used to initialize this HandlerLibrary. */
 	public void javacError(String message) {
-		javacWarning(message, null);
+		javacError(message, null);
 	}
 	
 	/** Generates an error in the Messager that was used to initialize this HandlerLibrary. */

File: src/lombok/javac/Javac.java
Patch:
@@ -92,6 +92,7 @@ public static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<
 			List<String> raws = new ArrayList<String>();
 			List<Object> guesses = new ArrayList<Object>();
 			final List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();
+			boolean isExplicit = false;
 			
 			for ( JCExpression arg : arguments ) {
 				String mName;
@@ -107,6 +108,7 @@ public static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<
 				}
 				
 				if ( !mName.equals(name) ) continue;
+				isExplicit = true;
 				if ( rhs instanceof JCNewArray ) {
 					List<JCExpression> elems = ((JCNewArray)rhs).elems;
 					for  ( JCExpression inner : elems ) {
@@ -121,7 +123,7 @@ public static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<
 				}
 			}
 			
-			values.put(name, new AnnotationValue(node, raws, guesses) {
+			values.put(name, new AnnotationValue(node, raws, guesses, isExplicit) {
 				@Override public void setError(String message, int valueIdx) {
 					node.addError(message, positions.get(valueIdx));
 				}

File: src/lombok/AccessLevel.java
Patch:
@@ -25,5 +25,7 @@
  * Represents an AccessLevel. Used e.g. to specify the access level for generated methods and fields.
  */
 public enum AccessLevel {
-	PUBLIC, MODULE, PROTECTED, PACKAGE, PRIVATE;
+	PUBLIC, MODULE, PROTECTED, PACKAGE, PRIVATE,
+	/** Represents not generating anything or the complete lack of a method. */
+	NONE;
 }

File: src/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -77,6 +77,8 @@ public void generateGetterForField(Node fieldNode, ASTNode pos) {
 	public boolean handle(AnnotationValues<Getter> annotation, Annotation ast, Node annotationNode) {
 		Node fieldNode = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
+		if ( level == AccessLevel.NONE ) return true;
+		
 		return createGetterForField(level, fieldNode, annotationNode, annotationNode.get(), true);
 	}
 	

File: src/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -85,6 +85,8 @@ public boolean handle(AnnotationValues<Setter> annotation, Annotation ast, Node
 		Node fieldNode = annotationNode.up();
 		if ( fieldNode.getKind() != Kind.FIELD ) return false;
 		AccessLevel level = annotation.getInstance().value();
+		if ( level == AccessLevel.NONE ) return true;
+		
 		return createSetterForField(level, fieldNode, annotationNode, annotationNode.get(), true);
 	}
 	

File: src/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -79,6 +79,8 @@ public void generateGetterForField(Node fieldNode, DiagnosticPosition pos) {
 	@Override public boolean handle(AnnotationValues<Getter> annotation, JCAnnotation ast, Node annotationNode) {
 		Node fieldNode = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
+		if ( level == AccessLevel.NONE ) return true;
+		
 		return createGetterForField(level, fieldNode, annotationNode, annotationNode.get(), true);
 	}
 	

File: src/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -82,6 +82,8 @@ public void generateSetterForField(Node fieldNode, DiagnosticPosition pos) {
 	@Override public boolean handle(AnnotationValues<Setter> annotation, JCAnnotation ast, Node annotationNode) {
 		Node fieldNode = annotationNode.up();
 		AccessLevel level = annotation.getInstance().value();
+		if ( level == AccessLevel.NONE ) return true;
+		
 		return createSetterForField(level, fieldNode, annotationNode, annotationNode.get(), true);
 	}
 	

File: src/lombok/core/TransformationsUtil.java
Patch:
@@ -83,7 +83,7 @@ public static String toGetterName(CharSequence fieldName, boolean isBoolean) {
 	public static final Pattern PRIMITIVE_TYPE_NAME_PATTERN = Pattern.compile(
 			"^(boolean|byte|short|int|long|float|double|char)$");
 	
-	public static final Pattern NON_NULL_PATTERN = Pattern.compile("^no[tn]null$", Pattern.CASE_INSENSITIVE);
+	public static final Pattern NON_NULL_PATTERN = Pattern.compile("^nonnull$", Pattern.CASE_INSENSITIVE);
 	public static final Pattern NULLABLE_PATTERN = Pattern.compile("^nullable$", Pattern.CASE_INSENSITIVE);
 	
 	/**

File: src/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -158,7 +158,7 @@ private ConstructorDeclaration createConstructor(boolean isPublic, Node type, Co
 				Statement nullCheck = generateNullCheck(field);
 				if (nullCheck != null) nullChecks.add(nullCheck);
 			}
-			Annotation[] copiedAnnotations = copyAnnotations(nonNulls, nullables);
+			Annotation[] copiedAnnotations = copyAnnotations(nonNulls, nullables, p);
 			if (copiedAnnotations.length != 0) argument.annotations = copiedAnnotations;
 			args.add(argument);
 		}
@@ -205,7 +205,7 @@ private MethodDeclaration createStaticConstructor(String name, Node type, Collec
 			
 			Argument argument = new Argument(field.name, fieldPos, copyType(field.type), 0);
 			Annotation[] copiedAnnotations = copyAnnotations(
-					findAnnotations(field, TransformationsUtil.NON_NULL_PATTERN), findAnnotations(field, TransformationsUtil.NULLABLE_PATTERN));
+					findAnnotations(field, TransformationsUtil.NON_NULL_PATTERN), findAnnotations(field, TransformationsUtil.NULLABLE_PATTERN), p);
 			if (copiedAnnotations.length != 0) argument.annotations = copiedAnnotations;
 			args.add(new Argument(field.name, fieldPos, copyType(field.type), Modifier.FINAL));
 		}

File: src/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -151,7 +151,7 @@ private MethodDeclaration generateSetter(TypeDeclaration parent, FieldDeclaratio
 			if (nullCheck != null) method.statements = new Statement[] { nullCheck, assignment };
 			else method.statements = new Statement[] { assignment };
 		}
-		Annotation[] copiedAnnotations = copyAnnotations(nonNulls, nullables);
+		Annotation[] copiedAnnotations = copyAnnotations(nonNulls, nullables, pos);
 		if (copiedAnnotations.length != 0) param.annotations = copiedAnnotations;
 		return method;
 	}

File: src/lombok/eclipse/handlers/PKG.java
Patch:
@@ -241,6 +241,7 @@ static void injectMethod(EclipseAST.Node type, AbstractMethodDeclaration method)
 	
 	static Annotation[] findAnnotations(FieldDeclaration field, Pattern namePattern) {
 		List<Annotation> result = new ArrayList<Annotation>();
+		if ( field.annotations == null ) return new Annotation[0];
 		for (Annotation annotation : field.annotations) {
 			TypeReference typeRef = annotation.type;
 			if ( typeRef != null && typeRef.getTypeName()!= null ) {

File: src/lombok/core/Version.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class Version {
 	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
-	private static final String VERSION = "0.8.3";
+	private static final String VERSION = "0.8.4-HEAD";
 	
 	private Version() {
 		//Prevent instantiation

File: src/lombok/core/Version.java
Patch:
@@ -25,6 +25,7 @@
  * This class just holds lombok's current version.
  */
 public class Version {
+	// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).
 	private static final String VERSION = "0.8.2-HEAD";
 	
 	private Version() {

File: src/lombok/javac/Javac.java
Patch:
@@ -116,6 +116,9 @@ public static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<
 				@Override public void setError(String message, int valueIdx) {
 					node.addError(message, positions.get(valueIdx));
 				}
+				@Override public void setWarning(String message, int valueIdx) {
+					node.addWarning(message, positions.get(valueIdx));
+				}
 			});
 		}
 		

File: src/lombok/installer/EclipseFinder.java
Patch:
@@ -82,7 +82,7 @@ private static void loadWindowsDriveInfoLib() throws IOException {
 		} catch ( Throwable ignore ) {}
 		
 		try {
-			if ( unpackDLL("WindowsDriveInfo-x64_64.dll", dll1) ) {
+			if ( unpackDLL("WindowsDriveInfo-x86_64.dll", dll2) ) {
 				System.load(dll2.getAbsolutePath());
 			}
 		} catch ( Throwable ignore ) {}

File: src/lombok/core/AnnotationValues.java
Patch:
@@ -74,7 +74,7 @@ public AnnotationValue(AST<?>.Node node, List<String> raws, List<Object> valueGu
 		}
 		
 		/**
-		 *  Override this if you want more specific behaviour (e.g. get the source position just right).
+		 *  Override this if you want more specific behaviour (to get the source position just right).
 		 * 
 		 * @param message English message with the problem.
 		 * @param valueIdx The index into the values for this annotation key that caused the problem.

File: src/lombok/installer/EclipseFinder.java
Patch:
@@ -53,7 +53,6 @@ static File findOurJar() {
 		try {
 			URI uri = EclipseFinder.class.getResource("/" + EclipseFinder.class.getName().replace('.', '/') + ".class").toURI();
 			Pattern p = Pattern.compile("^jar:file:([^\\!]+)\\!.*\\.class$");
-			System.out.println(uri.toString());
 			Matcher m = p.matcher(uri.toString());
 			if ( !m.matches() ) return new File("lombok.jar");
 			String rawUri = m.group(1);

File: src/lombok/eclipse/handlers/HandleData.java
Patch:
@@ -258,7 +258,7 @@ private MethodDeclaration createStaticConstructor(String name, Node type, Collec
 			TypeReference[] refs = new TypeReference[typeDecl.typeParameters.length];
 			int idx = 0;
 			for ( TypeParameter param : typeDecl.typeParameters ) {
-				refs[idx++] = new SingleTypeReference(param.name, 0);
+				refs[idx++] = new SingleTypeReference(param.name, (long)param.sourceStart << 32 | param.sourceEnd);
 			}
 			constructor.returnType = new ParameterizedSingleTypeReference(typeDecl.name, refs, 0, p);
 		} else constructor.returnType = new SingleTypeReference(((TypeDeclaration)type.get()).name, p);

File: src/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -90,7 +90,7 @@ public boolean handle(AnnotationValues<Getter> annotation, Annotation ast, Node
 	private boolean createGetterForField(AccessLevel level, Node fieldNode, Node errorNode, ASTNode pos, boolean whineIfExists) {
 		if ( fieldNode.getKind() != Kind.FIELD ) {
 			errorNode.addError("@Getter is only supported on a field.");
-			return false;
+			return true;
 		}
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
@@ -106,7 +106,7 @@ private boolean createGetterForField(AccessLevel level, Node fieldNode, Node err
 		case EXISTS_BY_USER:
 			if ( whineIfExists ) errorNode.addWarning(
 					String.format("Not generating %s(): A method with that name already exists",  getterName));
-			return false;
+			return true;
 		default:
 		case NOT_EXISTS:
 			//continue with creating the getter

File: src/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -95,7 +95,7 @@ public boolean handle(AnnotationValues<Setter> annotation, Annotation ast, Node
 	private boolean createSetterForField(AccessLevel level, Node fieldNode, Node errorNode, ASTNode pos, boolean whineIfExists) {
 		if ( fieldNode.getKind() != Kind.FIELD ) {
 			errorNode.addError("@Setter is only supported on a field.");
-			return false;
+			return true;
 		}
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
@@ -110,7 +110,7 @@ private boolean createSetterForField(AccessLevel level, Node fieldNode, Node err
 			if ( whineIfExists ) errorNode.addWarning(
 					String.format("Not generating %s(%s %s): A method with that name already exists",
 					setterName, field.type, new String(field.name)));
-			return false;
+			return true;
 		default:
 		case NOT_EXISTS:
 			//continue with creating the setter
@@ -121,7 +121,7 @@ private boolean createSetterForField(AccessLevel level, Node fieldNode, Node err
 		
 		injectMethod(fieldNode.up(), method);
 		
-		return false;
+		return true;
 	}
 	
 	private MethodDeclaration generateSetter(TypeDeclaration parent, FieldDeclaration field, String name,

File: src/lombok/javac/handlers/HandleGetter.java
Patch:
@@ -91,7 +91,7 @@ public void generateGetterForField(Node fieldNode, DiagnosticPosition pos) {
 	private boolean createGetterForField(AccessLevel level, Node fieldNode, Node errorNode, DiagnosticPosition pos, boolean whineIfExists) {
 		if ( fieldNode.getKind() != Kind.FIELD ) {
 			errorNode.addError("@Getter is only supported on a field.");
-			return false;
+			return true;
 		}
 		
 		JCVariableDecl fieldDecl = (JCVariableDecl)fieldNode.get();
@@ -103,7 +103,7 @@ private boolean createGetterForField(AccessLevel level, Node fieldNode, Node err
 		case EXISTS_BY_USER:
 			if ( whineIfExists ) errorNode.addWarning(
 					String.format("Not generating %s(): A method with that name already exists",  methodName));
-			return false;
+			return true;
 		default:
 		case NOT_EXISTS:
 			//continue with creating the getter

File: src/lombok/javac/handlers/HandleSetter.java
Patch:
@@ -94,7 +94,7 @@ public void generateSetterForField(Node fieldNode, DiagnosticPosition pos) {
 	private boolean createSetterForField(AccessLevel level, Node fieldNode, Node errorNode, DiagnosticPosition pos, boolean whineIfExists) {
 		if ( fieldNode.getKind() != Kind.FIELD ) {
 			fieldNode.addError("@Setter is only supported on a field.");
-			return false;
+			return true;
 		}
 		
 		JCVariableDecl fieldDecl = (JCVariableDecl)fieldNode.get();
@@ -107,7 +107,7 @@ private boolean createSetterForField(AccessLevel level, Node fieldNode, Node err
 			if ( whineIfExists ) errorNode.addWarning(
 					String.format("Not generating %s(%s %s): A method with that name already exists",
 					methodName, fieldDecl.vartype, fieldDecl.name));
-			return false;
+			return true;
 		default:
 		case NOT_EXISTS:
 			//continue with creating the setter

File: src/lombok/SneakyThrows.java
Patch:
@@ -67,5 +67,7 @@
 @Retention(RetentionPolicy.SOURCE)
 public @interface SneakyThrows {
 	/** The exception type(s) you want to sneakily throw onward. */
-	Class<? extends Throwable>[] value() default Throwable.class;
+	Class<? extends Throwable>[] value() default java.lang.Throwable.class;
+	
+	//The package is mentioned in java.lang due to a bug in javac (presence of an annotation processor throws off the type resolver for some reason).
 }

File: src/lombok/core/SpiLoadUtil.java
Patch:
@@ -38,7 +38,7 @@
 import lombok.Lombok;
 
 /**
- * The java core libraries have a SPI discovery system, but it works only in Java 1.6 and up. For at least eclipse,
+ * The java core libraries have a SPI discovery system, but it works only in Java 1.6 and up. For at least Eclipse,
  * lombok actually works in java 1.5, so we've rolled our own SPI discovery system.
  * 
  * It is not API compatible with <code>ServiceLoader</code>.

File: src/lombok/core/TransformationsUtil.java
Patch:
@@ -23,7 +23,7 @@
 
 /**
  * Container for static utility methods useful for some of the standard lombok transformations, regardless of
- * target platform (e.g. useful for both javac and eclipse lombok implementations).
+ * target platform (e.g. useful for both javac and Eclipse lombok implementations).
  */
 public class TransformationsUtil {
 	private TransformationsUtil() {

File: src/lombok/eclipse/EclipseAST.java
Patch:
@@ -47,8 +47,8 @@
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 /**
- * Wraps around eclipse's internal AST view to add useful features as well as the ability to visit parents from children,
- * something eclipse's own AST system does not offer.
+ * Wraps around Eclipse's internal AST view to add useful features as well as the ability to visit parents from children,
+ * something Eclipse own AST system does not offer.
  */
 public class EclipseAST extends AST<ASTNode> {
 	/**
@@ -534,7 +534,7 @@ private Node drill(Statement statement) {
 		return putInMap(new Node(statement, childNodes, Kind.STATEMENT));
 	}
 	
-	/** For eclipse, only Statement counts, as Expression is a subclass of it, eventhough this isn't
+	/** For Eclipse, only Statement counts, as Expression is a subclass of it, eventhough this isn't
 	 * entirely correct according to the JLS spec (only some expressions can be used as statements, not all of them). */
 	@Override protected Collection<Class<? extends ASTNode>> getStatementTypes() {
 		return Collections.<Class<? extends ASTNode>>singleton(Statement.class);

File: src/lombok/eclipse/EclipseASTVisitor.java
Patch:
@@ -59,7 +59,7 @@ public interface EclipseASTVisitor {
 	
 	/**
 	 * Called when visiting a field of a class.
-	 * Even though in eclipse initializers (both instance and static) are represented as Initializer objects,
+	 * Even though in Eclipse initializers (both instance and static) are represented as Initializer objects,
 	 * which are a subclass of FieldDeclaration, those do NOT result in a call to this method. They result
 	 * in a call to the visitInitializer method.
 	 */
@@ -77,7 +77,7 @@ public interface EclipseASTVisitor {
 	
 	/**
 	 * Called for both methods (MethodDeclaration) and constructors (ConstructorDeclaration), but not for
-	 * Clinit objects, which are a vestigial eclipse thing that never contain anything. Static initializers
+	 * Clinit objects, which are a vestigial Eclipse thing that never contain anything. Static initializers
 	 * show up as 'Initializer', in the visitInitializer method, with modifier bit STATIC set.
 	 */
 	void visitMethod(Node methodNode, AbstractMethodDeclaration method);

File: src/lombok/eclipse/EclipseAnnotationHandler.java
Patch:
@@ -43,7 +43,7 @@ public interface EclipseAnnotationHandler<T extends java.lang.annotation.Annotat
 	 * TargetType in the annotation to methods only.
 	 * 
 	 * @param annotation The actual annotation - use this object to retrieve the annotation parameters.
-	 * @param ast The eclipse AST node representing the annotation.
+	 * @param ast The Eclipse AST node representing the annotation.
 	 * @param annotationNode The Lombok AST wrapper around the 'ast' parameter. You can use this object
 	 * to travel back up the chain (something javac AST can't do) to the parent of the annotation, as well
 	 * as access useful methods such as generating warnings or errors focused on the annotation.

File: src/lombok/installer/package-info.java
Patch:
@@ -23,6 +23,6 @@
 /**
  * This package contains the lombok installer. It explains to any user that double-clicks the lombok.jar what
  * lombok is about, and has the ability to instrument (or remove existing Lombok instrumentation) from any
- * eclipse installation. This package also contains the graphics uses in the installer in SVG format.
+ * Eclipse installation. This package also contains the graphics uses in the installer in SVG format.
  */
 package lombok.installer;

File: src/lombok/Data.java
Patch:
@@ -29,10 +29,10 @@
 /**
  * Generates getters for all fields, a useful toString method, and hashCode and equals implementations that check
  * all non-transient fields. Will also generate setters for all non-final fields, as well as a constructor.
- * 
+ * <p>
  * If any method to be generated already exists (in name - the return type or parameters are not relevant), then
  * that method will not be generated by the Data annotation.
- * 
+ * <p>
  * <code>toString</code>, <code>equals</code>, and <code>hashCode</code> use the deepX variants in the
  * <code>java.util.Arrays</code> utility class. Therefore, if your class has arrays that contain themselves,
  * these methods will just loop endlessly until the inevitable <code>StackOverflowError</code>. This behaviour

File: src/lombok/Getter.java
Patch:
@@ -44,7 +44,7 @@
  * 
  * Note that fields of type <code>boolean</code> (but not <code>java.lang.Boolean</code>) will result in an
  * <code>isFoo</code> name instead of <code>getFoo</code>.
- * 
+ * <p>
  * If any method named <code>getFoo</code>/<code>isFoo</code> exists, regardless of return type or parameters, no method is generated,
  * and instead a compiler warning is emitted.
  */

File: src/lombok/Setter.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Put on any field to make lombok build a standard setter.
- * 
+ * <p>
  * Example:
  * <pre>
  *     private @Setter int foo;

File: src/lombok/Synchronized.java
Patch:
@@ -30,7 +30,7 @@
  * Almost exactly like putting the 'synchronized' keyword on a method, except will synchronize on a private internal
  * Object, so that other code not under your control doesn't meddle with your thread management by locking on
  * your own instance.
- * 
+ * <p>
  * For non-static methods, a field named <code>$lock</code> is used, and for static methods,
  * <code>$LOCK</code> is used. These will be generated if needed and if they aren't already present. The contents
  * of the fields will be serializable.

File: src/lombok/core/AST.java
Patch:
@@ -205,9 +205,9 @@ public Collection<String> getImportStatements() {
 		protected abstract boolean calculateIsStructurallySignificant();
 		
 		/**
-		 * Convenient shortcut to the owning JavacAST object's getNodeFor method.
+		 * Convenient shortcut to the owning JavacAST object's get method.
 		 * 
-		 * @see AST#getNodeFor()
+		 * @see AST#get(Object)
 		 */
 		public Node getNodeFor(N obj) {
 			return AST.this.get(obj);

File: src/lombok/core/AnnotationValues.java
Patch:
@@ -287,7 +287,7 @@ public List<String> getRawExpressions(String annotationMethodName) {
 	}
 	
 	/**
-	 * Convenience method to return the first result in a {@link getRawExpressions(String)} call.
+	 * Convenience method to return the first result in a {@link #getRawExpressions(String)} call.
 	 * 
 	 * You should use this method if the annotation method is not an array type.
 	 */
@@ -311,7 +311,7 @@ public List<String> getProbableFQTypes(String annotationMethodName) {
 	}
 	
 	/**
-	 * Convenience method to return the first result in a {@link getProbableFQType(String)} call.
+	 * Convenience method to return the first result in a {@link #getProbableFQType(String)} call.
 	 * 
 	 * You should use this method if the annotation method is not an array type.
 	 */

File: src/lombok/eclipse/EclipseAST.java
Patch:
@@ -355,7 +355,7 @@ public Node directUp() {
 		/**
 		 * Convenient shortcut to the owning EclipseAST object's isCompleteParse method.
 		 * 
-		 * @see JavacAST#isCompleteParse()
+		 * @see EclipseAST#isCompleteParse()
 		 */
 		public boolean isCompleteParse() {
 			return completeParse;

File: src/lombok/eclipse/EclipseASTVisitor.java
Patch:
@@ -124,7 +124,7 @@ public Printer(boolean printContent) {
 		/**
 		 * @param printContent if true, method and initializer bodies are printed directly, as java code,
 		 * instead of a tree listing of every AST node inside it.
-		 * @param PrintStream write output to this stream. You must close it yourself. flush() is called after every line.
+		 * @param out write output to this stream. You must close it yourself. flush() is called after every line.
 		 * 
 		 * @see java.io.PrintStream#flush()
 		 */

File: src/lombok/installer/Installer.java
Patch:
@@ -136,7 +136,7 @@ private static void printHeadlessInfo() {
 	
 	/**
 	 * Creates a new installer that starts out invisible.
-	 * Call the {@see #show()} method on a freshly created installer to render it.
+	 * Call the {@link #show()} method on a freshly created installer to render it.
 	 */
 	public Installer() {
 		appWindow = new JFrame(String.format("Project Lombok v%s - Installer", Version.getVersion()));

File: src/lombok/javac/HandlerLibrary.java
Patch:
@@ -151,7 +151,7 @@ public void javacError(String message, Throwable t) {
 	/**
 	 * Handles the provided annotation node by first finding a qualifying instance of
 	 * {@link JavacAnnotationHandler} and if one exists, calling it with a freshly cooked up
-	 * instance of {@link AnnotationValues}.
+	 * instance of {@link lombok.core.AnnotationValues}.
 	 * 
 	 * Note that depending on the printASTOnly flag, the {@link lombok.core.PrintAST} annotation
 	 * will either be silently skipped, or everything that isn't <code>PrintAST</code> will be skipped.
@@ -203,13 +203,13 @@ public void callASTVisitors(JavacAST ast) {
 	 * random right now. This lack of order is particularly annoying for the <code>PrintAST</code> annotation,
 	 * which is almost always intended to run last. Hence, this hack, which lets it in fact run last.
 	 * 
-	 * {@see #skipAllButPrintAST}
+	 * @see #skipAllButPrintAST()
 	 */
 	public void skipPrintAST() {
 		skipPrintAST = true;
 	}
 	
-	/** {@see #skipPrintAST} */
+	/** @see #skipPrintAST() */
 	public void skipAllButPrintAST() {
 		skipPrintAST = false;
 	}

File: src/lombok/javac/JavacASTVisitor.java
Patch:
@@ -114,7 +114,7 @@ public Printer(boolean printContent) {
 		/**
 		 * @param printContent if true, method and initializer bodies are printed directly, as java code,
 		 * instead of a tree listing of every AST node inside it.
-		 * @param PrintStream write output to this stream. You must close it yourself. flush() is called after every line.
+		 * @param out write output to this stream. You must close it yourself. flush() is called after every line.
 		 * 
 		 * @see java.io.PrintStream#flush()
 		 */

File: src/lombok/core/AST.java
Patch:
@@ -156,8 +156,8 @@ public Kind getKind() {
 		 * @see #isStructurallySignificant()
 		 */
 		public Node up() {
-			Node result = (Node)parent;
-			while ( result != null && !result.isStructurallySignificant ) result = (Node)result.parent;
+			Node result = parent;
+			while ( result != null && !result.isStructurallySignificant ) result = result.parent;
 			return result;
 		}
 		

File: src/lombok/eclipse/handlers/PKG.java
Patch:
@@ -133,7 +133,7 @@ static EclipseAST.Node getExistingLombokMethod(String methodName, EclipseAST.Nod
 		
 		if ( node.get() instanceof TypeDeclaration ) {
 			for ( AbstractMethodDeclaration def : ((TypeDeclaration)node.get()).methods ) {
-				char[] mName = ((AbstractMethodDeclaration)def).selector;
+				char[] mName = def.selector;
 				if ( mName == null ) continue;
 				if ( methodName.equals(new String(mName)) ) {
 					EclipseAST.Node existing = node.getNodeFor(def);

File: src/lombok/javac/JavacAST.java
Patch:
@@ -269,9 +269,9 @@ public void traverse(JavacASTVisitor visitor) {
 				visitor.endVisitLocal(this, (JCVariableDecl)get());
 				break;
 			case STATEMENT:
-				visitor.visitStatement(this, (JCTree)get());
+				visitor.visitStatement(this, get());
 				traverseChildren(visitor, this);
-				visitor.endVisitStatement(this, (JCTree)get());
+				visitor.endVisitStatement(this, get());
 				break;
 			case ANNOTATION:
 				switch ( up().getKind() ) {

File: src/lombok/javac/handlers/HandleData.java
Patch:
@@ -43,7 +43,7 @@ public class HandleData implements JavacAnnotationHandler<Data> {
 		Node typeNode = annotationNode.up();
 		JCClassDecl typeDecl = null;
 		if ( typeNode.get() instanceof JCClassDecl ) typeDecl = (JCClassDecl)typeNode.get();
-		long flags = typeDecl.mods.flags;
+		long flags = typeDecl == null ? 0 : typeDecl.mods.flags;
 		boolean notAClass = (flags & (Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION)) != 0;
 		
 		if ( typeDecl == null || notAClass ) {

File: src/lombok/Synchronized.java
Patch:
@@ -7,4 +7,6 @@
 
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.SOURCE)
-public @interface Synchronized {}
+public @interface Synchronized {
+	String value() default "";
+}

File: src/lombok/eclipse/handlers/HandleSynchronized.java
Patch:
@@ -48,7 +48,8 @@ public class HandleSynchronized implements EclipseAnnotationHandler<Synchronized
 			return true;
 		}
 		
-		char[] lockName = method.isStatic() ? STATIC_LOCK_NAME : INSTANCE_LOCK_NAME;
+		char[] lockName = annotation.getInstance().value().toCharArray();
+		if ( lockName.length == 0 ) lockName = method.isStatic() ? STATIC_LOCK_NAME : INSTANCE_LOCK_NAME;
 		
 		if ( fieldExists(new String(lockName), methodNode) == MemberExistsResult.NOT_EXISTS ) {
 			FieldDeclaration fieldDecl = new FieldDeclaration(lockName, 0, -1);

File: src/lombok/javac/handlers/HandleSynchronized.java
Patch:
@@ -41,7 +41,8 @@ public class HandleSynchronized implements JavacAnnotationHandler<Synchronized>
 			return true;
 		}
 		boolean isStatic = (method.mods.flags & Flags.STATIC) != 0;
-		String lockName = isStatic ? STATIC_LOCK_NAME : INSTANCE_LOCK_NAME;
+		String lockName = annotation.getInstance().value();
+		if ( lockName.length() == 0 ) lockName = isStatic ? STATIC_LOCK_NAME : INSTANCE_LOCK_NAME;
 		
 		TreeMaker maker = methodNode.getTreeMaker();
 		

File: src/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -103,9 +103,8 @@ private MethodDeclaration generateSetter(TypeDeclaration parent, FieldDeclaratio
 		method.typeParameters = null;
 		method.scope = parent.scope == null ? null : new MethodScope(parent.scope, method, false);
 		method.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;
-		FieldReference thisX = new FieldReference(("this." + new String(field.name)).toCharArray(), pos);
+		FieldReference thisX = new FieldReference(field.name, pos);
 		thisX.receiver = new ThisReference(ast.sourceStart, ast.sourceEnd);
-		thisX.token = field.name;
 		Assignment assignment = new Assignment(thisX, new SingleNameReference(field.name, pos), (int)pos);
 		method.bodyStart = method.declarationSourceStart = method.sourceStart = ast.sourceStart;
 		method.bodyEnd = method.declarationSourceEnd = method.sourceEnd = ast.sourceEnd;

File: src/lombok/eclipse/handlers/HandleCleanup.java
Patch:
@@ -36,7 +36,7 @@ public boolean handle(AnnotationValues<Cleanup> annotation, Annotation ast, Node
 		LocalDeclaration decl = (LocalDeclaration)annotationNode.up().get();
 		
 		Node ancestor = annotationNode.up().directUp();
-		ASTNode blockNode = annotationNode.up().directUp().get();
+		ASTNode blockNode = ancestor.get();
 		
 		final boolean isSwitch;
 		final Statement[] statements;
@@ -69,7 +69,7 @@ public boolean handle(AnnotationValues<Cleanup> annotation, Annotation ast, Node
 			return true;
 		}
 		
-		start++;
+		start++;  //We start with try{} *AFTER* the var declaration.
 		
 		int end;
 		if ( isSwitch ) {

File: src_eclipseagent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -93,7 +93,6 @@ private static String findPathOfOurClassloader() throws Exception {
 	}
 	
 	public static void premain(String agentArgs, Instrumentation instrumentation) throws Exception {
-		System.out.println("JAVA.VERSION: " + System.getProperty("java.version", "unknown"));
 		registerPatcher(instrumentation, false);
 		addLombokToSearchPaths(instrumentation);
 	}

File: src/lombok/eclipse/TransformEclipseAST.java
Patch:
@@ -103,8 +103,11 @@ public TransformEclipseAST(EclipseAST ast) {
 	}
 	
 	public void go() {
+		handlers.skipPrintAST();
 		ast.traverse(new AnnotationVisitor());
 		handlers.callASTVisitors(ast);
+		handlers.skipAllButPrintAST();
+		ast.traverse(new AnnotationVisitor());
 	}
 	
 	private static class AnnotationVisitor extends EclipseASTAdapter {

File: src/lombok/eclipse/handlers/HandlePrintAST.java
Patch:
@@ -27,7 +27,7 @@ public class HandlePrintAST implements EclipseAnnotationHandler<PrintAST> {
 			Lombok.sneakyThrow(e);
 		}
 		
-		annotationNode.up().traverse(new EclipseASTVisitor.Printer(stream));
+		annotationNode.up().traverse(new EclipseASTVisitor.Printer(annotation.getInstance().printContent(), stream));
 		return true;
 	}
 }

File: src/lombok/javac/handlers/HandlePrintAST.java
Patch:
@@ -26,7 +26,7 @@ public class HandlePrintAST implements JavacAnnotationHandler<PrintAST> {
 			Lombok.sneakyThrow(e);
 		}
 		
-		annotationNode.up().traverse(new JavacASTVisitor.Printer(stream));
+		annotationNode.up().traverse(new JavacASTVisitor.Printer(annotation.getInstance().printContent(), stream));
 		
 		return true;
 	}

File: src/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -7,7 +7,6 @@
 import lombok.core.TransformationsUtil;
 import lombok.core.AST.Kind;
 import lombok.eclipse.Eclipse;
-import lombok.eclipse.EclipseASTVisitor;
 import lombok.eclipse.EclipseAnnotationHandler;
 import lombok.eclipse.EclipseAST.Node;
 
@@ -77,7 +76,6 @@ private boolean createGetterForField(AccessLevel level, Node fieldNode, Node err
 			//continue with creating the getter
 		}
 		
-		if ( new String(field.name).equals("a") ) fieldNode.up().traverse(new EclipseASTVisitor.Printer());
 		MethodDeclaration method = generateGetter((TypeDeclaration) fieldNode.up().get(), field, getterName, modifier, pos);
 		
 		injectMethod(fieldNode.up(), method);

File: src/lombok/javac/HandlerLibrary.java
Patch:
@@ -83,15 +83,15 @@ public void javacWarning(String message) {
 	}
 	
 	public void javacWarning(String message, Throwable t) {
-		messager.printMessage(Diagnostic.Kind.WARNING, message + t == null ? "" : (": " + t));
+		messager.printMessage(Diagnostic.Kind.WARNING, message + (t == null ? "" : (": " + t)));
 	}
 	
 	public void javacError(String message) {
 		javacWarning(message, null);
 	}
 	
 	public void javacError(String message, Throwable t) {
-		messager.printMessage(Diagnostic.Kind.ERROR, message + t == null ? "" : (": " + t));
+		messager.printMessage(Diagnostic.Kind.ERROR, message + (t == null ? "" : (": " + t)));
 	}
 	
 	private static void loadVisitorHandlers(HandlerLibrary lib) {

File: src/lombok/eclipse/handlers/HandleGetter.java
Patch:
@@ -59,7 +59,7 @@ private boolean createGetterForField(AccessLevel level, Node fieldNode, Node err
 		}
 		
 		FieldDeclaration field = (FieldDeclaration) fieldNode.get();
-		TypeReference fieldType = field.type;
+		TypeReference fieldType = Eclipse.copyType(field.type);
 		String getterName = TransformationsUtil.toGetterName(
 				new String(field.name), nameEquals(fieldType.getTypeName(), "boolean"));
 		
@@ -89,7 +89,7 @@ private MethodDeclaration generateGetter(TypeDeclaration parent, FieldDeclaratio
 			int modifier, ASTNode pos) {
 		MethodDeclaration method = new MethodDeclaration(parent.compilationResult);
 		method.modifiers = modifier;
-		method.returnType = field.type;
+		method.returnType = Eclipse.copyType(field.type);
 		method.annotations = null;
 		method.arguments = null;
 		method.selector = name.toCharArray();

File: src/lombok/eclipse/handlers/HandleSetter.java
Patch:
@@ -95,7 +95,7 @@ private MethodDeclaration generateSetter(TypeDeclaration parent, FieldDeclaratio
 		method.modifiers = modifier;
 		method.returnType = TypeReference.baseTypeReference(TypeIds.T_void, 0);
 		method.annotations = null;
-		Argument param = new Argument(field.name, pos, field.type, 0);
+		Argument param = new Argument(field.name, pos, Eclipse.copyType(field.type), 0);
 		method.arguments = new Argument[] { param };
 		method.selector = name.toCharArray();
 		method.binding = null;

File: src/lombok/core/AnnotationValues.java
Patch:
@@ -183,7 +183,7 @@ private Object guessToType(Object guess, Class<?> expected, AnnotationValue v, i
 		}
 		
 		if ( expected == String.class ) {
-			if ( guess instanceof String ) return expected;
+			if ( guess instanceof String ) return guess;
 		}
 		
 		if ( Enum.class.isAssignableFrom(expected) ) {

File: src/lombok/Getter.java
Patch:
@@ -8,7 +8,5 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.SOURCE)
 public @interface Getter {
-	lombok.AccessLevel DEFAULT_ACCESS_LEVEL = lombok.AccessLevel.PUBLIC;
-	
 	lombok.AccessLevel value() default lombok.AccessLevel.PUBLIC;
 }

File: src/lombok/Setter.java
Patch:
@@ -8,7 +8,5 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.SOURCE)
 public @interface Setter {
-	lombok.AccessLevel DEFAULT_ACCESS_LEVEL = lombok.AccessLevel.PUBLIC;
-	
 	lombok.AccessLevel value() default lombok.AccessLevel.PUBLIC;
 }

File: src/lombok/eclipse/EclipseASTVisitor.java
Patch:
@@ -122,8 +122,8 @@ private String str(TypeReference type) {
 		}
 		
 		@Override public void visitCompilationUnit(Node node, CompilationUnitDeclaration unit) {
-			System.out.println("---------------------------------------------------------");
-			System.out.println(node.isCompleteParse() ? "COMPLETE" : "incomplete");
+			out.println("---------------------------------------------------------");
+			out.println(node.isCompleteParse() ? "COMPLETE" : "incomplete");
 			
 			print("<CUD %s>", node.getFileName());
 			indent++;

File: src/lombok/Getter.java
Patch:
@@ -8,5 +8,7 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.SOURCE)
 public @interface Getter {
-	AccessLevel value() default lombok.AccessLevel.PUBLIC;
+	lombok.AccessLevel DEFAULT_ACCESS_LEVEL = lombok.AccessLevel.PUBLIC;
+	
+	lombok.AccessLevel value() default lombok.AccessLevel.PUBLIC;
 }

File: src/lombok/Setter.java
Patch:
@@ -8,5 +8,7 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.SOURCE)
 public @interface Setter {
-	AccessLevel value() default lombok.AccessLevel.PUBLIC;
+	lombok.AccessLevel DEFAULT_ACCESS_LEVEL = lombok.AccessLevel.PUBLIC;
+	
+	lombok.AccessLevel value() default lombok.AccessLevel.PUBLIC;
 }

File: src_eclipseagent/lombok/eclipse/agent/EclipsePatcher.java
Patch:
@@ -90,7 +90,7 @@ private static void registerPatcher(Instrumentation instrumentation, boolean tra
 		instrumentation.addTransformer(new Patcher(), true);
 		
 		if ( transformExisting ) for ( Class<?> c : instrumentation.getAllLoadedClasses() ) {
-			if ( c.getName().equals(ECLIPSE_PARSER_CLASS_NAME) ) {
+			if ( c.getName().equals(ECLIPSE_PARSER_CLASS_NAME) || c.getName().equals(ECLIPSE_CUD_CLASS_NAME) ) {
 				try {
 					instrumentation.retransformClasses(c);
 				} catch ( UnmodifiableClassException ex ) {

File: src/lombok/core/PrintAST.java
Patch:
@@ -7,4 +7,6 @@
 
 @Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.TYPE})
 @Retention(RetentionPolicy.SOURCE)
-public @interface PrintAST {}
+public @interface PrintAST {
+	String outfile() default "";
+}

File: src/lombok/core/AnnotationValues.java
Patch:
@@ -98,7 +98,6 @@ public A getInstance() throws AnnotationValueDecodeFail {
 				}
 				
 				if ( !isArray && v.valueGuesses.size() > 1 ) {
-					System.out.println(v.valueGuesses.size() + ": " + v.valueGuesses);
 					throw new AnnotationValueDecodeFail(v, 
 							"Expected a single value, but " + method.getName() + " has an array of values", -1);
 				}

File: src/lombok/javac/HandlerLibrary.java
Patch:
@@ -32,7 +32,6 @@
 import com.sun.tools.javac.tree.JCTree.JCLiteral;
 import com.sun.tools.javac.tree.JCTree.JCNewArray;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
-import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;
 
 
 public class HandlerLibrary {
@@ -89,12 +88,12 @@ public void handle(final JavacAST.Node node) {
 						for  ( JCExpression inner : elems ) {
 							raws.add(inner.toString());
 							guesses.add(calculateGuess(inner));
-							positions.add(new SimpleDiagnosticPosition(inner.pos));
+							positions.add(inner.pos());
 						}
 					} else {
 						raws.add(rhs.toString());
 						guesses.add(calculateGuess(rhs));
-						positions.add(new SimpleDiagnosticPosition(rhs.pos));
+						positions.add(rhs.pos());
 					}
 				}
 				

File: src/lombok/core/AST.java
Patch:
@@ -250,6 +250,7 @@ private <T extends Node> void buildWithArray(Class<T> nodeType, Object array, Co
 			Node node = buildStatement(v);
 			if ( node != null ) list.add(nodeType.cast(node));
 		} else for ( Object v : (Object[])array ) {
+			if ( v == null ) return;
 			buildWithArray(nodeType, v, list, dim-1);
 		}
 	}

File: src/lombok/javac/apt/Processor.java
Patch:
@@ -58,7 +58,7 @@ public class Processor extends AbstractProcessor {
 		
 		for ( JavacAST ast : asts ) {
 			ast.traverse(new AnnotationVisitor());
-			handlers.handleAST(ast);
+			handlers.callASTVisitors(ast);
 		}
 		return false;
 	}

File: src/lombok/javac/apt/Processor.java
Patch:
@@ -42,7 +42,6 @@ public class Processor extends AbstractProcessor {
 		for ( TypeElement annotationType : annotations ) {
 			if ( !handlers.hasHandlerFor(annotationType) ) continue;
 			for ( Element element : roundEnv.getElementsAnnotatedWith(annotationType) ) {
-				System.out.println("HIGHER PING: " + element);
 				handlers.handleAnnotation(createNode(element), annotationType);
 			}
 		}

File: src/lombok/javac/handlers/HandleGetter_javac.java
Patch:
@@ -28,7 +28,6 @@
 @ProviderFor(JavacAnnotationHandler.class)
 public class HandleGetter_javac implements JavacAnnotationHandler<Getter> {
 	@Override public void handle(JavacNode node, Getter getter) {
-		System.out.println("PING: " + node.getJavacAST());
 		if ( !node.getJavacAST().getKind().isField() ) {
 			node.addError("@Getter is only supported on a field.");
 			return;

File: src/lombok/eclipse/EclipseAnnotationHandler.java
Patch:
@@ -1,5 +1,5 @@
 package lombok.eclipse;
 
 public interface EclipseAnnotationHandler<T extends java.lang.annotation.Annotation> {
-	void handle(T annotation, org.eclipse.jdt.internal.compiler.ast.Annotation ast, EclipseAST.Node node);
+	void handle(T annotation, org.eclipse.jdt.internal.compiler.ast.Annotation ast, EclipseAST.Node annotationNode);
 }

File: src_eclipseagent/lombok/eclipse/agent/EclipseParserPatcher.java
Patch:
@@ -25,7 +25,7 @@ private static class Patcher implements ClassFileTransformer {
 			
 			if ( ECLIPSE_PARSER_CLASS_NAME.equals(className) ) {
 				try {
-					return runTransform("lombok.agent.eclipse.EclipseParserTransformer", classfileBuffer);
+					return runTransform("lombok.eclipse.agent.EclipseParserTransformer", classfileBuffer);
 				} catch ( Throwable t ) {
 					System.err.println("Wasn't able to patch eclipse's Parser class:");
 					t.printStackTrace();
@@ -34,7 +34,7 @@ private static class Patcher implements ClassFileTransformer {
 			
 			if ( ECLIPSE_CUD_CLASS_NAME.equals(className) ) {
 				try {
-					return runTransform("lombok.agent.eclipse.EclipseCUDTransformer", classfileBuffer);
+					return runTransform("lombok.eclipse.agent.EclipseCUDTransformer", classfileBuffer);
 				} catch ( Throwable t ) {
 					System.err.println("Wasn't able to patch eclipse's CompilationUnitDeclaration class:");
 					t.printStackTrace();

File: src/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -15,7 +15,6 @@
 
 import lombok.eclipse.EclipseAST.Node;
 import lombok.transformations.TypeLibrary;
-import lombok.transformations.TypeResolver;
 
 import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
 import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;

File: src/lombok/eclipse/TypeResolver.java
Patch:
@@ -1,4 +1,4 @@
-package lombok.transformations;
+package lombok.eclipse;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -7,6 +7,7 @@
 
 import lombok.eclipse.EclipseAST;
 import lombok.eclipse.EclipseAST.Node;
+import lombok.transformations.TypeLibrary;
 
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;

File: src/lombok/eclipse/HandlerLibrary.java
Patch:
@@ -102,7 +102,7 @@ private Object calculateValue(CompilationUnitDeclaration ast, Class<?> type, Exp
 			String s = null;
 			if ( e instanceof SingleNameReference ) s = new String(((SingleNameReference)e).token);
 			else if ( e instanceof QualifiedNameReference ) s = str(((QualifiedNameReference)e).tokens);
-			if ( Enum.class.isAssignableFrom(type) ) toEnum(type, s);
+			if ( Enum.class.isAssignableFrom(type) ) return toEnum(type, s);
 			throw new EnumDecodeFail("Lombok annotations must contain literals only.");
 		} else {
 			throw new EnumDecodeFail("Lombok could not decode this annotation parameter.");

File: src/lombok/Getter.java
Patch:
@@ -8,5 +8,5 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.CLASS)
 public @interface Getter {
-	AccessLevel value() default AccessLevel.PUBLIC;
+	AccessLevel value() default lombok.AccessLevel.PUBLIC;
 }

